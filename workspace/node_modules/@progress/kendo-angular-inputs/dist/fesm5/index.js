import { ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injectable, Injector, Input, NgModule, NgZone, Optional, Output, Renderer2, TemplateRef, ViewChild, ViewChildren, forwardRef, isDevMode } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { Subscription as Subscription$1 } from 'rxjs/Subscription';
import { fromEvent as fromEvent$1 } from 'rxjs/observable/fromEvent';
import { interval as interval$1 } from 'rxjs/observable/interval';
import { merge as merge$1 } from 'rxjs/observable/merge';
import { filter as filter$1 } from 'rxjs/operators/filter';
import { concatMap as concatMap$1 } from 'rxjs/operators/concatMap';
import { startWith as startWith$1 } from 'rxjs/operators/startWith';
import { takeUntil as takeUntil$1 } from 'rxjs/operators/takeUntil';
import { SliderModel, SliderUtil } from '@telerik/kendo-inputs-common';
import { __extends } from 'tslib';
import { ComponentMessages, L10N_PREFIX, LocalizationService, RTL } from '@progress/kendo-angular-l10n';
import { skip as skip$1 } from 'rxjs/operators/skip';
import { browser, mobileOS } from '@progress/kendo-common';
import { Observable as Observable$1 } from 'rxjs/Observable';
import { CldrIntlService, IntlService } from '@progress/kendo-angular-intl';
import { CommonModule } from '@angular/common';
import Draggable from '@telerik/kendo-draggable';
import { ResizeSensorModule } from '@progress/kendo-angular-resize-sensor';

var MAX_PRECISION = 20;
/**
 * @hidden
 */
var fractionLength = function (value) {
    return (String(value).split('.')[1] || "").length;
};
var maxFractionLength = function (value1, value2) {
    return Math.max(fractionLength(value1), fractionLength(value2));
};
/**
 * @hidden
 */
var toFixedPrecision = function (value, precision) {
    var maxPrecision = Math.min(precision, MAX_PRECISION);
    return parseFloat(value.toFixed(maxPrecision));
};
/**
 * @hidden
 */
var add = function (value1, value2) {
    var maxPrecision = maxFractionLength(value1, value2);
    return toFixedPrecision(value1 + value2, maxPrecision);
};
/**
 * @hidden
 */
var subtract = function (value1, value2) {
    return add(value1, -value2);
};
/**
 * @hidden
 */
var multiply = function (value1, value2) {
    var maxPrecision = fractionLength(value1) + fractionLength(value2);
    return toFixedPrecision(value1 * value2, maxPrecision);
};
/**
 * @hidden
 */
var divide = function (dividend, divisor) {
    if (divisor === 0) {
        return NaN;
    }
    var power = maxFractionLength(dividend, divisor);
    var correctionValue = Math.pow(10, power);
    return ((correctionValue * dividend) / (correctionValue * divisor));
};
/**
 * @hidden
 */
var remainder = function (dividend, divisor) {
    return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));
};

function elementOffset(element) {
    var box = element.getBoundingClientRect();
    var documentElement = document.documentElement;
    return {
        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)
    };
}
function limitValue(value, min, max) {
    return Math.max(Math.min(value, max), min);
}
/**
 * @hidden
 */
function decreaseValueToStep(value, _a, large) {
    var max = _a.max, min = _a.min, smallStep = _a.smallStep, largeStep = _a.largeStep;
    if (large === void 0) { large = false; }
    var step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    var stepValue = subtract(value, min);
    var result;
    var stepRemainder = remainder(stepValue, step);
    if (stepRemainder === 0) {
        result = subtract(stepValue, step);
    }
    else {
        result = subtract(stepValue, stepRemainder);
    }
    return limitValue(add(result, min), min, max);
}
/**
 * @hidden
 */
function increaseValueToStep(value, _a, large) {
    var max = _a.max, min = _a.min, smallStep = _a.smallStep, largeStep = _a.largeStep;
    if (large === void 0) { large = false; }
    var step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
    var stepValue = subtract(value, min);
    var stepRemainder = remainder(stepValue, step);
    var result = add(subtract(stepValue, stepRemainder), step);
    return limitValue(add(result, min), min, max);
}
/**
 * @hidden
 */
function snapValue(value, options) {
    var smallStep = options.smallStep, min = options.min, max = options.max;
    var limitted = limitValue(value, min, max);
    if (value !== limitted) {
        return limitted;
    }
    var left = decreaseValueToStep(value, options);
    var right = increaseValueToStep(value, options);
    if ((value - min) % smallStep === 0) {
        return value;
    }
    if (right - value <= (right - left) / 2) {
        return right;
    }
    return left;
}
/**
 * @hidden
 */
function eventValue(eventArgs, scaleElement, options) {
    var min = options.min, max = options.max, vertical = options.vertical, rtl = options.rtl;
    var trackOffset = elementOffset(scaleElement);
    var offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;
    var scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);
    var offsetValue = offset * scale;
    var value = rtl || vertical ? max - offsetValue : min + offsetValue;
    var stepFractionLength = fractionLength(options.smallStep);
    value = toFixedPrecision(value, stepFractionLength + 1);
    return snapValue(value, options);
}
/**
 * @hidden
 */
function isButton(element) {
    return element.className.indexOf('k-button-increase') >= 0 || element.className.indexOf('k-button-decrease') >= 0;
}
/**
 * @hidden
 */
function increment(options) {
    return increaseValueToStep(options.value, options);
}
/**
 * @hidden
 */
function decrement(options) {
    return decreaseValueToStep(options.value, options);
}
/**
 * @hidden
 */
function incrementLarge(options) {
    return increaseValueToStep(options.value, options, true);
}
/**
 * @hidden
 */
function decrementLarge(options) {
    return decreaseValueToStep(options.value, options, true);
}
/**
 * @hidden
 */
function calculateValueFromTick(index, _a) {
    var max = _a.max, min = _a.min, smallStep = _a.smallStep, reverse = _a.reverse, vertical = _a.vertical;
    var value = add(min, multiply(index, smallStep));
    return vertical || reverse ? Math.abs(subtract(value, max)) : value;
}
/**
 * @hidden
 */
function calculateTicksCount(min, max, smallStep) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 0; }
    if (smallStep === void 0) { smallStep = 1; }
    if (smallStep <= 0) {
        throw new Error("Invalid argument: smallStep must be a positive number");
    }
    return add(divide(Math.abs(subtract(max, min)), smallStep), 1);
}

/**
 * @hidden
 */
var SliderModel$1 = /** @class */ (function (_super) {
    __extends(SliderModel$$1, _super);
    function SliderModel$$1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SliderModel$$1.prototype.getTickSizes = function () {
        var _a = this.props, min = _a.min, max = _a.max, smallStep = _a.smallStep;
        var count = calculateTicksCount(min, max, smallStep);
        var trackSize = this.trackWidth();
        var distStep = trackSize / subtract(max, min);
        var result = [];
        var usedSpace = 0;
        var endPoint = 0;
        for (var i = 0; i < count; i++) {
            if (i === 0 || i === count - 1) {
                endPoint += (smallStep / 2) * distStep;
            }
            else {
                endPoint += smallStep * distStep;
            }
            var size = Math.round(endPoint - usedSpace);
            result.push(size);
            usedSpace += size;
        }
        return result;
    };
    return SliderModel$$1;
}(SliderModel));

/**
 * Represents the template for the labels of the Slider.
 * To define the labels template, nest an `<ng-template>` tag with the `kendoSliderLabelTemplate` directive inside
 * the `<kendo-slider>` tag. The template context is passed to the `label` value.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-slider [largeStep]="2">
 *           <ng-template kendoSliderLabelTemplate let-value="value">
 *             <b>{{value}}</b>
 *           </ng-template>
 *         </kendo-slider>
 *     `
 * })
 *
 * class AppComponent {
 * }
 *
 * ```
 */
var LabelTemplateDirective = /** @class */ (function () {
    function LabelTemplateDirective(templateRef) {
        this.templateRef = templateRef;
    }
    LabelTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoSliderLabelTemplate]'
                },] },
    ];
    /** @nocollapse */
    LabelTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional },] },
    ]; };
    return LabelTemplateDirective;
}());

/**
 * @hidden
 */
var Keys;
(function (Keys) {
    Keys[Keys["backspace"] = 8] = "backspace";
    Keys[Keys["tab"] = 9] = "tab";
    Keys[Keys["enter"] = 13] = "enter";
    Keys[Keys["shift"] = 16] = "shift";
    Keys[Keys["ctrl"] = 17] = "ctrl";
    Keys[Keys["alt"] = 18] = "alt";
    Keys[Keys["space"] = 32] = "space";
    Keys[Keys["page_up"] = 33] = "page_up";
    Keys[Keys["page_down"] = 34] = "page_down";
    Keys[Keys["end"] = 35] = "end";
    Keys[Keys["home"] = 36] = "home";
    Keys[Keys["left"] = 37] = "left";
    Keys[Keys["up"] = 38] = "up";
    Keys[Keys["right"] = 39] = "right";
    Keys[Keys["down"] = 40] = "down";
    Keys[Keys["delete"] = 46] = "delete";
    Keys[Keys["numpad_dot"] = 110] = "numpad_dot";
})(Keys || (Keys = {}));

/**
 * @hidden
 */
var isChanged = function (propertyName, changes, skipFirstChange) {
    if (skipFirstChange === void 0) { skipFirstChange = true; }
    return (changes[propertyName] && (!changes[propertyName].isFirstChange() || !skipFirstChange) &&
        changes[propertyName].previousValue !== changes[propertyName].currentValue);
};
/**
 * @hidden
 */
var anyChanged = function (propertyNames, changes, skipFirstChange) {
    if (skipFirstChange === void 0) { skipFirstChange = true; }
    return propertyNames.some(function (name) { return isChanged(name, changes, skipFirstChange); });
};

/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
var areSame = function (value1, value2) {
    return value1 === value2 || (value1 === null && value2 === undefined) || (value1 === undefined && value2 === null);
};
/**
 * @hidden
 */
var hasObservers = function (emitter) { return emitter.observers.length > 0; };
/**
 * @hidden
 */
var requiresZoneOnBlur = function (ngControl) { return ngControl &&
    (!ngControl.touched || (ngControl.control && ngControl.control.updateOn === 'blur')); };

/**
 * @hidden
 */

/**
 * @hidden
 */
function invokeElementMethod(element, name) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    if (element && element.nativeElement) {
        return element.nativeElement[name].apply(element.nativeElement, args);
    }
}
/**
 * @hidden
 */
function isDocumentAvailable() {
    return typeof document !== 'undefined';
}
/**
 * @hidden
 */

var w = function () { return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); };
/**
 * @hidden
 */
var guid = function () { return "" + w() + w() + "-" + w() + "-" + w() + "-" + w() + "-" + w() + w() + w(); };

var FOCUSED = 'k-state-focused';
var PRESSED = 'k-pressed';
/**
 * Represents the [Kendo UI Slider component for Angular]({% slug overview_slider %}).
 */
var SliderComponent = /** @class */ (function () {
    function SliderComponent(localizationService, injector, renderer, ngZone, hostElement) {
        var _this = this;
        this.localizationService = localizationService;
        this.injector = injector;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid();
        /**
         * Renders the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
         * When `showButtons` is set to `false`, the buttons are not displayed.
         */
        this.showButtons = true;
        /**
         * Denotes the location of the tick marks in the Slider ([see example]({% slug ticks_slider %}#toc-placement)).
         *
         * The available options are:
         * * `before`&mdash;The tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
         * * `after`&mdash;The tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
         * * `both`&mdash;The tick marks are located on both sides of the track.
         * * `none`&mdash;The tick marks are not visible. The actual elements are not added to the DOM tree.
         */
        this.tickPlacement = 'both';
        /**
         * Defines the title of the ticks ([see example]({% slug ticks_slider %}#toc-titles)). The default title
         * for each tick is its Slider value. If you use a callback function, the function accepts an argument
         * that holds the value of the component and returns a string with the new title.
         */
        this.title = SliderUtil.identity;
        /**
         * If `vertical` is set to `true`, the orientation of the Slider changes from horizontal to vertical
         * ([see example]({% slug orientation_slider %})).
         */
        this.vertical = false;
        /**
         * The minimum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.min = 0;
        /**
         * The maximum value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * The attribute accepts both integers and floating-point numbers.
         */
        this.max = 10;
        /**
         * The step value of the Slider ([see example]({% slug predefinedsteps_slider %}#toc-small-steps)).
         * Accepts positive values only. Can be an integer or a floating-point number.
         */
        this.smallStep = 1;
        /**
         * Specifies that every n<sup>th</sup> tick will be large and will have a label
         * ([see example]({% slug predefinedsteps_slider %}#toc-large-steps)).
         * Accepts positive integer values only.
         */
        this.largeStep = null;
        /**
         * Determines whether the Slider is disabled ([see example]({% slug disabledstate_slider %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Slider is in its read-only state ([see example]({% slug readonly_slider %})).
         */
        this.readonly = false;
        /**
         * The current value of the Slider when it is initially displayed.
         * The component can use either NgModel or the `value` binding but not both of them at the same time.
         */
        this.value = 0;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.handleFocus = function () {
            _this.focused = true;
            if (hasObservers(_this.onFocus)) {
                _this.ngZone.run(function () {
                    _this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = function () {
            _this.focused = false;
            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {
                _this.ngZone.run(function () {
                    _this.ngTouched();
                    _this.onBlur.emit();
                });
            }
        };
        this.subscriptions = new Subscription$1();
        /**
         * @hidden
         */
        this.onWrapClick = function (args) {
            var target = args.target;
            if (!_this.isDisabled && !(isButton(target) || isButton(target.parentNode))) {
                var value = eventValue(args, _this.track.nativeElement, _this.getProps());
                _this.changeValue(value);
            }
        };
        /**
         * @hidden
         */
        this.ifEnabled = function (callback, event) {
            if (!_this.isDisabled) {
                callback.call(_this, event);
            }
        };
        /**
         * @hidden
         */
        this.onKeyDown = function (e) {
            var options = _this.getProps();
            var max = options.max, min = options.min;
            var handler = _this.keyBinding[e.keyCode];
            if (_this.isDisabled || !handler) {
                return;
            }
            var value = handler(options);
            _this.changeValue(SliderUtil.trimValue(max, min, value));
            e.preventDefault();
        };
        this.ngChange = function (_) { };
        this.ngTouched = function () { };
        this.decreaseValue = function () {
            _this.changeValue(decreaseValueToStep(_this.value, _this.getProps()));
        };
        this.increaseValue = function () {
            _this.changeValue(increaseValueToStep(_this.value, _this.getProps()));
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(SliderComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "horizontalClass", {
        get: function () {
            return !this.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "verticalClass", {
        get: function () {
            return this.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "sliderClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "transitionsClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "widgetClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "stateDefaultClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaDisabled", {
        get: function () {
            return this.disabled ? true : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaReadonly", {
        get: function () {
            return this.readonly ? true : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaMin", {
        get: function () {
            return this.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaMax", {
        get: function () {
            return this.max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaValue", {
        get: function () {
            return this.value ? this.value : this.min;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    SliderComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    SliderComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscriptions.add(this.localizationService
            .changes
            .subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
            _this.sizeComponent(false);
        }));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    };
    /**
     * Focuses the Slider.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    SliderComponent.prototype.focus = function () {
        invokeElementMethod(this.wrapper, 'focus');
    };
    /**
     * Blurs the Slider.
     */
    SliderComponent.prototype.blur = function () {
        invokeElementMethod(this.wrapper, 'blur');
    };
    SliderComponent.prototype.ngOnChanges = function (changes) {
        if (isChanged('value', changes)) {
            this.sizeComponent(false);
        }
    };
    SliderComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.showButtons) {
            this.setValueChangeInterval(this.increaseButton.nativeElement, function () { return _this.increaseValue(); });
            this.setValueChangeInterval(this.decreaseButton.nativeElement, function () { return _this.decreaseValue(); });
        }
        this.sizeComponent(false);
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(function () { return _this.sizeComponent(false); });
        }
    };
    SliderComponent.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
    };
    Object.defineProperty(SliderComponent.prototype, "incrementMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.incrementTitle || this.localizationService.get('increment');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "decrementMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.decrementTitle || this.localizationService.get('decrement');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "dragHandleMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.dragHandleTitle || this.localizationService.get('dragHandle');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    SliderComponent.prototype.handleDragPress = function (args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        this.focus();
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.onHandleDrag = function (args) {
        this.dragging = true;
        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.onHandleRelease = function () {
        this.dragging = false; //needed for animation
    };
    //ngModel binding
    /**
     * @hidden
     */
    SliderComponent.prototype.writeValue = function (value) {
        this.value = value;
        this.sizeComponent(true);
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.changeValue = function (value) {
        var _this = this;
        if (!areSame(this.value, value)) {
            this.ngZone.run(function () {
                _this.value = value;
                _this.ngChange(value);
                _this.valueChange.emit(value);
                _this.sizeComponent(true);
            });
        }
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.sizeComponent = function (animate) {
        if (!isDocumentAvailable()) {
            return;
        }
        var wrapper = this.wrapper.nativeElement;
        var props = this.getProps();
        var model = new SliderModel$1(props, wrapper, this.track.nativeElement);
        model.resizeTrack();
        if (this.ticks) {
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(function (element) { return element.nativeElement; }));
        }
        this.handleAnimation(animate); //first time the widget is initialized the selection should not be animated
        model.positionHandle(this.draghandle.nativeElement);
        model.positionSelection(this.draghandle.nativeElement, this.sliderSelection.nativeElement);
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    };
    Object.defineProperty(SliderComponent.prototype, "reverse", {
        get: function () {
            return this.localizationService.rtl && !this.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "keyBinding", {
        get: function () {
            var reverse = this.reverse;
            return _a = {}, _a[Keys.left] = reverse ? increment : decrement, _a[Keys.right] = reverse ? decrement : increment, _a[Keys.down] = decrement, _a[Keys.up] = increment, _a[Keys.page_up] = incrementLarge, _a[Keys.page_down] = decrementLarge, _a[Keys.home] = function (_a) {
                    var min = _a.min;
                    return min;
                }, _a[Keys.end] = function (_a) {
                    var max = _a.max;
                    return max;
                }, _a;
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "focused", {
        get: function () {
            return this.isFocused;
        },
        set: function (value) {
            if (this.isFocused !== value && this.hostElement) {
                var element = this.hostElement.nativeElement;
                if (value) {
                    this.renderer.addClass(element, FOCUSED);
                }
                else {
                    this.renderer.removeClass(element, FOCUSED);
                }
                this.isFocused = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "dragging", {
        get: function () {
            return this.isDragged;
        },
        set: function (value) {
            if (this.isDragged !== value && this.sliderSelection && this.draghandle) {
                var sliderSelection = this.sliderSelection.nativeElement;
                var draghandle = this.draghandle.nativeElement;
                if (value) {
                    this.renderer.addClass(sliderSelection, PRESSED);
                    this.renderer.addClass(draghandle, PRESSED);
                }
                else {
                    this.renderer.removeClass(sliderSelection, PRESSED);
                    this.renderer.removeClass(draghandle, PRESSED);
                }
                this.isDragged = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "isDisabled", {
        get: function () {
            return this.disabled || this.readonly;
        },
        enumerable: true,
        configurable: true
    });
    SliderComponent.prototype.setValueChangeInterval = function (element, callback) {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            var mousedown = fromEvent$1(element, 'mousedown');
            var mouseup = fromEvent$1(element, 'mouseup');
            var mouseout = fromEvent$1(element, 'mouseout');
            var subscription = mousedown.pipe(filter$1(function (e) { return e.button === 0 && !_this.isDisabled; }), concatMap$1(function () {
                return interval$1(150).pipe(startWith$1(-1), takeUntil$1(merge$1(mouseup, mouseout)));
            })).subscribe(function () {
                _this.focus();
                callback();
            });
            _this.subscriptions.add(subscription);
        });
    };
    SliderComponent.prototype.handleAnimation = function (animate) {
        var transition = '';
        if (!animate) {
            transition = 'none';
        }
        this.draghandle.nativeElement.style.transition = transition;
        this.sliderSelection.nativeElement.style.transition = transition;
    };
    SliderComponent.prototype.getProps = function () {
        return {
            buttons: this.showButtons,
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            largeStep: this.largeStep,
            max: this.max,
            min: this.min,
            readonly: this.readonly,
            reverse: this.reverse,
            rtl: this.localizationService.rtl,
            smallStep: this.smallStep,
            value: SliderUtil.trimValue(this.max, this.min, this.value),
            vertical: this.vertical
        };
    };
    SliderComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoSlider',
                    providers: [
                        LocalizationService,
                        { provide: L10N_PREFIX, useValue: 'kendo.slider' },
                        { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return SliderComponent; }) } /* tslint:disable-line */
                    ],
                    selector: 'kendo-slider',
                    template: "\n        <ng-container kendoSliderLocalizedMessages\n            i18n-increment=\"kendo.slider.increment|The title of the **Increase** button of the Slider.\"\n            increment=\"increment\"\n            i18n-decrement=\"kendo.slider.decrement|The title of the **Decrease** button of the Slider.\"\n            decrement=\"decrement\"\n            i18n-dragHandle=\"kendo.slider.dragHandle|The title of the drag handle of the Slider.\"\n            dragHandle=\"Drag\"\n        >\n\n        <div class=\"k-slider-wrap\" #wrap\n            [id]=\"focusableId\"\n            [class.k-slider-buttons]=\"showButtons\"\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            [attr.tabindex]=\"(this.disabled ? undefined : tabIndex)\"\n            [kendoEventsOutsideAngular]=\"{ focus: handleFocus, blur: handleBlur, click: onWrapClick, keydown: onKeyDown }\"\n            >\n            <a\n                #decreaseButton\n                *ngIf=\"showButtons\"\n                class=\"k-button k-button-decrease\"\n                [title]=\"decrementMessage\"\n                [attr.aria-label]=\"decrementMessage\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-w]=\"!vertical\"\n                    [class.k-i-arrow-s]=\"vertical\"\n                >\n                </span>\n            </a>\n            <a\n                *ngIf=\"showButtons\"\n                #increaseButton\n                class=\"k-button k-button-increase\"\n                [title]=\"incrementMessage\"\n                [attr.aria-label]=\"incrementMessage\"\n            >\n                <span class=\"k-icon\"\n                    [class.k-i-arrow-e]=\"!vertical\"\n                    [class.k-i-arrow-n]=\"vertical\"\n                >\n                </span>\n            </a>\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [largeStep]=\"largeStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n                [labelTemplate]=\"labelTemplate?.templateRef\"\n            >\n            </ul>\n        <div #track class=\"k-slider-track\">\n            <div #sliderSelection class=\"k-slider-selection\">\n            </div>\n                <a #draghandle\n                    class=\"k-draghandle\"\n                    [title]=\"dragHandleMessage\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                >Drag</a>\n            </div>\n\n            <kendo-resize-sensor (resize)=\"sizeComponent(false)\"></kendo-resize-sensor>\n        </div>\n  "
                },] },
    ];
    /** @nocollapse */
    SliderComponent.ctorParameters = function () { return [
        { type: LocalizationService, },
        { type: Injector, },
        { type: Renderer2, },
        { type: NgZone, },
        { type: ElementRef, },
    ]; };
    SliderComponent.propDecorators = {
        'focusableId': [{ type: Input },],
        'incrementTitle': [{ type: Input },],
        'decrementTitle': [{ type: Input },],
        'showButtons': [{ type: Input },],
        'tickPlacement': [{ type: Input },],
        'title': [{ type: Input },],
        'dragHandleTitle': [{ type: Input },],
        'vertical': [{ type: Input },],
        'min': [{ type: Input },],
        'max': [{ type: Input },],
        'smallStep': [{ type: Input },],
        'largeStep': [{ type: Input },],
        'fixedTickWidth': [{ type: Input },],
        'disabled': [{ type: Input },],
        'readonly': [{ type: Input },],
        'value': [{ type: Input },],
        'tabindex': [{ type: Input },],
        'tabIndex': [{ type: Input },],
        'onFocus': [{ type: Output, args: ['focus',] },],
        'onBlur': [{ type: Output, args: ['blur',] },],
        'valueChange': [{ type: Output },],
        'wrapper': [{ type: ViewChild, args: ['wrap',] },],
        'track': [{ type: ViewChild, args: ['track',] },],
        'draghandle': [{ type: ViewChild, args: ['draghandle',] },],
        'sliderSelection': [{ type: ViewChild, args: ['sliderSelection',] },],
        'ticksContainer': [{ type: ViewChild, args: ['ticks', { read: ElementRef },] },],
        'ticks': [{ type: ViewChild, args: ['ticks',] },],
        'decreaseButton': [{ type: ViewChild, args: ['decreaseButton',] },],
        'increaseButton': [{ type: ViewChild, args: ['increaseButton',] },],
        'labelTemplate': [{ type: ContentChild, args: [LabelTemplateDirective,] },],
        'direction': [{ type: HostBinding, args: ['attr.dir',] },],
        'horizontalClass': [{ type: HostBinding, args: ['class.k-slider-horizontal',] },],
        'verticalClass': [{ type: HostBinding, args: ['class.k-slider-vertical',] },],
        'sliderClass': [{ type: HostBinding, args: ['class.k-slider',] },],
        'transitionsClass': [{ type: HostBinding, args: ['class.k-slider-transitions',] },],
        'widgetClass': [{ type: HostBinding, args: ['class.k-widget',] },],
        'stateDefaultClass': [{ type: HostBinding, args: ['class.k-state-default',] },],
        'disabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
        'ariaDisabled': [{ type: HostBinding, args: ['attr.aria-disabled',] },],
        'ariaReadonly': [{ type: HostBinding, args: ['attr.aria-readonly',] },],
        'ariaMin': [{ type: HostBinding, args: ['attr.aria-valuemin',] },],
        'ariaMax': [{ type: HostBinding, args: ['attr.aria-valuemax',] },],
        'ariaValue': [{ type: HostBinding, args: ['attr.aria-valuenow',] },],
    };
    return SliderComponent;
}());

var FOCUSED$1 = 'k-state-focused';
/**
 * Represents the [Kendo UI Switch component for Angular]({% slug overview_switch %}).
 */
var SwitchComponent = /** @class */ (function () {
    function SwitchComponent(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {
        var _this = this;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.localizationService = localizationService;
        this.injector = injector;
        this.changeDetector = changeDetector;
        this.ngZone = ngZone;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid();
        /**
         * Sets the current value of the Switch when it is initially displayed.
         */
        this.checked = false;
        /**
         * Determines whether the Switch is disabled ([see example]({% slug disabled_switch %})).
         */
        this.disabled = false;
        /**
         * Determines whether the Switch is in its read-only state ([see example]({% slug readonly_switch %})).
         */
        this.readonly = false;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.ngChange = function (_) { };
        this.ngTouched = function () { };
        /**
         * @hidden
         */
        this.handleFocus = function () {
            _this.focused = true;
            if (hasObservers(_this.onFocus)) {
                _this.ngZone.run(function () {
                    _this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = function () {
            _this.focused = false;
            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {
                _this.ngZone.run(function () {
                    _this.ngTouched();
                    _this.onBlur.emit();
                });
            }
        };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
        this.keyDownHandler = this.keyDownHandler.bind(this);
        this.clickHandler = this.clickHandler.bind(this);
    }
    Object.defineProperty(SwitchComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "ieClass", {
        get: function () {
            return browser && browser.msie;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "ariaDisabled", {
        get: function () {
            return this.disabled ? true : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "ariaReadonly", {
        get: function () {
            return this.readonly ? true : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "ariaChecked", {
        get: function () {
            return this.checked ? true : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "hostClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "switchOnClass", {
        get: function () {
            return this.checked;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "switchOffClass", {
        get: function () {
            return !this.checked;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "onLabelMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.onLabel || this.localizationService.get('on');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "offLabelMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.offLabel || this.localizationService.get('off');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchComponent.prototype, "isEnabled", {
        get: function () {
            return !this.disabled && !this.readonly;
        },
        enumerable: true,
        configurable: true
    });
    SwitchComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (this.hostElement) {
            var wrapper = this.hostElement.nativeElement;
            this.renderer.removeAttribute(wrapper, "tabindex");
        }
        this.localizationChangeSubscription = this.localizationService
            .changes
            .pipe(skip$1(1))
            .subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.control = this.injector.get(NgControl, null);
    };
    SwitchComponent.prototype.ngOnDestroy = function () {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    };
    /**
     * Focuses the Switch.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="switch.focus()">Focus</button>
     *  <kendo-switch #switch></kendo-switch>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    SwitchComponent.prototype.focus = function () {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.focus();
    };
    /**
     * Blurs the Switch.
     */
    SwitchComponent.prototype.blur = function () {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.blur();
    };
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     */
    SwitchComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        this.changeDetector.markForCheck();
    };
    /**
     * @hidden
     */
    SwitchComponent.prototype.writeValue = function (value) {
        this.checked = value === null ? false : value;
        this.changeDetector.markForCheck();
    };
    /**
     * @hidden
     */
    SwitchComponent.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    SwitchComponent.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     */
    SwitchComponent.prototype.keyDownHandler = function (e) {
        var keyCode = e.keyCode;
        if (this.isEnabled && (keyCode === Keys.space || keyCode === Keys.enter)) {
            this.changeValue(!this.checked);
            e.preventDefault();
        }
    };
    /**
     * @hidden
     */
    SwitchComponent.prototype.clickHandler = function () {
        if (this.isEnabled) {
            this.changeValue(!this.checked);
        }
    };
    SwitchComponent.prototype.changeValue = function (value) {
        var _this = this;
        if (this.checked !== value) {
            this.ngZone.run(function () {
                _this.checked = value;
                _this.ngChange(value);
                _this.valueChange.emit(value);
                _this.changeDetector.markForCheck();
            });
        }
    };
    Object.defineProperty(SwitchComponent.prototype, "focused", {
        set: function (value) {
            if (this.isFocused !== value && this.hostElement) {
                var element = this.hostElement.nativeElement;
                if (value) {
                    this.renderer.addClass(element, FOCUSED$1);
                }
                else {
                    this.renderer.removeClass(element, FOCUSED$1);
                }
                this.isFocused = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    SwitchComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoSwitch',
                    providers: [
                        LocalizationService,
                        { provide: L10N_PREFIX, useValue: 'kendo.switch' },
                        {
                            multi: true,
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return SwitchComponent; }) /* tslint:disable-line */
                        }
                    ],
                    selector: 'kendo-switch',
                    template: "\n        <ng-container kendoSwitchLocalizedMessages\n            i18n-on=\"kendo.switch.on|The **On** label of the Switch.\"\n            on=\"ON\"\n            i18n-off=\"kendo.switch.off|The **Off** label of the Switch.\"\n            off=\"OFF\"\n        >\n\n        <span\n            #wrapper\n            class=\"k-switch-container\"\n            [id]=\"focusableId\"\n            [attr.tabindex]=\"(disabled ? undefined : tabIndex)\"\n            [kendoEventsOutsideAngular]=\"{ click: clickHandler, keydown: keyDownHandler, focus: handleFocus, blur: handleBlur }\"\n        >\n            <span class=\"k-switch-label-on\">{{onLabelMessage}}</span>\n            <span class=\"k-switch-label-off\">{{offLabelMessage}}</span>\n            <span class=\"k-switch-handle\"></span>\n        </span>\n  "
                },] },
    ];
    /** @nocollapse */
    SwitchComponent.ctorParameters = function () { return [
        { type: Renderer2, },
        { type: ElementRef, },
        { type: LocalizationService, },
        { type: Injector, },
        { type: ChangeDetectorRef, },
        { type: NgZone, },
    ]; };
    SwitchComponent.propDecorators = {
        'focusableId': [{ type: Input },],
        'onLabel': [{ type: Input },],
        'offLabel': [{ type: Input },],
        'checked': [{ type: Input },],
        'disabled': [{ type: Input },],
        'readonly': [{ type: Input },],
        'tabindex': [{ type: Input },],
        'tabIndex': [{ type: Input },],
        'onFocus': [{ type: Output, args: ['focus',] },],
        'onBlur': [{ type: Output, args: ['blur',] },],
        'valueChange': [{ type: Output },],
        'wrapper': [{ type: ViewChild, args: ['wrapper',] },],
        'direction': [{ type: HostBinding, args: ['attr.dir',] },],
        'ieClass': [{ type: HostBinding, args: ['class.k-ie',] },],
        'ariaDisabled': [{ type: HostBinding, args: ['attr.aria-disabled',] },],
        'ariaReadonly': [{ type: HostBinding, args: ['attr.aria-readonly',] },],
        'ariaChecked': [{ type: HostBinding, args: ['attr.aria-checked',] },],
        'hostClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-switch',] },],
        'switchOnClass': [{ type: HostBinding, args: ['class.k-switch-on',] },],
        'switchOffClass': [{ type: HostBinding, args: ['class.k-switch-off',] },],
        'disabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
    };
    return SwitchComponent;
}());

/**
 * Represents the [Kendo UI TextBox directive]({% slug overview_textbox %}) for the Inputs components for Angular.
 * Used to style the textbox of any `input` element.
 *
 * @example
 * ```ts-no-run
 * <input kendoTextBox />
 * <input kendoTextBox type="email" />
 * <input kendoTextBox type="password" />
 * ```
 */
var TextBoxDirective = /** @class */ (function () {
    function TextBoxDirective(renderer, inputElement) {
        this.renderer = renderer;
        this.inputElement = inputElement;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        this.listeners = [];
    }
    Object.defineProperty(TextBoxDirective.prototype, "hostClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxDirective.prototype, "value", {
        /**
         * @hidden
         */
        get: function () {
            return this.inputElement.nativeElement.value;
        },
        /**
         * @hidden
         */
        set: function (text) {
            if (!this.inputElement) {
                return;
            }
            this.inputElement.nativeElement.value = (text === undefined || text === null) ? '' : text;
            this.onValueChange.emit();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxDirective.prototype, "id", {
        get: function () {
            return this.inputElement.nativeElement.id;
        },
        set: function (id) {
            this.renderer.setAttribute(this.inputElement.nativeElement, 'id', id);
        },
        enumerable: true,
        configurable: true
    });
    TextBoxDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        var input = this.inputElement.nativeElement;
        this.listeners = [
            this.renderer.listen(input, 'focus', function () { return _this.onFocus.emit(); }),
            this.renderer.listen(input, 'blur', function () { return _this.onBlur.emit(); })
        ];
    };
    TextBoxDirective.prototype.ngOnDestroy = function () {
        this.listeners.forEach(function (listener) { return listener(); });
    };
    TextBoxDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[kendoTextBox]'
                },] },
    ];
    /** @nocollapse */
    TextBoxDirective.ctorParameters = function () { return [
        { type: Renderer2, },
        { type: ElementRef, },
    ]; };
    TextBoxDirective.propDecorators = {
        'hostClass': [{ type: HostBinding, args: ['class.k-textbox',] },],
        'value': [{ type: Input },],
    };
    return TextBoxDirective;
}());

/**
 * Represents the [Kendo UI TextArea directive for the Inputs components for Angular]({% slug overview_textarea %}).
 * Provides floating labels to `textarea` elements.
 *
 * @example
 * ```ts-no-run
 * <textarea kendoTextArea></textarea>
 * ```
 */
var TextAreaDirective = /** @class */ (function () {
    function TextAreaDirective(renderer, element, zone, changeDetector, injector, rtl) {
        this.renderer = renderer;
        this.element = element;
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.injector = injector;
        /**
         * Fires each time the textarea value is changed.
         */
        this.valueChange = new EventEmitter();
        /**
         * Specifies if the `textarea` element will resize its height automatically
         * ([see example]({% slug overview_textarea %}#toc-auto-resizing)).
         *
         * @default false
         */
        this.autoSize = false;
        /**
         * @hidden
         */
        this.onFocus = new EventEmitter();
        /**
         * @hidden
         */
        this.onBlur = new EventEmitter();
        /**
         * @hidden
         */
        this.onValueChange = new EventEmitter();
        this.listeners = [];
        this.ngChange = function (_) { };
        this.ngTouched = function () { };
        this.direction = rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(TextAreaDirective.prototype, "elementClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextAreaDirective.prototype, "id", {
        get: function () {
            return this.element.nativeElement.id;
        },
        set: function (id) {
            this.renderer.setAttribute(this.element.nativeElement, 'id', id);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TextAreaDirective.prototype.writeValue = function (value) {
        this.elementValue = value;
        this.resize();
    };
    /**
     * @hidden
     */
    TextAreaDirective.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    TextAreaDirective.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     */
    TextAreaDirective.prototype.setDisabledState = function (isDisabled) {
        this.setElementProperty('disabled', isDisabled);
    };
    TextAreaDirective.prototype.ngOnInit = function () {
        var _this = this;
        var element = this.element.nativeElement;
        this.zone.runOutsideAngular(function () {
            _this.listeners = [
                _this.renderer.listen(element, 'focus', _this.handleFocus.bind(_this)),
                _this.renderer.listen(element, 'blur', _this.handleBlur.bind(_this))
            ];
            _this.inputSubscription = fromEvent$1(element, 'input')
                .subscribe(_this.handleInput.bind(_this));
        });
        this.control = this.injector.get(NgControl, null);
    };
    TextAreaDirective.prototype.ngOnChanges = function (changes) {
        var element = this.element.nativeElement;
        if (changes.value) {
            this.elementValue = this.value;
        }
        if (changes.autoSize) {
            if (this.autoSize) {
                this.initialHeight = element.offsetHeight;
                this.renderer.setStyle(element, 'resize', 'none');
            }
            else {
                this.renderer.setStyle(element, 'overflow-y', 'auto');
                this.renderer.setStyle(element, 'resize', 'both');
                element.style.height = this.initialHeight + "px";
            }
        }
        this.resize();
    };
    TextAreaDirective.prototype.ngOnDestroy = function () {
        this.listeners.forEach(function (listener) { return listener(); });
        if (this.inputSubscription) {
            this.inputSubscription.unsubscribe();
        }
    };
    Object.defineProperty(TextAreaDirective.prototype, "elementValue", {
        get: function () {
            if (this.element) {
                return this.element.nativeElement.value;
            }
            return '';
        },
        set: function (value) {
            this.setElementProperty('value', (value === undefined || value === null) ? '' : value);
        },
        enumerable: true,
        configurable: true
    });
    TextAreaDirective.prototype.setElementProperty = function (name, value) {
        if (this.element) {
            this.renderer.setProperty(this.element.nativeElement, name, value);
        }
    };
    TextAreaDirective.prototype.resize = function () {
        if (!this.autoSize) {
            return;
        }
        var element = this.element.nativeElement;
        this.renderer.setStyle(element, 'overflow-y', 'hidden');
        element.style.height = this.initialHeight + "px";
        var scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = scrollHeight + "px";
        }
    };
    TextAreaDirective.prototype.handleInput = function () {
        var _this = this;
        var value = this.elementValue;
        this.value = value;
        if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {
            this.zone.run(function () {
                _this.ngChange(value);
                _this.onValueChange.emit(value);
                _this.valueChange.emit(value);
                _this.changeDetector.markForCheck();
            });
        }
        this.resize();
    };
    TextAreaDirective.prototype.handleFocus = function () {
        var _this = this;
        if (hasObservers(this.onFocus)) {
            this.zone.run(function () {
                _this.onFocus.emit();
            });
        }
    };
    TextAreaDirective.prototype.handleBlur = function () {
        var _this = this;
        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
            this.zone.run(function () {
                _this.ngTouched();
                _this.onBlur.emit();
                _this.changeDetector.markForCheck();
            });
        }
    };
    TextAreaDirective.decorators = [
        { type: Directive, args: [{
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return TextAreaDirective; }),
                            multi: true
                        }],
                    selector: 'textarea[kendoTextArea]'
                },] },
    ];
    /** @nocollapse */
    TextAreaDirective.ctorParameters = function () { return [
        { type: Renderer2, },
        { type: ElementRef, },
        { type: NgZone, },
        { type: ChangeDetectorRef, },
        { type: Injector, },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] },] },
    ]; };
    TextAreaDirective.propDecorators = {
        'elementClass': [{ type: HostBinding, args: ['class.k-textarea',] },],
        'direction': [{ type: HostBinding, args: ['attr.dir',] },],
        'valueChange': [{ type: Output },],
        'autoSize': [{ type: Input },],
        'value': [{ type: Input },],
    };
    return TextAreaDirective;
}());

var FloatingLabelInputAdapter = /** @class */ (function () {
    function FloatingLabelInputAdapter(component, formControl) {
        this.component = component;
        var isObservableOrEventEmitter = function (event) { return event instanceof Observable$1 || event instanceof EventEmitter; };
        if (isObservableOrEventEmitter(component.onFocus)) {
            this.onFocus = component.onFocus;
        }
        if (isObservableOrEventEmitter(component.onBlur)) {
            this.onBlur = component.onBlur;
        }
        if (formControl) {
            this.onValueChange = formControl.valueChanges;
        }
        else if (component.onValueChange) {
            this.onValueChange = component.onValueChange;
        }
    }
    Object.defineProperty(FloatingLabelInputAdapter.prototype, "focusableId", {
        get: function () {
            var component = this.component;
            if ('focusableId' in component) {
                return component.focusableId;
            }
            else if ('id' in component) {
                return component.id;
            }
            return "";
        },
        set: function (value) {
            var component = this.component;
            if ('focusableId' in component) {
                component.focusableId = value;
            }
            else if ('id' in component) {
                component.id = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    return FloatingLabelInputAdapter;
}());

var isFunction = function (x) { return Object.prototype.toString.call(x) === '[object Function]'; };
/**
 * Represents the [Kendo UI TextBoxContainer component for Angular]({% slug overview_textbox %}).
 * Provides floating labels to `input` elements.
 *
 * The TextBoxContainer supports both Template and Reactive Forms and
 * [can contain either of the following components]({% slug overview_textbox %}#toc-implementing-floating-labels):
 * * Input components which include the `kendoTextBox` directive, or
 * * Form-bound Input components.
 *
 * @example
 * ```ts
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-textbox-container floatingLabel="First name">
 *       <input kendoTextBox />
 *     </kendo-textbox-container>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
var TextBoxContainerComponent = /** @class */ (function () {
    function TextBoxContainerComponent(elementRef, renderer, changeDetectorRef, rtl) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.changeDetectorRef = changeDetectorRef;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.empty = true;
        /**
         * @hidden
         */
        this.invalid = false;
        this._subscriptions = [];
        this.direction = rtl ? 'rtl' : 'ltr';
        this.renderer.removeAttribute(this.elementRef.nativeElement, "id");
    }
    Object.defineProperty(TextBoxContainerComponent.prototype, "hostClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxContainerComponent.prototype, "textareaElementClass", {
        get: function () {
            return !!this.textarea;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxContainerComponent.prototype, "focusedClass", {
        get: function () {
            return this.focused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxContainerComponent.prototype, "emptyClass", {
        get: function () {
            return this.empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextBoxContainerComponent.prototype, "invalidClass", {
        get: function () {
            return this.invalid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    TextBoxContainerComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (!this.formControl && !this.textbox && !this.textarea) {
            if (isDevMode()) {
                throw new Error("The TextBoxContainer requires an element with the kendoTextBox or kendoTextArea directive" +
                    " or a forms-bound component to function properly.");
            }
            return;
        }
        // add focus/blur/valueChange handlers
        var control = new FloatingLabelInputAdapter(this.textbox || this.textarea || this.formControl.valueAccessor, this.formControl);
        var setFocus = function (isFocused) { return function () {
            _this.focused = isFocused;
            _this.updateState();
            _this.changeDetectorRef.markForCheck();
        }; };
        this.subscribe(control, 'onFocus', setFocus(true));
        this.subscribe(control, 'onBlur', setFocus(false));
        var updateState = function () { return _this.updateState(); };
        updateState();
        this.subscribe(control, 'onValueChange', updateState);
        // set label id for floating label
        if (this.id && control.focusableId) {
            // input wins
            this.id = control.focusableId;
        }
        else if (this.id) {
            control.focusableId = this.id;
        }
        else if (control.focusableId) {
            this.id = control.focusableId;
        }
        else {
            var id = "_" + guid();
            control.focusableId = id;
            this.id = id;
        }
    };
    /**
     * @hidden
     */
    TextBoxContainerComponent.prototype.ngOnDestroy = function () {
        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
        this._subscriptions = [];
    };
    TextBoxContainerComponent.prototype.subscribe = function (control, eventName, handler) {
        if (control[eventName] instanceof EventEmitter) {
            var subscription = control[eventName].subscribe(handler);
            this._subscriptions.push(subscription);
        }
    };
    TextBoxContainerComponent.prototype.updateState = function () {
        var empty = function (value) {
            // zero is not an empty value (e.g., NumericTextBox)
            if (value === 0 || value === false) {
                return false;
            }
            // empty arrays are an empty value (e.g., MultiSelect)
            if (Array.isArray(value) && !value.length) {
                return true;
            }
            return !value;
        };
        var formControl = this.formControl;
        if (formControl) {
            var valueAccessor = formControl.valueAccessor;
            if (isFunction(valueAccessor.isEmpty)) {
                this.empty = valueAccessor.isEmpty();
            }
            else {
                this.empty = empty(formControl.value);
            }
            this.invalid = formControl.invalid && (formControl.touched || formControl.dirty);
        }
        else {
            var value = (this.textbox || this.textarea).value;
            this.empty = empty(value);
        }
        this.changeDetectorRef.markForCheck();
    };
    TextBoxContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'kendo-textbox-container',
                    template: "\n        <ng-content></ng-content>\n        <label *ngIf=\"floatingLabel\" [for]=\"id\" class=\"k-label\">{{ floatingLabel }}</label>\n    "
                },] },
    ];
    /** @nocollapse */
    TextBoxContainerComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
        { type: ChangeDetectorRef, },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] },] },
    ]; };
    TextBoxContainerComponent.propDecorators = {
        'hostClasses': [{ type: HostBinding, args: ['class.k-textbox-container',] },],
        'textareaElementClass': [{ type: HostBinding, args: ['class.k-textarea-wrapper',] },],
        'focusedClass': [{ type: HostBinding, args: ['class.k-state-focused',] },],
        'emptyClass': [{ type: HostBinding, args: ['class.k-state-empty',] },],
        'invalidClass': [{ type: HostBinding, args: ['class.k-state-invalid',] },],
        'direction': [{ type: HostBinding, args: ['attr.dir',] },],
        'id': [{ type: Input },],
        'floatingLabel': [{ type: Input },],
        'textbox': [{ type: ContentChild, args: [TextBoxDirective,] },],
        'textarea': [{ type: ContentChild, args: [TextAreaDirective,] },],
        'formControl': [{ type: ContentChild, args: [NgControl,] },],
    };
    return TextBoxContainerComponent;
}());

/**
 * @hidden
 */
var createMaxValidator = function (maxValue) {
    return function (c) {
        var err = {
            maxError: {
                maxValue: maxValue,
                value: c.value
            }
        };
        return (c.value !== null && c.value > maxValue) ? err : null;
    };
};

/**
 * @hidden
 */
var createMinValidator = function (minValue) {
    return function (c) {
        var err = {
            minError: {
                minValue: minValue,
                value: c.value
            }
        };
        return (c.value !== null && c.value < minValue) ? err : null;
    };
};

/**
 * @hidden
 */
var MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min';
/**
 * @hidden
 */
var MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max';
/**
 * @hidden
 */
var POINT = ".";
/**
 * @hidden
 */
var INITIAL_SPIN_DELAY = 500;
/**
 * @hidden
 */
var SPIN_DELAY = 50;
/**
 * @hidden
 */
var EXPONENT_REGEX = /[eE][\-+]?[0-9]+/;

/**
 * @hidden
 */
var numericRegex = function (options) {
    var autoCorrect = options.autoCorrect, decimals = options.decimals, min = options.min;
    var separator = options.separator;
    if (separator === POINT) {
        separator = '\\' + separator;
    }
    var signPattern = autoCorrect && min !== null && min >= 0 ? '' : '-?';
    var numberPattern;
    if (decimals === 0) {
        numberPattern = '\\d*';
    }
    else {
        numberPattern = "(?:(?:\\d+(" + separator + "\\d*)?)|(?:" + separator + "\\d*))?";
    }
    return new RegExp("^" + signPattern + numberPattern + "$");
};
/**
 * @hidden
 */
var decimalPart = function (value) {
    return value >= 0 ? Math.floor(value) : Math.ceil(value);
};
/**
 * @hidden
 */
var noop = function (_) { }; // tslint:disable-line:no-empty
/**
 * @hidden
 */
var defined = function (value) {
    return typeof value !== 'undefined';
};
/**
 * @hidden
 */
var isNumber = function (value) {
    return !isNaN(value) && value !== null;
};
/**
 * @hidden
 */
function pad(value, digits) {
    var count = digits - String(value).length;
    var result = value;
    if (count > 0) {
        var padString = new Array(count + 1).join("0");
        result = parseFloat(value + padString);
    }
    return result;
}
/**
 * @hidden
 */
var getDeltaFromMouseWheel = function (e) {
    var delta = 0;
    if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
    }
    else if (e.detail) {
        delta = Math.round(-e.detail / 3);
    }
    return delta;
};

/**
 * @hidden
 */
var ArrowDirection;
(function (ArrowDirection) {
    ArrowDirection[ArrowDirection["Down"] = -1] = "Down";
    ArrowDirection[ArrowDirection["None"] = 0] = "None";
    ArrowDirection[ArrowDirection["Up"] = 1] = "Up";
})(ArrowDirection || (ArrowDirection = {}));

var PARSABLE_OPTIONS = ['min', 'max', 'step', 'decimals'];
var PARSABLE_DEFAULTS = {
    decimals: null,
    max: null,
    min: null,
    step: 1
};
var FOCUSED$2 = 'k-state-focused';
var FORMATTED_VALUE = 'k-formatted-value';
/**
 * Represents the [Kendo UI NumericTextBox component for Angular]({% slug overview_numerictextbox %}).
 */
var NumericTextBoxComponent = /** @class */ (function () {
    function NumericTextBoxComponent(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {
        var _this = this;
        this.intl = intl;
        this.renderer = renderer;
        this.localizationService = localizationService;
        this.injector = injector;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid();
        /**
         * Determines whether the NumericTextBox is disabled ([see example]({% slug disabled_numerictextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the NumericTextBox is in its read-only state ([see example]({% slug readonly_numerictextbox %})).
         */
        this.readonly = false;
        /**
         * Sets the title of the `input` element of the NumericTextBox.
         */
        this.title = '';
        /**
         * Specifies whether the value will be auto-corrected based on the minimum and maximum values
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.autoCorrect = false;
        /**
         * Specifies the number of decimals that the user can enter when the input is focused
         * ([see example]({% slug precision_numerictextbox %})).
         */
        this.decimals = null;
        /**
         * Specifies the value that is used to increment or decrement the component value
         * ([see example]({% slug predefinedsteps_numerictextbox %})).
         */
        this.step = 1;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered
         * ([see example]({% slug spinbuttons_numerictextbox %})).
         */
        this.spinners = true;
        /**
         * Determines whether the built-in minimum or maximum validators are enforced when a form is validated.
         *
         * > The 4.2.0 Angular version introduces the `min` and `max` validation directives. As a result, even if you set `rangeValidation`
         * to `false`, the built-in Angular validators will be executed.
         */
        this.rangeValidation = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Specifies the value of the NumericTextBox
         * ([see example]({% slug formats_numerictextbox %})).
         */
        this.value = null;
        /**
         * Fires each time the user selects a new value ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.valueChange = new EventEmitter();
        /**
         * Fires each time the user focuses the `input` element ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred ([see example]({% slug overview_numerictextbox %}#toc-events)).
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * @hidden
         */
        this.ArrowDirection = ArrowDirection;
        /**
         * @hidden
         */
        this.arrowDirection = ArrowDirection.None;
        this.inputValue = '';
        this.minValidateFn = noop;
        this.maxValidateFn = noop;
        this._format = "n2";
        /**
         * @hidden
         */
        this.increasePress = function (e) {
            _this.arrowPress(ArrowDirection.Up, e);
        };
        /**
         * @hidden
         */
        this.decreasePress = function (e) {
            _this.arrowPress(ArrowDirection.Down, e);
        };
        /**
         * @hidden
         */
        this.releaseArrow = function () {
            clearTimeout(_this.spinTimeout);
            if (_this.arrowDirection !== ArrowDirection.None) {
                _this.arrowDirection = ArrowDirection.None;
                _this.changeDetector.detectChanges();
            }
        };
        /**
         * @hidden
         */
        this.handleInput = function () {
            var input = _this.numericInput.nativeElement;
            var selectionStart = input.selectionStart, selectionEnd = input.selectionEnd, inputValue = input.value;
            if (_this.pressedKey === Keys.numpad_dot) {
                inputValue = _this.replaceNumpadDotValue();
            }
            if (!_this.isValid(inputValue)) {
                input.value = _this.inputValue;
                _this.setSelection(selectionStart - 1, selectionEnd - 1);
                return;
            }
            var parsedValue = _this.intl.parseNumber(inputValue);
            var value = _this.restrictDecimals(parsedValue);
            if (_this.autoCorrect) {
                var limited = _this.limitInputValue(value);
                value = limited.value;
                selectionStart = limited.selectionStart;
                selectionEnd = limited.selectionEnd;
            }
            if (parsedValue !== value || _this.hasTrailingZeros(inputValue) || !_this.focused) {
                _this.setInputValue(value);
                _this.setSelection(selectionStart, selectionEnd);
            }
            else {
                _this.inputValue = inputValue;
            }
            _this.updateValue(value);
            _this.previousSelection = null;
        };
        /**
         * @hidden
         */
        this.handleDragEnter = function () {
            if (!_this.focused && !_this.isDisabled) {
                _this.setInputValue(_this.value, true);
            }
        };
        /**
         * @hidden
         */
        this.handleFocus = function () {
            if (!_this.focused) {
                _this.focused = true;
                if (!_this.isDisabled) {
                    _this.setInputValue();
                    _this.ngZone.runOutsideAngular(function () {
                        setTimeout(function () {
                            _this.setSelection(0, _this.inputValue.length);
                        }, 0); /* tslint:disable-line  align */
                    });
                }
            }
            if (hasObservers(_this.onFocus)) {
                _this.ngZone.run(function () {
                    _this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = function () {
            _this.focused = false;
            //blur is thrown before input when dragging the input text in IE
            if (_this.inputValue !== _this.elementValue) {
                _this.handleInput();
            }
            _this.setInputValue();
            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {
                _this.ngZone.run(function () {
                    _this.ngTouched();
                    _this.onBlur.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleKeyDown = function (e) {
            if (_this.isDisabled) {
                return;
            }
            var step;
            if (e.keyCode === Keys.down) {
                step = -1;
            }
            else if (e.keyCode === Keys.up) {
                step = 1;
            }
            if (step && _this.step) {
                e.preventDefault();
                _this.addStep(step);
            }
            var input = _this.numericInput.nativeElement;
            _this.previousSelection = {
                end: input.selectionEnd,
                start: input.selectionStart
            };
            _this.pressedKey = e.keyCode;
        };
        /**
         * @hidden
         */
        this.handleWheel = function (e) {
            if (_this.focused && !_this.isDisabled) {
                e.preventDefault();
                var delta = getDeltaFromMouseWheel(e);
                _this.addStep(delta);
            }
        };
        //TODO: disable tslint and move those to the constructor level
        this.ngChange = function (_) { };
        this.ngTouched = function () { };
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    Object.defineProperty(NumericTextBoxComponent.prototype, "format", {
        /**
         * Specifies the number format which is used when the NumericTextBox is not focused
         * ([see example]({% slug formats_numerictextbox %})).
         * If `format` is set to `null` or `undefined`, the default format will be used.
         */
        get: function () {
            var format = this._format;
            return format !== null && format !== undefined ? format : 'n2';
        },
        set: function (value) {
            this._format = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "widgetClasses", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    NumericTextBoxComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscriptions = this.localizationService
            .changes
            .subscribe(function (_a) {
            var rtl = _a.rtl;
            _this.direction = rtl ? 'rtl' : 'ltr';
        });
        this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    };
    /**
     * @hidden
     */
    NumericTextBoxComponent.prototype.ngOnChanges = function (changes) {
        if (anyChanged(PARSABLE_OPTIONS, changes, false)) {
            this.parseOptions(PARSABLE_OPTIONS.filter(function (option) { return changes[option]; }));
        }
        this.verifySettings();
        if (anyChanged(['min', 'max', 'rangeValidation'], changes, false)) {
            this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop;
            this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop;
        }
        if (anyChanged(['autoCorrect', 'decimals', 'min'], changes)) {
            delete this.numericRegex;
        }
        if (anyChanged(['value', 'format'], changes, false)) {
            this.verifyValue(this.value);
            this.value = this.restrictModelValue(this.value);
            if (!this.focused || (this.intl.parseNumber(this.elementValue) !== this.value)) {
                this.setInputValue();
            }
        }
    };
    /**
     * @hidden
     */
    NumericTextBoxComponent.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        clearTimeout(this.spinTimeout);
    };
    /**
     * @hidden
     */
    NumericTextBoxComponent.prototype.validate = function (control) {
        return this.minValidateFn(control) || this.maxValidateFn(control);
    };
    /**
     * @hidden
     */
    NumericTextBoxComponent.prototype.writeValue = function (value) {
        this.verifyValue(value);
        var restrictedValue = this.restrictModelValue(value);
        this.value = restrictedValue;
        this.setInputValue();
    };
    /**
     * @hidden
     */
    NumericTextBoxComponent.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    NumericTextBoxComponent.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    NumericTextBoxComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * Focuses the NumericTextBox.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="numerictextbox.focus()">Focus NumericTextBox</button>
     *  <kendo-numerictextbox #numerictextbox></kendo-numerictextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    NumericTextBoxComponent.prototype.focus = function () {
        invokeElementMethod(this.numericInput, 'focus');
    };
    /**
     * Blurs the NumericTextBox.
     */
    NumericTextBoxComponent.prototype.blur = function () {
        invokeElementMethod(this.numericInput, 'blur');
    };
    /**
     * Notifies the `NumericTextBoxComponent` that the input value should be changed.
     * Can be used to update the input after setting the component properties directly.
     */
    NumericTextBoxComponent.prototype.notifyValueChange = function () {
        this.setInputValue();
    };
    Object.defineProperty(NumericTextBoxComponent.prototype, "incrementTitle", {
        /**
         * @hidden
         */
        get: function () {
            return this.localizationService.get('increment');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "decrementTitle", {
        /**
         * @hidden
         */
        get: function () {
            return this.localizationService.get('decrement');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "decimalSeparator", {
        get: function () {
            var numberSymbols = this.intl.numberSymbols();
            return numberSymbols.decimal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "elementValue", {
        get: function () {
            return this.numericInput.nativeElement.value;
        },
        set: function (value) {
            this.renderer.setProperty(this.numericInput.nativeElement, 'value', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "focused", {
        get: function () {
            return this.isFocused;
        },
        set: function (value) {
            if (this.isFocused !== value && this.numericWrap) {
                var wrap = this.numericWrap.nativeElement;
                var input = this.numericInput.nativeElement;
                if (value) {
                    this.renderer.addClass(wrap, FOCUSED$2);
                    if (!this.isDisabled) {
                        this.renderer.removeClass(input, FORMATTED_VALUE);
                    }
                }
                else {
                    this.renderer.removeClass(wrap, FOCUSED$2);
                    this.renderer.addClass(input, FORMATTED_VALUE);
                }
                this.isFocused = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "hasDecimals", {
        get: function () {
            return this.decimals !== null && this.decimals >= 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumericTextBoxComponent.prototype, "isDisabled", {
        get: function () {
            return this.disabled || this.readonly;
        },
        enumerable: true,
        configurable: true
    });
    NumericTextBoxComponent.prototype.arrowPress = function (direction, e) {
        e.preventDefault();
        if (this.isDisabled) {
            return;
        }
        if (!mobileOS) {
            this.focused = true;
            this.focus();
        }
        if (this.arrowDirection !== direction) {
            this.arrowDirection = direction;
            this.changeDetector.detectChanges();
        }
        if (this.step) {
            this.spin(direction, INITIAL_SPIN_DELAY);
        }
        else {
            this.setInputValue();
        }
    };
    NumericTextBoxComponent.prototype.updateValue = function (value) {
        var _this = this;
        if (!areSame(this.value, value)) {
            this.ngZone.run(function () {
                _this.value = value;
                _this.ngChange(value);
                _this.valueChange.emit(value);
                _this.changeDetector.markForCheck();
            });
        }
    };
    NumericTextBoxComponent.prototype.replaceNumpadDotValue = function () {
        var value = this.inputValue || "";
        if (this.previousSelection) {
            var input = this.numericInput.nativeElement;
            var selectionStart = input.selectionStart, selectionEnd = input.selectionEnd;
            var _a = this.previousSelection, start = _a.start, end = _a.end;
            input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);
            this.setSelection(selectionStart, selectionEnd);
        }
        return value;
    };
    NumericTextBoxComponent.prototype.isValid = function (value) {
        if (!this.numericRegex) {
            this.numericRegex = numericRegex({
                autoCorrect: this.autoCorrect,
                decimals: this.decimals,
                min: this.min,
                separator: this.decimalSeparator
            });
        }
        return this.numericRegex.test(value);
    };
    NumericTextBoxComponent.prototype.spin = function (step, timeout) {
        var _this = this;
        clearTimeout(this.spinTimeout);
        this.spinTimeout = window.setTimeout(function () {
            _this.spin(step, SPIN_DELAY);
        }, timeout); /* tslint:disable-line  align */
        this.addStep(step);
    };
    NumericTextBoxComponent.prototype.addStep = function (step) {
        var value = add(this.value || 0, this.step * step);
        value = this.limitValue(value);
        value = this.restrictDecimals(value);
        this.setInputValue(value);
        this.updateValue(value);
    };
    NumericTextBoxComponent.prototype.setSelection = function (start, end) {
        if (this.focused) {
            invokeElementMethod(this.numericInput, 'setSelectionRange', start, end);
        }
    };
    NumericTextBoxComponent.prototype.limitValue = function (value) {
        var result = value;
        if (!this.isInRange(value)) {
            if (isNumber(this.max) && value > this.max) {
                result = this.max;
            }
            if (isNumber(this.min) && value < this.min) {
                result = this.min;
            }
        }
        return result;
    };
    NumericTextBoxComponent.prototype.limitInputValue = function (value) {
        var _a = this.numericInput.nativeElement, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd, enteredValue = _a.value;
        var limitedValue = value;
        var selectToEnd = false;
        if (!this.isInRange(value)) {
            var lengthChange = enteredValue.length - String(this.inputValue).length;
            var _b = this, min = _b.min, max = _b.max;
            var hasMax = isNumber(max);
            var hasMin = isNumber(min);
            var padLimit = void 0, replaceNext = void 0;
            var correctedValue = value;
            if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {
                return {
                    selectionEnd: selectionEnd,
                    selectionStart: selectionStart,
                    value: null
                };
            }
            if (hasMax && value > max) {
                if (value > 0) {
                    replaceNext = true;
                }
                else {
                    padLimit = max;
                }
            }
            else if (hasMin && value < min) {
                if (value > 0) {
                    padLimit = min;
                }
                else {
                    replaceNext = true;
                }
            }
            if (padLimit) {
                var paddedValue = this.tryPadValue(value, padLimit);
                if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {
                    correctedValue = paddedValue;
                    selectToEnd = true;
                }
            }
            else if (replaceNext) {
                if (this.inputValue && selectionStart !== enteredValue.length) {
                    correctedValue = parseFloat(enteredValue.substr(0, selectionStart) +
                        enteredValue.substr(selectionStart + lengthChange));
                }
            }
            limitedValue = this.limitValue(correctedValue);
            selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection &&
                (this.previousSelection.end - this.previousSelection.start + lengthChange) > 0;
        }
        return {
            selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,
            selectionStart: selectionStart,
            value: limitedValue
        };
    };
    NumericTextBoxComponent.prototype.tryPadValue = function (value, limit) {
        var limitLength = String(Math.floor(limit)).length;
        var zeroPadded = pad(value, limitLength);
        var zeroPaddedNext = pad(value, limitLength + 1);
        var result;
        if (this.isInRange(zeroPadded)) {
            result = zeroPadded;
        }
        else if (this.isInRange(zeroPaddedNext)) {
            result = zeroPaddedNext;
        }
        return result;
    };
    NumericTextBoxComponent.prototype.isInRange = function (value) {
        return !isNumber(value) || ((!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max));
    };
    NumericTextBoxComponent.prototype.restrictModelValue = function (value) {
        var result = this.restrictDecimals(value, true);
        if (this.autoCorrect && this.limitValue(result) !== result) {
            result = null;
        }
        return result;
    };
    NumericTextBoxComponent.prototype.restrictDecimals = function (value, round) {
        var result = value;
        if (value && this.hasDecimals) {
            var decimals = this.decimals;
            var stringValue = String(value);
            if (round || EXPONENT_REGEX.test(stringValue)) {
                result = toFixedPrecision(value, decimals);
            }
            else {
                var parts = stringValue.split(POINT);
                var fraction = parts[1];
                if (fraction && fraction.length > decimals) {
                    fraction = fraction.substr(0, decimals);
                    result = parseFloat("" + parts[0] + POINT + fraction);
                }
            }
        }
        return result;
    };
    NumericTextBoxComponent.prototype.formatInputValue = function (value) {
        return String(value).replace(POINT, this.decimalSeparator);
    };
    NumericTextBoxComponent.prototype.formatValue = function (value, focused) {
        var formattedValue;
        if (value === null || !defined(value) || value === '') {
            formattedValue = '';
        }
        else if (focused && !this.readonly) {
            formattedValue = this.formatInputValue(value);
        }
        else {
            formattedValue = this.intl.formatNumber(value, this.format);
        }
        return formattedValue;
    };
    NumericTextBoxComponent.prototype.setInputValue = function (value, focused) {
        if (value === void 0) { value = this.value; }
        if (focused === void 0) { focused = this.focused; }
        var formattedValue = this.formatValue(value, focused);
        this.elementValue = formattedValue;
        this.inputValue = formattedValue;
    };
    NumericTextBoxComponent.prototype.verifySettings = function () {
        if (!isDevMode()) {
            return;
        }
        if (this.min !== null && this.max !== null && this.min > this.max) {
            throw new Error("The max value should be bigger than the min. See " + MIN_DOC_LINK + " and " + MAX_DOC_LINK + ".");
        }
    };
    NumericTextBoxComponent.prototype.verifyValue = function (value) {
        if (isDevMode() && value && typeof value !== 'number') {
            throw new Error("The NumericTextBox component requires value of type Number and " + JSON.stringify(value) + " was set.");
        }
    };
    NumericTextBoxComponent.prototype.parseOptions = function (options) {
        for (var idx = 0; idx < options.length; idx++) {
            var name_1 = options[idx];
            var value = this[name_1];
            if (typeof value === 'string') {
                var parsed = parseFloat(value);
                var valid = !isNaN(parsed);
                if (isDevMode() && !valid && value !== '') {
                    throw new Error('The NumericTextBox component requires value of type Number or a String representing ' +
                        ("a number for the " + name_1 + " property and " + JSON.stringify(value) + " was set."));
                }
                this[name_1] = valid ? parsed : PARSABLE_DEFAULTS[name_1];
            }
        }
    };
    NumericTextBoxComponent.prototype.intlChange = function () {
        delete this.numericRegex;
        if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {
            this.setInputValue();
        }
    };
    NumericTextBoxComponent.prototype.hasTrailingZeros = function (inputValue) {
        if (this.hasDecimals && this.focused) {
            var fraction = inputValue.split(this.decimalSeparator)[1];
            return fraction && fraction.length > this.decimals && fraction.lastIndexOf('0') === fraction.length - 1;
        }
    };
    NumericTextBoxComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoNumericTextBox',
                    providers: [
                        LocalizationService,
                        { provide: L10N_PREFIX, useValue: 'kendo.numerictextbox' },
                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return NumericTextBoxComponent; }), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return NumericTextBoxComponent; }), multi: true } /* tslint:disable-line */
                    ],
                    selector: 'kendo-numerictextbox',
                    template: "\n        <ng-container kendoNumericTextBoxLocalizedMessages\n            i18n-increment=\"kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox\"\n            increment=\"Increase value\"\n            i18n-decrement=\"kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox\"\n            decrement=\"Decrease value\"\n        >\n        </ng-container>\n        <span\n            class=\"k-numeric-wrap\"\n            [class.k-state-disabled]=\"disabled\"\n            [kendoEventsOutsideAngular]=\"{ mousewheel: handleWheel, DOMMouseScroll: handleWheel }\"\n            #numericWrap>\n            <input\n            role=\"spinbutton\"\n            class=\"k-input k-formatted-value\"\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            [id]=\"focusableId\"\n            [attr.aria-valuemin]=\"min\"\n            [attr.aria-valuemax]=\"max\"\n            [attr.aria-valuenow]=\"value\"\n            [attr.title]=\"title\"\n            [attr.placeholder]=\"placeholder\"\n            [tabindex]=\"tabIndex\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [kendoEventsOutsideAngular]=\"{\n                dragenter: handleDragEnter,\n                keydown: handleKeyDown,\n                input: handleInput,\n                focus: handleFocus,\n                blur: handleBlur\n            }\"\n            #numericInput />\n            <span class=\"k-select\" *ngIf=\"spinners\" [kendoEventsOutsideAngular]=\"{ mouseup: releaseArrow, mouseleave: releaseArrow }\">\n                <span\n                    [kendoEventsOutsideAngular]=\"{ mousedown: increasePress }\"\n                    [attr.aria-label]=\"incrementTitle\"\n                    [title]=\"incrementTitle\"\n                    [class.k-state-active]=\"arrowDirection === ArrowDirection.Up\"\n                    class=\"k-link k-link-increase\"\n                >\n                    <span class=\"k-icon k-i-arrow-n\"></span>\n                </span>\n                <span\n                    [kendoEventsOutsideAngular]=\"{ mousedown: decreasePress }\"\n                    [attr.aria-label]=\"decrementTitle\"\n                    [title]=\"decrementTitle\"\n                    [class.k-state-active]=\"arrowDirection === ArrowDirection.Down\"\n                    class=\"k-link k-link-decrease\"\n                >\n                    <span class=\"k-icon k-i-arrow-s\"></span>\n                </span>\n            </span>\n        </span>\n      "
                },] },
    ];
    /** @nocollapse */
    NumericTextBoxComponent.ctorParameters = function () { return [
        { type: IntlService, },
        { type: Renderer2, },
        { type: LocalizationService, },
        { type: Injector, },
        { type: NgZone, },
        { type: ChangeDetectorRef, },
        { type: ElementRef, },
    ]; };
    NumericTextBoxComponent.propDecorators = {
        'focusableId': [{ type: Input },],
        'disabled': [{ type: Input },],
        'readonly': [{ type: Input },],
        'title': [{ type: Input },],
        'autoCorrect': [{ type: Input },],
        'format': [{ type: Input },],
        'max': [{ type: Input },],
        'min': [{ type: Input },],
        'decimals': [{ type: Input },],
        'placeholder': [{ type: Input },],
        'step': [{ type: Input },],
        'spinners': [{ type: Input },],
        'rangeValidation': [{ type: Input },],
        'tabindex': [{ type: Input },],
        'tabIndex': [{ type: Input },],
        'value': [{ type: Input },],
        'valueChange': [{ type: Output },],
        'onFocus': [{ type: Output, args: ['focus',] },],
        'onBlur': [{ type: Output, args: ['blur',] },],
        'numericInput': [{ type: ViewChild, args: ['numericInput',] },],
        'numericWrap': [{ type: ViewChild, args: ['numericWrap',] },],
        'direction': [{ type: HostBinding, args: ['attr.dir',] },],
        'widgetClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-numerictextbox',] },],
    };
    return NumericTextBoxComponent;
}());

/**
 * @hidden
 */
var Messages = /** @class */ (function (_super) {
    __extends(Messages, _super);
    function Messages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Messages.propDecorators = {
        'decrement': [{ type: Input },],
        'increment': [{ type: Input },],
    };
    return Messages;
}(ComponentMessages));

/**
 * Custom component messages override default component messages.
 */
var NumericTextBoxCustomMessagesComponent = /** @class */ (function (_super) {
    __extends(NumericTextBoxCustomMessagesComponent, _super);
    function NumericTextBoxCustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    Object.defineProperty(NumericTextBoxCustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    NumericTextBoxCustomMessagesComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(function () { return NumericTextBoxCustomMessagesComponent; }) // tslint:disable-line:no-forward-ref
                        }
                    ],
                    selector: 'kendo-numerictextbox-messages',
                    template: ""
                },] },
    ];
    /** @nocollapse */
    NumericTextBoxCustomMessagesComponent.ctorParameters = function () { return [
        { type: LocalizationService, },
    ]; };
    return NumericTextBoxCustomMessagesComponent;
}(Messages));

/**
 * @hidden
 */
var ResultType;
(function (ResultType) {
    ResultType[ResultType["Literal"] = 0] = "Literal";
    ResultType[ResultType["Mask"] = 1] = "Mask";
    ResultType[ResultType["Undefined"] = 2] = "Undefined";
})(ResultType || (ResultType = {}));
/**
 * @hidden
 */
var Result = /** @class */ (function () {
    function Result(value, rest, type) {
        if (type === void 0) { type = ResultType.Undefined; }
        this.value = value;
        this.rest = rest;
        this.type = type;
    }
    //map :: Functor f => f a ~> (a -> b) -> f b
    Result.prototype.map = function (fn) {
        return new Result(fn(this.value), this.rest);
    };
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    Result.prototype.chain = function (fn) {
        return fn(this.value, this.rest);
    };
    Result.prototype.fold = function (s, _ /*we don't need it*/) {
        return s(this.value, this.rest);
    };
    Result.prototype.concat = function (r) {
        return this.map(function (vs, _) { return r.chain(function (v, __) { return vs.concat([v]); }); });
    };
    Result.prototype.toString = function () {
        return "Result({ value: '" + this.value + "', rest: " + this.rest + " })";
    };
    return Result;
}());

/**
 * @hidden
 */
var Stream = /** @class */ (function () {
    function Stream(input, control) {
        if (input === void 0) { input = []; }
        if (control === void 0) { control = []; }
        this.input = input;
        this.control = control;
        this.inputCursor = 0;
        this.controlCursor = 0;
    }
    Stream.prototype.eof = function () {
        return this.inputCursor >= this.input.length;
    };
    // Get the first value from the input.
    Stream.prototype.next = function () {
        return {
            char: this.input[this.inputCursor++],
            control: this.control[this.controlCursor++]
        };
    };
    Stream.prototype.peek = function () {
        return {
            char: this.input[this.inputCursor],
            control: this.control[this.controlCursor]
        };
    };
    Stream.prototype.eat_input = function () {
        this.inputCursor++;
    };
    Stream.prototype.eat_control = function () {
        this.controlCursor++;
    };
    Stream.prototype.eat = function () {
        this.inputCursor++;
        this.controlCursor++;
    };
    return Stream;
}());

var toArray = function (value) { return (value || '').split(''); };
var ESCAPE_CHARACTER = '\\';
/**
 * @hidden
 */
var Parser = /** @class */ (function () {
    function Parser(parse) {
        this.parse = parse;
    }
    Parser.prototype.run = function (input, control) {
        if (control === void 0) { control = ''; }
        if (input instanceof Stream) {
            return this.parse(input);
        }
        else {
            return this.parse(new Stream(toArray(input), toArray(control)));
        }
    };
    //map :: Functor f => f a ~> (a -> b) -> f b
    Parser.prototype.map = function (f) {
        var _this = this;
        return new Parser(function (stream) { return _this.parse(stream).map(f); });
    };
    //chain :: Chain m => m a ~> (a -> m b) -> m b
    Parser.prototype.chain = function (f) {
        var _this = this;
        return new Parser(function (stream) { return _this.parse(stream).chain(function (v, s) { return f(v).run(s); }); });
    };
    Parser.prototype.isLiteral = function (c) {
        return this.run(c).type === ResultType.Literal;
    };
    return Parser;
}());
/**
 * @hidden
 */
var mask = function (_a) {
    var prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;
    return function (rule) { return new Parser(function (stream) {
        while (!stream.eof()) {
            var _a = stream.peek(), char = _a.char, control = _a.control;
            if (char === control && control === prompt) {
                stream.eat();
                return new Result(prompt, stream, ResultType.Mask);
            }
            if (rule.test(char)) {
                stream.eat();
                return new Result(char, stream, ResultType.Mask);
            }
            if (char === promptPlaceholder) {
                stream.eat();
                return new Result(prompt, stream, ResultType.Mask);
            }
            stream.eat_input();
        }
        stream.eat();
        return new Result(prompt, stream, ResultType.Mask);
    }); };
};
/**
 * @hidden
 */
var literal = function (_token) { return new Parser(function (stream) {
    //    let {char, control} = stream.peek();
    var char = stream.peek().char;
    if (char === _token) {
        stream.eat();
        return new Result(_token, stream, ResultType.Literal);
    }
    //    if (control === _token) {
    //        while (!stream.eof() && char !== _token) {
    //            stream.eat_input();
    //            char = stream.peek().char;
    //        }
    //    }
    //
    //    if (control !== undefined) {
    //        stream.eat();
    //    }
    return new Result(_token, stream, ResultType.Literal);
}); };
/**
 * @hidden
 */
var unmask = function (prompt) { return function (rule) { return new Parser(function (stream) {
    while (!stream.eof()) {
        var _a = stream.peek(), char = _a.char, control = _a.control;
        if (char === prompt && control === prompt) {
            stream.eat();
            return new Result(char, stream);
        }
        if (rule.test(char)) {
            stream.eat();
            return new Result(char, stream);
        }
        stream.eat_input();
    }
    stream.eat();
    return new Result('', stream);
}); }; };
/**
 * @hidden
 */
var unliteral = function (_token) { return new Parser(function (stream) {
    if (stream.eof()) {
        return new Result('', stream);
    }
    var char = stream.peek().char;
    if (char === _token) {
        stream.eat();
    }
    return new Result(_token, stream);
}); };
/**
 * @hidden
 */
var token = function (rules, creator) { return new Parser(function (stream) {
    var char = stream.next().char;
    var rule = rules[char];
    if (char === ESCAPE_CHARACTER) {
        char = stream.next().char;
        return new Result(creator.literal(char), stream);
    }
    if (!rule) {
        return new Result(creator.literal(char), stream);
    }
    return new Result(creator.mask(rule), stream);
}); };
/**
 * @hidden
 */
var rawMask = function (_a) {
    var prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;
    return new Parser(function (stream) {
        var char = stream.next().char;
        if (char === prompt) {
            return new Result(promptPlaceholder, stream);
        }
        return new Result(char, stream);
    });
};
/**
 * @hidden
 */
var rawLiteral = function (includeLiterals) { return new Parser(function (stream) {
    var char = stream.next().char;
    if (includeLiterals) {
        return new Result(char, stream);
    }
    return new Result('', stream);
}); };

/**
 * @hidden
 */
var always = function (value) { return new Parser(function (stream) { return new Result(value, stream); }); };
/**
 * @hidden
 */
var append = function (p1, p2) { return p1.chain(function (vs) { return p2.map(function (v) { return vs.concat([v]); }); }); };
/**
 * @hidden
 */
var sequence = function (list) { return list.reduce(function (acc, parser) { return append(acc, parser); }, always([])); };
/**
 * @hidden
 */
var greedy = function (parser) { return new Parser(function (stream) {
    var result = new Result([], stream);
    while (!stream.eof()) {
        result = result.concat(parser.run(stream));
    }
    return result;
}); };

/**
 * @hidden
 */
var MaskingService = /** @class */ (function () {
    function MaskingService() {
        this.rules = {};
        this.prompt = "_";
        this.mask = "";
        this.promptPlaceholder = " ";
        this.includeLiterals = false;
        this.maskTokens = [];
        this.unmaskTokens = [];
        this.rawTokens = [];
        this.validationTokens = [];
    }
    MaskingService.prototype.update = function (_a) {
        var _b = _a.mask, mask$$1 = _b === void 0 ? '' : _b, _c = _a.prompt, prompt = _c === void 0 ? '' : _c, _d = _a.promptPlaceholder, promptPlaceholder = _d === void 0 ? ' ' : _d, _e = _a.rules, rules = _e === void 0 ? {} : _e, _f = _a.includeLiterals, includeLiterals = _f === void 0 ? false : _f;
        this.mask = mask$$1;
        this.prompt = prompt;
        this.promptPlaceholder = promptPlaceholder;
        this.rules = rules;
        this.includeLiterals = includeLiterals;
        this.tokenize();
    };
    MaskingService.prototype.validationValue = function (maskedValue) {
        if (maskedValue === void 0) { maskedValue = ''; }
        var value = maskedValue;
        sequence(this.validationTokens)
            .run(maskedValue)
            .fold(function (unmasked) {
            value = unmasked.join('');
        });
        return value;
    };
    MaskingService.prototype.rawValue = function (maskedValue) {
        if (maskedValue === void 0) { maskedValue = ''; }
        var value = maskedValue;
        if (!this.rawTokens.length) {
            return value;
        }
        sequence(this.rawTokens)
            .run(maskedValue)
            .fold(function (unmasked) {
            value = unmasked.join('');
        });
        return value;
    };
    /**
     * @hidden
     */
    MaskingService.prototype.maskRaw = function (rawValue) {
        if (rawValue === void 0) { rawValue = ''; }
        var value = rawValue;
        if (!this.maskTokens.length) {
            return value;
        }
        sequence(this.maskTokens)
            .run(rawValue)
            .fold(function (masked) {
            value = masked.join('');
        });
        return value;
    };
    MaskingService.prototype.maskInput = function (input, control, splitPoint) {
        if (input.length < control.length) {
            return this.maskRemoved(input, control, splitPoint);
        }
        return this.maskInserted(input, control, splitPoint);
    };
    MaskingService.prototype.maskInRange = function (pasted, oldValue, start, end) {
        var value = '';
        var selection = end;
        var beforeChange = oldValue.split('').slice(0, start);
        var afterChange = oldValue.split('').slice(end);
        sequence(this.maskTokens.slice(start, end))
            .run(pasted)
            .fold(function (masked) {
            value = beforeChange
                .concat(masked)
                .concat(afterChange)
                .join('');
        });
        return {
            selection: selection,
            value: value
        };
    };
    MaskingService.prototype.maskRemoved = function (input, control, splitPoint) {
        var _this = this;
        var value = '';
        var selection = splitPoint;
        var unchanged = input.split('').slice(splitPoint);
        var changed = input.split('').slice(0, splitPoint).join('');
        var take = this.maskTokens.length - (input.length - splitPoint);
        sequence(this.maskTokens.slice(0, take))
            .run(changed, control)
            .fold(function (masked) {
            selection = _this.adjustPosition(masked, selection);
            value = masked.concat(unchanged).join('');
        });
        return {
            selection: selection,
            value: value
        };
    };
    MaskingService.prototype.adjustPosition = function (input, selection) {
        var caretChar = input[selection];
        var isLiteral = this.maskTokens[selection].isLiteral(caretChar);
        if (!isLiteral && caretChar !== this.prompt) {
            return selection + 1;
        }
        return selection;
    };
    MaskingService.prototype.maskInserted = function (input, control, splitPoint) {
        var _this = this;
        var value = '';
        var selection = splitPoint;
        var changed = input.slice(0, splitPoint);
        sequence(this.unmaskTokens)
            .run(changed, control)
            .chain(function (unmasked) {
            selection = unmasked.join('').length;
            var unchanged = control.slice(selection);
            return sequence(_this.maskTokens)
                .run(unmasked.join('') + unchanged, control);
        })
            .fold(function (masked) {
            value = masked.join('');
        });
        return {
            selection: selection,
            value: value
        };
    };
    Object.defineProperty(MaskingService.prototype, "maskTokenCreator", {
        get: function () {
            var _a = this, prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;
            return {
                literal: function (rule) { return literal(rule); },
                mask: function (rule) { return mask({ prompt: prompt, promptPlaceholder: promptPlaceholder })(rule); }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaskingService.prototype, "unmaskTokenCreator", {
        get: function () {
            var _this = this;
            return {
                literal: function (rule) { return unliteral(rule); },
                mask: function (rule) { return unmask(_this.prompt)(rule); }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaskingService.prototype, "rawTokenCreator", {
        get: function () {
            var _a = this, prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder, includeLiterals = _a.includeLiterals;
            return {
                literal: function (_) { return rawLiteral(includeLiterals); },
                mask: function (_) { return rawMask({ prompt: prompt, promptPlaceholder: promptPlaceholder }); }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaskingService.prototype, "validationTokenCreator", {
        get: function () {
            var prompt = this.prompt;
            return {
                literal: function (_) { return rawLiteral(false); },
                mask: function (_) { return rawMask({ prompt: prompt, promptPlaceholder: '' }); }
            };
        },
        enumerable: true,
        configurable: true
    });
    MaskingService.prototype.tokenize = function () {
        var _this = this;
        greedy(token(this.rules, this.maskTokenCreator))
            .run(this.mask)
            .fold(function (tokens, _) {
            _this.maskTokens = tokens;
        });
        greedy(token(this.rules, this.unmaskTokenCreator))
            .run(this.mask)
            .fold(function (tokens, _) {
            _this.unmaskTokens = tokens;
        });
        greedy(token(this.rules, this.rawTokenCreator))
            .run(this.mask)
            .fold(function (tokens, _) {
            _this.rawTokens = tokens;
        });
        greedy(token(this.rules, this.validationTokenCreator))
            .run(this.mask)
            .fold(function (tokens, _) {
            _this.validationTokens = tokens;
        });
    };
    MaskingService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    MaskingService.ctorParameters = function () { return []; };
    return MaskingService;
}());

var resolvedPromise = Promise.resolve(null);
var FOCUSED$3 = 'k-state-focused';
/**
 * Represents the [Kendo UI MaskedTextBox component for Angular]({% slug overview_maskedtextbox %}).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *      <kendo-maskedtextbox
 *          [mask]="mask"
 *          [value]="value">
 *      </kendo-maskedtextbox>
 *     `
 * })
 *
 * class AppComponent {
 *  public value: string = "9580128055807792";
 *  public mask: string = "0000-0000-0000-0000";
 * }
 * ```
 */
var MaskedTextBoxComponent = /** @class */ (function () {
    function MaskedTextBoxComponent(service, renderer, hostElement, ngZone, injector, rtl) {
        var _this = this;
        this.service = service;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.ngZone = ngZone;
        this.injector = injector;
        /**
         * @hidden
         */
        this.focusableId = "k-" + guid();
        /**
         * Determines whether the MaskedTextBox is disabled ([see example]({% slug disabled_maskedtextbox %})).
         */
        this.disabled = false;
        /**
         * Determines whether the MaskedTextBox is in its read-only state ([see example]({% slug readonly_maskedtextbox %})).
         */
        this.readonly = false;
        this.hostClasses = true;
        /**
         * Represents a prompt character for the masked value.
         * @default `_`
         */
        this.prompt = '_';
        /**
         * Indicates a character which represents an empty position in the raw value.
         * @default ' '
         */
        this.promptPlaceholder = ' ';
        /**
         * Indicates whether to include literals in the raw value  ([see example]({% slug value_maskedtextbox %})).
         * @default false
         */
        this.includeLiterals = false;
        /**
         * Specifies if the mask should be shown on focus for empty value.
         */
        this.maskOnFocus = false;
        /**
         * Determines whether the built-in mask validator is enforced when a form is validated
         * ([see example]({% slug validation_maskedtextbox %})).
         * @default true
         */
        this.maskValidation = true;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the `input` element.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (focus)="handleFocus()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the `input` element gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-maskedtextbox (blur)="handleBlur()"></kendo-maskedtextbox>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the value changes.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.handleFocus = function () {
            _this.focused = true;
            if (_this.maskOnFocus && _this.emptyMask) {
                _this.updateInput(_this.service.maskRaw(_this.value));
                _this.ngZone.runOutsideAngular(function () {
                    setTimeout(function () {
                        _this.setSelection(0, 0);
                    }, 0);
                });
            }
            if (hasObservers(_this.onFocus)) {
                _this.ngZone.run(function () {
                    _this.onFocus.emit();
                });
            }
        };
        /**
         * @hidden
         */
        this.handleClick = function () {
            if (_this.focused && !_this.focusClick) {
                _this.focusClick = true;
                var _a = _this.input.nativeElement, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;
                if (selectionStart === selectionEnd) {
                    _this.setFocusSelection();
                }
            }
        };
        /**
         * @hidden
         */
        this.handleBlur = function () {
            _this.focused = false;
            _this.focusClick = false;
            if (_this.maskOnFocus && _this.emptyMask) {
                _this.updateInput(_this.maskedValue);
            }
            if (hasObservers(_this.onBlur) || requiresZoneOnBlur(_this.control)) {
                _this.ngZone.run(function () {
                    _this.onTouched();
                    _this.onBlur.emit();
                });
            }
        };
        this.onChange = function (_) { };
        this.onTouched = function () { };
        this.focusClick = false;
        this.defaultRules = {
            "#": /[\d\s\+\-]/,
            "&": /[\S]/,
            "0": /[\d]/,
            "9": /[\d\s]/,
            "?": /[a-zA-Z\s]/,
            "A": /[a-zA-Z0-9]/,
            "C": /./,
            "L": /[a-zA-Z]/,
            "a": /[a-zA-Z0-9\s]/
        };
        this.isPasted = false;
        this.selection = [0, 0];
        this.direction = rtl ? 'rtl' : 'ltr';
        this.updateService();
    }
    Object.defineProperty(MaskedTextBoxComponent.prototype, "hostDisabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaskedTextBoxComponent.prototype, "rules", {
        /**
         * Exposes the RegExp-based mask validation array ([see example]({% slug masks_maskedtextbox %})).
         */
        get: function () {
            return this._rules || this.defaultRules;
        },
        set: function (value) {
            this._rules = Object.assign({}, this.defaultRules, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaskedTextBoxComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    MaskedTextBoxComponent.prototype.ngOnInit = function () {
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.control = this.injector.get(NgControl, null);
    };
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the MaskedTextBox is empty.
     */
    MaskedTextBoxComponent.prototype.isEmpty = function () {
        if (this.input) {
            return !Boolean(this.input.nativeElement.value);
        }
    };
    /**
     * @hidden
     */
    MaskedTextBoxComponent.prototype.handleDragDrop = function () {
        return false;
    };
    /**
     * Focuses the MaskedTextBox.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="maskedinput.focus()">Focus the input</button>
     *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    MaskedTextBoxComponent.prototype.focus = function () {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.focus();
    };
    /**
     * Blurs the MaskedTextBox.
     */
    MaskedTextBoxComponent.prototype.blur = function () {
        if (!this.input) {
            return;
        }
        this.input.nativeElement.blur();
    };
    /**
     * @hidden
     */
    MaskedTextBoxComponent.prototype.pasteHandler = function (e) {
        var _a = e.target, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;
        if (selectionEnd === selectionStart) {
            return;
        }
        this.isPasted = true;
        this.selection = [selectionStart, selectionEnd];
    };
    /**
     * @hidden
     */
    MaskedTextBoxComponent.prototype.inputHandler = function (e) {
        var value = e.target.value;
        var _a = this.selection, start = _a[0], end = _a[1];
        if (!this.mask) {
            this.updateValue(value);
            this.isPasted = false;
            return;
        }
        var result;
        if (this.isPasted) {
            this.isPasted = false;
            var rightPart = this.maskedValue.length - end;
            var to = value.length - rightPart;
            result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);
        }
        else {
            result = this.service.maskInput(value, this.maskedValue, e.target.selectionStart);
        }
        this.updateInput(result.value, result.selection);
        this.updateValue(result.value);
    };
    /**
     * @hidden
     */
    MaskedTextBoxComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.value) {
            this.value = this.normalizeValue();
        }
        if (!this.mask) {
            this.updateInput(this.value);
            return;
        }
        var next = this.extractChanges(changes);
        this.updateService(next);
        if (isChanged('value', changes)) {
            var maskedValue = this.service.maskRaw(this.value);
            if (maskedValue !== this.maskedValue) {
                this.updateInput(maskedValue);
            }
        }
        else if (anyChanged(['promptPlaceholder', 'includeLiterals'], changes)) {
            resolvedPromise.then(function () {
                _this.updateValue(_this.maskedValue);
            });
        }
        else {
            this.updateInput(this.service.maskRaw(this.value));
        }
    };
    /**
     * @hidden
     * Writes a new value to the element.
     */
    MaskedTextBoxComponent.prototype.writeValue = function (value) {
        this.value = this.normalizeValue(value);
        this.updateInput(this.service.maskRaw(this.value));
    };
    /**
     * @hidden
     * Sets the function that will be called when a `change` event is triggered.
     */
    MaskedTextBoxComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    /**
     * @hidden
     * Sets the function that will be called when a `touch` event is triggered.
     */
    MaskedTextBoxComponent.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    MaskedTextBoxComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @hidden
     */
    MaskedTextBoxComponent.prototype.validate = function (_) {
        if (this.maskValidation === false || !this.mask) {
            return null;
        }
        if (!this.service.validationValue(this.maskedValue)) {
            return null;
        }
        if (this.maskedValue.indexOf(this.prompt) !== -1) {
            return {
                patternError: {
                    mask: this.mask,
                    maskedValue: this.maskedValue,
                    value: this.value
                }
            };
        }
        return null;
    };
    /**
     * @hidden
     */
    MaskedTextBoxComponent.prototype.updateValue = function (maskedValue) {
        if (this.mask && !this.service.validationValue(maskedValue)) {
            this.value = '';
        }
        else {
            this.value = this.service.rawValue(maskedValue);
        }
        this.onChange(this.value);
        this.valueChange.emit(this.value);
    };
    MaskedTextBoxComponent.prototype.updateInput = function (maskedValue, selection) {
        if (maskedValue === void 0) { maskedValue = ''; }
        this.maskedValue = maskedValue;
        var value = this.maskOnFocus && !this.focused && this.emptyMask ? '' : maskedValue;
        this.renderer.setProperty(this.input.nativeElement, "value", value);
        if (selection !== undefined) {
            this.setSelection(selection, selection);
        }
    };
    MaskedTextBoxComponent.prototype.extractChanges = function (changes) {
        return Object.keys(changes).filter(function (key) { return key !== 'rules'; }).reduce(function (obj, key) {
            obj[key] = changes[key].currentValue;
            return obj;
        }, {}); // tslint:disable-line:align
    };
    MaskedTextBoxComponent.prototype.updateService = function (extra) {
        var config = Object.assign({
            includeLiterals: this.includeLiterals,
            mask: this.mask,
            prompt: this.prompt,
            promptPlaceholder: this.promptPlaceholder,
            rules: this.rules
        }, extra); // tslint:disable-line:align
        this.service.update(config);
    };
    MaskedTextBoxComponent.prototype.setSelection = function (start, end) {
        if (start === void 0) { start = this.selection[0]; }
        if (end === void 0) { end = this.selection[1]; }
        if (this.focused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    };
    Object.defineProperty(MaskedTextBoxComponent.prototype, "emptyMask", {
        get: function () {
            return this.service.maskRaw() === this.maskedValue;
        },
        enumerable: true,
        configurable: true
    });
    MaskedTextBoxComponent.prototype.setFocusSelection = function () {
        var selectionStart = this.input.nativeElement.selectionStart;
        var index = this.maskedValue.indexOf(this.prompt);
        if (index >= 0 && index < selectionStart) {
            this.selection = [index, index];
            this.setSelection();
        }
    };
    Object.defineProperty(MaskedTextBoxComponent.prototype, "focused", {
        get: function () {
            return this.isFocused;
        },
        set: function (value) {
            if (this.isFocused !== value && this.hostElement) {
                var element = this.hostElement.nativeElement;
                if (value) {
                    this.renderer.addClass(element, FOCUSED$3);
                }
                else {
                    this.renderer.removeClass(element, FOCUSED$3);
                }
                this.isFocused = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    MaskedTextBoxComponent.prototype.normalizeValue = function (value) {
        if (value === void 0) { value = this.value; }
        var present = isPresent(value);
        if (present && typeof value !== 'string') {
            if (isDevMode()) {
                throw new Error('The MaskedTextBox component supports only string values.');
            }
            return String(value);
        }
        return present ? value : '';
    };
    MaskedTextBoxComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoMaskedTextBox',
                    providers: [
                        MaskingService,
                        {
                            multi: true,
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return MaskedTextBoxComponent; }) /* tslint:disable-line */
                        },
                        {
                            multi: true,
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(function () { return MaskedTextBoxComponent; }) /* tslint:disable-line */
                        }
                    ],
                    selector: 'kendo-maskedtextbox',
                    template: "\n        <input type=\"text\"\n            #input\n            autocomplete=\"off\"\n            autocorrect=\"off\"\n            autocapitalize=\"off\"\n            spellcheck=\"false\"\n            class=\"k-textbox\"\n            [id]=\"focusableId\"\n            [tabindex]=\"tabIndex\"\n            [attr.title]=\"title\"\n            [disabled]=\"disabled\"\n            [readonly]=\"readonly\"\n            [kendoEventsOutsideAngular]=\"{\n                focus: handleFocus,\n                blur: handleBlur,\n                click: handleClick,\n                dragstart: handleDragDrop,\n                drop: handleDragDrop\n            }\"\n        />\n    "
                },] },
    ];
    /** @nocollapse */
    MaskedTextBoxComponent.ctorParameters = function () { return [
        { type: MaskingService, },
        { type: Renderer2, },
        { type: ElementRef, },
        { type: NgZone, },
        { type: Injector, },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] },] },
    ]; };
    MaskedTextBoxComponent.propDecorators = {
        'focusableId': [{ type: Input },],
        'disabled': [{ type: Input },],
        'readonly': [{ type: Input },],
        'title': [{ type: Input },],
        'direction': [{ type: HostBinding, args: ['attr.dir',] },],
        'hostClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-maskedtextbox',] },],
        'hostDisabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
        'mask': [{ type: Input },],
        'value': [{ type: Input },],
        'rules': [{ type: Input },],
        'prompt': [{ type: Input },],
        'promptPlaceholder': [{ type: Input },],
        'includeLiterals': [{ type: Input },],
        'maskOnFocus': [{ type: Input },],
        'maskValidation': [{ type: Input },],
        'tabindex': [{ type: Input },],
        'tabIndex': [{ type: Input },],
        'onFocus': [{ type: Output, args: ['focus',] },],
        'onBlur': [{ type: Output, args: ['blur',] },],
        'valueChange': [{ type: Output },],
        'input': [{ type: ViewChild, args: ['input',] },],
        'pasteHandler': [{ type: HostListener, args: ['paste', ['$event'],] },],
        'inputHandler': [{ type: HostListener, args: ['input', ['$event'],] },],
    };
    return MaskedTextBoxComponent;
}());

/**
 * @hidden
 */
var SliderTick = /** @class */ (function () {
    function SliderTick(value) {
        this.value = value;
        this.classes = {
            'k-tick': true
        };
    }
    return SliderTick;
}());
/* tslint:disable:component-selector */
/**
 * @hidden
 */
var SliderTicksComponent = /** @class */ (function () {
    function SliderTicksComponent(rtl) {
        this.rtl = rtl;
        this.wrapperClasses = 'k-reset k-slider-items';
        this.ticks = [];
    }
    SliderTicksComponent.prototype.ngOnChanges = function (_) {
        this.createTicks();
    };
    SliderTicksComponent.prototype.createTicks = function () {
        var count = calculateTicksCount(this.min, this.max, this.step);
        var largeStep = this.largeStep;
        var tickValueProps = {
            max: this.max,
            min: this.min,
            smallStep: this.step
        };
        var result = [];
        for (var i = 0; i < count; i++) {
            result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));
            if (largeStep && i % largeStep === 0) {
                result[i].large = true;
                result[i].classes['k-tick-large'] = true;
            }
        }
        if (this.rtl || this.vertical) {
            result = result.reverse();
        }
        if (result.length > 0) {
            Object.assign(result[0].classes, this.endTickClasses(true));
            Object.assign(result[result.length - 1].classes, this.endTickClasses(false));
        }
        this.ticks = result;
    };
    SliderTicksComponent.prototype.endTickClasses = function (first) {
        return {
            'k-first': (first && !this.vertical) || (!first && this.vertical),
            'k-last': (!first && !this.vertical) || (first && this.vertical)
        };
    };
    SliderTicksComponent.decorators = [
        { type: Component, args: [{
                    selector: '[kendoSliderTicks]',
                    template: "\n    <li #tickElement *ngFor=\"let tick of ticks;\"\n        [ngClass]=\"tick.classes\"\n        title=\"{{ tickTitle(tick.value) }}\"\n        role=\"presentation\"\n     >\n         <ng-container [ngSwitch]=\"tick.large\">\n            <span class=\"k-label\" *ngSwitchCase=\"true\">\n                <ng-container [ngTemplateOutlet]=\"labelTemplate || defaultLabel\" [ngTemplateOutletContext]=\"tick\">\n                </ng-container>\n            </span>\n            <ng-container *ngSwitchCase=\"false\">&nbsp;</ng-container>\n         </ng-container>\n     </li>\n\n     <ng-template #defaultLabel let-value=\"value\">\n        {{ tickTitle(value) }}\n     </ng-template>\n  "
                },] },
    ];
    /** @nocollapse */
    SliderTicksComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] },] },
    ]; };
    SliderTicksComponent.propDecorators = {
        'wrapperClasses': [{ type: HostBinding, args: ['class',] },],
        'tickTitle': [{ type: Input },],
        'vertical': [{ type: Input },],
        'step': [{ type: Input },],
        'largeStep': [{ type: Input },],
        'min': [{ type: Input },],
        'max': [{ type: Input },],
        'labelTemplate': [{ type: Input },],
        'tickElements': [{ type: ViewChildren, args: ['tickElement',] },],
    };
    return SliderTicksComponent;
}());

/**
 * @hidden
 */
var KendoDraggableDirective = /** @class */ (function () {
    function KendoDraggableDirective(ngEl, ngZone) {
        var _this = this;
        this.kendoDrag = new EventEmitter();
        this.kendoPress = new EventEmitter();
        this.kendoRelease = new EventEmitter();
        if (!isDocumentAvailable()) {
            return;
        }
        this.draggable = new Draggable({
            drag: function (e) {
                if (e.hasOwnProperty("originalEvent")) {
                    e.originalEvent.preventDefault();
                }
                _this.kendoDrag.next(e);
            },
            press: function (e) { return _this.kendoPress.next(e); },
            release: function (e) { return _this.kendoRelease.next(e); }
        });
        ngZone.runOutsideAngular(function () {
            _this.draggable.bindTo(ngEl.nativeElement);
        });
    }
    KendoDraggableDirective.prototype.ngOnDestroy = function () {
        if (this.draggable) {
            this.draggable.destroy();
        }
    };
    KendoDraggableDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoDraggable]'
                },] },
    ];
    /** @nocollapse */
    KendoDraggableDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
    ]; };
    KendoDraggableDirective.propDecorators = {
        'kendoDrag': [{ type: Output },],
        'kendoPress': [{ type: Output },],
        'kendoRelease': [{ type: Output },],
    };
    return KendoDraggableDirective;
}());

/**
 * @hidden
 */
var DraggableModule = /** @class */ (function () {
    function DraggableModule() {
    }
    DraggableModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [KendoDraggableDirective],
                    exports: [KendoDraggableDirective],
                    imports: [CommonModule],
                    providers: [
                        { provide: IntlService, useClass: CldrIntlService }
                    ]
                },] },
    ];
    /** @nocollapse */
    DraggableModule.ctorParameters = function () { return []; };
    return DraggableModule;
}());

/* tslint:disable:no-input-rename */
/**
 * @hidden
 */
var EventsOutsideAngularDirective = /** @class */ (function () {
    function EventsOutsideAngularDirective(element, ngZone, renderer) {
        this.element = element;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.events = {};
    }
    EventsOutsideAngularDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (!this.element || !this.element.nativeElement) {
            return;
        }
        var events = this.events;
        this.subscriptions = [];
        this.ngZone.runOutsideAngular(function () {
            for (var name_1 in events) {
                if (events.hasOwnProperty(name_1)) {
                    _this.subscriptions.push(_this.renderer.listen(_this.element.nativeElement, name_1, events[name_1]));
                }
            }
        });
    };
    EventsOutsideAngularDirective.prototype.ngOnDestroy = function () {
        if (this.subscriptions) {
            for (var idx = 0; idx < this.subscriptions.length; idx++) {
                this.subscriptions[idx]();
            }
            this.subscriptions = null;
        }
    };
    EventsOutsideAngularDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[kendoEventsOutsideAngular]'
                },] },
    ];
    /** @nocollapse */
    EventsOutsideAngularDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: Renderer2, },
    ]; };
    EventsOutsideAngularDirective.propDecorators = {
        'events': [{ type: Input, args: ['kendoEventsOutsideAngular',] },],
    };
    return EventsOutsideAngularDirective;
}());

/**
 * @hidden
 */
var EventsModule = /** @class */ (function () {
    function EventsModule() {
    }
    EventsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [EventsOutsideAngularDirective],
                    exports: [EventsOutsideAngularDirective]
                },] },
    ];
    /** @nocollapse */
    EventsModule.ctorParameters = function () { return []; };
    return EventsModule;
}());

/**
 * @hidden
 */
var Messages$1 = /** @class */ (function (_super) {
    __extends(Messages, _super);
    function Messages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Messages.propDecorators = {
        'decrement': [{ type: Input },],
        'increment': [{ type: Input },],
        'dragHandle': [{ type: Input },],
    };
    return Messages;
}(ComponentMessages));

/**
 * @hidden
 */
var LocalizedMessagesDirective = /** @class */ (function (_super) {
    __extends(LocalizedMessagesDirective, _super);
    function LocalizedMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedMessagesDirective.decorators = [
        { type: Directive, args: [{
                    providers: [
                        {
                            provide: Messages$1,
                            useExisting: forwardRef(function () { return LocalizedMessagesDirective; }) // tslint:disable-line:no-forward-ref
                        }
                    ],
                    selector: '[kendoSliderLocalizedMessages]'
                },] },
    ];
    /** @nocollapse */
    LocalizedMessagesDirective.ctorParameters = function () { return [
        { type: LocalizationService, },
    ]; };
    return LocalizedMessagesDirective;
}(Messages$1));

/**
 * Custom component messages override default component messages.
 */
var SliderCustomMessagesComponent = /** @class */ (function (_super) {
    __extends(SliderCustomMessagesComponent, _super);
    function SliderCustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    Object.defineProperty(SliderCustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    SliderCustomMessagesComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            provide: Messages$1,
                            useExisting: forwardRef(function () { return SliderCustomMessagesComponent; }) // tslint:disable-line:no-forward-ref
                        }
                    ],
                    selector: 'kendo-slider-messages',
                    template: ""
                },] },
    ];
    /** @nocollapse */
    SliderCustomMessagesComponent.ctorParameters = function () { return [
        { type: LocalizationService, },
    ]; };
    return SliderCustomMessagesComponent;
}(Messages$1));

var COMPONENT_DIRECTIVES = [
    SliderComponent,
    SliderTicksComponent,
    SliderCustomMessagesComponent,
    LocalizedMessagesDirective,
    LabelTemplateDirective
];
var COMPONENT_EXPORTS = [
    SliderComponent,
    SliderCustomMessagesComponent,
    LocalizedMessagesDirective,
    LabelTemplateDirective
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Slider component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { SliderModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, SliderModule], // import Slider module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var SliderModule = /** @class */ (function () {
    function SliderModule() {
    }
    SliderModule.decorators = [
        { type: NgModule, args: [{
                    declarations: COMPONENT_DIRECTIVES,
                    exports: COMPONENT_EXPORTS,
                    imports: [CommonModule, DraggableModule, EventsModule, ResizeSensorModule],
                    providers: [
                        { provide: IntlService, useClass: CldrIntlService }
                    ]
                },] },
    ];
    /** @nocollapse */
    SliderModule.ctorParameters = function () { return []; };
    return SliderModule;
}());

/**
 * @hidden
 */
var Messages$2 = /** @class */ (function (_super) {
    __extends(Messages, _super);
    function Messages() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Messages.propDecorators = {
        'on': [{ type: Input },],
        'off': [{ type: Input },],
    };
    return Messages;
}(ComponentMessages));

/**
 * @hidden
 */
var LocalizedMessagesDirective$1 = /** @class */ (function (_super) {
    __extends(LocalizedMessagesDirective, _super);
    function LocalizedMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedMessagesDirective.decorators = [
        { type: Directive, args: [{
                    providers: [
                        {
                            provide: Messages$2,
                            useExisting: forwardRef(function () { return LocalizedMessagesDirective; }) // tslint:disable-line:no-forward-ref
                        }
                    ],
                    selector: '[kendoSwitchLocalizedMessages]'
                },] },
    ];
    /** @nocollapse */
    LocalizedMessagesDirective.ctorParameters = function () { return [
        { type: LocalizationService, },
    ]; };
    return LocalizedMessagesDirective;
}(Messages$2));

/**
 * Custom component messages override default component messages.
 */
var SwitchCustomMessagesComponent = /** @class */ (function (_super) {
    __extends(SwitchCustomMessagesComponent, _super);
    function SwitchCustomMessagesComponent(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    Object.defineProperty(SwitchCustomMessagesComponent.prototype, "override", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    SwitchCustomMessagesComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            provide: Messages$2,
                            useExisting: forwardRef(function () { return SwitchCustomMessagesComponent; }) // tslint:disable-line:no-forward-ref
                        }
                    ],
                    selector: 'kendo-switch-messages',
                    template: ""
                },] },
    ];
    /** @nocollapse */
    SwitchCustomMessagesComponent.ctorParameters = function () { return [
        { type: LocalizationService, },
    ]; };
    return SwitchCustomMessagesComponent;
}(Messages$2));

var COMPONENT_DIRECTIVES$1 = [
    SwitchComponent,
    SwitchCustomMessagesComponent,
    LocalizedMessagesDirective$1
];
var COMPONENT_EXPORTS$1 = [
    SwitchComponent,
    SwitchCustomMessagesComponent,
    LocalizedMessagesDirective$1
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Switch component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Switch module
 * import { SwitchModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, SwitchModule], // import Switch module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var SwitchModule = /** @class */ (function () {
    function SwitchModule() {
    }
    SwitchModule.decorators = [
        { type: NgModule, args: [{
                    declarations: COMPONENT_DIRECTIVES$1,
                    exports: COMPONENT_EXPORTS$1,
                    imports: [CommonModule, EventsModule, ResizeSensorModule],
                    providers: [
                        { provide: IntlService, useClass: CldrIntlService }
                    ]
                },] },
    ];
    /** @nocollapse */
    SwitchModule.ctorParameters = function () { return []; };
    return SwitchModule;
}());

/**
 * @hidden
 */
var LocalizedMessagesDirective$2 = /** @class */ (function (_super) {
    __extends(LocalizedMessagesDirective, _super);
    function LocalizedMessagesDirective(service) {
        var _this = _super.call(this) || this;
        _this.service = service;
        return _this;
    }
    LocalizedMessagesDirective.decorators = [
        { type: Directive, args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(function () { return LocalizedMessagesDirective; }) // tslint:disable-line:no-forward-ref
                        }
                    ],
                    selector: '[kendoNumericTextBoxLocalizedMessages]'
                },] },
    ];
    /** @nocollapse */
    LocalizedMessagesDirective.ctorParameters = function () { return [
        { type: LocalizationService, },
    ]; };
    return LocalizedMessagesDirective;
}(Messages));

var COMPONENT_EXPORTS$2 = [
    NumericTextBoxComponent,
    NumericTextBoxCustomMessagesComponent
];
var COMPONENT_DIRECTIVES$2 = [
    LocalizedMessagesDirective$2
].concat(COMPONENT_EXPORTS$2);
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the NumericTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the NumericTextBox module
 * import { NumericTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, NumericTextBoxModule], // import NumericTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var NumericTextBoxModule = /** @class */ (function () {
    function NumericTextBoxModule() {
    }
    NumericTextBoxModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [COMPONENT_DIRECTIVES$2],
                    exports: [COMPONENT_EXPORTS$2],
                    imports: [CommonModule, EventsModule],
                    providers: [
                        { provide: IntlService, useClass: CldrIntlService }
                    ]
                },] },
    ];
    /** @nocollapse */
    NumericTextBoxModule.ctorParameters = function () { return []; };
    return NumericTextBoxModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the MaskedTextBox component.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the MaskedTextBox module
 * import { MaskedTextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, MaskedTextBoxModule], // import MaskedTextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var MaskedTextBoxModule = /** @class */ (function () {
    function MaskedTextBoxModule() {
    }
    MaskedTextBoxModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [MaskedTextBoxComponent],
                    exports: [MaskedTextBoxComponent],
                    imports: [CommonModule, EventsModule],
                    providers: [
                        { provide: IntlService, useClass: CldrIntlService }
                    ]
                },] },
    ];
    /** @nocollapse */
    MaskedTextBoxModule.ctorParameters = function () { return []; };
    return MaskedTextBoxModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TextBox directive.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the TextBox module
 * import { TextBoxModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, TextBoxModule], // import TextBox module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var TextBoxModule = /** @class */ (function () {
    function TextBoxModule() {
    }
    TextBoxModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [TextBoxDirective, TextAreaDirective, TextBoxContainerComponent],
                    exports: [TextBoxDirective, TextAreaDirective, TextBoxContainerComponent],
                    imports: [CommonModule]
                },] },
    ];
    /** @nocollapse */
    TextBoxModule.ctorParameters = function () { return []; };
    return TextBoxModule;
}());

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Inputs components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Inputs module
 * import { InputsModule } from '@progress/kendo-angular-inputs';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, BrowserAnimationsModule, InputsModule], // import Inputs module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
var InputsModule = /** @class */ (function () {
    function InputsModule() {
    }
    InputsModule.decorators = [
        { type: NgModule, args: [{
                    exports: [TextBoxModule, SliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule],
                    imports: [CommonModule],
                    providers: [
                        { provide: IntlService, useClass: CldrIntlService }
                    ]
                },] },
    ];
    /** @nocollapse */
    InputsModule.ctorParameters = function () { return []; };
    return InputsModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { DraggableModule, EventsModule, MaskingService, LocalizedMessagesDirective$2 as LocalizedMessagesDirective, Messages, SliderCustomMessagesComponent, LocalizedMessagesDirective as LocalizedMessagesDirective$1, Messages$1, SwitchCustomMessagesComponent, LocalizedMessagesDirective$1 as LocalizedMessagesDirective$2, Messages$2, SliderComponent, LabelTemplateDirective, SwitchComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, MaskedTextBoxComponent, InputsModule, SliderModule, SwitchModule, NumericTextBoxModule, MaskedTextBoxModule, TextBoxContainerComponent, TextBoxDirective, TextAreaDirective, TextBoxModule, EventsOutsideAngularDirective, KendoDraggableDirective, SliderTicksComponent };
