import { ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, Inject, Injectable, Input, NgModule, NgZone, Optional, Output, QueryList, Renderer2, SkipSelf, TemplateRef, ViewChild, ViewChildren, isDevMode } from '@angular/core';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { AUTO_STYLE, animate, state, style, transition, trigger } from '@angular/animations';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { Subscription as Subscription$1 } from 'rxjs/Subscription';
import { CommonModule } from '@angular/common';
import Draggable from '@telerik/kendo-draggable';
import { of as of$1 } from 'rxjs/observable/of';
import { delay as delay$1 } from 'rxjs/operators/delay';
import { filter as filter$1 } from 'rxjs/operators/filter';
import { map as map$1 } from 'rxjs/operators/map';
import { switchMap as switchMap$1 } from 'rxjs/operators/switchMap';
import { takeUntil as takeUntil$1 } from 'rxjs/operators/takeUntil';
import { tap as tap$1 } from 'rxjs/operators/tap';

/**
 * @hidden
 */
var Keys;
(function (Keys) {
    Keys[Keys["backspace"] = 8] = "backspace";
    Keys[Keys["tab"] = 9] = "tab";
    Keys[Keys["enter"] = 13] = "enter";
    Keys[Keys["shift"] = 16] = "shift";
    Keys[Keys["ctrl"] = 17] = "ctrl";
    Keys[Keys["alt"] = 18] = "alt";
    Keys[Keys["pause/break"] = 19] = "pause/break";
    Keys[Keys["caps lock"] = 20] = "caps lock";
    Keys[Keys["esc"] = 27] = "esc";
    Keys[Keys["space"] = 32] = "space";
    Keys[Keys["page up"] = 33] = "page up";
    Keys[Keys["page down"] = 34] = "page down";
    Keys[Keys["end"] = 35] = "end";
    Keys[Keys["home"] = 36] = "home";
    Keys[Keys["left"] = 37] = "left";
    Keys[Keys["up"] = 38] = "up";
    Keys[Keys["right"] = 39] = "right";
    Keys[Keys["down"] = 40] = "down";
    Keys[Keys["insert"] = 45] = "insert";
    Keys[Keys["delete"] = 46] = "delete";
    Keys[Keys["command"] = 91] = "command";
    Keys[Keys["left command"] = 91] = "left command";
    Keys[Keys["right command"] = 93] = "right command";
    Keys[Keys["numpad *"] = 106] = "numpad *";
    Keys[Keys["numpad +"] = 107] = "numpad +";
    Keys[Keys["numpad -"] = 109] = "numpad -";
    Keys[Keys["numpad ."] = 110] = "numpad .";
    Keys[Keys["numpad /"] = 111] = "numpad /";
    Keys[Keys["num lock"] = 144] = "num lock";
    Keys[Keys["scroll lock"] = 145] = "scroll lock";
    Keys[Keys["my computer"] = 182] = "my computer";
    Keys[Keys["my calculator"] = 183] = "my calculator";
    Keys[Keys[";"] = 186] = ";";
    Keys[Keys["="] = 187] = "=";
    Keys[Keys[","] = 188] = ",";
    Keys[Keys["-"] = 189] = "-";
    Keys[Keys["."] = 190] = ".";
    Keys[Keys["/"] = 191] = "/";
    Keys[Keys["`"] = 192] = "`";
    Keys[Keys["["] = 219] = "[";
    Keys[Keys["\\"] = 220] = "\\";
    Keys[Keys["]"] = 221] = "]";
    Keys[Keys["'"] = 222] = "'";
})(Keys || (Keys = {}));

/**
 * Represents the expand modes of the PanelBar.
 * By default, the expand mode is set to `multiple`.
 */
var PanelBarExpandMode;
(function (PanelBarExpandMode) {
    /**
     * Allows you to expand only one item at a time.
     * When you expand an item, the item that was previously expanded is coll.
     */
    PanelBarExpandMode[PanelBarExpandMode["Single"] = 0] = "Single";
    /**
     * Allows you to expand only one item at a time and requires you to set the `height` property.
     * The expanded area occupies the entire height of the PanelBar.
     */
    PanelBarExpandMode[PanelBarExpandMode["Full"] = 1] = "Full";
    /**
     * The default mode of the PanelBar.
     * Allows you to expand more than one item at a time. Items can also be toggled.
     */
    PanelBarExpandMode[PanelBarExpandMode["Multiple"] = 2] = "Multiple";
    /**
     * By default, the expand mode is set to `multiple`.
     */
    PanelBarExpandMode[PanelBarExpandMode["Default"] = 2] = "Default";
})(PanelBarExpandMode || (PanelBarExpandMode = {}));

/**
 * @hidden
 */
let nextPanelbarId = 0;
/**
 * @hidden
 */
class PanelBarService {
    constructor() {
        this.parentSource = new Subject$1();
        this.keepContentSource = new BehaviorSubject$1(false);
        this.childSource = new Subject$1();
        this.parent$ = this.parentSource.asObservable();
        this.children$ = this.childSource.asObservable();
        this.keepContent$ = this.keepContentSource.asObservable();
        this.pbId = nextPanelbarId++;
    }
    onKeepContent(keepContent) {
        this.keepContentSource.next(keepContent);
    }
    onSelect(event) {
        this.childSource.next(event);
    }
    onFocus() {
        this.parentSource.next(true);
    }
    onBlur() {
        this.parentSource.next(false);
    }
}
PanelBarService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PanelBarService.ctorParameters = () => [];

/**
 * Represents the content template of the declaratively initialized PanelBar items.
 * The content can be expanded or collapsed through the item.
 */
class PanelBarContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarContentDirective.decorators = [
    { type: Directive, args: [{
                selector: "[kendoPanelBarContent]"
            },] },
];
/** @nocollapse */
PanelBarContentDirective.ctorParameters = () => [
    { type: TemplateRef, },
];

/**
 * Represents the template directive of the PanelBar which helps to customize the item title
 * ([more information and example]({% slug templates_panelbar %}#toc-customizing-the-appearance-of-the-title)).
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *        <kendo-panelbar>
 *            <kendo-panelbar-item [title]="'Paris'" [expanded]="true">
 *                <ng-template kendoPanelBarItemTitle>
 *                    Additional Content
 *                </ng-template>
 *            </kendo-panelbar-item>
 *        </kendo-panelbar>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class PanelBarItemTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarItemTitleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendoPanelBarItemTitle]'
            },] },
];
/** @nocollapse */
PanelBarItemTitleDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional },] },
];

const focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
/**
 * @hidden
 */
const isFocusable = (element) => {
    if (element.tagName) {
        const tagName = element.tagName.toLowerCase();
        const tabIndex = element.getAttribute('tabIndex');
        const skipTab = tabIndex === '-1';
        let focusable = tabIndex !== null && !skipTab;
        if (focusableRegex.test(tagName)) {
            focusable = !element.disabled && !skipTab;
        }
        return focusable;
    }
    return false;
};

/**
 * @hidden
 */
let nextId = 0;
/**
 * Represents the items of the PanelBar.
 */
class PanelBarItemComponent {
    constructor(parent, eventService, element) {
        this.parent = parent;
        this.eventService = eventService;
        this.element = element;
        /**
         * Sets the title of the PanelBar item ([see example]({% slug items_panelbar %}#toc-titles)).
         */
        this.title = 'Untitled';
        /**
         * Allows the component to set the `"id"` property to each item.
         * Used to set the `id` attributes of the nested elements and to enable the WAI-ARIA support.
         */
        this.id = `default-${nextId++}`;
        /**
         * Defines the icon that will be rendered next to the title ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.icon = '';
        /**
         * Defines  the icon that will be rendered next to the title by using a custom CSS class
         * ([see example]({% slug items_panelbar %}#toc-title-icons)).
         */
        this.iconClass = '';
        /**
         * Defines the location of the image that will be displayed next to the title
         * ([see example]({% slug items_panelbar %}#toc-title-images)).
         */
        this.imageUrl = '';
        /**
         * When set to `true`, disables a PanelBar item ([see example]({% slug items_panelbar %}#toc-disabled-state)).
         */
        this.disabled = false;
        /**
         * Sets the selected state of a PanelBar item ([see example]({% slug items_panelbar %}#toc-selected-state)).
         */
        this.selected = false;
        this.keepContent = false;
        this.hasChildItems = false;
        this.hasItems = false;
        this.hasContent = false;
        this.state = "inactive";
        this.role = "treeitem";
        this.titleAttribute = null; // tslint:disable-line
        this.focused = false;
        this.wrapperFocused = false;
        this.subscriptions = new Subscription$1(() => { });
        this._expanded = false;
        this.subscriptions.add(eventService.parent$.subscribe(focused => this.onWrapperFocusChange(focused)));
        this.subscriptions.add(eventService.keepContent$.subscribe(keepContent => this.keepContent = keepContent));
        this.wrapperFocused = parent ? parent.focused : false;
    }
    /**
     * When set to `true`, expands the PanelBar item ([see example]({% slug items_panelbar %}#toc-expanded-state)).
     */
    set expanded(value) {
        const activeState = this.animate ? "active" : "activeWithoutAnimation";
        this.state = value ? activeState : "inactive";
        if (!this.keepContent) {
            this.toggleExpandedChildAnimations(value);
        }
        this._expanded = value;
    }
    get expanded() {
        return this._expanded;
    }
    get animate() {
        return this.eventService.animate;
    }
    get kItemClass() {
        return true;
    }
    get kStateDefaultClass() {
        return !this.disabled;
    }
    get kStateDisabledClass() {
        return this.disabled;
    }
    get kStateExpandedClass() {
        return !this.disabled && this.expanded && (this.hasChildItems || this.hasContent);
    }
    get itemId() {
        return 'k-panelbar-' + this.eventService.pbId + '-item-' + this.id;
    }
    get ariaExpanded() {
        return (this.hasChildItems || this.hasContent) ? !this.disabled && this.expanded : null;
    }
    get ariaSelected() {
        return !this.disabled && this.selected;
    }
    get ariaDisabled() {
        return this.disabled ? true : null;
    }
    /**
     * @hidden
     */
    get titleTemplate() {
        return this.titleTemplates.length > 0 ? this.titleTemplates.toArray()[0].templateRef : undefined;
    }
    /**
     * @hidden
     */
    headerHeight() {
        return this.element.nativeElement.offsetHeight - (this.contentWrapper ? this.contentWrapper.nativeElement.offsetHeight : 0);
    }
    /**
     * @hidden
     */
    ngAfterContentChecked() {
        this.hasItems = this.items && this.items.filter(item => !item.hidden).length > 0;
        this.hasChildItems = this.contentItems.length > 1 || this.hasItems;
        this.hasContent = (this.contentTemplate !== undefined && this.contentTemplate.length > 0) ||
            this.content !== undefined;
        this.validateConfiguration();
    }
    /**
     * @hidden
     */
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
        }
        else {
            this.childrenItems = this.contentItems.filter(item => item !== this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @hidden
     */
    onItemAction() {
        if (!this.disabled) {
            this.eventService.onSelect(this);
        }
    }
    /**
     * @hidden
     */
    onItemClick(e) {
        if (!isFocusable(e.target)) {
            this.onItemAction();
        }
    }
    /**
     * @hidden
     */
    get iconClasses() {
        let icon = this.icon ? 'k-i-' + this.icon : null;
        return {
            [icon || this.iconClass]: true
        };
    }
    /**
     * @hidden
     */
    serialize() {
        return {
            content: this.content,
            disabled: this.disabled,
            expanded: this.expanded,
            focused: this.focused,
            icon: this.icon,
            iconClass: this.iconClass,
            id: this.id,
            imageUrl: this.imageUrl,
            selected: this.selected,
            title: this.title
        };
    }
    /**
     * @hidden
     */
    subTreeViewItems() {
        let subTree = [];
        this.viewChildItems.forEach(item => {
            subTree = subTree.concat(item.subTreeViewItems());
            subTree.push(item);
        });
        return subTree;
    }
    /**
     * @hidden
     */
    validateConfiguration() {
        if (isDevMode()) {
            if (this.content && (this.contentTemplate !== undefined && this.contentTemplate.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and component property.");
            }
        }
    }
    /**
     * @hidden
     */
    toggleAnimationState(value) {
        if (!this.animate) {
            return;
        }
        this.state = value ? 'active' : 'activeWithoutAnimation';
    }
    /**
     * @hidden
     */
    toggleExpandedChildAnimations(value) {
        if (this.childrenItems) {
            this.childrenItems.forEach(child => {
                if (child.expanded) {
                    child.toggleAnimationState(value);
                    child.toggleExpandedChildAnimations(value);
                }
            });
        }
    }
    onWrapperFocusChange(focused) {
        this.wrapperFocused = focused;
    }
}
PanelBarItemComponent.decorators = [
    { type: Component, args: [{
                animations: [
                    trigger('toggle', [
                        state('inactive', style({ display: 'none' })),
                        transition('* => active', [
                            style({ overflow: 'hidden', display: 'block', height: 0 }),
                            animate(200, style({ height: AUTO_STYLE }))
                        ]),
                        transition('active => *', [
                            style({ overflow: 'hidden', height: '*' }),
                            animate(200, style({ height: 0, display: 'none' }))
                        ])
                    ])
                ],
                exportAs: 'kendoPanelbarItem',
                selector: "kendo-panelbar-item",
                template: `<span
                #header
                [class.k-link]="true"
                [class.k-header]="!parent"
                [class.k-state-selected]="!disabled && selected"
                [class.k-state-focused]="!disabled && focused && wrapperFocused"
                (click)="onItemClick($event)">
            <span
                *ngIf="icon || iconClass"
                class="k-icon"
                [ngClass]="iconClasses">
            </span>
            <img
                *ngIf="imageUrl"
                class="k-image"
                [src]="imageUrl"
                alt="">
            {{title}}
            <ng-template [ngTemplateOutlet]="titleTemplate"></ng-template>
            <span *ngIf="hasChildItems || hasContent"
                [class.k-icon]="true"
                [class.k-i-arrow-n]="expanded"
                [class.k-panelbar-collapse]="expanded"
                [class.k-i-arrow-s]="!expanded"
                [class.k-panelbar-expand]="!expanded">
            </span>
        </span>
        <div #contentWrapper
            *ngIf="keepContent || (!disabled && expanded && (hasChildItems || hasContent))"
            [@toggle]="state"
            [attr.role]="'group'"
            [attr.aria-hidden]="!disabled && !expanded">
            <div
                *ngIf="hasChildItems && !items?.length"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-panel k-group">
                    <ng-content select="kendo-panelbar-item"></ng-content>
            </div>
            <div
                *ngIf="hasContent && !content"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-content">
                <ng-template
                    [ngTemplateOutlet]="contentTemplate.first.templateRef"
                    [ngTemplateOutletContext]="{
                        $implicit: {
                            title: title,
                            id: id,
                            icon: icon,
                            imageUrl: imageUrl,
                            disabled: disabled,
                            content: content
                        }
                    }">
                </ng-template>
            </div>
            <div *ngIf="hasItems"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-panel k-group">
                <ng-container *ngFor="let item of items">
                    <kendo-panelbar-item *ngIf="!item.hidden"
                        [title]="item.title"
                        [id]="item.id"
                        [icon]="item.icon"
                        [iconClass]="item.iconClass"
                        [imageUrl]="item.imageUrl"
                        [selected]="!!item.selected"
                        [expanded]="!!item.expanded"
                        [disabled]="!!item.disabled"
                        [template]="template"
                        [items]="item.children"
                        [content]="item.content">
                    </kendo-panelbar-item>
                </ng-container>
            </div>
            <div
                *ngIf="content"
                [style.overflow]="contentOverflow"
                [style.height]="contentHeight"
                class="k-content">
                <ng-template
                    [ngTemplateOutlet]="template"
                    [ngTemplateOutletContext]="{
                        $implicit: {
                            title: title,
                            id: id,
                            icon: icon,
                            imageUrl: imageUrl,
                            disabled: disabled,
                            content: content
                        }
                    }">
                </ng-template>
                <ng-template [ngIf]="!template">{{content}}</ng-template>
            </div>
        </div>`
            },] },
];
/** @nocollapse */
PanelBarItemComponent.ctorParameters = () => [
    { type: PanelBarItemComponent, decorators: [{ type: SkipSelf }, { type: Host }, { type: Optional },] },
    { type: PanelBarService, },
    { type: ElementRef, },
];
PanelBarItemComponent.propDecorators = {
    'title': [{ type: Input },],
    'id': [{ type: Input },],
    'icon': [{ type: Input },],
    'iconClass': [{ type: Input },],
    'imageUrl': [{ type: Input },],
    'disabled': [{ type: Input },],
    'expanded': [{ type: Input },],
    'selected': [{ type: Input },],
    'content': [{ type: Input },],
    'items': [{ type: Input },],
    'template': [{ type: Input },],
    'header': [{ type: ViewChild, args: ['header', {},] },],
    'contentWrapper': [{ type: ViewChild, args: ['contentWrapper', {},] },],
    'role': [{ type: HostBinding, args: ['attr.role',] },],
    'titleAttribute': [{ type: HostBinding, args: ['attr.title',] },],
    'kItemClass': [{ type: HostBinding, args: ['class.k-item',] },],
    'kStateDefaultClass': [{ type: HostBinding, args: ['class.k-state-default',] },],
    'kStateDisabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
    'kStateExpandedClass': [{ type: HostBinding, args: ['class.k-state-expanded',] },],
    'itemId': [{ type: HostBinding, args: ['id',] },],
    'ariaExpanded': [{ type: HostBinding, args: ['attr.aria-expanded',] },],
    'ariaSelected': [{ type: HostBinding, args: ['attr.aria-selected',] },],
    'ariaDisabled': [{ type: HostBinding, args: ['attr.aria-disabled',] },],
    'viewChildItems': [{ type: ViewChildren, args: [PanelBarItemComponent,] },],
    'contentItems': [{ type: ContentChildren, args: [PanelBarItemComponent,] },],
    'contentTemplate': [{ type: ContentChildren, args: [PanelBarContentDirective, { descendants: false },] },],
    'titleTemplates': [{ type: ContentChildren, args: [PanelBarItemTitleDirective, { descendants: false },] },],
};

/**
 * Represents the template directive of the PanelBar which helps to customize the item content.
 */
class PanelBarItemTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
PanelBarItemTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendoPanelBarItemTemplate]'
            },] },
];
/** @nocollapse */
PanelBarItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional },] },
];

let nextId$1 = 0;
const parsePanelBarItems = (data) => {
    return data.map((item) => {
        if (!item.id) {
            item.id = `default-${nextId$1++}`;
        }
        if (item.children) {
            item.children = parsePanelBarItems(item.children);
        }
        return item;
    });
};
var util = {
    parsePanelBarItems
};

/**
 * Represents the [Kendo UI PanelBar component for Angular]({% slug overview_panelbar %}).
 */
// TODO: add styles as input prop
class PanelBarComponent {
    constructor(elementRef, eventService, localization) {
        this.localization = localization;
        /**
         * Sets the expand mode of the PanelBar through the `PanelBarExpandMode` enum ([see example]({% slug expandmodes_panelbar %})).
         *
         * The available modes are:
         * - `"single"`&mdash;Expands only one item at a time. Expanding an item collapses the item that was previously expanded.
         * - `"multiple"`&mdash;The default mode of the PanelBar.
         * Expands more than one item at a time. Items can also be toggled.
         * - `"full"`&mdash;Expands only one item at a time.
         * The expanded area occupies the entire height of the PanelBar. Requires you to set the `height` property.
         */
        this.expandMode = PanelBarExpandMode.Default;
        /**
         * Allows the PanelBar to modify the selected state of the items.
         */
        this.selectable = true;
        /**
         * Sets the animate state of the PanelBar ([see example]({% slug animations_panelbar %})).
         */
        this.animate = true;
        /**
         * Sets the height of the component when the `"full"` expand mode is used.
         * This option is ignored in the `"multiple"` and `"single"` expand modes.
         */
        this.height = "400px";
        /**
         * Fires each time the user interacts with a PanelBar item
         * ([see example]({% slug routing_panelbar %}#toc-getting-the-selected-item)).
         * The event data contains all items that are modified.
         */
        this.stateChange = new EventEmitter();
        this.tabIndex = 0;
        this.role = "tree";
        this.activeDescendant = "";
        this.isViewInit = true;
        this.focused = false;
        this._keepItemContent = false;
        this.updateChildrenHeight = () => {
            let childrenHeight = 0;
            const panelbarHeight = this.elementRef.nativeElement.offsetHeight;
            const contentOverflow = this.expandMode === PanelBarExpandMode.Full ? 'auto' : 'visible';
            this.childrenItems.forEach(item => {
                childrenHeight += item.headerHeight();
            });
            this.childrenItems.forEach(item => {
                item.contentHeight = PanelBarExpandMode.Full === this.expandMode ? (panelbarHeight - childrenHeight) + "px" : 'auto';
                item.contentOverflow = contentOverflow;
            });
        };
        this.keyBindings = this.computedKeys;
        this.elementRef = elementRef;
        this.eventService = eventService;
        this.eventService.children$.subscribe(event => this.onItemAction(event));
    }
    /**
     * When set to `true`, the PanelBar renders the content of all items and they are persisted in the DOM
     * ([see example]({% slug templates_panelbar %}#toc-collections)).
     * By default, this option is set to `false`.
     */
    get keepItemContent() {
        return this._keepItemContent;
    }
    set keepItemContent(keepItemContent) {
        this._keepItemContent = keepItemContent;
        this.eventService.onKeepContent(keepItemContent);
    }
    /**
     * Sets the items of the PanelBar as an array of `PanelBarItemModel` instances
     * ([see example]({% slug items_panelbar %})).
     */
    set items(data) {
        if (data) {
            this._items = util.parsePanelBarItems(data);
        }
    }
    get items() {
        return this._items;
    }
    get hostHeight() {
        return this.expandMode === PanelBarExpandMode.Full ? this.height : 'auto';
    }
    get overflow() {
        return this.expandMode === PanelBarExpandMode.Full ? "hidden" : "visible";
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    get computedKeys() {
        return {
            [Keys.space]: () => this.selectFocusedItem(),
            [Keys.enter]: () => this.selectFocusedItem(),
            [Keys.up]: () => this.focusPreviousItem(),
            [this.invertKeys(Keys.left, Keys.right)]: () => this.collapseItem(),
            [Keys.down]: () => this.focusNextItem(),
            [this.invertKeys(Keys.right, Keys.left)]: () => this.expandItem(),
            [Keys.end]: () => this.focusLastItem(),
            [Keys.home]: () => this.focusFirstItem()
        };
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.keyBindings = this.computedKeys);
        this.eventService.animate = this.animate;
    }
    ngAfterViewChecked() {
        if (this.items) {
            this.childrenItems = this.viewChildItems.toArray();
            this.allItems = this.viewItems;
        }
        else {
            this.childrenItems = this.contentChildItems.toArray();
            this.allItems = this.contentItems.toArray();
        }
        if (this.isViewInit && this.childrenItems.length) {
            this.isViewInit = false;
            setTimeout(() => this.updateChildrenHeight());
        }
        this.validateConfiguration();
    }
    ngOnChanges(changes) {
        if (changes['height'] || changes['expandMode'] || changes["items"]) {
            if (this.childrenItems) {
                setTimeout(this.updateChildrenHeight);
            }
        }
        if (changes.animate) {
            this.eventService.animate = this.animate;
        }
    }
    get templateRef() {
        return this.template ? this.template.templateRef : undefined;
    }
    /**
     * @hidden
     */
    onComponentClick(event) {
        const itemClicked = this.visibleItems().some((item) => {
            return item.header.nativeElement.contains(event.target);
        });
        if (!this.focused && itemClicked) {
            this.elementRef.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        this.eventService.onFocus();
        this.focused = true;
        if (this.allItems.length > 0) {
            const visibleItems = this.visibleItems();
            const focusedItems = visibleItems.filter(item => item.focused);
            if (!focusedItems.length && visibleItems.length > 0) {
                visibleItems[0].focused = true;
                this.activeDescendant = visibleItems[0].itemId;
            }
        }
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        this.eventService.onBlur();
        this.focused = false;
        this.activeDescendant = "";
    }
    /**
     * @hidden
     */
    onComponentKeyDown(event) {
        if (event.target === this.elementRef.nativeElement) {
            if (event.keyCode === Keys.space || event.keyCode === Keys.up || event.keyCode === Keys.down ||
                event.keyCode === Keys.left || event.keyCode === Keys.right || event.keyCode === Keys.home ||
                event.keyCode === Keys.end || event.keyCode === Keys['page up'] || event.keyCode === Keys['page down']) {
                event.preventDefault();
            }
            const handler = this.keyBindings[event.keyCode];
            //TODO: check if next item is disabled and skip operation?
            if (handler) {
                handler();
            }
        }
    }
    get viewItems() {
        let treeItems = [];
        this.viewChildItems.toArray().forEach(item => {
            treeItems.push(item);
            treeItems = treeItems.concat(item.subTreeViewItems());
        });
        return treeItems;
    }
    validateConfiguration() {
        if (isDevMode()) {
            if (this.items && (this.contentItems && this.contentItems.length > 0)) {
                throw new Error("Invalid configuration: mixed template components and items property.");
            }
        }
    }
    onItemAction(item) {
        if (!item) {
            return;
        }
        let modifiedItems = new Array();
        this.allItems
            .forEach((currentItem) => {
            let selectedState = currentItem === item;
            let focusedState = selectedState;
            selectedState = this.selectable ? selectedState : currentItem.selected;
            if (currentItem.selected !== selectedState || currentItem.focused !== focusedState) {
                currentItem.selected = selectedState;
                currentItem.focused = focusedState;
                this.activeDescendant = focusedState ? currentItem.itemId : "";
                modifiedItems.push(currentItem);
            }
        });
        if (this.expandMode === PanelBarExpandMode.Multiple) {
            if (item.hasChildItems || item.hasContent) {
                item.expanded = !item.expanded;
            }
            if (modifiedItems.indexOf(item) < 0) {
                modifiedItems.push(item);
            }
        }
        else {
            let siblings = item.parent ? item.parent.childrenItems : this.childrenItems;
            if (item.hasChildItems || item.hasContent) {
                siblings
                    .forEach((currentItem) => {
                    let expandedState = currentItem === item;
                    if (currentItem.expanded !== expandedState) {
                        currentItem.expanded = expandedState;
                        if (modifiedItems.indexOf(currentItem) < 0) {
                            modifiedItems.push(currentItem);
                        }
                    }
                });
            }
        }
        if (modifiedItems.length > 0) {
            this.stateChange.emit(modifiedItems.map(currentItem => currentItem.serialize()));
        }
    }
    get hostClasses() {
        return true;
    }
    isVisible(item) {
        const visibleItems = this.visibleItems();
        return visibleItems.some(i => i === item);
    }
    getVisibleParent(item) {
        const visibleItems = this.visibleItems();
        if (!item.parent) {
            return item;
        }
        return visibleItems.some(i => i === item.parent) ? item.parent : this.getVisibleParent(item.parent);
    }
    focusItem(action) {
        const visibleItems = this.visibleItems();
        let currentIndex = visibleItems.findIndex(item => item.focused);
        let currentItem = visibleItems[currentIndex];
        let nextItem;
        if (currentIndex === -1) {
            let focusedItem = this.allItems.find(item => item.focused);
            focusedItem.focused = false;
            currentItem = this.getVisibleParent(focusedItem);
            currentIndex = visibleItems.findIndex(item => item === currentItem);
        }
        switch (action) {
            case "lastItem":
                nextItem = visibleItems[visibleItems.length - 1];
                break;
            case "firstItem":
                nextItem = visibleItems[0];
                break;
            case "nextItem":
                nextItem = visibleItems[currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0];
                break;
            case "previousItem":
                nextItem = visibleItems[currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1];
                break;
            default:
        }
        if (currentItem && nextItem && currentItem !== nextItem) {
            this.moveFocus(currentItem, nextItem);
        }
    }
    moveFocus(from, to) {
        from.focused = false;
        to.focused = true;
        this.activeDescendant = to.itemId;
        const modifiedItems = new Array(from.serialize(), to.serialize());
        this.stateChange.emit(modifiedItems);
    }
    focusLastItem() {
        this.focusItem("lastItem");
    }
    focusFirstItem() {
        this.focusItem("firstItem");
    }
    focusNextItem() {
        this.focusItem("nextItem");
    }
    focusPreviousItem() {
        this.focusItem("previousItem");
    }
    expandItem() {
        let currentItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(currentItem)) {
            currentItem.focused = false;
            currentItem = this.getVisibleParent(currentItem);
        }
        if (currentItem.hasChildItems || currentItem.hasContent) {
            if (!currentItem.expanded) {
                this.onItemAction(currentItem);
            }
            else if (currentItem.hasChildItems) {
                const firstChildIndex = currentItem.childrenItems.findIndex(item => !item.disabled);
                if (firstChildIndex > -1) {
                    this.moveFocus(currentItem, currentItem.childrenItems[firstChildIndex]);
                }
            }
        }
    }
    collapseItem() {
        const currentItem = this.allItems.filter(item => item.focused)[0];
        if (currentItem.expanded) {
            this.onItemAction(currentItem);
        }
        else if (currentItem.parent) {
            this.moveFocus(currentItem, currentItem.parent);
        }
    }
    selectFocusedItem() {
        let focusedItem = this.allItems.filter(item => item.focused)[0];
        if (!this.isVisible(focusedItem)) {
            focusedItem.focused = false;
            focusedItem = this.getVisibleParent(focusedItem);
        }
        if (focusedItem) {
            focusedItem.onItemAction();
        }
    }
    visibleItems() {
        return this.flatVisibleItems(this.childrenItems);
    }
    flatVisibleItems(listOfItems = new Array(), flattedItems = new Array()) {
        listOfItems.forEach(item => {
            if (!item.disabled) {
                flattedItems.push(item);
                if (item.expanded && item.hasChildItems) {
                    this.flatVisibleItems(item.childrenItems, flattedItems);
                }
            }
        });
        return flattedItems;
    }
}
PanelBarComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoPanelbar',
                providers: [
                    PanelBarService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.panelbar'
                    }
                ],
                selector: 'kendo-panelbar',
                template: `
        <ng-content *ngIf="contentChildItems && !items" select="kendo-panelbar-item"></ng-content>
        <ng-template [ngIf]="items?.length">
            <ng-container *ngFor="let item of items">
                <kendo-panelbar-item *ngIf="!item.hidden"
                     [title]="item.title"
                     [id]="item.id"
                     [icon]="item.icon"
                     [iconClass]="item.iconClass"
                     [imageUrl]="item.imageUrl"
                     [selected]="!!item.selected"
                     [expanded]="!!item.expanded"
                     [disabled]="!!item.disabled"
                     [template]="templateRef"
                     [items]="item.children"
                     [content]="item.content"
                >
                </kendo-panelbar-item>
            </ng-container>
        </ng-template>
    `
            },] },
];
/** @nocollapse */
PanelBarComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: PanelBarService, },
    { type: LocalizationService, },
];
PanelBarComponent.propDecorators = {
    'expandMode': [{ type: Input },],
    'selectable': [{ type: Input },],
    'animate': [{ type: Input },],
    'height': [{ type: Input },],
    'keepItemContent': [{ type: Input },],
    'items': [{ type: Input },],
    'stateChange': [{ type: Output },],
    'tabIndex': [{ type: HostBinding, args: ['attr.tabIndex',] },],
    'role': [{ type: HostBinding, args: ['attr.role',] },],
    'activeDescendant': [{ type: HostBinding, args: ['attr.aria-activedescendant',] },],
    'hostHeight': [{ type: HostBinding, args: ['style.height',] },],
    'overflow': [{ type: HostBinding, args: ['style.overflow',] },],
    'dir': [{ type: HostBinding, args: ['attr.dir',] },],
    'template': [{ type: ContentChild, args: [PanelBarItemTemplateDirective,] },],
    'contentItems': [{ type: ContentChildren, args: [PanelBarItemComponent, { descendants: true },] },],
    'contentChildItems': [{ type: ContentChildren, args: [PanelBarItemComponent,] },],
    'viewChildItems': [{ type: ViewChildren, args: [PanelBarItemComponent,] },],
    'onComponentClick': [{ type: HostListener, args: ['click', ['$event'],] },],
    'onComponentFocus': [{ type: HostListener, args: ['focus',] },],
    'onComponentBlur': [{ type: HostListener, args: ['blur',] },],
    'onComponentKeyDown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
    'hostClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-panelbar',] },],
};

/**
 * Represents the pane component of the Splitter.
 */
class SplitterPaneComponent {
    constructor(element, renderer, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        /**
         * Specifies if the user is allowed to resize the pane and provide space for other panes.
         */
        this.resizable = true;
        /**
         * Specifies if the user is allowed to hide the pane and provide space for other panes.
         */
        this.collapsible = false;
        /**
         * Specifies if overflowing content is scrollable or hidden.
         */
        this.scrollable = true;
        /**
         * Specifies if the pane is initially collapsed.
         */
        this.collapsed = false;
        /**
         * @hidden
         */
        this.orientation = 'horizontal';
        /**
         * @hidden
         */
        this.containsSplitter = false;
        /**
         * @hidden
         */
        this.overlayContent = false;
        /**
         * Fires each time the user resizes the Splitter pane.
         * The event data contains the new pane size.
         * Allows a two-way binding of the pane `size` property.
         */
        this.sizeChange = new EventEmitter();
        /**
         * Fires each time the `collapsed` property changes.
         * The event data contains the new property state.
         * Allows a two-way binding of the `collapsed` pane property.
         */
        this.collapsedChange = new EventEmitter();
        this.hostClass = true;
    }
    /**
     * @hidden
     */
    set order(paneOrder) {
        this._order = paneOrder;
        this.setOrderStyles();
    }
    get order() {
        return this._order;
    }
    /**
     * Sets the initial size of the pane.
     * Has to be between the `min` and `max` properties.
     */
    set size(newSize) {
        this._size = newSize;
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-preferred-size', newSize);
        this.renderer.setStyle(element, 'flex-basis', newSize);
        if (this.staticPaneClass) {
            this.renderer.addClass(element, 'k-pane-static');
        }
        else {
            this.renderer.removeClass(element, 'k-pane-static');
        }
    }
    get size() {
        return this._size;
    }
    get isHidden() {
        return this.collapsed;
    }
    get styleDisplayFlex() {
        return this.containsSplitter;
    }
    get staticPaneClass() {
        return !this.resizable && !this.collapsible || this.fixedSize;
    }
    get scrollablePaneClass() {
        return this.scrollable;
    }
    get fixedSize() {
        return this.size && this.size.length > 0;
    }
    ngAfterViewChecked() {
        const element = this.element.nativeElement;
        if (this.isHidden) {
            this.renderer.addClass(element, 'k-state-hidden');
            this.renderer.addClass(element, 'hidden');
        }
        else {
            this.renderer.removeClass(element, 'k-state-hidden');
            this.renderer.removeClass(element, 'hidden');
        }
    }
    /**
     * @hidden
     */
    get computedSize() {
        if (this.orientation === 'vertical') {
            return this.element.nativeElement.offsetHeight;
        }
        else {
            return this.element.nativeElement.offsetWidth;
        }
    }
    /**
     * @hidden
     */
    toggleOverlay(show) {
        this.overlayContent = show;
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    detectChanges() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    setOrderStyles() {
        const element = this.element.nativeElement;
        this.renderer.setStyle(element, '-ms-flex-order', this.order);
        this.renderer.setStyle(element, 'order', this.order);
    }
}
SplitterPaneComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoSplitterPane',
                selector: 'kendo-splitter-pane',
                template: `
        <ng-container *ngIf="!collapsed"><ng-content></ng-content></ng-container>
        <div *ngIf="overlayContent" class="k-splitter-overlay k-overlay"></div>
    `
            },] },
];
/** @nocollapse */
SplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ChangeDetectorRef, },
];
SplitterPaneComponent.propDecorators = {
    'order': [{ type: Input },],
    'size': [{ type: Input },],
    'min': [{ type: Input },],
    'max': [{ type: Input },],
    'resizable': [{ type: Input },],
    'collapsible': [{ type: Input },],
    'scrollable': [{ type: Input },],
    'collapsed': [{ type: Input },],
    'orientation': [{ type: Input },],
    'containsSplitter': [{ type: Input },],
    'overlayContent': [{ type: Input },],
    'sizeChange': [{ type: Output },],
    'collapsedChange': [{ type: Output },],
    'styleDisplayFlex': [{ type: HostBinding, args: ['class.k-pane-flex',] },],
    'hostClass': [{ type: HostBinding, args: ['class.k-pane',] },],
    'staticPaneClass': [{ type: HostBinding, args: ['class.k-pane-static',] },],
    'scrollablePaneClass': [{ type: HostBinding, args: ['class.k-scrollable',] },],
};

const SIZING_DOC_LINK = 'https://www.telerik.com/kendo-angular-ui/components/layout/splitter/panes/#toc-size';
/**
 * @hidden
 */
class SplitterService {
    constructor(zone) {
        this.zone = zone;
        this.layoutChange = new EventEmitter();
        this.containerSize = () => { };
    }
    tryToggle(paneIndex) {
        const pane = this.pane(paneIndex);
        if (pane.collapsible) {
            pane.collapsed = !pane.collapsed;
            pane.collapsedChange.emit(pane.collapsed);
            this.emit(this.layoutChange, {});
            if (pane.collapsed) {
                pane.detectChanges();
            }
        }
        return pane.collapsible;
    }
    toggleContentOverlay(index, show) {
        this.pane(index).toggleOverlay(show);
        this.pane(index + 1).toggleOverlay(show);
    }
    dragState(splitbarIndex) {
        let prev = this.pane(splitbarIndex);
        let next = this.pane(splitbarIndex + 1);
        const total = prev.computedSize + next.computedSize;
        const px = s => this.toPixels(s);
        return {
            prev: {
                index: splitbarIndex,
                initialSize: prev.computedSize,
                min: px(prev.min) || total - px(next.max) || 0,
                max: px(prev.max) || total - px(next.min) || total
            },
            next: {
                index: splitbarIndex + 1,
                initialSize: next.computedSize,
                min: px(next.min) || total - px(prev.max) || 0,
                max: px(next.max) || total - px(prev.min) || total
            }
        };
    }
    setSize(state$$1, delta) {
        const clamp = (min, max, v) => Math.min(max, Math.max(min, v));
        const resize = (paneState, change) => {
            const pane = this.pane(paneState.index);
            const splitterSize = this.containerSize();
            const newSize = clamp(paneState.min, paneState.max, paneState.initialSize + change);
            let size = "";
            if (this.isPercent(pane.size)) {
                size = (100 * newSize / splitterSize) + "%";
            }
            else {
                size = newSize + "px";
            }
            pane.size = size;
            this.emit(pane.sizeChange, size);
        };
        const prev = this.pane(state$$1.prev.index);
        const next = this.pane(state$$1.next.index);
        // determine which pane to resize
        if (prev.fixedSize && next.fixedSize) {
            // resizing both panes
            resize(state$$1.prev, delta);
            resize(state$$1.next, -delta);
        }
        else if (next.collapsible || next.fixedSize) {
            // resizing next
            resize(state$$1.next, -delta);
        }
        else {
            // resizing prev
            resize(state$$1.prev, delta);
        }
        this.emit(this.layoutChange, {});
    }
    isDraggable(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsedPane = prev.collapsed || next.collapsed;
        return betweenResizablePanes && !nearCollapsedPane;
    }
    isStatic(splitBarIndex) {
        const prev = this.pane(splitBarIndex);
        const next = this.pane(splitBarIndex + 1);
        const betweenResizablePanes = prev.resizable && next.resizable;
        const nearCollapsiblePane = prev.collapsible || next.collapsible;
        return !betweenResizablePanes && !nearCollapsiblePane;
    }
    pane(index) {
        if (!this.panes) {
            throw new Error("Panes not initialized");
        }
        if (index < 0 || index >= this.panes.length) {
            throw new Error("Index out of range");
        }
        return this.panes[index];
    }
    configure({ panes, orientation, containerSize }) {
        this.panes = panes;
        this.panes.forEach((pane, index) => {
            pane.order = index * 2;
            pane.orientation = orientation;
        });
        if (isDevMode()) {
            const allFixed = panes.length && !panes.some(pane => !pane.fixedSize);
            if (allFixed) {
                throw new Error(`
                    The Splitter should have at least one pane without a set size.
                    See ${SIZING_DOC_LINK} for more information.
                `);
            }
        }
        this.containerSize = containerSize;
    }
    isPercent(size) {
        return /%$/.test(size);
    }
    toPixels(size) {
        let result = parseFloat(size);
        if (this.isPercent(size)) {
            result = (this.containerSize() * result / 100);
        }
        return result;
    }
    emit(emitter, args) {
        if (emitter.observers.length) {
            this.zone.run(() => emitter.emit(args));
        }
    }
}
SplitterService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
SplitterService.ctorParameters = () => [
    { type: NgZone, },
];

/**
 * Represents the [Kendo UI Splitter component for Angular]({% slug overview_splitter %}).
 *
 * ```ts-preview
 *
 *  @Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-splitter style="height: 280px;">
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / left pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane>
 *            <h3>Inner splitter / center pane</h3>
 *            <p>Resizable only.</p>
 *          </kendo-splitter-pane>
 *
 *          <kendo-splitter-pane [collapsible]="true" size="30%">
 *            <h3>Inner splitter / right pane</h3>
 *            <p>Resizable and collapsible.</p>
 *          </kendo-splitter-pane>
 *
 *        </kendo-splitter>
 *      `,
 *    styles: [ `
 *        h3 { font-size: 1.2em; }
 *        h3, p { margin: 10px; padding: 0; }
 *    ` ]
 *  })
 *  class AppComponent {}
 * ```
 */
class SplitterComponent {
    constructor(element, splitterService, localization, enclosingPane) {
        this.element = element;
        this.splitterService = splitterService;
        this.localization = localization;
        /**
         * Specifies the orientation of the panes within the Splitter.
         * Panes in a horizontal Splitter are placed horizontally.
         * Panes in a vertical Splitter are placed vertically.
         */
        this.orientation = 'horizontal';
        this.ariaRole = 'splitter';
        if (enclosingPane) {
            enclosingPane.containsSplitter = true;
        }
        // the handler only runs in NgZone if there are bound handlers
        // this line merges both streams
        this.layoutChange = this.splitterService.layoutChange;
        this.configure = this.configure.bind(this);
    }
    get hostClasses() {
        return true;
    }
    get horizontalHostClasses() {
        return this.orientation === 'horizontal';
    }
    get verticalHostClasses() {
        return this.orientation === 'vertical';
    }
    get dir() {
        return this.direction;
    }
    ngAfterContentInit() {
        this.reconfigure();
    }
    ngOnChanges(changes) {
        if (changes.orientation && !changes.orientation.isFirstChange()) {
            this.reconfigure();
        }
    }
    ngOnDestroy() {
        this.unsubscribeChanges();
    }
    reconfigure() {
        this.unsubscribeChanges();
        this.configure();
        this.paneChangesSubscription = this.panes.changes.subscribe(this.configure);
    }
    unsubscribeChanges() {
        if (this.paneChangesSubscription) {
            this.paneChangesSubscription.unsubscribe();
            this.paneChangesSubscription = null;
        }
    }
    configure() {
        this.splitterService.configure({
            panes: this.panes.toArray(),
            orientation: this.orientation,
            containerSize: () => {
                if (this.orientation === 'vertical') {
                    return this.element.nativeElement.clientHeight;
                }
                else {
                    return this.element.nativeElement.clientWidth;
                }
            }
        });
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
}
SplitterComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoSplitter',
                selector: 'kendo-splitter',
                providers: [
                    SplitterService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.spliter'
                    }
                ],
                template: `
      <ng-content select="kendo-splitter-pane"></ng-content>
      <ng-container *ngFor="
        let pane of panes;
        let index = index;
        let last = last;
      ">
        <kendo-splitter-bar
          kendoLayoutDraggable
          *ngIf="!last"
          [index]="index"
          [orientation]="orientation">
        </kendo-splitter-bar>
      </ng-container>
    `
            },] },
];
/** @nocollapse */
SplitterComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: SplitterService, },
    { type: LocalizationService, },
    { type: SplitterPaneComponent, decorators: [{ type: Optional }, { type: Host }, { type: Inject, args: [SplitterPaneComponent,] },] },
];
SplitterComponent.propDecorators = {
    'orientation': [{ type: Input },],
    'layoutChange': [{ type: Output },],
    'hostClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-splitter',] }, { type: HostBinding, args: ['class.k-splitter-flex',] },],
    'horizontalHostClasses': [{ type: HostBinding, args: ['class.k-splitter-horizontal',] },],
    'verticalHostClasses': [{ type: HostBinding, args: ['class.k-splitter-vertical',] },],
    'dir': [{ type: HostBinding, args: ['attr.dir',] },],
    'ariaRole': [{ type: HostBinding, args: ['attr.role',] },],
    'panes': [{ type: ContentChildren, args: [SplitterPaneComponent,] },],
};

/**
 * Represents the content template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabContent` inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class TabContentDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TabContentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendoTabContent]'
            },] },
];
/** @nocollapse */
TabContentDirective.ctorParameters = () => [
    { type: TemplateRef, },
];

/**
 * Represents the title template of the Kendo UI TabStrip.
 * To define the template, nest a `<ng-template>` tag with the `kendoTabTitle` directive inside the component tag.
 *
 * @example
 * ```ts-preview
 *
 * _@Component({
 *     selector: 'my-app',
 *     template: `
 *         <kendo-tabstrip [ngStyle]="{'width': '400px'}" [animate]="true">
 *           <kendo-tabstrip-tab [title]="'Paris'" [selected]="true">
 *             <ng-template kendoTabTitle>
 *               Title
 *             </ng-template>
 *             <ng-template kendoTabContent>
 *               <h3>Content 1</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *
 *           <kendo-tabstrip-tab [title]="'Sofia'">
 *             <ng-template kendoTabContent>
 *               <h3>Content 2</h3>
 *             </ng-template>
 *           </kendo-tabstrip-tab>
 *         </kendo-tabstrip>
 *     `
 * })
 *
 * class AppComponent {}
 *
 * ```
 */
class TabTitleDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TabTitleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendoTabTitle]'
            },] },
];
/** @nocollapse */
TabTitleDirective.ctorParameters = () => [
    { type: TemplateRef, },
];

/**
 * Represents the tab component of the TabStrip.
 */
class TabStripTabComponent {
    constructor() {
        this.active = false;
        this._tabContent = new QueryList();
    }
    get tabContent() {
        return this._tabContent.first;
    }
    ngAfterContentInit() {
        this.active = this.selected;
    }
    ngOnChanges(changes) {
        if (changes['selected'] && !changes['selected'].isFirstChange()) {
            this.active = this.selected;
        }
    }
}
TabStripTabComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoTabStripTab',
                selector: 'kendo-tabstrip-tab',
                template: ``
            },] },
];
/** @nocollapse */
TabStripTabComponent.ctorParameters = () => [];
TabStripTabComponent.propDecorators = {
    'title': [{ type: Input },],
    'disabled': [{ type: Input },],
    'cssClass': [{ type: Input },],
    'selected': [{ type: Input },],
    '_tabContent': [{ type: ContentChildren, args: [TabContentDirective,] },],
    'tabTitle': [{ type: ContentChild, args: [TabTitleDirective,] },],
};

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * If the event is prevented by any of its subscribers, returns `true`.
     *
     * @returns `true` if the default action was prevented. Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}
/**
 * Arguments for the `select` event of the TabStrip.
 * The `select` event fires when a tab is selected (clicked).
 */
class SelectEvent extends PreventableEvent {
    /**
     * Constructs the event arguments for the `select` event.
     * @param index - The index of the selected tab.
     * @param title - The title of the selected tab.
     */
    constructor(index, title) {
        super();
        this.index = index;
        this.title = title;
    }
}

/**
 * Represents the [Kendo UI TabStrip component for Angular]({% slug overview_tabstrip %}).
 */
class TabStripComponent {
    constructor(localization, renderer, wrapper) {
        this.localization = localization;
        this.renderer = renderer;
        this.wrapper = wrapper;
        /**
         * Enables the tab animation.
         */
        this.animate = true;
        /**
         * Sets the position of the tabs. Defaults to `top`.
         */
        this.tabPosition = 'top';
        /**
         * When set to `true`, the component renders all tabs and they are persisted in the DOM.
         * By default, `keepTabContent` is `false`.
         */
        this.keepTabContent = false;
        /**
         * Fires each time the user selects a tab ([see example]({% slug overview_tabstrip %}#toc-basic-usage)).
         * The event data contains the index of the selected tab and its title.
         */
        this.tabSelect = new EventEmitter();
        this.hostClasses = true;
        /**
         * @hidden
         */
        this._animate = false;
        this.keyBindings = this.computedKeys;
    }
    /**
     * Sets the height of the TabStrip.
     */
    set height(value) {
        this._height = value;
        this.renderer.setStyle(this.wrapper.nativeElement, 'height', value);
    }
    get height() {
        return this._height;
    }
    get tabsAtTop() {
        return this.tabPosition === 'top';
    }
    get tabsAtRight() {
        return this.tabPosition === 'right';
    }
    get tabsAtBottom() {
        return this.tabPosition === 'bottom';
    }
    get tabsAtLeft() {
        return this.tabPosition === 'left';
    }
    get dir() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    /**
     * @hidden
     */
    contentClass(active) {
        const visible = !this.keepTabContent || active;
        return visible ? 'k-content k-state-active' : 'k-content';
    }
    get computedKeys() {
        return {
            [this.invertKeys(Keys.left, Keys.right)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.right, Keys.left)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.down, Keys.up)]: (selectedIndex) => this.nextNavigatableIndex(selectedIndex),
            [this.invertKeys(Keys.up, Keys.down)]: (selectedIndex) => this.prevNavigatableIndex(selectedIndex),
            [Keys.home]: () => this.firstNavigatableIndex(),
            [Keys.end]: () => this.lastNavigatableIndex()
        };
    }
    /**
     * @hidden
     */
    get tabsAlignment() {
        return {
            start: 'flex-start',
            end: 'flex-end',
            center: 'center',
            justify: 'space-between'
        }[this.tabAlignment];
    }
    /**
     * @hidden
     */
    invertKeys(original, inverted) {
        return this.localization.rtl ? inverted : original;
    }
    /**
     * @hidden
     */
    onKeyDown(event) {
        let selectedIndex = this.tabs.toArray().findIndex(tab => tab.active && !tab.disabled);
        if (event.currentTarget !== this.tablist.nativeElement) {
            return;
        }
        if (event.keyCode === Keys.space || event.keyCode === Keys.up || event.keyCode === Keys.down ||
            event.keyCode === Keys.left || event.keyCode === Keys.right || event.keyCode === Keys.home ||
            event.keyCode === Keys.end || event.keyCode === Keys['page up'] || event.keyCode === Keys['page down']) {
            event.preventDefault();
        }
        if (selectedIndex === -1) {
            this.selectTab(this.firstNavigatableIndex());
        }
        else {
            const getTabIndex = this.keyBindings[event.keyCode];
            if (getTabIndex) {
                const nextIndex = getTabIndex(selectedIndex);
                if (selectedIndex !== nextIndex) {
                    this.selectTab(getTabIndex(selectedIndex));
                }
            }
        }
    }
    /**
     * @hidden
     */
    tabPanelId(id) {
        return 'k-tabstrip-tabpanel-' + id;
    }
    /**
     * @hidden
     */
    tabId(id) {
        return 'k-tabstrip-tab-' + id;
    }
    /**
     * Allows the user to select a tab programmatically.
     * @param {number} index - The index of the tab that will be selected.
     */
    selectTab(index) {
        const tab = this.tabs.toArray()[index];
        if (!tab || Boolean(tab.disabled)) {
            return;
        }
        this.emitEvent(tab, index);
    }
    ngOnInit() {
        this.localizationChangeSubscription = this.localization
            .changes.subscribe(() => this.keyBindings = this.computedKeys);
    }
    ngOnDestroy() {
        if (this.localizationChangeSubscription) {
            this.localizationChangeSubscription.unsubscribe();
        }
    }
    firstNavigatableIndex() {
        const tabs = this.tabs.toArray();
        for (let i = 0; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    }
    lastNavigatableIndex() {
        const tabs = this.tabs.toArray();
        for (let i = tabs.length - 1; i > 0; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
        }
    }
    prevNavigatableIndex(selectedIndex) {
        if (selectedIndex - 1 < 0) {
            return this.lastNavigatableIndex();
        }
        const tabs = this.tabs.toArray();
        for (let i = selectedIndex - 1; i > -1; i--) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i === 0) {
                return this.lastNavigatableIndex();
            }
        }
        return selectedIndex;
    }
    nextNavigatableIndex(selectedIndex) {
        if (selectedIndex + 1 >= this.tabs.length) {
            return this.firstNavigatableIndex();
        }
        const tabs = this.tabs.toArray();
        for (let i = selectedIndex + 1; i < tabs.length; i++) {
            if (!tabs[i].disabled) {
                return i;
            }
            if (i + 1 === tabs.length) {
                return this.firstNavigatableIndex();
            }
        }
    }
    emitEvent(tab, selectedIndex) {
        const selectArgs = new SelectEvent(selectedIndex, tab.title);
        this.tabSelect.emit(selectArgs);
        if (!selectArgs.isDefaultPrevented() && !tab.active) {
            this._animate = this.animate;
            this.deactivateAll();
            tab.active = true;
        }
    }
    deactivateAll() {
        this.tabs.forEach((tab) => {
            tab.active = false;
        });
    }
}
TabStripComponent.decorators = [
    { type: Component, args: [{
                animations: [
                    trigger('state', [
                        state('active', style({ opacity: 1 })),
                        transition('* => active', [
                            style({ opacity: 0 }),
                            animate('400ms ease-in')
                        ])
                    ])
                ],
                providers: [
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.tabstrip'
                    }
                ],
                exportAs: 'kendoTabStrip',
                selector: 'kendo-tabstrip',
                template: `
        <ng-container *ngIf="!tabsAtBottom">
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
        </ng-container>

        <ng-container *ngIf="tabsAtBottom">
            <ng-container *ngTemplateOutlet="content">
            </ng-container>
            <ng-container *ngTemplateOutlet="heading">
            </ng-container>
        </ng-container>

        <ng-template #heading>
            <ul
                class="k-reset k-tabstrip-items"
                [style.justifyContent]="tabsAlignment"
                role="tablist"
                (keydown)="onKeyDown($event)"
                [tabIndex]="0"
                #tablist
            >
                <li *ngFor="let tab of tabs; let i = index;" (click)="selectTab(i)"
                    role="tab"
                    [id]="tabId(i)"
                    [ngClass]="tab.cssClass"
                    [class.k-item]="true"
                    [class.k-state-default]="true"
                    [class.k-state-active]="tab.active"
                    [class.k-state-disabled]="tab.disabled"
                    [attr.aria-selected]="tab.active"
                    [attr.aria-controls]="tab.tabPanelId"
                    [attr.aria-disabled]="tab.disabled"
                ><span class="k-link">{{ tab.title }}<ng-template [ngTemplateOutlet]="tab.tabTitle?.templateRef"></ng-template></span></li>
            </ul>
        </ng-template>
        <ng-template #content>
            <ng-template ngFor let-tab [ngForOf]="tabs" let-i="index">
                <div
                    [@state]="tab.active && _animate ? 'active' : 'inactive'"
                    *ngIf="tab.active || keepTabContent"
                    [ngClass]="contentClass(tab.active)"
                    role="tabpanel"
                    [id]="tabPanelId(i)"
                    [attr.aria-hidden]="!tab.active"
                    [attr.aria-expanded]="tab.active"
                    [attr.aria-labelledby]="tabId(i)"
                    [attr.aria-disabled]="tab.disabled"
                >
                    <ng-template [ngTemplateOutlet]="tab.tabContent?.templateRef"></ng-template>
                </div>
            </ng-template>
        </ng-template>
    `
            },] },
];
/** @nocollapse */
TabStripComponent.ctorParameters = () => [
    { type: LocalizationService, },
    { type: Renderer2, },
    { type: ElementRef, },
];
TabStripComponent.propDecorators = {
    'height': [{ type: Input },],
    'animate': [{ type: Input },],
    'tabAlignment': [{ type: Input },],
    'tabPosition': [{ type: Input },],
    'keepTabContent': [{ type: Input },],
    'tablist': [{ type: ViewChild, args: ['tablist',] },],
    'tabSelect': [{ type: Output },],
    'hostClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-tabstrip',] }, { type: HostBinding, args: ['class.k-floatwrap',] }, { type: HostBinding, args: ['class.k-header',] },],
    'tabsAtTop': [{ type: HostBinding, args: ['class.k-tabstrip-top',] },],
    'tabsAtRight': [{ type: HostBinding, args: ['class.k-tabstrip-right',] },],
    'tabsAtBottom': [{ type: HostBinding, args: ['class.k-tabstrip-bottom',] },],
    'tabsAtLeft': [{ type: HostBinding, args: ['class.k-tabstrip-left',] },],
    'dir': [{ type: HostBinding, args: ['attr.dir',] },],
    'tabs': [{ type: ContentChildren, args: [TabStripTabComponent,] },],
};

const exportedModules = [
    PanelBarComponent,
    PanelBarItemComponent,
    PanelBarContentDirective,
    PanelBarItemTemplateDirective,
    PanelBarItemTitleDirective
];
const declarations = [
    ...exportedModules
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the PanelBar component.
 *
 * The module registers:
 * - `PanelBarComponent`&mdash;The `PanelBar` component class.
 * - `PanelBarItemComponent`&mdash;The `PanelBarItem` component class.
 * - `PanelBarContentComponent`&mdash;The `PanelBarContent` component class.
 * - `PanelBarItemTemplateDirective&mdash;The `PanelBarItemTemplate` directive.
 * - `PanelBarItemTitleDirective&mdash;The `PanelBarItemTitle` directive.
 */
class PanelBarModule {
}
PanelBarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [declarations],
                exports: [exportedModules],
                imports: [CommonModule]
            },] },
];
/** @nocollapse */
PanelBarModule.ctorParameters = () => [];

/**
 * @hidden
 */
class DraggableDirective {
    constructor(zone, element) {
        this.zone = zone;
        this.kendo = {
            drag: new EventEmitter(),
            press: new EventEmitter(),
            release: new EventEmitter()
        };
        if (typeof document !== 'undefined') {
            this.draggable = new Draggable({
                drag: (e) => this.kendo.drag.next(e),
                press: (e) => this.kendo.press.next(e),
                release: (e) => this.kendo.release.next(e)
            });
            this.zone.runOutsideAngular(() => this.draggable.bindTo(element.nativeElement));
        }
    }
    ngOnDestroy() {
        if (typeof document !== 'undefined') {
            this.draggable.destroy();
        }
    }
}
DraggableDirective.decorators = [
    { type: Directive, args: [{
                outputs: ['kendo.press', 'kendo.drag', 'kendo.release'],
                selector: '[kendoLayoutDraggable]'
            },] },
];
/** @nocollapse */
DraggableDirective.ctorParameters = () => [
    { type: NgZone, },
    { type: ElementRef, },
];

const stopPropagation = ({ originalEvent: event }) => {
    event.stopPropagation();
    event.preventDefault();
};
const preventOnDblClick = release => mouseDown => of$1(mouseDown).pipe(delay$1(150), takeUntil$1(release));
const classFromObject = classes => Object.keys(classes).filter(c => classes[c]).join(' ');
const createMoveStream = (draggable) => mouseDown => draggable.kendo.drag
    .pipe(takeUntil$1(draggable.kendo.release), map$1(({ pageX, pageY }) => ({
    originalX: mouseDown.pageX,
    originalY: mouseDown.pageY,
    pageX,
    pageY
})));
/**
 * @hidden
 */
class SplitterBarComponent {
    constructor(draggable, splitter, localization) {
        this.draggable = draggable;
        this.splitter = splitter;
        this.localization = localization;
        this.orientation = 'horizontal';
        this.index = 0;
        this.ariaRole = 'separator';
        this.focused = false;
        this.subscriptions = new Subscription$1();
    }
    get direction() {
        return this.localization.rtl ? 'rtl' : 'ltr';
    }
    get tabIndex() {
        return this.splitter.isStatic(this.index) ? -1 : 0;
    }
    get hostClasses() {
        const isHorizontal = this.orientation === 'horizontal';
        const isDraggable = this.splitter.isDraggable(this.index);
        const isStatic = this.splitter.isStatic(this.index);
        return classFromObject({
            'k-state-focused': this.focused,
            'k-splitbar': true,
            'k-splitbar-horizontal': isHorizontal,
            'k-splitbar-vertical': !isHorizontal,
            'k-splitbar-draggable-horizontal': isHorizontal && isDraggable,
            'k-splitbar-draggable-vertical': !isHorizontal && isDraggable,
            'k-splitbar-static-horizontal': isHorizontal && isStatic,
            'k-splitbar-static-vertical': !isHorizontal && isStatic
        });
    }
    get touchAction() {
        if (this.splitter.isDraggable(this.index)) {
            return 'none';
        }
    }
    get order() {
        return 2 * this.index + 1;
    }
    collapseAny() {
        this.tryToggleNearest();
    }
    onFocusIn() {
        this.focused = true;
    }
    onFocusOut() {
        this.focused = false;
    }
    onKeyDown(event) {
        const keyCode = event && event.keyCode;
        const isHorizontal = this.orientation === 'horizontal';
        const resize = delta => {
            event.preventDefault();
            const state$$1 = this.splitter.dragState(this.index);
            this.splitter.setSize(state$$1, delta);
        };
        if (keyCode === Keys.enter) {
            event.preventDefault();
            this.tryToggleNearest();
        }
        else if (isHorizontal && keyCode === Keys.left) {
            resize(-10);
        }
        else if (isHorizontal && keyCode === Keys.right) {
            resize(10);
        }
        else if (!isHorizontal && keyCode === Keys.up) {
            resize(-10);
        }
        else if (!isHorizontal && keyCode === Keys.down) {
            resize(10);
        }
    }
    ngOnInit() {
        let state$$1;
        const listener = this.draggable.kendo.press.pipe(tap$1(stopPropagation), filter$1(() => this.splitter.isDraggable(this.index)), tap$1(() => state$$1 = this.splitter.dragState(this.index)), tap$1(() => this.splitter.toggleContentOverlay(this.index, true)), switchMap$1(preventOnDblClick(this.draggable.kendo.release)), switchMap$1(createMoveStream(this.draggable))).subscribe(({ pageX, pageY, originalX, originalY }) => {
            let delta;
            if (this.orientation === 'vertical') {
                delta = pageY - originalY;
            }
            else if (this.direction === 'rtl') {
                delta = originalX - pageX;
            }
            else {
                delta = pageX - originalX;
            }
            this.splitter.setSize(state$$1, delta);
        });
        this.subscriptions.add(listener);
        this.subscriptions.add(this.draggable.kendo.release.subscribe(() => this.splitter.toggleContentOverlay(this.index, false)));
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    togglePrevious() {
        this.splitter.tryToggle(this.index);
    }
    toggleNext() {
        this.splitter.tryToggle(this.index + 1);
    }
    previousArrowClass() {
        const pane = this.splitter.pane(this.index);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible,
            'k-collapse-prev': isCollapsible,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    nextArrowClass() {
        const pane = this.splitter.pane(this.index + 1);
        const isCollapsible = pane.collapsible;
        const isCollapsed = pane.collapsed;
        const isHorizontal = this.orientation === 'horizontal';
        return classFromObject({
            'k-icon': true,
            'k-hidden': !isCollapsible,
            'k-collapse-next': isCollapsible,
            'k-i-arrow-60-right': isCollapsible && isHorizontal && !isCollapsed,
            'k-i-arrow-60-left': isCollapsible && isHorizontal && isCollapsed,
            'k-i-arrow-60-down': isCollapsible && !isHorizontal && !isCollapsed,
            'k-i-arrow-60-up': isCollapsible && !isHorizontal && isCollapsed
        });
    }
    tryToggleNearest() {
        const prev = this.index;
        const next = this.index + 1;
        if (!this.splitter.tryToggle(prev)) {
            this.splitter.tryToggle(next);
        }
    }
}
SplitterBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'kendo-splitter-bar',
                template: `
      <div [class]="previousArrowClass()" (click)="togglePrevious()"></div>
      <div class="k-resize-handle"></div>
      <div [class]="nextArrowClass()" (click)="toggleNext()"></div>
    `
            },] },
];
/** @nocollapse */
SplitterBarComponent.ctorParameters = () => [
    { type: DraggableDirective, decorators: [{ type: Host },] },
    { type: SplitterService, },
    { type: LocalizationService, },
];
SplitterBarComponent.propDecorators = {
    'orientation': [{ type: Input }, { type: HostBinding, args: ['attr.aria-orientation',] },],
    'index': [{ type: Input },],
    'ariaRole': [{ type: HostBinding, args: ['attr.role',] },],
    'focused': [{ type: HostBinding, args: ['class.k-state-focused',] },],
    'tabIndex': [{ type: HostBinding, args: ['attr.tabindex',] },],
    'hostClasses': [{ type: HostBinding, args: ['class',] },],
    'touchAction': [{ type: HostBinding, args: ['style.touch-action',] },],
    'order': [{ type: HostBinding, args: ['style.-ms-flex-order',] }, { type: HostBinding, args: ['style.order',] },],
    'collapseAny': [{ type: HostListener, args: ['dblclick',] },],
    'onFocusIn': [{ type: HostListener, args: ['focusin',] },],
    'onFocusOut': [{ type: HostListener, args: ['focusout',] },],
    'onKeyDown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
};

const exportedModules$1 = [
    SplitterComponent,
    SplitterPaneComponent
];
const declarations$1 = [
    DraggableDirective,
    SplitterBarComponent,
    ...exportedModules$1
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Splitter component.
 *
 * The module registers:
 * - `SplitterComponent`&mdash;The `Splitter` component class.
 * - `SplitterPaneComponent`&mdash;The `SplitterPane` component class.
 */
class SplitterModule {
}
SplitterModule.decorators = [
    { type: NgModule, args: [{
                declarations: [declarations$1],
                exports: [exportedModules$1],
                imports: [CommonModule]
            },] },
];
/** @nocollapse */
SplitterModule.ctorParameters = () => [];

const exportedModules$2 = [
    TabStripComponent,
    TabStripTabComponent,
    TabContentDirective,
    TabTitleDirective
];
const declarations$2 = [
    ...exportedModules$2
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the TabStrip component.
 *
 * The module registers:
 * - `TabStripComponent`&mdash;The `TabStrip` component class.
 * - `TabStripTabComponent`&mdash;The `TabStripTab` component class.
 * - `TabContentDirective`&mdash;The tab content directive used on the `<ng-template>` tag.
 * - `TabTitleDirective`&mdash;The tab title directive used on the `<ng-template>` tag.
 */
class TabStripModule {
}
TabStripModule.decorators = [
    { type: NgModule, args: [{
                declarations: [declarations$2],
                exports: [exportedModules$2],
                imports: [CommonModule]
            },] },
];
/** @nocollapse */
TabStripModule.ctorParameters = () => [];

/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})
 * definition for the Layout components.
 *
 * @example
 *
 * ```ts-no-run
 * // Import the Layout module
 * import { LayoutModule } from '@progress/kendo-angular-layout';
 *
 * // The browser platform with a compiler
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 *
 * import { NgModule } from '@angular/core';
 *
 * // Import the app component
 * import { AppComponent } from './app.component';
 *
 * // Define the app module
 * _@NgModule({
 *     declarations: [AppComponent], // declare app component
 *     imports:      [BrowserModule, LayoutModule], // import Layout module
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 *
 * // Compile and launch the module
 * platformBrowserDynamic().bootstrapModule(AppModule);
 *
 * ```
 */
class LayoutModule {
}
LayoutModule.decorators = [
    { type: NgModule, args: [{
                exports: [
                    PanelBarModule,
                    SplitterModule,
                    TabStripModule
                ]
            },] },
];
/** @nocollapse */
LayoutModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { DraggableDirective, PanelBarService, SplitterBarComponent, SplitterService, PreventableEvent, PanelBarComponent, PanelBarItemComponent, PanelBarContentDirective, PanelBarItemTemplateDirective, PanelBarItemTitleDirective, PanelBarExpandMode, SplitterComponent, SplitterPaneComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, SelectEvent, LayoutModule, PanelBarModule, SplitterModule, TabStripModule };
