import { Component, Input, Output, HostBinding, EventEmitter, ContentChild, ElementRef, Renderer2, ViewChildren, HostListener, NgZone, ViewChild } from '@angular/core';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { Subscription } from 'rxjs/Subscription';
import { DragResizeService } from './drag-resize.service';
import { OFFSET_STYLES, isPresent, isChanged, isTruthy, hasClasses, WINDOW_CLASSES } from '../common/util';
import { isDocumentAvailable, RESIZE_DIRECTIONS } from "../common/util";
import { ResizeHandleDirective } from './window-resize-handle.directive';
import { WindowTitleBarComponent } from './window-titlebar.component';
import { NavigationService } from './navigation.service';
/**
 * Represents the [Kendo UI Window component for Angular]({% slug overview_window_dialogs %}).
 */
export class WindowComponent {
    constructor(el, renderer, service, navigation, ngZone, localization) {
        this.el = el;
        this.renderer = renderer;
        this.service = service;
        this.navigation = navigation;
        this.ngZone = ngZone;
        /**
         * Specifies if the content of the component is persisted in the DOM when minimized.
         * @default false
         */
        this.keepContent = false;
        /**
         * Fires when the user starts to move the Window.
         */
        this.dragStart = new EventEmitter();
        /**
         * Fires when the Window was moved by the user.
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fires when the user starts to resize the Window.
         */
        this.resizeStart = new EventEmitter();
        /**
         * Fires when the Window was resized by the user.
         */
        this.resizeEnd = new EventEmitter();
        /**
         * Fires when the user closes the Window.
         */
        this.close = new EventEmitter();
        /**
         * Fires when the `width` property of the component was updated. The event is triggered only after the resizing
         * has ended. The event data contains the new width. Allows a two-way binding of the `width` property.
         */
        this.widthChange = new EventEmitter();
        /**
         * Fires when the `height` property of the component was updated. The event is triggered only after the resizing
         * has ended. The event data contains the new height. Allows a two-way binding of the `height` property.
         */
        this.heightChange = new EventEmitter();
        /**
         * Fires when the `top` property of the component was updated. The event is triggered only after the dragging
         * and resizing have ended. The event data contains the new top offset. Allows a two-way binding of the `top` property.
         */
        this.topChange = new EventEmitter();
        /**
         * Fires when the `left` property of the component was updated. The event is triggered only after the dragging
         * and resizing have ended. The event data contains the new left offset. Allows a two-way binding of the `left` property.
         */
        this.leftChange = new EventEmitter();
        /**
         * Fires when the `state` property of the component was updated. The event data contains the new state. Allows a
         * two-way binding of the `state` property.
         */
        this.stateChange = new EventEmitter();
        this.tabIndex = 0;
        this.draged = false;
        this.resized = false;
        this.windowSubscription = new Subscription();
        this.direction = localization.rtl ? 'rtl' : 'ltr';
        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');
        this.resizeDirections = RESIZE_DIRECTIONS;
        this.subscribeEvents();
    }
    /**
     * Specifies whether the user will be able to drag the component.
     * @default true
     */
    set draggable(value) {
        this.options.draggable = value;
    }
    get draggable() {
        return this.options.draggable;
    }
    /**
     * Specifies whether the user will be able to resize the component.
     * @default true
     */
    set resizable(value) {
        this.options.resizable = value;
    }
    get resizable() {
        return this.options.resizable;
    }
    /**
     * Specifies the initial state of the component.
     * If not specified, the value is set to `default`.
     *
     * The possible values are:
     * * `minimized`
     * * `maximized`
     * * `default`
     */
    set state(value) {
        this.options.state = value;
    }
    get state() {
        return this.options.state;
    }
    /**
     * Specifies the minimum width of the component.
     * The `minWidth` property has to be set in pixels.
     * @default 120
     */
    set minWidth(value) {
        this.setOption('minWidth', value);
    }
    get minWidth() {
        return this.options.minWidth;
    }
    /**
     * Specifies the minimum height of the Window.
     * The `minHeight` property has to be set in pixels.
     * @default 100
     */
    set minHeight(value) {
        this.setOption('minHeight', value);
    }
    get minHeight() {
        return this.options.minHeight;
    }
    /**
     * Specifies the width of the Window.
     * The `width` property has to be set in pixels.
     */
    set width(value) {
        this.setOption('width', value);
    }
    get width() {
        return this.options.width;
    }
    /**
     * Specifies the height of the Window.
     * The `height` property has to be set in pixels.
     */
    set height(value) {
        this.setOption('height', value);
    }
    get height() {
        return this.options.height;
    }
    /**
     * Specifies the initial top offset of the Window.
     * The `top` property has to be set in pixels.
     */
    set top(value) {
        this.setOption('top', value);
    }
    get top() {
        return this.options.top;
    }
    /**
     * Specifies the initial left offset of the Window.
     * Numeric values are treated as pixels.
     */
    set left(value) {
        this.setOption('left', value);
    }
    get left() {
        return this.options.left;
    }
    get hostClasses() {
        return true;
    }
    get dir() {
        return this.direction;
    }
    ngAfterViewInit() {
        this.setNextZIndex();
        this.setInitialOffset();
        this.handleInitialFocus();
    }
    ngOnInit() {
        this.renderer.removeAttribute(this.el.nativeElement, 'title');
        this.service.init(this.el);
    }
    ngOnChanges(changes) {
        OFFSET_STYLES.forEach((style) => {
            if (isChanged(style, changes)) {
                this.setStyle(style, this.options[style]);
            }
        });
        if (isChanged('draggable', changes)) {
            const titleBar = isPresent(this.titleBarContent) ? this.titleBarContent : this.titleBarView;
            if (isTruthy(changes.draggable.currentValue)) {
                titleBar.subscribeDrag();
            }
            else {
                titleBar.unsubscribeDrag();
            }
        }
        if (isChanged('state', changes)) {
            if (isPresent(this.service.lastAction)) {
                this.service.lastAction = null;
            }
            else {
                this.service.applyManualState();
                this.updateAllOffset();
            }
        }
    }
    ngOnDestroy() {
        if (this.windowSubscription) {
            this.windowSubscription.unsubscribe();
        }
        this.localizationChangeSubscription.unsubscribe();
    }
    /**
     * Focuses the wrapper of the Window component.
     */
    focus() {
        const wrapper = this.el.nativeElement;
        if (isPresent(wrapper)) {
            wrapper.focus();
        }
    }
    /**
     * Brings the current Window component on top of other Window components on the page.
     */
    bringToFront() {
        this.setNextZIndex();
    }
    /**
     * Manually updates the `width` or `height` option of the Window.
     * The required style will be applied to the Window wrapper element and the
     * corresponding property of the component instance will be updated.
     * This method is intended to be used for sizing dynamically created components using the
     * [`WindowService`]({% slug api_dialog_windowservice %})
     * @param {WindowDimensionSetting} dimension - The option that will be updated
     * @param {number} value - The value set in pixels
     */
    setDimension(dimension, value) {
        this.setOption(dimension, value);
        this.setStyle(dimension, value);
    }
    /**
     * Manually updates the `top` or `left` offset of the Window.
     * The required style will be applied to the Window wrapper element and the
     * corresponding property of the component instance will be updated.
     * This method is intended to be used for positioning dynamically created components using the
     * [`WindowService`]({% slug api_dialog_windowservice %})
     * @param {WindowOffsetSetting} offset - The option that will be updated
     * @param {number} value - The value set in pixels
     */
    setOffset(offset, value) {
        this.setOption(offset, value);
        this.setStyle(offset, value);
    }
    get showDefaultTitleBar() {
        return !isPresent(this.titleBarContent);
    }
    get windowClasses() {
        return true;
    }
    get styleMinWidth() {
        return this.minWidth + 'px';
    }
    get styleMinHeight() {
        return this.minHeight + 'px';
    }
    get stylePosition() {
        return this.options.position;
    }
    get wrapperMaximizedClass() {
        return this.state === 'maximized';
    }
    /**
     * @hidden
     */
    onComponentKeydown(event) {
        if (hasClasses(event.target, WINDOW_CLASSES)) {
            this.navigation.process(event);
        }
    }
    /**
     * @hidden
     */
    onComponentFocus() {
        this.renderer.addClass(this.el.nativeElement, 'k-state-focused');
        this.setNextZIndex();
    }
    /**
     * @hidden
     */
    onComponentBlur() {
        this.renderer.removeClass(this.el.nativeElement, 'k-state-focused');
    }
    subscribeEvents() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.windowSubscription.add(this.service.focus.subscribe(() => {
            this.el.nativeElement.focus();
        }));
        this.windowSubscription.add(this.service.dragStart.subscribe(() => {
            this.draged = true;
            this.ngZone.run(() => {
                this.dragStart.emit();
            });
        }));
        this.windowSubscription.add(this.service.dragEnd.subscribe(() => {
            if (this.draged) {
                this.draged = false;
                this.ngZone.run(() => {
                    this.dragEnd.emit();
                });
            }
        }));
        this.windowSubscription.add(this.service.close.subscribe(() => {
            this.close.emit();
        }));
        this.windowSubscription.add(this.service.resizeStart.subscribe(() => {
            this.resized = true;
            this.ngZone.run(() => {
                this.resizeStart.emit();
            });
        }));
        this.windowSubscription.add(this.service.resizeEnd.subscribe(() => {
            if (this.resized) {
                this.resized = false;
                this.ngZone.run(() => {
                    this.resizeEnd.emit();
                });
            }
        }));
        this.windowSubscription.add(this.service.change.subscribe((ev) => {
            OFFSET_STYLES.forEach((style) => {
                if (isPresent(ev[style])) {
                    this.setStyle(style, ev[style]);
                    if (this.state !== 'maximized') {
                        const emitter = this[style + 'Change'];
                        if (emitter.observers.length) {
                            this.ngZone.run(() => {
                                emitter.emit(ev[style]);
                            });
                        }
                    }
                }
            });
        }));
        this.windowSubscription.add(this.service.stateChange.subscribe((state) => {
            if (isPresent(this.service.lastAction)) {
                this.updateAllOffset();
                this.stateChange.emit(state);
            }
        }));
    }
    setNextZIndex() {
        const currentZIndex = this.el.nativeElement.style['z-index'];
        const nextPossibleZIndex = this.service.nextPossibleZIndex;
        if (!currentZIndex || (nextPossibleZIndex - currentZIndex > 1)) {
            this.renderer.setStyle(this.el.nativeElement, "z-index", this.service.nextZIndex);
        }
    }
    setInitialOffset() {
        if (this.state !== 'maximized') {
            this.updateAllOffset();
            if (!isPresent(this.left) || !isPresent(this.top)) {
                this.service.center();
            }
        }
        else {
            const viewPort = this.service.windowViewPort;
            this.setStyle('width', viewPort.width);
            this.setStyle('height', viewPort.height);
            this.setStyle('top', 0);
            this.setStyle('left', 0);
        }
    }
    updateAllOffset() {
        OFFSET_STYLES.forEach((style) => {
            if (isPresent(this[style])) {
                this.setStyle(style, this[style]);
            }
            else {
                this.removeStyle(style);
            }
        });
    }
    setStyle(style, value) {
        this.renderer.setStyle(this.el.nativeElement, style, value + 'px');
    }
    removeStyle(style) {
        this.renderer.removeStyle(this.el.nativeElement, style);
    }
    get options() {
        return this.service.options;
    }
    setOption(style, value) {
        if (typeof value !== 'number' && typeof value !== 'string') {
            return;
        }
        const parsedValue = (typeof value === 'number') ? value : parseInt(value, 10);
        this.options[style] = parsedValue;
        this.service.setRestoreOption(style, parsedValue);
    }
    handleInitialFocus() {
        const wrapper = this.el.nativeElement;
        if (this.autoFocusedElement) {
            const initiallyFocusedElement = wrapper.querySelector(this.autoFocusedElement);
            if (initiallyFocusedElement) {
                initiallyFocusedElement.focus();
            }
        }
        else {
            this.focus();
        }
    }
}
WindowComponent.decorators = [
    { type: Component, args: [{
                exportAs: 'kendoWindow',
                providers: [
                    DragResizeService,
                    NavigationService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.window'
                    }
                ],
                selector: 'kendo-window',
                template: `
        <kendo-window-titlebar *ngIf="showDefaultTitleBar" [template]="titleBarTemplate">
            <div class="k-window-title">{{title}}</div>
            <button kendoWindowMinimizeAction></button>
            <button kendoWindowMaximizeAction></button>
            <button kendoWindowRestoreAction></button>
            <button kendoWindowCloseAction></button>
        </kendo-window-titlebar>
        <ng-content select="kendo-window-titlebar" *ngIf="!showDefaultTitleBar"></ng-content>

        <div *ngIf="state !== 'minimized' || keepContent"
            [hidden]="state === 'minimized' && keepContent"
            class="k-content k-window-content">
            <ng-content *ngIf="!contentTemplate"></ng-content>
            <ng-template [ngTemplateOutlet]="contentTemplate" *ngIf="contentTemplate"></ng-template>
        </div>

        <ng-template [ngIf]='resizable'>
            <div *ngFor='let dir of resizeDirections'
                [direction]="dir"
                kendoWindowResizeHandle
                kendoWindowDraggable>
            </div>
        </ng-template>
    `
            },] },
];
/** @nocollapse */
WindowComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: DragResizeService, },
    { type: NavigationService, },
    { type: NgZone, },
    { type: LocalizationService, },
];
WindowComponent.propDecorators = {
    'autoFocusedElement': [{ type: Input },],
    'title': [{ type: Input },],
    'draggable': [{ type: Input },],
    'resizable': [{ type: Input },],
    'keepContent': [{ type: Input },],
    'state': [{ type: Input },],
    'minWidth': [{ type: Input },],
    'minHeight': [{ type: Input },],
    'width': [{ type: Input },],
    'height': [{ type: Input },],
    'top': [{ type: Input },],
    'left': [{ type: Input },],
    'dragStart': [{ type: Output },],
    'dragEnd': [{ type: Output },],
    'resizeStart': [{ type: Output },],
    'resizeEnd': [{ type: Output },],
    'close': [{ type: Output },],
    'widthChange': [{ type: Output },],
    'heightChange': [{ type: Output },],
    'topChange': [{ type: Output },],
    'leftChange': [{ type: Output },],
    'stateChange': [{ type: Output },],
    'tabIndex': [{ type: HostBinding, args: ['attr.tabIndex',] },],
    'hostClasses': [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-window',] },],
    'dir': [{ type: HostBinding, args: ['attr.dir',] },],
    'titleBarView': [{ type: ViewChild, args: [WindowTitleBarComponent,] },],
    'titleBarContent': [{ type: ContentChild, args: [WindowTitleBarComponent,] },],
    'resizeHandles': [{ type: ViewChildren, args: [ResizeHandleDirective,] },],
    'windowClasses': [{ type: HostBinding, args: ['class.k-window-wrapper',] },],
    'styleMinWidth': [{ type: HostBinding, args: ['style.minWidth',] },],
    'styleMinHeight': [{ type: HostBinding, args: ['style.minHeight',] },],
    'stylePosition': [{ type: HostBinding, args: ['style.position',] },],
    'wrapperMaximizedClass': [{ type: HostBinding, args: ['class.k-window-maximized',] },],
    'onComponentKeydown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
    'onComponentFocus': [{ type: HostListener, args: ['focus',] },],
    'onComponentBlur': [{ type: HostListener, args: ['blur',] },],
};
