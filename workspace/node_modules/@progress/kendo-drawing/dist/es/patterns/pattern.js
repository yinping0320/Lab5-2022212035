import { Size, Rect as geomRect, Circle as geomCircle } from '../geometry';
import { Rect as drawRect, Circle as drawCircle, Path } from '../drawing';
import Group from '../shapes/group';
import { definitionId } from '../util';
import { PATTERN } from '../core/constants';

var defaultColor = "#aba4a6";
var defaultLine = { width: 2, gap: 18 };
var defaultDot = { radius: 10, gap: 10 };
var defaultGrid = { size: 18, gap: 2 };

export var Pattern = (function (Group) {
    function Pattern(options) {
        Group.call(this);

        var width = options.width;
        var height = options.height;
        this._size = Size.create([width, height]);
        this.id = definitionId();
    }

    if ( Group ) Pattern.__proto__ = Group;
    Pattern.prototype = Object.create( Group && Group.prototype );
    Pattern.prototype.constructor = Pattern;

    var prototypeAccessors = { nodeType: { configurable: true } };

    prototypeAccessors.nodeType.get = function () {
        return PATTERN;
    };

    Pattern.prototype.size = function size (value) {
        if (value) {
            this._size = Size.create(value);
            return this;
        }

        return this._size;
    };

    Object.defineProperties( Pattern.prototype, prototypeAccessors );

    return Pattern;
}(Group));

var drawBackground = function (pattern, color, size) {
    if (color) {
        pattern.append(
            new drawRect(new geomRect([0, 0], size), { fill: { color: color }, stroke: null })
        );
    }
};

export function dotsPattern(options) {
    if ( options === void 0 ) options = {};

    var gap = options.gap; if ( gap === void 0 ) gap = defaultDot.gap;
    var radius = options.radius; if ( radius === void 0 ) radius = defaultDot.radius;
    var color = options.color; if ( color === void 0 ) color = defaultColor;
    var background = options.background;
    var shapeOptions = { fill: { color: color }, stroke: null };
    var size = 4 * radius + 2 * gap;
    var yC2 = 3 * radius + 1.5 * gap;
    var center1 = [size / 2, radius + 1/2 * gap];
    var center2 = [0, yC2];
    var center3 = [size, yC2];

    var pattern = new Pattern({ width: size, height: size });

    drawBackground(pattern, background, [size, size]);

    pattern.append(
        new drawCircle(new geomCircle(center1, radius), shapeOptions),
        new drawCircle(new geomCircle(center2, radius), shapeOptions),
        new drawCircle(new geomCircle(center3, radius), shapeOptions)
    );

    return pattern;
};

export function verticalStripesPattern(options) {
    if ( options === void 0 ) options = {};

    var gap = options.gap; if ( gap === void 0 ) gap = defaultLine.gap;
    var width = options.width; if ( width === void 0 ) width = defaultLine.width;
    var color = options.color; if ( color === void 0 ) color = defaultColor;
    var background = options.background;
    var size = width + gap;
    var shapeOptions = { fill: null, stroke: { color: color, width: width / 2 } };
    var pattern = new Pattern({ width: size, height: size });

    drawBackground(pattern, background, [size, size]);

    var xStart = width / 4;
    var xEnd = size - width / 4;

    var startLine = new Path(shapeOptions);
    startLine.moveTo(xStart, 0).lineTo(xStart, size);

    var endLine = new Path(shapeOptions);
    endLine.moveTo(xEnd, 0).lineTo(xEnd, size);

    pattern.append(startLine, endLine);

    return pattern;
};

export function crosshatchPattern(options) {
    if ( options === void 0 ) options = {};

    var gap = options.gap; if ( gap === void 0 ) gap = defaultLine.gap;
    var width = options.width; if ( width === void 0 ) width = defaultLine.width;
    var color = options.color; if ( color === void 0 ) color = defaultColor;
    var background = options.background;
    var size = Math.sqrt(2) * (width + gap);
    var shapeOptions = { fill: null, stroke: { color: color, width: width } };
    var pattern = new Pattern({ width: size, height: size });

    drawBackground(pattern, background, [size, size]);

    var line1 = new Path(shapeOptions);
    line1.moveTo(0, 0).lineTo(size, size);

    var line2 = new Path(shapeOptions);
    line2.moveTo(size, 0).lineTo(0, size);

    pattern.append(line1, line2);

    return pattern;
};

export function diagonalStripesPattern(options) {
    if ( options === void 0 ) options = {};

    var gap = options.gap; if ( gap === void 0 ) gap = defaultLine.gap;
    var width = options.width; if ( width === void 0 ) width = defaultLine.width;
    var color = options.color; if ( color === void 0 ) color = defaultColor;
    var background = options.background;
    var size = Math.sqrt(2) * (width + gap);
    var shapeOptions = { fill: null, stroke: { color: color, width: width, lineCap: 'square' } };
    var pattern = new Pattern({ width: size, height: size });
    
    drawBackground(pattern, background, [size, size]);

    var line1 = new Path(shapeOptions);
    line1.moveTo(0, size / 2).lineTo(size / 2, 0);

    var line2 = new Path(shapeOptions);
    line2.moveTo(size / 2, size).lineTo(size, size / 2);

    pattern.append(line1, line2);

    return pattern;
};

export function gridPattern(options) {
    if ( options === void 0 ) options = {};

    var gap = options.gap; if ( gap === void 0 ) gap = defaultGrid.gap;
    var squareSize = options.size; if ( squareSize === void 0 ) squareSize = defaultGrid.size;
    var color = options.color; if ( color === void 0 ) color = defaultColor;
    var background = options.background;
    var size = squareSize + gap;
    var halfGap = gap / 2;
    var shapeOptions = { fill: { color: color }, stroke: null };
    var pattern = new Pattern({ width: size, height: size });

    drawBackground(pattern, background, [size, size]);

    var rect = new drawRect(new geomRect([halfGap, halfGap], [squareSize, squareSize]), shapeOptions);
    pattern.append(rect);

    return pattern;
};
