import { BindingData, ViewModel } from '@farris/devkit';
import { QDPCacheUtil, RtfServices, SchemaManagerService, RestfulService, DataRenderExtendService, Server_Host, EventBus, FilterManagerService, Load_Data_Uri, Load_Data_Col } from '@qdp/common';
import { CacheService, SessionService } from '@ecp-caf/caf-common';
import { of, EMPTY, fromEvent, Observable, Subject } from 'rxjs';
import { debounceTime, switchMap, map } from 'rxjs/operators';
import { Directive, ElementRef, EventEmitter, Input, NgZone, Output, Optional, Injector, Inject, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChangeFilter {
    /**
     * @param {?} _changes
     */
    constructor(_changes) {
        this._changes = _changes;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    static of(changes) {
        return new ChangeFilter(changes);
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    notEmpty(key) {
        if (this._changes[key]) {
            /** @type {?} */
            const value = this._changes[key].currentValue;
            if (value !== undefined && value !== null) {
                return of(value);
            }
        }
        return EMPTY;
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    has(key) {
        if (this._changes[key]) {
            /** @type {?} */
            const value = this._changes[key].currentValue;
            return of(value);
        }
        return EMPTY;
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    notFirst(key) {
        if (this._changes[key] && !this._changes[key].isFirstChange()) {
            /** @type {?} */
            const value = this._changes[key].currentValue;
            return of(value);
        }
        return EMPTY;
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    notFirstAndEmpty(key) {
        if (this._changes[key] && !this._changes[key].isFirstChange()) {
            /** @type {?} */
            const value = this._changes[key].currentValue;
            if (value !== undefined && value !== null) {
                return of(value);
            }
        }
        return EMPTY;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxEchartsDirective {
    /**
     * @param {?} el
     * @param {?} ngZone
     */
    constructor(el, ngZone) {
        this.el = el;
        this.ngZone = ngZone;
        this.autoResize = true;
        this.loadingType = 'default';
        this.detectEventChanges = true; // deprecated, left for compatibility reasons to avoid triggering major version
        // deprecated, left for compatibility reasons to avoid triggering major version
        // ngx-echarts events
        this.chartInit = new EventEmitter();
        // echarts mouse events
        this.chartClick = this.createLazyEvent('click');
        this.chartDblClick = this.createLazyEvent('dblclick');
        this.chartMouseDown = this.createLazyEvent('mousedown');
        this.chartMouseMove = this.createLazyEvent('mousemove');
        this.chartMouseUp = this.createLazyEvent('mouseup');
        this.chartMouseOver = this.createLazyEvent('mouseover');
        this.chartMouseOut = this.createLazyEvent('mouseout');
        this.chartGlobalOut = this.createLazyEvent('globalout');
        this.chartContextMenu = this.createLazyEvent('contextmenu');
        // echarts mouse events
        this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');
        this.chartLegendSelected = this.createLazyEvent('legendselected');
        this.chartLegendUnselected = this.createLazyEvent('legendunselected');
        this.chartLegendScroll = this.createLazyEvent('legendscroll');
        this.chartDataZoom = this.createLazyEvent('datazoom');
        this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');
        this.chartTimelineChanged = this.createLazyEvent('timelinechanged');
        this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');
        this.chartRestore = this.createLazyEvent('restore');
        this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');
        this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');
        this.chartPieSelectChanged = this.createLazyEvent('pieselectchanged');
        this.chartPieSelected = this.createLazyEvent('pieselected');
        this.chartPieUnselected = this.createLazyEvent('pieunselected');
        this.chartMapSelectChanged = this.createLazyEvent('mapselectchanged');
        this.chartMapSelected = this.createLazyEvent('mapselected');
        this.chartMapUnselected = this.createLazyEvent('mapunselected');
        this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');
        this.chartFocusNodeAdjacency = this.createLazyEvent('focusnodeadjacency');
        this.chartUnfocusNodeAdjacency = this.createLazyEvent('unfocusnodeadjacency');
        this.chartBrush = this.createLazyEvent('brush');
        this.chartBrushSelected = this.createLazyEvent('brushselected');
        this.chartRendered = this.createLazyEvent('rendered');
        this.chartFinished = this.createLazyEvent('finished');
        this.currentOffsetWidth = 0;
        this.currentOffsetHeight = 0;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const filter = ChangeFilter.of(changes);
        filter.notFirstAndEmpty('options').subscribe((/**
         * @param {?} opt
         * @return {?}
         */
        opt => this.onOptionsChange(opt)));
        filter.notFirstAndEmpty('merge').subscribe((/**
         * @param {?} opt
         * @return {?}
         */
        opt => this.setOption(opt)));
        filter.has('loading').subscribe((/**
         * @param {?} v
         * @return {?}
         */
        v => this.toggleLoading(!!v)));
        filter.notFirst('theme').subscribe((/**
         * @return {?}
         */
        () => this.refreshChart()));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.resizeSub = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this.autoResize && window.innerWidth !== this.currentWindowWidth) {
                this.currentWindowWidth = window.innerWidth;
                this.currentOffsetWidth = this.el.nativeElement.offsetWidth;
                this.currentOffsetHeight = this.el.nativeElement.offsetHeight;
                this.resize();
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // tslint:disable-next-line:no-unused-expression
        this.resizeSub && this.resizeSub.unsubscribe();
        this.dispose();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        // No heavy work in DoCheck!
        if (this.chart && this.autoResize) {
            /** @type {?} */
            const offsetWidth = this.el.nativeElement.offsetWidth;
            /** @type {?} */
            const offsetHeight = this.el.nativeElement.offsetHeight;
            if (this.currentOffsetWidth !== offsetWidth || this.currentOffsetHeight !== offsetHeight) {
                this.currentOffsetWidth = offsetWidth;
                this.currentOffsetHeight = offsetHeight;
                this.resize();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => this.initChart()));
    }
    /**
     * @private
     * @return {?}
     */
    dispose() {
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    resize() {
        if (this.chart) {
            this.chart.resize();
        }
    }
    /**
     * @private
     * @param {?} loading
     * @return {?}
     */
    toggleLoading(loading) {
        if (this.chart) {
            loading ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading();
        }
    }
    // 保存visualMap
    /**
     * @param {?} option
     * @param {?=} opts
     * @return {?}
     */
    setOption(option, opts) {
        this.chart.setOption(option, opts);
    }
    /**
     * @return {?}
     */
    clearOption() {
        if (this.chart) {
            this.chart.clear();
        }
    }
    /**
     * @return {?}
     */
    getOption() {
        return this.chart.getOption();
    }
    /**
     * @private
     * @return {?}
     */
    refreshChart() {
        this.dispose();
        this.initChart();
    }
    /**
     * @private
     * @return {?}
     */
    createChart() {
        this.currentWindowWidth = window.innerWidth;
        this.currentOffsetWidth = this.el.nativeElement.offsetWidth;
        this.currentOffsetHeight = this.el.nativeElement.offsetHeight;
        /** @type {?} */
        const dom = this.el.nativeElement;
        if (window && window.getComputedStyle) {
            /** @type {?} */
            const prop = window.getComputedStyle(dom, null).getPropertyValue('height');
            if ((!prop || prop === '0px') &&
                (!dom.style.height || dom.style.height === '0px')) {
                dom.style.height = '400px';
            }
        }
        return this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => echarts.init(dom, this.theme, this.initOpts)));
    }
    /**
     * @private
     * @return {?}
     */
    initChart() {
        this.onOptionsChange(this.options);
        if (this.merge && this.chart) {
            this.setOption(this.merge);
        }
    }
    /**
     * @private
     * @param {?} opt
     * @return {?}
     */
    onOptionsChange(opt) {
        if (opt) {
            if (!this.chart) {
                this.chart = this.createChart();
                this.chartInit.emit(this.chart);
            }
            this.chart.setOption(this.options, true);
        }
        else {
            if (!this.chart) {
                this.chart = this.createChart();
                this.chartInit.emit(this.chart);
            }
        }
    }
    // allows to lazily bind to only those events that are requested through the `@Output` by parent components
    // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info
    /**
     * @private
     * @template T
     * @param {?} eventName
     * @return {?}
     */
    createLazyEvent(eventName) {
        return (/** @type {?} */ (this.chartInit.pipe(switchMap((/**
         * @param {?} chart
         * @return {?}
         */
        (chart) => new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            chart.on(eventName, (/**
             * @param {?} data
             * @return {?}
             */
            (data) => this.ngZone.run((/**
             * @return {?}
             */
            () => observer.next(data)))));
            return null; // no need to react on unsubscribe as long as the `dispose()` is called in ngOnDestroy
        })))))));
    }
    /**
     * @param {?} data1
     * @param {?} num
     * @return {?}
     */
    setNumber(data1, num) {
        /** @type {?} */
        const arr = [];
        /** @type {?} */
        const l = data1.length;
        for (let i = 0; i < l; i++) {
            arr[i] = data1[i][num];
        }
        return arr;
    }
    /**
     * @param {?} data
     * @param {?=} option
     * @return {?}
     */
    setData(data, option) {
        if (this.chart) {
            this.chart.clear();
        }
        data.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item.dynamicPropSet) {
                /** @type {?} */
                const dy = item.dynamicPropSet;
                delete item.dynamicPropSet;
                Object.assign(item, dy);
            }
        }));
        if (data && data.length) {
            this.chartsData = {
                dataset: {
                    dimensions: [],
                    source: []
                }
            };
            Object.keys(data[0]).forEach((/**
             * @param {?} key
             * @return {?}
             */
            key => {
                this.chartsData.dataset.dimensions.push(key);
            }));
            data.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                /** @type {?} */
                const row = [];
                Object.keys(item).forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                key => {
                    row.push(item[key]);
                }));
                this.chartsData.dataset.source.push(row);
            }));
            if (option) {
                if (option.series && option.series.type && option.series.type === 'pie') {
                    /** @type {?} */
                    const resultOption = {
                        title: option.title,
                        dataset: this.chartsData.dataset,
                        tooltip: {
                            formatter: '{d}%',
                        },
                        series: [{
                                type: option.series.type,
                                encode: {
                                    value: option.series.encode.y[0],
                                    itemName: option.series.encode.x[0],
                                },
                            }]
                    };
                    resultOption.dataset.source.splice(0, 0, resultOption.dataset.dimensions);
                    this.chart.setOption(resultOption);
                }
                else if (option.series && (option.series.type === 'line' || option.series.type === 'scatter')) {
                    option.dataset = this.chartsData.dataset;
                    this.setZoom(option);
                    /** @type {?} */
                    const row1 = this.chartsData.dataset.dimensions.indexOf(option.series.encode.y[0]);
                    option.visualMap[0].dimension = row1;
                    option.visualMap[0].min = Math.min.apply(null, this.setNumber(this.chartsData.dataset.source, row1));
                    option.visualMap[0].max = Math.max.apply(null, this.setNumber(this.chartsData.dataset.source, row1));
                    option.dataset.source.splice(0, 0, option.dataset.dimensions);
                    this.chart.setOption(option);
                }
                else if (option.series && option.series.type && option.series.type === 'effectScatter') {
                    option.dataset = this.chartsData.dataset;
                    if (option.series.encode.value2.length === 0) {
                        /** @type {?} */
                        const row1 = this.chartsData.dataset.dimensions.indexOf(option.series.encode.value1[0]);
                        option.visualMap[0].dimension = row1;
                        option.visualMap[0].min = Math.min.apply(null, this.setNumber(this.chartsData.dataset.source, row1));
                        option.visualMap[0].max = Math.max.apply(null, this.setNumber(this.chartsData.dataset.source, row1));
                        /** @type {?} */
                        const row2 = this.chartsData.dataset.dimensions.indexOf(option.series.encode.value1[0]);
                        option.visualMap[1].dimension = row2;
                        option.visualMap[1].min = Math.min.apply(null, this.setNumber(this.chartsData.dataset.source, row2));
                        option.visualMap[1].max = Math.max.apply(null, this.setNumber(this.chartsData.dataset.source, row2));
                    }
                    else {
                        /** @type {?} */
                        const row = this.chartsData.dataset.dimensions.indexOf(option.series.encode.value1[0]);
                        option.visualMap[0].dimension = row;
                        option.visualMap[0].min = Math.min.apply(null, this.setNumber(this.chartsData.dataset.source, row));
                        option.visualMap[0].max = Math.max.apply(null, this.setNumber(this.chartsData.dataset.source, row));
                        /** @type {?} */
                        const row2 = this.chartsData.dataset.dimensions.indexOf(option.series.encode.value2[0]);
                        option.visualMap[1].dimension = row2;
                        option.visualMap[1].min = Math.min.apply(null, this.setNumber(this.chartsData.dataset.source, row2));
                        option.visualMap[1].max = Math.max.apply(null, this.setNumber(this.chartsData.dataset.source, row2));
                    }
                    option.dataset.source.splice(0, 0, option.dataset.dimensions);
                    this.chart.setOption(option);
                }
                else if (option.series && option.series.type === 'bar') {
                    if (option.series.encode.y && option.series.encode.y.length < 2) {
                        /** @type {?} */
                        const arrayTemp1 = [];
                        /** @type {?} */
                        const arrayTemp2 = [];
                        // tslint:disable-next-line:prefer-for-of
                        for (let i = 0; i < this.chartsData.dataset.source.length; i++) {
                            arrayTemp1.push(this.chartsData.dataset.source[i][this.chartsData.dataset.dimensions.indexOf(option.series.encode.x[0])]);
                            arrayTemp2.push(this.chartsData.dataset.source[i][this.chartsData.dataset.dimensions.indexOf(option.series.encode.y[0])]);
                        }
                        /** @type {?} */
                        const isRepeat = Array.from(new Set(arrayTemp1)).length - arrayTemp1.length;
                        if (isRepeat === 0) {
                            option.dataset = this.chartsData.dataset;
                            this.setZoom(option);
                            /** @type {?} */
                            const row1 = this.chartsData.dataset.dimensions.indexOf(option.series.encode.y[0]);
                            option.legend = {};
                            option.visualMap[0].dimension = row1;
                            option.visualMap[0].min = Math.min.apply(null, this.setNumber(this.chartsData.dataset.source, row1));
                            option.visualMap[0].max = Math.max.apply(null, this.setNumber(this.chartsData.dataset.source, row1));
                            option.dataset.source.splice(0, 0, option.dataset.dimensions);
                            this.chart.setOption(option);
                        }
                        // 分组，重新设置数据格式和处理逻辑
                        if (isRepeat < 0) {
                            option.visualMap = [];
                            option.dataset = this.chartsData.dataset;
                            this.setZoom(option);
                            /** @type {?} */
                            const ob = [];
                            for (let i = 0; i < arrayTemp1.length; i++) {
                                ob.push({
                                    name: arrayTemp1[i],
                                    value: arrayTemp2[i]
                                });
                            }
                            /** @type {?} */
                            const hash = {};
                            /** @type {?} */
                            let i = 0;
                            /** @type {?} */
                            const res = [];
                            ob.forEach((/**
                             * @param {?} item
                             * @return {?}
                             */
                            function (item) {
                                /** @type {?} */
                                const name = item.name;
                                hash[name] ? res[hash[name] - 1].value.push(item.value) : hash[name] = ++i && res.push({
                                    name: name,
                                    value: [item.value],
                                });
                            }));
                            // 拿到对象数组进行转置
                            /** @type {?} */
                            const xdata = [];
                            /** @type {?} */
                            let max = 0;
                            res.forEach((/**
                             * @param {?} item
                             * @return {?}
                             */
                            function (item) {
                                xdata.push(item.name);
                                if (item.value.length + 1 > max) {
                                    max = item.value.length + 1;
                                }
                            }));
                            /** @type {?} */
                            const series = [];
                            /** @type {?} */
                            const legendData = [];
                            for (let i = 1; i < max; i++) {
                                legendData.push(i + '次');
                                series.push({
                                    name: i + '次',
                                    type: 'bar',
                                    stack: '总量',
                                    data: [],
                                });
                            }
                            res.forEach((/**
                             * @param {?} item
                             * @return {?}
                             */
                            function (item) {
                                for (let i = 0; i < max - 1; i++) {
                                    if (item.value[i]) {
                                        series[i].data.push(item.value[i]);
                                    }
                                    else {
                                        series[i].data.push(0);
                                    }
                                }
                            }));
                            option.xAxis = [{ data: xdata }];
                            option.series = series;
                            option.legend = { data: legendData };
                            this.chart.setOption(option);
                            return;
                        }
                    }
                    else if (option.series.encode.y && option.series.encode.y.length > 1) {
                        option.dataset = this.chartsData.dataset;
                        this.setZoom(option);
                        option.visualMap = [];
                        /** @type {?} */
                        const seriesChange = [];
                        // legend data
                        /** @type {?} */
                        const yList = option.series.encode.y;
                        for (let i = 0; i < yList.length; i++) {
                            /** @type {?} */
                            const temp = {
                                type: option.series.type,
                                name: option.legend.data[i],
                                encode: {
                                    x: option.series.encode.x,
                                    y: [yList[i]],
                                },
                                label: {
                                    normal: {
                                        show: true,
                                        position: 'insideTop'
                                    }
                                },
                            };
                            if (option.title.id && option.title.id === 'pile') {
                                temp.stack = '总量';
                                delete temp.label;
                            }
                            seriesChange.push(temp);
                        }
                        option.series = seriesChange;
                        option.dataset.source.splice(0, 0, option.dataset.dimensions);
                        this.chart.setOption(option);
                    }
                }
            }
        }
    }
    /**
     * @param {?} op
     * @return {?}
     */
    setZoom(op) {
        /** @type {?} */
        let dataZoom = [];
        if (op.dataset.source.length > 9) {
            dataZoom = [{
                    id: 'dataZoomX',
                    type: 'slider',
                    xAxisIndex: [0],
                    filterMode: 'filter'
                }];
            op.dataZoom = dataZoom;
        }
    }
}
NgxEchartsDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'qdp-charts, [qdp-charts]',
            },] }
];
/** @nocollapse */
NgxEchartsDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
NgxEchartsDirective.propDecorators = {
    queryId: [{ type: Input }],
    options: [{ type: Input }],
    theme: [{ type: Input }],
    loading: [{ type: Input }],
    queryRelativeUrl: [{ type: Input }],
    initOpts: [{ type: Input }],
    merge: [{ type: Input }],
    autoResize: [{ type: Input }],
    loadingType: [{ type: Input }],
    loadingOpts: [{ type: Input }],
    detectEventChanges: [{ type: Input }],
    chartInit: [{ type: Output }],
    chartClick: [{ type: Output }],
    chartDblClick: [{ type: Output }],
    chartMouseDown: [{ type: Output }],
    chartMouseMove: [{ type: Output }],
    chartMouseUp: [{ type: Output }],
    chartMouseOver: [{ type: Output }],
    chartMouseOut: [{ type: Output }],
    chartGlobalOut: [{ type: Output }],
    chartContextMenu: [{ type: Output }],
    chartLegendSelectChanged: [{ type: Output }],
    chartLegendSelected: [{ type: Output }],
    chartLegendUnselected: [{ type: Output }],
    chartLegendScroll: [{ type: Output }],
    chartDataZoom: [{ type: Output }],
    chartDataRangeSelected: [{ type: Output }],
    chartTimelineChanged: [{ type: Output }],
    chartTimelinePlayChanged: [{ type: Output }],
    chartRestore: [{ type: Output }],
    chartDataViewChanged: [{ type: Output }],
    chartMagicTypeChanged: [{ type: Output }],
    chartPieSelectChanged: [{ type: Output }],
    chartPieSelected: [{ type: Output }],
    chartPieUnselected: [{ type: Output }],
    chartMapSelectChanged: [{ type: Output }],
    chartMapSelected: [{ type: Output }],
    chartMapUnselected: [{ type: Output }],
    chartAxisAreaSelected: [{ type: Output }],
    chartFocusNodeAdjacency: [{ type: Output }],
    chartUnfocusNodeAdjacency: [{ type: Output }],
    chartBrush: [{ type: Output }],
    chartBrushSelected: [{ type: Output }],
    chartRendered: [{ type: Output }],
    chartFinished: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormBindingDataDirective {
    /**
     * @param {?} charts
     * @param {?} bindingData
     * @param {?} viewModel
     * @param {?} schemaManager
     * @param {?} injector
     */
    constructor(charts, bindingData, viewModel, schemaManager, injector) {
        this.charts = charts;
        this.bindingData = bindingData;
        this.viewModel = viewModel;
        this.schemaManager = schemaManager;
        this.injector = injector;
        this.delay = 0;
        this.interval = 0;
        if (this.injector) {
            this.cache = this.injector.get(CacheService);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        QDPCacheUtil.setCache(RtfServices.getTabId(this.queryId) + this.queryId + 'form-charts', this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.delayLoad();
    }
    /**
     * @return {?}
     */
    delayLoad() {
        if (!this.delay) {
            this.delay = 0;
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.bindingListChange();
            this.intervalLoad();
        }), this.delay);
    }
    /**
     * @return {?}
     */
    intervalLoad() {
        if (this.interval) {
            this.myVar = setInterval((/**
             * @return {?}
             */
            () => {
                this.bindingListChange();
            }), this.interval);
        }
    }
    /**
     * @return {?}
     */
    clearIntervalLoad() {
        if (this.myVar) {
            clearInterval(this.myVar);
        }
    }
    /**
     * @private
     * @return {?}
     */
    bindingListChange() {
        if (this.bindingData) {
            this.bindData();
            this.bindingData.changes.subscribe((/**
             * @param {?} change
             * @return {?}
             */
            (change) => {
                this.bindData();
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    bindData() {
        /** @type {?} */
        const self = this;
        if (this.bindingList) {
            /** @type {?} */
            let op;
            /** @type {?} */
            const organizationId = this.cache.get(RtfServices.getTabId(self.queryId) + 'organizationId') || '';
            this.schemaManager.getDefaultSchema(this.charts.queryId, this.charts.queryRelativeUrl, '', organizationId).subscribe((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                if (value) {
                    if (value.schemaValue.chartsType.series.type && value.schemaValue.chartsType.series.type !== -1) {
                        op = Object.assign({}, value.schemaValue.chartsData, value.schemaValue.chartsStyle);
                        value.schemaValue.chartsType.series.type = value.schemaValue.chartsType.series.type.replace('1', '');
                        op.series.type = value.schemaValue.chartsType.series.type;
                        if (op.series.type !== 'line1') {
                            delete op.series.areaStyle;
                        }
                        else {
                            op.series.areaStyle = {};
                        }
                    }
                }
                /** @type {?} */
                const dynamiccols = [];
                this.bindingList.properties.forEach((/**
                 * @param {?} col
                 * @return {?}
                 */
                col => {
                    /** @type {?} */
                    const dynamiccol = {};
                    dynamiccol.name = col.name;
                    dynamiccol.bindField = col.name;
                    dynamiccol.colWidth = 150;
                    dynamiccol.align = 0;
                    dynamiccol.visible = true;
                    dynamiccol.isFixed = false;
                    dynamiccol.formatType = 0;
                    dynamiccol.formattor = '';
                    dynamiccol.sort = 0;
                    dynamiccol.pageAggreText = null;
                    dynamiccol.pageAggre = 0;
                    dynamiccol.isGroup = false;
                    dynamiccol.groupAggreText = '';
                    dynamiccol.groupAggre = 0;
                    dynamiccol.totalAggreText = '';
                    dynamiccol.totalAggre = 0;
                    dynamiccol.level = 1;
                    dynamiccol.childList = [];
                    dynamiccol.dimension = 0;
                    dynamiccol.rowColor = null;
                    dynamiccols.push(dynamiccol);
                }));
                this.schemaManager.setColInfo(dynamiccols);
                if (op && op.series && op.series.type) {
                    op.series.type = op.series.type.replace('1', '');
                }
                this.charts.setData(this.bindingList.toJSON(), op);
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    get bindingList() {
        if (!this.bindingData || !this.viewModel) {
            return undefined;
        }
        // 根实体
        if (this.viewModel.bindingPath === '/' || !this.viewModel.bindingPath) {
            return this.bindingData.list;
        }
        // 子实体
        /** @type {?} */
        let bindingPath = this.viewModel.bindingPath.substr(1);
        bindingPath = bindingPath[0].toLowerCase() + bindingPath.substring(1, bindingPath.length);
        /** @type {?} */
        const paths = bindingPath.split('/');
        /** @type {?} */
        const filteredPaths = paths.filter((/**
         * @param {?} part
         * @return {?}
         */
        (part) => {
            return part !== '';
        }));
        return this.bindingData.getValue(filteredPaths);
    }
}
FormBindingDataDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'formBindingData, [formBindingData]',
            },] }
];
/** @nocollapse */
FormBindingDataDirective.ctorParameters = () => [
    { type: NgxEchartsDirective, decorators: [{ type: Optional }] },
    { type: BindingData, decorators: [{ type: Optional }] },
    { type: ViewModel, decorators: [{ type: Optional }] },
    { type: SchemaManagerService },
    { type: Injector, decorators: [{ type: Optional }] }
];
FormBindingDataDirective.propDecorators = {
    delay: [{ type: Input }],
    interval: [{ type: Input }],
    queryId: [{ type: Input }],
    controlType: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LcpBindingDataDirective {
    /**
     * @param {?} serverHost
     * @param {?} restfulService
     * @param {?} sessionService
     * @param {?} cache
     * @param {?} schemaManager
     * @param {?} charts
     * @param {?} dataRenderExtendService
     * @param {?} filterService
     * @param {?} loadDataUri
     * @param {?} loadDataCol
     * @param {?} injector
     */
    constructor(serverHost, restfulService, sessionService, cache, schemaManager, charts, dataRenderExtendService, filterService, loadDataUri, loadDataCol, injector) {
        this.serverHost = serverHost;
        this.restfulService = restfulService;
        this.sessionService = sessionService;
        this.cache = cache;
        this.schemaManager = schemaManager;
        this.charts = charts;
        this.dataRenderExtendService = dataRenderExtendService;
        this.filterService = filterService;
        this.loadDataUri = loadDataUri;
        this.loadDataCol = loadDataCol;
        this.injector = injector;
        this.delay = 0;
        this.interval = 0;
        this.funcIds = [];
        this.pageInfoChange = new Subject();
    }
    /**
     * @private
     * @return {?}
     */
    bindCloseTabEvent() {
        try {
            /** @type {?} */
            const tab = gspframeworkService.rtf.session.getCommonVariable();
            gspframeworkService.rtf.frmEvent.eventListener('beforeFuncCloseEvent', this.clearParametersCache.bind(this), tab);
            this.funcIds.push(tab.tabId);
            return tab.tabId + RtfServices.getInSuiteFrmUUID();
        }
        catch (e) {
        }
    }
    /**
     * @private
     * @return {?}
     */
    clearParametersCache() {
        /** @type {?} */
        const tabId = arguments[0].tabId;
        this.cache.set(this.queryId, '');
        this.cache.set(arguments[0].tabId, '');
        this.cache.set(arguments[0].tabId + 'renderMode', '');
        /** @type {?} */
        const index = this.funcIds.findIndex((/**
         * @param {?} el
         * @return {?}
         */
        el => el === tabId));
        if (index >= 0) {
            this.funcIds.splice(index, 1);
            gspframeworkService.rtf.func.close(arguments[0]);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.tabId = RtfServices.getTabId(this.queryId);
        QDPCacheUtil.setCache(this.tabId + this.queryId + 'lcp-charts', this);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const changeName in changes) {
            /** @type {?} */
            const newValue = changes[changeName].currentValue;
            if (newValue !== null && newValue !== void 0) {
                /** @type {?} */
                const eventId = RtfServices.getTabId(this.queryId);
                switch (changeName) {
                    case 'queryId':
                        this.queryId = newValue;
                        QDPCacheUtil.setCache(eventId + this.queryId + 'lcp-charts', this);
                        break;
                    case 'eventType':
                        if (newValue) {
                            EventBus.register(newValue, this.handleLinkage, eventId);
                        }
                        break;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // if (this.qoId) { // 查询结果集过滤条件
        this.filterService.getFilter(this.qoManagerCode, this.queryId, this.queryRelativeUrl, 1).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            if (data) {
                /** @type {?} */
                const conditionExpression = JSON.stringify(data.filter);
                this.render('', '', '', conditionExpression);
            }
            else {
                this.render('');
            }
        }));
        // } else {
        //   this.render('');
        // }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    handleLinkage($event) {
        try {
            /** @type {?} */
            const params = JSON.stringify($event);
            this.delayLoad('', {}, params, this.queryRelativeUrl);
        }
        catch (e) {
        }
    }
    /**
     * @param {?} schemaId
     * @param {?=} option
     * @param {?=} linkageParams
     * @param {?=} queryRelativeUrl
     * @param {?=} conditionExpression
     * @return {?}
     */
    delayLoad(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression) {
        if (!this.delay) {
            this.delay = 0;
        }
        if (this.delay === 0) {
            this.bindData(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression);
            this.intervalLoad(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression);
        }
        else {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.bindData(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression);
                this.intervalLoad(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression);
            }), this.delay);
        }
    }
    /**
     * @param {?} schemaId
     * @param {?=} option
     * @param {?=} linkageParams
     * @param {?=} queryRelativeUrl
     * @param {?=} conditionExpression
     * @return {?}
     */
    intervalLoad(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression) {
        if (this.interval) {
            this.myVar = setInterval((/**
             * @return {?}
             */
            () => {
                this.bindData(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression);
            }), this.interval);
        }
    }
    /**
     * @return {?}
     */
    clearIntervalLoad() {
        if (this.myVar) {
            clearInterval(this.myVar);
        }
    }
    /**
     * @param {?} schemaId
     * @param {?=} option
     * @param {?=} linkageParams
     * @param {?=} conditionExpression
     * @return {?}
     */
    render(schemaId, option, linkageParams, conditionExpression) {
        this.delayLoad(schemaId, option, linkageParams, this.queryRelativeUrl, conditionExpression);
    }
    /**
     * @param {?} params
     * @param {?} queryRelativeUrl
     * @return {?}
     */
    getData(params, queryRelativeUrl) {
        /** @type {?} */
        const self = this;
        /** @type {?} */
        let uri = this.serverHost;
        if (this.loadDataUri) {
            uri += this.loadDataUri;
        }
        else {
            uri += (!queryRelativeUrl || queryRelativeUrl === '') ? '/api/runtime/bcc/v1.0/qdpsearch/query' : (queryRelativeUrl + 'querydata');
        }
        /** @type {?} */
        const result$ = !queryRelativeUrl ? this.restfulService.post(uri, queryRelativeUrl ? { 'Param': params } : params, {}, this.createHeaderSessionId())
            : this.restfulService.put(uri, queryRelativeUrl ? { 'Param': params } : params, {}, this.createHeaderSessionId());
        return result$.pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            if (data) {
                data = (!queryRelativeUrl || queryRelativeUrl === '') ? data : data.returnValue;
                if (data && data.pageInfo) {
                    self.pageInfoChange.next(data.pageInfo);
                }
            }
            return data;
        })));
    }
    /**
     * @param {?} params
     * @param {?} queryRelativeUrl
     * @return {?}
     */
    getCol(params, queryRelativeUrl) {
        /** @type {?} */
        let uri = this.serverHost;
        if (this.loadDataCol) {
            uri += this.loadDataCol;
        }
        else {
            uri += ((!queryRelativeUrl || queryRelativeUrl === '') ? '/api/runtime/bcc/v1.0/qdpsearch/' : queryRelativeUrl) + 'querycol';
        }
        params = (!queryRelativeUrl || queryRelativeUrl === '') ? params : { 'Param': params };
        /** @type {?} */
        const result$ = !queryRelativeUrl ? this.restfulService.post(uri, params, {}, this.createHeaderSessionId())
            : this.restfulService.put(uri, params, {}, this.createHeaderSessionId());
        return result$.pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            if (data) {
                data = (!queryRelativeUrl || queryRelativeUrl === '') ? data : data.returnValue;
            }
            return data;
        })));
    }
    /**
     * @private
     * @param {?} queryId
     * @param {?} controlType
     * @param {?} schemaId
     * @param {?} qoManagerCode
     * @param {?} extendCond
     * @param {?} pageIndex
     * @param {?} pageSize
     * @param {?=} printIntegration
     * @param {?=} excelExportName
     * @param {?=} voId
     * @return {?}
     */
    createParameters(queryId, controlType, schemaId, qoManagerCode, extendCond, pageIndex, pageSize, printIntegration, excelExportName, voId) {
        /** @type {?} */
        let entityData;
        /** @type {?} */
        const tabId = this.bindCloseTabEvent();
        if (this.cache.get(tabId)) {
            entityData = JSON.stringify(this.cache.get(tabId));
        }
        else if (this.cache.get(queryId)) {
            entityData = JSON.stringify(this.cache.get(queryId));
        }
        else {
            entityData = JSON.stringify({ 'id': 'undefined_null' });
        }
        /** @type {?} */
        const params = {
            entityData: entityData,
            extendCond: extendCond,
            pageIndex: pageIndex,
            pageSize: pageSize,
            schemaId: schemaId && schemaId !== 'prefab' ? schemaId : '1',
            filterCond: this.cache.get(tabId + 'filtercondition') ? this.cache.get(tabId + 'filtercondition') : '',
            qoManagerCode: qoManagerCode ? qoManagerCode : '',
            voCode: voId ? voId : ''
        };
        try {
            /** @type {?} */
            const parameterEntityData = JSON.parse(entityData);
            if (parameterEntityData.hasOwnProperty('@filterExpressionString@')) {
                /** @type {?} */
                const filterExpression = params && params.filterCond ? JSON.parse(params.filterCond) : null;
                if (!filterExpression) {
                    params.filterCond = parameterEntityData['@filterExpressionString@'];
                }
                else {
                    /** @type {?} */
                    const advanceFilterExpression = JSON.parse(parameterEntityData['@filterExpressionString@']);
                    advanceFilterExpression.expressItems = advanceFilterExpression.expressItems.concat(filterExpression.expressItems);
                    params.filterCond = JSON.stringify(advanceFilterExpression);
                }
            }
        }
        catch (e) {
        }
        if (controlType) {
            params['controlType'] = controlType;
        }
        if (excelExportName) {
            params['excelExportName'] = excelExportName;
        }
        if (printIntegration) {
            params['printIntegration'] = printIntegration ? JSON.stringify(printIntegration) : '';
        }
        return params;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    getSchemaInfo(obj) {
        /** @type {?} */
        const self = this;
        obj.schemaId = obj.schemaId === 'prefab' ? '1' : obj.schemaId;
        if (!obj.schemaId) {
            return self.getDefaultSchemaInfo(obj);
        }
        else {
            /** @type {?} */
            const organizationId = this.cache.get(RtfServices.getTabId(obj.queryId) + 'organizationId') || '';
            /** @type {?} */
            const result$ = this.schemaManager.getSchema(obj.schemaId, obj.queryId, obj.queryRelativeUrl, obj.groupType, organizationId);
            return result$.pipe(switchMap((/**
             * @param {?} schemaValue
             * @return {?}
             */
            (schemaValue) => {
                if (schemaValue && schemaValue['id']) {
                    return of(schemaValue);
                }
                //  else {
                //   return self.getDefaultSchemaInfo(obj);
                // }
            })));
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    getDefaultSchemaInfo(obj) {
        /** @type {?} */
        const organizationId = this.cache.get(RtfServices.getTabId(obj.queryId) + 'organizationId') || '';
        return this.schemaManager.getDefaultSchema(obj.queryId, obj.queryRelativeUrl, obj.groupType, organizationId);
    }
    /**
     * @private
     * @param {?} schemaId
     * @param {?=} option
     * @param {?=} linkageParams
     * @param {?=} queryRelativeUrl
     * @param {?=} conditionExpression
     * @return {?}
     */
    bindData(schemaId, option, linkageParams, queryRelativeUrl, conditionExpression) {
        /** @type {?} */
        let op = option;
        this.getSchemaInfo({ schemaId: schemaId, queryId: this.charts.queryId, queryRelativeUrl }).subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            /** @type {?} */
            let _schemaId = '';
            if (schemaId) {
                _schemaId = schemaId;
            }
            if (value && !_schemaId) {
                _schemaId = value.id;
                if (value.schemaValue.chartsType.series.type && value.schemaValue.chartsType.series.type !== -1) {
                    op = Object.assign({}, value.schemaValue.chartsData, value.schemaValue.chartsStyle);
                    value.schemaValue.chartsType.series.type = value.schemaValue.chartsType.series.type.replace('1', '');
                    op.series.type = value.schemaValue.chartsType.series.type;
                    if (op.series.type !== 'line1') {
                        delete op.series.areaStyle;
                    }
                    else {
                        op.series.areaStyle = {};
                    }
                }
            }
            if (value && value.schemaValue && value.schemaValue.customOption) {
                try {
                    op = Object.assign({}, op, JSON.parse(value.schemaValue.customOption));
                }
                catch (e) {
                    op = Object.assign({}, op, value.schemaValue.customOption);
                }
            }
            /** @type {?} */
            let entityData = '';
            if (this.cache.get(this.charts.queryId)) {
                entityData = JSON.stringify(this.cache.get(this.charts.queryId));
            }
            if (linkageParams) {
                entityData = linkageParams;
            }
            // TODO: mork
            /** @type {?} */
            const params = this.createParameters(this.queryId, 'charts', _schemaId, this.qoManagerCode, '', 0, 0, undefined, undefined, this.voId);
            params['queryId'] = this.queryId ? this.queryId : '';
            if (this.qoManagerCode) {
                params['qoManagerCode'] = this.qoManagerCode;
            }
            if (_schemaId && _schemaId !== 'prefab') {
                params['schemaId'] = _schemaId;
            }
            else {
                params['schemaId'] = '1';
            }
            // 查询数据前事件
            if (this.dataRenderExtendService && this.dataRenderExtendService.beforeQueryData) {
                this.dataRenderExtendService.beforeQueryData(this.createEventParams('beforeQueryData', '查询数据前', params, this.charts));
                try {
                    this.cache.set(this.tabId, JSON.parse(params['entityData']));
                }
                catch (e) { }
            }
            // 添加列
            /** @type {?} */
            const self = this;
            self.getData(params, queryRelativeUrl).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                self.getCol(params, queryRelativeUrl).subscribe((/**
                 * @param {?} resultData
                 * @return {?}
                 */
                resultData => {
                    if (!data.dynamicCols || data.dynamicCols.length === 0) {
                        data.dynamicCols = resultData.dynamicCols || [];
                    }
                    else {
                        resultData.dynamicCols.forEach((/**
                         * @param {?} col
                         * @return {?}
                         */
                        col => {
                            data.dynamicCols.push(col);
                        }));
                    }
                    if (data && data.dynamicCols && data.dynamicCols.length) {
                        /** @type {?} */
                        const joinParam = {};
                        joinParam['controlType'] = 'charts';
                        joinParam['colList'] = data.dynamicCols;
                        self.cache.set(self.tabId + 'joinSearch', joinParam);
                        self.schemaManager.colList.next(data.dynamicCols);
                    }
                    // 数据加载前事件
                    if (op && op.series && op.series.type) {
                        op.series.type = op.series.type.replace('1', '');
                    }
                    if (data && data.data && data.data.length) {
                        self.charts.setData(data.data, op);
                    }
                    else {
                        self.charts.setData([], op);
                    }
                    // 页面渲染后事件
                    if (self.dataRenderExtendService && self.dataRenderExtendService.afterLoadData) {
                        self.dataRenderExtendService.beforeLoadData(self.createEventParams('afterLoadData', '渲染后事件', data, self.charts));
                    }
                    self.cache.set(self.charts.queryId + 'echartsconfig', op);
                }));
            }));
        }));
    }
    /**
     * @private
     * @return {?}
     */
    createHeaderSessionId() {
        return RtfServices.createHeaderSessionId(this.sessionService);
    }
    /**
     * @private
     * @param {?} eventCode
     * @param {?} eventName
     * @param {?} data
     * @param {?} control
     * @return {?}
     */
    createEventParams(eventCode, eventName, data, control) {
        return {
            eventCode,
            eventName,
            data,
            control
        };
    }
}
LcpBindingDataDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'lcpBindingData, [lcpBindingData]',
            },] }
];
/** @nocollapse */
LcpBindingDataDirective.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [Server_Host,] }, { type: Optional }] },
    { type: RestfulService },
    { type: SessionService },
    { type: CacheService },
    { type: SchemaManagerService },
    { type: NgxEchartsDirective, decorators: [{ type: Optional }] },
    { type: DataRenderExtendService, decorators: [{ type: Optional }] },
    { type: FilterManagerService },
    { type: String, decorators: [{ type: Inject, args: [Load_Data_Uri,] }, { type: Optional }] },
    { type: String, decorators: [{ type: Inject, args: [Load_Data_Col,] }, { type: Optional }] },
    { type: Injector, decorators: [{ type: Optional }] }
];
LcpBindingDataDirective.propDecorators = {
    qoManagerCode: [{ type: Input }],
    delay: [{ type: Input }],
    interval: [{ type: Input }],
    eventType: [{ type: Input }],
    queryRelativeUrl: [{ type: Input }],
    queryId: [{ type: Input }],
    controlType: [{ type: Input }],
    qoId: [{ type: Input }],
    voId: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EchartsModule {
}
EchartsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    NgxEchartsDirective,
                    FormBindingDataDirective,
                    LcpBindingDataDirective
                ],
                exports: [
                    NgxEchartsDirective,
                    FormBindingDataDirective,
                    LcpBindingDataDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxEchartsDirective, FormBindingDataDirective, LcpBindingDataDirective, EchartsModule };

//# sourceMappingURL=qdp-echarts.js.map