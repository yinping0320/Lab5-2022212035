/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, HostBinding, HostListener } from '@angular/core';
export class DndNodragDirective {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    get draggable() {
        return true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragStart(event) {
        event = event.originalEvent || event;
        if (!event._dndHandle) {
            // If a child element already reacted to dragstart and set a dataTransfer object, we will
            // allow that. For example, this is the case for user selections inside of input elements.
            if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {
                event.preventDefault();
            }
            event.stopPropagation();
        }
    }
    /**
     * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element
     * would be removed.
     * @param {?} event
     * @return {?}
     */
    onDragEnd(event) {
        event = event.originalEvent || event;
        if (!event._dndHandle) {
            event.stopPropagation();
        }
    }
}
DndNodragDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dndNodrag]',
            },] }
];
/** @nocollapse */
DndNodragDirective.ctorParameters = () => [];
DndNodragDirective.propDecorators = {
    draggable: [{ type: HostBinding, args: ['draggable',] }],
    onDragStart: [{ type: HostListener, args: ['dragstart', ['$event'],] }],
    onDragEnd: [{ type: HostListener, args: ['dragend', ['$event'],] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG5kLW5vZHJhZy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcWRwL2NvbW1vbi8iLCJzb3VyY2VzIjpbImxpYi9kbmQtbGlzdC9kaXJlY3RpdmVzL2RuZC1ub2RyYWcuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFLN0UsTUFBTSxPQUFPLGtCQUFrQjtJQUM3QixnQkFBZSxDQUFDOzs7O0lBRWhCLFFBQVEsS0FBSSxDQUFDOzs7O0lBRWIsSUFDSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDOzs7OztJQUdELFdBQVcsQ0FBQyxLQUFLO1FBQ2YsS0FBSyxHQUFHLEtBQUssQ0FBQyxhQUFhLElBQUksS0FBSyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO1lBQ3JCLHlGQUF5RjtZQUN6RiwwRkFBMEY7WUFDMUYsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ2xFLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQzthQUN4QjtZQUNELEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUN6QjtJQUNILENBQUM7Ozs7Ozs7SUFPRCxTQUFTLENBQUMsS0FBSztRQUNiLEtBQUssR0FBRyxLQUFLLENBQUMsYUFBYSxJQUFJLEtBQUssQ0FBQztRQUNyQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRTtZQUNyQixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDekI7SUFDSCxDQUFDOzs7WUFwQ0YsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxhQUFhO2FBQ3hCOzs7Ozt3QkFNRSxXQUFXLFNBQUMsV0FBVzswQkFLdkIsWUFBWSxTQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQzt3QkFpQnBDLFlBQVksU0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbZG5kTm9kcmFnXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBEbmROb2RyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gIGNvbnN0cnVjdG9yKCkge31cclxuXHJcbiAgbmdPbkluaXQoKSB7fVxyXG5cclxuICBASG9zdEJpbmRpbmcoJ2RyYWdnYWJsZScpXHJcbiAgZ2V0IGRyYWdnYWJsZSgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignZHJhZ3N0YXJ0JywgWyckZXZlbnQnXSlcclxuICBvbkRyYWdTdGFydChldmVudCkge1xyXG4gICAgZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xyXG4gICAgaWYgKCFldmVudC5fZG5kSGFuZGxlKSB7XHJcbiAgICAgIC8vIElmIGEgY2hpbGQgZWxlbWVudCBhbHJlYWR5IHJlYWN0ZWQgdG8gZHJhZ3N0YXJ0IGFuZCBzZXQgYSBkYXRhVHJhbnNmZXIgb2JqZWN0LCB3ZSB3aWxsXHJcbiAgICAgIC8vIGFsbG93IHRoYXQuIEZvciBleGFtcGxlLCB0aGlzIGlzIHRoZSBjYXNlIGZvciB1c2VyIHNlbGVjdGlvbnMgaW5zaWRlIG9mIGlucHV0IGVsZW1lbnRzLlxyXG4gICAgICBpZiAoIShldmVudC5kYXRhVHJhbnNmZXIudHlwZXMgJiYgZXZlbnQuZGF0YVRyYW5zZmVyLnR5cGVzLmxlbmd0aCkpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBwcm9wYWdhdGlvbiBvZiBkcmFnZW5kIGV2ZW50cywgb3RoZXJ3aXNlIGRuZC1tb3ZlZCBtaWdodCBiZSB0cmlnZ2VyZWQgYW5kIHRoZSBlbGVtZW50XHJcbiAgICogd291bGQgYmUgcmVtb3ZlZC5cclxuICAgKi9cclxuICBASG9zdExpc3RlbmVyKCdkcmFnZW5kJywgWyckZXZlbnQnXSlcclxuICBvbkRyYWdFbmQoZXZlbnQpIHtcclxuICAgIGV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcclxuICAgIGlmICghZXZlbnQuX2RuZEhhbmRsZSkge1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19