import sp from 'signature_pad/dist/signature_pad.umd';
import { Injectable, Component, ViewChild, ElementRef, Input, Output, EventEmitter, NgModule, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/wf-sign.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WfSignService {
    constructor() { }
}
WfSignService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
WfSignService.ctorParameters = () => [];
/** @nocollapse */ WfSignService.ngInjectableDef = defineInjectable({ factory: function WfSignService_Factory() { return new WfSignService(); }, token: WfSignService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/wf-sign.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WfSignComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
WfSignComponent.decorators = [
    { type: Component, args: [{
                selector: 'wf-sign-wf-sign',
                template: `
    <p>
      wf-sign works!
    </p>
  `
            }] }
];
/** @nocollapse */
WfSignComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/signature/signature.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SignatureComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        // no op
        this.elementRef = elementRef;
        this.options = this.options || {};
        this.onBeginEvent = new EventEmitter();
        this.onEndEvent = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const canvas = this.elementRef.nativeElement.querySelector('canvas');
        if (((/** @type {?} */ (this.options))).canvasHeight) {
            canvas.height = ((/** @type {?} */ (this.options))).canvasHeight;
        }
        if (((/** @type {?} */ (this.options))).canvasWidth) {
            canvas.width = ((/** @type {?} */ (this.options))).canvasWidth;
        }
        this.signaturePad = new sp(canvas, this.options);
        this.signaturePad.onBegin = this.onBegin.bind(this);
        this.signaturePad.onEnd = this.onEnd.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /** @type {?} */
        const canvas = this.elementRef.nativeElement.querySelector('canvas');
        canvas.width = 0;
        canvas.height = 0;
    }
    /**
     * @return {?}
     */
    resizeCanvas() {
        // When zoomed out to less than 100%, for some very strange reason,
        // some browsers report devicePixelRatio as less than 1
        // and only part of the canvas is cleared then.
        /** @type {?} */
        const ratio = Math.max(window.devicePixelRatio || 1, 1);
        //const canvas: any = this.signaturePad._canvas;
        /** @type {?} */
        const canvas = this.signaturePad.canvas;
        canvas.width = canvas.offsetWidth * ratio;
        canvas.height = canvas.offsetHeight * ratio;
        canvas.getContext('2d').scale(ratio, ratio);
        this.signaturePad.clear(); // otherwise isEmpty() might return incorrect value
    }
    /**
     * @param {?} text
     * @return {?}
     */
    setWaterMark(text) {
        /** @type {?} */
        const canvas = this.elementRef.nativeElement.querySelector('canvas');
        /** @type {?} */
        const ctx = canvas.getContext("2d");
        ctx.font = "20px 微软雅黑";
        ctx.fillStyle = '#888';
        ctx.fillText(text, 10, 50);
    }
    //
    /**
     * @return {?}
     */
    setImageBackground() {
        /** @type {?} */
        const canvas = this.elementRef.nativeElement.querySelector('canvas');
        /** @type {?} */
        const ctx = canvas.getContext("2d");
        /** @type {?} */
        var imageData = ctx.getImageData(0, 0, ((/** @type {?} */ (this.options))).canvasWidth, ((/** @type {?} */ (this.options))).canvasHeight);
        for (var i = 0; i < imageData.data.length; i += 4) {
            // 当该像素是透明的，则设置成白色
            if (imageData.data[i + 3] == 0) {
                imageData.data[i] = 255;
                imageData.data[i + 1] = 255;
                imageData.data[i + 2] = 255;
                imageData.data[i + 3] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }
    /**
     * @param {?} image
     * @return {?}
     */
    setBackgroundImage(image) {
        /** @type {?} */
        const canvas = this.elementRef.nativeElement.querySelector('canvas');
        /** @type {?} */
        const ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0);
    }
    // Returns signature image as an array of point groups
    /**
     * @return {?}
     */
    toData() {
        if (this.signaturePad) {
            return this.signaturePad.toData();
        }
        else {
            return [];
        }
    }
    // Draws signature image from an array of point groups
    /**
     * @param {?} points
     * @return {?}
     */
    fromData(points) {
        this.signaturePad.fromData(points);
    }
    // Returns signature image as data URL (see https://mdn.io/todataurl for the list of possible paramters)
    /**
     * @param {?=} imageType
     * @param {?=} quality
     * @return {?}
     */
    toDataURL(imageType, quality) {
        return this.signaturePad.toDataURL(imageType, quality); // save image as data URL
    }
    // Draws signature image from data URL
    /**
     * @param {?} dataURL
     * @param {?=} options
     * @return {?}
     */
    fromDataURL(dataURL, options = {}) {
        // set default height and width on read data from URL
        if (!options.hasOwnProperty('height') && ((/** @type {?} */ (this.options))).canvasHeight) {
            options.height = ((/** @type {?} */ (this.options))).canvasHeight;
        }
        if (!options.hasOwnProperty('width') && ((/** @type {?} */ (this.options))).canvasWidth) {
            options.width = ((/** @type {?} */ (this.options))).canvasWidth;
        }
        this.signaturePad.fromDataURL(dataURL, options);
    }
    // Clears the canvas
    /**
     * @return {?}
     */
    clear() {
        this.signaturePad.clear();
    }
    // Returns true if canvas is empty, otherwise returns false
    /**
     * @return {?}
     */
    isEmpty() {
        return this.signaturePad.isEmpty();
    }
    // Unbinds all event handlers
    /**
     * @return {?}
     */
    off() {
        this.signaturePad.off();
    }
    // Rebinds all event handlers
    /**
     * @return {?}
     */
    on() {
        this.signaturePad.on();
    }
    // set an option on the signaturePad - e.g. set('minWidth', 50);
    /**
     * @param {?} option
     * @param {?} value
     * @return {?}
     */
    set(option, value) {
        switch (option) {
            case 'canvasHeight':
                this.signaturePad.canvas.height = value;
                break;
            case 'canvasWidth':
                this.signaturePad.canvas.width = value;
                break;
            default:
                this.signaturePad[option] = value;
        }
    }
    // notify subscribers on signature begin
    /**
     * @return {?}
     */
    onBegin() {
        this.onBeginEvent.emit(true);
    }
    // notify subscribers on signature end
    /**
     * @return {?}
     */
    onEnd() {
        this.onEndEvent.emit(true);
    }
    /**
     * @return {?}
     */
    queryPad() {
        return this.signaturePad;
    }
}
SignatureComponent.decorators = [
    { type: Component, args: [{
                template: '<canvas></canvas>',
                selector: 'wf-sign-signature'
            }] }
];
/** @nocollapse */
SignatureComponent.ctorParameters = () => [
    { type: ElementRef }
];
SignatureComponent.propDecorators = {
    options: [{ type: Input }],
    onBeginEvent: [{ type: Output }],
    onEndEvent: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/sign/sign.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SignComponent {
    constructor() {
        // 抛出选中的事件
        this.toDataUrlEvent = new EventEmitter();
        this.isDrawEvent = new EventEmitter();
        this.imageType = "image/png";
        this.imageQuality = 1;
        this.isDraw = false;
        this.signaturePadOptions = {
            // passed through to szimek/signature_pad constructor
            'minWidth': 1,
            'canvasWidth': 500,
            'canvasHeight': 240
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // this.signaturePad is now available
        this.signaturePad.set('minWidth', 1); // set szimek/signature_pad options at runtime
        this.signaturePad.set('canvasWidth', this.canvasDiv.nativeElement.clientWidth);
        this.signaturePad.clear(); // invoke functions from szimek/signature_pad API
        this.signaturePad.setImageBackground();
    }
    /**
     * @return {?}
     */
    confirm() {
        console.log(this.signaturePad.toDataURL(this.imageType, this.imageQuality));
        this.signaturePad.setWaterMark(new Date());
        this.toDataUrlEvent.emit(this.signaturePad.toDataURL(this.imageType, this.imageQuality));
    }
    /**
     * @return {?}
     */
    reset() {
        this.signaturePad.clear();
        this.isDraw = false;
        this.isDrawEvent.emit(this.isDraw);
    }
    /**
     * @return {?}
     */
    drawComplete() {
        this.isDraw = true;
        this.isDrawEvent.emit(this.isDraw);
        // will be notified of szimek/signature_pad's onEnd event
        //console.log(this.signaturePad.toDataURL());
    }
    /**
     * @return {?}
     */
    drawStart() {
        // will be notified of szimek/signature_pad's onBegin event
        console.log('begin drawing');
    }
}
SignComponent.decorators = [
    { type: Component, args: [{
                selector: 'wf-sign-sign',
                template: "<div class=\"fm-feature-suggestion fm-feature-section--gutter\">\r\n    <div #canvastitle style=\"padding:2px 2px 2px 0;text-align:left;width:100%;height: 21px;\">\r\n        <span style=\"font-size: 15px;color: #999999;\">\u7B7E\u540D\u533A\u57DF</span>\r\n      </div>\r\n      <wf-sign-signature  [options]=\"signaturePadOptions\" (onBeginEvent)=\"drawStart()\" (onEndEvent)=\"drawComplete()\"></wf-sign-signature>\r\n  <div class=\"fm-feature-suggestion--bar\">\r\n    <ul class=\"suggestion--bar-common\">\r\n      <li class=\"suggestion--bar-item\" (click)=\"confirm()\">\r\n        <span>\u786E\u8BA4</span>\r\n      </li>\r\n      <li class=\"suggestion--bar-item\" (click)=\"reset()\">\r\n        <span>\u91CD\u7F6E</span>\r\n      </li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n",
                styles: [".fm-page-main1{overflow:hidden}.fm-utils-flex-column{display:flex;flex-direction:column}.fm-page{position:absolute;top:0;left:0;bottom:0;right:0;display:flex;flex-direction:column;background:#fff;font-size:13px;line-height:18px}.fm-page-main{flex-basis:0;flex-shrink:1;flex-grow:1;overflow-x:hidden;overflow-y:auto;position:relative}.fm-feature-section--gutter{margin:0 0 12px}.fm-feature-suggestion{background:#fff;padding:12px 16px}.fm-feature-suggestion .fm-feature-suggestion--bar{display:flex;flex-direction:row;align-items:center;color:#888}"]
            }] }
];
/** @nocollapse */
SignComponent.ctorParameters = () => [];
SignComponent.propDecorators = {
    signaturePad: [{ type: ViewChild, args: [SignatureComponent,] }],
    canvasDiv: [{ type: ViewChild, args: ['canvastitle',] }],
    toDataUrlEvent: [{ type: Output }],
    isDrawEvent: [{ type: Output }],
    imageType: [{ type: Input }],
    imageQuality: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/sign-here/sign-here.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SignHereComponent {
    constructor() {
        // 抛出选中的事件
        this.imageType = "image/png";
        this.imageQuality = 1;
        this.title = '请对审批意见进行签字确认';
        this.isDraw = false;
        this.signaturePadOptions = {
            // passed through to szimek/signature_pad constructor
            'minWidth': 1,
            'canvasWidth': 500,
            'canvasHeight': 240
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // this.signaturePad is now available
        this.signaturePad.set('minWidth', 1); // set szimek/signature_pad options at runtime
        this.signaturePad.set('canvasWidth', this.canvasDiv.nativeElement.clientWidth);
        this.signaturePad.clear(); // invoke functions from szimek/signature_pad API
        this.signaturePad.setImageBackground();
        if (this.image) {
            /** @type {?} */
            const img = new Image();
            img.src = this.image;
            this.signaturePad.setBackgroundImage(img);
        }
    }
    /**
     * @return {?}
     */
    confirm() {
        console.log(this.signaturePad.toDataURL(this.imageType, this.imageQuality));
        //this.signaturePad.setWaterMark(new Date());
        return this.signaturePad.toDataURL(this.imageType, this.imageQuality);
    }
    /**
     * @return {?}
     */
    reset() {
        this.signaturePad.clear();
        this.signaturePad.setImageBackground();
        this.isDraw = false;
    }
    /**
     * @return {?}
     */
    drawComplete() {
        this.isDraw = true;
        // will be notified of szimek/signature_pad's onEnd event
        //console.log(this.signaturePad.toDataURL());
    }
    /**
     * @return {?}
     */
    drawStart() {
        // will be notified of szimek/signature_pad's onBegin event
        console.log('begin drawing');
    }
    //设置背景图片
    /**
     * @param {?} image
     * @return {?}
     */
    initCanvasByImage(image) {
        this.signaturePad.setBackgroundImage(image);
    }
}
SignHereComponent.decorators = [
    { type: Component, args: [{
                selector: 'wf-sign-here',
                template: "<div class=\"fm-feature-suggestion fm-feature-section--gutter\">\r\n    <div style=\"padding:2px 2px 2px 0;text-align:left;width:100%;height: 21px;\">\r\n        <span style=\"font-size: 15px;color: #999999;\">{{title}}</span>\r\n      </div>\r\n      <div class=\"wf-sign-signature-docker\">\r\n      <div #canvastitle class=\"wf-sign-signature\">\r\n      <wf-sign-signature  [options]=\"signaturePadOptions\" (onBeginEvent)=\"drawStart()\" (onEndEvent)=\"drawComplete()\"></wf-sign-signature>\r\n    </div>\r\n</div>\r\n</div>\r\n",
                styles: [".fm-page-main1{overflow:hidden}.fm-utils-flex-column{display:flex;flex-direction:column}.fm-page{position:absolute;top:0;left:0;bottom:0;right:0;display:flex;flex-direction:column;background:#fff;font-size:13px;line-height:18px}.fm-page-main{flex-basis:0;flex-shrink:1;flex-grow:1;overflow-x:hidden;overflow-y:auto;position:relative}.fm-feature-section--gutter{margin:0 0 12px}.fm-feature-suggestion{background:#fff;padding:12px 16px}.fm-feature-suggestion .fm-feature-suggestion--bar{display:flex;flex-direction:row;align-items:center;color:#888}.wf-sign-signature{margin:1px}.wf-sign-signature-docker{border:1px dashed #ddd;margin-left:4px;margin-right:4px}"]
            }] }
];
/** @nocollapse */
SignHereComponent.ctorParameters = () => [];
SignHereComponent.propDecorators = {
    signaturePad: [{ type: ViewChild, args: [SignatureComponent,] }],
    canvasDiv: [{ type: ViewChild, args: ['canvastitle',] }],
    imageType: [{ type: Input }],
    imageQuality: [{ type: Input }],
    title: [{ type: Input }],
    image: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/wf-sign.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WfSignModule {
}
WfSignModule.decorators = [
    { type: NgModule, args: [{
                declarations: [WfSignComponent, SignatureComponent, SignComponent, SignHereComponent],
                imports: [],
                exports: [WfSignComponent, SignatureComponent, SignComponent, SignHereComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: gsp-wf-wf-sign.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { WfSignService, WfSignComponent, WfSignModule, SignHereComponent, SignComponent as ɵb, SignatureComponent as ɵa };

//# sourceMappingURL=gsp-wf-wf-sign.js.map