{"version":3,"file":"mxgraph-types.js","sourceRoot":"","sources":["../../../src/lib/mxgraph-types.ts"],"names":[],"mappings":"AAwBA,MAAM,KAAQ,SAAS,CA48oBtB;AA58oBD,WAAc,SAAS;AA48oBvB,CAAC,EA58oBa,SAAS,KAAT,SAAS,QA48oBtB","sourcesContent":["/**\r\n * Based on mxgraph 4.2.0.\r\n */\r\nexport declare function MxGraphFactory(opts: {\r\n    /** Specifies the path in mxClient.basePath. */\r\n    mxBasePath?: string;\r\n    /** Specifies the path in mxClient.imageBasePath. */\r\n    mxImageBasePath?: string;\r\n    /** Specifies the language for resources in mxClient.language. */\r\n    mxLanguage?: string;\r\n    /** Array of all supported language extensions. */\r\n    mxLanguages?: string[];\r\n    /** Specifies the default language in mxClient.defaultLanguage. */\r\n    mxDefaultLanguage?: string;\r\n    /** Specifies if any resources should be loaded.  Default is true. */\r\n    mxLoadResources?: boolean;\r\n    /** Specifies if any stylesheets should be loaded.  Default is true. */\r\n    mxLoadStylesheets?: boolean;\r\n    /** Force loading the JavaScript files in development mode */\r\n    mxForceIncludes?: boolean;\r\n    /** Specify the extension of resource files. */\r\n    mxResourceExtension?: string;\r\n}): typeof MxGraphNS;\r\n\r\nexport module MxGraphNS {\r\n    export declare function escape(s: string): string;\r\n    export declare function unescape(s: string): string;\r\n    export declare var mxBasePath: string;\r\n    export declare var mxImageBasePath: string;\r\n    export declare var mxLanguage: string;\r\n    export declare var mxLanguages: string[];\r\n    export declare var mxDefaultLanguage: string;\r\n    export declare var mxLoadResources: boolean;\r\n    export declare var mxLoadStylesheets: boolean;\r\n    export declare var mxForceIncludes: boolean;\r\n    export declare var mxResourceExtension: string;\r\n\r\n    export declare var mxClient:\r\n        {\r\n            /**\r\n             * Class: mxClient\r\n             *\r\n             * Bootstrapping mechanism for the mxGraph thin client. The production version\r\n             * of this file contains all code required to run the mxGraph thin client, as\r\n             * well as global constants to identify the browser and operating system in\r\n             * use. You may have to load chrome://global/content/contentAreaUtils.js in\r\n             * your page to disable certain security restrictions in Mozilla.\r\n             * \r\n             * Variable: VERSION\r\n             *\r\n             * Contains the current version of the mxGraph library. The strings that\r\n             * communicate versions of mxGraph use the following format.\r\n             * \r\n             * versionMajor.versionMinor.buildNumber.revisionNumber\r\n             * \r\n             * Current version is 4.0.6.\r\n             */\r\n            VERSION: number;\r\n\r\n            /**\r\n             * Variable: IS_IE\r\n             *\r\n             * True if the current browser is Internet Explorer 10 or below. Use <mxClient.IS_IE11>\r\n             * to detect IE 11.\r\n             */\r\n            IS_IE: boolean;\r\n\r\n            /**\r\n             * Variable: IS_IE6\r\n             *\r\n             * True if the current browser is Internet Explorer 6.x.\r\n             */\r\n            IS_IE6: boolean;\r\n            /**\r\n             * Variable: IS_IE11\r\n             *\r\n             * True if the current browser is Internet Explorer 11.x.\r\n             */\r\n            IS_IE11: boolean;\r\n\r\n            /**\r\n             * Variable: IS_EDGE\r\n             *\r\n             * True if the current browser is Microsoft Edge.\r\n             */\r\n            IS_EDGE: boolean;\r\n\r\n            /**\r\n             * Variable: IS_QUIRKS\r\n             *\r\n             * True if the current browser is Internet Explorer and it is in quirks mode.\r\n             */\r\n            IS_QUIRKS: boolean;\r\n\r\n            /**\r\n             * Variable: IS_EM\r\n             * \r\n             * True if the browser is IE11 in enterprise mode (IE8 standards mode).\r\n             */\r\n            IS_EM: boolean;\r\n\r\n            /**\r\n             * Variable: VML_PREFIX\r\n             * \r\n             * Prefix for VML namespace in node names. Default is 'v'.\r\n             */\r\n            VML_PREFIX: string;\r\n\r\n            /**\r\n             * Variable: OFFICE_PREFIX\r\n             * \r\n             * Prefix for VML office namespace in node names. Default is 'o'.\r\n             */\r\n            OFFICE_PREFIX: string;\r\n\r\n            /**\r\n             * Variable: IS_NS\r\n             *\r\n             * True if the current browser is Netscape (including Firefox).\r\n             */\r\n            IS_NS: boolean;\r\n\r\n            /**\r\n             * Variable: IS_OP\r\n             *\r\n             * True if the current browser is Opera.\r\n             */\r\n            IS_OP: boolean;\r\n\r\n            /**\r\n             * Variable: IS_OT\r\n             *\r\n             * True if -o-transform is available as a CSS style, ie for Opera browsers\r\n             * based on a Presto engine with version 2.5 or later.\r\n             */\r\n            IS_OT: boolean;\r\n\r\n            /**\r\n             * Variable: IS_SF\r\n             *\r\n             * True if the current browser is Safari.\r\n             */\r\n            IS_SF: boolean;\r\n\r\n            /**\r\n             * Variable: IS_IOS\r\n             * \r\n             * Returns true if the user agent is an iPad, iPhone or iPod.\r\n             */\r\n            IS_IOS: boolean;\r\n\r\n            /**\r\n             * Variable: IS_GC\r\n             *\r\n             * True if the current browser is Google Chrome.\r\n             */\r\n            IS_GC: boolean;\r\n\r\n            /**\r\n             * Variable: IS_CHROMEAPP\r\n             *\r\n             * True if the this is running inside a Chrome App.\r\n             */\r\n            IS_CHROMEAPP: boolean;\r\n\r\n            /**\r\n             * Variable: IS_FF\r\n             *\r\n             * True if the current browser is Firefox.\r\n             */\r\n            IS_FF: boolean;\r\n\r\n            /**\r\n             * Variable: IS_MT\r\n             *\r\n             * True if -moz-transform is available as a CSS style. This is the case\r\n             * for all Firefox-based browsers newer than or equal 3, such as Camino,\r\n             * Iceweasel, Seamonkey and Iceape.\r\n             */\r\n            IS_MT: boolean;\r\n\r\n            /**\r\n             * Variable: IS_VML\r\n             *\r\n             * True if the browser supports VML.\r\n             */\r\n            IS_VML: boolean;\r\n\r\n            /**\r\n             * Variable: IS_SVG\r\n             *\r\n             * True if the browser supports SVG.\r\n             */\r\n            IS_SVG: boolean;\r\n\r\n            /**\r\n             * Variable: NO_FO\r\n             *\r\n             * True if foreignObject support is not available. This is the case for\r\n             * Opera, older SVG-based browsers and all versions of IE.\r\n             */\r\n            NO_FO: boolean;\r\n\r\n            /**\r\n             * Variable: IS_WIN\r\n             *\r\n             * True if the client is a Windows.\r\n             */\r\n            IS_WIN: boolean;\r\n\r\n            /**\r\n             * Variable: IS_MAC\r\n             *\r\n             * True if the client is a Mac.\r\n             */\r\n            IS_MAC: boolean;\r\n\r\n            /**\r\n             * Variable: IS_CHROMEOS\r\n             *\r\n             * True if the client is a Chrome OS.\r\n             */\r\n            IS_CHROMEOS: boolean;\r\n\r\n            /**\r\n             * Variable: IS_TOUCH\r\n             * \r\n             * True if this device supports touchstart/-move/-end events (Apple iOS,\r\n             * Android, Chromebook and Chrome Browser on touch-enabled devices).\r\n             */\r\n            IS_TOUCH: boolean;\r\n\r\n            /**\r\n             * Variable: IS_POINTER\r\n             * \r\n             * True if this device supports Microsoft pointer events (always false on Macs).\r\n             */\r\n            IS_POINTER: boolean;\r\n\r\n            /**\r\n             * Variable: IS_LOCAL\r\n             *\r\n             * True if the documents location does not start with http:// or https://.\r\n             */\r\n            IS_LOCAL: boolean;\r\n\r\n            /**\r\n             * Variable: defaultBundles\r\n             * \r\n             * Contains the base names of the default bundles if mxLoadResources is false.\r\n             */\r\n            defaultBundles: string[];\r\n\r\n            /**\r\n             * Function: isBrowserSupported\r\n             *\r\n             * Returns true if the current browser is supported, that is, if\r\n             * <mxClient.IS_VML> or <mxClient.IS_SVG> is true.\r\n             * \r\n             * Example:\r\n             * \r\n             * (code)\r\n             * if (!mxClient.isBrowserSupported())\r\n             * {\r\n             *   mxUtils.error('Browser is not supported!', 200, false);\r\n             * }\r\n             * (end)\r\n             */\r\n            isBrowserSupported: () => boolean;\r\n\r\n            /**\r\n             * Function: link\r\n             *\r\n             * Adds a link node to the head of the document. Use this\r\n             * to add a stylesheet to the page as follows:\r\n             *\r\n             * (code)\r\n             * mxClient.link('stylesheet', filename);\r\n             * (end)\r\n             *\r\n             * where filename is the (relative) URL of the stylesheet. The charset\r\n             * is hardcoded to ISO-8859-1 and the type is text/css.\r\n             * \r\n             * Parameters:\r\n             * \r\n             * rel - String that represents the rel attribute of the link node.\r\n             * href - String that represents the href attribute of the link node.\r\n             * doc - Optional parent document of the link node.\r\n             * id - unique id for the link element to check if it already exists\r\n             */\r\n            link: (rel: string, href: string, doc?: XMLDocument, id?: string) => void;\r\n\r\n            /**\r\n             * Function: loadResources\r\n             * \r\n             * Helper method to load the default bundles if mxLoadResources is false.\r\n             * \r\n             * Parameters:\r\n             * \r\n             * fn - Function to call after all resources have been loaded.\r\n             * lan - Optional string to pass to <mxResources.add>.\r\n             */\r\n            loadResources: (fn: any, lan?: string) => void;\r\n\r\n            /**\r\n             * Function: include\r\n             *\r\n             * Dynamically adds a script node to the document header.\r\n             * \r\n             * In production environments, the includes are resolved in the mxClient.js\r\n             * file to reduce the number of requests required for client startup. This\r\n             * function should only be used in development environments, but not in\r\n             * production systems.\r\n             */\r\n            include: (src: string) => void;\r\n\r\n            /**\r\n             * Variable: basePath\r\n             *\r\n             * Basepath for all URLs in the core without trailing slash. Default is '.'.\r\n             * Set mxBasePath prior to loading the mxClient library as follows to override\r\n             * this setting:\r\n             *\r\n             * (code)\r\n             * <script type=\"text/javascript\">\r\n             * \t\tmxBasePath = '/path/to/core/directory';\r\n             * </script>\r\n             * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\r\n             * (end)\r\n             * \r\n             * When using a relative path, the path is relative to the URL of the page that\r\n             * contains the assignment. Trailing slashes are automatically removed.\r\n             */\r\n            basePath: string;\r\n\r\n            /**\r\n             * Variable: imageBasePath\r\n             *\r\n             * Basepath for all images URLs in the core without trailing slash. Default is\r\n             * <mxClient.basePath> + '/images'. Set mxImageBasePath prior to loading the\r\n             * mxClient library as follows to override this setting:\r\n             *\r\n             * (code)\r\n             * <script type=\"text/javascript\">\r\n             * \t\tmxImageBasePath = '/path/to/image/directory';\r\n             * </script>\r\n             * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\r\n             * (end)\r\n             * \r\n             * When using a relative path, the path is relative to the URL of the page that\r\n             * contains the assignment. Trailing slashes are automatically removed.\r\n             */\r\n            imageBasePath: string,\r\n\r\n            /**\r\n             * Variable: language\r\n             *\r\n             * Defines the language of the client, eg. en for english, de for german etc.\r\n             * The special value 'none' will disable all built-in internationalization and\r\n             * resource loading. See <mxResources.getSpecialBundle> for handling identifiers\r\n             * with and without a dash.\r\n             * \r\n             * Set mxLanguage prior to loading the mxClient library as follows to override\r\n             * this setting:\r\n             *\r\n             * (code)\r\n             * <script type=\"text/javascript\">\r\n             * \t\tmxLanguage = 'en';\r\n             * </script>\r\n             * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\r\n             * (end)\r\n             * \r\n             * If internationalization is disabled, then the following variables should be\r\n             * overridden to reflect the current language of the system. These variables are\r\n             * cleared when i18n is disabled.\r\n             * <mxEditor.askZoomResource>, <mxEditor.lastSavedResource>,\r\n             * <mxEditor.currentFileResource>, <mxEditor.propertiesResource>,\r\n             * <mxEditor.tasksResource>, <mxEditor.helpResource>, <mxEditor.outlineResource>,\r\n             * <mxElbowEdgeHandler.doubleClickOrientationResource>, <mxUtils.errorResource>,\r\n             * <mxUtils.closeResource>, <mxGraphSelectionModel.doneResource>,\r\n             * <mxGraphSelectionModel.updatingSelectionResource>, <mxGraphView.doneResource>,\r\n             * <mxGraphView.updatingDocumentResource>, <mxCellRenderer.collapseExpandResource>,\r\n             * <mxGraph.containsValidationErrorsResource> and\r\n             * <mxGraph.alreadyConnectedResource>.\r\n             */\r\n            language: string,\r\n\r\n            /**\r\n             * Variable: defaultLanguage\r\n             * \r\n             * Defines the default language which is used in the common resource files. Any\r\n             * resources for this language will only load the common resource file, but not\r\n             * the language-specific resource file. Default is 'en'.\r\n             * \r\n             * Set mxDefaultLanguage prior to loading the mxClient library as follows to override\r\n             * this setting:\r\n             *\r\n             * (code)\r\n             * <script type=\"text/javascript\">\r\n             * \t\tmxDefaultLanguage = 'de';\r\n             * </script>\r\n             * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\r\n             * (end)\r\n             */\r\n            defaultLanguage: string;\r\n\r\n            /**\r\n             * Variable: languages\r\n             *\r\n             * Defines the optional array of all supported language extensions. The default\r\n             * language does not have to be part of this list. See\r\n             * <mxResources.isLanguageSupported>.\r\n             *\r\n             * (code)\r\n             * <script type=\"text/javascript\">\r\n             * \t\tmxLanguages = ['de', 'it', 'fr'];\r\n             * </script>\r\n             * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\r\n             * (end)\r\n             * \r\n             * This is used to avoid unnecessary requests to language files, ie. if a 404\r\n             * will be returned.\r\n             */\r\n            languages: string[];\r\n        };\r\n\r\n    export declare class mxStencil {\r\n        /**\r\n         * Static global variable that specifies the default value for the localized\r\n         * attribute of the text element. Default is false.\r\n         */\r\n        static defaultLocalized: boolean;\r\n        /**\r\n         * Static global switch that specifies if the use of eval is allowed for\r\n         * evaluating text content and images. Default is false. Set this to true\r\n         * if stencils can not contain user input.\r\n         */\r\n        static allowEval: boolean;\r\n        /**\r\n         * Holds the XML node with the stencil description.\r\n         */\r\n        desc: Element;\r\n        /**\r\n         * Holds an array of <mxConnectionConstraints> as defined in the shape.\r\n         */\r\n        constraints: mxConnectionConstraint[];\r\n        /**\r\n         * Holds the aspect of the shape. Default is 'auto'.\r\n         */\r\n        aspect: string;\r\n        /**\r\n         * Holds the width of the shape. Default is 100.\r\n         */\r\n        w0: number;\r\n        /**\r\n         * Holds the height of the shape. Default is 100.\r\n         */\r\n        h0: number;\r\n        /**\r\n         * Holds the XML node with the stencil description.\r\n         */\r\n        bgNode: Element;\r\n        /**\r\n         * Holds the XML node with the stencil description.\r\n         */\r\n        fgNode: Element;\r\n        /**\r\n         * Holds the strokewidth direction from the description.\r\n         */\r\n        strokewidth: number | string;\r\n        /**\r\n         * Constructs a new generic shape by setting <desc> to the given XML node and\r\n         * invoking <parseDescription> and <parseConstraints>.\r\n         *\r\n         * @param desc XML node that contains the stencil description.\r\n         */\r\n        constructor(desc: Element);\r\n        /**\r\n         * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.\r\n         */\r\n        parseDescription(): void;\r\n        /**\r\n         * Reads the constraints from <desc> into <constraints> using\r\n         * <parseConstraint>.\r\n         */\r\n        parseConstraints(): void;\r\n        /**\r\n         * Parses the given XML node and returns its <mxConnectionConstraint>.\r\n         */\r\n        parseConstraint(node: Element): mxConnectionConstraint;\r\n        /**\r\n         * Gets the given attribute as a text. The return value from <evaluateAttribute>\r\n         * is used as a key to <mxResources.get> if the localized attribute in the text\r\n         * node is 1 or if <defaultLocalized> is true.\r\n         */\r\n        evaluateTextAttribute(node: Element, attribute: string, shape: any): string;\r\n        /**\r\n         * Gets the attribute for the given name from the given node. If the attribute\r\n         * does not exist then the text content of the node is evaluated and if it is\r\n         * a function it is invoked with <shape> as the only argument and the return\r\n         * value is used as the attribute value to be returned.\r\n         */\r\n        evaluateAttribute(node: Element, attribute: string, shape: any): string;\r\n        /**\r\n         * Draws this stencil inside the given bounds.\r\n         */\r\n        drawShape(canvas: any, shape: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Draws this stencil inside the given bounds.\r\n         */\r\n        drawChildren(canvas: any, shape: any, x: any, y: any, w: any, h: any, node: any, aspect: any, disableShadow: any): void;\r\n        /**\r\n         * Returns a rectangle that contains the offset in x and y and the horizontal\r\n         * and vertical scale in width and height used to draw this shape inside the\r\n         * given <mxRectangle>.\r\n         *\r\n         * shape - <mxShape> to be drawn.\r\n         * bounds - <mxRectangle> that should contain the stencil.\r\n         * direction - Optional direction of the shape to be darwn.\r\n         */\r\n        computeAspect(shape: any, x: any, y: any, w: any, h: any, direction: any): mxRectangle;\r\n        /**\r\n         * Draws this stencil inside the given bounds.\r\n         */\r\n        drawNode(canvas: any, shape: any, node: any, aspect: any, disableShadow: any): void;\r\n    }\r\n\r\n    export declare class mxShape {\r\n        getPorts(): any;\r\n        /**\r\n         * Holds the dialect in which the shape is to be painted.\r\n         * This can be one of the DIALECT constants in <mxConstants>.\r\n         */\r\n        dialect: any;\r\n        /**\r\n         * Holds the scale in which the shape is being painted.\r\n         */\r\n        scale: number;\r\n        /**\r\n         * Rendering hint for configuring the canvas.\r\n         */\r\n        antiAlias: boolean;\r\n        /**\r\n         * Holds the <mxRectangle> that specifies the bounds of this shape.\r\n         */\r\n        bounds: mxRectangle;\r\n        /**\r\n         * Holds the array of <mxPoints> that specify the points of this shape.\r\n         */\r\n        points: mxPoint[];\r\n        /**\r\n         * Holds the outermost DOM node that represents this shape.\r\n         */\r\n        node: HTMLElement | SVGElement;\r\n        /**\r\n         * Optional reference to the corresponding <mxCellState>.\r\n         */\r\n        state: mxCellState;\r\n        /**\r\n         * Optional reference to the style of the corresponding <mxCellState>.\r\n         */\r\n        style: any[];\r\n        /**\r\n         * Contains the bounding box of the shape, that is, the smallest rectangle\r\n         * that includes all pixels of the shape.\r\n         */\r\n        boundingBox: mxRectangle;\r\n        /**\r\n         * Holds the <mxStencil> that defines the shape.\r\n         */\r\n        stencil: mxStencil;\r\n        /**\r\n         * Event-tolerance for SVG strokes (in px). Default is 8. This is only passed\r\n         * to the canvas in <createSvgCanvas> if <pointerEvents> is true.\r\n         */\r\n        svgStrokeTolerance: number;\r\n        /**\r\n         * Specifies if pointer events should be handled. Default is true.\r\n         */\r\n        pointerEvents: boolean;\r\n        /**\r\n         * Specifies if pointer events should be handled. Default is true.\r\n         */\r\n        svgPointerEvents: string;\r\n        /**\r\n         * Specifies if pointer events outside of shape should be handled. Default\r\n         * is false.\r\n         */\r\n        shapePointerEvents: boolean;\r\n        /**\r\n         * Specifies if pointer events outside of stencils should be handled. Default\r\n         * is false. Set this to true for backwards compatibility with the 1.x branch.\r\n         */\r\n        stencilPointerEvents: boolean;\r\n        /**\r\n         * Scale for improving the precision of VML rendering. Default is 1.\r\n         */\r\n        vmlScale: number;\r\n        /**\r\n         * Specifies if the shape should be drawn as an outline. This disables all\r\n         * fill colors and can be used to disable other drawing states that should\r\n         * not be painted for outlines. Default is false. This should be set before\r\n         * calling <apply>.\r\n         */\r\n        outline: boolean;\r\n        /**\r\n         * Specifies if the shape is visible. Default is true.\r\n         */\r\n        visible: boolean;\r\n        /**\r\n         * Allows to use the SVG bounding box in SVG. Default is false for performance\r\n         * reasons.\r\n         */\r\n        useSvgBoundingBox: boolean;\r\n        /**\r\n         * Implicit variable declarations\r\n         */\r\n        strokewidth: number;\r\n        rotation: number;\r\n        opacity: number;\r\n        fillOpacity: number;\r\n        strokeOpacity: number;\r\n        flipH: boolean;\r\n        flipV: boolean;\r\n        spacing: any;\r\n        fill: any;\r\n        gradient: any;\r\n        gradientDirection: any;\r\n        stroke: any;\r\n        startSize: any;\r\n        endSize: any;\r\n        startArrow: any;\r\n        endArrow: any;\r\n        direction: any;\r\n        isShadow: any;\r\n        isDashed: any;\r\n        isRounded: any;\r\n        glass: any;\r\n        cursor: string;\r\n        constructor(stencil?: any);\r\n        /**\r\n         * Initializes the shape by creaing the DOM node using <create>\r\n         * and adding it into the given container.\r\n         *\r\n         * @param container - DOM node that will contain the shape.\r\n         */\r\n        init(container: HTMLElement): void;\r\n        /**\r\n         * Specifies if any VML should be added via insertAdjacentHtml to the DOM. This\r\n         * is only needed in IE8 and only if the shape contains VML markup. This method\r\n         * returns true.\r\n         */\r\n        isParseVml(): boolean;\r\n        /**\r\n         * Returns true if HTML is allowed for this shape. This implementation always\r\n         * returns false.\r\n         */\r\n        isHtmlAllowed(): boolean;\r\n        /**\r\n         * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\r\n         */\r\n        getSvgScreenOffset(): 0 | 0.5;\r\n        /**\r\n         * Creates and returns the DOM node(s) for the shape in\r\n         * the given container. This implementation invokes\r\n         * <createSvg>, <createHtml> or <createVml> depending\r\n         * on the <dialect> and style settings.\r\n         *\r\n         * @param container - DOM node that will contain the shape.\r\n         */\r\n        create(container: Element): HTMLElement | SVGGElement;\r\n        /**\r\n         * Creates and returns the SVG node(s) to represent this shape.\r\n         */\r\n        createSvg(...args: any[]): SVGGElement;\r\n        /**\r\n         * Creates and returns the VML node to represent this shape.\r\n         */\r\n        createVml(...args: any[]): HTMLElement;\r\n        /**\r\n         * Creates and returns the HTML DOM node(s) to represent\r\n         * this shape. This implementation falls back to <createVml>\r\n         * so that the HTML creation is optional.\r\n         */\r\n        createHtml(...args: any[]): HTMLDivElement;\r\n        /**\r\n         * Reconfigures this shape. This will update the colors etc in\r\n         * addition to the bounds or points.\r\n         */\r\n        reconfigure(): void;\r\n        /**\r\n         * Creates and returns the SVG node(s) to represent this shape.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Removes all child nodes and resets all CSS.\r\n         */\r\n        clear(): void;\r\n        /**\r\n         * Updates the bounds based on the points.\r\n         */\r\n        updateBoundsFromPoints(): void;\r\n        /**\r\n         * Returns the <mxRectangle> for the label bounds of this shape, based on the\r\n         * given scaled and translated bounds of the shape. This method should not\r\n         * change the rectangle in-place. This implementation returns the given rect.\r\n         */\r\n        getLabelBounds(rect: any): any;\r\n        /**\r\n         * Returns the scaled top, left, bottom and right margin to be used for\r\n         * computing the label bounds as an <mxRectangle>, where the bottom and right\r\n         * margin are defined in the width and height of the rectangle, respectively.\r\n         */\r\n        getLabelMargins(rect: any): any;\r\n        /**\r\n         * Returns true if the bounds are not null and all of its variables are numeric.\r\n         */\r\n        checkBounds(): boolean;\r\n        /**\r\n         * Returns the temporary element used for rendering in IE8 standards mode.\r\n         */\r\n        createVmlGroup(): HTMLElement;\r\n        /**\r\n         * Updates the SVG or VML shape.\r\n         */\r\n        redrawShape(): void;\r\n        /**\r\n         * Creates a new canvas for drawing this shape. May return null.\r\n         */\r\n        createCanvas(): mxSvgCanvas2D | mxVmlCanvas2D;\r\n        /**\r\n         * Creates and returns an <mxSvgCanvas2D> for rendering this shape.\r\n         */\r\n        createSvgCanvas(): mxSvgCanvas2D;\r\n        /**\r\n         * Creates and returns an <mxVmlCanvas2D> for rendering this shape.\r\n         */\r\n        createVmlCanvas(): any;\r\n        /**\r\n         * Updates the bounds of the VML container.\r\n         */\r\n        updateVmlContainer(): void;\r\n        /**\r\n         * Allow optimization by replacing VML with HTML.\r\n         */\r\n        redrawHtmlShape(): void;\r\n        /**\r\n         * Allow optimization by replacing VML with HTML.\r\n         */\r\n        updateHtmlFilters(node: any): void;\r\n        /**\r\n         * Allow optimization by replacing VML with HTML.\r\n         */\r\n        updateHtmlColors(node: any): void;\r\n        /**\r\n         * Allow optimization by replacing VML with HTML.\r\n         */\r\n        updateHtmlBounds(node: any): void;\r\n        /**\r\n         * Destroys the given canvas which was used for drawing. This implementation\r\n         * increments the reference counts on all shared gradients used in the canvas.\r\n         */\r\n        destroyCanvas(canvas: any): void;\r\n        /**\r\n         * Generic rendering code.\r\n         */\r\n        paint(c: any): void;\r\n        /**\r\n         * Sets the state of the canvas for drawing the shape.\r\n         */\r\n        configureCanvas(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Returns the bounding box for the gradient box for this shape.\r\n         */\r\n        getGradientBounds(c: any, x: any, y: any, w: any, h: any): mxRectangle;\r\n        /**\r\n         * Sets the scale and rotation on the given canvas.\r\n         */\r\n        updateTransform(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Paints the vertex shape.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Hook for subclassers. This implementation is empty.\r\n         */\r\n        paintBackground(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Hook for subclassers. This implementation is empty.\r\n         */\r\n        paintForeground(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Hook for subclassers. This implementation is empty.\r\n         */\r\n        paintEdgeShape(c: any, pts: any): void;\r\n        /**\r\n         * Returns the arc size for the given dimension.\r\n         */\r\n        getArcSize(w: any, h: any): number;\r\n        /**\r\n         * Paints the glass gradient effect.\r\n         */\r\n        paintGlassEffect(c: any, x: any, y: any, w: any, h: any, arc: any): void;\r\n        /**\r\n         * Paints the given points with rounded corners.\r\n         */\r\n        addPoints(c: any, pts: any, rounded: any, arcSize: any, close: any, exclude: any, initialMove: any): void;\r\n        /**\r\n         * Resets all styles.\r\n         */\r\n        resetStyles(): void;\r\n        /**\r\n         * Applies the style of the given <mxCellState> to the shape. This\r\n         * implementation assigns the following styles to local fields:\r\n         *\r\n         * - <mxConstants.STYLE_FILLCOLOR> => fill\r\n         * - <mxConstants.STYLE_GRADIENTCOLOR> => gradient\r\n         * - <mxConstants.STYLE_GRADIENT_DIRECTION> => gradientDirection\r\n         * - <mxConstants.STYLE_OPACITY> => opacity\r\n         * - <mxConstants.STYLE_FILL_OPACITY> => fillOpacity\r\n         * - <mxConstants.STYLE_STROKE_OPACITY> => strokeOpacity\r\n         * - <mxConstants.STYLE_STROKECOLOR> => stroke\r\n         * - <mxConstants.STYLE_STROKEWIDTH> => strokewidth\r\n         * - <mxConstants.STYLE_SHADOW> => isShadow\r\n         * - <mxConstants.STYLE_DASHED> => isDashed\r\n         * - <mxConstants.STYLE_SPACING> => spacing\r\n         * - <mxConstants.STYLE_STARTSIZE> => startSize\r\n         * - <mxConstants.STYLE_ENDSIZE> => endSize\r\n         * - <mxConstants.STYLE_ROUNDED> => isRounded\r\n         * - <mxConstants.STYLE_STARTARROW> => startArrow\r\n         * - <mxConstants.STYLE_ENDARROW> => endArrow\r\n         * - <mxConstants.STYLE_ROTATION> => rotation\r\n         * - <mxConstants.STYLE_DIRECTION> => direction\r\n         * - <mxConstants.STYLE_GLASS> => glass\r\n         *\r\n         * This keeps a reference to the <style>. If you need to keep a reference to\r\n         * the cell, you can override this method and store a local reference to\r\n         * state.cell or the <mxCellState> itself. If <outline> should be true, make\r\n         * sure to set it before calling this method.\r\n         *\r\n         * state - <mxCellState> of the corresponding cell.\r\n         */\r\n        apply(state: any): void;\r\n        /**\r\n         * Sets the cursor on the given shape.\r\n         *\r\n         * cursor - The cursor to be used.\r\n         */\r\n        setCursor(cursor: any): void;\r\n        /**\r\n         * Returns the current cursor.\r\n         */\r\n        getCursor(): string;\r\n        /**\r\n         * Updates the <boundingBox> for this shape using <createBoundingBox> and\r\n         * <augmentBoundingBox> and stores the result in <boundingBox>.\r\n         */\r\n        updateBoundingBox(): void;\r\n        /**\r\n         * Returns a new rectangle that represents the bounding box of the bare shape\r\n         * with no shadows or strokewidths.\r\n         */\r\n        createBoundingBox(): any;\r\n        /**\r\n         * Augments the bounding box with the strokewidth and shadow offsets.\r\n         */\r\n        augmentBoundingBox(bbox: any): void;\r\n        /**\r\n         * Returns true if the bounds should be inverted.\r\n         */\r\n        isPaintBoundsInverted(): boolean;\r\n        /**\r\n         * Returns the rotation from the style.\r\n         */\r\n        getRotation(): number;\r\n        /**\r\n         * Returns the rotation for the text label.\r\n         */\r\n        getTextRotation(): number;\r\n        /**\r\n         * Returns the actual rotation of the shape.\r\n         */\r\n        getShapeRotation(): number;\r\n        /**\r\n         * Adds a transparent rectangle that catches all events.\r\n         */\r\n        createTransparentSvgRectangle(x: any, y: any, w: any, h: any): Element;\r\n        /**\r\n         * Sets a transparent background CSS style to catch all events.\r\n         *\r\n         * Paints the line shape.\r\n         */\r\n        setTransparentBackgroundImage(node: any): void;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        releaseSvgGradients(grads: any): void;\r\n        /**\r\n         * Destroys the shape by removing it from the DOM and releasing the DOM\r\n         * node associated with the shape using <mxEvent.release>.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Code to add stencils.\r\n     *\r\n     * (code)\r\n     * var req = mxUtils.load('test/stencils.xml');\r\n     * var root = req.getDocumentElement();\r\n     * var shape = root.firstChild;\r\n     *\r\n     * while (shape != null)\r\n     * {\r\n     * \t if (shape.nodeType == mxConstants.NODETYPE_ELEMENT)\r\n     *   {\r\n     *     mxStencilRegistry.addStencil(shape.getAttribute('name'), new mxStencil(shape));\r\n     *   }\r\n     *\r\n     *   shape = shape.nextSibling;\r\n     * }\r\n     * (end)\r\n     */\r\n    export declare var mxStencilRegistry: {\r\n        stencils: {};\r\n        addStencil(name: any, stencil: any): void;\r\n        getStencil(name: any): any;\r\n    };\r\n\r\n\r\n    export declare var mxMarker: {\r\n        markers: any[];\r\n        addMarker(type: any, funct: any): void;\r\n        createMarker(canvas: any, shape: any, type: any, pe: any, unitX: any, unitY: any, size: any, source: any, sw: any, filled: any): any;\r\n    };\r\n\r\n    /**\r\n     * Extends <mxShape> to implement an actor shape. If a custom shape with one\r\n     * filled area is needed, then this shape's <redrawPath> should be overridden.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * function SampleShape() { }\r\n     *\r\n     * SampleShape.prototype = new mxActor();\r\n     * SampleShape.prototype.constructor = vsAseShape;\r\n     *\r\n     * mxCellRenderer.registerShape('sample', SampleShape);\r\n     * SampleShape.prototype.redrawPath = function(path, x, y, w, h)\r\n     * {\r\n     *   path.moveTo(0, 0);\r\n     *   path.lineTo(w, h);\r\n     *   // ...\r\n     *   path.close();\r\n     * }\r\n     * (end)\r\n     *\r\n     * This shape is registered under <mxConstants.SHAPE_ACTOR> in\r\n     * <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxActor\r\n     *\r\n     * Constructs a new actor shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxActor extends mxShape {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Redirects to redrawPath for subclasses to work.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Draws the path for this shape.\r\n         */\r\n        redrawPath(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxActor> to implement a cloud shape.\r\n     *\r\n     * This shape is registered under <mxConstants.SHAPE_CLOUD> in\r\n     * <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxCloud\r\n     *\r\n     * Constructs a new cloud shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxCloud extends mxActor {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Draws the path for this shape.\r\n         */\r\n        redrawPath(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a rectangle shape.\r\n     * This shape is registered under <mxConstants.SHAPE_RECTANGLE>\r\n     * in <mxCellRenderer>.\r\n     */\r\n    export declare class mxRectangleShape extends mxShape {\r\n        /**\r\n         * Constructs a new rectangle shape.\r\n         *\r\n         * @param bounds - <mxRectangle> that defines the bounds. This is stored in\r\n         * <mxShape.bounds>.\r\n         * @param fill - String that defines the fill color. This is stored in <fill>.\r\n         * @param stroke - String that defines the stroke color. This is stored in <stroke>.\r\n         * @param strokewidth - Optional integer that defines the stroke width. Default is\r\n         * 1. This is stored in <strokewidth>.\r\n         */\r\n        constructor(bounds: mxRectangle, fill: string, stroke: string, strokewidth?: number);\r\n        /**\r\n         * Returns true for non-rounded, non-rotated shapes with no glass gradient.\r\n         */\r\n        isHtmlAllowed(): boolean;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        paintBackground(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        paintForeground(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement an ellipse shape.\r\n     * This shape is registered under <mxConstants.SHAPE_ELLIPSE>\r\n     * in <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxEllipse\r\n     *\r\n     * Constructs a new ellipse shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxEllipse extends mxShape {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth?: any);\r\n        /**\r\n         * Paints the ellipse shape.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a double ellipse shape. This shape is\r\n     * registered under <mxConstants.SHAPE_DOUBLE_ELLIPSE> in <mxCellRenderer>.\r\n     * Use the following override to only fill the inner ellipse in this shape:\r\n     *\r\n     * (code)\r\n     * mxDoubleEllipse.prototype.paintVertexShape = function(c, x, y, w, h)\r\n     * {\r\n     *   c.ellipse(x, y, w, h);\r\n     *   c.stroke();\r\n     *\r\n     *   var inset = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));\r\n     *   x += inset;\r\n     *   y += inset;\r\n     *   w -= 2 * inset;\r\n     *   h -= 2 * inset;\r\n     *\r\n     *   if (w > 0 && h > 0)\r\n     *   {\r\n     *     c.ellipse(x, y, w, h);\r\n     *   }\r\n     *\r\n     *   c.fillAndStroke();\r\n     * };\r\n     * (end)\r\n     *\r\n     * Constructor: mxDoubleEllipse\r\n     *\r\n     * Constructs a new ellipse shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxDoubleEllipse extends mxShape {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Paints the background.\r\n         */\r\n        paintBackground(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Paints the foreground.\r\n         */\r\n        paintForeground(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Returns the bounds for the label.\r\n         */\r\n        getLabelBounds(rect: any): mxRectangle;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a rhombus (aka diamond) shape.\r\n     * This shape is registered under <mxConstants.SHAPE_RHOMBUS>\r\n     * in <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxRhombus\r\n     *\r\n     * Constructs a new rhombus shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxRhombus extends mxShape {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Generic painting implementation.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a polyline (a line with multiple points).\r\n     * This shape is registered under <mxConstants.SHAPE_POLYLINE> in\r\n     * <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxPolyline\r\n     *\r\n     * Constructs a new polyline shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * points - Array of <mxPoints> that define the points. This is stored in\r\n     * <mxShape.points>.\r\n     * stroke - String that defines the stroke color. Default is 'black'. This is\r\n     * stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxPolyline extends mxShape {\r\n        constructor(points: mxPoint[], stroke: string, strokewidth?: number);\r\n        /**\r\n         * Returns 0.\r\n         */\r\n        getRotation(): number;\r\n        /**\r\n         * Returns 0.\r\n         */\r\n        getShapeRotation(): number;\r\n        /**\r\n         * Returns false.\r\n         */\r\n        isPaintBoundsInverted(): boolean;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        paintEdgeShape(c: any, pts: any): void;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        paintLine(c: any, pts: any, rounded: any): void;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        paintCurvedLine(c: any, pts: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement an arrow shape. (The shape\r\n     * is used to represent edges, not vertices.)\r\n     * This shape is registered under <mxConstants.SHAPE_ARROW>\r\n     * in <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxArrow\r\n     *\r\n     * Constructs a new arrow shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * points - Array of <mxPoints> that define the points. This is stored in\r\n     * <mxShape.points>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     * arrowWidth - Optional integer that defines the arrow width. Default is\r\n     * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\r\n     * spacing - Optional integer that defines the spacing between the arrow shape\r\n     * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\r\n     * <spacing>.\r\n     * endSize - Optional integer that defines the size of the arrowhead. Default\r\n     * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\r\n     */\r\n    export declare class mxArrow extends mxShape {\r\n        constructor(points: any, fill: any, stroke: any, strokewidth: any, arrowWidth: any, spacing: any, endSize: any);\r\n        /**\r\n         * Augments the bounding box with the edge width and markers.\r\n         */\r\n        augmentBoundingBox(bbox: any): void;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        paintEdgeShape(c: any, pts: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement an new rounded arrow shape with support for\r\n     * waypoints and double arrows. (The shape is used to represent edges, not\r\n     * vertices.) This shape is registered under <mxConstants.SHAPE_ARROW_CONNECTOR>\r\n     * in <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxArrowConnector\r\n     *\r\n     * Constructs a new arrow shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * points - Array of <mxPoints> that define the points. This is stored in\r\n     * <mxShape.points>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     * arrowWidth - Optional integer that defines the arrow width. Default is\r\n     * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\r\n     * spacing - Optional integer that defines the spacing between the arrow shape\r\n     * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\r\n     * <spacing>.\r\n     * endSize - Optional integer that defines the size of the arrowhead. Default\r\n     * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\r\n     */\r\n    export declare class mxArrowConnector extends mxShape {\r\n        constructor(points: any, fill: any, stroke: any, strokewidth: any, arrowWidth: any, spacing: any, endSize: any);\r\n        /**\r\n         * Overrides mxShape to reset spacing.\r\n         */\r\n        resetStyles(): void;\r\n        /**\r\n         * Overrides apply to get smooth transition from default start- and endsize.\r\n         */\r\n        apply(state: any): void;\r\n        /**\r\n         * Augments the bounding box with the edge width and markers.\r\n         */\r\n        augmentBoundingBox(bbox: any): void;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        paintEdgeShape(c: any, pts: any): void;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        paintMarker(c: any, ptX: any, ptY: any, nx: any, ny: any, size: any, arrowWidth: any, edgeWidth: any, spacing: any, initialMove: any): void;\r\n        /**\r\n         * Returns wether the arrow is rounded\r\n         */\r\n        isArrowRounded(): any;\r\n        /**\r\n         * Returns the width of the start arrow\r\n         */\r\n        getStartArrowWidth(): number;\r\n        /**\r\n         * Returns the width of the end arrow\r\n         */\r\n        getEndArrowWidth(): number;\r\n        /**\r\n         * Returns the width of the body of the edge\r\n         */\r\n        getEdgeWidth(): number;\r\n        /**\r\n         * Returns whether the ends of the shape are drawn\r\n         */\r\n        isOpenEnded(): boolean;\r\n        /**\r\n         * Returns whether the start marker is drawn\r\n         */\r\n        isMarkerStart(): boolean;\r\n        /**\r\n         * Returns whether the end marker is drawn\r\n         */\r\n        isMarkerEnd(): boolean;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a text shape. To change vertical text from\r\n     * bottom to top to top to bottom, the following code can be used:\r\n     *\r\n     * @example\r\n     * mxText.prototype.verticalTextRotation = 90;\r\n     */\r\n    export declare class mxText extends mxShape {\r\n        /**\r\n         * Specifies the spacing to be added to the top spacing. Default is 0. Use the\r\n         * value 5 here to get the same label positions as in mxGraph 1.x.\r\n         */\r\n        baseSpacingTop: number;\r\n        /**\r\n         * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\r\n         * value 1 here to get the same label positions as in mxGraph 1.x.\r\n         */\r\n        baseSpacingBottom: number;\r\n        /**\r\n         * Specifies the spacing to be added to the left spacing. Default is 0.\r\n         */\r\n        baseSpacingLeft: number;\r\n        /**\r\n         * Specifies the spacing to be added to the right spacing. Default is 0.\r\n         */\r\n        baseSpacingRight: number;\r\n        /**\r\n         * Specifies if linefeeds in HTML labels should be replaced with BR tags.\r\n         * Default is true.\r\n         */\r\n        replaceLinefeeds: boolean;\r\n        /**\r\n         * Rotation for vertical text. Default is -90 (bottom to top).\r\n         */\r\n        verticalTextRotation: number;\r\n        /**\r\n         * Specifies if the string size should be measured in <updateBoundingBox> if\r\n         * the label is clipped and the label position is center and middle. If this is\r\n         * true, then the bounding box will be set to <bounds>. Default is true.\r\n         * <ignoreStringSize> has precedence over this switch.\r\n         */\r\n        ignoreClippedStringSize: boolean;\r\n        /**\r\n         * Specifies if the actual string size should be measured. If disabled the\r\n         * boundingBox will not ignore the actual size of the string, otherwise\r\n         * <bounds> will be used instead. Default is false.\r\n         */\r\n        ignoreStringSize: boolean;\r\n        /**\r\n         * Specifies the padding to be added to the text width for the bounding box.\r\n         * This is needed to make sure no clipping is applied to borders. Default is 4\r\n         * for IE 8 standards mode and 3 for all others.\r\n         */\r\n        textWidthPadding: number;\r\n        /**\r\n         * Contains the last rendered text value. Used for caching.\r\n         */\r\n        lastValue: any;\r\n        /**\r\n         * Specifies if caching for HTML labels should be enabled. Default is true.\r\n         */\r\n        cacheEnabled: boolean;\r\n        /**\r\n         * Implicitly defined variables\r\n         */\r\n        textDirection: any;\r\n        labelPadding: any;\r\n        overflow: any;\r\n        clipped: any;\r\n        wrap: any;\r\n        border: any;\r\n        background: any;\r\n        horizontal: any;\r\n        spacingLeft: any;\r\n        spacingBottom: any;\r\n        spacingRight: any;\r\n        spacingTop: any;\r\n        fontStyle: any;\r\n        size: any;\r\n        family: any;\r\n        valign: any;\r\n        align: any;\r\n        color: any;\r\n        value: any;\r\n        /**\r\n         * Constructs a new text shape.\r\n         *\r\n         * @param value - String that represents the text to be displayed. This is stored in\r\n         * <value>.\r\n         * @param bounds - <mxRectangle> that defines the bounds. This is stored in\r\n         * <mxShape.bounds>.\r\n         * @param align - Specifies the horizontal alignment. Default is ''. This is stored in\r\n         * <align>.\r\n         * @param valign - Specifies the vertical alignment. Default is ''. This is stored in\r\n         * <valign>.\r\n         * @param color - String that specifies the text color. Default is 'black'. This is\r\n         * stored in <color>.\r\n         * @param family - String that specifies the font family. Default is\r\n         * <mxConstants.DEFAULT_FONTFAMILY>. This is stored in <family>.\r\n         * @param size - Integer that specifies the font size. Default is\r\n         * <mxConstants.DEFAULT_FONTSIZE>. This is stored in <size>.\r\n         * @param fontStyle - Specifies the font style. Default is 0. This is stored in\r\n         * <fontStyle>.\r\n         * @param spacing - Integer that specifies the global spacing. Default is 2. This is\r\n         * stored in <spacing>.\r\n         * @param spacingTop - Integer that specifies the top spacing. Default is 0. The\r\n         * sum of the spacing and this is stored in <spacingTop>.\r\n         * @param spacingRight - Integer that specifies the right spacing. Default is 0. The\r\n         * sum of the spacing and this is stored in <spacingRight>.\r\n         * @param spacingBottom - Integer that specifies the bottom spacing. Default is 0.The\r\n         * sum of the spacing and this is stored in <spacingBottom>.\r\n         * @param spacingLeft - Integer that specifies the left spacing. Default is 0. The\r\n         * sum of the spacing and this is stored in <spacingLeft>.\r\n         * @param horizontal - Boolean that specifies if the label is horizontal. Default is\r\n         * true. This is stored in <horizontal>.\r\n         * @param background - String that specifies the background color. Default is null.\r\n         * This is stored in <background>.\r\n         * @param border - String that specifies the label border color. Default is null.\r\n         * This is stored in <border>.\r\n         * @param wrap - Specifies if word-wrapping should be enabled. Default is false.\r\n         * This is stored in <wrap>.\r\n         * @param clipped - Specifies if the label should be clipped. Default is false.\r\n         * This is stored in <clipped>.\r\n         * @param overflow - Value of the overflow style. Default is 'visible'.\r\n         */\r\n        constructor(value: any, bounds: any, align: any, valign: any, color: any, family: any, size: any, fontStyle: any, spacing: any, spacingTop: any, spacingRight: any, spacingBottom: any, spacingLeft: any, horizontal: any, background: any, border: any, wrap: any, clipped: any, overflow: any, labelPadding: any, textDirection: any);\r\n        /**\r\n         * Text shapes do not contain VML markup and do not need to be parsed. This\r\n         * method returns false to speed up rendering in IE8.\r\n         */\r\n        isParseVml(): boolean;\r\n        /**\r\n         * Returns true if HTML is allowed for this shape. This implementation returns\r\n         * true if the browser is not in IE8 standards mode.\r\n         */\r\n        isHtmlAllowed(): boolean;\r\n        /**\r\n         * Disables offset in IE9 for crisper image output.\r\n         */\r\n        getSvgScreenOffset(): 0;\r\n        /**\r\n         * Returns true if the bounds are not null and all of its variables are numeric.\r\n         */\r\n        checkBounds(): boolean;\r\n        /**\r\n         * Generic rendering code.\r\n         */\r\n        paint(c: any, update?: boolean): void;\r\n        /**\r\n         * Renders the text using the given DOM nodes.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Resets all styles.\r\n         */\r\n        resetStyles(): void;\r\n        /**\r\n         * Extends mxShape to update the text styles.\r\n         *\r\n         * state - <mxCellState> of the corresponding cell.\r\n         */\r\n        apply(state: any): void;\r\n        /**\r\n         * Used to determine the automatic text direction. Returns\r\n         * <mxConstants.TEXT_DIRECTION_LTR> or <mxConstants.TEXT_DIRECTION_RTL>\r\n         * depending on the contents of <value>. This is not invoked for HTML, wrapped\r\n         * content or if <value> is a DOM node.\r\n         */\r\n        getAutoDirection(): string;\r\n        /**\r\n         * Updates the <boundingBox> for this shape using the given node and position.\r\n         */\r\n        updateBoundingBox(): void;\r\n        /**\r\n         * Returns 0 to avoid using rotation in the canvas via updateTransform.\r\n         */\r\n        getShapeRotation(): number;\r\n        /**\r\n         * Returns the rotation for the text label of the corresponding shape.\r\n         */\r\n        getTextRotation(): number;\r\n        /**\r\n         * Inverts the bounds if <mxShape.isBoundsInverted> returns true or if the\r\n         * horizontal style is false.\r\n         */\r\n        isPaintBoundsInverted(): boolean;\r\n        /**\r\n         * Sets the state of the canvas for drawing the shape.\r\n         */\r\n        configureCanvas(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Sets the width and height of the container to 1px.\r\n         */\r\n        updateVmlContainer(): void;\r\n        /**\r\n         * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n         */\r\n        redrawHtmlShape(): void;\r\n        /**\r\n         * Returns the spacing as an <mxPoint>.\r\n         */\r\n        updateHtmlTransform(): void;\r\n        /**\r\n         * Sets the inner HTML of the given element to the <value>.\r\n         */\r\n        updateInnerHtml(elt: any): void;\r\n        /**\r\n         * Rotated text rendering quality is bad for IE9 quirks/IE8 standards\r\n         */\r\n        updateHtmlFilter(): void;\r\n        /**\r\n         * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n         */\r\n        updateValue(): void;\r\n        /**\r\n         * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n         */\r\n        updateFont(node: any): void;\r\n        /**\r\n         * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n         */\r\n        updateSize(node: any, enableWrap: any): void;\r\n        /**\r\n         * Returns the spacing as an <mxPoint>.\r\n         */\r\n        updateMargin(): void;\r\n        /**\r\n         * Returns the spacing as an <mxPoint>.\r\n         */\r\n        getSpacing(): mxPoint;\r\n    }\r\n\r\n    /**\r\n     * Implementation of the triangle shape.\r\n     *\r\n     * Constructor: mxTriangle\r\n     *\r\n     * Constructs a new triangle shape.\r\n     */\r\n    export declare class mxTriangle extends mxActor {\r\n        constructor();\r\n        /**\r\n         * Draws the path for this shape.\r\n         */\r\n        redrawPath(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Implementation of the hexagon shape.\r\n     *\r\n     * Constructor: mxHexagon\r\n     *\r\n     * Constructs a new hexagon shape.\r\n     */\r\n    export declare class mxHexagon extends mxActor {\r\n        constructor();\r\n        /**\r\n         * Draws the path for this shape.\r\n         */\r\n        redrawPath(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a horizontal line shape.\r\n     * This shape is registered under <mxConstants.SHAPE_LINE> in\r\n     * <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxLine\r\n     *\r\n     * Constructs a new line shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * stroke - String that defines the stroke color. Default is 'black'. This is\r\n     * stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxLine extends mxShape {\r\n        constructor(bounds: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Redirects to redrawPath for subclasses to work.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement an image shape. This shape is registered\r\n     * under <mxConstants.SHAPE_IMAGE> in <mxCellRenderer>.\r\n     */\r\n    export declare class mxImageShape extends mxRectangleShape {\r\n        /**\r\n         * Switch to preserve image aspect. Default is true.\r\n         */\r\n        preserveImageAspect: boolean;\r\n        /** URL of the image */\r\n        image: string;\r\n        shadow: boolean;\r\n        /**\r\n         * Constructs a new image shape.\r\n         *\r\n         * @param bounds - <mxRectangle> that defines the bounds. This is stored in\r\n         * <mxShape.bounds>.\r\n         * @param image - String that specifies the URL of the image. This is stored in\r\n         * <image>.\r\n         * @param fill - String that defines the fill color. This is stored in <fill>.\r\n         * @param stroke - String that defines the stroke color. This is stored in <stroke>.\r\n         * @param strokewidth - Optional integer that defines the stroke width. Default is\r\n         * 0. This is stored in <strokewidth>.\r\n         */\r\n        constructor(bounds: mxRectangle, image: string, fill: string, stroke: string, strokewidth?: number);\r\n        /**\r\n         * Disables offset in IE9 for crisper image output.\r\n         */\r\n        getSvgScreenOffset(): 0;\r\n        /**\r\n         * Overrides <mxShape.apply> to replace the fill and stroke colors with the\r\n         * respective values from <mxConstants.STYLE_IMAGE_BACKGROUND> and\r\n         * <mxConstants.STYLE_IMAGE_BORDER>.\r\n         *\r\n         * Applies the style of the given <mxCellState> to the shape. This\r\n         * implementation assigns the following styles to local fields:\r\n         *\r\n         * - <mxConstants.STYLE_IMAGE_BACKGROUND> => fill\r\n         * - <mxConstants.STYLE_IMAGE_BORDER> => stroke\r\n         *\r\n         * @param state - <mxCellState> of the corresponding cell.\r\n         */\r\n        apply(state: mxCellState): void;\r\n        /**\r\n         * Returns true if HTML is allowed for this shape. This implementation always\r\n         * returns false.\r\n         */\r\n        isHtmlAllowed(): boolean;\r\n        /**\r\n         * Creates and returns the HTML DOM node(s) to represent\r\n         * this shape. This implementation falls back to <createVml>\r\n         * so that the HTML creation is optional.\r\n         */\r\n        createHtml(): HTMLDivElement;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Overrides <mxShape.redraw> to preserve the aspect ratio of images.\r\n         */\r\n        redrawHtmlShape(): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement an image shape with a label.\r\n     * This shape is registered under <mxConstants.SHAPE_LABEL> in\r\n     * <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxLabel\r\n     *\r\n     * Constructs a new label shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxLabel extends mxRectangleShape {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Initializes the shape and the <indicator>.\r\n         */\r\n        init(container: any): void;\r\n        /**\r\n         * Reconfigures this shape. This will update the colors of the indicator\r\n         * and reconfigure it if required.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Returns true for non-rounded, non-rotated shapes with no glass gradient and\r\n         * no indicator shape.\r\n         */\r\n        isHtmlAllowed(): boolean;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        paintForeground(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        paintImage(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        getImageBounds(x: any, y: any, w: any, h: any): mxRectangle;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        paintIndicator(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        getIndicatorBounds(x: any, y: any, w: any, h: any): mxRectangle;\r\n        /**\r\n         * Generic background painting implementation.\r\n         */\r\n        redrawHtmlShape(): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement an cylinder shape. If a\r\n     * custom shape with one filled area and an overlay path is\r\n     * needed, then this shape's <redrawPath> should be overridden.\r\n     * This shape is registered under <mxConstants.SHAPE_CYLINDER>\r\n     * in <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxCylinder\r\n     *\r\n     * Constructs a new cylinder shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxCylinder extends mxShape {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Redirects to redrawPath for subclasses to work.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Draws the path for this shape.\r\n         */\r\n        redrawPath(c: any, x: any, y: any, w: any, h: any, isForeground: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a connector shape. The connector\r\n     * shape allows for arrow heads on either side.\r\n     *\r\n     * This shape is registered under <mxConstants.SHAPE_CONNECTOR> in\r\n     * <mxCellRenderer>.\r\n     *\r\n     * Constructor: mxConnector\r\n     *\r\n     * Constructs a new connector shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * points - Array of <mxPoints> that define the points. This is stored in\r\n     * <mxShape.points>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * Default is 'black'.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxConnector extends mxPolyline {\r\n        constructor(points: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Updates the <boundingBox> for this shape using <createBoundingBox> and\r\n         * <augmentBoundingBox> and stores the result in <boundingBox>.\r\n         */\r\n        updateBoundingBox(): void;\r\n        /**\r\n         * Paints the line shape.\r\n         */\r\n        paintEdgeShape(c: any, pts: any): void;\r\n        /**\r\n         * Prepares the marker by adding offsets in pts and returning a function to\r\n         * paint the marker.\r\n         */\r\n        createMarker(c: any, pts: any, source: any): any;\r\n        /**\r\n         * Augments the bounding box with the strokewidth and shadow offsets.\r\n         */\r\n        augmentBoundingBox(bbox: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxShape> to implement a swimlane shape. This shape is registered\r\n     * under <mxConstants.SHAPE_SWIMLANE> in <mxCellRenderer>. Use the\r\n     * <mxConstants.STYLE_STYLE_STARTSIZE> to define the size of the title\r\n     * region, <mxConstants.STYLE_SWIMLANE_FILLCOLOR> for the content area fill,\r\n     * <mxConstants.STYLE_SEPARATORCOLOR> to draw an additional vertical separator\r\n     * and <mxConstants.STYLE_SWIMLANE_LINE> to hide the line between the title\r\n     * region and the content area. The <mxConstants.STYLE_HORIZONTAL> affects\r\n     * the orientation of this shape, not only its label.\r\n     *\r\n     * Constructor: mxSwimlane\r\n     *\r\n     * Constructs a new swimlane shape.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n     * <mxShape.bounds>.\r\n     * fill - String that defines the fill color. This is stored in <fill>.\r\n     * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n     * strokewidth - Optional integer that defines the stroke width. Default is\r\n     * 1. This is stored in <strokewidth>.\r\n     */\r\n    export declare class mxSwimlane extends mxShape {\r\n        constructor(bounds: any, fill: any, stroke: any, strokewidth: any);\r\n        /**\r\n         * Returns the bounding box for the gradient box for this shape.\r\n         */\r\n        getTitleSize(): number;\r\n        /**\r\n         * Returns the bounding box for the gradient box for this shape.\r\n         */\r\n        getLabelBounds(rect: any): mxRectangle;\r\n        /**\r\n         * Returns the bounding box for the gradient box for this shape.\r\n         */\r\n        getGradientBounds(c: any, x: any, y: any, w: any, h: any): mxRectangle;\r\n        /**\r\n         * Returns the arcsize for the swimlane.\r\n         */\r\n        getArcSize(w: any, h: any, start?: any): number;\r\n        /**\r\n         * Paints the swimlane vertex shape.\r\n         */\r\n        isHorizontal(): boolean;\r\n        /**\r\n         * Paints the swimlane vertex shape.\r\n         */\r\n        paintVertexShape(c: any, x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Paints the swimlane vertex shape.\r\n         */\r\n        paintSwimlane(c: any, x: any, y: any, w: any, h: any, start: any, fill: any, swimlaneLine: any): void;\r\n        /**\r\n         * Paints the swimlane vertex shape.\r\n         */\r\n        paintRoundedSwimlane(c: any, x: any, y: any, w: any, h: any, start: any, r: any, fill: any, swimlaneLine: any): void;\r\n        /**\r\n         * Paints the swimlane vertex shape.\r\n         */\r\n        paintSeparator(c: any, x: any, y: any, w: any, h: any, start: any, color: any): void;\r\n        /**\r\n         * Paints the swimlane vertex shape.\r\n         */\r\n        getImageBounds(x: any, y: any, w: any, h: any): mxRectangle;\r\n    }\r\n\r\n\r\n    export declare var mxLog: {\r\n        consoleName: string;\r\n        TRACE: boolean;\r\n        DEBUG: boolean;\r\n        WARN: boolean;\r\n        buffer: string;\r\n        init(): void;\r\n        info(): void;\r\n        addButton(lab: any, funct: any): void;\r\n        isVisible(): any;\r\n        show(): void;\r\n        setVisible(visible: any): void;\r\n        enter(string: any): number;\r\n        leave(string: any, t0: any): void;\r\n        debug(string: any, t0: any): void;\r\n        warn(string: any, t0: any): void;\r\n        write(string: any, t0: any): void;\r\n        writeln(string: any, t0: any): void;\r\n    };\r\n\r\n\r\n    export declare var mxObjectIdentity: {\r\n        FIELD_NAME: string;\r\n        counter: number;\r\n        get(obj: any): any;\r\n        clear(obj: any): void;\r\n    };\r\n\r\n    /**\r\n     * A wrapper class for an associative array with object keys. Note: This\r\n     * implementation uses <mxObjectIdentitiy> to turn object keys into strings.\r\n     *\r\n     * Constructor: mxEventSource\r\n     *\r\n     * Constructs a new dictionary which allows object to be used as keys.\r\n     */\r\n    export declare class mxDictionary {\r\n        constructor();\r\n        /**\r\n         * Clears the dictionary.\r\n         */\r\n        clear(): void;\r\n        /**\r\n         * Returns the value for the given key.\r\n         */\r\n        get(key: any): any;\r\n        /**\r\n         * Stores the value under the given key and returns the previous\r\n         * value for that key.\r\n         */\r\n        put(key: any, value: any): any;\r\n        /**\r\n         * Removes the value for the given key and returns the value that\r\n         * has been removed.\r\n         */\r\n        remove(key: any): any;\r\n        /**\r\n         * Returns all keys as an array.\r\n         */\r\n        getKeys(): any[];\r\n        /**\r\n         * Returns all values as an array.\r\n         */\r\n        getValues(): any[];\r\n        /**\r\n         * Visits all entries in the dictionary using the given function with the\r\n         * following signature: function(key, value) where key is a string and\r\n         * value is an object.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * visitor - A function that takes the key and value as arguments.\r\n         */\r\n        visit(visitor: any): void;\r\n    }\r\n\r\n\r\n    export declare var mxResources: {\r\n        resources: any[];\r\n        extension: string;\r\n        resourcesEncoded: boolean;\r\n        loadDefaultBundle: boolean;\r\n        loadSpecialBundle: boolean;\r\n        isLanguageSupported(lan: any): boolean;\r\n        getDefaultBundle(basename: any, lan: any): string;\r\n        getSpecialBundle(basename: string, lan: string): string;\r\n        add(basename: string, lan?: string, callback?: () => void): void;\r\n        parse(text: string): void;\r\n        get(key: string, params?: string[], defaultValue?: string): string;\r\n        replacePlaceholders(value: string, params: string[]): string;\r\n        loadResources(callback?: () => void): void;\r\n    };\r\n\r\n    /**\r\n     * Implements a 2-dimensional vector with double precision coordinates.\r\n     */\r\n    export declare class mxPoint {\r\n        /**\r\n         * Holds the x-coordinate of the point. Default is 0.\r\n         * @desc Relative to left corner.\r\n         */\r\n        x: number;\r\n        /**\r\n         * Holds the y-coordinate of the point. Default is 0.\r\n         * @desc Relative to top.\r\n         */\r\n        y: number;\r\n        /**\r\n         * Constructs a new point for the optional x and y coordinates, relative to\r\n         * the top left corner. If no coordinates are given, then the default values\r\n         * for <x> and <y> are used.\r\n         */\r\n        constructor(x?: number, y?: number);\r\n        /**\r\n         * Returns true if the given object equals this point.\r\n         */\r\n        equals(obj: mxPoint): boolean;\r\n        /**\r\n         * Returns a clone of this <mxPoint>.\r\n         */\r\n        clone(): any;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxPoint> to implement a 2-dimensional rectangle with double\r\n     * precision coordinates.\r\n     */\r\n    export declare class mxRectangle extends mxPoint {\r\n        /**\r\n         * Holds the width of the rectangle. Default is 0.\r\n         */\r\n        width: number;\r\n        /**\r\n         * Holds the height of the rectangle. Default is 0.\r\n         */\r\n        height: number;\r\n        /**\r\n         * Constructs a new rectangle for the optional parameters. If no parameters\r\n         * are given then the respective default values are used.\r\n         *\r\n         * @param x X-coordinate of the rectangle origin (top left corner)\r\n         * @param y Y-coordinate of the rectangle origin (top left corner)\r\n         * @param w Width of the rectangle\r\n         * @param h Height of the rectangle\r\n         */\r\n        constructor(x?: number, y?: number, width?: number, height?: number);\r\n        /**\r\n         * Sets this rectangle to the specified values\r\n         *\r\n         * @param x X-coordinate of the rectangle origin (top left corner)\r\n         * @param y Y-coordinate of the rectangle origin (top left corner)\r\n         * @param w Width of the rectangle\r\n         * @param h Height of the rectangle\r\n         */\r\n        setRect(x: number, y: number, w: number, h: number): void;\r\n        /**\r\n         * Returns the x-coordinate of the center point.\r\n         */\r\n        getCenterX(): number;\r\n        /**\r\n         * Returns the y-coordinate of the center point.\r\n         */\r\n        getCenterY(): number;\r\n        /**\r\n         * Adds the given rectangle to this rectangle, i.e. such that it just\r\n         * about contains the supplied rectangle.\r\n         *\r\n         * @param rect\r\n         */\r\n        add(rect: mxRectangle): void;\r\n        /**\r\n         * Changes this rectangle to where it overlaps with the given rectangle.\r\n         *\r\n         * @param rect\r\n         */\r\n        intersect(rect: mxRectangle): void;\r\n        /**\r\n         * Grows the rectangle by the given amount, that is, this method subtracts\r\n         * the given amount from the x- and y-coordinates and adds twice the amount\r\n         * to the width and height.\r\n         */\r\n        grow(amount: number): void;\r\n        /**\r\n         * Returns the top, left corner as a new <mxPoint>.\r\n         */\r\n        getPoint(): mxPoint;\r\n        /**\r\n         * Rotates this rectangle by 90 degree around its center point.\r\n         */\r\n        rotate90(): void;\r\n        /**\r\n         * Returns true if the given object equals this rectangle.\r\n         */\r\n        equals(obj: mxRectangle): boolean;\r\n        /**\r\n         * Returns a new <mxRectangle> which is a copy of the given rectangle.\r\n         */\r\n        static fromRectangle(rect: mxRectangle): mxRectangle;\r\n    }\r\n\r\n\r\n    export declare var mxEffects: {\r\n        animateChanges(graph: any, changes: any, done: any): void;\r\n        cascadeOpacity(graph: any, cell: any, opacity: any): void;\r\n        fadeOut(node: any, from: any, remove: any, step: any, delay: any, isEnabled: any): void;\r\n    };\r\n\r\n    export declare var mxUtils: {\r\n        errorResource: string;\r\n        closeResource: string;\r\n        errorImage: string;\r\n\r\n        removeCursors(element: HTMLElement): void;\r\n\r\n        getCurrentStyle(elt: HTMLElement): CSSStyleDeclaration;\r\n\r\n        parseCssNumber(value: string): number;\r\n\r\n        setPrefixedStyle(style: any, name: string, value: any): void;\r\n\r\n        htmlEntities(s: string, newline?: boolean): any;\r\n\r\n        hasScrollbars(elt: HTMLElement): boolean;\r\n\r\n        getOffset(container: HTMLElement, scrollOffset?: boolean): mxPoint;\r\n\r\n        /**\r\n         * Function: makeDraggable\r\n         * \r\n         * Configures the given DOM element to act as a drag source for the\r\n         * specified graph. Returns a a new <mxDragSource>. If\r\n         * <mxDragSource.guideEnabled> is enabled then the x and y arguments must\r\n         * be used in funct to match the preview location.\r\n         * \r\n         * Example:\r\n         * \r\n         * (code)\r\n         * var funct = function(graph, evt, cell, x, y)\r\n         * {\r\n         *   if (graph.canImportCell(cell))\r\n         *   {\r\n         *     var parent = graph.getDefaultParent();\r\n         *     var vertex = null;\r\n         *     \r\n         *     graph.getModel().beginUpdate();\r\n         *     try\r\n         *     {\r\n         * \t     vertex = graph.insertVertex(parent, null, 'Hello', x, y, 80, 30);\r\n         *     }\r\n         *     finally\r\n         *     {\r\n         *       graph.getModel().endUpdate();\r\n         *     }\r\n         *\r\n         *     graph.setSelectionCell(vertex);\r\n         *   }\r\n         * }\r\n         * \r\n         * var img = document.createElement('img');\r\n         * img.setAttribute('src', 'editors/images/rectangle.gif');\r\n         * img.style.position = 'absolute';\r\n         * img.style.left = '0px';\r\n         * img.style.top = '0px';\r\n         * img.style.width = '16px';\r\n         * img.style.height = '16px';\r\n         * \r\n         * var dragImage = img.cloneNode(true);\r\n         * dragImage.style.width = '32px';\r\n         * dragImage.style.height = '32px';\r\n         * mxUtils.makeDraggable(img, graph, funct, dragImage);\r\n         * document.body.appendChild(img);\r\n         * (end)\r\n         * \r\n         * Parameters:\r\n         * \r\n         * element - DOM element to make draggable.\r\n         * graphF - <mxGraph> that acts as the drop target or a function that takes a\r\n         * mouse event and returns the current <mxGraph>.\r\n         * funct - Function to execute on a successful drop.\r\n         * dragElement - Optional DOM node to be used for the drag preview.\r\n         * dx - Optional horizontal offset between the cursor and the drag\r\n         * preview.\r\n         * dy - Optional vertical offset between the cursor and the drag\r\n         * preview.\r\n         * autoscroll - Optional boolean that specifies if autoscroll should be\r\n         * used. Default is mxGraph.autoscroll.\r\n         * scalePreview - Optional boolean that specifies if the preview element\r\n         * should be scaled according to the graph scale. If this is true, then\r\n         * the offsets will also be scaled. Default is false.\r\n         * highlightDropTargets - Optional boolean that specifies if dropTargets\r\n         * should be highlighted. Default is true.\r\n         * getDropTarget - Optional function to return the drop target for a given\r\n         * location (x, y). Default is mxGraph.getCellAt.\r\n         */\r\n        makeDraggable(element: HTMLElement, graphF: mxGraph, funct: Function, dragElement?: HTMLElement, dx?: number, dy?: number, autoscroll?: boolean,\r\n            scalePreview?: boolean, highlightDropTargets?: boolean, getDropTarget?: (x: number, y: number) => mxCell): mxDragSource;\r\n\r\n        /**\r\n         * Function: setOpacity\r\n         * \r\n         * Sets the opacity of the specified DOM node to the given value in %.\r\n         * \r\n         * Parameters:\r\n         * \r\n         * node - DOM node to set the opacity for.\r\n         * value - Opacity in %. Possible values are between 0 and 100.\r\n         */\r\n        setOpacity(node: HTMLElement, value: number): void;\r\n\r\n        /**\r\n         * Function: convertPoint\r\n         * \r\n         * Converts the specified point (x, y) using the offset of the specified\r\n         * container and returns a new <mxPoint> with the result.\r\n         * \r\n         * (code)\r\n         * var pt = mxUtils.convertPoint(graph.container,\r\n         *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));\r\n         * (end)\r\n         * \r\n         * Parameters:\r\n         * \r\n         * container - DOM node to use for the offset.\r\n         * x - X-coordinate of the point to be converted.\r\n         * y - Y-coordinate of the point to be converted.\r\n         */\r\n        convertPoint(container: HTMLElement, x: number, y: number): mxPoint;\r\n        /**\r\n         * Function: getValue\r\n         * \r\n         * Returns the value for the given key in the given associative array or\r\n         * the given default value if the value is null.\r\n         * \r\n         * Parameters:\r\n         * \r\n         * array - Associative array that contains the value for the key.\r\n         * key - Key whose value should be returned.\r\n         * defaultValue - Value to be returned if the value for the given\r\n         * key is null.\r\n         */\r\n        getValue(array: any[], key: any, defaultValue?: any): any;\r\n\r\n        /**\r\n         * Function: indexOf\r\n         * \r\n         * Returns the index of obj in array or -1 if the array does not contain\r\n         * the given object.\r\n         * \r\n         * Parameters:\r\n         * \r\n         * array - Array to check for the given obj.\r\n         * obj - Object to find in the given array.\r\n         */\r\n        indexOf(array: any[], obj: any): number;\r\n\r\n        [key: string]: any;\r\n    };\r\n\r\n    export declare class mxConstants {\r\n        static DEFAULT_HOTSPOT: number;\r\n        static MIN_HOTSPOT_SIZE: number;\r\n        static MAX_HOTSPOT_SIZE: number;\r\n        static RENDERING_HINT_EXACT: string;\r\n        static RENDERING_HINT_FASTER: string;\r\n        static RENDERING_HINT_FASTEST: string;\r\n        static DIALECT_SVG: string;\r\n        static DIALECT_VML: string;\r\n        static DIALECT_MIXEDHTML: string;\r\n        static DIALECT_PREFERHTML: string;\r\n        static DIALECT_STRICTHTML: string;\r\n        static NS_SVG: string;\r\n        static NS_XHTML: string;\r\n        static NS_XLINK: string;\r\n        static SHADOWCOLOR: string;\r\n        static VML_SHADOWCOLOR: string;\r\n        static SHADOW_OFFSET_X: number;\r\n        static SHADOW_OFFSET_Y: number;\r\n        static SHADOW_OPACITY: number;\r\n        static NODETYPE_ELEMENT: number;\r\n        static NODETYPE_ATTRIBUTE: number;\r\n        static NODETYPE_TEXT: number;\r\n        static NODETYPE_CDATA: number;\r\n        static NODETYPE_ENTITY_REFERENCE: number;\r\n        static NODETYPE_ENTITY: number;\r\n        static NODETYPE_PROCESSING_INSTRUCTION: number;\r\n        static NODETYPE_COMMENT: number;\r\n        static NODETYPE_DOCUMENT: number;\r\n        static NODETYPE_DOCUMENTTYPE: number;\r\n        static NODETYPE_DOCUMENT_FRAGMENT: number;\r\n        static NODETYPE_NOTATION: number;\r\n        static TOOLTIP_VERTICAL_OFFSET: number;\r\n        static DEFAULT_VALID_COLOR: string;\r\n        static DEFAULT_INVALID_COLOR: string;\r\n        static OUTLINE_HIGHLIGHT_COLOR: string;\r\n        static OUTLINE_HIGHLIGHT_STROKEWIDTH: number;\r\n        static HIGHLIGHT_STROKEWIDTH: number;\r\n        static HIGHLIGHT_SIZE: number;\r\n        static HIGHLIGHT_OPACITY: number;\r\n        static CURSOR_MOVABLE_VERTEX: string;\r\n        static CURSOR_MOVABLE_EDGE: string;\r\n        static CURSOR_LABEL_HANDLE: string;\r\n        static CURSOR_TERMINAL_HANDLE: string;\r\n        static CURSOR_BEND_HANDLE: string;\r\n        static CURSOR_VIRTUAL_BEND_HANDLE: string;\r\n        static CURSOR_CONNECT: string;\r\n        static HIGHLIGHT_COLOR: string;\r\n        static CONNECT_TARGET_COLOR: string;\r\n        static INVALID_CONNECT_TARGET_COLOR: string;\r\n        static DROP_TARGET_COLOR: string;\r\n        static VALID_COLOR: string;\r\n        static INVALID_COLOR: string;\r\n        static EDGE_SELECTION_COLOR: string;\r\n        static VERTEX_SELECTION_COLOR: string;\r\n        static VERTEX_SELECTION_STROKEWIDTH: number;\r\n        static EDGE_SELECTION_STROKEWIDTH: number;\r\n        static VERTEX_SELECTION_DASHED: boolean;\r\n        static EDGE_SELECTION_DASHED: boolean;\r\n        static GUIDE_COLOR: string;\r\n        static GUIDE_STROKEWIDTH: number;\r\n        static OUTLINE_COLOR: string;\r\n        static OUTLINE_STROKEWIDTH: number;\r\n        static HANDLE_SIZE: number;\r\n        static LABEL_HANDLE_SIZE: number;\r\n        static HANDLE_FILLCOLOR: string;\r\n        static HANDLE_STROKECOLOR: string;\r\n        static LABEL_HANDLE_FILLCOLOR: string;\r\n        static CONNECT_HANDLE_FILLCOLOR: string;\r\n        static LOCKED_HANDLE_FILLCOLOR: string;\r\n        static OUTLINE_HANDLE_FILLCOLOR: string;\r\n        static OUTLINE_HANDLE_STROKECOLOR: string;\r\n        static DEFAULT_FONTFAMILY: string;\r\n        static DEFAULT_FONTSIZE: number;\r\n        static DEFAULT_TEXT_DIRECTION: string;\r\n        static LINE_HEIGHT: number;\r\n        static WORD_WRAP: string;\r\n        static ABSOLUTE_LINE_HEIGHT: boolean;\r\n        static DEFAULT_FONTSTYLE: number;\r\n        static DEFAULT_STARTSIZE: number;\r\n        static DEFAULT_MARKERSIZE: number;\r\n        static DEFAULT_IMAGESIZE: number;\r\n        static ENTITY_SEGMENT: number;\r\n        static RECTANGLE_ROUNDING_FACTOR: number;\r\n        static LINE_ARCSIZE: number;\r\n        static ARROW_SPACING: number;\r\n        static ARROW_WIDTH: number;\r\n        static ARROW_SIZE: number;\r\n        static PAGE_FORMAT_A4_PORTRAIT: mxRectangle;\r\n        static PAGE_FORMAT_A4_LANDSCAPE: mxRectangle;\r\n        static PAGE_FORMAT_LETTER_PORTRAIT: mxRectangle;\r\n        static PAGE_FORMAT_LETTER_LANDSCAPE: mxRectangle;\r\n        static NONE: string;\r\n        static STYLE_PERIMETER: string;\r\n        static STYLE_SOURCE_PORT: string;\r\n        static STYLE_TARGET_PORT: string;\r\n        static STYLE_PORT_CONSTRAINT: string;\r\n        static STYLE_PORT_CONSTRAINT_ROTATION: string;\r\n        static STYLE_SOURCE_PORT_CONSTRAINT: string;\r\n        static STYLE_TARGET_PORT_CONSTRAINT: string;\r\n        static STYLE_OPACITY: string;\r\n        static STYLE_FILL_OPACITY: string;\r\n        static STYLE_STROKE_OPACITY: string;\r\n        static STYLE_TEXT_OPACITY: string;\r\n        static STYLE_TEXT_DIRECTION: string;\r\n        static STYLE_OVERFLOW: string;\r\n        static STYLE_ORTHOGONAL: string;\r\n        static STYLE_EXIT_X: string;\r\n        static STYLE_EXIT_Y: string;\r\n        static STYLE_EXIT_PERIMETER: string;\r\n        static STYLE_ENTRY_X: string;\r\n        static STYLE_ENTRY_Y: string;\r\n        static STYLE_ENTRY_PERIMETER: string;\r\n        static STYLE_WHITE_SPACE: string;\r\n        static STYLE_ROTATION: string;\r\n        static STYLE_FILLCOLOR: string;\r\n        static STYLE_POINTER_EVENTS: string;\r\n        static STYLE_SWIMLANE_FILLCOLOR: string;\r\n        static STYLE_MARGIN: string;\r\n        static STYLE_GRADIENTCOLOR: string;\r\n        static STYLE_GRADIENT_DIRECTION: string;\r\n        static STYLE_STROKECOLOR: string;\r\n        static STYLE_SEPARATORCOLOR: string;\r\n        static STYLE_STROKEWIDTH: string;\r\n        static STYLE_ALIGN: string;\r\n        static STYLE_VERTICAL_ALIGN: string;\r\n        static STYLE_LABEL_WIDTH: string;\r\n        static STYLE_LABEL_POSITION: string;\r\n        static STYLE_VERTICAL_LABEL_POSITION: string;\r\n        static STYLE_IMAGE_ASPECT: string;\r\n        static STYLE_IMAGE_ALIGN: string;\r\n        static STYLE_IMAGE_VERTICAL_ALIGN: string;\r\n        static STYLE_GLASS: string;\r\n        static STYLE_IMAGE: string;\r\n        static STYLE_IMAGE_WIDTH: string;\r\n        static STYLE_IMAGE_HEIGHT: string;\r\n        static STYLE_IMAGE_BACKGROUND: string;\r\n        static STYLE_IMAGE_BORDER: string;\r\n        static STYLE_FLIPH: string;\r\n        static STYLE_FLIPV: string;\r\n        static STYLE_NOLABEL: string;\r\n        static STYLE_NOEDGESTYLE: string;\r\n        static STYLE_LABEL_BACKGROUNDCOLOR: string;\r\n        static STYLE_LABEL_BORDERCOLOR: string;\r\n        static STYLE_LABEL_PADDING: string;\r\n        static STYLE_INDICATOR_SHAPE: string;\r\n        static STYLE_INDICATOR_IMAGE: string;\r\n        static STYLE_INDICATOR_COLOR: string;\r\n        static STYLE_INDICATOR_STROKECOLOR: string;\r\n        static STYLE_INDICATOR_GRADIENTCOLOR: string;\r\n        static STYLE_INDICATOR_SPACING: string;\r\n        static STYLE_INDICATOR_WIDTH: string;\r\n        static STYLE_INDICATOR_HEIGHT: string;\r\n        static STYLE_INDICATOR_DIRECTION: string;\r\n        static STYLE_SHADOW: string;\r\n        static STYLE_SEGMENT: string;\r\n        static STYLE_ENDARROW: string;\r\n        static STYLE_STARTARROW: string;\r\n        static STYLE_ENDSIZE: string;\r\n        static STYLE_STARTSIZE: string;\r\n        static STYLE_SWIMLANE_LINE: string;\r\n        static STYLE_ENDFILL: string;\r\n        static STYLE_STARTFILL: string;\r\n        static STYLE_DASHED: string;\r\n        static STYLE_DASH_PATTERN: string;\r\n        static STYLE_FIX_DASH: string;\r\n        static STYLE_ROUNDED: string;\r\n        static STYLE_CURVED: string;\r\n        static STYLE_ARCSIZE: string;\r\n        static STYLE_ABSOLUTE_ARCSIZE: string;\r\n        static STYLE_SOURCE_PERIMETER_SPACING: string;\r\n        static STYLE_TARGET_PERIMETER_SPACING: string;\r\n        static STYLE_PERIMETER_SPACING: string;\r\n        static STYLE_SPACING: string;\r\n        static STYLE_SPACING_TOP: string;\r\n        static STYLE_SPACING_LEFT: string;\r\n        static STYLE_SPACING_BOTTOM: string;\r\n        static STYLE_SPACING_RIGHT: string;\r\n        static STYLE_HORIZONTAL: string;\r\n        static STYLE_DIRECTION: string;\r\n        static STYLE_ELBOW: string;\r\n        static STYLE_FONTCOLOR: string;\r\n        static STYLE_FONTFAMILY: string;\r\n        static STYLE_FONTSIZE: string;\r\n        static STYLE_FONTSTYLE: string;\r\n        static STYLE_ASPECT: string;\r\n        static STYLE_AUTOSIZE: string;\r\n        static STYLE_FOLDABLE: string;\r\n        static STYLE_EDITABLE: string;\r\n        static STYLE_BENDABLE: string;\r\n        static STYLE_MOVABLE: string;\r\n        static STYLE_RESIZABLE: string;\r\n        static STYLE_RESIZE_WIDTH: string;\r\n        static STYLE_RESIZE_HEIGHT: string;\r\n        static STYLE_ROTATABLE: string;\r\n        static STYLE_CLONEABLE: string;\r\n        static STYLE_DELETABLE: string;\r\n        static STYLE_SHAPE: string;\r\n        static STYLE_EDGE: string;\r\n        static STYLE_JETTY_SIZE: string;\r\n        static STYLE_SOURCE_JETTY_SIZE: string;\r\n        static STYLE_TARGET_JETTY_SIZE: string;\r\n        static STYLE_LOOP: string;\r\n        static STYLE_ORTHOGONAL_LOOP: string;\r\n        static STYLE_ROUTING_CENTER_X: string;\r\n        static STYLE_ROUTING_CENTER_Y: string;\r\n        static FONT_BOLD: number;\r\n        static FONT_ITALIC: number;\r\n        static FONT_UNDERLINE: number;\r\n        static SHAPE_RECTANGLE: string;\r\n        static SHAPE_ELLIPSE: string;\r\n        static SHAPE_DOUBLE_ELLIPSE: string;\r\n        static SHAPE_RHOMBUS: string;\r\n        static SHAPE_LINE: string;\r\n        static SHAPE_IMAGE: string;\r\n        static SHAPE_ARROW: string;\r\n        static SHAPE_ARROW_CONNECTOR: string;\r\n        static SHAPE_LABEL: string;\r\n        static SHAPE_CYLINDER: string;\r\n        static SHAPE_SWIMLANE: string;\r\n        static SHAPE_CONNECTOR: string;\r\n        static SHAPE_ACTOR: string;\r\n        static SHAPE_CLOUD: string;\r\n        static SHAPE_TRIANGLE: string;\r\n        static SHAPE_HEXAGON: string;\r\n        static ARROW_CLASSIC: string;\r\n        static ARROW_CLASSIC_THIN: string;\r\n        static ARROW_BLOCK: string;\r\n        static ARROW_BLOCK_THIN: string;\r\n        static ARROW_OPEN: string;\r\n        static ARROW_OPEN_THIN: string;\r\n        static ARROW_OVAL: string;\r\n        static ARROW_DIAMOND: string;\r\n        static ARROW_DIAMOND_THIN: string;\r\n        static ALIGN_LEFT: string;\r\n        static ALIGN_CENTER: string;\r\n        static ALIGN_RIGHT: string;\r\n        static ALIGN_TOP: string;\r\n        static ALIGN_MIDDLE: string;\r\n        static ALIGN_BOTTOM: string;\r\n        static DIRECTION_NORTH: string;\r\n        static DIRECTION_SOUTH: string;\r\n        static DIRECTION_EAST: string;\r\n        static DIRECTION_WEST: string;\r\n        static TEXT_DIRECTION_DEFAULT: string;\r\n        static TEXT_DIRECTION_AUTO: string;\r\n        static TEXT_DIRECTION_LTR: string;\r\n        static TEXT_DIRECTION_RTL: string;\r\n        static DIRECTION_MASK_NONE: number;\r\n        static DIRECTION_MASK_WEST: number;\r\n        static DIRECTION_MASK_NORTH: number;\r\n        static DIRECTION_MASK_SOUTH: number;\r\n        static DIRECTION_MASK_EAST: number;\r\n        static DIRECTION_MASK_ALL: number;\r\n        static ELBOW_VERTICAL: string;\r\n        static ELBOW_HORIZONTAL: string;\r\n        static EDGESTYLE_ELBOW: string;\r\n        static EDGESTYLE_ENTITY_RELATION: string;\r\n        static EDGESTYLE_LOOP: string;\r\n        static EDGESTYLE_SIDETOSIDE: string;\r\n        static EDGESTYLE_TOPTOBOTTOM: string;\r\n        static EDGESTYLE_ORTHOGONAL: string;\r\n        static EDGESTYLE_SEGMENT: string;\r\n        static PERIMETER_ELLIPSE: string;\r\n        static PERIMETER_RECTANGLE: string;\r\n        static PERIMETER_RHOMBUS: string;\r\n        static PERIMETER_HEXAGON: string;\r\n        static PERIMETER_TRIANGLE: string;\r\n    }\r\n\r\n    /**\r\n     * The mxEventObject is a wrapper for all properties of a single event.\r\n     * Additionally, it also offers functions to consume the event and check if it\r\n     * was consumed as follows:\r\n     *\r\n     * @example\r\n     * evt.consume();\r\n     * INV: evt.isConsumed() == true\r\n     */\r\n    export declare class mxEventObject {\r\n        /**\r\n         * Holds the name.\r\n         */\r\n        name: string;\r\n        /**\r\n         * Holds the properties as an associative array.\r\n         */\r\n        properties: any;\r\n        /**\r\n         * Holds the consumed state. Default is false.\r\n         */\r\n        consumed: boolean;\r\n        /**\r\n         * Constructs a new event object with the specified name. An optional\r\n         * sequence of key, value pairs can be appended to define properties.\r\n         *\r\n         * @example\r\n         * new mxEventObject(\"eventName\", key1, val1, .., keyN, valN)\r\n         */\r\n        constructor(name?: any, ...args: any[]);\r\n        /**\r\n         * Returns <name>.\r\n         */\r\n        getName(): string;\r\n        /**\r\n         * Returns <properties>.\r\n         */\r\n        getProperties(): any;\r\n        /**\r\n         * Returns the property for the given key.\r\n         */\r\n        getProperty(key: any): any;\r\n        /**\r\n         * Returns true if the event has been consumed.\r\n         */\r\n        isConsumed(): boolean;\r\n        /**\r\n         * Consumes the event.\r\n         */\r\n        consume(): void;\r\n    }\r\n\r\n    /**\r\n     * Base class for all mouse events in mxGraph. A listener for this event should\r\n     * implement the following methods:\r\n     *\r\n     * (code)\r\n     * graph.addMouseListener(\r\n     * {\r\n     *   mouseDown: function(sender, evt)\r\n     *   {\r\n     *     mxLog.debug('mouseDown');\r\n     *   },\r\n     *   mouseMove: function(sender, evt)\r\n     *   {\r\n     *     mxLog.debug('mouseMove');\r\n     *   },\r\n     *   mouseUp: function(sender, evt)\r\n     *   {\r\n     *     mxLog.debug('mouseUp');\r\n     *   }\r\n     * });\r\n     * (end)\r\n     *\r\n     * Constructor: mxMouseEvent\r\n     *\r\n     * Constructs a new event object for the given arguments.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * evt - Native mouse event.\r\n     * state - Optional <mxCellState> under the mouse.\r\n     *\r\n     */\r\n    export declare class mxMouseEvent {\r\n        constructor(evt: any, state?: any);\r\n        /**\r\n         * Returns <evt>.\r\n         */\r\n        getEvent(): any;\r\n        /**\r\n         * Returns the target DOM element using <mxEvent.getSource> for <evt>.\r\n         */\r\n        getSource(): any;\r\n        /**\r\n         * Returns true if the given <mxShape> is the source of <evt>.\r\n         */\r\n        isSource(shape: any): any;\r\n        /**\r\n         * Returns <evt.clientX>.\r\n         */\r\n        getX(): any;\r\n        /**\r\n         * Returns <evt.clientY>.\r\n         */\r\n        getY(): any;\r\n        /**\r\n         * Returns <graphX>.\r\n         */\r\n        getGraphX(): any;\r\n        /**\r\n         * Returns <graphY>.\r\n         */\r\n        getGraphY(): any;\r\n        /**\r\n         * Returns <state>.\r\n         */\r\n        getState(): any;\r\n        /**\r\n         * Returns the <mxCell> in <state> is not null.\r\n         */\r\n        getCell(): any;\r\n        /**\r\n         * Returns true if the event is a popup trigger.\r\n         */\r\n        isPopupTrigger(): boolean;\r\n        /**\r\n         * Returns <consumed>.\r\n         */\r\n        isConsumed(): any;\r\n        /**\r\n         * Sets <consumed> to true and invokes preventDefault on the native event\r\n         * if such a method is defined. This is used mainly to avoid the cursor from\r\n         * being changed to a text cursor in Webkit. You can use the preventDefault\r\n         * flag to disable this functionality.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * preventDefault - Specifies if the native event should be canceled. Default\r\n         * is true.\r\n         */\r\n        consume(preventDefault?: any): void;\r\n    }\r\n\r\n    /**\r\n     * Base class for objects that dispatch named events. To create a subclass that\r\n     * inherits from mxEventSource, the following code is used.\r\n     *\r\n     * (code)\r\n     * function MyClass() { };\r\n     *\r\n     * MyClass.prototype = new mxEventSource();\r\n     * MyClass.prototype.constructor = MyClass;\r\n     * (end)\r\n     *\r\n     * Known Subclasses:\r\n     *\r\n     * <mxGraphModel>, <mxGraph>, <mxGraphView>, <mxEditor>, <mxCellOverlay>,\r\n     * <mxToolbar>, <mxWindow>\r\n     */\r\n    export declare class mxEventSource {\r\n        /**\r\n         * Holds the event names and associated listeners in an array. The array\r\n         * contains the event name followed by the respective listener for each\r\n         * registered listener.\r\n         */\r\n        eventListeners: any;\r\n        /**\r\n         * Specifies if events can be fired. Default is true.\r\n         */\r\n        eventsEnabled: boolean;\r\n        /**\r\n         * Optional source for events. Default is null.\r\n         */\r\n        eventSource: any;\r\n        /**\r\n         * Constructs a new event source.\r\n         */\r\n        constructor(eventSource?: any);\r\n        /**\r\n         * Returns <eventsEnabled>.\r\n         */\r\n        isEventsEnabled(): boolean;\r\n        /**\r\n         * Sets <eventsEnabled>.\r\n         */\r\n        setEventsEnabled(value: any): void;\r\n        /**\r\n         * Returns <eventSource>.\r\n         */\r\n        getEventSource(): any;\r\n        /**\r\n         * Sets <eventSource>.\r\n         */\r\n        setEventSource(value: any): void;\r\n        /**\r\n         * Binds the specified function to the given event name. If no event name\r\n         * is given, then the listener is registered for all events.\r\n         *\r\n         * The parameters of the listener are the sender and an <mxEventObject>.\r\n         */\r\n        addListener(name: any, funct: any): void;\r\n        /**\r\n         * Removes all occurrences of the given listener from <eventListeners>.\r\n         */\r\n        removeListener(funct: any): void;\r\n        /**\r\n         * Dispatches the given event to the listeners which are registered for\r\n         * the event. The sender argument is optional. The current execution scope\r\n         * (\"this\") is used for the listener invocation (see <mxUtils.bind>).\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * fireEvent(new mxEventObject(\"eventName\", key1, val1, .., keyN, valN))\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - <mxEventObject> that represents the event.\r\n         * sender - Optional sender to be passed to the listener. Default value is\r\n         * the return value of <getEventSource>.\r\n         */\r\n        fireEvent(evt: mxEventObject, sender?: mxEventSource): void;\r\n    }\r\n\r\n\r\n    export declare var mxEvent: {\r\n        EVENT_SCALE: string;\r\n        EVENT_HIDE: string;\r\n\r\n        objects: any[];\r\n        addListener: (element: any, eventName: any, funct: any) => void;\r\n        removeListener: (element: any, eventName: any, funct: any) => void;\r\n        removeAllListeners(element: any): void;\r\n        addGestureListeners(node: any, startListener: any, moveListener?: any, endListener?: any): void;\r\n        removeGestureListeners(node: any, startListener: any, moveListener?: any, endListener?: any): void;\r\n        redirectMouseEvents(node: any, graph: any, state: any, down?: any, move?: any, up?: any, dblClick?: any): void;\r\n        release(element: any): void;\r\n        addMouseWheelListener(funct: (evt: any, up: boolean) => void, target?: HTMLElement): void;\r\n        disableContextMenu: (element: any) => void;\r\n        getSource(evt: any): any;\r\n        isConsumed(evt: any): boolean;\r\n        isTouchEvent(evt: any): boolean;\r\n        isPenEvent(evt: any): boolean;\r\n        isMultiTouchEvent(evt: any): boolean;\r\n        isMouseEvent(evt: any): boolean;\r\n        isLeftMouseButton(evt: any): boolean;\r\n        isMiddleMouseButton(evt: any): boolean;\r\n        isRightMouseButton(evt: any): boolean;\r\n        isPopupTrigger(evt: any): boolean;\r\n        isShiftDown(evt: any): boolean;\r\n        isAltDown(evt: any): boolean;\r\n        isControlDown(evt: any): boolean;\r\n        isMetaDown(evt: any): boolean;\r\n        getMainEvent(e: any): any;\r\n        getClientX(e: PointerEvent): number;\r\n        getClientY(e: PointerEvent): number;\r\n        consume(evt: any, preventDefault?: boolean, stopPropagation?: boolean): void;\r\n        LABEL_HANDLE: number;\r\n        ROTATION_HANDLE: number;\r\n        CUSTOM_HANDLE: number;\r\n        VIRTUAL_HANDLE: number;\r\n        MOUSE_DOWN: string;\r\n        MOUSE_MOVE: string;\r\n        MOUSE_UP: string;\r\n        ACTIVATE: string;\r\n        RESIZE_START: string;\r\n        RESIZE: string;\r\n        RESIZE_END: string;\r\n        MOVE_START: string;\r\n        MOVE: string;\r\n        MOVE_END: string;\r\n        PAN_START: string;\r\n        PAN: string;\r\n        PAN_END: string;\r\n        MINIMIZE: string;\r\n        NORMALIZE: string;\r\n        MAXIMIZE: string;\r\n        HIDE: string;\r\n        SHOW: string;\r\n        CLOSE: string;\r\n        DESTROY: string;\r\n        REFRESH: string;\r\n        SIZE: string;\r\n        SELECT: string;\r\n        FIRED: string;\r\n        FIRE_MOUSE_EVENT: string;\r\n        GESTURE: string;\r\n        TAP_AND_HOLD: string;\r\n        GET: string;\r\n        RECEIVE: string;\r\n        CONNECT: string;\r\n        DISCONNECT: string;\r\n        SUSPEND: string;\r\n        RESUME: string;\r\n        MARK: string;\r\n        ROOT: string;\r\n        POST: string;\r\n        OPEN: string;\r\n        SAVE: string;\r\n        BEFORE_ADD_VERTEX: string;\r\n        ADD_VERTEX: string;\r\n        AFTER_ADD_VERTEX: string;\r\n        DONE: string;\r\n        EXECUTE: string;\r\n        EXECUTED: string;\r\n        BEGIN_UPDATE: string;\r\n        START_EDIT: string;\r\n        END_UPDATE: string;\r\n        END_EDIT: string;\r\n        BEFORE_UNDO: string;\r\n        UNDO: string;\r\n        REDO: string;\r\n        CHANGE: string;\r\n        NOTIFY: string;\r\n        LAYOUT_CELLS: string;\r\n        CLICK: string;\r\n        SCALE: string;\r\n        TRANSLATE: string;\r\n        SCALE_AND_TRANSLATE: string;\r\n        UP: string;\r\n        DOWN: string;\r\n        ADD: string;\r\n        REMOVE: string;\r\n        CLEAR: string;\r\n        ADD_CELLS: string;\r\n        CELLS_ADDED: string;\r\n        MOVE_CELLS: string;\r\n        CELLS_MOVED: string;\r\n        RESIZE_CELLS: string;\r\n        CELLS_RESIZED: string;\r\n        TOGGLE_CELLS: string;\r\n        CELLS_TOGGLED: string;\r\n        ORDER_CELLS: string;\r\n        CELLS_ORDERED: string;\r\n        REMOVE_CELLS: string;\r\n        CELLS_REMOVED: string;\r\n        GROUP_CELLS: string;\r\n        UNGROUP_CELLS: string;\r\n        REMOVE_CELLS_FROM_PARENT: string;\r\n        FOLD_CELLS: string;\r\n        CELLS_FOLDED: string;\r\n        ALIGN_CELLS: string;\r\n        LABEL_CHANGED: string;\r\n        CONNECT_CELL: string;\r\n        CELL_CONNECTED: string;\r\n        SPLIT_EDGE: string;\r\n        FLIP_EDGE: string;\r\n        START_EDITING: string;\r\n        EDITING_STARTED: string;\r\n        EDITING_STOPPED: string;\r\n        ADD_OVERLAY: string;\r\n        REMOVE_OVERLAY: string;\r\n        UPDATE_CELL_SIZE: string;\r\n        ESCAPE: string;\r\n        DOUBLE_CLICK: string;\r\n        START: string;\r\n        RESET: string;\r\n    };\r\n\r\n    /**\r\n     * XML HTTP request wrapper. See also: <mxUtils.get>, <mxUtils.post> and\r\n     * <mxUtils.load>. This class provides a cross-browser abstraction for Ajax\r\n     * requests.\r\n     *\r\n     * Encoding:\r\n     *\r\n     * For encoding parameter values, the built-in encodeURIComponent JavaScript\r\n     * method must be used. For automatic encoding of post data in <mxEditor> the\r\n     * <mxEditor.escapePostData> switch can be set to true (default). The encoding\r\n     * will be carried out using the conte type of the page. That is, the page\r\n     * containting the editor should contain a meta tag in the header, eg.\r\n     * <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var onload = function(req)\r\n     * {\r\n     *   mxUtils.alert(req.getDocumentElement());\r\n     * }\r\n     *\r\n     * var onerror = function(req)\r\n     * {\r\n     *   mxUtils.alert('Error');\r\n     * }\r\n     * new mxXmlRequest(url, 'key=value').send(onload, onerror);\r\n     * (end)\r\n     *\r\n     * Sends an asynchronous POST request to the specified URL.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var req = new mxXmlRequest(url, 'key=value', 'POST', false);\r\n     * req.send();\r\n     * mxUtils.alert(req.getDocumentElement());\r\n     * (end)\r\n     *\r\n     * Sends a synchronous POST request to the specified URL.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var encoder = new mxCodec();\r\n     * var result = encoder.encode(graph.getModel());\r\n     * var xml = encodeURIComponent(mxUtils.getXml(result));\r\n     * new mxXmlRequest(url, 'xml='+xml).send();\r\n     * (end)\r\n     *\r\n     * Sends an encoded graph model to the specified URL using xml as the\r\n     * parameter name. The parameter can then be retrieved in C# as follows:\r\n     *\r\n     * (code)\r\n     * string xml = HttpUtility.UrlDecode(context.Request.Params[\"xml\"]);\r\n     * (end)\r\n     *\r\n     * Or in Java as follows:\r\n     *\r\n     * (code)\r\n     * String xml = URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\");\r\n     * (end)\r\n     *\r\n     * Note that the linefeeds should only be replaced if the XML is\r\n     * processed in Java, for example when creating an image.\r\n     *\r\n     * Constructor: mxXmlRequest\r\n     *\r\n     * Constructs an XML HTTP request.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * url - Target URL of the request.\r\n     * params - Form encoded parameters to send with a POST request.\r\n     * method - String that specifies the request method. Possible values are\r\n     * POST and GET. Default is POST.\r\n     * async - Boolean specifying if an asynchronous request should be used.\r\n     * Default is true.\r\n     * username - String specifying the username to be used for the request.\r\n     * password - String specifying the password to be used for the request.\r\n     */\r\n    export declare class mxXmlRequest {\r\n        constructor(url: any, params: any, method: any, async: any, username: any, password: any);\r\n        /**\r\n         * Returns <binary>.\r\n         */\r\n        isBinary(): any;\r\n        /**\r\n         * Sets <binary>.\r\n         */\r\n        setBinary(value: any): void;\r\n        /**\r\n         * Returns true if the response is ready.\r\n         */\r\n        isReady(): boolean;\r\n        /**\r\n         * Returns the document element of the response XML document.\r\n         */\r\n        getDocumentElement(): any;\r\n        /**\r\n         * Returns the response as an XML document. Use <getDocumentElement> to get\r\n         * the document element of the XML document.\r\n         */\r\n        getXml(): any;\r\n        /**\r\n         * Returns the response as a string.\r\n         */\r\n        getText(): any;\r\n        /**\r\n         * Returns the status as a number, eg. 404 for \"Not found\" or 200 for \"OK\".\r\n         * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be cought.\r\n         */\r\n        getStatus(): any;\r\n        /**\r\n         * Send the <request> to the target URL using the specified functions to\r\n         * process the response asychronously.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * onload - Function to be invoked if a successful response was received.\r\n         * onerror - Function to be called on any error.\r\n         * timeout - Optional timeout in ms before calling ontimeout.\r\n         * ontimeout - Optional function to execute on timeout.\r\n         */\r\n        send(onload: any, onerror: any, timeout: any, ontimeout: any): void;\r\n        /**\r\n         * Sets the headers for the given request and parameters. This sets the\r\n         * content-type to application/x-www-form-urlencoded if any params exist.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * request.setRequestHeaders = function(request, params)\r\n         * {\r\n         *   if (params != null)\r\n         *   {\r\n         *     request.setRequestHeader('Content-Type',\r\n         *             'multipart/form-data');\r\n         *     request.setRequestHeader('Content-Length',\r\n         *             params.length);\r\n         *   }\r\n         * };\r\n         * (end)\r\n         *\r\n         * Use the code above before calling <send> if you require a\r\n         * multipart/form-data request.\r\n         */\r\n        setRequestHeaders(request: any, params: any): void;\r\n        /**\r\n         * Creates and posts a request to the given target URL using a dynamically\r\n         * created form inside the given document.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * docs - Document that contains the form element.\r\n         * target - Target to send the form result to.\r\n         */\r\n        simulate(doc: any, target: any): void;\r\n    }\r\n\r\n\r\n    export declare var mxClipboard: {\r\n        STEPSIZE: number;\r\n        insertCount: number;\r\n        cells: any;\r\n        setCells(cells: any): void;\r\n        getCells(): any;\r\n        isEmpty(): boolean;\r\n        cut(graph: any, cells?: any): any;\r\n        removeCells(graph: any, cells: any): void;\r\n        copy(graph: any, cells?: any): any;\r\n        paste(graph: any): any;\r\n    };\r\n\r\n    /**\r\n     * Basic window inside a document.\r\n     *\r\n     * Examples:\r\n     *\r\n     * Creating a simple window.\r\n     *\r\n     * (code)\r\n     * var tb = document.createElement('div');\r\n     * var wnd = new mxWindow('Title', tb, 100, 100, 200, 200, true, true);\r\n     * wnd.setVisible(true);\r\n     * (end)\r\n     *\r\n     * Creating a window that contains an iframe.\r\n     *\r\n     * (code)\r\n     * var frame = document.createElement('iframe');\r\n     * frame.setAttribute('width', '192px');\r\n     * frame.setAttribute('height', '172px');\r\n     * frame.setAttribute('src', 'http://www.example.com/');\r\n     * frame.style.backgroundColor = 'white';\r\n     *\r\n     * var w = document.body.clientWidth;\r\n     * var h = (document.body.clientHeight || document.documentElement.clientHeight);\r\n     * var wnd = new mxWindow('Title', frame, (w-200)/2, (h-200)/3, 200, 200);\r\n     * wnd.setVisible(true);\r\n     * (end)\r\n     *\r\n     * To limit the movement of a window, eg. to keep it from being moved beyond\r\n     * the top, left corner the following method can be overridden (recommended):\r\n     *\r\n     * (code)\r\n     * wnd.setLocation = function(x, y)\r\n     * {\r\n     *   x = Math.max(0, x);\r\n     *   y = Math.max(0, y);\r\n     *   mxWindow.prototype.setLocation.apply(this, arguments);\r\n     * };\r\n     * (end)\r\n     *\r\n     * Or the following event handler can be used:\r\n     *\r\n     * (code)\r\n     * wnd.addListener(mxEvent.MOVE, function(e)\r\n     * {\r\n     *   wnd.setLocation(Math.max(0, wnd.getX()), Math.max(0, wnd.getY()));\r\n     * });\r\n     * (end)\r\n     *\r\n     * To keep a window inside the current window:\r\n     *\r\n     * (code)\r\n     * mxEvent.addListener(window, 'resize', mxUtils.bind(this, function()\r\n     * {\r\n     *   var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\r\n     *   var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\r\n     *\r\n     *   var x = this.window.getX();\r\n     *   var y = this.window.getY();\r\n     *\r\n     *   if (x + this.window.table.clientWidth > iw)\r\n     *   {\r\n     *     x = Math.max(0, iw - this.window.table.clientWidth);\r\n     *   }\r\n     *\r\n     *   if (y + this.window.table.clientHeight > ih)\r\n     *   {\r\n     *     y = Math.max(0, ih - this.window.table.clientHeight);\r\n     *   }\r\n     *\r\n     *   if (this.window.getX() != x || this.window.getY() != y)\r\n     *   {\r\n     *     this.window.setLocation(x, y);\r\n     *   }\r\n     * }));\r\n     * (end)\r\n     *\r\n     * Event: mxEvent.MOVE_START\r\n     *\r\n     * Fires before the window is moved. The <code>event</code> property contains\r\n     * the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.MOVE\r\n     *\r\n     * Fires while the window is being moved. The <code>event</code> property\r\n     * contains the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.MOVE_END\r\n     *\r\n     * Fires after the window is moved. The <code>event</code> property contains\r\n     * the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.RESIZE_START\r\n     *\r\n     * Fires before the window is resized. The <code>event</code> property contains\r\n     * the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.RESIZE\r\n     *\r\n     * Fires while the window is being resized. The <code>event</code> property\r\n     * contains the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.RESIZE_END\r\n     *\r\n     * Fires after the window is resized. The <code>event</code> property contains\r\n     * the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.MAXIMIZE\r\n     *\r\n     * Fires after the window is maximized. The <code>event</code> property\r\n     * contains the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.MINIMIZE\r\n     *\r\n     * Fires after the window is minimized. The <code>event</code> property\r\n     * contains the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.NORMALIZE\r\n     *\r\n     * Fires after the window is normalized, that is, it returned from\r\n     * maximized or minimized state. The <code>event</code> property contains the\r\n     * corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.ACTIVATE\r\n     *\r\n     * Fires after a window is activated. The <code>previousWindow</code> property\r\n     * contains the previous window. The event sender is the active window.\r\n     *\r\n     * Event: mxEvent.SHOW\r\n     *\r\n     * Fires after the window is shown. This event has no properties.\r\n     *\r\n     * Event: mxEvent.HIDE\r\n     *\r\n     * Fires after the window is hidden. This event has no properties.\r\n     *\r\n     * Event: mxEvent.CLOSE\r\n     *\r\n     * Fires before the window is closed. The <code>event</code> property contains\r\n     * the corresponding mouse event.\r\n     *\r\n     * Event: mxEvent.DESTROY\r\n     *\r\n     * Fires before the window is destroyed. This event has no properties.\r\n     *\r\n     * Constructor: mxWindow\r\n     *\r\n     * Constructs a new window with the given dimension and title to display\r\n     * the specified content. The window elements use the given style as a\r\n     * prefix for the classnames of the respective window elements, namely,\r\n     * the window title and window pane. The respective postfixes are appended\r\n     * to the given stylename as follows:\r\n     *\r\n     *   style - Base style for the window.\r\n     *   style+Title - Style for the window title.\r\n     *   style+Pane - Style for the window pane.\r\n     *\r\n     * The default value for style is mxWindow, resulting in the following\r\n     * classnames for the window elements: mxWindow, mxWindowTitle and\r\n     * mxWindowPane.\r\n     *\r\n     * If replaceNode is given then the window replaces the given DOM node in\r\n     * the document.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * title - String that represents the title of the new window.\r\n     * content - DOM node that is used as the window content.\r\n     * x - X-coordinate of the window location.\r\n     * y - Y-coordinate of the window location.\r\n     * width - Width of the window.\r\n     * height - Optional height of the window. Default is to match the height\r\n     * of the content at the specified width.\r\n     * minimizable - Optional boolean indicating if the window is minimizable.\r\n     * Default is true.\r\n     * movable - Optional boolean indicating if the window is movable. Default\r\n     * is true.\r\n     * replaceNode - Optional DOM node that the window should replace.\r\n     * style - Optional base classname for the window elements. Default is\r\n     * mxWindow.\r\n     */\r\n    export declare class mxWindow extends mxEventSource {\r\n        table: HTMLTableElement;\r\n        destroyOnClose: boolean;\r\n        constructor(title: any, content: any, x: any, y: any, width: any, height: any, minimizable: any, movable: any, replaceNode?: any, style?: any);\r\n        /**\r\n         * Initializes the DOM tree that represents the window.\r\n         */\r\n        init(x: any, y: any, width: any, height: any, style: any): void;\r\n        /**\r\n         * Sets the window title to the given string. HTML markup inside the title\r\n         * will be escaped.\r\n         */\r\n        setTitle(title: any): void;\r\n        /**\r\n         * Sets if the window contents should be scrollable.\r\n         */\r\n        setScrollable(scrollable: any): void;\r\n        /**\r\n         * Puts the window on top of all other windows.\r\n         */\r\n        activate(): void;\r\n        /**\r\n         * Returuns the outermost DOM node that makes up the window.\r\n         */\r\n        getElement(): any;\r\n        /**\r\n         * Makes sure the window is inside the client area of the window.\r\n         */\r\n        fit(): void;\r\n        /**\r\n         * Returns true if the window is resizable.\r\n         */\r\n        isResizable(): boolean;\r\n        /**\r\n         * Sets if the window should be resizable. To avoid interference with some\r\n         * built-in features of IE10 and later, the use of the following code is\r\n         * recommended if there are resizable <mxWindow>s in the page:\r\n         *\r\n         * (code)\r\n         * if (mxClient.IS_POINTER)\r\n         * {\r\n         *   document.body.style.msTouchAction = 'none';\r\n         * }\r\n         * (end)\r\n         */\r\n        setResizable(resizable: any): void;\r\n        /**\r\n         * Sets the size of the window.\r\n         */\r\n        setSize(width: any, height: any): void;\r\n        /**\r\n         * Sets if the window is minimizable.\r\n         */\r\n        setMinimizable(minimizable: any): void;\r\n        /**\r\n         * Returns an <mxRectangle> that specifies the size for the minimized window.\r\n         * A width or height of 0 means keep the existing width or height. This\r\n         * implementation returns the height of the window title and keeps the width.\r\n         */\r\n        getMinimumSize(): mxRectangle;\r\n        /**\r\n         * Installs the event listeners required for minimizing the window.\r\n         */\r\n        installMinimizeHandler(): void;\r\n        /**\r\n         * Sets if the window is maximizable.\r\n         */\r\n        setMaximizable(maximizable: any): void;\r\n        /**\r\n         * Installs the event listeners required for maximizing the window.\r\n         */\r\n        installMaximizeHandler(): void;\r\n        /**\r\n         * Installs the event listeners required for moving the window.\r\n         */\r\n        installMoveHandler(): void;\r\n        /**\r\n         * Sets the upper, left corner of the window.\r\n         */\r\n        setLocation(x: any, y: any): void;\r\n        /**\r\n         * Returns the current position on the x-axis.\r\n         */\r\n        getX(): number;\r\n        /**\r\n         * Returns the current position on the y-axis.\r\n         */\r\n        getY(): number;\r\n        /**\r\n         * Adds the <closeImage> as a new image node in <closeImg> and installs the\r\n         * <close> event.\r\n         */\r\n        installCloseHandler(): void;\r\n        /**\r\n         * Sets the image associated with the window.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * image - URL of the image to be used.\r\n         */\r\n        setImage(image: any): void;\r\n        /**\r\n         * Sets the image associated with the window.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * closable - Boolean specifying if the window should be closable.\r\n         */\r\n        setClosable(closable: any): void;\r\n        /**\r\n         * Returns true if the window is visible.\r\n         */\r\n        isVisible(): boolean;\r\n        /**\r\n         * Shows or hides the window depending on the given flag.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * visible - Boolean indicating if the window should be made visible.\r\n         */\r\n        setVisible(visible: any): void;\r\n        /**\r\n         * Shows the window.\r\n         */\r\n        show(): void;\r\n        /**\r\n         * Hides the window.\r\n         */\r\n        hide(): void;\r\n        /**\r\n         * Destroys the window and removes all associated resources. Fires a\r\n         * <destroy> event prior to destroying the window.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * A simple class for creating HTML forms.\r\n     *\r\n     * Constructor: mxForm\r\n     *\r\n     * Creates a HTML table using the specified classname.\r\n     */\r\n    export declare class mxForm {\r\n        constructor(className: any);\r\n        /**\r\n         * Returns the table that contains this form.\r\n         */\r\n        getTable(): any;\r\n        /**\r\n         * Helper method to add an OK and Cancel button using the respective\r\n         * functions.\r\n         */\r\n        addButtons(okFunct: any, cancelFunct: any): void;\r\n        /**\r\n         * Adds an input for the given name, type and value and returns it.\r\n         */\r\n        addText(name: any, value: any, type: any): any;\r\n        /**\r\n         * Adds a checkbox for the given name and value and returns the textfield.\r\n         */\r\n        addCheckbox(name: any, value: any): HTMLInputElement;\r\n        /**\r\n         * Adds a textarea for the given name and value and returns the textarea.\r\n         */\r\n        addTextarea(name: any, value: any, rows: any): any;\r\n        /**\r\n         * Adds a combo for the given name and returns the combo.\r\n         */\r\n        addCombo(name: any, isMultiSelect: any, size: any): any;\r\n        /**\r\n         * Adds an option for the given label to the specified combo.\r\n         */\r\n        addOption(combo: any, label: any, value: any, isSelected: any): void;\r\n        /**\r\n         * Adds a new row with the name and the input field in two columns and\r\n         * returns the given input.\r\n         */\r\n        addField(name: any, input: any): any;\r\n    }\r\n\r\n    /**\r\n     * Encapsulates the URL, width and height of an image.\r\n     */\r\n    export declare class mxImage {\r\n        /**\r\n         * String that specifies the URL of the image.\r\n         */\r\n        src: string;\r\n        /**\r\n         * Integer that specifies the width of the image.\r\n         */\r\n        width: number;\r\n        /**\r\n         * Integer that specifies the height of the image.\r\n         */\r\n        height: number;\r\n        /**\r\n         * Constructs a new image.\r\n         * @param src String that specifies the URL of the image.\r\n         * @param width Integer that specifies the width of the image.\r\n         * @param height Integer that specifies the height of the image.\r\n         */\r\n        constructor(src: any, width: any, height: any);\r\n    }\r\n\r\n    /**\r\n     * Maintains the size of a div element in Internet Explorer. This is a\r\n     * workaround for the right and bottom style being ignored in IE.\r\n     *\r\n     * If you need a div to cover the scrollwidth and -height of a document,\r\n     * then you can use this class as follows:\r\n     *\r\n     * (code)\r\n     * var resizer = new mxDivResizer(background);\r\n     * resizer.getDocumentHeight = function()\r\n     * {\r\n     *   return document.body.scrollHeight;\r\n     * }\r\n     * resizer.getDocumentWidth = function()\r\n     * {\r\n     *   return document.body.scrollWidth;\r\n     * }\r\n     * resizer.resize();\r\n     * (end)\r\n     *\r\n     * Constructor: mxDivResizer\r\n     *\r\n     * Constructs an object that maintains the size of a div\r\n     * element when the window is being resized. This is only\r\n     * required for Internet Explorer as it ignores the respective\r\n     * stylesheet information for DIV elements.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * div - Reference to the DOM node whose size should be maintained.\r\n     * container - Optional Container that contains the div. Default is the\r\n     * window.\r\n     */\r\n    export declare class mxDivResizer {\r\n        constructor(div: any, container: any);\r\n        /**\r\n         * Updates the style of the DIV after the window has been resized.\r\n         */\r\n        resize(): void;\r\n        /**\r\n         * Hook for subclassers to return the width of the document (without\r\n         * scrollbars).\r\n         */\r\n        getDocumentWidth(): number;\r\n        /**\r\n         * Hook for subclassers to return the height of the document (without\r\n         * scrollbars).\r\n         */\r\n        getDocumentHeight(): number;\r\n    }\r\n\r\n    /**\r\n     * Wrapper to create a drag source from a DOM element so that the element can\r\n     * be dragged over a graph and dropped into the graph as a new cell.\r\n     *\r\n     * Problem is that in the dropHandler the current preview location is not\r\n     * available, so the preview and the dropHandler must match.\r\n     *\r\n     * Constructor: mxDragSource\r\n     *\r\n     * Constructs a new drag source for the given element.\r\n     */\r\n    export declare class mxDragSource {\r\n        previewElement: HTMLDivElement;\r\n        currentGuide: mxGuide;\r\n        previewElementHeight: string;\r\n        previewElementWidth: string;\r\n        currentHighlight: mxCellHighlight;\r\n        dragElementZIndex: number;\r\n        /**\r\n         * Holds the DOM node that is used to represent the drag preview.  If this is null then the source element will be cloned and used for the drag preview.\r\n         */\r\n        dragElement: HTMLElement;\r\n        /**\r\n         * Reference to the mxGraph that is the current drop target.\r\n         */\r\n        currentGraph: mxGraph;\r\n        constructor(element: any, dropHandler: any);\r\n        /**\r\n         * Returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Sets <enabled>.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Returns <guidesEnabled>.\r\n         */\r\n        isGuidesEnabled(): boolean;\r\n        /**\r\n         * Sets <guidesEnabled>.\r\n         */\r\n        setGuidesEnabled(value: any): void;\r\n        /**\r\n         * Returns <gridEnabled>.\r\n         */\r\n        isGridEnabled(): any;\r\n        /**\r\n         * Sets <gridEnabled>.\r\n         */\r\n        setGridEnabled(value: any): void;\r\n        /**\r\n         * Returns the graph for the given mouse event. This implementation returns\r\n         * null.\r\n         */\r\n        getGraphForEvent(evt: any): any;\r\n        /**\r\n         * Returns the drop target for the given graph and coordinates. This\r\n         * implementation uses <mxGraph.getCellAt>.\r\n         */\r\n        getDropTarget(graph: any, x: any, y: any, evt: any): any;\r\n        /**\r\n         * Creates and returns a clone of the <dragElementPrototype> or the <element>\r\n         * if the former is not defined.\r\n         */\r\n        createDragElement(evt: any): any;\r\n        /**\r\n         * Creates and returns an element which can be used as a preview in the given\r\n         * graph.\r\n         */\r\n        createPreviewElement(graph: any): any;\r\n        /**\r\n         * Returns true if this drag source is active.\r\n         */\r\n        isActive(): boolean;\r\n        /**\r\n         * Stops and removes everything and restores the state of the object.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Returns the drop target for the given graph and coordinates. This\r\n         * implementation uses <mxGraph.getCellAt>.\r\n         *\r\n         * To ignore popup menu events for a drag source, this function can be\r\n         * overridden as follows.\r\n         *\r\n         * (code)\r\n         * var mouseDown = dragSource.mouseDown;\r\n         *\r\n         * dragSource.mouseDown = function(evt)\r\n         * {\r\n         *   if (!mxEvent.isPopupTrigger(evt))\r\n         *   {\r\n         *     mouseDown.apply(this, arguments);\r\n         *   }\r\n         * };\r\n         * (end)\r\n         */\r\n        mouseDown(evt: any): void;\r\n        /**\r\n         * Creates the <dragElement> using <createDragElement>.\r\n         */\r\n        startDrag(evt: any): void;\r\n        /**\r\n         * Invokes <removeDragElement>.\r\n         */\r\n        stopDrag(): void;\r\n        /**\r\n         * Removes and destroys the <dragElement>.\r\n         */\r\n        removeDragElement(): void;\r\n        /**\r\n         * Returns true if the given graph contains the given event.\r\n         */\r\n        graphContainsEvent(graph: any, evt: any): boolean;\r\n        /**\r\n         * Gets the graph for the given event using <getGraphForEvent>, updates the\r\n         * <currentGraph>, calling <dragEnter> and <dragExit> on the new and old graph,\r\n         * respectively, and invokes <dragOver> if <currentGraph> is not null.\r\n         */\r\n        mouseMove(evt: any): void;\r\n        /**\r\n         * Processes the mouse up event and invokes <drop>, <dragExit> and <stopDrag>\r\n         * as required.\r\n         */\r\n        mouseUp(evt: any): void;\r\n        /**\r\n         * Actives the given graph as a drop target.\r\n         */\r\n        removeListeners(): void;\r\n        /**\r\n         * Actives the given graph as a drop target.\r\n         */\r\n        dragEnter(graph: any, evt: any): void;\r\n        /**\r\n         * Deactivates the given graph as a drop target.\r\n         */\r\n        dragExit(graph: any, evt: any): void;\r\n        /**\r\n         * Implements autoscroll, updates the <currentPoint>, highlights any drop\r\n         * targets and updates the preview.\r\n         */\r\n        dragOver(graph: any, evt: any): void;\r\n        /**\r\n         * Returns the drop target for the given graph and coordinates. This\r\n         * implementation uses <mxGraph.getCellAt>.\r\n         */\r\n        drop(graph: any, evt: any, dropTarget: any, x: any, y: any): void;\r\n    }\r\n\r\n    /**\r\n     * Creates a toolbar inside a given DOM node. The toolbar may contain icons,\r\n     * buttons and combo boxes.\r\n     *\r\n     * Event: mxEvent.SELECT\r\n     *\r\n     * Fires when an item was selected in the toolbar. The <code>function</code>\r\n     * property contains the function that was selected in <selectMode>.\r\n     *\r\n     * Constructor: mxToolbar\r\n     *\r\n     * Constructs a toolbar in the specified container.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * container - DOM node that contains the toolbar.\r\n     */\r\n    export declare class mxToolbar extends mxEventSource {\r\n        constructor(container: any);\r\n        /**\r\n         * Adds the given function as an image with the specified title and icon\r\n         * and returns the new image node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * title - Optional string that is used as the tooltip.\r\n         * icon - Optional URL of the image to be used. If no URL is given, then a\r\n         * button is created.\r\n         * funct - Function to execute on a mouse click.\r\n         * pressedIcon - Optional URL of the pressed image. Default is a gray\r\n         * background.\r\n         * style - Optional style classname. Default is mxToolbarItem.\r\n         * factoryMethod - Optional factory method for popup menu, eg.\r\n         * function(menu, evt, cell) { menu.addItem('Hello, World!'); }\r\n         */\r\n        addItem(title: any, icon: any, funct: any, pressedIcon: any, style: any, factoryMethod: any): HTMLImageElement | HTMLButtonElement;\r\n        /**\r\n         * Adds and returns a new SELECT element using the given style. The element\r\n         * is placed inside a DIV with the mxToolbarComboContainer style classname.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * style - Optional style classname. Default is mxToolbarCombo.\r\n         */\r\n        addCombo(style: any): HTMLSelectElement;\r\n        /**\r\n         * Adds and returns a new SELECT element using the given title as the\r\n         * default element. The selection is reset to this element after each\r\n         * change.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * title - String that specifies the title of the default element.\r\n         * style - Optional style classname. Default is mxToolbarCombo.\r\n         */\r\n        addActionCombo(title: any, style: any): HTMLSelectElement;\r\n        /**\r\n         * Adds and returns a new OPTION element inside the given SELECT element.\r\n         * If the given value is a function then it is stored in the option's funct\r\n         * field.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * combo - SELECT element that will contain the new entry.\r\n         * title - String that specifies the title of the option.\r\n         * value - Specifies the value associated with this option.\r\n         */\r\n        addOption(combo: any, title: any, value: any): HTMLOptionElement;\r\n        /**\r\n         * Adds a new selectable item to the toolbar. Only one switch mode item may\r\n         * be selected at a time. The currently selected item is the default item\r\n         * after a reset of the toolbar.\r\n         */\r\n        addSwitchMode(title: any, icon: any, funct: any, pressedIcon: any, style: any): HTMLImageElement;\r\n        /**\r\n         * Adds a new item to the toolbar. The selection is typically reset after\r\n         * the item has been consumed, for example by adding a new vertex to the\r\n         * graph. The reset is not carried out if the item is double clicked.\r\n         *\r\n         * The function argument uses the following signature: funct(evt, cell) where\r\n         * evt is the native mouse event and cell is the cell under the mouse.\r\n         */\r\n        addMode(title: any, icon: any, funct: any, pressedIcon?: any, style?: any, toggle?: any): HTMLImageElement | HTMLButtonElement;\r\n        /**\r\n         * Resets the state of the previously selected mode and displays the given\r\n         * DOM node as selected. This function fires a select event with the given\r\n         * function as a parameter.\r\n         */\r\n        selectMode(domNode: any, funct: any): void;\r\n        /**\r\n         * Selects the default mode and resets the state of the previously selected\r\n         * mode.\r\n         */\r\n        resetMode(forced: any): void;\r\n        /**\r\n         * Adds the specifies image as a separator.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * icon - URL of the separator icon.\r\n         */\r\n        addSeparator(icon: any): any;\r\n        /**\r\n         * Adds a break to the container.\r\n         */\r\n        addBreak(): void;\r\n        /**\r\n         * Adds a horizontal line to the container.\r\n         */\r\n        addLine(): void;\r\n        /**\r\n         * Removes the toolbar and all its associated resources.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Implements a composite undoable edit. Here is an example for a custom change\r\n     * which gets executed via the model:\r\n     *\r\n     * (code)\r\n     * function CustomChange(model, name)\r\n     * {\r\n     *   this.model = model;\r\n     *   this.name = name;\r\n     *   this.previous = name;\r\n     * };\r\n     *\r\n     * CustomChange.prototype.execute = function()\r\n     * {\r\n     *   var tmp = this.model.name;\r\n     *   this.model.name = this.previous;\r\n     *   this.previous = tmp;\r\n     * };\r\n     *\r\n     * var name = prompt('Enter name');\r\n     * graph.model.execute(new CustomChange(graph.model, name));\r\n     * (end)\r\n     *\r\n     * Event: mxEvent.EXECUTED\r\n     *\r\n     * Fires between START_EDIT and END_EDIT after an atomic change was executed.\r\n     * The <code>change</code> property contains the change that was executed.\r\n     *\r\n     * Event: mxEvent.START_EDIT\r\n     *\r\n     * Fires before a set of changes will be executed in <undo> or <redo>.\r\n     * This event contains no properties.\r\n     *\r\n     * Event: mxEvent.END_EDIT\r\n     *\r\n     * Fires after a set of changeswas executed in <undo> or <redo>.\r\n     * This event contains no properties.\r\n     */\r\n    export declare class mxUndoableEdit {\r\n        /**\r\n         * Specifies the source of the edit.\r\n         */\r\n        source: any;\r\n        /**\r\n         * Array that contains the changes that make up this edit. The changes are\r\n         * expected to either have an undo and redo function, or an execute\r\n         * function. Default is an empty array.\r\n         */\r\n        changes: any[];\r\n        /**\r\n         * Specifies if the undoable change is significant.\r\n         * Default is true.\r\n         */\r\n        significant: boolean;\r\n        /**\r\n         * Specifies if this edit has been undone. Default is false.\r\n         */\r\n        undone: boolean;\r\n        /**\r\n         * Specifies if this edit has been redone. Default is false.\r\n         */\r\n        redone: boolean;\r\n        /**\r\n         * Constructs a new undoable edit for the given source.\r\n         * @param source\r\n         * @param significant\r\n         */\r\n        constructor(source: any, significant?: boolean);\r\n        /**\r\n         * Returns true if the this edit contains no changes.\r\n         */\r\n        isEmpty(): boolean;\r\n        /**\r\n         * Returns <significant>.\r\n         */\r\n        isSignificant(): boolean;\r\n        /**\r\n         * Adds the specified change to this edit. The change is an object that is\r\n         * expected to either have an undo and redo, or an execute function.\r\n         */\r\n        add(change: any): void;\r\n        /**\r\n         * Hook to notify any listeners of the changes after an <undo> or <redo>\r\n         * has been carried out. This implementation is empty.\r\n         */\r\n        notify(): void;\r\n        /**\r\n         * Hook to free resources after the edit has been removed from the command\r\n         * history. This implementation is empty.\r\n         */\r\n        die(): void;\r\n        /**\r\n         * Undoes all changes in this edit.\r\n         */\r\n        undo(): void;\r\n        /**\r\n         * Redoes all changes in this edit.\r\n         */\r\n        redo(): void;\r\n    }\r\n\r\n    /**\r\n     * Implements a command history. When changing the graph model, an\r\n     * <mxUndoableChange> object is created at the start of the transaction (when\r\n     * model.beginUpdate is called). All atomic changes are then added to this\r\n     * object until the last model.endUpdate call, at which point the\r\n     * <mxUndoableEdit> is dispatched in an event, and added to the history inside\r\n     * <mxUndoManager>. This is done by an event listener in\r\n     * <mxEditor.installUndoHandler>.\r\n     *\r\n     * Each atomic change of the model is represented by an object (eg.\r\n     * <mxRootChange>, <mxChildChange>, <mxTerminalChange> etc) which contains the\r\n     * complete undo information. The <mxUndoManager> also listens to the\r\n     * <mxGraphView> and stores it's changes to the current root as insignificant\r\n     * undoable changes, so that drilling (step into, step up) is undone.\r\n     *\r\n     * This means when you execute an atomic change on the model, then change the\r\n     * current root on the view and click undo, the change of the root will be\r\n     * undone together with the change of the model so that the display represents\r\n     * the state at which the model was changed. However, these changes are not\r\n     * transmitted for sharing as they do not represent a state change.\r\n     *\r\n     * Example:\r\n     *\r\n     * When adding an undo manager to a graph, make sure to add it\r\n     * to the model and the view as well to maintain a consistent\r\n     * display across multiple undo/redo steps.\r\n     *\r\n     * (code)\r\n     * var undoManager = new mxUndoManager();\r\n     * var listener = function(sender, evt)\r\n     * {\r\n     *   undoManager.undoableEditHappened(evt.getProperty('edit'));\r\n     * };\r\n     * graph.getModel().addListener(mxEvent.UNDO, listener);\r\n     * graph.getView().addListener(mxEvent.UNDO, listener);\r\n     * (end)\r\n     *\r\n     * The code creates a function that informs the undoManager\r\n     * of an undoable edit and binds it to the undo event of\r\n     * <mxGraphModel> and <mxGraphView> using\r\n     * <mxEventSource.addListener>.\r\n     *\r\n     * Event: mxEvent.CLEAR\r\n     *\r\n     * Fires after <clear> was invoked. This event has no properties.\r\n     *\r\n     * Event: mxEvent.UNDO\r\n     *\r\n     * Fires afer a significant edit was undone in <undo>. The <code>edit</code>\r\n     * property contains the <mxUndoableEdit> that was undone.\r\n     *\r\n     * Event: mxEvent.REDO\r\n     *\r\n     * Fires afer a significant edit was redone in <redo>. The <code>edit</code>\r\n     * property contains the <mxUndoableEdit> that was redone.\r\n     *\r\n     * Event: mxEvent.ADD\r\n     *\r\n     * Fires after an undoable edit was added to the history. The <code>edit</code>\r\n     * property contains the <mxUndoableEdit> that was added.\r\n     *\r\n     * Constructor: mxUndoManager\r\n     *\r\n     * Constructs a new undo manager with the given history size. If no history\r\n     * size is given, then a default size of 100 steps is used.\r\n     */\r\n    export declare class mxUndoManager extends mxEventSource {\r\n        constructor(size: any);\r\n        /**\r\n         * Returns true if the history is empty.\r\n         */\r\n        isEmpty(): boolean;\r\n        /**\r\n         * Clears the command history.\r\n         */\r\n        clear(): void;\r\n        /**\r\n         * Returns true if an undo is possible.\r\n         */\r\n        canUndo(): boolean;\r\n        /**\r\n         * Undoes the last change.\r\n         */\r\n        undo(): void;\r\n        /**\r\n         * Returns true if a redo is possible.\r\n         */\r\n        canRedo(): boolean;\r\n        /**\r\n         * Redoes the last change.\r\n         */\r\n        redo(): void;\r\n        /**\r\n         * Method to be called to add new undoable edits to the <history>.\r\n         */\r\n        undoableEditHappened(undoableEdit: any): void;\r\n        /**\r\n         * Removes all pending steps after <indexOfNextAdd> from the history,\r\n         * invoking die on each edit. This is called from <undoableEditHappened>.\r\n         */\r\n        trim(): void;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Converts relative and absolute URLs to absolute URLs with protocol and domain.\r\n     */\r\n    export declare class mxUrlConverter {\r\n        /**\r\n         * Private helper function to update the base URL.\r\n         */\r\n        updateBaseUrl(): void;\r\n        /**\r\n         * Returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Sets <enabled>.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Returns <baseUrl>.\r\n         */\r\n        getBaseUrl(): any;\r\n        /**\r\n         * Sets <baseUrl>.\r\n         */\r\n        setBaseUrl(value: any): void;\r\n        /**\r\n         * Converts the given URL to an absolute URL with protol and domain.\r\n         * Relative URLs are first converted to absolute URLs.\r\n         */\r\n        convert(url: any): any;\r\n    }\r\n\r\n    /**\r\n     * Implements a handler for panning.\r\n     */\r\n    export declare function mxPanningManager(graph: any): void;\r\n\r\n    /**\r\n     * Basic popup menu. To add a vertical scrollbar to a given submenu, the\r\n     * following code can be used.\r\n     *\r\n     * (code)\r\n     * var mxPopupMenuShowMenu = mxPopupMenu.prototype.showMenu;\r\n     * mxPopupMenu.prototype.showMenu = function()\r\n     * {\r\n     *   mxPopupMenuShowMenu.apply(this, arguments);\r\n     *\r\n     *   this.div.style.overflowY = 'auto';\r\n     *   this.div.style.overflowX = 'hidden';\r\n     *   this.div.style.maxHeight = '160px';\r\n     * };\r\n     * (end)\r\n     *\r\n     * Constructor: mxPopupMenu\r\n     *\r\n     * Constructs a popupmenu.\r\n     *\r\n     * Event: mxEvent.SHOW\r\n     *\r\n     * Fires after the menu has been shown in <popup>.\r\n     */\r\n    export declare class mxPopupMenu extends mxEventSource {\r\n        labels: boolean;\r\n        autoExpand: boolean;\r\n        showDisabled: boolean;\r\n        smartSeparators: boolean;\r\n        div: HTMLDivElement;\r\n        zIndex: number;\r\n        submenuImage: string;\r\n\r\n        constructor(factoryMethod?: any);\r\n        /**\r\n         * Initializes the shapes required for this vertex handler.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Returns true if the given event is a popupmenu trigger for the optional\r\n         * given cell.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * me - <mxMouseEvent> that represents the mouse event.\r\n         */\r\n        isPopupTrigger(me: any): any;\r\n        /**\r\n         * Adds the given item to the given parent item. If no parent item is specified\r\n         * then the item is added to the top-level menu. The return value may be used\r\n         * as the parent argument, ie. as a submenu item. The return value is the table\r\n         * row that represents the item.\r\n         *\r\n         * Paramters:\r\n         *\r\n         * title - String that represents the title of the menu item.\r\n         * image - Optional URL for the image icon.\r\n         * funct - Function associated that takes a mouseup or touchend event.\r\n         * parent - Optional item returned by <addItem>.\r\n         * iconCls - Optional string that represents the CSS class for the image icon.\r\n         * IconsCls is ignored if image is given.\r\n         * enabled - Optional boolean indicating if the item is enabled. Default is true.\r\n         * active - Optional boolean indicating if the menu should implement any event handling.\r\n         * Default is true.\r\n         */\r\n        addItem(title: any, image: any, funct: any, parent?: any, iconCls?: any, enabled?: any, active?: any): HTMLTableRowElement;\r\n        /**\r\n         * Adds a checkmark to the given menuitem.\r\n         */\r\n        addCheckmark(item: any, img: any): void;\r\n        /**\r\n         * Creates the nodes required to add submenu items inside the given parent\r\n         * item. This is called in <addItem> if a parent item is used for the first\r\n         * time. This adds various DOM nodes and a <submenuImage> to the parent.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - An item returned by <addItem>.\r\n         */\r\n        createSubmenu(parent: any): void;\r\n        /**\r\n         * Shows the submenu inside the given parent row.\r\n         */\r\n        showSubmenu(parent: any, row: any): void;\r\n        /**\r\n         * Adds a horizontal separator in the given parent item or the top-level menu\r\n         * if no parent is specified.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - Optional item returned by <addItem>.\r\n         * force - Optional boolean to ignore <smartSeparators>. Default is false.\r\n         */\r\n        addSeparator(parent?: mxPopupMenu | HTMLTableRowElement, force?: any): void;\r\n        /**\r\n         * Shows the popup menu for the given event and cell.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * graph.panningHandler.popup = function(x, y, cell, evt)\r\n         * {\r\n         *   mxUtils.alert('Hello, World!');\r\n         * }\r\n         * (end)\r\n         */\r\n        popup(x: any, y: any, cell: any, evt: any): void;\r\n        /**\r\n         * Returns true if the menu is showing.\r\n         */\r\n        isMenuShowing(): boolean;\r\n        /**\r\n         * Shows the menu.\r\n         */\r\n        showMenu(): void;\r\n        /**\r\n         * Removes the menu and all submenus.\r\n         */\r\n        hideMenu(): void;\r\n        /**\r\n         * Removes all submenus inside the given parent.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - An item returned by <addItem>.\r\n         */\r\n        hideSubmenu(parent: any): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Manager for automatically saving diagrams. The <save> hook must be\r\n     * implemented.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var mgr = new mxAutoSaveManager(editor.graph);\r\n     * mgr.save = function()\r\n     * {\r\n     *   mxLog.show();\r\n     *   mxLog.debug('save');\r\n     * };\r\n     * (end)\r\n     *\r\n     * Constructor: mxAutoSaveManager\r\n     *\r\n     * Constructs a new automatic layout for the given graph.\r\n     *\r\n     * Arguments:\r\n     *\r\n     * graph - Reference to the enclosing graph.\r\n     */\r\n    export declare class mxAutoSaveManager extends mxEventSource {\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enabled - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Sets the graph that the layouts operate on.\r\n         */\r\n        setGraph(graph: any): void;\r\n        /**\r\n         * Empty hook that is called if the graph should be saved.\r\n         */\r\n        save(): void;\r\n        /**\r\n         * Invoked when the graph model has changed.\r\n         */\r\n        graphModelChanged(changes: any): void;\r\n        /**\r\n         * Resets all counters.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Removes all handlers from the <graph> and deletes the reference to it.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Implements a basic animation in JavaScript.\r\n     *\r\n     * Constructor: mxAnimation\r\n     *\r\n     * Constructs an animation.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     */\r\n    export declare class mxAnimation extends mxEventSource {\r\n        constructor(delay: any);\r\n        /**\r\n         * Returns true if the animation is running.\r\n         */\r\n        isRunning(): boolean;\r\n        /**\r\n         * Starts the animation by repeatedly invoking updateAnimation.\r\n         */\r\n        startAnimation(): void;\r\n        /**\r\n         * Hook for subclassers to implement the animation. Invoke stopAnimation\r\n         * when finished, startAnimation to resume. This is called whenever the\r\n         * timer fires and fires an mxEvent.EXECUTE event with no properties.\r\n         */\r\n        updateAnimation(): void;\r\n        /**\r\n         * Stops the animation by deleting the timer and fires an <mxEvent.DONE>.\r\n         */\r\n        stopAnimation(): void;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Implements animation for morphing cells. Here is an example of\r\n     * using this class for animating the result of a layout algorithm:\r\n     *\r\n     * (code)\r\n     * graph.getModel().beginUpdate();\r\n     * try\r\n     * {\r\n     *   var circleLayout = new mxCircleLayout(graph);\r\n     *   circleLayout.execute(graph.getDefaultParent());\r\n     * }\r\n     * finally\r\n     * {\r\n     *   var morph = new mxMorphing(graph);\r\n     *   morph.addListener(mxEvent.DONE, function()\r\n     *   {\r\n     *     graph.getModel().endUpdate();\r\n     *   });\r\n     *\r\n     *   morph.startAnimation();\r\n     * }\r\n     * (end)\r\n     *\r\n     * Constructor: mxMorphing\r\n     *\r\n     * Constructs an animation.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     * steps - Optional number of steps in the morphing animation. Default is 6.\r\n     * ease - Optional easing constant for the animation. Default is 1.5.\r\n     * delay - Optional delay between the animation steps. Passed to <mxAnimation>.\r\n     */\r\n    export declare class mxMorphing extends mxAnimation {\r\n        constructor(graph: any, steps: any, ease: any, delay: any);\r\n        /**\r\n         * Animation step.\r\n         */\r\n        updateAnimation(): void;\r\n        /**\r\n         * Shows the changes in the given <mxCellStatePreview>.\r\n         */\r\n        show(move: any): void;\r\n        /**\r\n         * Animates the given cell state using <mxCellStatePreview.moveState>.\r\n         */\r\n        animateCell(cell: any, move: any, recurse: any): void;\r\n        /**\r\n         * Returns true if the animation should not recursively find more\r\n         * deltas for children if the given parent state has been animated.\r\n         */\r\n        stopRecursion(state: any, delta: any): boolean;\r\n        /**\r\n         * Returns the vector between the current rendered state and the future\r\n         * location of the state after the display will be updated.\r\n         */\r\n        getDelta(state: any): mxPoint;\r\n        /**\r\n         * Returns the top, left corner of the given cell. TODO: Improve performance\r\n         * by using caching inside this method as the result per cell never changes\r\n         * during the lifecycle of this object.\r\n         */\r\n        getOriginForCell(cell: any): any;\r\n    }\r\n\r\n    /**\r\n     * Maps from keys to base64 encoded images or file locations. All values must\r\n     * be URLs or use the format data:image/format followed by a comma and the base64\r\n     * encoded image data, eg. \"data:image/gif,XYZ\", where XYZ is the base64 encoded\r\n     * image data.\r\n     *\r\n     * To add a new image bundle to an existing graph, the following code is used:\r\n     *\r\n     * (code)\r\n     * var bundle = new mxImageBundle(alt);\r\n     * bundle.putImage('myImage', 'data:image/gif,R0lGODlhEAAQAMIGAAAAAICAAICAgP' +\r\n     *   '//AOzp2O3r2////////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAh+QQBCgAHACwAAAAA' +\r\n     *   'EAAQAAADTXi63AowynnAMDfjPUDlnAAJhmeBFxAEloliKltWmiYCQvfVr6lBPB1ggxN1hi' +\r\n     *   'laSSASFQpIV5HJBDyHpqK2ejVRm2AAgZCdmCGO9CIBADs=', fallback);\r\n     * bundle.putImage('mySvgImage', 'data:image/svg+xml,' + encodeURIComponent(\r\n     *   '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\">' +\r\n     *   '<linearGradient id=\"gradient\"><stop offset=\"10%\" stop-color=\"#F00\"/>' +\r\n     *   '<stop offset=\"90%\" stop-color=\"#fcc\"/></linearGradient>' +\r\n     *   '<rect fill=\"url(#gradient)\" width=\"100%\" height=\"100%\"/></svg>'), fallback);\r\n     * graph.addImageBundle(bundle);\r\n     * (end);\r\n     *\r\n     * Alt is an optional boolean (default is false) that specifies if the value\r\n     * or the fallback should be returned in <getImage>.\r\n     *\r\n     * The image can then be referenced in any cell style using image=myImage.\r\n     * If you are using mxOutline, you should use the same image bundles in the\r\n     * graph that renders the outline.\r\n     *\r\n     * The keys for images are resolved in <mxGraph.postProcessCellStyle> and\r\n     * turned into a data URI if the returned value has a short data URI format\r\n     * as specified above.\r\n     *\r\n     * A typical value for the fallback is a MTHML link as defined in RFC 2557.\r\n     * Note that this format requires a file to be dynamically created on the\r\n     * server-side, or the page that contains the graph to be modified to contain\r\n     * the resources, this can be done by adding a comment that contains the\r\n     * resource in the HEAD section of the page after the title tag.\r\n     *\r\n     * This type of fallback mechanism should be used in IE6 and IE7. IE8 does\r\n     * support data URIs, but the maximum size is limited to 32 KB, which means\r\n     * all data URIs should be limited to 32 KB.\r\n     */\r\n    export declare class mxImageBundle {\r\n        constructor(alt: any);\r\n        /**\r\n         * Adds the specified entry to the map. The entry is an object with a value and\r\n         * fallback property as specified in the arguments.\r\n         */\r\n        putImage(key: any, value: any, fallback: any): void;\r\n        /**\r\n         * Returns the value for the given key. This returns the value\r\n         * or fallback, depending on <alt>. The fallback is returned if\r\n         * <alt> is true, the value is returned otherwise.\r\n         */\r\n        getImage(key: any): any;\r\n    }\r\n\r\n    /**\r\n     * Creates a new image export declare instance to be used with an export declare canvas. Here\r\n     * is an example that uses this class to create an image via a backend using\r\n     * <mxXmlExportCanvas>.\r\n     *\r\n     * (code)\r\n     * var xmlDoc = mxUtils.createXmlDocument();\r\n     * var root = xmlDoc.createElement('output');\r\n     * xmlDoc.appendChild(root);\r\n     *\r\n     * var xmlCanvas = new mxXmlCanvas2D(root);\r\n     * var imgExport = new mxImageExport();\r\n     * imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);\r\n     *\r\n     * var bounds = graph.getGraphBounds();\r\n     * var w = Math.ceil(bounds.x + bounds.width);\r\n     * var h = Math.ceil(bounds.y + bounds.height);\r\n     *\r\n     * var xml = mxUtils.getXml(root);\r\n     * new mxXmlRequest('declare', 'format=png&w=' + w +\r\n     * \t\t'&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))\r\n     * \t\t.simulate(document, '_blank');\r\n     * (end)\r\n     *\r\n     * Constructor: mxImageExport\r\n     *\r\n     * Constructs a new image declare.\r\n     */\r\n    export declare class mxImageExport {\r\n        /**\r\n         * Draws the given state and all its descendants to the given canvas.\r\n         */\r\n        drawState(state: any, canvas: any): void;\r\n        /**\r\n         * Draws the given state and all its descendants to the given canvas.\r\n         */\r\n        visitStatesRecursive(state: any, canvas: any, visitor: any): void;\r\n        /**\r\n         * Returns the link for the given cell state and canvas. This returns null.\r\n         */\r\n        getLinkForCellState(state: any, canvas: any): any;\r\n        /**\r\n         * Draws the given state to the given canvas.\r\n         */\r\n        drawCellState(state: any, canvas: any): void;\r\n        /**\r\n         * Draws the shape of the given state.\r\n         */\r\n        drawShape(state: any, canvas: any): void;\r\n        /**\r\n         * Draws the text of the given state.\r\n         */\r\n        drawText(state: any, canvas: any): void;\r\n        /**\r\n         * Draws the overlays for the given state. This is called if <includeOverlays>\r\n         * is true.\r\n         */\r\n        drawOverlays(state: any, canvas: any): void;\r\n    }\r\n\r\n    /**\r\n     * Base class for all canvases. A description of the public API is available in <mxXmlCanvas2D>.\r\n     * All color values of <mxConstants.NONE> will be converted to null in the state.\r\n     *\r\n     * Constructor: mxAbstractCanvas2D\r\n     *\r\n     * Constructs a new abstract canvas.\r\n     */\r\n    export declare class mxAbstractCanvas2D {\r\n        constructor();\r\n        /**\r\n         * Create a new <mxUrlConverter> and returns it.\r\n         */\r\n        createUrlConverter(): mxUrlConverter;\r\n        /**\r\n         * Resets the state of this canvas.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Creates the state of the this canvas.\r\n         */\r\n        createState(): {\r\n            dx: number;\r\n            dy: number;\r\n            scale: number;\r\n            alpha: number;\r\n            fillAlpha: number;\r\n            strokeAlpha: number;\r\n            fillColor: any;\r\n            gradientFillAlpha: number;\r\n            gradientColor: any;\r\n            gradientAlpha: number;\r\n            gradientDirection: any;\r\n            strokeColor: any;\r\n            strokeWidth: number;\r\n            dashed: boolean;\r\n            dashPattern: string;\r\n            fixDash: boolean;\r\n            lineCap: string;\r\n            lineJoin: string;\r\n            miterLimit: number;\r\n            fontColor: string;\r\n            fontBackgroundColor: any;\r\n            fontBorderColor: any;\r\n            fontSize: number;\r\n            fontFamily: string;\r\n            fontStyle: number;\r\n            shadow: boolean;\r\n            shadowColor: string;\r\n            shadowAlpha: number;\r\n            shadowDx: number;\r\n            shadowDy: number;\r\n            rotation: number;\r\n            rotationCx: number;\r\n            rotationCy: number;\r\n        };\r\n        /**\r\n         * Rounds all numbers to integers.\r\n         */\r\n        format(value: any): number;\r\n        /**\r\n         * Adds the given operation to the path.\r\n         */\r\n        addOp(): void;\r\n        /**\r\n         * Rotates the given point and returns the result as an <mxPoint>.\r\n         */\r\n        rotatePoint(x: any, y: any, theta: any, cx: any, cy: any): any;\r\n        /**\r\n         * Saves the current state.\r\n         */\r\n        save(): void;\r\n        /**\r\n         * Restores the current state.\r\n         */\r\n        restore(): void;\r\n        /**\r\n         * Sets the current link. Hook for subclassers.\r\n         */\r\n        setLink(link: any): void;\r\n        /**\r\n         * Scales the current state.\r\n         */\r\n        scale(value: any): void;\r\n        /**\r\n         * Translates the current state.\r\n         */\r\n        translate(dx: any, dy: any): void;\r\n        /**\r\n         * Rotates the current state.\r\n         */\r\n        rotate(theta: any, flipH: any, flipV: any, cx: any, cy: any): void;\r\n        /**\r\n         * Sets the current alpha.\r\n         */\r\n        setAlpha(value: any): void;\r\n        /**\r\n         * Sets the current solid fill alpha.\r\n         */\r\n        setFillAlpha(value: any): void;\r\n        /**\r\n         * Sets the current stroke alpha.\r\n         */\r\n        setStrokeAlpha(value: any): void;\r\n        /**\r\n         * Sets the current fill color.\r\n         */\r\n        setFillColor(value: any): void;\r\n        /**\r\n         * Sets the current gradient.\r\n         */\r\n        setGradient(color1: any, color2: any, x: any, y: any, w: any, h: any, direction: any, alpha1: any, alpha2: any): void;\r\n        /**\r\n         * Sets the current stroke color.\r\n         */\r\n        setStrokeColor(value: any): void;\r\n        /**\r\n         * Sets the current stroke width.\r\n         */\r\n        setStrokeWidth(value: any): void;\r\n        /**\r\n         * Enables or disables dashed lines.\r\n         */\r\n        setDashed(value: any, fixDash?: any): void;\r\n        /**\r\n         * Sets the current dash pattern.\r\n         */\r\n        setDashPattern(value: any): void;\r\n        /**\r\n         * Sets the current line cap.\r\n         */\r\n        setLineCap(value: any): void;\r\n        /**\r\n         * Sets the current line join.\r\n         */\r\n        setLineJoin(value: any): void;\r\n        /**\r\n         * Sets the current miter limit.\r\n         */\r\n        setMiterLimit(value: any): void;\r\n        /**\r\n         * Sets the current font color.\r\n         */\r\n        setFontColor(value: any): void;\r\n        /**\r\n         * Sets the current font color.\r\n         */\r\n        setFontBackgroundColor(value: any): void;\r\n        /**\r\n         * Sets the current font color.\r\n         */\r\n        setFontBorderColor(value: any): void;\r\n        /**\r\n         * Sets the current font size.\r\n         */\r\n        setFontSize(value: any): void;\r\n        /**\r\n         * Sets the current font family.\r\n         */\r\n        setFontFamily(value: any): void;\r\n        /**\r\n         * Sets the current font style.\r\n         */\r\n        setFontStyle(value: any): void;\r\n        /**\r\n         * Enables or disables and configures the current shadow.\r\n         */\r\n        setShadow(enabled: any): void;\r\n        /**\r\n         * Enables or disables and configures the current shadow.\r\n         */\r\n        setShadowColor(value: any): void;\r\n        /**\r\n         * Enables or disables and configures the current shadow.\r\n         */\r\n        setShadowAlpha(value: any): void;\r\n        /**\r\n         * Enables or disables and configures the current shadow.\r\n         */\r\n        setShadowOffset(dx: any, dy: any): void;\r\n        /**\r\n         * Starts a new path.\r\n         */\r\n        begin(): void;\r\n        /**\r\n         *  Moves the current path the given coordinates.\r\n         */\r\n        moveTo(x: any, y: any): void;\r\n        /**\r\n         * Draws a line to the given coordinates. Uses moveTo with the op argument.\r\n         */\r\n        lineTo(x: any, y: any): void;\r\n        /**\r\n         * Adds a quadratic curve to the current path.\r\n         */\r\n        quadTo(x1: any, y1: any, x2: any, y2: any): void;\r\n        /**\r\n         * Adds a bezier curve to the current path.\r\n         */\r\n        curveTo(x1: any, y1: any, x2: any, y2: any, x3: any, y3: any): void;\r\n        /**\r\n         * Adds the given arc to the current path. This is a synthetic operation that\r\n         * is broken down into curves.\r\n         */\r\n        arcTo(rx: any, ry: any, angle: any, largeArcFlag: any, sweepFlag: any, x: any, y: any): void;\r\n        /**\r\n         * Closes the current path.\r\n         */\r\n        close(x1: any, y1: any, x2: any, y2: any, x3: any, y3: any): void;\r\n        /**\r\n         * Empty implementation for backwards compatibility. This will be removed.\r\n         */\r\n        end(): void;\r\n    }\r\n\r\n    /**\r\n     * Base class for all canvases. The following methods make up the public\r\n     * interface of the canvas 2D for all painting in mxGraph:\r\n     *\r\n     * - <save>, <restore>\r\n     * - <scale>, <translate>, <rotate>\r\n     * - <setAlpha>, <setFillAlpha>, <setStrokeAlpha>, <setFillColor>, <setGradient>,\r\n     *   <setStrokeColor>, <setStrokeWidth>, <setDashed>, <setDashPattern>, <setLineCap>,\r\n     *   <setLineJoin>, <setMiterLimit>\r\n     * - <setFontColor>, <setFontBackgroundColor>, <setFontBorderColor>, <setFontSize>,\r\n     *   <setFontFamily>, <setFontStyle>\r\n     * - <setShadow>, <setShadowColor>, <setShadowAlpha>, <setShadowOffset>\r\n     * - <rect>, <roundrect>, <ellipse>, <image>, <text>\r\n     * - <begin>, <moveTo>, <lineTo>, <quadTo>, <curveTo>\r\n     * - <stroke>, <fill>, <fillAndStroke>\r\n     *\r\n     * <mxAbstractCanvas2D.arcTo> is an additional method for drawing paths. This is\r\n     * a synthetic method, meaning that it is turned into a sequence of curves by\r\n     * default. Subclassers may add native support for arcs.\r\n     *\r\n     * Constructor: mxXmlCanvas2D\r\n     *\r\n     * Constructs a new abstract canvas.\r\n     */\r\n    export declare class mxXmlCanvas2D extends mxAbstractCanvas2D {\r\n        constructor(root: any);\r\n        /**\r\n         * Writes the rendering defaults to <root>:\r\n         */\r\n        writeDefaults(): void;\r\n        /**\r\n         * Returns a formatted number with 2 decimal places.\r\n         */\r\n        format(value: any): number;\r\n        /**\r\n         * Creates the given element using the owner document of <root>.\r\n         */\r\n        createElement(name: any): any;\r\n        /**\r\n         * Saves the drawing state.\r\n         */\r\n        save(): void;\r\n        /**\r\n         * Restores the drawing state.\r\n         */\r\n        restore(): void;\r\n        /**\r\n         * Scales the output.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * scale - Number that represents the scale where 1 is equal to 100%.\r\n         */\r\n        scale(value: any): void;\r\n        /**\r\n         * Translates the output.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dx - Number that specifies the horizontal translation.\r\n         * dy - Number that specifies the vertical translation.\r\n         */\r\n        translate(dx: any, dy: any): void;\r\n        /**\r\n         * Rotates and/or flips the output around a given center. (Note: Due to\r\n         * limitations in VML, the rotation cannot be concatenated.)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * theta - Number that represents the angle of the rotation (in degrees).\r\n         * flipH - Boolean indicating if the output should be flipped horizontally.\r\n         * flipV - Boolean indicating if the output should be flipped vertically.\r\n         * cx - Number that represents the x-coordinate of the rotation center.\r\n         * cy - Number that represents the y-coordinate of the rotation center.\r\n         */\r\n        rotate(theta: any, flipH: any, flipV: any, cx: any, cy: any): void;\r\n        /**\r\n         * Sets the current alpha.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Number that represents the new alpha. Possible values are between\r\n         * 1 (opaque) and 0 (transparent).\r\n         */\r\n        setAlpha(value: any): void;\r\n        /**\r\n         * Sets the current fill alpha.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Number that represents the new fill alpha. Possible values are between\r\n         * 1 (opaque) and 0 (transparent).\r\n         */\r\n        setFillAlpha(value: any): void;\r\n        /**\r\n         * Sets the current stroke alpha.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Number that represents the new stroke alpha. Possible values are between\r\n         * 1 (opaque) and 0 (transparent).\r\n         */\r\n        setStrokeAlpha(value: any): void;\r\n        /**\r\n         * Sets the current fill color.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Hexadecimal representation of the color or 'none'.\r\n         */\r\n        setFillColor(value: any): void;\r\n        /**\r\n         * Sets the gradient. Note that the coordinates may be ignored by some implementations.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * color1 - Hexadecimal representation of the start color.\r\n         * color2 - Hexadecimal representation of the end color.\r\n         * x - X-coordinate of the gradient region.\r\n         * y - y-coordinate of the gradient region.\r\n         * w - Width of the gradient region.\r\n         * h - Height of the gradient region.\r\n         * direction - One of <mxConstants.DIRECTION_NORTH>, <mxConstants.DIRECTION_EAST>,\r\n         * <mxConstants.DIRECTION_SOUTH> or <mxConstants.DIRECTION_WEST>.\r\n         * alpha1 - Optional alpha of the start color. Default is 1. Possible values\r\n         * are between 1 (opaque) and 0 (transparent).\r\n         * alpha2 - Optional alpha of the end color. Default is 1. Possible values\r\n         * are between 1 (opaque) and 0 (transparent).\r\n         */\r\n        setGradient(color1: any, color2: any, x: any, y: any, w: any, h: any, direction: any, alpha1: any, alpha2: any): void;\r\n        /**\r\n         * Sets the current stroke color.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Hexadecimal representation of the color or 'none'.\r\n         */\r\n        setStrokeColor(value: any): void;\r\n        /**\r\n         * Sets the current stroke width.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Numeric representation of the stroke width.\r\n         */\r\n        setStrokeWidth(value: any): void;\r\n        /**\r\n         * Enables or disables dashed lines.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Boolean that specifies if dashed lines should be enabled.\r\n         * value - Boolean that specifies if the stroke width should be ignored\r\n         * for the dash pattern. Default is false.\r\n         */\r\n        setDashed(value: any, fixDash: any): void;\r\n        /**\r\n         * Sets the current dash pattern. Default is '3 3'.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - String that represents the dash pattern, which is a sequence of\r\n         * numbers defining the length of the dashes and the length of the spaces\r\n         * between the dashes. The lengths are relative to the line width - a length\r\n         * of 1 is equals to the line width.\r\n         */\r\n        setDashPattern(value: any): void;\r\n        /**\r\n         * Sets the line cap. Default is 'flat' which corresponds to 'butt' in SVG.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - String that represents the line cap. Possible values are flat, round\r\n         * and square.\r\n         */\r\n        setLineCap(value: any): void;\r\n        /**\r\n         * Sets the line join. Default is 'miter'.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - String that represents the line join. Possible values are miter,\r\n         * round and bevel.\r\n         */\r\n        setLineJoin(value: any): void;\r\n        /**\r\n         * Sets the miter limit. Default is 10.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Number that represents the miter limit.\r\n         */\r\n        setMiterLimit(value: any): void;\r\n        /**\r\n         * Sets the current font color. Default is '#000000'.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Hexadecimal representation of the color or 'none'.\r\n         */\r\n        setFontColor(value: any): void;\r\n        /**\r\n         * Sets the current font background color.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Hexadecimal representation of the color or 'none'.\r\n         */\r\n        setFontBackgroundColor(value: any): void;\r\n        /**\r\n         * Sets the current font border color.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Hexadecimal representation of the color or 'none'.\r\n         */\r\n        setFontBorderColor(value: any): void;\r\n        /**\r\n         * Sets the current font size. Default is <mxConstants.DEFAULT_FONTSIZE>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Numeric representation of the font size.\r\n         */\r\n        setFontSize(value: any): void;\r\n        /**\r\n         * Sets the current font family. Default is <mxConstants.DEFAULT_FONTFAMILY>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - String representation of the font family. This handles the same\r\n         * values as the CSS font-family property.\r\n         */\r\n        setFontFamily(value: any): void;\r\n        /**\r\n         * Sets the current font style.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Numeric representation of the font family. This is the sum of the\r\n         * font styles from <mxConstants>.\r\n         */\r\n        setFontStyle(value: any): void;\r\n        /**\r\n         * Enables or disables shadows.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Boolean that specifies if shadows should be enabled.\r\n         */\r\n        setShadow(value: any): void;\r\n        /**\r\n         * Sets the current shadow color. Default is <mxConstants.SHADOWCOLOR>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Hexadecimal representation of the color or 'none'.\r\n         */\r\n        setShadowColor(value: any): void;\r\n        /**\r\n         * Sets the current shadows alpha. Default is <mxConstants.SHADOW_OPACITY>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Number that represents the new alpha. Possible values are between\r\n         * 1 (opaque) and 0 (transparent).\r\n         */\r\n        setShadowAlpha(value: any): void;\r\n        /**\r\n         * Sets the current shadow offset.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dx - Number that represents the horizontal offset of the shadow.\r\n         * dy - Number that represents the vertical offset of the shadow.\r\n         */\r\n        setShadowOffset(dx: any, dy: any): void;\r\n        /**\r\n         * Puts a rectangle into the drawing buffer.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x - Number that represents the x-coordinate of the rectangle.\r\n         * y - Number that represents the y-coordinate of the rectangle.\r\n         * w - Number that represents the width of the rectangle.\r\n         * h - Number that represents the height of the rectangle.\r\n         */\r\n        rect(x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Puts a rounded rectangle into the drawing buffer.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x - Number that represents the x-coordinate of the rectangle.\r\n         * y - Number that represents the y-coordinate of the rectangle.\r\n         * w - Number that represents the width of the rectangle.\r\n         * h - Number that represents the height of the rectangle.\r\n         * dx - Number that represents the horizontal rounding.\r\n         * dy - Number that represents the vertical rounding.\r\n         */\r\n        roundrect(x: any, y: any, w: any, h: any, dx: any, dy: any): void;\r\n        /**\r\n         * Puts an ellipse into the drawing buffer.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x - Number that represents the x-coordinate of the ellipse.\r\n         * y - Number that represents the y-coordinate of the ellipse.\r\n         * w - Number that represents the width of the ellipse.\r\n         * h - Number that represents the height of the ellipse.\r\n         */\r\n        ellipse(x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Paints an image.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x - Number that represents the x-coordinate of the image.\r\n         * y - Number that represents the y-coordinate of the image.\r\n         * w - Number that represents the width of the image.\r\n         * h - Number that represents the height of the image.\r\n         * src - String that specifies the URL of the image.\r\n         * aspect - Boolean indicating if the aspect of the image should be preserved.\r\n         * flipH - Boolean indicating if the image should be flipped horizontally.\r\n         * flipV - Boolean indicating if the image should be flipped vertically.\r\n         */\r\n        image(x: any, y: any, w: any, h: any, src: any, aspect: any, flipH: any, flipV: any): void;\r\n        /**\r\n         * Starts a new path and puts it into the drawing buffer.\r\n         */\r\n        begin(): void;\r\n        /**\r\n         * Moves the current path the given point.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x - Number that represents the x-coordinate of the point.\r\n         * y - Number that represents the y-coordinate of the point.\r\n         */\r\n        moveTo(x: any, y: any): void;\r\n        /**\r\n         * Draws a line to the given coordinates.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x - Number that represents the x-coordinate of the endpoint.\r\n         * y - Number that represents the y-coordinate of the endpoint.\r\n         */\r\n        lineTo(x: any, y: any): void;\r\n        /**\r\n         * Adds a quadratic curve to the current path.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x1 - Number that represents the x-coordinate of the control point.\r\n         * y1 - Number that represents the y-coordinate of the control point.\r\n         * x2 - Number that represents the x-coordinate of the endpoint.\r\n         * y2 - Number that represents the y-coordinate of the endpoint.\r\n         */\r\n        quadTo(x1: any, y1: any, x2: any, y2: any): void;\r\n        /**\r\n         * Adds a bezier curve to the current path.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x1 - Number that represents the x-coordinate of the first control point.\r\n         * y1 - Number that represents the y-coordinate of the first control point.\r\n         * x2 - Number that represents the x-coordinate of the second control point.\r\n         * y2 - Number that represents the y-coordinate of the second control point.\r\n         * x3 - Number that represents the x-coordinate of the endpoint.\r\n         * y3 - Number that represents the y-coordinate of the endpoint.\r\n         */\r\n        curveTo(x1: any, y1: any, x2: any, y2: any, x3: any, y3: any): void;\r\n        /**\r\n         * Closes the current path.\r\n         */\r\n        close(): void;\r\n        /**\r\n         * Paints the given text. Possible values for format are empty string for\r\n         * plain text and html for HTML markup. Background and border color as well\r\n         * as clipping is not available in plain text labels for VML. HTML labels\r\n         * are not available as part of shapes with no foreignObject support in SVG\r\n         * (eg. IE9, IE10).\r\n         *\r\n         * Parameters:\r\n         *\r\n         * x - Number that represents the x-coordinate of the text.\r\n         * y - Number that represents the y-coordinate of the text.\r\n         * w - Number that represents the available width for the text or 0 for automatic width.\r\n         * h - Number that represents the available height for the text or 0 for automatic height.\r\n         * str - String that specifies the text to be painted.\r\n         * align - String that represents the horizontal alignment.\r\n         * valign - String that represents the vertical alignment.\r\n         * wrap - Boolean that specifies if word-wrapping is enabled. Requires w > 0.\r\n         * format - Empty string for plain text or 'html' for HTML markup.\r\n         * overflow - Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.\r\n         * clip - Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.\r\n         * rotation - Number that specifies the angle of the rotation around the anchor point of the text.\r\n         * dir - Optional string that specifies the text direction. Possible values are rtl and lrt.\r\n         */\r\n        text(x: any, y: any, w: any, h: any, str: any, align: any, valign: any, wrap: any, format: any, overflow: any, clip: any, rotation: any, dir: any): void;\r\n        /**\r\n         * Paints the outline of the current drawing buffer.\r\n         */\r\n        stroke(): void;\r\n        /**\r\n         * Fills the current drawing buffer.\r\n         */\r\n        fill(): void;\r\n        /**\r\n         * Fills the current drawing buffer and its outline.\r\n         */\r\n        fillAndStroke(): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxAbstractCanvas2D> to implement a canvas for SVG. This canvas writes all\r\n     * calls as SVG output to the given SVG root node.\r\n     *\r\n     * (code)\r\n     * var svgDoc = mxUtils.createXmlDocument();\r\n     * var root = (svgDoc.createElementNS != null) ?\r\n     * \t\tsvgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');\r\n     *\r\n     * if (svgDoc.createElementNS == null)\r\n     * {\r\n     *   root.setAttribute('xmlns', mxConstants.NS_SVG);\r\n     *   root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);\r\n     * }\r\n     * else\r\n     * {\r\n     *   root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);\r\n     * }\r\n     *\r\n     * var bounds = graph.getGraphBounds();\r\n     * root.setAttribute('width', (bounds.x + bounds.width + 4) + 'px');\r\n     * root.setAttribute('height', (bounds.y + bounds.height + 4) + 'px');\r\n     * root.setAttribute('version', '1.1');\r\n     *\r\n     * svgDoc.appendChild(root);\r\n     *\r\n     * var svgCanvas = new mxSvgCanvas2D(root);\r\n     * (end)\r\n     *\r\n     * A description of the public API is available in <mxXmlCanvas2D>.\r\n     *\r\n     * To disable anti-aliasing in the output, use the following code.\r\n     *\r\n     * (code)\r\n     * graph.view.canvas.ownerSVGElement.setAttribute('shape-rendering', 'crispEdges');\r\n     * (end)\r\n     *\r\n     * Or set the respective attribute in the SVG element directly.\r\n     */\r\n    export declare class mxSvgCanvas2D extends mxAbstractCanvas2D {\r\n        /**\r\n         * Holds the current DOM node.\r\n         */\r\n        node: Element;\r\n        /**\r\n         * Specifies if plain text output should match the vertical HTML alignment.\r\n         * Defaul is true.\r\n         */\r\n        matchHtmlAlignment: boolean;\r\n        /**\r\n         * Specifies if text output should be enabled. Default is true.\r\n         */\r\n        textEnabled: boolean;\r\n        /**\r\n         * Specifies if use of foreignObject for HTML markup is allowed. Default is true.\r\n         */\r\n        foEnabled: boolean;\r\n        /**\r\n         * Specifies the fallback text for unsupported foreignObjects in exported\r\n         * documents. Default is '[Object]'. If this is set to null then no fallback\r\n         * text is added to the exported document.\r\n         */\r\n        foAltText: string;\r\n        /**\r\n         * Offset to be used for foreignObjects.\r\n         */\r\n        foOffset: number;\r\n        /**\r\n         * Offset to be used for text elements.\r\n         */\r\n        textOffset: number;\r\n        /**\r\n         * Offset to be used for image elements.\r\n         */\r\n        imageOffset: number;\r\n        /**\r\n         * Adds transparent paths for strokes.\r\n         */\r\n        strokeTolerance: number;\r\n        /**\r\n         * Local counter for references in SVG declare.\r\n         */\r\n        refCount: number;\r\n        /**\r\n         * Specifies if a transparent rectangle should be added on top of images to absorb\r\n         * all pointer events. Default is false. This is only needed in Firefox to disable\r\n         * control-clicks on images.\r\n         */\r\n        blockImagePointerEvents: boolean;\r\n        /**\r\n         * Correction factor for <mxConstants.LINE_HEIGHT> in HTML output. Default is 1.\r\n         */\r\n        lineHeightCorrection: number;\r\n        /**\r\n         * Default value for active pointer events. Default is all.\r\n         */\r\n        pointerEventsValue: string;\r\n        /**\r\n         * Padding to be added for text that is not wrapped to account for differences\r\n         * in font metrics on different platforms in pixels. Default is 10.\r\n         */\r\n        fontMetricsPadding: number;\r\n        /**\r\n         * Specifies if offsetWidth and offsetHeight should be cached. Default is true.\r\n         * This is used to speed up repaint of text in <updateText>.\r\n         */\r\n        cacheOffsetSize: boolean;\r\n        /**\r\n         * Implicit variable declarations\r\n         */\r\n        root: SVGElement;\r\n        gradients: any[];\r\n        defs: SVGDefsElement;\r\n        styleEnabled: boolean;\r\n        state: any;\r\n        pointerEvents: any;\r\n        originalRoot: any;\r\n        path: any;\r\n        closeOp: any;\r\n        useDomParser: boolean;\r\n        rotateHtml: boolean;\r\n        /**\r\n         * Constructs a new SVG canvas.\r\n         *\r\n         * @param root - SVG container for the output.\r\n         * @param styleEnabled - Optional boolean that specifies if a style section should be\r\n         * added. The style section sets the default font-size, font-family and\r\n         * stroke-miterlimit globally. Default is false.\r\n         */\r\n        constructor(root: any, styleEnabled: any);\r\n        /**\r\n         * Rounds all numbers to 2 decimal points.\r\n         */\r\n        format(value: any): number;\r\n        /**\r\n         * Returns the URL of the page without the hash part. This needs to use href to\r\n         * include any search part with no params (ie question mark alone). This is a\r\n         * workaround for the fact that window.location.search is empty if there is\r\n         * no search string behind the question mark.\r\n         */\r\n        getBaseUrl(): string;\r\n        /**\r\n         * Returns any offsets for rendering pixels.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Creates the optional style section.\r\n         */\r\n        createStyle(x?: any): any;\r\n        /**\r\n         * Returns the alternate content for the given foreignObject.\r\n         */\r\n        createAlternateContent(fo: any, x: any, y: any, w: any, h: any, str: any, align: any, valign: any, wrap: any, format: any, overflow: any, clip: any, rotation: any): any;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        createGradientId(start: any, end: any, alpha1: any, alpha2: any, direction: any): string;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        getSvgGradient(start: any, end: any, alpha1: any, alpha2: any, direction: any): any;\r\n        /**\r\n         * Creates the given SVG gradient.\r\n         */\r\n        createSvgGradient(start: any, end: any, alpha1: any, alpha2: any, direction: any): any;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        addNode(filled: any, stroked: any): void;\r\n        /**\r\n         * Transfers the stroke attributes from <state> to <node>.\r\n         */\r\n        updateFill(): void;\r\n        /**\r\n         * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).\r\n         */\r\n        getCurrentStrokeWidth(): number;\r\n        /**\r\n         * Transfers the stroke attributes from <state> to <node>.\r\n         */\r\n        updateStroke(): void;\r\n        /**\r\n         * Transfers the stroke attributes from <state> to <node>.\r\n         */\r\n        updateStrokeAttributes(): void;\r\n        /**\r\n         * Creates the SVG dash pattern for the given state.\r\n         */\r\n        createDashPattern(scale: any): string;\r\n        /**\r\n         * Creates a hit detection tolerance shape for the given node.\r\n         */\r\n        createTolerance(node: any): any;\r\n        /**\r\n         * Creates a shadow for the given node.\r\n         */\r\n        createShadow(node: any): any;\r\n        /**\r\n         * Experimental implementation for hyperlinks.\r\n         */\r\n        setLink(link: any): void;\r\n        /**\r\n         * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\r\n         */\r\n        rotate(theta: any, flipH: any, flipV: any, cx: any, cy: any): void;\r\n        /**\r\n         * Extends superclass to create path.\r\n         */\r\n        begin(): void;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        rect(x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        roundrect(x: any, y: any, w: any, h: any, dx: any, dy: any): void;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        ellipse(x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        image(x: any, y: any, w: any, h: any, src: any, aspect: any, flipH: any, flipV: any): void;\r\n        /**\r\n         * Converts the given HTML string to XHTML.\r\n         */\r\n        convertHtml(val: any): any;\r\n        /**\r\n         * Private helper function to create SVG elements\r\n         */\r\n        createDiv(str: any, align: any, valign: any, style: any, overflow: any): any;\r\n        /**\r\n         * Invalidates the cached offset size for the given node.\r\n         */\r\n        invalidateCachedOffsetSize(node: any): void;\r\n        /**\r\n         * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.\r\n         */\r\n        updateText(x: any, y: any, w: any, h: any, align: any, valign: any, wrap: any, overflow: any, clip: any, rotation: any, node: any): void;\r\n        /**\r\n         * Paints the given text. Possible values for format are empty string for plain\r\n         * text and html for HTML markup. Note that HTML markup is only supported if\r\n         * foreignObject is supported and <foEnabled> is true. (This means IE9 and later\r\n         * does currently not support HTML text as part of shapes.)\r\n         */\r\n        text(x: any, y: any, w: any, h: any, str: any, align: any, valign: any, wrap: any, format: any, overflow: any, clip: any, rotation: any, dir: any): void;\r\n        /**\r\n         * Creates a clip for the given coordinates.\r\n         */\r\n        createClip(x: any, y: any, w: any, h: any): any;\r\n        /**\r\n         * Paints the given text. Possible values for format are empty string for\r\n         * plain text and html for HTML markup.\r\n         */\r\n        plainText(x: any, y: any, w: any, h: any, str: any, align: any, valign: any, wrap: any, overflow: any, clip: any, rotation: any, dir: any): void;\r\n        /**\r\n         * Updates the text properties for the given node. (NOTE: For this to work in\r\n         * IE, the given node must be a text or tspan element.)\r\n         */\r\n        updateFont(node: any): void;\r\n        /**\r\n         * Background color and border\r\n         */\r\n        addTextBackground(node: any, str: any, x: any, y: any, w: any, h: any, align: any, valign: any, overflow: any): void;\r\n        /**\r\n         * Paints the outline of the current path.\r\n         */\r\n        stroke(): void;\r\n        /**\r\n         * Fills the current path.\r\n         */\r\n        fill(): void;\r\n        /**\r\n         * Fills and paints the outline of the current path.\r\n         */\r\n        fillAndStroke(): void;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Implements a canvas to be used for rendering VML. Here is an example of implementing a\r\n     * fallback for SVG images which are not supported in VML-based browsers.\r\n     *\r\n     * (code)\r\n     * var mxVmlCanvas2DImage = mxVmlCanvas2D.prototype.image;\r\n     * mxVmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\r\n     * {\r\n     *   if (src.substring(src.length - 4, src.length) == '.svg')\r\n     *   {\r\n     *     src = 'http://www.jgraph.com/images/mxgraph.gif';\r\n     *   }\r\n     *\r\n     *   mxVmlCanvas2DImage.apply(this, arguments);\r\n     * };\r\n     * (end)\r\n     *\r\n     * To disable anti-aliasing in the output, use the following code.\r\n     *\r\n     * (code)\r\n     * document.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{antialias:false;)}';\r\n     * (end)\r\n     *\r\n     * A description of the public API is available in <mxXmlCanvas2D>. Note that\r\n     * there is a known issue in VML where gradients are painted using the outer\r\n     * bounding box of rotated shapes, not the actual bounds of the shape. See\r\n     * also <text> for plain text label restrictions in shapes for VML.\r\n     */\r\n    export declare class mxVmlCanvas2D extends mxAbstractCanvas2D {\r\n        constructor(root: any);\r\n        /**\r\n         * Creates the given element using the document.\r\n         */\r\n        createElement(name: any): any;\r\n        /**\r\n         * Creates a new element using <createElement> and prefixes the given name with\r\n         * <mxClient.VML_PREFIX>.\r\n         */\r\n        createVmlElement(name: any): any;\r\n        /**\r\n         * Adds the current node to the <root>.\r\n         */\r\n        addNode(filled: any, stroked: any): void;\r\n        /**\r\n         * Creates a transparent fill.\r\n         */\r\n        createTransparentFill(): any;\r\n        /**\r\n         * Creates a fill for the current state.\r\n         */\r\n        createFill(): any;\r\n        /**\r\n         * Creates a fill for the current state.\r\n         */\r\n        createStroke(): any;\r\n        /**\r\n         * Returns a VML dash pattern for the current dashPattern.\r\n         * See http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx\r\n         */\r\n        getVmlDashStyle(): string;\r\n        /**\r\n         * Creates a shadow for the given node.\r\n         */\r\n        createShadow(node: any, filled: any, stroked: any): any;\r\n        /**\r\n         * Creates the fill for the shadow.\r\n         */\r\n        createShadowFill(): any;\r\n        /**\r\n         * Creates the stroke for the shadow.\r\n         */\r\n        createShadowStroke(): any;\r\n        /**\r\n         * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\r\n         */\r\n        rotate(theta: any, flipH: any, flipV: any, cx: any, cy: any): void;\r\n        /**\r\n         * Extends superclass to create path.\r\n         */\r\n        begin(): void;\r\n        /**\r\n         * Replaces quadratic curve with bezier curve in VML.\r\n         */\r\n        quadTo(x1: any, y1: any, x2: any, y2: any): void;\r\n        /**\r\n         * Sets the glass gradient.\r\n         */\r\n        createRect(nodeName: any, x: any, y: any, w: any, h: any): any;\r\n        /**\r\n         * Sets the current path to a rectangle.\r\n         */\r\n        rect(x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Sets the current path to a rounded rectangle.\r\n         */\r\n        roundrect(x: any, y: any, w: any, h: any, dx: any, dy: any): void;\r\n        /**\r\n         * Sets the current path to an ellipse.\r\n         */\r\n        ellipse(x: any, y: any, w: any, h: any): void;\r\n        /**\r\n         * Paints an image.\r\n         */\r\n        image(x: any, y: any, w: any, h: any, src: any, aspect: any, flipH: any, flipV: any): void;\r\n        /**\r\n         * Creates the innermost element that contains the HTML text.\r\n         */\r\n        createDiv(str: any, align: any, valign: any, overflow: any): any;\r\n        /**\r\n         * Paints the given text. Possible values for format are empty string for plain\r\n         * text and html for HTML markup. Clipping, text background and border are not\r\n         * supported for plain text in VML.\r\n         */\r\n        text(x: any, y: any, w: any, h: any, str: any, align: any, valign: any, wrap: any, format: any, overflow: any, clip: any, rotation: any, dir: any): void;\r\n        /**\r\n         * Paints the outline of the current path.\r\n         */\r\n        plainText(x: any, y: any, w: any, h: any, str: any, align: any, valign: any, wrap: any, format: any, overflow: any, clip: any, rotation: any, dir: any): void;\r\n        /**\r\n         * Paints the outline of the current path.\r\n         */\r\n        stroke(): void;\r\n        /**\r\n         * Fills the current path.\r\n         */\r\n        fill(): void;\r\n        /**\r\n         * Fills and paints the outline of the current path.\r\n         */\r\n        fillAndStroke(): void;\r\n    }\r\n\r\n    /**\r\n     * Implements the alignment of selection cells to other cells in the graph.\r\n     *\r\n     * Constructor: mxGuide\r\n     *\r\n     * Constructs a new guide object.\r\n     */\r\n    export declare class mxGuide {\r\n        constructor(graph: any, states: any);\r\n        /**\r\n         * Sets the <mxCellStates> that should be used for alignment.\r\n         */\r\n        setStates(states: any): void;\r\n        /**\r\n         * Returns true if the guide should be enabled for the given native event. This\r\n         * implementation always returns true.\r\n         */\r\n        isEnabledForEvent(evt: any): boolean;\r\n        /**\r\n         * Returns the tolerance for the guides. Default value is gridSize / 2.\r\n         */\r\n        getGuideTolerance(): number;\r\n        /**\r\n         * Returns the mxShape to be used for painting the respective guide. This\r\n         * implementation returns a new, dashed and crisp <mxPolyline> using\r\n         * <mxConstants.GUIDE_COLOR> and <mxConstants.GUIDE_STROKEWIDTH> as the format.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * horizontal - Boolean that specifies which guide should be created.\r\n         */\r\n        createGuideShape(horizontal: any): mxPolyline;\r\n        /**\r\n         * Moves the <bounds> by the given <mxPoint> and returnt the snapped point.\r\n         */\r\n        move(bounds: any, delta: any, gridEnabled: any): any;\r\n        /**\r\n         * Hides all current guides.\r\n         */\r\n        getGuideColor(state: any, horizontal: any): string;\r\n        /**\r\n         * Hides all current guides.\r\n         */\r\n        hide(): void;\r\n        /**\r\n         * Shows or hides the current guides.\r\n         */\r\n        setVisible(visible: any): void;\r\n        /**\r\n         * Destroys all resources that this object uses.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Base class for all layout algorithms in mxGraph. Main public functions are\r\n     * <move> for handling a moved cell within a layouted parent, and <execute> for\r\n     * running the layout on a given parent cell.\r\n     *\r\n     * Known Subclasses:\r\n     *\r\n     * <mxCircleLayout>, <mxCompactTreeLayout>, <mxCompositeLayout>,\r\n     * <mxFastOrganicLayout>, <mxParallelEdgeLayout>, <mxPartitionLayout>,\r\n     * <mxStackLayout>\r\n     *\r\n     * Constructor: mxGraphLayout\r\n     *\r\n     * Constructs a new layout using the given layouts.\r\n     *\r\n     * Arguments:\r\n     *\r\n     * graph - Enclosing\r\n     */\r\n    export declare class mxGraphLayout {\r\n        /**\r\n         * Variable: useBoundingBox\r\n         *\r\n         * Boolean indicating if the bounding box of the label should be used if\r\n         * its available. Default is true.\r\n         */\r\n        useBoundingBox: boolean;\r\n        constructor(graph: any);\r\n        /**\r\n         * Notified when a cell is being moved in a parent that has automatic\r\n         * layout to update the cell state (eg. index) so that the outcome of the\r\n         * layout will position the vertex as close to the point (x, y) as\r\n         * possible.\r\n         *\r\n         * Empty implementation.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> which has been moved.\r\n         * x - X-coordinate of the new cell location.\r\n         * y - Y-coordinate of the new cell location.\r\n         */\r\n        moveCell(cell: any, x: any, y: any): void;\r\n        /**\r\n         * Executes the layout algorithm for the children of the given parent.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - <mxCell> whose children should be layed out.\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Returns the graph that this layout operates on.\r\n         */\r\n        getGraph(): any;\r\n        /**\r\n         * Returns the constraint for the given key and cell. The optional edge and\r\n         * source arguments are used to return inbound and outgoing routing-\r\n         * constraints for the given edge and vertex. This implementation always\r\n         * returns the value for the given key in the style of the given cell.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * key - Key of the constraint to be returned.\r\n         * cell - <mxCell> whose constraint should be returned.\r\n         * edge - Optional <mxCell> that represents the connection whose constraint\r\n         * should be returned. Default is null.\r\n         * source - Optional boolean that specifies if the connection is incoming\r\n         * or outgoing. Default is null.\r\n         */\r\n        getConstraint(key: any, cell: any, edge: any, source: any): any;\r\n        /**\r\n         * Traverses the (directed) graph invoking the given function for each\r\n         * visited vertex and edge. The function is invoked with the current vertex\r\n         * and the incoming edge as a parameter. This implementation makes sure\r\n         * each vertex is only visited once. The function may return false if the\r\n         * traversal should stop at the given vertex.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * mxLog.show();\r\n         * var cell = graph.getSelectionCell();\r\n         * graph.traverse(cell, false, function(vertex, edge)\r\n         * {\r\n         *   mxLog.debug(graph.getLabel(vertex));\r\n         * });\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> that represents the vertex where the traversal starts.\r\n         * directed - Optional boolean indicating if edges should only be traversed\r\n         * from source to target. Default is true.\r\n         * func - Visitor function that takes the current vertex and the incoming\r\n         * edge as arguments. The traversal stops if the function returns false.\r\n         * edge - Optional <mxCell> that represents the incoming edge. This is\r\n         * null for the first step of the traversal.\r\n         * visited - Optional <mxDictionary> of cell paths for the visited cells.\r\n         */\r\n        static traverse(vertex: any, directed: any, func: any, edge: any, visited: any): void;\r\n        /**\r\n         * Returns a boolean indicating if the given <mxCell> is movable or\r\n         * bendable by the algorithm. This implementation returns true if the given\r\n         * cell is movable in the graph.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> whose movable state should be returned.\r\n         */\r\n        isVertexMovable(cell: any): any;\r\n        /**\r\n         * Returns a boolean indicating if the given <mxCell> should be ignored by\r\n         * the algorithm. This implementation returns false for all vertices.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> whose ignored state should be returned.\r\n         */\r\n        isVertexIgnored(vertex: any): boolean;\r\n        /**\r\n         * Returns a boolean indicating if the given <mxCell> should be ignored by\r\n         * the algorithm. This implementation returns false for all vertices.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> whose ignored state should be returned.\r\n         */\r\n        isEdgeIgnored(edge: any): boolean;\r\n        /**\r\n         * Disables or enables the edge style of the given edge.\r\n         */\r\n        setEdgeStyleEnabled(edge: any, value: any): void;\r\n        /**\r\n         * Disables or enables orthogonal end segments of the given edge.\r\n         */\r\n        setOrthogonalEdge(edge: any, value: any): void;\r\n        /**\r\n         * Determines the offset of the given parent to the parent\r\n         * of the layout\r\n         */\r\n        getParentOffset(parent: any): mxPoint;\r\n        /**\r\n         * Replaces the array of mxPoints in the geometry of the given edge\r\n         * with the given array of mxPoints.\r\n         */\r\n        setEdgePoints(edge: any, points: any): void;\r\n        /**\r\n         * Sets the new position of the given cell taking into account the size of\r\n         * the bounding box if <useBoundingBox> is true. The change is only carried\r\n         * out if the new location is not equal to the existing location, otherwise\r\n         * the geometry is not replaced with an updated instance. The new or old\r\n         * bounds are returned (including overlapping labels).\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> whose geometry is to be set.\r\n         * x - Integer that defines the x-coordinate of the new location.\r\n         * y - Integer that defines the y-coordinate of the new location.\r\n         */\r\n        setVertexLocation(cell: any, x: any, y: any): any;\r\n        /**\r\n         * Returns an <mxRectangle> that defines the bounds of the given cell or\r\n         * the bounding box if <useBoundingBox> is true.\r\n         */\r\n        getVertexBounds(cell: any): mxRectangle;\r\n        /**\r\n         * Shortcut to <mxGraph.updateGroupBounds> with moveGroup set to true.\r\n         */\r\n        arrangeGroups(cells: any, border: any, topBorder: any, rightBorder: any, bottomBorder: any, leftBorder: any): any;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxGraphLayout> to create a horizontal or vertical stack of the\r\n     * child vertices. The children do not need to be connected for this layout\r\n     * to work.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layout = new mxStackLayout(graph, true);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * Constructor: mxStackLayout\r\n     *\r\n     * Constructs a new stack layout layout for the specified graph,\r\n     * spacing, orientation and offset.\r\n     */\r\n    export declare class mxStackLayout extends mxGraphLayout {\r\n        fill: boolean;\r\n        marginBottom: number;\r\n        marginTop: number;\r\n        marginRight: number;\r\n        marginLeft: number;\r\n        border: any;\r\n        spacing: any;\r\n        resizeLast: boolean;\r\n        resizeParent: boolean;\r\n        horizontal: boolean;\r\n        resizeParentMax: boolean;\r\n        constructor(graph: any, horizontal: any, spacing?: any, x0?: any, y0?: any, border?: any);\r\n        /**\r\n         * Returns <horizontal>.\r\n         */\r\n        isHorizontal(): any;\r\n        /**\r\n         * Implements <mxGraphLayout.moveCell>.\r\n         */\r\n        moveCell(cell: any, x: any, y: any): void;\r\n        /**\r\n         * Returns the size for the parent container or the size of the graph\r\n         * container if the parent is a layer or the root of the model.\r\n         */\r\n        getParentSize(parent: any): any;\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         *\r\n         * Only children where <isVertexIgnored> returns false are taken into\r\n         * account.\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         *\r\n         * Only children where <isVertexIgnored> returns false are taken into\r\n         * account.\r\n         */\r\n        setChildGeometry(child: any, geo: any): void;\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         *\r\n         * Only children where <isVertexIgnored> returns false are taken into\r\n         * account.\r\n         */\r\n        updateParentGeometry(parent: any, pgeo: any, last: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxGraphLayout> for partitioning the parent cell vertically or\r\n     * horizontally by filling the complete area with the child cells. A horizontal\r\n     * layout partitions the height of the given parent whereas a a non-horizontal\r\n     * layout partitions the width. If the parent is a layer (that is, a child of\r\n     * the root node), then the current graph size is partitioned. The children do\r\n     * not need to be connected for this layout to work.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layout = new mxPartitionLayout(graph, true, 10, 20);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * Constructor: mxPartitionLayout\r\n     *\r\n     * Constructs a new stack layout layout for the specified graph,\r\n     * spacing, orientation and offset.\r\n     */\r\n    export declare class mxPartitionLayout extends mxGraphLayout {\r\n        constructor(graph: any, horizontal: any, spacing: any, border: any);\r\n        /**\r\n         * Returns <horizontal>.\r\n         */\r\n        isHorizontal(): any;\r\n        /**\r\n         * Implements <mxGraphLayout.moveCell>.\r\n         */\r\n        moveCell(cell: any, x: any, y: any): void;\r\n        /**\r\n         * Implements <mxGraphLayout.execute>. All children where <isVertexIgnored>\r\n         * returns false and <isVertexMovable> returns true are modified.\r\n         */\r\n        execute(parent: any): void;\r\n    }\r\n\r\n    /**\r\n     * Class: mxCompactTreeLayout\r\n     * \r\n     * Extends <mxGraphLayout> to implement a compact tree (Moen) algorithm. This\r\n     * layout is suitable for graphs that have no cycles (trees). Vertices that are\r\n     * not connected to the tree will be ignored by this layout.\r\n     * \r\n     * Example:\r\n     * \r\n     * (code)\r\n     * var layout = new mxCompactTreeLayout(graph);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     * \r\n     * Constructor: mxCompactTreeLayout\r\n     * \r\n     * Constructs a new compact tree layout for the specified graph\r\n     * and orientation.\r\n     */\r\n    export declare class mxCompactTreeLayout extends mxGraphLayout {\r\n        resetEdges: boolean;\r\n        edgeRouting: boolean;\r\n        /**\r\n         * Variable: maintainParentLocation\r\n         * \r\n         * Specifies if the parent location should be maintained, so that the\r\n         * top, left corner stays the same before and after execution of\r\n         * the layout. Default is false for backwards compatibility.\r\n         */\r\n        maintainParentLocation: boolean;\r\n        levelDistance: any;\r\n        /**\r\n         * Variable: groupPadding\r\n         * \r\n         * Padding added to resized parents. Default is 10.\r\n         */\r\n        groupPadding: any;\r\n        /**\r\n         * Variable: resizeParent\r\n         * \r\n         * If the parents should be resized to match the width/height of the\r\n         * children. Default is true.\r\n         */\r\n        resizeParent: boolean;\r\n        /**\r\n         * Variable: horizontal\r\n         *\r\n         * Specifies the orientation of the layout. Default is true.\r\n         */\r\n        horizontal: boolean;\r\n        root: any;\r\n        /**\r\n         * Variable: invert\r\n         *\r\n         * Specifies if edge directions should be inverted. Default is false.\r\n         */\r\n        invert: boolean;\r\n        constructor(graph: any, horizontal?: any, invert?: any);\r\n        /**\r\n         * Returns a boolean indicating if the given <mxCell> should be ignored as a\r\n         * vertex. This returns true if the cell has no connections.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> whose ignored state should be returned.\r\n         */\r\n        isVertexIgnored(vertex: any): any;\r\n        /**\r\n         * Returns <horizontal>.\r\n         */\r\n        isHorizontal(): any;\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         *\r\n         * If the parent has any connected edges, then it is used as the root of\r\n         * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\r\n         * root node within the set of children of the given parent.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - <mxCell> whose children should be laid out.\r\n         * root - Optional <mxCell> that will be used as the root of the tree.\r\n         * Overrides <root> if specified.\r\n         */\r\n        execute(parent: any, root?: any): void;\r\n        /**\r\n         * Moves the specified node and all of its children by the given amount.\r\n         */\r\n        moveNode(node: any, dx: any, dy: any): void;\r\n        /**\r\n         * Called if <sortEdges> is true to sort the array of outgoing edges in place.\r\n         */\r\n        sortOutgoingEdges(source: any, edges: any): void;\r\n        /**\r\n         * Stores the maximum height (relative to the layout\r\n         * direction) of cells in each rank\r\n         */\r\n        findRankHeights(node: any, rank: any): void;\r\n        /**\r\n         * Set the cells heights (relative to the layout\r\n         * direction) when the tops of each rank are to be aligned\r\n         */\r\n        setCellHeights(node: any, rank: any): void;\r\n        /**\r\n         * Does a depth first search starting at the specified cell.\r\n         * Makes sure the specified parent is never left by the\r\n         * algorithm.\r\n         */\r\n        dfs(cell: any, parent: any): any;\r\n        /**\r\n         * Starts the actual compact tree layout algorithm\r\n         * at the given node.\r\n         */\r\n        layout(node: any): void;\r\n        /**\r\n         * Function: horizontalLayout\r\n         */\r\n        horizontalLayout(node: any, x0: any, y0: any, bounds?: any): any;\r\n        /**\r\n         * Function: verticalLayout\r\n         */\r\n        verticalLayout(node: any, parent: any, x0: any, y0: any, bounds?: any): any;\r\n        /**\r\n         * Function: attachParent\r\n         */\r\n        attachParent(node: any, height: any): void;\r\n        /**\r\n         * Function: layoutLeaf\r\n         */\r\n        layoutLeaf(node: any): void;\r\n        /**\r\n         * Function: join\r\n         */\r\n        join(node: any): any;\r\n        /**\r\n         * Function: merge\r\n         */\r\n        merge(p1: any, p2: any): number;\r\n        /**\r\n         * Function: offset\r\n         */\r\n        offset(p1: any, p2: any, a1: any, a2: any, b1: any, b2: any): number;\r\n        /**\r\n         * Function: bridge\r\n         */\r\n        bridge(line1: any, x1: any, y1: any, line2: any, x2: any, y2: any): Object;\r\n        /**\r\n         * Function: createNode\r\n         */\r\n        createNode(cell: any): Object;\r\n        /**\r\n         * Function: apply\r\n         */\r\n        apply(node: any, bounds: any): any;\r\n        /**\r\n         * Function: createLine\r\n         */\r\n        createLine(dx: any, dy: any, next?: any): Object;\r\n        /**\r\n         * Adjust parent cells whose child geometries have changed. The default\r\n         * implementation adjusts the group to just fit around the children with\r\n         * a padding.\r\n         */\r\n        adjustParents(): void;\r\n        /**\r\n         * Moves the specified node and all of its children by the given amount.\r\n         */\r\n        localEdgeProcessing(node: any): void;\r\n        /**\r\n         * Separates the x position of edges as they connect to vertices\r\n         */\r\n        processNodeOutgoing(node: any): void;\r\n    }\r\n    /**\r\n     * A utility class used to track cells whilst sorting occurs on the weighted\r\n     * sum of their connected edges. Does not violate (x.compareTo(y)==0) ==\r\n     * (x.equals(y))\r\n     *\r\n     * Constructor: WeightedCellSorter\r\n     *\r\n     * Constructs a new weighted cell sorted for the given cell and weight.\r\n     */\r\n    export declare class WeightedCellSorter {\r\n        constructor(cell: any, weightedValue: any);\r\n        /**\r\n         * Compares two WeightedCellSorters.\r\n         */\r\n        compare(a: any, b: any): 1 | 0 | -1;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxGraphLayout> to implement a radial tree algorithm. This\r\n     * layout is suitable for graphs that have no cycles (trees). Vertices that are\r\n     * not connected to the tree will be ignored by this layout.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layout = new mxRadialTreeLayout(graph);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * Constructor: mxRadialTreeLayout\r\n     *\r\n     * Constructs a new radial tree layout for the specified graph\r\n     */\r\n    export declare class mxRadialTreeLayout extends mxCompactTreeLayout {\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns a boolean indicating if the given <mxCell> should be ignored as a\r\n         * vertex. This returns true if the cell has no connections.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> whose ignored state should be returned.\r\n         */\r\n        isVertexIgnored(vertex: any): any;\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         *\r\n         * If the parent has any connected edges, then it is used as the root of\r\n         * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\r\n         * root node within the set of children of the given parent.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - <mxCell> whose children should be laid out.\r\n         * root - Optional <mxCell> that will be used as the root of the tree.\r\n         */\r\n        execute(parent: any, root: any): void;\r\n        /**\r\n         * Recursive function to calculate the dimensions of each row\r\n         *\r\n         * Parameters:\r\n         *\r\n         * row - Array of internal nodes, the children of which are to be processed.\r\n         * rowNum - Integer indicating which row is being processed.\r\n         */\r\n        calcRowDims(row: any, rowNum: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxGraphLayout> to implement a fast organic layout algorithm.\r\n     * The vertices need to be connected for this layout to work, vertices\r\n     * with no connections are ignored.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layout = new mxFastOrganicLayout(graph);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * Constructor: mxCompactTreeLayout\r\n     *\r\n     * Constructs a new fast organic layout for the specified graph.\r\n     */\r\n    export declare class mxFastOrganicLayout extends mxGraphLayout {\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns a boolean indicating if the given <mxCell> should be ignored as a\r\n         * vertex. This returns true if the cell has no connections.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> whose ignored state should be returned.\r\n         */\r\n        isVertexIgnored(vertex: any): any;\r\n        /**\r\n         * Implements <mxGraphLayout.execute>. This operates on all children of the\r\n         * given parent where <isVertexIgnored> returns false.\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Takes the displacements calculated for each cell and applies them to the\r\n         * local cache of cell positions. Limits the displacement to the current\r\n         * temperature.\r\n         */\r\n        calcPositions(): void;\r\n        /**\r\n         * Calculates the attractive forces between all laid out nodes linked by\r\n         * edges\r\n         */\r\n        calcAttraction(): void;\r\n        /**\r\n         * Calculates the repulsive forces between all laid out nodes\r\n         */\r\n        calcRepulsion(): void;\r\n        /**\r\n         * Reduces the temperature of the layout from an initial setting in a linear\r\n         * fashion to zero.\r\n         */\r\n        reduceTemperature(): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxGraphLayout> to implement a circluar layout for a given radius.\r\n     * The vertices do not need to be connected for this layout to work and all\r\n     * connections between vertices are not taken into account.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layout = new mxCircleLayout(graph);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * Constructor: mxCircleLayout\r\n     *\r\n     * Constructs a new circular layout for the specified radius.\r\n     *\r\n     * Arguments:\r\n     *\r\n     * graph - <mxGraph> that contains the cells.\r\n     * radius - Optional radius as an int. Default is 100.\r\n     */\r\n    export declare class mxCircleLayout extends mxGraphLayout {\r\n        constructor(graph: any, radius?: any);\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Returns the radius to be used for the given vertex count. Max is the maximum\r\n         * width or height of all vertices in the layout.\r\n         */\r\n        getRadius(count: any, max: any): number;\r\n        /**\r\n         * Executes the circular layout for the specified array\r\n         * of vertices and the given radius. This is called from\r\n         * <execute>.\r\n         */\r\n        circle(vertices: any, r: any, left: any, top: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxGraphLayout> for arranging parallel edges. This layout works\r\n     * on edges for all pairs of vertices where there is more than one edge\r\n     * connecting the latter.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layout = new mxParallelEdgeLayout(graph);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * To run the layout for the parallel edges of a changed edge only, the\r\n     * following code can be used.\r\n     *\r\n     * (code)\r\n     * var layout = new mxParallelEdgeLayout(graph);\r\n     *\r\n     * graph.addListener(mxEvent.CELL_CONNECTED, function(sender, evt)\r\n     * {\r\n     *   var model = graph.getModel();\r\n     *   var edge = evt.getProperty('edge');\r\n     *   var src = model.getTerminal(edge, true);\r\n     *   var trg = model.getTerminal(edge, false);\r\n     *\r\n     *   layout.isEdgeIgnored = function(edge2)\r\n     *   {\r\n     *     var src2 = model.getTerminal(edge2, true);\r\n     *     var trg2 = model.getTerminal(edge2, false);\r\n     *\r\n     *     return !(model.isEdge(edge2) && ((src == src2 && trg == trg2) || (src == trg2 && trg == src2)));\r\n     *   };\r\n     *\r\n     *   layout.execute(graph.getDefaultParent());\r\n     * });\r\n     * (end)\r\n     *\r\n     * Constructor: mxCompactTreeLayout\r\n     *\r\n     * Constructs a new fast organic layout for the specified graph.\r\n     */\r\n    export declare class mxParallelEdgeLayout extends mxGraphLayout {\r\n        constructor(graph: any);\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Finds the parallel edges in the given parent.\r\n         */\r\n        findParallels(parent: any): any[];\r\n        /**\r\n         * Returns a unique ID for the given edge. The id is independent of the\r\n         * edge direction and is built using the visible terminal of the given\r\n         * edge.\r\n         */\r\n        getEdgeId(edge: any): string;\r\n        /**\r\n         * Lays out the parallel edges in the given array.\r\n         */\r\n        layout(parallels: any): void;\r\n        /**\r\n         * Routes the given edge via the given point.\r\n         */\r\n        route(edge: any, x: any, y: any): void;\r\n    }\r\n\r\n    /**\r\n     * Allows to compose multiple layouts into a single layout. The master layout\r\n     * is the layout that handles move operations if another layout than the first\r\n     * element in <layouts> should be used. The <master> layout is not executed as\r\n     * the code assumes that it is part of <layouts>.\r\n     *\r\n     * Example:\r\n     * (code)\r\n     * var first = new mxFastOrganicLayout(graph);\r\n     * var second = new mxParallelEdgeLayout(graph);\r\n     * var layout = new mxCompositeLayout(graph, [first, second], first);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * Constructor: mxCompositeLayout\r\n     *\r\n     * Constructs a new layout using the given layouts. The graph instance is\r\n     * required for creating the transaction that contains all layouts.\r\n     *\r\n     * Arguments:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     * layouts - Array of <mxGraphLayouts>.\r\n     * master - Optional layout that handles moves. If no layout is given then\r\n     * the first layout of the above array is used to handle moves.\r\n     */\r\n    export declare class mxCompositeLayout extends mxGraphLayout {\r\n        constructor(graph: any, layouts: any, master: any);\r\n        /**\r\n         * Implements <mxGraphLayout.moveCell> by calling move on <master> or the first\r\n         * layout in <layouts>.\r\n         */\r\n        moveCell(cell: any, x: any, y: any): void;\r\n        /**\r\n         * Implements <mxGraphLayout.execute> by executing all <layouts> in a\r\n         * single transaction.\r\n         */\r\n        execute(parent: any): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxGraphLayout> to implement an edge label layout. This layout\r\n     * makes use of cell states, which means the graph must be validated in\r\n     * a graph view (so that the label bounds are available) before this layout\r\n     * can be executed.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layout = new mxEdgeLabelLayout(graph);\r\n     * layout.execute(graph.getDefaultParent());\r\n     * (end)\r\n     *\r\n     * Constructor: mxEdgeLabelLayout\r\n     *\r\n     * Constructs a new edge label layout.\r\n     *\r\n     * Arguments:\r\n     *\r\n     * graph - <mxGraph> that contains the cells.\r\n     */\r\n    export declare class mxEdgeLabelLayout extends mxGraphLayout {\r\n        constructor(graph: any, radius: any);\r\n        /**\r\n         * Implements <mxGraphLayout.execute>.\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Places the labels of the given edges.\r\n         */\r\n        placeLabels(v: any, e: any): void;\r\n        /**\r\n         * Places the labels of the given edges.\r\n         */\r\n        avoid(edge: any, vertex: any): void;\r\n    }\r\n\r\n    export declare class mxGraphModel extends mxEventSource {\r\n        /**\r\n         * Holds the root cell, which in turn contains the cells that represent the\r\n         * layers of the diagram as child cells. That is, the actual elements of the\r\n         * diagram are supposed to live in the third generation of cells and below.\r\n         */\r\n        root: any;\r\n        /**\r\n         * Maps from Ids to cells.\r\n         */\r\n        cells: { [id: string]: mxCell };\r\n        /**\r\n         * Specifies if edges should automatically be moved into the nearest common\r\n         * ancestor of their terminals. Default is true.\r\n         */\r\n        maintainEdgeParent: boolean;\r\n        /**\r\n         * Specifies if relative edge parents should be ignored for finding the nearest\r\n         * common ancestors of an edge's terminals. Default is true.\r\n         */\r\n        ignoreRelativeEdgeParent: boolean;\r\n        /**\r\n         * Specifies if the model should automatically create Ids for new cells.\r\n         * Default is true.\r\n         */\r\n        createIds: boolean;\r\n        /**\r\n         * Defines the prefix of new Ids. Default is an empty string.\r\n         */\r\n        prefix: string;\r\n        /**\r\n         * Defines the postfix of new Ids. Default is an empty string.\r\n         */\r\n        postfix: string;\r\n        /**\r\n         * Specifies the next Id to be created. Initial value is 0.\r\n         */\r\n        nextId: number;\r\n        /**\r\n         * Holds the changes for the current transaction. If the transaction is\r\n         * closed then a new object is created for this variable using\r\n         * <createUndoableEdit>.\r\n         */\r\n        currentEdit: any;\r\n        /**\r\n         * Counter for the depth of nested transactions. Each call to <beginUpdate>\r\n         * will increment this number and each call to <endUpdate> will decrement\r\n         * it. When the counter reaches 0, the transaction is closed and the\r\n         * respective events are fired. Initial value is 0.\r\n         */\r\n        updateLevel: number;\r\n        /**\r\n         * True if the program flow is currently inside endUpdate.\r\n         */\r\n        endingUpdate: boolean;\r\n        constructor(root?: any);\r\n        /**\r\n         * Sets a new root using <createRoot>.\r\n         */\r\n        clear(): void;\r\n        /**\r\n         * Returns <createIds>.\r\n         */\r\n        isCreateIds(): boolean;\r\n        /**\r\n         * Sets <createIds>.\r\n         */\r\n        setCreateIds(value: any): void;\r\n        /**\r\n         * Creates a new root cell with a default layer (child 0).\r\n         */\r\n        createRoot(): mxCell;\r\n        /**\r\n         * Returns the <mxCell> for the specified Id or null if no cell can be\r\n         * found for the given Id.\r\n         *\r\n         * @param id - A string representing the Id of the cell.\r\n         */\r\n        getCell(id: string): mxCell;\r\n        /**\r\n         * Returns the cells from the given array where the given filter function\r\n         * returns true.\r\n         */\r\n        filterCells(cells: mxCell[], filter: (cell: mxCell) => boolean): mxCell[];\r\n        /**\r\n         * Returns all descendants of the given cell and the cell itself in an array.\r\n         *\r\n         * @param parent - <mxCell> whose descendants should be returned.\r\n         */\r\n        getDescendants(parent: mxCell): mxCell[];\r\n        /**\r\n         * Visits all cells recursively and applies the specified filter function\r\n         * to each cell. If the function returns true then the cell is added\r\n         * to the resulting array. The parent and result paramters are optional.\r\n         * If parent is not specified then the recursion starts at <root>.\r\n         *\r\n         * The following example extracts all vertices from a given model:\r\n         * @example\r\n         * var filter = function(cell)\r\n         * {\r\n         * \treturn model.isVertex(cell);\r\n         * }\r\n         * var vertices = model.filterDescendants(filter);\r\n         *\r\n         * @param filter - JavaScript function that takes an <mxCell> as an argument\r\n         * and returns a boolean.\r\n         * @param parent - Optional <mxCell> that is used as the root of the recursion.\r\n         */\r\n        filterDescendants(filter: (cell: mxCell) => boolean, parent?: mxCell): mxCell[];\r\n        /**\r\n         * Returns the root of the model or the topmost parent of the given cell.\r\n         *\r\n         * @param cell - Optional <mxCell> that specifies the child.\r\n         */\r\n        getRoot(cell?: mxCell): mxCell;\r\n        /**\r\n         * Sets the <root> of the model using <mxRootChange> and adds the change to\r\n         * the current transaction. This resets all datastructures in the model and\r\n         * is the preferred way of clearing an existing model. Returns the new\r\n         * root.\r\n         *\r\n         * @example\r\n         * var root = new mxCell();\r\n         * root.insert(new mxCell());\r\n         * model.setRoot(root);\r\n         *\r\n         * @param root - <mxCell> that specifies the new root.\r\n         */\r\n        setRoot(root: mxCell): mxCell;\r\n        /**\r\n         * Inner callback to change the root of the model and update the internal\r\n         * datastructures, such as <cells> and <nextId>. Returns the previous root.\r\n         *\r\n         * @param root - <mxCell> that specifies the new root.\r\n         */\r\n        rootChanged(root: mxCell): mxCell;\r\n        /**\r\n         * Returns true if the given cell is the root of the model and a non-null\r\n         * value.\r\n         *\r\n         * @param cell - <mxCell> that represents the possible root.\r\n         */\r\n        isRoot(cell: mxCell): boolean;\r\n        /**\r\n         * Returns true if <isRoot> returns true for the parent of the given cell.\r\n         *\r\n         * @param cell - <mxCell> that represents the possible layer.\r\n         */\r\n        isLayer(cell: mxCell): boolean;\r\n        /**\r\n         * Returns true if the given parent is an ancestor of the given child.\r\n         *\r\n         * @param parent - <mxCell> that specifies the parent.\r\n         * @param child - <mxCell> that specifies the child.\r\n         */\r\n        isAncestor(parent: mxCell, child: mxCell): boolean;\r\n        /**\r\n         * Returns true if the model contains the given <mxCell>.\r\n         *\r\n         * @param cell - <mxCell> that specifies the cell.\r\n         */\r\n        contains(cell: mxCell): boolean;\r\n        /**\r\n         * Returns the parent of the given cell.\r\n         *\r\n         * @param cell - <mxCell> whose parent should be returned.\r\n         */\r\n        getParent(cell: mxCell): mxCell;\r\n        /**\r\n         * Adds the specified child to the parent at the given index using\r\n         * <mxChildChange> and adds the change to the current transaction. If no\r\n         * index is specified then the child is appended to the parent's array of\r\n         * children. Returns the inserted child.\r\n         *\r\n         * @param parent - <mxCell> that specifies the parent to contain the child.\r\n         * @param child - <mxCell> that specifies the child to be inserted.\r\n         * @param index - Optional integer that specifies the index of the child.\r\n         */\r\n        add(parent: mxCell, child: mxCell, index?: number): mxCell;\r\n        /**\r\n         * Inner callback to update <cells> when a cell has been added. This\r\n         * implementation resolves collisions by creating new Ids. To change the\r\n         * ID of a cell after it was inserted into the model, use the following\r\n         * code:\r\n         *\r\n         * (code\r\n         * delete model.cells[cell.getId()];\r\n         * cell.setId(newId);\r\n         * model.cells[cell.getId()] = cell;\r\n         * (end)\r\n         *\r\n         * If the change of the ID should be part of the command history, then the\r\n         * cell should be removed from the model and a clone with the new ID should\r\n         * be reinserted into the model instead.\r\n         *\r\n         * @param cell - <mxCell> that specifies the cell that has been added.\r\n         */\r\n        cellAdded(cell: mxCell): void;\r\n        /**\r\n         * Hook method to create an Id for the specified cell. This implementation\r\n         * concatenates <prefix>, id and <postfix> to create the Id and increments\r\n         * <nextId>. The cell is ignored by this implementation, but can be used in\r\n         * overridden methods to prefix the Ids with eg. the cell type.\r\n         *\r\n         * @param cell - <mxCell> to create the Id for.\r\n         */\r\n        createId(cell: mxCell): string;\r\n        /**\r\n         * Updates the parent for all edges that are connected to cell or one of\r\n         * its descendants using <updateEdgeParent>.\r\n         */\r\n        updateEdgeParents(cell: mxCell, root?: mxCell): void;\r\n        /**\r\n         * Returns the absolute, accumulated origin for the children inside the\r\n         * given parent as an <mxPoint>.\r\n         */\r\n        getOrigin(cell: mxCell): mxPoint;\r\n        /**\r\n         * Returns the nearest common ancestor for the specified cells.\r\n         *\r\n         * @param cell1 - <mxCell> that specifies the first cell in the tree.\r\n         * @param cell2 - <mxCell> that specifies the second cell in the tree.\r\n         */\r\n        getNearestCommonAncestor(cell1: mxCell, cell2: mxCell): mxCell;\r\n        /**\r\n         * Removes the specified cell from the model using <mxChildChange> and adds\r\n         * the change to the current transaction. This operation will remove the\r\n         * cell and all of its children from the model. Returns the removed cell.\r\n         *\r\n         * @param cell - <mxCell> that should be removed.\r\n         */\r\n        remove(cell: mxCell): mxCell;\r\n        /**\r\n         * Inner callback to update <cells> when a cell has been removed.\r\n         *\r\n         * @param cell - <mxCell> that specifies the cell that has been removed.\r\n         */\r\n        cellRemoved(cell: mxCell): void;\r\n        /**\r\n         * Inner callback to update the parent of a cell using <mxCell.insert>\r\n         * on the parent and return the previous parent.\r\n         *\r\n         * @param cell - <mxCell> to update the parent for.\r\n         * @param parent - <mxCell> that specifies the new parent of the cell.\r\n         * @param index - Optional integer that defines the index of the child\r\n         * in the parent's child array.\r\n         */\r\n        parentForCellChanged(cell: mxCell, parent: mxCell, index?: number): mxCell;\r\n        /**\r\n         * Returns the number of children in the given cell.\r\n         *\r\n         * @param cell - <mxCell> whose number of children should be returned.\r\n         */\r\n        getChildCount(cell: mxCell): number;\r\n        /**\r\n         * Returns the child of the given <mxCell> at the given index.\r\n         *\r\n         * @param cell - <mxCell> that represents the parent.\r\n         * @param index - Integer that specifies the index of the child to be returned.\r\n         */\r\n        getChildAt(cell: mxCell, index: number): mxCell;\r\n        /**\r\n         * Returns all children of the given <mxCell> as an array of <mxCells>. The\r\n         * return value should be only be read.\r\n         *\r\n         * @param cell - <mxCell> the represents the parent.\r\n         */\r\n        getChildren(cell: mxCell): mxCell[];\r\n        /**\r\n         * Returns the child vertices of the given parent.\r\n         *\r\n         * @param cell - <mxCell> whose child vertices should be returned.\r\n         */\r\n        getChildVertices(parent: mxCell): mxCell[];\r\n        /**\r\n         * Returns the child edges of the given parent.\r\n         *\r\n         * @param cell - <mxCell> whose child edges should be returned.\r\n         */\r\n        getChildEdges(parent: mxCell): mxCell[];\r\n        /**\r\n         * Returns the children of the given cell that are vertices and/or edges\r\n         * depending on the arguments.\r\n         *\r\n         * @param cell - <mxCell> the represents the parent.\r\n         * @param vertices - Boolean indicating if child vertices should be returned.\r\n         * Default is false.\r\n         * @param edges - Boolean indicating if child edges should be returned.\r\n         * Default is false.\r\n         */\r\n        getChildCells(parent: mxCell, vertices?: boolean, edges?: boolean): mxCell[];\r\n        /**\r\n         * Returns the source or target <mxCell> of the given edge depending on the\r\n         * value of the boolean parameter.\r\n         *\r\n         * @param edge - <mxCell> that specifies the edge.\r\n         * @param isSource - Boolean indicating which end of the edge should be returned.\r\n         */\r\n        getTerminal(edge: mxCell, isSource: boolean): mxCell;\r\n        /**\r\n         * Sets the source or target terminal of the given <mxCell> using\r\n         * <mxTerminalChange> and adds the change to the current transaction.\r\n         * This implementation updates the parent of the edge using <updateEdgeParent>\r\n         * if required.\r\n         *\r\n         * @param edge - <mxCell> that specifies the edge.\r\n         * @param terminal - <mxCell> that specifies the new terminal.\r\n         * @param isSource - Boolean indicating if the terminal is the new source or\r\n         * target terminal of the edge.\r\n         */\r\n        setTerminal(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;\r\n        /**\r\n         * Sets the source and target <mxCell> of the given <mxCell> in a single\r\n         * transaction using <setTerminal> for each end of the edge.\r\n         *\r\n         * @param edge - <mxCell> that specifies the edge.\r\n         * @param source - <mxCell> that specifies the new source terminal.\r\n         * @param target - <mxCell> that specifies the new target terminal.\r\n         */\r\n        setTerminals(edge: mxCell, source: mxCell, target: mxCell): void;\r\n        /**\r\n         * Inner helper function to update the terminal of the edge using\r\n         * <mxCell.insertEdge> and return the previous terminal.\r\n         *\r\n         * @param edge - <mxCell> that specifies the edge to be updated.\r\n         * @param terminal - <mxCell> that specifies the new terminal.\r\n         * @param isSource - Boolean indicating if the terminal is the new source or\r\n         * target terminal of the edge.\r\n         */\r\n        terminalForCellChanged(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;\r\n        /**\r\n         * Returns the number of distinct edges connected to the given cell.\r\n         *\r\n         * @param cell - <mxCell> that represents the vertex.\r\n         */\r\n        getEdgeCount(cell: mxCell): number;\r\n        /**\r\n         * Returns the edge of cell at the given index.\r\n         *\r\n         * @param cell - <mxCell> that specifies the vertex.\r\n         * @param index - Integer that specifies the index of the edge\r\n         * to return.\r\n         */\r\n        getEdgeAt(cell: mxCell, index: number): mxCell;\r\n        /**\r\n         * Returns the number of incoming or outgoing edges, ignoring the given\r\n         * edge.\r\n         *\r\n         * @param cell - <mxCell> whose edge count should be returned.\r\n         * @param outgoing - Boolean that specifies if the number of outgoing or\r\n         * incoming edges should be returned.\r\n         * @param ignoredEdge - <mxCell> that represents an edge to be ignored.\r\n         */\r\n        getDirectedEdgeCount(cell: mxCell, outgoing: boolean, ignoredEdge?: mxCell): number;\r\n        /**\r\n         * Returns all edges of the given cell without loops.\r\n         *\r\n         * @param cell - <mxCell> whose edges should be returned.\r\n         */\r\n        getConnections(cell: mxCell): mxCell[];\r\n        /**\r\n         * Returns the incoming edges of the given cell without loops.\r\n         *\r\n         * @param cell - <mxCell> whose incoming edges should be returned.\r\n         */\r\n        getIncomingEdges(cell: mxCell): mxCell[];\r\n        /**\r\n         * Returns the outgoing edges of the given cell without loops.\r\n         *\r\n         * @param cell - <mxCell> whose outgoing edges should be returned.\r\n         */\r\n        getOutgoingEdges(cell: mxCell): mxCell[];\r\n        /**\r\n         * Returns all distinct edges connected to this cell as a new array of\r\n         * <mxCells>. If at least one of incoming or outgoing is true, then loops\r\n         * are ignored, otherwise if both are false, then all edges connected to\r\n         * the given cell are returned including loops.\r\n         *\r\n         * @param cell - <mxCell> that specifies the cell.\r\n         * @param incoming - Optional boolean that specifies if incoming edges should be\r\n         * returned. Default is true.\r\n         * @param outgoing - Optional boolean that specifies if outgoing edges should be\r\n         * returned. Default is true.\r\n         * @param includeLoops - Optional boolean that specifies if loops should be returned.\r\n         * Default is true.\r\n         */\r\n        getEdges(cell: mxCell, incoming?: boolean, outgoing?: boolean, includeLoops?: boolean): mxCell[];\r\n        /**\r\n         * Returns all edges between the given source and target pair. If directed\r\n         * is true, then only edges from the source to the target are returned,\r\n         * otherwise, all edges between the two cells are returned.\r\n         *\r\n         * @param source - <mxCell> that defines the source terminal of the edge to be\r\n         * returned.\r\n         * @param target - <mxCell> that defines the target terminal of the edge to be\r\n         * returned.\r\n         * @param directed - Optional boolean that specifies if the direction of the\r\n         * edge should be taken into account. Default is false.\r\n         */\r\n        getEdgesBetween(source: mxCell, target: mxCell, directed?: boolean): mxCell[];\r\n        /**\r\n         * Returns all opposite vertices wrt terminal for the given edges, only\r\n         * returning sources and/or targets as specified. The result is returned\r\n         * as an array of <mxCells>.\r\n         *\r\n         * @param edges - Array of <mxCells> that contain the edges to be examined.\r\n         * @param terminal - <mxCell> that specifies the known end of the edges.\r\n         * @param sources - Boolean that specifies if source terminals should be contained\r\n         * in the result. Default is true.\r\n         * @param targets - Boolean that specifies if target terminals should be contained\r\n         * in the result. Default is true.\r\n         */\r\n        getOpposites(edges: mxCell[], terminal: mxCell, sources?: boolean, targets?: boolean): mxCell[];\r\n        /**\r\n         * Returns the topmost cells of the hierarchy in an array that contains no\r\n         * descendants for each <mxCell> that it contains. Duplicates should be\r\n         * removed in the cells array to improve performance.\r\n         *\r\n         * @param cells - Array of <mxCells> whose topmost ancestors should be returned.\r\n         */\r\n        getTopmostCells(cells: mxCell[]): mxCell[];\r\n        /**\r\n         * Returns true if the given cell is a vertex.\r\n         *\r\n         * @param cell - <mxCell> that represents the possible vertex.\r\n         */\r\n        isVertex(cell: mxCell): boolean;\r\n        /**\r\n         * Returns true if the given cell is an edge.\r\n         *\r\n         * @param cell - <mxCell> that represents the possible edge.\r\n         */\r\n        isEdge(cell: mxCell): boolean;\r\n        /**\r\n         * Returns true if the given <mxCell> is connectable. If <edgesConnectable>\r\n         * is false, then this function returns false for all edges else it returns\r\n         * the return value of <mxCell.isConnectable>.\r\n         *\r\n         * @param cell - <mxCell> whose connectable state should be returned.\r\n         */\r\n        isConnectable(cell: mxCell): boolean;\r\n        /**\r\n         * Returns the user object of the given <mxCell> using <mxCell.getValue>.\r\n         *\r\n         * @param cell - <mxCell> whose user object should be returned.\r\n         */\r\n        getValue(cell: mxCell): Value;\r\n        /**\r\n         * Sets the user object of then given <mxCell> using <mxValueChange>\r\n         * and adds the change to the current transaction.\r\n         *\r\n         * @param cell - <mxCell> whose user object should be changed.\r\n         * @param value - Object that defines the new user object.\r\n         */\r\n        setValue(cell: mxCell, value: Object): Object;\r\n        /**\r\n         * Returns the <mxGeometry> of the given <mxCell>.\r\n         *\r\n         * @param cell - <mxCell> whose geometry should be returned.\r\n         */\r\n        getGeometry(cell: mxCell): mxGeometry;\r\n        /**\r\n         * Sets the <mxGeometry> of the given <mxCell>. The actual update\r\n         * of the cell is carried out in <geometryForCellChanged>. The\r\n         * <mxGeometryChange> action is used to encapsulate the change.\r\n         *\r\n         * @param cell - <mxCell> whose geometry should be changed.\r\n         * @param geometry - <mxGeometry> that defines the new geometry.\r\n         */\r\n        setGeometry(cell: mxCell, geometry: mxGeometry): mxGeometry;\r\n        /**\r\n         * Returns the style of the given <mxCell>.\r\n         *\r\n         * @param cell - <mxCell> whose style should be returned.\r\n         */\r\n        getStyle(cell: mxCell): string;\r\n        /**\r\n         * Sets the style of the given <mxCell> using <mxStyleChange> and\r\n         * adds the change to the current transaction.\r\n         *\r\n         * @param cell - <mxCell> whose style should be changed.\r\n         * @param style - String of the form [stylename;|key=value;] to specify\r\n         * the new cell style.\r\n         */\r\n        setStyle(cell: mxCell, style: string): string;\r\n        /**\r\n         * Inner callback to update the style of the given <mxCell>\r\n         * using <mxCell.setStyle> and return the previous style.\r\n         *\r\n         * @param cell - <mxCell> that specifies the cell to be updated.\r\n         * @param style - String of the form [stylename;|key=value;] to specify\r\n         * the new cell style.\r\n         */\r\n        styleForCellChanged(cell: mxCell, style: string): string;\r\n        /**\r\n         * Returns true if the given <mxCell> is collapsed.\r\n         *\r\n         * @param cell - <mxCell> whose collapsed state should be returned.\r\n         */\r\n        isCollapsed(cell: mxCell): boolean;\r\n        /**\r\n         * Sets the collapsed state of the given <mxCell> using <mxCollapseChange>\r\n         * and adds the change to the current transaction.\r\n         *\r\n         * @param cell - <mxCell> whose collapsed state should be changed.\r\n         * @param collapsed - Boolean that specifies the new collpased state.\r\n         */\r\n        setCollapsed(cell: mxCell, collapsed: boolean): boolean;\r\n        /**\r\n         * Inner callback to update the collapsed state of the\r\n         * given <mxCell> using <mxCell.setCollapsed> and return\r\n         * the previous collapsed state.\r\n         *\r\n         * @param cell - <mxCell> that specifies the cell to be updated.\r\n         * @param collapsed - Boolean that specifies the new collpased state.\r\n         */\r\n        collapsedStateForCellChanged(cell: mxCell, collapsed: boolean): boolean;\r\n        /**\r\n         * Returns true if the given <mxCell> is visible.\r\n         *\r\n         * @param cell - <mxCell> whose visible state should be returned.\r\n         */\r\n        isVisible(cell: mxCell): boolean;\r\n        /**\r\n         * Sets the visible state of the given <mxCell> using <mxVisibleChange> and\r\n         * adds the change to the current transaction.\r\n         *\r\n         * @param cell - <mxCell> whose visible state should be changed.\r\n         * @param visible - Boolean that specifies the new visible state.\r\n         */\r\n        setVisible(cell: mxCell, visible: boolean): boolean;\r\n        /**\r\n         * Inner callback to update the visible state of the\r\n         * given <mxCell> using <mxCell.setCollapsed> and return\r\n         * the previous visible state.\r\n         *\r\n         * @param cell - <mxCell> that specifies the cell to be updated.\r\n         * @param visible - Boolean that specifies the new visible state.\r\n         */\r\n        visibleStateForCellChanged(cell: mxCell, visible: boolean): boolean;\r\n        /**\r\n         * Executes the given edit and fires events if required. The edit object\r\n         * requires an execute function which is invoked. The edit is added to the\r\n         * <currentEdit> between <beginUpdate> and <endUpdate> calls, so that\r\n         * events will be fired if this execute is an individual transaction, that\r\n         * is, if no previous <beginUpdate> calls have been made without calling\r\n         * <endUpdate>. This implementation fires an <execute> event before\r\n         * executing the given change.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * change - Object that described the change.\r\n         */\r\n        execute(change: any): void;\r\n        /**\r\n         * Increments the <updateLevel> by one. The event notification\r\n         * is queued until <updateLevel> reaches 0 by use of\r\n         * <endUpdate>.\r\n         *\r\n         * All changes on <mxGraphModel> are transactional,\r\n         * that is, they are executed in a single undoable change\r\n         * on the model (without transaction isolation).\r\n         * Therefore, if you want to combine any\r\n         * number of changes into a single undoable change,\r\n         * you should group any two or more API calls that\r\n         * modify the graph model between <beginUpdate>\r\n         * and <endUpdate> calls as shown here:\r\n         *\r\n         * (code)\r\n         * var model = graph.getModel();\r\n         * var parent = graph.getDefaultParent();\r\n         * var index = model.getChildCount(parent);\r\n         * model.beginUpdate();\r\n         * try\r\n         * {\r\n         *   model.add(parent, v1, index);\r\n         *   model.add(parent, v2, index+1);\r\n         * }\r\n         * finally\r\n         * {\r\n         *   model.endUpdate();\r\n         * }\r\n         * (end)\r\n         *\r\n         * Of course there is a shortcut for appending a\r\n         * sequence of cells into the default parent:\r\n         *\r\n         * (code)\r\n         * graph.addCells([v1, v2]).\r\n         * (end)\r\n         */\r\n        beginUpdate(): void;\r\n        /**\r\n         * Decrements the <updateLevel> by one and fires an <undo>\r\n         * event if the <updateLevel> reaches 0. This function\r\n         * indirectly fires a <change> event by invoking the notify\r\n         * function on the <currentEdit> und then creates a new\r\n         * <currentEdit> using <createUndoableEdit>.\r\n         *\r\n         * The <undo> event is fired only once per edit, whereas\r\n         * the <change> event is fired whenever the notify\r\n         * function is invoked, that is, on undo and redo of\r\n         * the edit.\r\n         */\r\n        endUpdate(): void;\r\n        /**\r\n         * Creates a new <mxUndoableEdit> that implements the\r\n         * notify function to fire a <change> and <notify> event\r\n         * through the <mxUndoableEdit>'s source.\r\n         */\r\n        createUndoableEdit(): mxUndoableEdit;\r\n        /**\r\n         * Merges the children of the given cell into the given target cell inside\r\n         * this model. All cells are cloned unless there is a corresponding cell in\r\n         * the model with the same id, in which case the source cell is ignored and\r\n         * all edges are connected to the corresponding cell in this model. Edges\r\n         * are considered to have no identity and are always cloned unless the\r\n         * cloneAllEdges flag is set to false, in which case edges with the same\r\n         * id in the target model are reconnected to reflect the terminals of the\r\n         * source edges.\r\n         */\r\n        mergeChildren(from: any, to: any, cloneAllEdges: any): void;\r\n        /**\r\n         * Clones the children of the source cell into the given target cell in\r\n         * this model and adds an entry to the mapping that maps from the source\r\n         * cell to the target cell with the same id or the clone of the source cell\r\n         * that was inserted into this model.\r\n         */\r\n        mergeChildrenImpl(from: any, to: any, cloneAllEdges: any, mapping: any): void;\r\n        /**\r\n         * Returns an array that represents the set (no duplicates) of all parents\r\n         * for the given array of cells.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cells - Array of cells whose parents should be returned.\r\n         */\r\n        getParents(cells: any): any[];\r\n        /**\r\n         * Returns a deep clone of the given <mxCell> (including\r\n         * the children) which is created using <cloneCells>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> to be cloned.\r\n         */\r\n        cloneCell(cell: any): any;\r\n        /**\r\n         * Returns an array of clones for the given array of <mxCells>.\r\n         * Depending on the value of includeChildren, a deep clone is created for\r\n         * each cell. Connections are restored based if the corresponding\r\n         * cell is contained in the passed in array.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cells - Array of <mxCell> to be cloned.\r\n         * includeChildren - Boolean indicating if the cells should be cloned\r\n         * with all descendants.\r\n         * mapping - Optional mapping for existing clones.\r\n         */\r\n        cloneCells(cells: mxCell[], includeChildren: boolean, mapping?: any): any[];\r\n        /**\r\n         * Inner helper method for cloning cells recursively.\r\n         */\r\n        cloneCellImpl(cell: any, mapping: any, includeChildren: any): any;\r\n        /**\r\n         * Hook for cloning the cell. This returns cell.clone() or\r\n         * any possible exceptions.\r\n         */\r\n        cellCloned(cell: any): any;\r\n        /**\r\n         * Inner helper method for restoring the connections in\r\n         * a network of cloned cells.\r\n         */\r\n        restoreClone(clone: any, cell: any, mapping: any): void;\r\n    }\r\n    /**\r\n     * Action to change the root in a model.\r\n     *\r\n     * Constructor: mxRootChange\r\n     *\r\n     * Constructs a change of the root in the\r\n     * specified model.\r\n     */\r\n    export declare class mxRootChange {\r\n        model: mxGraphModel;\r\n        root: any;\r\n        previous: mxCell;\r\n        constructor(model: any, root: any);\r\n        /**\r\n         * Carries out a change of the root using\r\n         * <mxGraphModel.rootChanged>.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * Action to add or remove a child in a model.\r\n     *\r\n     * Constructor: mxChildChange\r\n     *\r\n     * Constructs a change of a child in the\r\n     * specified model.\r\n     */\r\n    export declare class mxChildChange {\r\n        parent: any;\r\n        previous: any;\r\n        child: mxCell;\r\n        index: any;\r\n        previousIndex: any;\r\n        constructor(model: any, parent: any, child: mxCell, index?: number);\r\n        /**\r\n         * Changes the parent of <child> using\r\n         * <mxGraphModel.parentForCellChanged> and\r\n         * removes or restores the cell's\r\n         * connections.\r\n         */\r\n        execute(): void;\r\n        /**\r\n         * Disconnects the given cell recursively from its\r\n         * terminals and stores the previous terminal in the\r\n         * cell's terminals.\r\n         */\r\n        connect(cell: any, isConnect: any): void;\r\n    }\r\n    /**\r\n     * Action to change a terminal in a model.\r\n     *\r\n     * Constructor: mxTerminalChange\r\n     *\r\n     * Constructs a change of a terminal in the\r\n     * specified model.\r\n     */\r\n    export declare class mxTerminalChange {\r\n        model: any;\r\n        cell: mxCell;\r\n        terminal: any;\r\n        previous: mxCell;\r\n        source: any;\r\n        constructor(model: any, cell: any, terminal: any, source: any);\r\n        /**\r\n         * Changes the terminal of <cell> to <previous> using\r\n         * <mxGraphModel.terminalForCellChanged>.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * Action to change a user object in a model.\r\n     *\r\n     * Constructor: mxValueChange\r\n     *\r\n     * Constructs a change of a user object in the\r\n     * specified model.\r\n     */\r\n    export declare class mxValueChange {\r\n        model: any;\r\n        cell: any;\r\n        value: any;\r\n        previous: any;\r\n        constructor(model: any, cell: any, value: any);\r\n        /**\r\n         * Changes the value of <cell> to <previous> using\r\n         * <mxGraphModel.valueForCellChanged>.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * Action to change a cell's style in a model.\r\n     *\r\n     * Constructor: mxStyleChange\r\n     *\r\n     * Constructs a change of a style in the\r\n     * specified model.\r\n     */\r\n    export declare class mxStyleChange {\r\n        model: any;\r\n        cell: any;\r\n        style: any;\r\n        previous: any;\r\n        constructor(model: any, cell: any, style: any);\r\n        /**\r\n         * Changes the style of <cell> to <previous> using\r\n         * <mxGraphModel.styleForCellChanged>.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * Action to change a cell's geometry in a model.\r\n     *\r\n     * Constructor: mxGeometryChange\r\n     *\r\n     * Constructs a change of a geometry in the\r\n     * specified model.\r\n     */\r\n    export declare class mxGeometryChange {\r\n        model: any;\r\n        cell: any;\r\n        geometry: any;\r\n        previous: any;\r\n        constructor(model: any, cell: any, geometry: any);\r\n        /**\r\n         * Changes the geometry of <cell> ro <previous> using\r\n         * <mxGraphModel.geometryForCellChanged>.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * Action to change a cell's collapsed state in a model.\r\n     *\r\n     * Constructor: mxCollapseChange\r\n     *\r\n     * Constructs a change of a collapsed state in the\r\n     * specified model.\r\n     */\r\n    export declare class mxCollapseChange {\r\n        model: any;\r\n        cell: any;\r\n        collapsed: any;\r\n        previous: any;\r\n        constructor(model: any, cell: any, collapsed: any);\r\n        /**\r\n         * Changes the collapsed state of <cell> to <previous> using\r\n         * <mxGraphModel.collapsedStateForCellChanged>.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * Action to change a cell's visible state in a model.\r\n     *\r\n     * Constructor: mxVisibleChange\r\n     *\r\n     * Constructs a change of a visible state in the\r\n     * specified model.\r\n     */\r\n    export declare class mxVisibleChange {\r\n        model: any;\r\n        cell: any;\r\n        visible: any;\r\n        previous: any;\r\n        constructor(model: any, cell: any, visible: any);\r\n        /**\r\n         * Changes the visible state of <cell> to <previous> using\r\n         * <mxGraphModel.visibleStateForCellChanged>.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * Action to change the attribute of a cell's user object.\r\n     * There is no method on the graph model that uses this\r\n     * action. To use the action, you can use the code shown\r\n     * in the example below.\r\n     *\r\n     * Example:\r\n     *\r\n     * To change the attributeName in the cell's user object\r\n     * to attributeValue, use the following code:\r\n     *\r\n     * (code)\r\n     * model.beginUpdate();\r\n     * try\r\n     * {\r\n     *   var edit = new mxCellAttributeChange(\r\n     *     cell, attributeName, attributeValue);\r\n     *   model.execute(edit);\r\n     * }\r\n     * finally\r\n     * {\r\n     *   model.endUpdate();\r\n     * }\r\n     * (end)\r\n     *\r\n     * Constructor: mxCellAttributeChange\r\n     *\r\n     * Constructs a change of a attribute of the DOM node\r\n     * stored as the value of the given <mxCell>.\r\n     */\r\n    export declare class mxCellAttributeChange {\r\n        cell: any;\r\n        attribute: any;\r\n        value: any;\r\n        previous: any;\r\n        constructor(cell: any, attribute: any, value: any);\r\n        /**\r\n         * Changes the attribute of the cell's user object by\r\n         * using <mxCell.setAttribute>.\r\n         */\r\n        execute(): void;\r\n    }\r\n\r\n    export declare interface Value extends Object {\r\n        nodeName: string;\r\n    }\r\n    /**\r\n     * Cells are the elements of the graph model. They represent the state\r\n     * of the groups, vertices and edges in a graph.\r\n     *\r\n     * Custom attributes:\r\n     *\r\n     * For custom attributes we recommend using an XML node as the value of a cell.\r\n     * The following code can be used to create a cell with an XML node as the\r\n     * value:\r\n     *\r\n     * (code)\r\n     * var doc = mxUtils.createXmlDocument();\r\n     * var node = doc.createElement('MyNode')\r\n     * node.setAttribute('label', 'MyLabel');\r\n     * node.setAttribute('attribute1', 'value1');\r\n     * graph.insertVertex(graph.getDefaultParent(), null, node, 40, 40, 80, 30);\r\n     * (end)\r\n     *\r\n     * For the label to work, <mxGraph.convertValueToString> and\r\n     * <mxGraph.cellLabelChanged> should be overridden as follows:\r\n     *\r\n     * (code)\r\n     * graph.convertValueToString = function(cell)\r\n     * {\r\n     *   if (mxUtils.isNode(cell.value))\r\n     *   {\r\n     *     return cell.getAttribute('label', '')\r\n     *   }\r\n     * };\r\n     *\r\n     * var invalidating: any;\r\n     * cellLabelChanged = graph.cellLabelChanged;\r\n     * graph.cellLabelChanged = function(cell, newValue, autoSize)\r\n     * {\r\n     *   if (mxUtils.isNode(cell.value))\r\n     *   {\r\n     *     // Clones the value for correct undo/redo\r\n     *     var elt = cell.value.cloneNode(true);\r\n     *     elt.setAttribute('label', newValue);\r\n     *     newValue = elt;\r\n     *   }\r\n     *\r\n     *   cellLabelChanged.apply(this, arguments);\r\n     * };\r\n     * (end)\r\n     */\r\n    export declare class mxCell {\r\n        /**\r\n         * Holds the Id. Default is null.\r\n         */\r\n        id: string;\r\n        /**\r\n         * Holds the user object. Default is null.\r\n         */\r\n        value: any;\r\n        /**\r\n         * Holds the <mxGeometry>. Default is null.\r\n         */\r\n        geometry: mxGeometry;\r\n        /**\r\n         * Holds the style as a string of the form [(stylename|key=value);]. Default is\r\n         * null.\r\n         */\r\n        style: string;\r\n        /**\r\n         * Specifies whether the cell is a vertex. Default is false.\r\n         */\r\n        vertex: boolean;\r\n        /**\r\n         * Specifies whether the cell is an edge. Default is false.\r\n         */\r\n        edge: boolean;\r\n        /**\r\n         * Specifies whether the cell is connectable. Default is true.\r\n         */\r\n        connectable: boolean;\r\n        /**\r\n         * Specifies whether the cell is visible. Default is true.\r\n         */\r\n        visible: boolean;\r\n        /**\r\n         * Specifies whether the cell is collapsed. Default is false.\r\n         */\r\n        collapsed: boolean;\r\n        /**\r\n         * Reference to the parent cell.\r\n         */\r\n        parent: mxCell;\r\n        /**\r\n         * Reference to the source terminal.\r\n         */\r\n        source: mxCell;\r\n        /**\r\n         * Reference to the target terminal.\r\n         */\r\n        target: mxCell;\r\n        /**\r\n         * Holds the child cells.\r\n         */\r\n        children: mxCell[];\r\n        /**\r\n         * Holds the edges.\r\n         */\r\n        edges: mxCell[];\r\n        /**\r\n         * List of members that should not be cloned inside <clone>. This field is\r\n         * passed to <mxUtils.clone> and is not made persistent in <mxCellCodec>.\r\n         * This is not a convention for all classes, it is only used in this class\r\n         * to mark transient fields since transient modifiers are not supported by\r\n         * the language.\r\n         */\r\n        mxTransient: string[];\r\n        /**\r\n         * Implicit variable declarations\r\n         */\r\n        overlays: mxCellOverlay[];\r\n        /**\r\n         * Constructs a new cell to be used in a graph model.\r\n         * This method invokes <onInit> upon completion.\r\n         *\r\n         * @param value - Optional object that represents the cell value.\r\n         * @param geometry - Optional <mxGeometry> that specifies the geometry.\r\n         * @param style - Optional formatted string that defines the style.\r\n         */\r\n        constructor(value?: any, geometry?: mxGeometry, style?: string);\r\n        /**\r\n         * Returns the Id of the cell as a string.\r\n         */\r\n        getId(): string;\r\n        /**\r\n         * Sets the Id of the cell to the given string.\r\n         */\r\n        setId(id: string): void;\r\n        /**\r\n         * Returns the user object of the cell. The user\r\n         * object is stored in <value>.\r\n         */\r\n        getValue(): Value;\r\n        /**\r\n         * Sets the user object of the cell. The user object\r\n         * is stored in <value>.\r\n         */\r\n        setValue(value: any): void;\r\n        /**\r\n         * Changes the user object after an in-place edit\r\n         * and returns the previous value. This implementation\r\n         * replaces the user object with the given value and\r\n         * returns the old user object.\r\n         */\r\n        valueChanged(newValue: any): any;\r\n        /**\r\n         * Returns the <mxGeometry> that describes the <geometry>.\r\n         */\r\n        getGeometry(): mxGeometry;\r\n        /**\r\n         * Sets the <mxGeometry> to be used as the <geometry>.\r\n         */\r\n        setGeometry(geometry: mxGeometry): void;\r\n        /**\r\n         * Returns a string that describes the <style>.\r\n         */\r\n        getStyle(): string;\r\n        /**\r\n         * Sets the string to be used as the <style>.\r\n         */\r\n        setStyle(style: string): void;\r\n        /**\r\n         * Returns true if the cell is a vertex.\r\n         */\r\n        isVertex(): boolean;\r\n        /**\r\n         * Specifies if the cell is a vertex. This should only be assigned at\r\n         * construction of the cell and not be changed during its lifecycle.\r\n         *\r\n         * @param vertex - Boolean that specifies if the cell is a vertex.\r\n         */\r\n        setVertex(vertex: boolean): void;\r\n        /**\r\n         * Returns true if the cell is an edge.\r\n         */\r\n        isEdge(): boolean;\r\n        /**\r\n         * Specifies if the cell is an edge. This should only be assigned at\r\n         * construction of the cell and not be changed during its lifecycle.\r\n         *\r\n         * @param edge - Boolean that specifies if the cell is an edge.\r\n         */\r\n        setEdge(edge: boolean): void;\r\n        /**\r\n         * Returns true if the cell is connectable.\r\n         */\r\n        isConnectable(): boolean;\r\n        /**\r\n         * Sets the connectable state.\r\n         *\r\n         * @param connectable - Boolean that specifies the new connectable state.\r\n         */\r\n        setConnectable(connectable: boolean): void;\r\n        /**\r\n         * Returns true if the cell is visibile.\r\n         */\r\n        isVisible(): boolean;\r\n        /**\r\n         * Specifies if the cell is visible.\r\n         *\r\n         * @param visible - Boolean that specifies the new visible state.\r\n         */\r\n        setVisible(visible: boolean): void;\r\n        /**\r\n         * Returns true if the cell is collapsed.\r\n         */\r\n        isCollapsed(): boolean;\r\n        /**\r\n         * Sets the collapsed state.\r\n         *\r\n         * @param collapsed - Boolean that specifies the new collapsed state.\r\n         */\r\n        setCollapsed(collapsed: boolean): void;\r\n        /**\r\n         * Returns the cell's parent.\r\n         */\r\n        getParent(): mxCell;\r\n        /**\r\n         * Sets the parent cell.\r\n         *\r\n         * @param parent - <mxCell> that represents the new parent.\r\n         */\r\n        setParent(parent: mxCell): void;\r\n        /**\r\n         * Returns the source or target terminal.\r\n         *\r\n         * @param source - Boolean that specifies if the source terminal should be\r\n         * returned. (true:source, false:target)\r\n         */\r\n        getTerminal(source: boolean): mxCell;\r\n        /**\r\n         * Sets the source or target terminal and returns the new terminal.\r\n         *\r\n         * @param terminal - <mxCell> that represents the new source or target terminal.\r\n         * @param isSource - Boolean that specifies if the source or target terminal\r\n         * should be set.\r\n         */\r\n        setTerminal(terminal: mxCell, isSource: boolean): mxCell;\r\n        /**\r\n         * Returns the number of child cells.\r\n         */\r\n        getChildCount(): number;\r\n        /**\r\n         * Returns the index of the specified child in the child array.\r\n         *\r\n         * @param child - Child whose index should be returned.\r\n         */\r\n        getIndex(child: mxCell): any;\r\n        /**\r\n         * Returns the child at the specified index.\r\n         *\r\n         * @param index - Integer that specifies the child to be returned.\r\n         */\r\n        getChildAt(index: number): mxCell;\r\n        /**\r\n         * Inserts the specified child into the child array at the specified index\r\n         * and updates the parent reference of the child. If not childIndex is\r\n         * specified then the child is appended to the child array. Returns the\r\n         * inserted child.\r\n         *\r\n         * @param child - <mxCell> to be inserted or appended to the child array.\r\n         * @param index - Optional integer that specifies the index at which the child\r\n         * should be inserted into the child array.\r\n         */\r\n        insert(child: mxCell, index?: number): mxCell;\r\n        /**\r\n         * Removes the child at the specified index from the child array and\r\n         * returns the child that was removed. Will remove the parent reference of\r\n         * the child.\r\n         *\r\n         * @param index - Integer that specifies the index of the child to be\r\n         * removed.\r\n         */\r\n        remove(index: number): any;\r\n        /**\r\n         * Removes the cell from its parent.\r\n         */\r\n        removeFromParent(): void;\r\n        /**\r\n         * Returns the number of edges in the edge array.\r\n         */\r\n        getEdgeCount(): number;\r\n        /**\r\n         * Returns the index of the specified edge in <edges>.\r\n         *\r\n         * @param edge - <mxCell> whose index in <edges> should be returned.\r\n         */\r\n        getEdgeIndex(edge: mxCell): any;\r\n        /**\r\n         * Returns the edge at the specified index in <edges>.\r\n         *\r\n         * @param index - Integer that specifies the index of the edge to be returned.\r\n         */\r\n        getEdgeAt(index: number): mxCell;\r\n        /**\r\n         * Inserts the specified edge into the edge array and returns the edge.\r\n         * Will update the respective terminal reference of the edge.\r\n         *\r\n         * @param edge - <mxCell> to be inserted into the edge array.\r\n         * @param isOutgoing - Boolean that specifies if the edge is outgoing.\r\n         */\r\n        insertEdge(edge: mxCell, isOutgoing: boolean): mxCell;\r\n        /**\r\n         * Removes the specified edge from the edge array and returns the edge.\r\n         * Will remove the respective terminal reference from the edge.\r\n         *\r\n         * @param edge - <mxCell> to be removed from the edge array.\r\n         * @param isOutgoing - Boolean that specifies if the edge is outgoing.\r\n         */\r\n        removeEdge(edge: mxCell, isOutgoing: boolean): mxCell;\r\n        /**\r\n         * Removes the edge from its source or target terminal.\r\n         *\r\n         * @param isSource - Boolean that specifies if the edge should be removed from its\r\n         * source or target terminal.\r\n         */\r\n        removeFromTerminal(isSource: boolean): void;\r\n        /**\r\n         * Returns true if the user object is an XML node that contains the given\r\n         * attribute.\r\n         *\r\n         * @param name - Name of the attribute.\r\n         */\r\n        hasAttribute(name: string): any;\r\n        /**\r\n         * Returns the specified attribute from the user object if it is an XML\r\n         * node.\r\n         *\r\n         * @param name - Name of the attribute whose value should be returned.\r\n         * @param defaultValue - Optional default value to use if the attribute has no\r\n         * value.\r\n         */\r\n        getAttribute(name: string, defaultValue?: string): any;\r\n        /**\r\n         * Sets the specified attribute on the user object if it is an XML node.\r\n         *\r\n         * @param name - Name of the attribute whose value should be set.\r\n         * @param value - New value of the attribute.\r\n         */\r\n        setAttribute(name: string, value: string): void;\r\n        /**\r\n         * Returns a clone of the cell. Uses <cloneValue> to clone\r\n         * the user object. All fields in <mxTransient> are ignored\r\n         * during the cloning.\r\n         */\r\n        clone(): any;\r\n        /**\r\n         * Returns a clone of the cell's user object.\r\n         */\r\n        cloneValue(): any;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxRectangle> to represent the geometry of a cell.\r\n     *\r\n     * For vertices, the geometry consists of the x- and y-location, and the width\r\n     * and height. For edges, the geometry consists of the optional terminal- and\r\n     * control points. The terminal points are only required if an edge is\r\n     * unconnected, and are stored in the sourcePoint> and <targetPoint>\r\n     * variables, respectively.\r\n     *\r\n     * Example:\r\n     *\r\n     * If an edge is unconnected, that is, it has no source or target terminal,\r\n     * then a geometry with terminal points for a new edge can be defined as\r\n     * follows.\r\n     *\r\n     * (code)\r\n     * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\r\n     * geometry.points = [new mxPoint(x2, y2)];\r\n     * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\r\n     * (end)\r\n     *\r\n     * Control points are used regardless of the connected state of an edge and may\r\n     * be ignored or interpreted differently depending on the edge's <mxEdgeStyle>.\r\n     *\r\n     * To disable automatic reset of control points after a cell has been moved or\r\n     * resized, the the <mxGraph.resizeEdgesOnMove> and\r\n     * <mxGraph.resetEdgesOnResize> may be used.\r\n     *\r\n     * Edge Labels:\r\n     *\r\n     * Using the x- and y-coordinates of a cell's geometry, it is possible to\r\n     * position the label on edges on a specific location on the actual edge shape\r\n     * as it appears on the screen. The x-coordinate of an edge's geometry is used\r\n     * to describe the distance from the center of the edge from -1 to 1 with 0\r\n     * being the center of the edge and the default value. The y-coordinate of an\r\n     * edge's geometry is used to describe the absolute, orthogonal distance in\r\n     * pixels from that point. In addition, the <mxGeometry.offset> is used as an\r\n     * absolute offset vector from the resulting point.\r\n     *\r\n     * This coordinate system is applied if <relative> is true, otherwise the\r\n     * offset defines the absolute vector from the edge's center point to the\r\n     * label and the values for <x> and <y> are ignored.\r\n     *\r\n     * The width and height parameter for edge geometries can be used to set the\r\n     * label width and height (eg. for word wrapping).\r\n     *\r\n     * Ports:\r\n     *\r\n     * The term \"port\" refers to a relatively positioned, connectable child cell,\r\n     * which is used to specify the connection between the parent and another cell\r\n     * in the graph. Ports are typically modeled as vertices with relative\r\n     * geometries.\r\n     *\r\n     * Offsets:\r\n     *\r\n     * The <offset> field is interpreted in 3 different ways, depending on the cell\r\n     * and the geometry. For edges, the offset defines the absolute offset for the\r\n     * edge label. For relative geometries, the offset defines the absolute offset\r\n     * for the origin (top, left corner) of the vertex, otherwise the offset\r\n     * defines the absolute offset for the label inside the vertex or group.\r\n     */\r\n    export declare class mxGeometry extends mxRectangle {\r\n        /**\r\n         * Global switch to translate the points in translate. Default is true.\r\n         */\r\n        TRANSLATE_CONTROL_POINTS: boolean;\r\n        /**\r\n         * Stores alternate values for x, y, width and height in a rectangle. See\r\n         * <swap> to exchange the values. Default is null.\r\n         */\r\n        alternateBounds: any;\r\n        /**\r\n         * Defines the source <mxPoint> of the edge. This is used if the\r\n         * corresponding edge does not have a source vertex. Otherwise it is\r\n         * ignored. Default is  null.\r\n         */\r\n        sourcePoint: any;\r\n        /**\r\n         * Defines the target <mxPoint> of the edge. This is used if the\r\n         * corresponding edge does not have a target vertex. Otherwise it is\r\n         * ignored. Default is null.\r\n         */\r\n        targetPoint: any;\r\n        /**\r\n         * Array of <mxPoints> which specifies the control points along the edge.\r\n         * These points are the intermediate points on the edge, for the endpoints\r\n         * use <targetPoint> and <sourcePoint> or set the terminals of the edge to\r\n         * a non-null value. Default is null.\r\n         */\r\n        points: any;\r\n        /**\r\n         * For edges, this holds the offset (in pixels) from the position defined\r\n         * by <x> and <y> on the edge. For relative geometries (for vertices), this\r\n         * defines the absolute offset from the point defined by the relative\r\n         * coordinates. For absolute geometries (for vertices), this defines the\r\n         * offset for the label. Default is null.\r\n         */\r\n        offset: any;\r\n        /**\r\n         * Specifies if the coordinates in the geometry are to be interpreted as\r\n         * relative coordinates. For edges, this is used to define the location of\r\n         * the edge label relative to the edge as rendered on the display. For\r\n         * vertices, this specifies the relative location inside the bounds of the\r\n         * parent cell.\r\n         *\r\n         * If this is false, then the coordinates are relative to the origin of the\r\n         * parent cell or, for edges, the edge label position is relative to the\r\n         * center of the edge as rendered on screen.\r\n         *\r\n         * Default is false.\r\n         */\r\n        relative: boolean;\r\n        /**\r\n         * Constructs a new object to describe the size and location of a vertex or\r\n         * the control points of an edge.\r\n         * @param x\r\n         * @param y\r\n         * @param width\r\n         * @param height\r\n         */\r\n        constructor(x?: number, y?: number, width?: number, height?: number);\r\n        /**\r\n         * Swaps the x, y, width and height with the values stored in\r\n         * <alternateBounds> and puts the previous values into <alternateBounds> as\r\n         * a rectangle. This operation is carried-out in-place, that is, using the\r\n         * existing geometry instance. If this operation is called during a graph\r\n         * model transactional change, then the geometry should be cloned before\r\n         * calling this method and setting the geometry of the cell using\r\n         * <mxGraphModel.setGeometry>.\r\n         */\r\n        swap(): void;\r\n        /**\r\n         * Returns the <mxPoint> representing the source or target point of this\r\n         * edge. This is only used if the edge has no source or target vertex.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * isSource - Boolean that specifies if the source or target point\r\n         * should be returned.\r\n         */\r\n        getTerminalPoint(isSource: any): any;\r\n        /**\r\n         * Sets the <sourcePoint> or <targetPoint> to the given <mxPoint> and\r\n         * returns the new point.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * point - Point to be used as the new source or target point.\r\n         * isSource - Boolean that specifies if the source or target point\r\n         * should be set.\r\n         */\r\n        setTerminalPoint(point: any, isSource: any): any;\r\n        /**\r\n         * Rotates the geometry by the given angle around the given center. That is,\r\n         * <x> and <y> of the geometry, the <sourcePoint>, <targetPoint> and all\r\n         * <points> are translated by the given amount. <x> and <y> are only\r\n         * translated if <relative> is false.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * angle - Number that specifies the rotation angle in degrees.\r\n         * cx - <mxPoint> that specifies the center of the rotation.\r\n         */\r\n        rotate(angle: any, cx: any): void;\r\n        /**\r\n         * Translates the geometry by the specified amount. That is, <x> and <y> of the\r\n         * geometry, the <sourcePoint>, <targetPoint> and all <points> are translated\r\n         * by the given amount. <x> and <y> are only translated if <relative> is false.\r\n         * If <TRANSLATE_CONTROL_POINTS> is false, then <points> are not modified by\r\n         * this function.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dx - Number that specifies the x-coordinate of the translation.\r\n         * dy - Number that specifies the y-coordinate of the translation.\r\n         */\r\n        translate(dx: any, dy: any): void;\r\n        /**\r\n         * Scales the geometry by the given amount. That is, <x> and <y> of the\r\n         * geometry, the <sourcePoint>, <targetPoint> and all <points> are scaled\r\n         * by the given amount. <x>, <y>, <width> and <height> are only scaled if\r\n         * <relative> is false. If <fixedAspect> is true, then the smaller value\r\n         * is used to scale the width and the height.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * sx - Number that specifies the horizontal scale factor.\r\n         * sy - Number that specifies the vertical scale factor.\r\n         * fixedAspect - Optional boolean to keep the aspect ratio fixed.\r\n         */\r\n        scale(sx: any, sy: any, fixedAspect: any): void;\r\n        /**\r\n         * Returns true if the given object equals this geometry.\r\n         */\r\n        equals(obj: any): any;\r\n    }\r\n\r\n\r\n    export declare var mxCellPath: {\r\n        PATH_SEPARATOR: string;\r\n        create(cell: any): string;\r\n        getParentPath(path: any): any;\r\n        resolve(root: any, path: any): any;\r\n        compare(p1: any, p2: any): number;\r\n    };\r\n\r\n\r\n    export declare var mxPerimeter: {\r\n        RectanglePerimeter(bounds: any, vertex: any, next: any, orthogonal: any): mxPoint;\r\n        EllipsePerimeter(bounds: any, vertex: any, next: any, orthogonal: any): mxPoint;\r\n        RhombusPerimeter(bounds: any, vertex: any, next: any, orthogonal: any): any;\r\n        TrianglePerimeter(bounds: any, vertex: any, next: any, orthogonal: any): any;\r\n        HexagonPerimeter(bounds: any, vertex: any, next: any, orthogonal: any): mxPoint;\r\n    };\r\n\r\n    /**\r\n     * Implements printing of a diagram across multiple pages. The following opens\r\n     * a print preview for an existing graph:\r\n     *\r\n     * (code)\r\n     * var preview = new mxPrintPreview(graph);\r\n     * preview.open();\r\n     * (end)\r\n     *\r\n     * Use <mxUtils.getScaleForPageCount> as follows in order to print the graph\r\n     * across a given number of pages:\r\n     *\r\n     * (code)\r\n     * var pageCount = mxUtils.prompt('Enter page count', '1');\r\n     *\r\n     * if (pageCount != null)\r\n     * {\r\n     *   var scale = mxUtils.getScaleForPageCount(pageCount, graph);\r\n     *   var preview = new mxPrintPreview(graph, scale);\r\n     *   preview.open();\r\n     * }\r\n     * (end)\r\n     *\r\n     * Additional pages:\r\n     *\r\n     * To add additional pages before and after the output, <getCoverPages> and\r\n     * <getAppendices> can be used, respectively.\r\n     *\r\n     * (code)\r\n     * var preview = new mxPrintPreview(graph, 1);\r\n     *\r\n     * preview.getCoverPages = function(w, h)\r\n     * {\r\n     *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\r\n     *   {\r\n     *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'\r\n     *   }))];\r\n     * };\r\n     *\r\n     * preview.getAppendices = function(w, h)\r\n     * {\r\n     *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\r\n     *   {\r\n     *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'\r\n     *   }))];\r\n     * };\r\n     *\r\n     * preview.open();\r\n     * (end)\r\n     *\r\n     * CSS:\r\n     *\r\n     * The CSS from the original page is not carried over to the print preview.\r\n     * To add CSS to the page, use the css argument in the <open> function or\r\n     * override <writeHead> to add the respective link tags as follows:\r\n     *\r\n     * (code)\r\n     * var writeHead = preview.writeHead;\r\n     * preview.writeHead = function(doc, css)\r\n     * {\r\n     *   writeHead.apply(this, arguments);\r\n     *   doc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');\r\n     * };\r\n     * (end)\r\n     *\r\n     * Padding:\r\n     *\r\n     * To add a padding to the page in the preview (but not the print output), use\r\n     * the following code:\r\n     *\r\n     * (code)\r\n     * preview.writeHead = function(doc)\r\n     * {\r\n     *   writeHead.apply(this, arguments);\r\n     *\r\n     *   doc.writeln('<style type=\"text/css\">');\r\n     *   doc.writeln('@media screen {');\r\n     *   doc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');\r\n     *   doc.writeln('}');\r\n     *   doc.writeln('</style>');\r\n     * };\r\n     * (end)\r\n     *\r\n     * Headers:\r\n     *\r\n     * Apart from setting the title argument in the mxPrintPreview constructor you\r\n     * can override <renderPage> as follows to add a header to any page:\r\n     *\r\n     * (code)\r\n     * var oldRenderPage = mxPrintPreview.prototype.renderPage;\r\n     * mxPrintPreview.prototype.renderPage = function(w, h, x, y, content, pageNumber)\r\n     * {\r\n     *   var div = oldRenderPage.apply(this, arguments);\r\n     *\r\n     *   var header = document.createElement('div');\r\n     *   header.style.position = 'absolute';\r\n     *   header.style.top = '0px';\r\n     *   header.style.width = '100%';\r\n     *   header.style.textAlign = 'right';\r\n     *   mxUtils.write(header, 'Your header here');\r\n     *   div.firstChild.appendChild(header);\r\n     *\r\n     *   return div;\r\n     * };\r\n     * (end)\r\n     *\r\n     * The pageNumber argument contains the number of the current page, starting at\r\n     * 1. To display a header on the first page only, check pageNumber and add a\r\n     * vertical offset in the constructor call for the height of the header.\r\n     *\r\n     * Page Format:\r\n     *\r\n     * For landscape printing, use <mxConstants.PAGE_FORMAT_A4_LANDSCAPE> as\r\n     * the pageFormat in <mxUtils.getScaleForPageCount> and <mxPrintPreview>.\r\n     * Keep in mind that one can not set the defaults for the print dialog\r\n     * of the operating system from JavaScript so the user must manually choose\r\n     * a page format that matches this setting.\r\n     *\r\n     * You can try passing the following CSS directive to <open> to set the\r\n     * page format in the print dialog to landscape. However, this CSS\r\n     * directive seems to be ignored in most major browsers, including IE.\r\n     *\r\n     * (code)\r\n     * @page {\r\n     *   size: landscape;\r\n     * }\r\n     * (end)\r\n     *\r\n     * Note that the print preview behaves differently in IE when used from the\r\n     * filesystem or via HTTP so printing should always be tested via HTTP.\r\n     *\r\n     * If you are using a DOCTYPE in the source page you can override <getDoctype>\r\n     * and provide the same DOCTYPE for the print preview if required. Here is\r\n     * an example for IE8 standards mode.\r\n     *\r\n     * (code)\r\n     * var preview = new mxPrintPreview(graph);\r\n     * preview.getDoctype = function()\r\n     * {\r\n     *   return '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=5,IE=8\" ><![endif]-->';\r\n     * };\r\n     * preview.open();\r\n     * (end)\r\n     *\r\n     * Constructor: mxPrintPreview\r\n     *\r\n     * Constructs a new print preview for the given parameters.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - <mxGraph> to be previewed.\r\n     * scale - Optional scale of the output. Default is 1 / <mxGraph.pageScale>.\r\n     * border - Border in pixels along each side of every page. Note that the\r\n     * actual print function in the browser will add another border for\r\n     * printing.\r\n     * pageFormat - <mxRectangle> that specifies the page format (in pixels).\r\n     * This should match the page format of the printer. Default uses the\r\n     * <mxGraph.pageFormat> of the given graph.\r\n     * x0 - Optional left offset of the output. Default is 0.\r\n     * y0 - Optional top offset of the output. Default is 0.\r\n     * borderColor - Optional color of the page border. Default is no border.\r\n     * Note that a border is sometimes useful to highlight the printed page\r\n     * border in the print preview of the browser.\r\n     * title - Optional string that is used for the window title. Default\r\n     * is 'Printer-friendly version'.\r\n     * pageSelector - Optional boolean that specifies if the page selector\r\n     * should appear in the window with the print preview. Default is true.\r\n     */\r\n    export declare class mxPrintPreview {\r\n        printOverlays: boolean;\r\n        printControls: boolean;\r\n        printBackgroundImage: boolean;\r\n        constructor(graph: any, scale?: any, pageFormat?: any, border?: any, x0?: any, y0?: any, borderColor?: any, title?: any, pageSelector?: any);\r\n        /**\r\n         * Returns <wnd>.\r\n         */\r\n        getWindow(): any;\r\n        /**\r\n         * Returns the string that should go before the HTML tag in the print preview\r\n         * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,\r\n         * IE8 in IE8 standards mode and edge in IE9 standards mode.\r\n         */\r\n        getDoctype(): string;\r\n        /**\r\n         * Adds the given graph to the existing print preview.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * css - Optional CSS string to be used in the head section.\r\n         * targetWindow - Optional window that should be used for rendering. If\r\n         * this is specified then no HEAD tag, CSS and BODY tag will be written.\r\n         */\r\n        appendGraph(graph: any, scale: any, x0: any, y0: any, forcePageBreaks: any, keepOpen: any): void;\r\n        /**\r\n         * Shows the print preview window. The window is created here if it does\r\n         * not exist.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * css - Optional CSS string to be used in the head section.\r\n         * targetWindow - Optional window that should be used for rendering. If\r\n         * this is specified then no HEAD tag, CSS and BODY tag will be written.\r\n         */\r\n        open(css?: any, targetWindow?: any, forcePageBreaks?: any, keepOpen?: any): any;\r\n        /**\r\n         * Adds a page break to the given document.\r\n         */\r\n        addPageBreak(doc: any): void;\r\n        /**\r\n         * Writes the closing tags for body and page after calling <writePostfix>.\r\n         */\r\n        closeDocument(): void;\r\n        /**\r\n         * Writes the HEAD section into the given document, without the opening\r\n         * and closing HEAD tags.\r\n         */\r\n        writeHead(doc: any, css: any): void;\r\n        /**\r\n         * Called before closing the body of the page. This implementation is empty.\r\n         */\r\n        writePostfix(doc: any): void;\r\n        /**\r\n         * Creates the page selector table.\r\n         */\r\n        createPageSelector(vpages: any, hpages: any): any;\r\n        /**\r\n         * Creates a DIV that prints a single page of the given\r\n         * graph using the given scale and returns the DIV that\r\n         * represents the page.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * w - Width of the page in pixels.\r\n         * h - Height of the page in pixels.\r\n         * dx - Optional horizontal page offset in pixels (used internally).\r\n         * dy - Optional vertical page offset in pixels (used internally).\r\n         * content - Callback that adds the HTML content to the inner div of a page.\r\n         * Takes the inner div as the argument.\r\n         * pageNumber - Integer representing the page number.\r\n         */\r\n        renderPage(w: any, h: any, dx: any, dy: any, content: any, pageNumber: any): HTMLDivElement;\r\n        /**\r\n         * Returns the root cell for painting the graph.\r\n         */\r\n        getRoot(): any;\r\n        /**\r\n         * Adds a graph fragment to the given div.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dx - Horizontal translation for the diagram.\r\n         * dy - Vertical translation for the diagram.\r\n         * scale - Scale for the diagram.\r\n         * pageNumber - Number of the page to be rendered.\r\n         * div - Div that contains the output.\r\n         * clip - Contains the clipping rectangle as an <mxRectangle>.\r\n         */\r\n        addGraphFragment(dx: any, dy: any, scale: any, pageNumber: any, div: any, clip: any): void;\r\n        /**\r\n         * Returns the link for the given cell state. This returns null.\r\n         */\r\n        getLinkForCellState(state: any): any;\r\n        /**\r\n         * Inserts the background image into the given div.\r\n         */\r\n        insertBackgroundImage(div: any, dx: any, dy: any): void;\r\n        /**\r\n         * Returns the pages to be added before the print output. This returns null.\r\n         */\r\n        getCoverPages(): any;\r\n        /**\r\n         * Returns the pages to be added after the print output. This returns null.\r\n         */\r\n        getAppendices(): any;\r\n        /**\r\n         * Opens the print preview and shows the print dialog.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * css - Optional CSS string to be used in the head section.\r\n         */\r\n        print(css: any): void;\r\n        /**\r\n         * Closes the print preview window.\r\n         */\r\n        close(): void;\r\n    }\r\n\r\n    /**\r\n     * Defines the appearance of the cells in a graph. See <putCellStyle> for an\r\n     * example of creating a new cell style. It is recommended to use objects, not\r\n     * arrays for holding cell styles. Existing styles can be cloned using\r\n     * <mxUtils.clone> and turned into a string for debugging using\r\n     * <mxUtils.toString>.\r\n     *\r\n     * Default Styles:\r\n     *\r\n     * The stylesheet contains two built-in styles, which are used if no style is\r\n     * defined for a cell:\r\n     *\r\n     *   defaultVertex - Default style for vertices\r\n     *   defaultEdge - Default style for edges\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var vertexStyle = stylesheet.getDefaultVertexStyle();\r\n     * vertexStyle[mxConstants.ROUNDED] = true;\r\n     * var edgeStyle = stylesheet.getDefaultEdgeStyle();\r\n     * edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;\r\n     * (end)\r\n     *\r\n     * Modifies the built-in default styles.\r\n     *\r\n     * To avoid the default style for a cell, add a leading semicolon\r\n     * to the style definition, eg.\r\n     *\r\n     * (code)\r\n     * ;shadow=1\r\n     * (end)\r\n     *\r\n     * Removing keys:\r\n     *\r\n     * For removing a key in a cell style of the form [stylename;|key=value;] the\r\n     * special value none can be used, eg. highlight;fillColor=none\r\n     *\r\n     * See also the helper methods in mxUtils to modify strings of this format,\r\n     * namely <mxUtils.setStyle>, <mxUtils.indexOfStylename>,\r\n     * <mxUtils.addStylename>, <mxUtils.removeStylename>,\r\n     * <mxUtils.removeAllStylenames> and <mxUtils.setStyleFlag>.\r\n     *\r\n     * Constructor: mxStylesheet\r\n     *\r\n     * Constructs a new stylesheet and assigns default styles.\r\n     */\r\n    export declare class mxStylesheet {\r\n        constructor();\r\n        /**\r\n         * Creates and returns the default vertex style.\r\n         */\r\n        createDefaultVertexStyle(): Object;\r\n        /**\r\n         * Creates and returns the default edge style.\r\n         */\r\n        createDefaultEdgeStyle(): Object;\r\n        /**\r\n         * Sets the default style for vertices using defaultVertex as the\r\n         * stylename.\r\n         *\r\n         * Parameters:\r\n         * style - Key, value pairs that define the style.\r\n         */\r\n        putDefaultVertexStyle(style: any): void;\r\n        /**\r\n         * Sets the default style for edges using defaultEdge as the stylename.\r\n         */\r\n        putDefaultEdgeStyle(style: any): void;\r\n        /**\r\n         * Returns the default style for vertices.\r\n         */\r\n        getDefaultVertexStyle(): any;\r\n        /**\r\n         * Sets the default style for edges.\r\n         */\r\n        getDefaultEdgeStyle(): any;\r\n        /**\r\n         * Stores the given map of key, value pairs under the given name in\r\n         * <styles>.\r\n         *\r\n         * Example:\r\n         *\r\n         * The following example adds a new style called 'rounded' into an\r\n         * existing stylesheet:\r\n         *\r\n         * (code)\r\n         * var style = new Object();\r\n         * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\r\n         * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\r\n         * style[mxConstants.STYLE_ROUNDED] = true;\r\n         * graph.getStylesheet().putCellStyle('rounded', style);\r\n         * (end)\r\n         *\r\n         * In the above example, the new style is an object. The possible keys of\r\n         * the object are all the constants in <mxConstants> that start with STYLE\r\n         * and the values are either JavaScript objects, such as\r\n         * <mxPerimeter.RightAngleRectanglePerimeter> (which is in fact a function)\r\n         * or expressions, such as true. Note that not all keys will be\r\n         * interpreted by all shapes (eg. the line shape ignores the fill color).\r\n         * The final call to this method associates the style with a name in the\r\n         * stylesheet. The style is used in a cell with the following code:\r\n         *\r\n         * (code)\r\n         * model.setStyle(cell, 'rounded');\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * name - Name for the style to be stored.\r\n         * style - Key, value pairs that define the style.\r\n         */\r\n        putCellStyle(name: any, style: any): void;\r\n        /**\r\n         * Returns the cell style for the specified stylename or the given\r\n         * defaultStyle if no style can be found for the given stylename.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * name - String of the form [(stylename|key=value);] that represents the\r\n         * style.\r\n         * defaultStyle - Default style to be returned if no style can be found.\r\n         */\r\n        getCellStyle(name: any, defaultStyle: any): any;\r\n    }\r\n\r\n    /**\r\n     * Represents the current state of a cell in a given <mxGraphView>.\r\n     *\r\n     * For edges, the edge label position is stored in <absoluteOffset>.\r\n     *\r\n     * The size for oversize labels can be retrieved using the boundingBox property\r\n     * of the <text> field as shown below.\r\n     *\r\n     * @example\r\n     * var bbox = (state.text != null) ? state.text.boundingBox : null;\r\n     */\r\n    export declare class mxCellState extends mxRectangle {\r\n        /**\r\n         * Reference to the enclosing <mxGraphView>.\r\n         */\r\n        view: mxGraphView;\r\n        /**\r\n         * Reference to the <mxCell> that is represented by this state.\r\n         */\r\n        cell: mxCell;\r\n        /**\r\n         * Contains an array of key, value pairs that represent the style of the\r\n         * cell.\r\n         */\r\n        style: any;\r\n        /**\r\n         * Specifies if the state is invalid. Default is true.\r\n         */\r\n        invalid: boolean;\r\n        /**\r\n         * <mxPoint> that holds the origin for all child cells. Default is a new\r\n         * empty <mxPoint>.\r\n         */\r\n        origin: mxPoint;\r\n        /**\r\n         * Holds an array of <mxPoints> that represent the absolute points of an\r\n         * edge.\r\n         */\r\n        absolutePoints: mxPoint[];\r\n        /**\r\n         * <mxPoint> that holds the absolute offset. For edges, this is the\r\n         * absolute coordinates of the label position. For vertices, this is the\r\n         * offset of the label relative to the top, left corner of the vertex.\r\n         */\r\n        absoluteOffset: mxPoint;\r\n        /**\r\n         * Caches the visible source terminal state.\r\n         */\r\n        visibleSourceState: any;\r\n        /**\r\n         * Caches the visible target terminal state.\r\n         */\r\n        visibleTargetState: any;\r\n        /**\r\n         * Caches the distance between the end points for an edge.\r\n         */\r\n        terminalDistance: number;\r\n        /**\r\n         * Caches the length of an edge.\r\n         */\r\n        length: number;\r\n        /**\r\n         * Array of numbers that represent the cached length of each segment of the\r\n         * edge.\r\n         */\r\n        segments: number[];\r\n        /**\r\n         * Holds the <mxShape> that represents the cell graphically.\r\n         */\r\n        shape: mxShape;\r\n        /**\r\n         * Holds the <mxText> that represents the label of the cell. Thi smay be\r\n         * null if the cell has no label.\r\n         */\r\n        text: mxText;\r\n        /**\r\n         * Holds the unscaled width of the state.\r\n         */\r\n        unscaledWidth: any;\r\n        /**\r\n         * Implicit variable declarations\r\n         */\r\n        cellBounds: mxRectangle;\r\n        paintBounds: mxRectangle;\r\n        /**\r\n         * Constructs a new object that represents the current state of the given\r\n         * cell in the specified view.\r\n         *\r\n         * @param view - <mxGraphView> that contains the state.\r\n         * @param cell - <mxCell> that this state represents.\r\n         * @param style - Array of key, value pairs that constitute the style.\r\n         */\r\n        constructor(view: mxGraphView, cell: mxCell, style: any[]);\r\n        /**\r\n         * Returns the <mxRectangle> that should be used as the perimeter of the\r\n         * cell.\r\n         *\r\n         * @param border - Optional border to be added around the perimeter bounds.\r\n         * @param bounds - Optional <mxRectangle> to be used as the initial bounds.\r\n         */\r\n        getPerimeterBounds(border?: number, bounds?: mxRectangle): mxRectangle;\r\n        /**\r\n         * Sets the first or last point in <absolutePoints> depending on isSource.\r\n         *\r\n         * @param point - <mxPoint> that represents the terminal point.\r\n         * @param isSource - Boolean that specifies if the first or last point should\r\n         * be assigned.\r\n         */\r\n        setAbsoluteTerminalPoint(point: mxPoint, isSource: boolean): void;\r\n        /**\r\n         * Sets the given cursor on the shape and text shape.\r\n         */\r\n        setCursor(cursor: any): void;\r\n        /**\r\n         * Returns the visible source or target terminal cell.\r\n         *\r\n         * @param source - Boolean that specifies if the source or target cell should be\r\n         * returned.\r\n         */\r\n        getVisibleTerminal(source: boolean): any;\r\n        /**\r\n         * Returns the visible source or target terminal state.\r\n         *\r\n         * @param source - Boolean that specifies if the source or target state should be\r\n         * returned.\r\n         */\r\n        getVisibleTerminalState(source: boolean): any;\r\n        /**\r\n         * Sets the visible source or target terminal state.\r\n         *\r\n         * @param terminalState - <mxCellState> that represents the terminal.\r\n         * @param source - Boolean that specifies if the source or target state should be set.\r\n         */\r\n        setVisibleTerminalState(terminalState: mxCellState, source: boolean): void;\r\n        /**\r\n         * Returns the unscaled, untranslated bounds.\r\n         */\r\n        getCellBounds(): mxRectangle;\r\n        /**\r\n         * Returns the unscaled, untranslated paint bounds. This is the same as\r\n         * <getCellBounds> but with a 90 degree rotation if the shape's\r\n         * isPaintBoundsInverted returns true.\r\n         */\r\n        getPaintBounds(): mxRectangle;\r\n        /**\r\n         * Updates the cellBounds and paintBounds.\r\n         */\r\n        updateCachedBounds(): void;\r\n        /**\r\n         * Destructor: setState\r\n         *\r\n         * Copies all fields from the given state to this state.\r\n         */\r\n        setState(state: mxCellState): void;\r\n        /**\r\n         * Returns a clone of this <mxCellState>.\r\n         */\r\n        clone(): mxCellState;\r\n        /**\r\n         * Destructor: destroy\r\n         *\r\n         * Destroys the state and all associated resources.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Implements the selection model for a graph. Here is a listener that handles\r\n     * all removed selection cells.\r\n     *\r\n     * (code)\r\n     * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)\r\n     * {\r\n     *   var cells = evt.getProperty('added');\r\n     *\r\n     *   for (var i = 0; i < cells.length; i++)\r\n     *   {\r\n     *     // Handle cells[i]...\r\n     *   }\r\n     * });\r\n     * (end)\r\n     *\r\n     * Event: mxEvent.UNDO\r\n     *\r\n     * Fires after the selection was changed in <changeSelection>. The\r\n     * <code>edit</code> property contains the <mxUndoableEdit> which contains the\r\n     * <mxSelectionChange>.\r\n     *\r\n     * Event: mxEvent.CHANGE\r\n     *\r\n     * Fires after the selection changes by executing an <mxSelectionChange>. The\r\n     * <code>added</code> and <code>removed</code> properties contain arrays of\r\n     * cells that have been added to or removed from the selection, respectively.\r\n     * The names are inverted due to historic reasons. This cannot be changed.\r\n     */\r\n    export declare class mxGraphSelectionModel extends mxEventSource {\r\n        /**\r\n         * Specifies the resource key for the status message after a long operation.\r\n         * If the resource for this key does not exist then the value is used as\r\n         * the status message. Default is 'done'.\r\n         */\r\n        doneResource: string;\r\n        /**\r\n         * Specifies the resource key for the status message while the selection is\r\n         * being updated. If the resource for this key does not exist then the\r\n         * value is used as the status message. Default is 'updatingSelection'.\r\n         */\r\n        updatingSelectionResource: string;\r\n        /**\r\n         * Reference to the enclosing <mxGraph>.\r\n         */\r\n        graph: mxGraph;\r\n        /**\r\n         * Specifies if only one selected item at a time is allowed.\r\n         * Default is false.\r\n         */\r\n        singleSelection: boolean;\r\n        /**\r\n         * Implicit variable declarations\r\n         */\r\n        cells: mxCell[];\r\n        /**\r\n         * Constructs a new graph selection model for the given <mxGraph>.\r\n         *\r\n         * @param graph - Reference to the enclosing <mxGraph>.\r\n         */\r\n        constructor(graph: mxGraph);\r\n        /**\r\n         * Returns <singleSelection> as a boolean.\r\n         */\r\n        isSingleSelection(): boolean;\r\n        /**\r\n         * Sets the <singleSelection> flag.\r\n         *\r\n         * @param singleSelection - Boolean that specifies the new value for\r\n         * <singleSelection>.\r\n         */\r\n        setSingleSelection(singleSelection: boolean): void;\r\n        /**\r\n         * Returns true if the given <mxCell> is selected.\r\n         */\r\n        isSelected(cell: mxCell): boolean;\r\n        /**\r\n         * Returns true if no cells are currently selected.\r\n         */\r\n        isEmpty(): boolean;\r\n        /**\r\n         * Clears the selection and fires a <change> event if the selection was not\r\n         * empty.\r\n         */\r\n        clear(): void;\r\n        /**\r\n         * Selects the specified <mxCell> using <setCells>.\r\n         *\r\n         * @param cell - <mxCell> to be selected.\r\n         */\r\n        setCell(cell: mxCell): void;\r\n        /**\r\n         * Selects the given array of <mxCells> and fires a <change> event.\r\n         *\r\n         * @param cells - Array of <mxCells> to be selected.\r\n         */\r\n        setCells(cells: mxCell[]): void;\r\n        /**\r\n         * Returns the first selectable cell in the given array of cells.\r\n         */\r\n        getFirstSelectableCell(cells: mxCell[]): mxCell;\r\n        /**\r\n         * Adds the given <mxCell> to the selection and fires a <select> event.\r\n         *\r\n         * @param cell - <mxCell> to add to the selection.\r\n         */\r\n        addCell(cell: mxCell): void;\r\n        /**\r\n         * Adds the given array of <mxCells> to the selection and fires a <select>\r\n         * event.\r\n         *\r\n         * @param cells - Array of <mxCells> to add to the selection.\r\n         */\r\n        addCells(cells: mxCell[]): void;\r\n        /**\r\n         * Removes the specified <mxCell> from the selection and fires a <select>\r\n         * event for the remaining cells.\r\n         *\r\n         * @param cell - <mxCell> to remove from the selection.\r\n         */\r\n        removeCell(cell: mxCell): void;\r\n        /**\r\n         * Function: removeCells\r\n         */\r\n        removeCells(cells: mxCell[]): void;\r\n        /**\r\n         * Inner callback to add the specified <mxCell> to the selection. No event\r\n         * is fired in this implementation.\r\n         */\r\n        changeSelection(added: mxCell[], removed: mxCell[]): void;\r\n        /**\r\n         * Inner callback to add the specified <mxCell> to the selection. No event\r\n         * is fired in this implementation.\r\n         *\r\n         * @param cell - <mxCell> to add to the selection.\r\n         */\r\n        cellAdded(cell: mxCell): void;\r\n        /**\r\n         * Inner callback to remove the specified <mxCell> from the selection. No\r\n         * event is fired in this implementation.\r\n         *\r\n         * @param cell - <mxCell> to remove from the selection.\r\n         */\r\n        cellRemoved(cell: mxCell): void;\r\n    }\r\n    /**\r\n     * Action to change the current root in a view.\r\n     */\r\n    export declare class mxSelectionChange {\r\n        selectionModel: mxGraphSelectionModel;\r\n        added: mxCell[];\r\n        removed: mxCell[];\r\n        /**\r\n         * Constructs a change of the current root in the given view.\r\n         */\r\n        constructor(selectionModel: mxGraphSelectionModel, added: mxCell[], removed: mxCell[]);\r\n        /**\r\n         * Changes the current root of the view.\r\n         */\r\n        execute(): void;\r\n    }\r\n\r\n    /**\r\n     * In-place editor for the graph. To control this editor, use\r\n     * <mxGraph.invokesStopCellEditing>, <mxGraph.enterStopsCellEditing> and\r\n     * <mxGraph.escapeEnabled>. If <mxGraph.enterStopsCellEditing> is true then\r\n     * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\r\n     * escape keys can always be used to stop editing.\r\n     *\r\n     * To customize the location of the textbox in the graph, override\r\n     * <getEditorBounds> as follows:\r\n     *\r\n     * (code)\r\n     * graph.cellEditor.getEditorBounds = function(state)\r\n     * {\r\n     *   var result = mxCellEditor.prototype.getEditorBounds.apply(this, arguments);\r\n     *\r\n     *   if (this.graph.getModel().isEdge(state.cell))\r\n     *   {\r\n     *     result.x = state.getCenterX() - result.width / 2;\r\n     *     result.y = state.getCenterY() - result.height / 2;\r\n     *   }\r\n     *\r\n     *   return result;\r\n     * };\r\n     * (end)\r\n     *\r\n     * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\r\n     * then <mxShape.getLabelBounds> is used to compute the current bounds of the textbox.\r\n     *\r\n     * The textarea uses the mxCellEditor CSS class. You can modify this class in\r\n     * your custom CSS. Note: You should modify the CSS after loading the client\r\n     * in the page.\r\n     *\r\n     * Example:\r\n     *\r\n     * To only allow numeric input in the in-place editor, use the following code.\r\n     *\r\n     * (code)\r\n     * var text = graph.cellEditor.textarea;\r\n     *\r\n     * mxEvent.addListener(text, 'keydown', function (evt)\r\n     * {\r\n     *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\r\n     *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\r\n     *   {\r\n     *     mxEvent.consume(evt);\r\n     *   }\r\n     * });\r\n     * (end)\r\n     *\r\n     * Placeholder:\r\n     *\r\n     * To implement a placeholder for cells without a label, use the\r\n     * <emptyLabelText> variable.\r\n     *\r\n     * Resize in Chrome:\r\n     *\r\n     * Resize of the textarea is disabled by default. If you want to enable\r\n     * this feature extend <init> and set this.textarea.style.resize = ''.\r\n     *\r\n     * To start editing on a key press event, the container of the graph\r\n     * should have focus or a focusable parent should be used to add the\r\n     * key press handler as follows.\r\n     *\r\n     * (code)\r\n     * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, function(evt)\r\n     * {\r\n     *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\r\n     *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\r\n     *   {\r\n     *     graph.startEditing();\r\n     *\r\n     *     if (mxClient.IS_FF)\r\n     *     {\r\n     *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\r\n     *     }\r\n     *   }\r\n     * }));\r\n     * (end)\r\n     *\r\n     * To allow focus for a DIV, and hence to receive key press events, some browsers\r\n     * require it to have a valid tabindex attribute. In this case the following\r\n     * code may be used to keep the container focused.\r\n     *\r\n     * (code)\r\n     * var graphFireMouseEvent = graph.fireMouseEvent;\r\n     * graph.fireMouseEvent = function(evtName, me, sender)\r\n     * {\r\n     *   if (evtName == mxEvent.MOUSE_DOWN)\r\n     *   {\r\n     *     this.container.focus();\r\n     *   }\r\n     *\r\n     *   graphFireMouseEvent.apply(this, arguments);\r\n     * };\r\n     * (end)\r\n     *\r\n     * Constructor: mxCellEditor\r\n     *\r\n     * Constructs a new in-place editor for the specified graph.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     */\r\n    export declare class mxCellEditor {\r\n        graph: mxGraph;\r\n        editingCell: mxCell;\r\n        constructor(graph: any);\r\n        textarea: HTMLElement;\r\n        /**\r\n         * Creates the <textarea> and installs the event listeners. The key handler\r\n         * updates the <modified> state.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Called in <stopEditing> if cancel is false to invoke <mxGraph.labelChanged>.\r\n         */\r\n        applyValue(state: any, value: any): void;\r\n        /**\r\n         * Gets the initial editing value for the given cell.\r\n         */\r\n        getInitialValue(state: any, trigger: any): any;\r\n        /**\r\n         * Returns the current editing value.\r\n         */\r\n        getCurrentValue(state: any): any;\r\n        /**\r\n         * Installs listeners for focus, change and standard key event handling.\r\n         */\r\n        installListeners(elt: any): void;\r\n        /**\r\n         * Returns true if the given keydown event should stop cell editing. This\r\n         * returns true if F2 is pressed of if <mxGraph.enterStopsCellEditing> is true\r\n         * and enter is pressed without control or shift.\r\n         */\r\n        isStopEditingEvent(evt: any): boolean;\r\n        /**\r\n         * Returns true if this editor is the source for the given native event.\r\n         */\r\n        isEventSource(evt: any): boolean;\r\n        /**\r\n         * Returns <modified>.\r\n         */\r\n        resize(): void;\r\n        /**\r\n         * Called if the textarea has lost focus.\r\n         */\r\n        focusLost(): void;\r\n        /**\r\n         * Returns the background color for the in-place editor. This implementation\r\n         * always returns null.\r\n         */\r\n        getBackgroundColor(state: any): any;\r\n        /**\r\n         * Starts the editor for the given cell.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> to start editing.\r\n         * trigger - Optional mouse event that triggered the editor.\r\n         */\r\n        startEditing(cell: any, trigger: any): void;\r\n        /**\r\n         * Returns <selectText>.\r\n         */\r\n        isSelectText(): any;\r\n        /**\r\n         * Stops the editor and applies the value if cancel is false.\r\n         */\r\n        stopEditing(cancel: any): void;\r\n        /**\r\n         * Prepares the textarea for getting its value in <stopEditing>.\r\n         * This implementation removes the extra trailing linefeed in Firefox.\r\n         */\r\n        prepareTextarea(): void;\r\n        /**\r\n         * Returns true if the label should be hidden while the cell is being\r\n         * edited.\r\n         */\r\n        isHideLabel(state: any): boolean;\r\n        /**\r\n         * Returns the minimum width and height for editing the given state.\r\n         */\r\n        getMinimumSize(state: any): mxRectangle;\r\n        /**\r\n         * Returns the <mxRectangle> that defines the bounds of the editor.\r\n         */\r\n        getEditorBounds(state: any): mxRectangle;\r\n        /**\r\n         * Returns the initial label value to be used of the label of the given\r\n         * cell is empty. This label is displayed and cleared on the first keystroke.\r\n         * This implementation returns <emptyLabelText>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> for which a text for an empty editing box should be\r\n         * returned.\r\n         */\r\n        getEmptyLabelText(cell: any): any;\r\n        /**\r\n         * Returns the cell that is currently being edited or null if no cell is\r\n         * being edited.\r\n         */\r\n        getEditingCell(): any;\r\n        /**\r\n         * Destroys the editor and removes all associated resources.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Renders cells into a document object model. The <defaultShapes> is a global\r\n     * map of shapename, constructor pairs that is used in all instances. You can\r\n     * get a list of all available shape names using the following code.\r\n     *\r\n     * In general the cell renderer is in charge of creating, redrawing and\r\n     * destroying the shape and label associated with a cell state, as well as\r\n     * some other graphical objects, namely controls and overlays. The shape\r\n     * hieararchy in the display (ie. the hierarchy in which the DOM nodes\r\n     * appear in the document) does not reflect the cell hierarchy. The shapes\r\n     * are a (flat) sequence of shapes and labels inside the draw pane of the\r\n     * graph view, with some exceptions, namely the HTML labels being placed\r\n     * directly inside the graph container for certain browsers.\r\n     *\r\n     * (code)\r\n     * mxLog.show();\r\n     * for (var i in mxCellRenderer.defaultShapes)\r\n     * {\r\n     *   mxLog.debug(i);\r\n     * }\r\n     * (end)\r\n     *\r\n     * Constructor: mxCellRenderer\r\n     *\r\n     * Constructs a new cell renderer with the following built-in shapes:\r\n     * arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,\r\n     * swimlane, connector, actor and cloud.\r\n     */\r\n    export declare class mxCellRenderer {\r\n        antiAlias: boolean;\r\n        /**\r\n         * Registers the given constructor under the specified key in this instance\r\n         * of the renderer.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * key - String representing the shape name.\r\n         * shape - Constructor of the <mxShape> subclass.\r\n         */\r\n        static registerShape(key: any, shape: any): void;\r\n        /**\r\n         * Initializes the shape in the given state by calling its init method with\r\n         * the correct container after configuring it using <configureShape>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the shape should be initialized.\r\n         */\r\n        initializeShape(state: any): void;\r\n        /**\r\n         * Creates and returns the shape for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the shape should be created.\r\n         */\r\n        createShape(state: any): any;\r\n        /**\r\n         * Creates the indicator shape for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the indicator shape should be created.\r\n         */\r\n        createIndicatorShape(state: any): void;\r\n        /**\r\n         * Returns the shape for the given name from <defaultShapes>.\r\n         */\r\n        getShape(name: any): any;\r\n        /**\r\n         * Returns the constructor to be used for creating the shape.\r\n         */\r\n        getShapeConstructor(state: any): any;\r\n        /**\r\n         * Configures the shape for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the shape should be configured.\r\n         */\r\n        configureShape(state: any): void;\r\n        /**\r\n         * Replaces any reserved words used for attributes, eg. inherit,\r\n         * indicated or swimlane for colors in the shape for the given state.\r\n         * This implementation resolves these keywords on the fill, stroke\r\n         * and gradient color keys.\r\n         */\r\n        postConfigureShape(state: any): void;\r\n        /**\r\n         * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\r\n         * the respective color on the shape.\r\n         */\r\n        checkPlaceholderStyles(state: any): boolean;\r\n        /**\r\n         * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\r\n         * the respective color on the shape.\r\n         */\r\n        resolveColor(state: any, field: any, key: any): void;\r\n        /**\r\n         * Returns the value to be used for the label.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the label should be created.\r\n         */\r\n        getLabelValue(state: any): any;\r\n        /**\r\n         * Creates the label for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the label should be created.\r\n         */\r\n        createLabel(state: any, value: any): void;\r\n        /**\r\n         * Initiailzes the label with a suitable container.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label should be initialized.\r\n         */\r\n        initializeLabel(state: any, shape: any): void;\r\n        /**\r\n         * Creates the actual shape for showing the overlay for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the overlay should be created.\r\n         */\r\n        createCellOverlays(state: any): void;\r\n        /**\r\n         * Initializes the given overlay.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the overlay should be created.\r\n         * overlay - <mxImageShape> that represents the overlay.\r\n         */\r\n        initializeOverlay(state: any, overlay: any): void;\r\n        /**\r\n         * Installs the listeners for the given <mxCellState>, <mxCellOverlay> and\r\n         * <mxShape> that represents the overlay.\r\n         */\r\n        installCellOverlayListeners(state: any, overlay: any, shape: any): void;\r\n        /**\r\n         * Creates the control for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the control should be created.\r\n         */\r\n        createControl(state: any): void;\r\n        /**\r\n         * Hook for creating the click handler for the folding icon.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose control click handler should be returned.\r\n         */\r\n        createControlClickHandler(state: any): any;\r\n        /**\r\n         * Initializes the given control and returns the corresponding DOM node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the control should be initialized.\r\n         * control - <mxShape> to be initialized.\r\n         * handleEvents - Boolean indicating if mousedown and mousemove should fire events via the graph.\r\n         * clickHandler - Optional function to implement clicks on the control.\r\n         */\r\n        initControl(state: any, control: any, handleEvents: any, clickHandler: any): any;\r\n        /**\r\n         * Returns true if the event is for the shape of the given state. This\r\n         * implementation always returns true.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose shape fired the event.\r\n         * evt - Mouse event which was fired.\r\n         */\r\n        isShapeEvent(state: any, evt: any): boolean;\r\n        /**\r\n         * Returns true if the event is for the label of the given state. This\r\n         * implementation always returns true.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label fired the event.\r\n         * evt - Mouse event which was fired.\r\n         */\r\n        isLabelEvent(state: any, evt: any): boolean;\r\n        /**\r\n         * Installs the event listeners for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the event listeners should be isntalled.\r\n         */\r\n        installListeners(state: any): void;\r\n        /**\r\n         * Redraws the label for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label should be redrawn.\r\n         */\r\n        redrawLabel(state: any, forced: any): void;\r\n        /**\r\n         * Returns true if the style for the text shape has changed.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label should be checked.\r\n         * shape - <mxText> shape to be checked.\r\n         */\r\n        isTextShapeInvalid(state: any, shape: any): any;\r\n        /**\r\n         * Called to invoked redraw on the given text shape.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * shape - <mxText> shape to be redrawn.\r\n         */\r\n        redrawLabelShape(shape: any): void;\r\n        /**\r\n         * Returns the scaling used for the label of the given state\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label scale should be returned.\r\n         */\r\n        getTextScale(state: any): any;\r\n        /**\r\n         * Returns the bounds to be used to draw the label of the given state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label bounds should be returned.\r\n         */\r\n        getLabelBounds(state: any): mxRectangle;\r\n        /**\r\n         * Adds the shape rotation to the given label bounds and\r\n         * applies the alignment and offsets.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label bounds should be rotated.\r\n         * bounds - <mxRectangle> the rectangle to be rotated.\r\n         */\r\n        rotateLabelBounds(state: any, bounds: any): void;\r\n        /**\r\n         * Redraws the overlays for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose overlays should be redrawn.\r\n         */\r\n        redrawCellOverlays(state: any, forced: any): void;\r\n        /**\r\n         * Redraws the control for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose control should be redrawn.\r\n         */\r\n        redrawControl(state: any, forced: any): void;\r\n        /**\r\n         * Returns the bounds to be used to draw the control (folding icon) of the\r\n         * given state.\r\n         */\r\n        getControlBounds(state: any, w: any, h: any): mxRectangle;\r\n        /**\r\n         * Inserts the given array of <mxShapes> after the given nodes in the DOM.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * shapes - Array of <mxShapes> to be inserted.\r\n         * node - Node in <drawPane> after which the shapes should be inserted.\r\n         * htmlNode - Node in the graph container after which the shapes should be inserted that\r\n         * will not go into the <drawPane> (eg. HTML labels without foreignObjects).\r\n         */\r\n        insertStateAfter(state: any, node: any, htmlNode: any): any[];\r\n        /**\r\n         * Returns the <mxShapes> for the given cell state in the order in which they should\r\n         * appear in the DOM.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose shapes should be returned.\r\n         */\r\n        getShapesForState(state: any): any[];\r\n        /**\r\n         * Updates the bounds or points and scale of the shapes for the given cell\r\n         * state. This is called in mxGraphView.validatePoints as the last step of\r\n         * updating all cells.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the shapes should be updated.\r\n         * force - Optional boolean that specifies if the cell should be reconfiured\r\n         * and redrawn without any additional checks.\r\n         * rendering - Optional boolean that specifies if the cell should actually\r\n         * be drawn into the DOM. If this is false then redraw and/or reconfigure\r\n         * will not be called on the shape.\r\n         */\r\n        redraw(state: mxCellState, force?: any, rendering?: any): void;\r\n        /**\r\n         * Redraws the shape for the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose label should be redrawn.\r\n         */\r\n        redrawShape(state: any, force: any, rendering: any): boolean;\r\n        /**\r\n         * Invokes redraw on the shape of the given state.\r\n         */\r\n        doRedrawShape(state: any): void;\r\n        /**\r\n         * Returns true if the given shape must be repainted.\r\n         */\r\n        isShapeInvalid(state: any, shape: any): boolean;\r\n        /**\r\n         * Destroys the shapes associated with the given cell state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> for which the shapes should be destroyed.\r\n         */\r\n        destroy(state: any): void;\r\n    }\r\n\r\n\r\n    export declare var mxEdgeStyle: {\r\n        EntityRelation(state: any, source: any, target: any, points: any, result: any): void;\r\n        Loop(state: any, source: any, target: any, points: any, result: any): void;\r\n        ElbowConnector(state: any, source: any, target: any, points: any, result: any): void;\r\n        SideToSide(state: any, source: any, target: any, points: any, result: any): void;\r\n        TopToBottom(state: any, source: any, target: any, points: any, result: any): void;\r\n        SegmentConnector(state: any, source: any, target: any, hints: any, result: any): void;\r\n        orthBuffer: number;\r\n        orthPointsFallback: boolean;\r\n        dirVectors: number[][];\r\n        wayPoints1: number[][];\r\n        routePatterns: number[][][];\r\n        inlineRoutePatterns: number[][][];\r\n        vertexSeperations: any[];\r\n        limits: number[][];\r\n        LEFT_MASK: number;\r\n        TOP_MASK: number;\r\n        RIGHT_MASK: number;\r\n        BOTTOM_MASK: number;\r\n        LEFT: number;\r\n        TOP: number;\r\n        RIGHT: number;\r\n        BOTTOM: number;\r\n        SIDE_MASK: number;\r\n        CENTER_MASK: number;\r\n        SOURCE_MASK: number;\r\n        TARGET_MASK: number;\r\n        VERTEX_MASK: number;\r\n        getJettySize(state: any, source: any, target: any, points: any, isSource: any): any;\r\n        OrthConnector(state: any, source: any, target: any, points: any, result: any): void;\r\n        getRoutePattern(dir: any, quad: any, dx: any, dy: any): any;\r\n    };\r\n\r\n\r\n    export declare var mxStyleRegistry: {\r\n        values: any[];\r\n        dynamicLoading?: any;\r\n        putValue(name: any, obj: any): void;\r\n        getValue(name: any): any;\r\n        getName(value: any): string;\r\n    };\r\n\r\n    /**\r\n     * Extends <mxEventSource> to implement a view for a graph. This class is in\r\n     * charge of computing the absolute coordinates for the relative child\r\n     * geometries, the points for perimeters and edge styles and keeping them\r\n     * cached in <mxCellStates> for faster retrieval. The states are updated\r\n     * whenever the model or the view state (translate, scale) changes. The scale\r\n     * and translate are honoured in the bounds.\r\n     *\r\n     * Event: mxEvent.UNDO\r\n     *\r\n     * Fires after the root was changed in <setCurrentRoot>. The <code>edit</code>\r\n     * property contains the <mxUndoableEdit> which contains the\r\n     * <mxCurrentRootChange>.\r\n     *\r\n     * Event: mxEvent.SCALE_AND_TRANSLATE\r\n     *\r\n     * Fires after the scale and translate have been changed in <scaleAndTranslate>.\r\n     * The <code>scale</code>, <code>previousScale</code>, <code>translate</code>\r\n     * and <code>previousTranslate</code> properties contain the new and previous\r\n     * scale and translate, respectively.\r\n     *\r\n     * Event: mxEvent.SCALE\r\n     *\r\n     * Fires after the scale was changed in <setScale>. The <code>scale</code> and\r\n     * <code>previousScale</code> properties contain the new and previous scale.\r\n     *\r\n     * Event: mxEvent.TRANSLATE\r\n     *\r\n     * Fires after the translate was changed in <setTranslate>. The\r\n     * <code>translate</code> and <code>previousTranslate</code> properties contain\r\n     * the new and previous value for translate.\r\n     *\r\n     * Event: mxEvent.DOWN and mxEvent.UP\r\n     *\r\n     * Fire if the current root is changed by executing an <mxCurrentRootChange>.\r\n     * The event name depends on the location of the root in the cell hierarchy\r\n     * with respect to the current root. The <code>root</code> and\r\n     * <code>previous</code> properties contain the new and previous root,\r\n     * respectively.\r\n     */\r\n    export declare class mxGraphView extends mxEventSource {\r\n        backgroundPageShape: mxRectangleShape;\r\n        /**\r\n         *\r\n         */\r\n        EMPTY_POINT: mxPoint;\r\n        /**\r\n         * Specifies the resource key for the status message after a long operation.\r\n         * If the resource for this key does not exist then the value is used as\r\n         * the status message. Default is 'done'.\r\n         */\r\n        doneResource: string;\r\n        /**\r\n         * Specifies the resource key for the status message while the document is\r\n         * being updated. If the resource for this key does not exist then the\r\n         * value is used as the status message. Default is 'updatingDocument'.\r\n         */\r\n        updatingDocumentResource: string;\r\n        /**\r\n         * Specifies if string values in cell styles should be evaluated using\r\n         * <mxUtils.eval>. This will only be used if the string values can't be mapped\r\n         * to objects using <mxStyleRegistry>. Default is false. NOTE: Enabling this\r\n         * switch carries a possible security risk.\r\n         */\r\n        allowEval: boolean;\r\n        /**\r\n         * Specifies if a gesture should be captured when it goes outside of the\r\n         * graph container. Default is true.\r\n         */\r\n        captureDocumentGesture: boolean;\r\n        /**\r\n         * Specifies if the <canvas> should be hidden while rendering in IE8 standards\r\n         * mode and quirks mode. This will significantly improve rendering performance.\r\n         * Default is true.\r\n         */\r\n        optimizeVmlReflows: boolean;\r\n        /**\r\n         * Specifies if shapes should be created, updated and destroyed using the\r\n         * methods of <mxCellRenderer> in <graph>. Default is true.\r\n         */\r\n        rendering: boolean;\r\n        /**\r\n         * Reference to the enclosing <mxGraph>.\r\n         */\r\n        graph: mxGraph;\r\n        /**\r\n         * <mxCell> that acts as the root of the displayed cell hierarchy.\r\n         */\r\n        currentRoot: mxCell;\r\n        /**\r\n         * <mxRectangle> that caches the scales, translated bounds of the current view.\r\n         */\r\n        graphBounds: mxRectangle;\r\n        /**\r\n         * Specifies the scale. Default is 1 (100%).\r\n         */\r\n        scale: number;\r\n        /**\r\n         * <mxPoint> that specifies the current translation. Default is a new\r\n         * empty <mxPoint>.\r\n         */\r\n        translate: mxPoint;\r\n        /**\r\n         * <mxDictionary> that maps from cell IDs to <mxCellStates>.\r\n         */\r\n        states: mxDictionary;\r\n        /**\r\n         * Specifies if the style should be updated in each validation step. If this\r\n         * is false then the style is only updated if the state is created or if the\r\n         * style of the cell was changed. Default is false.\r\n         */\r\n        updateStyle: boolean;\r\n        /**\r\n         * During validation, this contains the last DOM node that was processed.\r\n         */\r\n        lastNode: HTMLElement;\r\n        /**\r\n         * During validation, this contains the last HTML DOM node that was processed.\r\n         */\r\n        lastHtmlNode: HTMLElement;\r\n        /**\r\n         * During validation, this contains the last edge's DOM node that was processed.\r\n         */\r\n        lastForegroundNode: HTMLElement;\r\n        /**\r\n         * During validation, this contains the last edge HTML DOM node that was processed.\r\n         */\r\n        lastForegroundHtmlNode: HTMLElement;\r\n        /**\r\n         * Implicit variable definitions\r\n         */\r\n        canvas: SVGGElement;\r\n        placeholder: HTMLElement;\r\n        textDiv: HTMLElement;\r\n        backgroundPane: HTMLElement;\r\n        drawPane: SVGElement;\r\n        overlayPane: HTMLElement;\r\n        decoratorPane: HTMLElement;\r\n        /**\r\n         * Constructs a new view for the given <mxGraph>.\r\n         *\r\n         * @param graph - Reference to the enclosing <mxGraph>.\r\n         */\r\n        constructor(graph: mxGraph);\r\n        /**\r\n         * Returns <graphBounds>.\r\n         */\r\n        getGraphBounds(): mxRectangle;\r\n        /**\r\n         * Sets <graphBounds>.\r\n         */\r\n        setGraphBounds(value: mxRectangle): void;\r\n        /**\r\n         * Returns the union of all <mxCellStates> for the given array of <mxCells>.\r\n         *\r\n         * @param cells - Array of <mxCells> whose bounds should be returned.\r\n         */\r\n        getBounds(cells: mxCell[]): mxRectangle;\r\n        /**\r\n         * Sets and returns the current root and fires an <undo> event before\r\n         * calling <mxGraph.sizeDidChange>.\r\n         *\r\n         * @param root - <mxCell> that specifies the root of the displayed cell hierarchy.\r\n         */\r\n        setCurrentRoot(root: any): any;\r\n        /**\r\n         * Sets the scale and translation and fires a <scale> and <translate> event\r\n         * before calling <revalidate> followed by <mxGraph.sizeDidChange>.\r\n         *\r\n         * @param scale - Decimal value that specifies the new scale (1 is 100%).\r\n         * @param dx - X-coordinate of the translation.\r\n         * @param dy - Y-coordinate of the translation.\r\n         */\r\n        scaleAndTranslate(scale: any, dx: any, dy: any): void;\r\n        /**\r\n         * Returns the <scale>.\r\n         */\r\n        getScale(): number;\r\n        /**\r\n         * Sets the scale and fires a <scale> event before calling <revalidate> followed\r\n         * by <mxGraph.sizeDidChange>.\r\n         *\r\n         * @param value - Decimal value that specifies the new scale (1 is 100%).\r\n         */\r\n        setScale(value: any): void;\r\n        /**\r\n         * Returns the <translate>.\r\n         */\r\n        getTranslate(): mxPoint;\r\n        /**\r\n         * Sets the translation and fires a <translate> event before calling\r\n         * <revalidate> followed by <mxGraph.sizeDidChange>. The translation is the\r\n         * negative of the origin.\r\n         *\r\n         * @param dx - X-coordinate of the translation.\r\n         * @param dy - Y-coordinate of the translation.\r\n         */\r\n        setTranslate(dx: number, dy: number): void;\r\n        /**\r\n         * Clears the view if <currentRoot> is not null and revalidates.\r\n         */\r\n        refresh(): void;\r\n        /**\r\n         * Revalidates the complete view with all cell states.\r\n         */\r\n        revalidate(): void;\r\n        /**\r\n         * Removes the state of the given cell and all descendants if the given\r\n         * cell is not the current root.\r\n         *\r\n         * @param cell - Optional <mxCell> for which the state should be removed. Default\r\n         * is the root of the model.\r\n         * @param force - Boolean indicating if the current root should be ignored for\r\n         * recursion.\r\n         */\r\n        clear(cell?: mxCell, force?: boolean, recurse?: boolean): void;\r\n        /**\r\n         * Invalidates the state of the given cell, all its descendants and\r\n         * connected edges.\r\n         *\r\n         * @param cell - Optional <mxCell> to be invalidated. Default is the root of the\r\n         * model.\r\n         */\r\n        invalidate(cell?: mxCell, recurse?: boolean, includeEdges?: boolean): void;\r\n        /**\r\n         * Calls <validateCell> and <validateCellState> and updates the <graphBounds>\r\n         * using <getBoundingBox>. Finally the background is validated using\r\n         * <validateBackground>.\r\n         *\r\n         * @param cell - Optional <mxCell> to be used as the root of the validation.\r\n         * Default is <currentRoot> or the root of the model.\r\n         */\r\n        validate(cell?: mxCell): void;\r\n        /**\r\n         * Returns the bounds for an empty graph. This returns a rectangle at\r\n         * <translate> with the size of 0 x 0.\r\n         */\r\n        getEmptyBounds(): mxRectangle;\r\n        /**\r\n         * Returns the bounding box of the shape and the label for the given\r\n         * <mxCellState> and its children if recurse is true.\r\n         *\r\n         * @param state - <mxCellState> whose bounding box should be returned.\r\n         * @param recurse - Optional boolean indicating if the children should be included.\r\n         * Default is true.\r\n         */\r\n        getBoundingBox(state: mxCellState, recurse?: boolean): mxRectangle;\r\n        /**\r\n         * Creates and returns the shape used as the background page.\r\n         *\r\n         * bounds - <mxRectangle> that represents the bounds of the shape.\r\n         */\r\n        createBackgroundPageShape(bounds: any): mxRectangleShape;\r\n        /**\r\n         * Calls <validateBackgroundImage> and <validateBackgroundPage>.\r\n         */\r\n        validateBackground(): void;\r\n        /**\r\n         * Validates the background image.\r\n         */\r\n        validateBackgroundImage(): void;\r\n        /**\r\n         * Validates the background page.\r\n         */\r\n        validateBackgroundPage(): void;\r\n        /**\r\n         * Returns the bounds for the background page.\r\n         */\r\n        getBackgroundPageBounds(): mxRectangle;\r\n        /**\r\n         * Updates the bounds and redraws the background image.\r\n         *\r\n         * Example:\r\n         *\r\n         * If the background image should not be scaled, this can be replaced with\r\n         * the following.\r\n         *\r\n         * (code)\r\n         * mxGraphView.prototype.redrawBackground = function(backgroundImage, bg)\r\n         * {\r\n         *   backgroundImage.bounds.x = this.translate.x;\r\n         *   backgroundImage.bounds.y = this.translate.y;\r\n         *   backgroundImage.bounds.width = bg.width;\r\n         *   backgroundImage.bounds.height = bg.height;\r\n         *\r\n         *   backgroundImage.redraw();\r\n         * };\r\n         * (end)\r\n         *\r\n         * @param backgroundImage - <mxImageShape> that represents the background image.\r\n         * @param bg - <mxImage> that specifies the image and its dimensions.\r\n         */\r\n        redrawBackgroundImage(backgroundImage: any, bg: any): void;\r\n        /**\r\n         * Recursively creates the cell state for the given cell if visible is true and\r\n         * the given cell is visible. If the cell is not visible but the state exists\r\n         * then it is removed using <removeState>.\r\n         *\r\n         * @param cell - <mxCell> whose <mxCellState> should be created.\r\n         * @param visible - Optional boolean indicating if the cell should be visible. Default\r\n         * is true.\r\n         */\r\n        validateCell(cell: mxCell, visible?: boolean): mxCell;\r\n        /**\r\n         * Validates and repaints the <mxCellState> for the given <mxCell>.\r\n         *\r\n         * @param cell - <mxCell> whose <mxCellState> should be validated.\r\n         * @param recurse - Optional boolean indicating if the children of the cell should be\r\n         * validated. Default is true.\r\n         */\r\n        validateCellState(cell: mxCell, recurse?: boolean): mxCellState;\r\n        /**\r\n         * Updates the given <mxCellState>.\r\n         *\r\n         * @param state - <mxCellState> to be updated.\r\n         */\r\n        updateCellState(state: mxCellState): void;\r\n        /**\r\n         * Returns true if the children of the given cell should not be visible in the\r\n         * view. This implementation uses <mxGraph.isCellVisible> but it can be\r\n         * overidden to use a separate condition.\r\n         *\r\n         * @param cell\r\n         */\r\n        isCellCollapsed(cell: any): boolean;\r\n        /**\r\n         * Validates the given cell state.\r\n         *\r\n         * @param state\r\n         * @param geo\r\n         */\r\n        updateVertexState(state: any, geo: any): void;\r\n        /**\r\n         * Validates the given cell state.\r\n         *\r\n         * @param state\r\n         * @param geo\r\n         */\r\n        updateEdgeState(state: any, geo: any): void;\r\n        /**\r\n         * Updates the absoluteOffset of the given vertex cell state. This takes\r\n         * into account the label position styles.\r\n         *\r\n         * @param state - <mxCellState> whose absolute offset should be updated.\r\n         */\r\n        updateVertexLabelOffset(state: any): void;\r\n        /**\r\n         * Resets the current validation state.\r\n         */\r\n        resetValidationState(): void;\r\n        /**\r\n         * Invoked when a state has been processed in <validatePoints>. This is used\r\n         * to update the order of the DOM nodes of the shape.\r\n         *\r\n         * @param state - <mxCellState> that represents the cell state.\r\n         */\r\n        stateValidated(state: any): void;\r\n        /**\r\n         * Sets the initial absolute terminal points in the given state before the edge\r\n         * style is computed.\r\n         *\r\n         * @param edge - <mxCellState> whose initial terminal points should be updated.\r\n         * @param source - <mxCellState> which represents the source terminal.\r\n         * @param target - <mxCellState> which represents the target terminal.\r\n         */\r\n        updateFixedTerminalPoints(edge: any, source: any, target: any): void;\r\n        /**\r\n         * Sets the fixed source or target terminal point on the given edge.\r\n         *\r\n         * @param edge - <mxCellState> whose terminal point should be updated.\r\n         * @param terminal - <mxCellState> which represents the actual terminal.\r\n         * @param source - Boolean that specifies if the terminal is the source.\r\n         * @param constraint - <mxConnectionConstraint> that specifies the connection.\r\n         */\r\n        updateFixedTerminalPoint(edge: any, terminal: any, source: any, constraint: any): void;\r\n        /**\r\n         * Returns the fixed source or target terminal point for the given edge.\r\n         *\r\n         * @param edge - <mxCellState> whose terminal point should be returned.\r\n         * @param terminal - <mxCellState> which represents the actual terminal.\r\n         * @param source - Boolean that specifies if the terminal is the source.\r\n         * @param constraint - <mxConnectionConstraint> that specifies the connection.\r\n         */\r\n        getFixedTerminalPoint(edge: any, terminal: any, source: any, constraint: any): any;\r\n        /**\r\n         * Updates the bounds of the given cell state to reflect the bounds of the stencil\r\n         * if it has a fixed aspect and returns the previous bounds as an <mxRectangle> if\r\n         * the bounds have been modified or null otherwise.\r\n         *\r\n         * @param edge - <mxCellState> whose bounds should be updated.\r\n         */\r\n        updateBoundsFromStencil(state: any): any;\r\n        /**\r\n         * Updates the absolute points in the given state using the specified array\r\n         * of <mxPoints> as the relative points.\r\n         *\r\n         * @param edge - <mxCellState> whose absolute points should be updated.\r\n         * @param points - Array of <mxPoints> that constitute the relative points.\r\n         * @param source - <mxCellState> that represents the source terminal.\r\n         * @param target - <mxCellState> that represents the target terminal.\r\n         */\r\n        updatePoints(edge: any, points: any, source: any, target: any): void;\r\n        /**\r\n         * Transforms the given control point to an absolute point.\r\n         *\r\n         * @param state\r\n         * @param pt\r\n         */\r\n        transformControlPoint(state: any, pt: any): mxPoint;\r\n        /**\r\n         * Returns true if the given edge should be routed with <mxGraph.defaultLoopStyle>\r\n         * or the <mxConstants.STYLE_LOOP> defined for the given edge. This implementation\r\n         * returns true if the given edge is a loop and does not\r\n         *\r\n         * @param edge\r\n         * @param points\r\n         * @param source\r\n         * @param target\r\n         */\r\n        isLoopStyleEnabled(edge: mxCellState, points: any, source: any, target: any): boolean;\r\n        /**\r\n         * Returns the edge style function to be used to render the given edge state.\r\n         *\r\n         * @param edge\r\n         * @param points\r\n         * @param source\r\n         * @param target\r\n         */\r\n        getEdgeStyle(edge: any, points?: any, source?: any, target?: any): any;\r\n        /**\r\n         * Updates the terminal points in the given state after the edge style was\r\n         * computed for the edge.\r\n         *\r\n         * @param state - <mxCellState> whose terminal points should be updated.\r\n         * @param source - <mxCellState> that represents the source terminal.\r\n         * @param target - <mxCellState> that represents the target terminal.\r\n         */\r\n        updateFloatingTerminalPoints(state: any, source: any, target: any): void;\r\n        /**\r\n         * Updates the absolute terminal point in the given state for the given\r\n         * start and end state, where start is the source if source is true.\r\n         *\r\n         * @param edge - <mxCellState> whose terminal point should be updated.\r\n         * @param start - <mxCellState> for the terminal on \"this\" side of the edge.\r\n         * @param end - <mxCellState> for the terminal on the other side of the edge.\r\n         * @param source - Boolean indicating if start is the source terminal state.\r\n         */\r\n        updateFloatingTerminalPoint(edge: any, start: any, end: any, source: any): void;\r\n        /**\r\n         * Returns the floating terminal point for the given edge, start and end\r\n         * state, where start is the source if source is true.\r\n         *\r\n         * @param edge - <mxCellState> whose terminal point should be returned.\r\n         * @param start - <mxCellState> for the terminal on \"this\" side of the edge.\r\n         * @param end - <mxCellState> for the terminal on the other side of the edge.\r\n         * @param source - Boolean indicating if start is the source terminal state.\r\n         */\r\n        getFloatingTerminalPoint(edge: any, start: any, end: any, source: any): mxPoint;\r\n        /**\r\n         * Returns an <mxCellState> that represents the source or target terminal or\r\n         * port for the given edge.\r\n         *\r\n         * @param state - <mxCellState> that represents the state of the edge.\r\n         * @param terminal - <mxCellState> that represents the terminal.\r\n         * @param source - Boolean indicating if the given terminal is the source terminal.\r\n         */\r\n        getTerminalPort(state: any, terminal: any, source: any): any;\r\n        /**\r\n         * Returns an <mxPoint> that defines the location of the intersection point between\r\n         * the perimeter and the line between the center of the shape and the given point.\r\n         *\r\n         * @param terminal - <mxCellState> for the source or target terminal.\r\n         * @param next - <mxPoint> that lies outside of the given terminal.\r\n         * @param orthogonal - Boolean that specifies if the orthogonal projection onto\r\n         * the perimeter should be returned. If this is false then the intersection\r\n         * of the perimeter and the line between the next and the center point is\r\n         * returned.\r\n         * @param border - Optional border between the perimeter and the shape.\r\n         */\r\n        getPerimeterPoint(terminal: mxCellState, next: mxPoint, orthogonal: boolean, border?: number): mxPoint;\r\n        /**\r\n         * Returns the x-coordinate of the center point for automatic routing.\r\n         */\r\n        getRoutingCenterX(state: any): any;\r\n        /**\r\n         * Returns the y-coordinate of the center point for automatic routing.\r\n         */\r\n        getRoutingCenterY(state: any): any;\r\n        /**\r\n         * Returns the perimeter bounds for the given terminal, edge pair as an\r\n         * <mxRectangle>.\r\n         *\r\n         * If you have a model where each terminal has a relative child that should\r\n         * act as the graphical endpoint for a connection from/to the terminal, then\r\n         * this method can be replaced as follows:\r\n         *\r\n         * (code)\r\n         * var oldGetPerimeterBounds = mxGraphView.prototype.getPerimeterBounds;\r\n         * mxGraphView.prototype.getPerimeterBounds = function(terminal, edge, isSource)\r\n         * {\r\n         *   var model = this.graph.getModel();\r\n         *   var childCount = model.getChildCount(terminal.cell);\r\n         *\r\n         *   if (childCount > 0)\r\n         *   {\r\n         *     var child = model.getChildAt(terminal.cell, 0);\r\n         *     var geo = model.getGeometry(child);\r\n         *\r\n         *     if (geo != null &&\r\n         *         geo.relative)\r\n         *     {\r\n         *       var state = this.getState(child);\r\n         *\r\n         *       if (state != null)\r\n         *       {\r\n         *         terminal = state;\r\n         *       }\r\n         *     }\r\n         *   }\r\n         *\r\n         *   return oldGetPerimeterBounds.apply(this, arguments);\r\n         * };\r\n         * (end)\r\n         *\r\n         * @param terminal - <mxCellState> that represents the terminal.\r\n         * @param border - Number that adds a border between the shape and the perimeter.\r\n         */\r\n        getPerimeterBounds(terminal: mxCellState, border?: number): mxRectangle;\r\n        /**\r\n         * Returns the perimeter function for the given state.\r\n         *\r\n         * @param state\r\n         */\r\n        getPerimeterFunction(state: mxCellState): any;\r\n        /**\r\n         * Returns the nearest point in the list of absolute points or the center\r\n         * of the opposite terminal.\r\n         *\r\n         * @param edge - <mxCellState> that represents the edge.\r\n         * @param opposite - <mxCellState> that represents the opposite terminal.\r\n         * @param source - Boolean indicating if the next point for the source or target\r\n         * @param should be returned.\r\n         */\r\n        getNextPoint(edge: any, opposite: any, source: any): any;\r\n        /**\r\n         * Returns the nearest ancestor terminal that is visible. The edge appears\r\n         * to be connected to this terminal on the display. The result of this method\r\n         * is cached in <mxCellState.getVisibleTerminalState>.\r\n         *\r\n         * @param edge - <mxCell> whose visible terminal should be returned.\r\n         * @param source - Boolean that specifies if the source or target terminal\r\n         * should be returned.\r\n         */\r\n        getVisibleTerminal(edge: any, source: any): mxCell;\r\n        /**\r\n         * Updates the given state using the bounding box of t\r\n         * he absolute points.\r\n         * Also updates <mxCellState.terminalDistance>, <mxCellState.length> and\r\n         * <mxCellState.segments>.\r\n         *\r\n         * @param state - <mxCellState> whose bounds should be updated.\r\n         */\r\n        updateEdgeBounds(state: any): void;\r\n        /**\r\n         * Returns the absolute point on the edge for the given relative\r\n         * <mxGeometry> as an <mxPoint>. The edge is represented by the given\r\n         * <mxCellState>.\r\n         *\r\n         * @param state - <mxCellState> that represents the state of the parent edge.\r\n         * @param geometry - <mxGeometry> that represents the relative location.\r\n         */\r\n        getPoint(state: any, geometry?: any): mxPoint;\r\n        /**\r\n         * Gets the relative point that describes the given, absolute label\r\n         * position for the given edge state.\r\n         *\r\n         * @param state - <mxCellState> that represents the state of the parent edge.\r\n         * @param x - Specifies the x-coordinate of the absolute label location.\r\n         * @param y - Specifies the y-coordinate of the absolute label location.\r\n         */\r\n        getRelativePoint(edgeState: any, x: any, y: any): mxPoint;\r\n        /**\r\n         * Updates <mxCellState.absoluteOffset> for the given state. The absolute\r\n         * offset is normally used for the position of the edge label. Is is\r\n         * calculated from the geometry as an absolute offset from the center\r\n         * between the two endpoints if the geometry is absolute, or as the\r\n         * relative distance between the center along the line and the absolute\r\n         * orthogonal distance if the geometry is relative.\r\n         *\r\n         * @param state - <mxCellState> whose absolute offset should be updated.\r\n         */\r\n        updateEdgeLabelOffset(state: any): void;\r\n        /**\r\n         * Returns the <mxCellState> for the given cell. If create is true, then\r\n         * the state is created if it does not yet exist.\r\n         *\r\n         * @param cell - <mxCell> for which the <mxCellState> should be returned.\r\n         * @param create - Optional boolean indicating if a new state should be created\r\n         * @param if it does not yet exist. Default is false.\r\n         */\r\n        getState(cell: mxCell, create?: boolean): mxCellState;\r\n        /**\r\n         * Returns <rendering>.\r\n         */\r\n        isRendering(): boolean;\r\n        /**\r\n         * Sets <rendering>.\r\n         *\r\n         * @param value\r\n         */\r\n        setRendering(value: boolean): void;\r\n        /**\r\n         * Returns <allowEval>.\r\n         */\r\n        isAllowEval(): boolean;\r\n        /**\r\n         * Sets <allowEval>.\r\n         *\r\n         * @param value\r\n         */\r\n        setAllowEval(value: boolean): void;\r\n        /**\r\n         * Returns <mxCellState>.\r\n         */\r\n        getState(cell: mxCell): mxCellState;\r\n        /**\r\n         * Returns <states>.\r\n         */\r\n        getStates(): mxDictionary;\r\n        /**\r\n         * Sets <states>.\r\n         *\r\n         * @param value\r\n         */\r\n        setStates(value: mxDictionary): void;\r\n        /**\r\n         * Returns the <mxCellStates> for the given array of <mxCells>. The array\r\n         * contains all states that are not null, that is, the returned array may\r\n         * have less elements than the given array. If no argument is given, then\r\n         * this returns <states>.\r\n         *\r\n         * @param cells\r\n         */\r\n        getCellStates(cells: mxCell[]): any[] | mxDictionary;\r\n        /**\r\n         * Removes and returns the <mxCellState> for the given cell.\r\n         *\r\n         * @param cell - <mxCell> for which the <mxCellState> should be removed.\r\n         */\r\n        removeState(cell: any): any;\r\n        /**\r\n         * Creates and returns an <mxCellState> for the given cell and initializes\r\n         * it using <mxCellRenderer.initialize>.\r\n         *\r\n         * @param cell - <mxCell> for which a new <mxCellState> should be created.\r\n         */\r\n        createState(cell: any): mxCellState;\r\n        /**\r\n         * Returns the DOM node that contains the background-, draw- and\r\n         * overlay- and decoratorpanes.\r\n         */\r\n        getCanvas(): Element;\r\n        /**\r\n         * Returns the DOM node that represents the background layer.\r\n         */\r\n        getBackgroundPane(): HTMLElement;\r\n        /**\r\n         * Returns the DOM node that represents the main drawing layer.\r\n         */\r\n        getDrawPane(): SVGElement;\r\n        /**\r\n         * Returns the DOM node that represents the layer above the drawing layer.\r\n         */\r\n        getOverlayPane(): HTMLElement;\r\n        /**\r\n         * Returns the DOM node that represents the topmost drawing layer.\r\n         */\r\n        getDecoratorPane(): HTMLElement;\r\n        /**\r\n         * Returns true if the event origin is one of the drawing panes or\r\n         * containers of the view.\r\n         */\r\n        isContainerEvent(evt: any): boolean;\r\n        /**\r\n         * Returns true if the event origin is one of the scrollbars of the\r\n         * container in IE. Such events are ignored.\r\n         */\r\n        isScrollEvent(evt: any): boolean;\r\n        /**\r\n         * Initializes the graph event dispatch loop for the specified container\r\n         * and invokes <create> to create the required DOM nodes for the display.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Installs the required listeners in the container.\r\n         */\r\n        installListeners(): void;\r\n        /**\r\n         * Creates the DOM nodes for the HTML display.\r\n         */\r\n        createHtml(): void;\r\n        /**\r\n         * Updates the size of the HTML canvas.\r\n         */\r\n        updateHtmlCanvasSize(width: any, height: any): void;\r\n        /**\r\n         * Creates and returns a drawing pane in HTML (DIV).\r\n         */\r\n        createHtmlPane(width: any, height: any): HTMLElement;\r\n        /**\r\n         * Creates the DOM nodes for the VML display.\r\n         */\r\n        createVml(): void;\r\n        /**\r\n         * Creates a drawing pane in VML (group).\r\n         */\r\n        createVmlPane(width: any, height: any): HTMLElement;\r\n        /**\r\n         * Creates and returns the DOM nodes for the SVG display.\r\n         */\r\n        createSvg(): void;\r\n        /**\r\n         * Updates the style of the container after installing the SVG DOM elements.\r\n         */\r\n        updateContainerStyle(container: any): void;\r\n        /**\r\n         * Destroys the view and all its resources.\r\n         */\r\n        destroy(): void;\r\n    }\r\n    /**\r\n     * Action to change the current root in a view.\r\n     *\r\n     * Constructor: mxCurrentRootChange\r\n     *\r\n     * Constructs a change of the current root in the given view.\r\n     */\r\n    export declare class mxCurrentRootChange {\r\n        constructor(view: any, root: any);\r\n        /**\r\n         * Changes the current root of the view.\r\n         */\r\n        execute(): void;\r\n    }\r\n    /**\r\n     * A string to affect the display performance and rendering in IE, but not in SVG-based browsers. The parameter is mapped to <dialect>, which may be one of <mxConstants.DIALECT_SVG> for SVG-based browsers, \r\n     * <mxConstants.DIALECT_STRICTHTML> for fastest display mode,\r\n     * <mxConstants.DIALECT_PREFERHTML> for faster display mode,\r\n     * <mxConstants.DIALECT_MIXEDHTML> for fast \r\n     * and <mxConstants.DIALECT_VML> for exact display mode (slowest). The dialects are defined in mxConstants.\r\n     * The default values are DIALECT_SVG for SVG-based browsers and DIALECT_MIXED for IE.\r\n     */\r\n    export declare enum renderingHint {\r\n        /**\r\n        * The display performance is \r\n        * highly improved in IE if the VML is not contained within a VML group \r\n        * element. The lack of a group element only slightly affects the display while \r\n        * panning, but improves the performance by almost a factor of 2, while keeping \r\n        * the display sufficiently accurate. This also allows to render certain shapes as HTML \r\n        * if the display accuracy is not affected, which is implemented by \r\n        * <mxShape.isMixedModeHtml>. This is the default setting and is mapped to\r\n        * DIALECT_MIXEDHTML.\r\n        */\r\n        fast = 'fast',\r\n\r\n        /**\r\n        * Same as fast, but more expensive shapes are avoided. This is \r\n        * controlled by <mxShape.preferModeHtml>. The default implementation will \r\n        * avoid gradients and rounded rectangles, but more significant shapes, such \r\n        * as rhombus, ellipse, actor and cylinder will be rendered accurately. This \r\n        * setting is mapped to DIALECT_PREFERHTML.\r\n        */\r\n        faster = 'faster',\r\n\r\n        /**\r\n        * Almost anything will be rendered in Html.This allows for \r\n        * rectangles, labels and images.This setting is mapped to\r\n        * DIALECT_STRICTHTML.\r\n        */\r\n        fastest = 'fastest',\r\n\r\n        /**\r\n        * exact - If accurate panning is required and if the diagram is small(up\r\n        * to 100 cells), then this value should be used.In this mode, a group is\r\n        * created that contains the VML.This allows for accurate panning and is\r\n        * mapped to DIALECT_VML.\r\n        */\r\n        exact = 'exact',\r\n    }\r\n\r\n    export declare class mxGraph extends mxEventSource {\r\n        selectionCellsHandler: mxSelectionCellsHandler;\r\n        connectionHandler: mxConnectionHandler;\r\n        panningHandler: mxPanningHandler;\r\n        tooltipHandler: mxTooltipHandler;\r\n        graphHandler: mxGraphHandler;\r\n        popupMenuHandler: mxPopupMenuHandler;\r\n\r\n        /**\r\n         * Immutable empty array instance.\r\n         */\r\n        readonly EMPTY_ARRAY: any[];\r\n        /**\r\n         * Holds the mouse event listeners. See <fireMouseEvent>.\r\n         */\r\n        mouseListeners: any;\r\n        /**\r\n         * Holds the state of the mouse button.\r\n         */\r\n        isMouseDown: boolean;\r\n        /**\r\n         * Holds the <mxGraphModel> that contains the cells to be displayed.\r\n         */\r\n        model: mxGraphModel;\r\n        /**\r\n         * Holds the <mxGraphView> that caches the <mxCellStates> for the cells.\r\n         */\r\n        view: mxGraphView;\r\n        /**\r\n         * Holds the <mxStylesheet> that defines the appearance of the cells.\r\n         *\r\n         *\r\n         * Example:\r\n         *\r\n         * Use the following code to read a stylesheet into an existing graph.\r\n         *\r\n         * (code)\r\n         * var req = mxUtils.load('stylesheet.xml');\r\n         * var root = req.getDocumentElement();\r\n         * var dec = new mxCodec(root.ownerDocument);\r\n         * dec.decode(root, graph.stylesheet);\r\n         * (end)\r\n         */\r\n        stylesheet: mxStylesheet;\r\n        /**\r\n         * Holds the <mxGraphSelectionModel> that models the current selection.\r\n         */\r\n        selectionModel: mxGraphSelectionModel;\r\n        /**\r\n         * Holds the <mxCellEditor> that is used as the in-place editing.\r\n         */\r\n        cellEditor: mxCellEditor;\r\n        /**\r\n         * Holds the <mxCellRenderer> for rendering the cells in the graph.\r\n         */\r\n        cellRenderer: mxCellRenderer;\r\n        /**\r\n         * An array of <mxMultiplicities> describing the allowed\r\n         * connections in a graph.\r\n         */\r\n        multiplicities: mxMultiplicity[];\r\n        /**\r\n         * RenderHint as it was passed to the constructor.\r\n         */\r\n        renderHint: any;\r\n        /**\r\n         * Dialect to be used for drawing the graph. Possible values are all\r\n         * constants in <mxConstants> with a DIALECT-prefix.\r\n         */\r\n        dialect: string;\r\n        /**\r\n         * Specifies the grid size. Default is 10.\r\n         */\r\n        gridSize: number;\r\n        /**\r\n         * Specifies if the grid is enabled. This is used in <snap>. Default is\r\n         * true.\r\n         */\r\n        gridEnabled: boolean;\r\n        /**\r\n         * Specifies if ports are enabled. This is used in <cellConnected> to update\r\n         * the respective style. Default is true.\r\n         */\r\n        portsEnabled: boolean;\r\n        /**\r\n         * Specifies if native double click events should be detected. Default is true.\r\n         */\r\n        nativeDblClickEnabled: boolean;\r\n        /**\r\n         * Specifies if double taps on touch-based devices should be handled as a\r\n         * double click. Default is true.\r\n         */\r\n        doubleTapEnabled: boolean;\r\n        /**\r\n         * Specifies the timeout for double taps and non-native double clicks. Default\r\n         * is 500 ms.\r\n         */\r\n        doubleTapTimeout: number;\r\n        /**\r\n         * Specifies the tolerance for double taps and double clicks in quirks mode.\r\n         * Default is 25 pixels.\r\n         */\r\n        doubleTapTolerance: number;\r\n        /**\r\n         * Holds the x-coordinate of the last touch event for double tap detection.\r\n         */\r\n        lastTouchX: number;\r\n        /**\r\n         * Holds the y-coordinate of the last touch event for double tap detection.\r\n         */\r\n        lastTouchY: number;\r\n        /**\r\n         * Holds the time of the last touch event for double click detection.\r\n         */\r\n        lastTouchTime: number;\r\n        /**\r\n         * Specifies if tap and hold should be used for starting connections on touch-based\r\n         * devices. Default is true.\r\n         */\r\n        tapAndHoldEnabled: boolean;\r\n        /**\r\n         * Specifies the time for a tap and hold. Default is 500 ms.\r\n         */\r\n        tapAndHoldDelay: number;\r\n        /**\r\n         * True if the timer for tap and hold events is running.\r\n         */\r\n        tapAndHoldInProgress: boolean;\r\n        /**\r\n         * True as long as the timer is running and the touch events\r\n         * stay within the given <tapAndHoldTolerance>.\r\n         */\r\n        tapAndHoldValid: boolean;\r\n        /**\r\n         * Holds the x-coordinate of the intial touch event for tap and hold.\r\n         */\r\n        initialTouchX: number;\r\n        /**\r\n         * Holds the y-coordinate of the intial touch event for tap and hold.\r\n         */\r\n        initialTouchY: number;\r\n        /**\r\n         * Tolerance for a move to be handled as a single click.\r\n         * Default is 4 pixels.\r\n         */\r\n        tolerance: number;\r\n        /**\r\n         * Value returned by <getOverlap> if <isAllowOverlapParent> returns\r\n         * true for the given cell. <getOverlap> is used in <constrainChild> if\r\n         * <isConstrainChild> returns true. The value specifies the\r\n         * portion of the child which is allowed to overlap the parent.\r\n         */\r\n        defaultOverlap: number;\r\n        /**\r\n         * Specifies the default parent to be used to insert new cells.\r\n         * This is used in <getDefaultParent>. Default is null.\r\n         */\r\n        defaultParent: any;\r\n        /**\r\n         * Specifies the alternate edge style to be used if the main control point\r\n         * on an edge is being doubleclicked. Default is null.\r\n         */\r\n        alternateEdgeStyle: any;\r\n        /**\r\n         * Specifies the <mxImage> to be returned by <getBackgroundImage>. Default\r\n         * is null.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);\r\n         * graph.setBackgroundImage(img);\r\n         * graph.view.validate();\r\n         * (end)\r\n         */\r\n        backgroundImage: mxImage;\r\n        /**\r\n         * Specifies if the background page should be visible. Default is false.\r\n         * Not yet implemented.\r\n         */\r\n        pageVisible: boolean;\r\n        /**\r\n         * Specifies if a dashed line should be drawn between multiple pages. Default\r\n         * is false. If you change this value while a graph is being displayed then you\r\n         * should call <sizeDidChange> to force an update of the display.\r\n         */\r\n        pageBreaksVisible: boolean;\r\n        /**\r\n         * Specifies the color for page breaks. Default is 'gray'.\r\n         */\r\n        pageBreakColor: string;\r\n        /**\r\n         * Specifies the page breaks should be dashed. Default is true.\r\n         */\r\n        pageBreakDashed: boolean;\r\n        /**\r\n         * Specifies the minimum distance for page breaks to be visible. Default is\r\n         * 20 (in pixels).\r\n         */\r\n        minPageBreakDist: number;\r\n        /**\r\n         * Specifies if the graph size should be rounded to the next page number in\r\n         * <sizeDidChange>. This is only used if the graph container has scrollbars.\r\n         * Default is false.\r\n         */\r\n        preferPageSize: boolean;\r\n        /**\r\n         * Specifies the page format for the background page. Default is\r\n         * <mxConstants.PAGE_FORMAT_A4_PORTRAIT>. This is used as the default in\r\n         * <mxPrintPreview> and for painting the background page if <pageVisible> is\r\n         * true and the pagebreaks if <pageBreaksVisible> is true.\r\n         */\r\n        pageFormat: mxRectangle;\r\n        /**\r\n         * Specifies the scale of the background page. Default is 1.5.\r\n         * Not yet implemented.\r\n         */\r\n        pageScale: number;\r\n        /**\r\n         * Specifies the return value for <isEnabled>. Default is true.\r\n         */\r\n        enabled: boolean;\r\n        /**\r\n         * Specifies if <mxKeyHandler> should invoke <escape> when the escape key\r\n         * is pressed. Default is true.\r\n         */\r\n        escapeEnabled: boolean;\r\n        /**\r\n         * If true, when editing is to be stopped by way of selection changing,\r\n         * data in diagram changing or other means stopCellEditing is invoked, and\r\n         * changes are saved. This is implemented in a focus handler in\r\n         * <mxCellEditor>. Default is true.\r\n         */\r\n        invokesStopCellEditing: boolean;\r\n        /**\r\n         * If true, pressing the enter key without pressing control or shift will stop\r\n         * editing and accept the new value. This is used in <mxCellEditor> to stop\r\n         * cell editing. Note: You can always use F2 and escape to stop editing.\r\n         * Default is false.\r\n         */\r\n        enterStopsCellEditing: boolean;\r\n        /**\r\n         * Specifies if scrollbars should be used for panning in <panGraph> if\r\n         * any scrollbars are available. If scrollbars are enabled in CSS, but no\r\n         * scrollbars appear because the graph is smaller than the container size,\r\n         * then no panning occurs if this is true. Default is true.\r\n         */\r\n        useScrollbarsForPanning: boolean;\r\n        /**\r\n         * Specifies the return value for <canExportCell>. Default is true.\r\n         */\r\n        exportEnabled: boolean;\r\n        /**\r\n         * Specifies the return value for <canImportCell>. Default is true.\r\n         */\r\n        importEnabled: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellLocked>. Default is false.\r\n         */\r\n        cellsLocked: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellCloneable>. Default is true.\r\n         */\r\n        cellsCloneable: boolean;\r\n        /**\r\n         * Specifies if folding (collapse and expand via an image icon in the graph\r\n         * should be enabled). Default is true.\r\n         */\r\n        foldingEnabled: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellEditable>. Default is true.\r\n         */\r\n        cellsEditable: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellDeletable>. Default is true.\r\n         */\r\n        cellsDeletable: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellMovable>. Default is true.\r\n         */\r\n        cellsMovable: boolean;\r\n        /**\r\n         * Specifies the return value for edges in <isLabelMovable>. Default is true.\r\n         */\r\n        edgeLabelsMovable: boolean;\r\n        /**\r\n         * Specifies the return value for vertices in <isLabelMovable>. Default is false.\r\n         */\r\n        vertexLabelsMovable: boolean;\r\n        /**\r\n         * Specifies the return value for <isDropEnabled>. Default is false.\r\n         */\r\n        dropEnabled: boolean;\r\n        /**\r\n         * Specifies if dropping onto edges should be enabled. This is ignored if\r\n         * <dropEnabled> is false. If enabled, it will call <splitEdge> to carry\r\n         * out the drop operation. Default is true.\r\n         */\r\n        splitEnabled: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellResizable>. Default is true.\r\n         */\r\n        cellsResizable: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellsBendable>. Default is true.\r\n         */\r\n        cellsBendable: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellSelectable>. Default is true.\r\n         */\r\n        cellsSelectable: boolean;\r\n        /**\r\n         * Specifies the return value for <isCellDisconntable>. Default is true.\r\n         */\r\n        cellsDisconnectable: boolean;\r\n        /**\r\n         * Specifies if the graph should automatically update the cell size after an\r\n         * edit. This is used in <isAutoSizeCell>. Default is false.\r\n         */\r\n        autoSizeCells: boolean;\r\n        /**\r\n         * Specifies if autoSize style should be applied when cells are added. Default is false.\r\n         */\r\n        autoSizeCellsOnAdd: boolean;\r\n        /**\r\n         * Specifies if the graph should automatically scroll if the mouse goes near\r\n         * the container edge while dragging. This is only taken into account if the\r\n         * container has scrollbars. Default is true.\r\n         *\r\n         * If you need this to work without scrollbars then set <ignoreScrollbars> to\r\n         * true. Please consult the <ignoreScrollbars> for details. In general, with\r\n         * no scrollbars, the use of <allowAutoPanning> is recommended.\r\n         */\r\n        autoScroll: boolean;\r\n        /**\r\n         * Specifies if the graph should automatically scroll regardless of the\r\n         * scrollbars. This will scroll the container using positive values for\r\n         * scroll positions (ie usually only rightwards and downwards). To avoid\r\n         * possible conflicts with panning, set <translateToScrollPosition> to true.\r\n         */\r\n        ignoreScrollbars: boolean;\r\n        /**\r\n         * Specifies if the graph should automatically convert the current scroll\r\n         * position to a translate in the graph view when a mouseUp event is received.\r\n         * This can be used to avoid conflicts when using <autoScroll> and\r\n         * <ignoreScrollbars> with no scrollbars in the container.\r\n         */\r\n        translateToScrollPosition: boolean;\r\n        /**\r\n         * Specifies if autoscrolling should be carried out via mxPanningManager even\r\n         * if the container has scrollbars. This disables <scrollPointToVisible> and\r\n         * uses <mxPanningManager> instead. If this is true then <autoExtend> is\r\n         * disabled. It should only be used with a scroll buffer or when scollbars\r\n         * are visible and scrollable in all directions. Default is false.\r\n         */\r\n        timerAutoScroll: boolean;\r\n        /**\r\n         * Specifies if panning via <panGraph> should be allowed to implement autoscroll\r\n         * if no scrollbars are available in <scrollPointToVisible>. To enable panning\r\n         * inside the container, near the edge, set <mxPanningManager.border> to a\r\n         * positive value. Default is false.\r\n         */\r\n        allowAutoPanning: boolean;\r\n        /**\r\n         * Specifies if the size of the graph should be automatically extended if the\r\n         * mouse goes near the container edge while dragging. This is only taken into\r\n         * account if the container has scrollbars. Default is true. See <autoScroll>.\r\n         */\r\n        autoExtend: boolean;\r\n        /**\r\n         * <mxRectangle> that specifies the area in which all cells in the diagram\r\n         * should be placed. Uses in <getMaximumGraphBounds>. Use a width or height of\r\n         * 0 if you only want to give a upper, left corner.\r\n         */\r\n        maximumGraphBounds: any;\r\n        /**\r\n         * <mxRectangle> that specifies the minimum size of the graph. This is ignored\r\n         * if the graph container has no scrollbars. Default is null.\r\n         */\r\n        minimumGraphSize: any;\r\n        /**\r\n         * <mxRectangle> that specifies the minimum size of the <container> if\r\n         * <resizeContainer> is true.\r\n         */\r\n        minimumContainerSize: any;\r\n        /**\r\n         * <mxRectangle> that specifies the maximum size of the container if\r\n         * <resizeContainer> is true.\r\n         */\r\n        maximumContainerSize: any;\r\n        /**\r\n         * Specifies if the container should be resized to the graph size when\r\n         * the graph size has changed. Default is false.\r\n         */\r\n        resizeContainer: boolean;\r\n        /**\r\n         * Border to be added to the bottom and right side when the container is\r\n         * being resized after the graph has been changed. Default is 0.\r\n         */\r\n        border: number;\r\n        /**\r\n         * Specifies if edges should appear in the foreground regardless of their order\r\n         * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\r\n         * both true then the normal order is applied. Default is false.\r\n         */\r\n        keepEdgesInForeground: boolean;\r\n        /**\r\n         * Specifies if edges should appear in the background regardless of their order\r\n         * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\r\n         * both true then the normal order is applied. Default is false.\r\n         */\r\n        keepEdgesInBackground: boolean;\r\n        /**\r\n         * Specifies if negative coordinates for vertices are allowed. Default is true.\r\n         */\r\n        allowNegativeCoordinates: boolean;\r\n        /**\r\n         * Specifies if a child should be constrained inside the parent bounds after a\r\n         * move or resize of the child. Default is true.\r\n         */\r\n        constrainChildren: boolean;\r\n        /**\r\n         * Specifies if child cells with relative geometries should be constrained\r\n         * inside the parent bounds, if <constrainChildren> is true, and/or the\r\n         * <maximumGraphBounds>. Default is false.\r\n         */\r\n        constrainRelativeChildren: boolean;\r\n        /**\r\n         * Specifies if a parent should contain the child bounds after a resize of\r\n         * the child. Default is true. This has precedence over <constrainChildren>.\r\n         */\r\n        extendParents: boolean;\r\n        /**\r\n         * Specifies if parents should be extended according to the <extendParents>\r\n         * switch if cells are added. Default is true.\r\n         */\r\n        extendParentsOnAdd: boolean;\r\n        /**\r\n         * Specifies if parents should be extended according to the <extendParents>\r\n         * switch if cells are added. Default is false for backwards compatiblity.\r\n         */\r\n        extendParentsOnMove: boolean;\r\n        /**\r\n         * Specifies the return value for <isRecursiveResize>. Default is\r\n         * false for backwards compatiblity.\r\n         */\r\n        recursiveResize: boolean;\r\n        /**\r\n         * Specifies if the cell size should be changed to the preferred size when\r\n         * a cell is first collapsed. Default is true.\r\n         */\r\n        collapseToPreferredSize: boolean;\r\n        /**\r\n         * Specifies the factor used for <zoomIn> and <zoomOut>. Default is 1.2\r\n         * (120%).\r\n         */\r\n        zoomFactor: number;\r\n        /**\r\n         * Specifies if the viewport should automatically contain the selection cells\r\n         * after a zoom operation. Default is false.\r\n         */\r\n        keepSelectionVisibleOnZoom: boolean;\r\n        /**\r\n         * Specifies if the zoom operations should go into the center of the actual\r\n         * diagram rather than going from top, left. Default is true.\r\n         */\r\n        centerZoom: boolean;\r\n        /**\r\n         * Specifies if the scale and translate should be reset if the root changes in\r\n         * the model. Default is true.\r\n         */\r\n        resetViewOnRootChange: boolean;\r\n        /**\r\n         * Specifies if edge control points should be reset after the resize of a\r\n         * connected cell. Default is false.\r\n         */\r\n        resetEdgesOnResize: boolean;\r\n        /**\r\n         * Specifies if edge control points should be reset after the move of a\r\n         * connected cell. Default is false.\r\n         */\r\n        resetEdgesOnMove: boolean;\r\n        /**\r\n         * Specifies if edge control points should be reset after the the edge has been\r\n         * reconnected. Default is true.\r\n         */\r\n        resetEdgesOnConnect: boolean;\r\n        /**\r\n         * Specifies if loops (aka self-references) are allowed. Default is false.\r\n         */\r\n        allowLoops: boolean;\r\n        /**\r\n         * <mxEdgeStyle> to be used for loops. This is a fallback for loops if the\r\n         * <mxConstants.STYLE_LOOP> is undefined. Default is <mxEdgeStyle.Loop>.\r\n         */\r\n        defaultLoopStyle: (state: any, source: any, target: any, points: any, result: any) => void;\r\n        /**\r\n         * Specifies if multiple edges in the same direction between the same pair of\r\n         * vertices are allowed. Default is true.\r\n         */\r\n        multigraph: boolean;\r\n        /**\r\n         * Specifies if edges are connectable. Default is false. This overrides the\r\n         * connectable field in edges.\r\n         */\r\n        connectableEdges: boolean;\r\n        /**\r\n         * Specifies if edges with disconnected terminals are allowed in the graph.\r\n         * Default is true.\r\n         */\r\n        allowDanglingEdges: boolean;\r\n        /**\r\n         * Specifies if edges that are cloned should be validated and only inserted\r\n         * if they are valid. Default is true.\r\n         */\r\n        cloneInvalidEdges: boolean;\r\n        /**\r\n         * Specifies if edges should be disconnected from their terminals when they\r\n         * are moved. Default is true.\r\n         */\r\n        disconnectOnMove: boolean;\r\n        /**\r\n         * Specifies if labels should be visible. This is used in <getLabel>. Default\r\n         * is true.\r\n         */\r\n        labelsVisible: boolean;\r\n        /**\r\n         * Specifies the return value for <isHtmlLabel>. Default is false.\r\n         */\r\n        htmlLabels: boolean;\r\n        /**\r\n         * Specifies if swimlanes should be selectable via the content if the\r\n         * mouse is released. Default is true.\r\n         */\r\n        swimlaneSelectionEnabled: boolean;\r\n        /**\r\n         * Specifies if nesting of swimlanes is allowed. Default is true.\r\n         */\r\n        swimlaneNesting: boolean;\r\n        /**\r\n         * The attribute used to find the color for the indicator if the indicator\r\n         * color is set to 'swimlane'. Default is <mxConstants.STYLE_FILLCOLOR>.\r\n         */\r\n        swimlaneIndicatorColorAttribute: string;\r\n        /**\r\n         * Holds the list of image bundles.\r\n         */\r\n        imageBundles: any;\r\n        /**\r\n         * Specifies the minimum scale to be applied in <fit>. Default is 0.1. Set this\r\n         * to null to allow any value.\r\n         */\r\n        minFitScale: number;\r\n        /**\r\n         * Specifies the maximum scale to be applied in <fit>. Default is 8. Set this\r\n         * to null to allow any value.\r\n         */\r\n        maxFitScale: number;\r\n        /**\r\n         * Current horizontal panning value. Default is 0.\r\n         */\r\n        panDx: number;\r\n        /**\r\n         * Current vertical panning value. Default is 0.\r\n         */\r\n        panDy: number;\r\n        /**\r\n         * Specifies the <mxImage> to indicate a collapsed state.\r\n         * Default value is mxClient.imageBasePath + '/collapsed.gif'\r\n         */\r\n        collapsedImage: mxImage;\r\n        /**\r\n         * Specifies the <mxImage> to indicate a expanded state.\r\n         * Default value is mxClient.imageBasePath + '/expanded.gif'\r\n         */\r\n        expandedImage: mxImage;\r\n        /**\r\n         * Specifies the <mxImage> for the image to be used to display a warning\r\n         * overlay. See <setCellWarning>. Default value is mxClient.imageBasePath +\r\n         * '/warning'.  The extension for the image depends on the platform. It is\r\n         * '.png' on the Mac and '.gif' on all other platforms.\r\n         */\r\n        warningImage: mxImage;\r\n        /**\r\n         * Specifies the resource key for the error message to be displayed in\r\n         * non-multigraphs when two vertices are already connected. If the resource\r\n         * for this key does not exist then the value is used as the error message.\r\n         * Default is 'alreadyConnected'.\r\n         */\r\n        alreadyConnectedResource: string;\r\n        /**\r\n         * Specifies the resource key for the warning message to be displayed when\r\n         * a collapsed cell contains validation errors. If the resource for this\r\n         * key does not exist then the value is used as the warning message.\r\n         * Default is 'containsValidationErrors'.\r\n         */\r\n        containsValidationErrorsResource: string;\r\n        /**\r\n         * Specifies the resource key for the tooltip on the collapse/expand icon.\r\n         * If the resource for this key does not exist then the value is used as\r\n         * the tooltip. Default is 'collapse-expand'.\r\n         */\r\n        collapseExpandResource: string;\r\n        container: HTMLDivElement;\r\n        /**\r\n    * Constructs a new mxGraph in the specified container. \r\n    * \r\n    * Model is an optional {@link mxGraphModel}. If no model is provided, a new mxGraphModel instance is used as the model. \r\n    * The container must have a valid owner document prior to calling this function in Internet Explorer. \r\n    * RenderHint - see {@link renderingHint}\r\n    *\r\n    * To create a graph inside a DOM node with an id of graph:\r\n    * @example\r\n    * var container = document.getElementById('graph');\r\n    * var graph = new mxGraph(container);\r\n    * \r\n    * @param container - Optional DOM node that acts as a container for the graph.\r\n    * If this is null then the container can be initialized later using\r\n    * <init>.\r\n    * @param model - Optional <mxGraphModel> that constitutes the graph data.\r\n    * @param renderHint - Optional string that specifies the display accuracy and\r\n    * performance. Default is mxConstants.DIALECT_MIXEDHTML (for IE).\r\n    * @param stylesheet - Optional <mxStylesheet> to be used in the graph.\r\n    */\r\n        constructor(container?: Element, model?: mxGraphModel, renderHint?: renderingHint, stylesheet?: mxStylesheet);\r\n        /**\r\n         * Initializes the <container> and creates the respective datastructures.\r\n         *\r\n         * container - DOM node that will contain the graph display.\r\n         */\r\n        init(container: HTMLDivElement): void;\r\n        /**\r\n         * Creates the tooltip-, panning-, connection- and graph-handler (in this\r\n         * order). This is called in the constructor before <init> is called.\r\n         */\r\n        createHandlers(): void;\r\n        /**\r\n         * Creates and returns a new <mxTooltipHandler> to be used in this graph.\r\n         */\r\n        createTooltipHandler(): mxTooltipHandler;\r\n        /**\r\n         * Creates and returns a new <mxTooltipHandler> to be used in this graph.\r\n         */\r\n        createSelectionCellsHandler(): mxSelectionCellsHandler;\r\n        /**\r\n         * Creates and returns a new <mxConnectionHandler> to be used in this graph.\r\n         */\r\n        createConnectionHandler(): mxConnectionHandler;\r\n        /**\r\n         * Creates and returns a new <mxGraphHandler> to be used in this graph.\r\n         */\r\n        createGraphHandler(): mxGraphHandler;\r\n        /**\r\n         * Creates and returns a new <mxPanningHandler> to be used in this graph.\r\n         */\r\n        createPanningHandler(): mxPanningHandler;\r\n        /**\r\n         * Creates and returns a new <mxPopupMenuHandler> to be used in this graph.\r\n         */\r\n        createPopupMenuHandler(): mxPopupMenuHandler;\r\n        /**\r\n         * Creates a new <mxGraphSelectionModel> to be used in this graph.\r\n         */\r\n        createSelectionModel(): mxGraphSelectionModel;\r\n        /**\r\n         * Creates a new <mxGraphSelectionModel> to be used in this graph.\r\n         */\r\n        createStylesheet(): mxStylesheet;\r\n        /**\r\n         * Creates a new <mxGraphView> to be used in this graph.\r\n         */\r\n        createGraphView(): mxGraphView;\r\n        /**\r\n         * Creates a new <mxCellRenderer> to be used in this graph.\r\n         */\r\n        createCellRenderer(): mxCellRenderer;\r\n        /**\r\n         * Creates a new <mxCellEditor> to be used in this graph.\r\n         */\r\n        createCellEditor(): mxCellEditor;\r\n        /**\r\n         * Returns the <mxGraphModel> that contains the cells.\r\n         */\r\n        getModel(): mxGraphModel;\r\n        /**\r\n         * Returns the <mxGraphView> that contains the <mxCellStates>.\r\n         */\r\n        getView(): mxGraphView;\r\n        /**\r\n         * Returns the <mxStylesheet> that defines the style.\r\n         */\r\n        getStylesheet(): mxStylesheet;\r\n        /**\r\n         * Sets the <mxStylesheet> that defines the style.\r\n         */\r\n        setStylesheet(stylesheet: mxStylesheet): void;\r\n        /**\r\n         * Returns the <mxGraphSelectionModel> that contains the selection.\r\n         */\r\n        getSelectionModel(): mxGraphSelectionModel;\r\n        /**\r\n         * Sets the <mxGraphSelectionModel> that contains the selection.\r\n         */\r\n        setSelectionModel(selectionModel: mxGraphSelectionModel): void;\r\n        /**\r\n         * Returns the cells to be selected for the given array of changes.\r\n         */\r\n        getSelectionCellsForChanges(changes: (mxRootChange | mxChildChange | {\r\n            cell: mxCell;\r\n        })[]): mxCell[];\r\n        /**\r\n         * Called when the graph model changes. Invokes <processChange> on each\r\n         * item of the given array to update the view accordingly.\r\n         *\r\n         * changes - Array that contains the individual changes.\r\n         */\r\n        graphModelChanged(changes: any): void;\r\n        /**\r\n         * Returns the cells that have been removed from the model.\r\n         */\r\n        getRemovedCellsForChanges(changes: any): mxCell[];\r\n        /**\r\n         * Processes the given change and invalidates the respective cached data\r\n         * in <view>. This fires a <root> event if the root has changed in the\r\n         * model.\r\n         *\r\n         * change - Object that represents the change on the model.\r\n         */\r\n        processChange(change: any): void;\r\n        /**\r\n         * Removes all cached information for the given cell and its descendants.\r\n         * This is called when a cell was removed from the model.\r\n         *\r\n         * Paramters:\r\n         *\r\n         * cell - <mxCell> that was removed from the model.\r\n         */\r\n        removeStateForCell(cell: mxCell): void;\r\n        /**\r\n         * Adds an <mxCellOverlay> for the specified cell. This method fires an\r\n         * <addoverlay> event and returns the new <mxCellOverlay>.\r\n         *\r\n         * cell - <mxCell> to add the overlay for.\r\n         * overlay - <mxCellOverlay> to be added for the cell.\r\n         */\r\n        addCellOverlay(cell: mxCell, overlay: mxCellOverlay): mxCellOverlay;\r\n        /**\r\n         * Returns the array of <mxCellOverlays> for the given cell or null, if\r\n         * no overlays are defined.\r\n         *\r\n         * cell - <mxCell> whose overlays should be returned.\r\n         */\r\n        getCellOverlays(cell: mxCell): mxCellOverlay[];\r\n        /**\r\n         * Removes and returns the given <mxCellOverlay> from the given cell. This\r\n         * method fires a <removeoverlay> event. If no overlay is given, then all\r\n         * overlays are removed using <removeOverlays>.\r\n         *\r\n         * cell - <mxCell> whose overlay should be removed.\r\n         * overlay - Optional <mxCellOverlay> to be removed.\r\n         */\r\n        removeCellOverlay(cell: mxCell, overlay: mxCellOverlay): mxCellOverlay;\r\n        /**\r\n         * Removes all <mxCellOverlays> from the given cell. This method\r\n         * fires a <removeoverlay> event for each <mxCellOverlay> and returns\r\n         * the array of <mxCellOverlays> that was removed from the cell.\r\n         *\r\n         * cell - <mxCell> whose overlays should be removed\r\n         */\r\n        removeCellOverlays(cell: mxCell): mxCellOverlay[];\r\n        /**\r\n         * Removes all <mxCellOverlays> in the graph for the given cell and all its\r\n         * descendants. If no cell is specified then all overlays are removed from\r\n         * the graph. This implementation uses <removeCellOverlays> to remove the\r\n         * overlays from the individual cells.\r\n         *\r\n         * cell - Optional <mxCell> that represents the root of the subtree to\r\n         * remove the overlays from. Default is the root in the model.\r\n         */\r\n        clearCellOverlays(cell: mxCell): void;\r\n        /**\r\n         * Creates an overlay for the given cell using the warning and image or\r\n         * <warningImage> and returns the new <mxCellOverlay>. The warning is\r\n         * displayed as a tooltip in a red font and may contain HTML markup. If\r\n         * the warning is null or a zero length string, then all overlays are\r\n         * removed from the cell.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * graph.setCellWarning(cell, '<b>Warning:</b>: Hello, World!');\r\n         * (end)\r\n         *\r\n         * cell - <mxCell> whose warning should be set.\r\n         * warning - String that represents the warning to be displayed.\r\n         * img - Optional <mxImage> to be used for the overlay. Default is\r\n         * <warningImage>.\r\n         * isSelect - Optional boolean indicating if a click on the overlay\r\n         * should select the corresponding cell. Default is false.\r\n         */\r\n        setCellWarning(cell: mxCell, warning: string, img?: mxImage, isSelect?: boolean): mxCellOverlay;\r\n        /**\r\n         * Calls <startEditingAtCell> using the given cell or the first selection\r\n         * cell.\r\n         *\r\n         * evt - Optional mouse event that triggered the editing.\r\n         */\r\n        startEditing(evt: any): void;\r\n        /**\r\n         * Fires a <startEditing> event and invokes <mxCellEditor.startEditing>\r\n         * on <editor>. After editing was started, a <editingStarted> event is\r\n         * fired.\r\n         *\r\n         * cell - <mxCell> to start the in-place editor for.\r\n         * evt - Optional mouse event that triggered the editing.\r\n         */\r\n        startEditingAtCell(cell: any, evt: any): void;\r\n        /**\r\n         * Returns the initial value for in-place editing. This implementation\r\n         * returns <convertValueToString> for the given cell. If this function is\r\n         * overridden, then <mxGraphModel.valueForCellChanged> should take care\r\n         * of correctly storing the actual new value inside the user object.\r\n         *\r\n         * cell - <mxCell> for which the initial editing value should be returned.\r\n         * evt - Optional mouse event that triggered the editor.\r\n         */\r\n        getEditingValue(cell: any, evt: any): string;\r\n        /**\r\n         * Stops the current editing  and fires a <editingStopped> event.\r\n         *\r\n         * cancel - Boolean that specifies if the current editing value\r\n         * should be stored.\r\n         */\r\n        stopEditing(cancel?: any): void;\r\n        /**\r\n         * Sets the label of the specified cell to the given value using\r\n         * <cellLabelChanged> and fires <mxEvent.LABEL_CHANGED> while the\r\n         * transaction is in progress. Returns the cell whose label was changed.\r\n         *\r\n         * cell - <mxCell> whose label should be changed.\r\n         * value - New label to be assigned.\r\n         * evt - Optional event that triggered the change.\r\n         */\r\n        labelChanged(cell: any, value: any, evt: any): any;\r\n        /**\r\n         * Sets the new label for a cell. If autoSize is true then\r\n         * <cellSizeUpdated> will be called.\r\n         *\r\n         * In the following example, the function is extended to map changes to\r\n         * attributes in an XML node, as shown in <convertValueToString>.\r\n         * Alternatively, the handling of this can be implemented as shown in\r\n         * <mxGraphModel.valueForCellChanged> without the need to clone the\r\n         * user object.\r\n         *\r\n         * (code)\r\n         * var graphCellLabelChanged = graph.cellLabelChanged;\r\n         * graph.cellLabelChanged = function(cell, newValue, autoSize)\r\n         * {\r\n         * \t// Cloned for correct undo/redo\r\n         * \tvar elt = cell.value.cloneNode(true);\r\n         *  elt.setAttribute('label', newValue);\r\n         *\r\n         *  newValue = elt;\r\n         *  graphCellLabelChanged.apply(this, arguments);\r\n         * };\r\n         * (end)\r\n         *\r\n         * cell - <mxCell> whose label should be changed.\r\n         * value - New label to be assigned.\r\n         * autoSize - Boolean that specifies if <cellSizeUpdated> should be called.\r\n         */\r\n        cellLabelChanged(cell: any, value: any, autoSize: any): void;\r\n        /**\r\n         * Processes an escape keystroke.\r\n         *\r\n         * evt - Mouseevent that represents the keystroke.\r\n         */\r\n        escape(evt?: any): void;\r\n        /**\r\n         * Processes a singleclick on an optional cell and fires a <click> event.\r\n         * The click event is fired initially. If the graph is enabled and the\r\n         * event has not been consumed, then the cell is selected using\r\n         * <selectCellForEvent> or the selection is cleared using\r\n         * <clearSelection>. The events consumed state is set to true if the\r\n         * corresponding <mxMouseEvent> has been consumed.\r\n         *\r\n         * To handle a click event, use the following code.\r\n         *\r\n         * (code)\r\n         * graph.addListener(mxEvent.CLICK, function(sender, evt)\r\n         * {\r\n         *   var e = evt.getProperty('event'); // mouse event\r\n         *   var cell = evt.getProperty('cell'); // cell may be null\r\n         *\r\n         *   if (cell != null)\r\n         *   {\r\n         *     // Do something useful with cell and consume the event\r\n         *     evt.consume();\r\n         *   }\r\n         * });\r\n         * (end)\r\n         *\r\n         * me - <mxMouseEvent> that represents the single click.\r\n         */\r\n        click(me: any): void;\r\n        /**\r\n         * Processes a doubleclick on an optional cell and fires a <dblclick>\r\n         * event. The event is fired initially. If the graph is enabled and the\r\n         * event has not been consumed, then <edit> is called with the given\r\n         * cell. The event is ignored if no cell was specified.\r\n         *\r\n         * Example for overriding this method.\r\n         *\r\n         * (code)\r\n         * graph.dblClick = function(evt, cell)\r\n         * {\r\n         *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\r\n         *   this.fireEvent(mxe);\r\n         *\r\n         *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\r\n         *   {\r\n         * \t   mxUtils.alert('Hello, World!');\r\n         *     mxe.consume();\r\n         *   }\r\n         * }\r\n         * (end)\r\n         *\r\n         * Example listener for this event.\r\n         *\r\n         * (code)\r\n         * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)\r\n         * {\r\n         *   var cell = evt.getProperty('cell');\r\n         *   // do something with the cell and consume the\r\n         *   // event to prevent in-place editing from start\r\n         * });\r\n         * (end)\r\n         *\r\n         * evt - Mouseevent that represents the doubleclick.\r\n         * cell - Optional <mxCell> under the mousepointer.\r\n         */\r\n        dblClick(evt: MouseEvent, cell?: any): void;\r\n        /**\r\n         * Handles the <mxMouseEvent> by highlighting the <mxCellState>.\r\n         *\r\n         * me - <mxMouseEvent> that represents the touch event.\r\n         * state - Optional <mxCellState> that is associated with the event.\r\n         */\r\n        tapAndHold(me: any): void;\r\n        /**\r\n         * Scrolls the graph to the given point, extending the graph container if\r\n         * specified.\r\n         */\r\n        scrollPointToVisible(x: any, y: any, extend: any, border: any): void;\r\n        /**\r\n         * Creates and returns an <mxPanningManager>.\r\n         */\r\n        createPanningManager(): any;\r\n        /**\r\n         * Returns the size of the border and padding on all four sides of the\r\n         * container. The left, top, right and bottom borders are stored in the x, y,\r\n         * width and height of the returned <mxRectangle>, respectively.\r\n         */\r\n        getBorderSizes(): mxRectangle;\r\n        /**\r\n         * Returns the preferred size of the background page if <preferPageSize> is true.\r\n         */\r\n        getPreferredPageSize(bounds: any, width: any, height: any): mxRectangle;\r\n        /**\r\n         * Scales the graph such that the complete diagram fits into <container> and\r\n         * returns the current scale in the view. To fit an initial graph prior to\r\n         * rendering, set <mxGraphView.rendering> to false prior to changing the model\r\n         * and execute the following after changing the model.\r\n         * \r\n         * @example\r\n         * graph.fit();\r\n         * graph.view.rendering = true;\r\n         * graph.refresh();\r\n         * \r\n         * @example <caption>To fit and center the graph, the following code can be used.</caption>\r\n         * var margin = 2;\r\n         * var max = 3;\r\n         * \r\n         * var bounds = graph.getGraphBounds();\r\n         * var cw = graph.container.clientWidth - margin;\r\n         * var ch = graph.container.clientHeight - margin;\r\n         * var w = bounds.width / graph.view.scale;\r\n         * var h = bounds.height / graph.view.scale;\r\n         * var s = Math.min(max, Math.min(cw / w, ch / h));\r\n         * \r\n         * graph.view.scaleAndTranslate(s,\r\n         *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,\r\n         *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);\r\n         * \r\n         * @param border - Optional number that specifies the border. Default is <border>.\r\n         * @param keepOrigin - Optional boolean that specifies if the translate should be\r\n         * changed. Default is false.\r\n         * @param margin - Optional margin in pixels. Default is 0.\r\n         * @param enabled - Optional boolean that specifies if the scale should be set or\r\n         * just returned. Default is true.\r\n         * @param ignoreWidth - Optional boolean that specifies if the width should be\r\n         * ignored. Default is false.\r\n         * @param ignoreHeight - Optional boolean that specifies if the height should be\r\n         * ignored. Default is false.\r\n         * @param maxHeight - Optional maximum height.\r\n         */\r\n        fit(border?: number, keepOrigin?: boolean, margin?: number, enabled?: boolean, ignoreWidth?: boolean, ignoreHeight?: boolean, maxHeight?: number): number;\r\n        /**\r\n         * Called when the size of the graph has changed. This implementation fires\r\n         * a <size> event after updating the clipping region of the SVG element in\r\n         * SVG-bases browsers.\r\n         */\r\n        sizeDidChange(): void;\r\n        /**\r\n         * Resizes the container for the given graph width and height.\r\n         */\r\n        doResizeContainer(width: any, height: any): void;\r\n        /**\r\n         * Invokes from <sizeDidChange> to redraw the page breaks.\r\n         *\r\n         * visible - Boolean that specifies if page breaks should be shown.\r\n         * width - Specifies the width of the container in pixels.\r\n         * height - Specifies the height of the container in pixels.\r\n         */\r\n        updatePageBreaks(visible: any, width: any, height: any): void;\r\n        /**\r\n         * Returns an array of key, value pairs representing the cell style for the\r\n         * given cell. If no string is defined in the model that specifies the\r\n         * style, then the default style for the cell is returned or <EMPTY_ARRAY>,\r\n         * if not style can be found. Note: You should try and get the cell state\r\n         * for the given cell and use the cached style in the state before using\r\n         * this method.\r\n         *\r\n         * cell - <mxCell> whose style should be returned as an array.\r\n         */\r\n        getCellStyle(cell: mxCell): any;\r\n        /**\r\n         * Tries to resolve the value for the image style in the image bundles and\r\n         * turns short data URIs as defined in mxImageBundle to data URIs as\r\n         * defined in RFC 2397 of the IETF.\r\n         */\r\n        postProcessCellStyle(style: any): any;\r\n        /**\r\n         * Sets the style of the specified cells. If no cells are given, then the\r\n         * selection cells are changed.\r\n         *\r\n         * style - String representing the new style of the cells.\r\n         * cells - Optional array of <mxCells> to set the style for. Default is the\r\n         * selection cells.\r\n         */\r\n        setCellStyle(style: string, cells?: mxCell[]): void;\r\n        /**\r\n         * Toggles the boolean value for the given key in the style of the given cell\r\n         * and returns the new value as 0 or 1. If no cell is specified then the\r\n         * selection cell is used.\r\n         *\r\n         * Parameter:\r\n         *\r\n         * key - String representing the key for the boolean value to be toggled.\r\n         * defaultValue - Optional boolean default value if no value is defined.\r\n         * Default is false.\r\n         * cell - Optional <mxCell> whose style should be modified. Default is\r\n         * the selection cell.\r\n         */\r\n        toggleCellStyle(key: any, defaultValue: any, cell: any): any;\r\n        /**\r\n         * Toggles the boolean value for the given key in the style of the given cells\r\n         * and returns the new value as 0 or 1. If no cells are specified, then the\r\n         * selection cells are used. For example, this can be used to toggle\r\n         * <mxConstants.STYLE_ROUNDED> or any other style with a boolean value.\r\n         *\r\n         * Parameter:\r\n         *\r\n         * key - String representing the key for the boolean value to be toggled.\r\n         * defaultValue - Optional boolean default value if no value is defined.\r\n         * Default is false.\r\n         * cells - Optional array of <mxCells> whose styles should be modified.\r\n         * Default is the selection cells.\r\n         */\r\n        toggleCellStyles(key: any, defaultValue: any, cells?: any): any;\r\n        /**\r\n         * Sets the key to value in the styles of the given cells. This will modify\r\n         * the existing cell styles in-place and override any existing assignment\r\n         * for the given key. If no cells are specified, then the selection cells\r\n         * are changed. If no value is specified, then the respective key is\r\n         * removed from the styles.\r\n         *\r\n         * key - String representing the key to be assigned.\r\n         * value - String representing the new value for the key.\r\n         * cells - Optional array of <mxCells> to change the style for. Default is\r\n         * the selection cells.\r\n         */\r\n        setCellStyles(key: any, value: any, cells: any): void;\r\n        /**\r\n         * Toggles the given bit for the given key in the styles of the specified\r\n         * cells.\r\n         *\r\n         * key - String representing the key to toggle the flag in.\r\n         * flag - Integer that represents the bit to be toggled.\r\n         * cells - Optional array of <mxCells> to change the style for. Default is\r\n         * the selection cells.\r\n         */\r\n        toggleCellStyleFlags(key: any, flag: any, cells: any): void;\r\n        /**\r\n         * Sets or toggles the given bit for the given key in the styles of the\r\n         * specified cells.\r\n         *\r\n         * key - String representing the key to toggle the flag in.\r\n         * flag - Integer that represents the bit to be toggled.\r\n         * value - Boolean value to be used or null if the value should be toggled.\r\n         * cells - Optional array of <mxCells> to change the style for. Default is\r\n         * the selection cells.\r\n         */\r\n        setCellStyleFlags(key: any, flag: any, value: any, cells: any): void;\r\n        /**\r\n         * Aligns the given cells vertically or horizontally according to the given\r\n         * alignment using the optional parameter as the coordinate.\r\n         *\r\n         * align - Specifies the alignment. Possible values are all constants in\r\n         * mxConstants with an ALIGN prefix.\r\n         * cells - Array of <mxCells> to be aligned.\r\n         * param - Optional coordinate for the alignment.\r\n         */\r\n        alignCells(align: any, cells?: any, param?: any): any;\r\n        /**\r\n         * Toggles the style of the given edge between null (or empty) and\r\n         * <alternateEdgeStyle>. This method fires <mxEvent.FLIP_EDGE> while the\r\n         * transaction is in progress. Returns the edge that was flipped.\r\n         *\r\n         * Here is an example that overrides this implementation to invert the\r\n         * value of <mxConstants.STYLE_ELBOW> without removing any existing styles.\r\n         *\r\n         * (code)\r\n         * graph.flipEdge = function(edge)\r\n         * {\r\n         *   if (edge != null)\r\n         *   {\r\n         *     var state = this.view.getState(edge);\r\n         *     var style = (state != null) ? state.style : this.getCellStyle(edge);\r\n         *\r\n         *     if (style != null)\r\n         *     {\r\n         *       var elbow = mxUtils.getValue(style, mxConstants.STYLE_ELBOW,\r\n         *           mxConstants.ELBOW_HORIZONTAL);\r\n         *       var value = (elbow == mxConstants.ELBOW_HORIZONTAL) ?\r\n         *           mxConstants.ELBOW_VERTICAL : mxConstants.ELBOW_HORIZONTAL;\r\n         *       this.setCellStyles(mxConstants.STYLE_ELBOW, value, [edge]);\r\n         *     }\r\n         *   }\r\n         * };\r\n         * (end)\r\n         *\r\n         * edge - <mxCell> whose style should be changed.\r\n         */\r\n        flipEdge(edge: any): any;\r\n        /**\r\n         * Adds the specified <mxImageBundle>.\r\n         */\r\n        addImageBundle(bundle: any): void;\r\n        /**\r\n         * Removes the specified <mxImageBundle>.\r\n         */\r\n        removeImageBundle(bundle: any): void;\r\n        /**\r\n         * Searches all <imageBundles> for the specified key and returns the value\r\n         * for the first match or null if the key is not found.\r\n         */\r\n        getImageFromBundles(key: any): any;\r\n        /**\r\n         * Moves the given cells to the front or back. The change is carried out\r\n         * using <cellsOrdered>. This method fires <mxEvent.ORDER_CELLS> while the\r\n         * transaction is in progress.\r\n         *\r\n         * back - Boolean that specifies if the cells should be moved to back.\r\n         * cells - Array of <mxCells> to move to the background. If null is\r\n         * specified then the selection cells are used.\r\n         */\r\n        orderCells(back: any, cells?: any): any;\r\n        /**\r\n         * Moves the given cells to the front or back. This method fires\r\n         * <mxEvent.CELLS_ORDERED> while the transaction is in progress.\r\n         *\r\n         * cells - Array of <mxCells> whose order should be changed.\r\n         * back - Boolean that specifies if the cells should be moved to back.\r\n         */\r\n        cellsOrdered(cells: any, back: any): void;\r\n        /**\r\n         * Adds the cells into the given group. The change is carried out using\r\n         * <cellsAdded>, <cellsMoved> and <cellsResized>. This method fires\r\n         * <mxEvent.GROUP_CELLS> while the transaction is in progress. Returns the\r\n         * new group. A group is only created if there is at least one entry in the\r\n         * given array of cells.\r\n         *\r\n         * group - <mxCell> that represents the target group. If null is specified\r\n         * then a new group is created using <createGroupCell>.\r\n         * border - Optional integer that specifies the border between the child\r\n         * area and the group bounds. Default is 0.\r\n         * cells - Optional array of <mxCells> to be grouped. If null is specified\r\n         * then the selection cells are used.\r\n         */\r\n        groupCells(group: any, border: any, cells: any): any;\r\n        /**\r\n         * Returns the cells with the same parent as the first cell\r\n         * in the given array.\r\n         */\r\n        getCellsForGroup(cells: any): any[];\r\n        /**\r\n         * Returns the bounds to be used for the given group and children.\r\n         */\r\n        getBoundsForGroup(group: any, children: any, border: any): mxRectangle;\r\n        /**\r\n         * Hook for creating the group cell to hold the given array of <mxCells> if\r\n         * no group cell was given to the <group> function.\r\n         *\r\n         * The following code can be used to set the style of new group cells.\r\n         *\r\n         * (code)\r\n         * var graphCreateGroupCell = graph.createGroupCell;\r\n         * graph.createGroupCell = function(cells)\r\n         * {\r\n         *   var group = graphCreateGroupCell.apply(this, arguments);\r\n         *   group.setStyle('group');\r\n         *\r\n         *   return group;\r\n         * };\r\n         */\r\n        createGroupCell(cells: any): mxCell;\r\n        /**\r\n         * Ungroups the given cells by moving the children the children to their\r\n         * parents parent and removing the empty groups. Returns the children that\r\n         * have been removed from the groups.\r\n         *\r\n         * cells - Array of cells to be ungrouped. If null is specified then the\r\n         * selection cells are used.\r\n         */\r\n        ungroupCells(cells: any): any[];\r\n        /**\r\n         * Hook to remove the groups after <ungroupCells>.\r\n         *\r\n         * cells - Array of <mxCells> that were ungrouped.\r\n         */\r\n        removeCellsAfterUngroup(cells: any): void;\r\n        /**\r\n         * Removes the specified cells from their parents and adds them to the\r\n         * default parent. Returns the cells that were removed from their parents.\r\n         *\r\n         * cells - Array of <mxCells> to be removed from their parents.\r\n         */\r\n        removeCellsFromParent(cells: any): any;\r\n        /**\r\n         * Updates the bounds of the given groups to include all children and returns\r\n         * the passed-in cells. Call this with the groups in parent to child order,\r\n         * top-most group first, the cells are processed in reverse order and cells\r\n         * with no children are ignored.\r\n         *\r\n         * cells - The groups whose bounds should be updated. If this is null, then\r\n         * the selection cells are used.\r\n         * border - Optional border to be added in the group. Default is 0.\r\n         * moveGroup - Optional boolean that allows the group to be moved. Default\r\n         * is false.\r\n         * topBorder - Optional top border to be added in the group. Default is 0.\r\n         * rightBorder - Optional top border to be added in the group. Default is 0.\r\n         * bottomBorder - Optional top border to be added in the group. Default is 0.\r\n         * leftBorder - Optional top border to be added in the group. Default is 0.\r\n         */\r\n        updateGroupBounds(cells: any, border: any, moveGroup?: any, topBorder?: any, rightBorder?: any, bottomBorder?: any, leftBorder?: any): any;\r\n        /**\r\n         * Returns the bounding box for the given array of <mxCells>. The bounding box for\r\n         * each cell and its descendants is computed using <mxGraphView.getBoundingBox>.\r\n         *\r\n         * cells - Array of <mxCells> whose bounding box should be returned.\r\n         */\r\n        getBoundingBox(cells: any): any;\r\n        /**\r\n         * Function: cloneCells\r\n         * \r\n         * Returns the clones for the given cells. The clones are created recursively\r\n         * using <mxGraphModel.cloneCells>. If the terminal of an edge is not in the\r\n         * given array, then the respective end is assigned a terminal point and the\r\n         * terminal is removed.\r\n         * \r\n         * Parameters:\r\n         * \r\n         * cells - Array of <mxCells> to be cloned.\r\n         * allowInvalidEdges - Optional boolean that specifies if invalid edges\r\n         * should be cloned. Default is true.\r\n         * mapping - Optional mapping for existing clones.\r\n         * keepPosition - Optional boolean indicating if the position of the cells should\r\n         * be updated to reflect the lost parent cell. Default is false.\r\n         */\r\n        cloneCells(cells: mxCell[], allowInvalidEdges?: boolean, mapping?: boolean, keepPosition?: boolean): mxCell[];\r\n        /**\r\n         * Adds a new vertex into the given parent {@link mxCell} using value as the user\r\n         * object and the given coordinates as the {@link mxGeometry} of the new vertex.\r\n         * The id and style are used for the respective properties of the new\r\n         * {@link mxCell}, which is returned.\r\n         *\r\n         * When adding new vertices from a mouse event, one should take into\r\n         * account the offset of the graph container and the scale and translation\r\n         * of the view in order to find the correct unscaled, untranslated\r\n         * coordinates using {@link mxGraph.getPointForEvent} as follows:\r\n         *\r\n         * (code)\r\n         * var pt = graph.getPointForEvent(evt);\r\n         * var parent = graph.getDefaultParent();\r\n         * graph.insertVertex(parent, null,\r\n         * \t\t\t'Hello, World!', x, y, 220, 30);\r\n         * (end)\r\n         *\r\n         * For adding image cells, the style parameter can be assigned as\r\n         *\r\n         * (code)\r\n         * stylename;image=imageUrl\r\n         * (end)\r\n         *\r\n         * See {@link mxGraph} for more information on using images.\r\n         *\r\n         * @param {mxCell} parent Specifies the parent of the new vertex.\r\n         * @param {?string} id Optional string that defines the Id of the new vertex.\r\n         * @param {Object} value User defined data object.\r\n         * @param {number} x Integer that defines the x coordinate of the vertex.\r\n         * @param {number} y Integer that defines the y coordinate of the vertex.\r\n         * @param {number} width Integer that defines the width of the vertex.\r\n         * @param {number} height Integer that defines the height of the vertex.\r\n         * @param {string} [style] Optional string that defines the cell style.\r\n         * @param {boolean} [relative] Optional boolean that specifies if the geometry is relative.\r\n         * Default is false.\r\n         */\r\n        insertVertex(parent: mxCell, id: string, value: Object, x: number, y: number, width: number, height: number, style?: string, relative?: boolean): mxCell;\r\n        /**\r\n         * Adds a new edge into the given parent {@link mxCell} using value as the user\r\n         * object and the given source and target as the terminals of the new edge.\r\n         * The id and style are used for the respective properties of the new\r\n         * {@link mxCell}, which is returned.\r\n         *\r\n         * @param {mxCell} parent specifies the parent of the new edge.\r\n         * @param {?string} id Optional string that defines the Id of the new edge.\r\n         * @param {Object} value User defined data object.\r\n         * @param {mxCell} source Source of the edge.\r\n         * @param {mxCell} target Target of the edge.\r\n         * @param {string} [style] Optional string that defines the cell style.\r\n         */\r\n        insertEdge(parent: mxCell, id: string, value: Object, source: mxCell, target: mxCell, style?: string): mxCell;\r\n        /**\r\n         * Adds the edge to the parent and connects it to the given source and\r\n         * target terminals. This is a shortcut method. Returns the edge that was\r\n         * added.\r\n         *\r\n         * @param edge - <mxCell> to be inserted into the given parent.\r\n         * @param parent - <mxCell> that represents the new parent. If no parent is\r\n         * given then the default parent is used.\r\n         * @param source - Optional <mxCell> that represents the source terminal.\r\n         * @param target - Optional <mxCell> that represents the target terminal.\r\n         * @param index - Optional index to insert the cells at. Default is to append.\r\n         */\r\n        addEdge(edge: mxCell, parent: mxCell, source?: mxCell, target?: mxCell, index?: number): mxCell;\r\n        /**\r\n         * Adds the cell to the parent and connects it to the given source and\r\n         * target terminals. This is a shortcut method. Returns the cell that was\r\n         * added.\r\n         *\r\n         * @param cell - <mxCell> to be inserted into the given parent.\r\n         * @param parent - <mxCell> that represents the new parent. If no parent is\r\n         * given then the default parent is used.\r\n         * @param index - Optional index to insert the cells at. Default is to append.\r\n         * @param source - Optional <mxCell> that represents the source terminal.\r\n         * @param target - Optional <mxCell> that represents the target terminal.\r\n         */\r\n        addCell(cell: mxCell, parent: mxCell, index?: number, source?: mxCell, target?: mxCell): mxCell;\r\n        /**\r\n         * Adds the cells to the parent at the given index, connecting each cell to\r\n         * the optional source and target terminal. The change is carried out using\r\n         * <cellsAdded>. This method fires <mxEvent.ADD_CELLS> while the\r\n         * transaction is in progress. Returns the cells that were added.\r\n         *\r\n         * @param cells - Array of <mxCells> to be inserted.\r\n         * @param parent - <mxCell> that represents the new parent. If no parent is\r\n         * given then the default parent is used.\r\n         * @param index - Optional index to insert the cells at. Default is to append.\r\n         * @param source - Optional source <mxCell> for all inserted cells.\r\n         * @param target - Optional target <mxCell> for all inserted cells.\r\n         */\r\n        addCells(cells: mxCell[], parent?: mxCell, index?: number, source?: mxCell, target?: mxCell): mxCell[];\r\n        /**\r\n         * Resizes the specified cell to just fit around the its label and/or children\r\n         *\r\n         * @param cell - <mxCells> to be resized.\r\n         * @param recurse - Optional boolean which specifies if all descendants should be\r\n         * autosized. Default is true.\r\n         */\r\n        autoSizeCell(cell: mxCell, recurse?: boolean): void;\r\n        /**\r\n         * Removes the given cells from the graph including all connected edges if\r\n         * includeEdges is true. The change is carried out using <cellsRemoved>.\r\n         * This method fires <mxEvent.REMOVE_CELLS> while the transaction is in\r\n         * progress. The removed cells are returned as an array.\r\n         *\r\n         * cells - Array of <mxCells> to remove. If null is specified then the\r\n         * selection cells which are deletable are used.\r\n         * includeEdges - Optional boolean which specifies if all connected edges\r\n         * should be removed as well. Default is true.\r\n         */\r\n        removeCells(cells?: any, includeEdges?: any): any;\r\n        /**\r\n         * Removes the given cells from the model. This method fires\r\n         * <mxEvent.CELLS_REMOVED> while the transaction is in progress.\r\n         *\r\n         * cells - Array of <mxCells> to remove.\r\n         */\r\n        cellsRemoved(cells: any): void;\r\n        /**\r\n         * Splits the given edge by adding the newEdge between the previous source\r\n         * and the given cell and reconnecting the source of the given edge to the\r\n         * given cell. This method fires <mxEvent.SPLIT_EDGE> while the transaction\r\n         * is in progress. Returns the new edge that was inserted.\r\n         *\r\n         * edge - <mxCell> that represents the edge to be splitted.\r\n         * cells - <mxCells> that represents the cells to insert into the edge.\r\n         * newEdge - <mxCell> that represents the edge to be inserted.\r\n         * dx - Optional integer that specifies the vector to move the cells.\r\n         * dy - Optional integer that specifies the vector to move the cells.\r\n         */\r\n        splitEdge(edge: any, cells: any, newEdge: any, dx: any, dy: any, x?: number, y?: number, parent?: mxCell): any;\r\n        /**\r\n         * Sets the visible state of the specified cells and all connected edges\r\n         * if includeEdges is true. The change is carried out using <cellsToggled>.\r\n         * This method fires <mxEvent.TOGGLE_CELLS> while the transaction is in\r\n         * progress. Returns the cells whose visible state was changed.\r\n         *\r\n         * show - Boolean that specifies the visible state to be assigned.\r\n         * cells - Array of <mxCells> whose visible state should be changed. If\r\n         * null is specified then the selection cells are used.\r\n         * includeEdges - Optional boolean indicating if the visible state of all\r\n         * connected edges should be changed as well. Default is true.\r\n         */\r\n        toggleCells(show: any, cells: any, includeEdges: any): any;\r\n        /**\r\n         * Sets the visible state of the specified cells.\r\n         *\r\n         * cells - Array of <mxCells> whose visible state should be changed.\r\n         * show - Boolean that specifies the visible state to be assigned.\r\n         */\r\n        cellsToggled(cells: any, show: any): void;\r\n        /**\r\n         * Sets the collapsed state of the specified cells and all descendants\r\n         * if recurse is true. The change is carried out using <cellsFolded>.\r\n         * This method fires <mxEvent.FOLD_CELLS> while the transaction is in\r\n         * progress. Returns the cells whose collapsed state was changed.\r\n         *\r\n         * @param collapsed - Boolean indicating the collapsed state to be assigned.\r\n         * @param recurse - Optional boolean indicating if the collapsed state of all\r\n         * descendants should be set. Default is false.\r\n         * @param cells - Array of <mxCells> whose collapsed state should be set. If\r\n         * null is specified then the foldable selection cells are used.\r\n         * @param checkFoldable - Optional boolean indicating of isCellFoldable should be\r\n         * checked. Default is false.\r\n         * @param evt - Optional native event that triggered the invocation.\r\n         */\r\n        foldCells(collapse: boolean, recurse?: boolean, cells?: mxCell[], checkFoldable?: boolean, evt?: Event): mxCell[];\r\n        /**\r\n         * Sets the collapsed state of the specified cells. This method fires\r\n         * <mxEvent.CELLS_FOLDED> while the transaction is in progress. Returns the\r\n         * cells whose collapsed state was changed.\r\n         *\r\n         * @param cells - Array of <mxCells> whose collapsed state should be set.\r\n         * @param collapsed - Boolean indicating the collapsed state to be assigned.\r\n         * @param recurse - Boolean indicating if the collapsed state of all descendants\r\n         * should be set.\r\n         * @param checkFoldable - Optional boolean indicating of isCellFoldable should be\r\n         * checked. Default is false.\r\n         */\r\n        cellsFolded(cells: mxCell[], collapse: boolean, recurse: boolean, checkFoldable?: boolean): void;\r\n        /**\r\n         * Swaps the alternate and the actual bounds in the geometry of the given\r\n         * cell invoking <updateAlternateBounds> before carrying out the swap.\r\n         *\r\n         * cell - <mxCell> for which the bounds should be swapped.\r\n         * willCollapse - Boolean indicating if the cell is going to be collapsed.\r\n         */\r\n        swapBounds(cell: any, willCollapse: any): void;\r\n        /**\r\n         * Updates or sets the alternate bounds in the given geometry for the given\r\n         * cell depending on whether the cell is going to be collapsed. If no\r\n         * alternate bounds are defined in the geometry and\r\n         * <collapseToPreferredSize> is true, then the preferred size is used for\r\n         * the alternate bounds. The top, left corner is always kept at the same\r\n         * location.\r\n         *\r\n         * cell - <mxCell> for which the geometry is being udpated.\r\n         * g - <mxGeometry> for which the alternate bounds should be updated.\r\n         * willCollapse - Boolean indicating if the cell is going to be collapsed.\r\n         */\r\n        updateAlternateBounds(cell: any, geo: any, willCollapse: any): void;\r\n        /**\r\n         * Returns an array with the given cells and all edges that are connected\r\n         * to a cell or one of its descendants.\r\n         */\r\n        addAllEdges(cells: any): any;\r\n        /**\r\n         * Returns all edges connected to the given cells or its descendants.\r\n         */\r\n        getAllEdges(cells: any): any[];\r\n        /**\r\n         * Updates the size of the given cell in the model using <cellSizeUpdated>.\r\n         * This method fires <mxEvent.UPDATE_CELL_SIZE> while the transaction is in\r\n         * progress. Returns the cell whose size was updated.\r\n         *\r\n         * @param cell - <mxCell> whose size should be updated.\r\n         */\r\n        updateCellSize(cell: mxCell, ignoreChildren?: boolean): mxCell;\r\n        /**\r\n         * Updates the size of the given cell in the model using\r\n         * <getPreferredSizeForCell> to get the new size.\r\n         *\r\n         * cell - <mxCell> for which the size should be changed.\r\n         */\r\n        cellSizeUpdated(cell: any, ignoreChildren: any): void;\r\n        /**\r\n         * Returns the preferred width and height of the given <mxCell> as an\r\n         * <mxRectangle>. To implement a minimum width, add a new style eg.\r\n         * minWidth in the vertex and override this method as follows.\r\n         *\r\n         * (code)\r\n         * var graphGetPreferredSizeForCell = graph.getPreferredSizeForCell;\r\n         * graph.getPreferredSizeForCell = function(cell)\r\n         * {\r\n         *   var result = graphGetPreferredSizeForCell.apply(this, arguments);\r\n         *   var style = this.getCellStyle(cell);\r\n         *\r\n         *   if (style['minWidth'] > 0)\r\n         *   {\r\n         *     result.width = Math.max(style['minWidth'], result.width);\r\n         *   }\r\n         *\r\n         *   return result;\r\n         * };\r\n         * (end)\r\n         *\r\n         * cell - <mxCell> for which the preferred size should be returned.\r\n         */\r\n        getPreferredSizeForCell(cell: any): any;\r\n        /**\r\n         * Sets the bounds of the given cell using <resizeCells>. Returns the\r\n         * cell which was passed to the function.\r\n         *\r\n         * @param cell - <mxCell> whose bounds should be changed.\r\n         * @param bounds - <mxRectangle> that represents the new bounds.\r\n         * @param recurse - Recursively resize children\r\n         */\r\n        resizeCell(cell: mxCell, bounds: mxRectangle, recurse?: any): mxCell;\r\n        /**\r\n         * Sets the bounds of the given cells and fires a <mxEvent.RESIZE_CELLS>\r\n         * event while the transaction is in progress. Returns the cells which\r\n         * have been passed to the function.\r\n         *\r\n         * @param cells - Array of <mxCells> whose bounds should be changed.\r\n         * @param bounds - Array of <mxRectangles> that represent the new bounds.\r\n         * @param recurse - Recursively resize children\r\n         */\r\n        resizeCells(cells: mxCell[], bounds: mxRectangle[], recurse?: any): mxCell[];\r\n        /**\r\n         * Sets the bounds of the given cells and fires a <mxEvent.CELLS_RESIZED>\r\n         * event. If <extendParents> is true, then the parent is extended if a\r\n         * child size is changed so that it overlaps with the parent.\r\n         *\r\n         * The following example shows how to control group resizes to make sure\r\n         * that all child cells stay within the group.\r\n         *\r\n         * @example\r\n         * graph.addListener(mxEvent.CELLS_RESIZED, function(sender, evt)\r\n         * {\r\n         *   var cells = evt.getProperty('cells');\r\n         *\r\n         *   if (cells != null)\r\n         *   {\r\n         *     for (var i = 0; i < cells.length; i++)\r\n         *     {\r\n         *       if (graph.getModel().getChildCount(cells[i]) > 0)\r\n         *       {\r\n         *         var geo = graph.getCellGeometry(cells[i]);\r\n         *\r\n         *         if (geo != null)\r\n         *         {\r\n         *           var children = graph.getChildCells(cells[i], true, true);\r\n         *           var bounds = graph.getBoundingBoxFromGeometry(children, true);\r\n         *\r\n         *           geo = geo.clone();\r\n         *           geo.width = Math.max(geo.width, bounds.width);\r\n         *           geo.height = Math.max(geo.height, bounds.height);\r\n         *\r\n         *           graph.getModel().setGeometry(cells[i], geo);\r\n         *         }\r\n         *       }\r\n         *     }\r\n         *   }\r\n         * });\r\n         *\r\n         * @param cells - Array of <mxCells> whose bounds should be changed.\r\n         * @param bounds - Array of <mxRectangles> that represent the new bounds.\r\n         * @param recurse - Optional boolean that specifies if the children should be resized.\r\n         */\r\n        cellsResized(cells: mxCell[], bounds: mxRectangle[], recurse?: boolean): void;\r\n        /**\r\n         * Resizes the parents recursively so that they contain the complete area\r\n         * of the resized child cell.\r\n         *\r\n         * @param cell - <mxCell> whose bounds should be changed.\r\n         * @param bounds - <mxRectangles> that represent the new bounds.\r\n         * @param ignoreRelative - Boolean that indicates if relative cells should be ignored.\r\n         * @param recurse - Optional boolean that specifies if the children should be resized.\r\n         */\r\n        cellResized(cell: mxCell, bounds: mxRectangle, ignoreRelative: boolean, recurse: boolean): void;\r\n        /**\r\n         * Resizes the child cells of the given cell for the given new geometry with\r\n         * respect to the current geometry of the cell.\r\n         *\r\n         * @param cell - <mxCell> that has been resized.\r\n         * @param newGeo - <mxGeometry> that represents the new bounds.\r\n         */\r\n        resizeChildCells(cell: mxCell, newGeo: mxGeometry): void;\r\n        /**\r\n         * Constrains the children of the given cell using <constrainChild>.\r\n         *\r\n         * cell - <mxCell> that has been resized.\r\n         */\r\n        constrainChildCells(cell: any): void;\r\n        /**\r\n         * Scales the points, position and size of the given cell according to the\r\n         * given vertical and horizontal scaling factors.\r\n         *\r\n         * @param cell - <mxCell> whose geometry should be scaled.\r\n         * @param dx - Horizontal scaling factor.\r\n         * @param dy - Vertical scaling factor.\r\n         * @param recurse - Boolean indicating if the child cells should be scaled.\r\n         */\r\n        scaleCell(cell: mxCell, dx: number, dy: number, recurse: boolean): void;\r\n        /**\r\n         * Resizes the parents recursively so that they contain the complete area\r\n         * of the resized child cell.\r\n         *\r\n         * @param cell - <mxCell> that has been resized.\r\n         */\r\n        extendParent(cell: mxCell): void;\r\n        /**\r\n         * Clones and inserts the given cells into the graph using the move\r\n         * method and returns the inserted cells. This shortcut is used if\r\n         * cells are inserted via datatransfer.\r\n         *\r\n         * @param cells - Array of <mxCells> to be imported.\r\n         * @param dx - Integer that specifies the x-coordinate of the vector. Default is 0.\r\n         * @param dy - Integer that specifies the y-coordinate of the vector. Default is 0.\r\n         * @param target - <mxCell> that represents the new parent of the cells.\r\n         * @param evt - Mouseevent that triggered the invocation.\r\n         * @param mapping - Optional mapping for existing clones.\r\n         */\r\n        importCells(cells: mxCell[], dx: number, dy: number, target: mxCell, evt?: Event, mapping?: any): mxCell[];\r\n        /**\r\n         * Moves or clones the specified cells and moves the cells or clones by the\r\n         * given amount, adding them to the optional target cell. The evt is the\r\n         * mouse event as the mouse was released. The change is carried out using\r\n         * <cellsMoved>. This method fires <mxEvent.MOVE_CELLS> while the\r\n         * transaction is in progress. Returns the cells that were moved.\r\n         *\r\n         * Use the following code to move all cells in the graph.\r\n         *\r\n         * @example graph.moveCells(graph.getChildCells(null, true, true), 10, 10);\r\n         *\r\n         * @param cells - Array of <mxCells> to be moved, cloned or added to the target.\r\n         * @param dx - Integer that specifies the x-coordinate of the vector. Default is 0.\r\n         * @param dy - Integer that specifies the y-coordinate of the vector. Default is 0.\r\n         * @param clone - Boolean indicating if the cells should be cloned. Default is false.\r\n         * @param target - <mxCell> that represents the new parent of the cells.\r\n         * @param evt - Mouseevent that triggered the invocation.\r\n         * @param mapping - Optional mapping for existing clones.\r\n         */\r\n        moveCells(cells: mxCell[], dx?: number, dy?: number, clone?: boolean, target?: mxCell, evt?: Event, mapping?: any): mxCell[];\r\n        /**\r\n         * Moves the specified cells by the given vector, disconnecting the cells\r\n         * using disconnectGraph is disconnect is true. This method fires\r\n         * <mxEvent.CELLS_MOVED> while the transaction is in progress.\r\n         */\r\n        cellsMoved(cells: mxCell[], dx: number, dy: number, disconnect?: boolean, constrain?: boolean, extend?: boolean): void;\r\n        /**\r\n         * Translates the geometry of the given cell and stores the new,\r\n         * translated geometry in the model as an atomic change.\r\n         */\r\n        translateCell(cell: any, dx: any, dy: any): void;\r\n        /**\r\n         * Returns the <mxRectangle> inside which a cell is to be kept.\r\n         *\r\n         * cell - <mxCell> for which the area should be returned.\r\n         */\r\n        getCellContainmentArea(cell: any): mxRectangle;\r\n        /**\r\n         * Returns the bounds inside which the diagram should be kept as an\r\n         * <mxRectangle>.\r\n         */\r\n        getMaximumGraphBounds(): any;\r\n        /**\r\n         * Keeps the given cell inside the bounds returned by\r\n         * <getCellContainmentArea> for its parent, according to the rules defined by\r\n         * <getOverlap> and <isConstrainChild>. This modifies the cell's geometry\r\n         * in-place and does not clone it.\r\n         *\r\n         * cells - <mxCell> which should be constrained.\r\n         * sizeFirst - Specifies if the size should be changed first. Default is true.\r\n         */\r\n        constrainChild(cell: mxCell, sizeFirst?: boolean): void;\r\n        /**\r\n         * Resets the control points of the edges that are connected to the given\r\n         * cells if not both ends of the edge are in the given cells array.\r\n         *\r\n         * cells - Array of <mxCells> for which the connected edges should be\r\n         * reset.\r\n         */\r\n        resetEdges(cells: mxCell[]): void;\r\n        /**\r\n         * Resets the control points of the given edge.\r\n         *\r\n         * edge - <mxCell> whose points should be reset.\r\n         */\r\n        resetEdge(edge: any): any;\r\n        /**\r\n         * Returns the constraint used to connect to the outline of the given state.\r\n         */\r\n        getOutlineConstraint(point: any, terminalState: any, me: any): mxConnectionConstraint;\r\n        /**\r\n         * Returns an array of all <mxConnectionConstraints> for the given terminal. If\r\n         * the shape of the given terminal is a <mxStencilShape> then the constraints\r\n         * of the corresponding <mxStencil> are returned.\r\n         *\r\n         * terminal - <mxCellState> that represents the terminal.\r\n         * source - Boolean that specifies if the terminal is the source or target.\r\n         */\r\n        getAllConnectionConstraints(terminal: any, source: any): mxConnectionConstraint[];\r\n        /**\r\n         * Returns an <mxConnectionConstraint> that describes the given connection\r\n         * point. This result can then be passed to <getConnectionPoint>.\r\n         *\r\n         * @param edge - <mxCellState> that represents the edge.\r\n         * @param terminal - <mxCellState> that represents the terminal.\r\n         * @param source - Boolean indicating if the terminal is the source or target.\r\n         */\r\n        getConnectionConstraint(edge: mxCellState, terminal: mxCellState, source: boolean): mxConnectionConstraint;\r\n        /**\r\n         * Sets the <mxConnectionConstraint> that describes the given connection point.\r\n         * If no constraint is given then nothing is changed. To remove an existing\r\n         * constraint from the given edge, use an empty constraint instead.\r\n         *\r\n         * @param edge - <mxCell> that represents the edge.\r\n         * @param terminal - <mxCell> that represents the terminal.\r\n         * @param source - Boolean indicating if the terminal is the source or target.\r\n         * @param constraint - Optional <mxConnectionConstraint> to be used for this\r\n         * connection.\r\n         */\r\n        setConnectionConstraint(edge: mxCell, terminal: mxCell, source: boolean, constraint?: mxConnectionConstraint): void;\r\n        /**\r\n         * Returns the nearest point in the list of absolute points or the center\r\n         * of the opposite terminal.\r\n         *\r\n         * @param vertex - <mxCellState> that represents the vertex.\r\n         * @param constraint - <mxConnectionConstraint> that represents the connection point\r\n         * constraint as returned by <getConnectionConstraint>.\r\n         */\r\n        getConnectionPoint(vertex: mxCellState, constraint: mxConnectionConstraint): mxPoint;\r\n        /**\r\n         * Connects the specified end of the given edge to the given terminal\r\n         * using <cellConnected> and fires <mxEvent.CONNECT_CELL> while the\r\n         * transaction is in progress. Returns the updated edge.\r\n         *\r\n         * @param edge - <mxCell> whose terminal should be updated.\r\n         * @param terminal - <mxCell> that represents the new terminal to be used.\r\n         * @param source - Boolean indicating if the new terminal is the source or target.\r\n         * @param constraint - Optional <mxConnectionConstraint> to be used for this\r\n         * connection.\r\n         */\r\n        connectCell(edge: mxCell, terminal: mxCell, source: boolean, constraint?: mxConnectionConstraint): mxCell;\r\n        /**\r\n         * Sets the new terminal for the given edge and resets the edge points if\r\n         * <resetEdgesOnConnect> is true. This method fires\r\n         * <mxEvent.CELL_CONNECTED> while the transaction is in progress.\r\n         *\r\n         * @param edge - <mxCell> whose terminal should be updated.\r\n         * @param terminal - <mxCell> that represents the new terminal to be used.\r\n         * @param source - Boolean indicating if the new terminal is the source or target.\r\n         * @param constraint - <mxConnectionConstraint> to be used for this connection.\r\n         */\r\n        cellConnected(edge: mxCell, terminal: mxCell, source: boolean, constraint?: mxConnectionConstraint): void;\r\n        /**\r\n         * Disconnects the given edges from the terminals which are not in the\r\n         * given array.\r\n         *\r\n         * @param cells - Array of <mxCells> to be disconnected.\r\n         */\r\n        disconnectGraph(cells: mxCell[]): void;\r\n        /**\r\n         * Returns the current root of the displayed cell hierarchy. This is a\r\n         * shortcut to <mxGraphView.currentRoot> in <view>.\r\n         */\r\n        getCurrentRoot(): mxCell;\r\n        /**\r\n         * Returns the translation to be used if the given cell is the root cell as\r\n         * an <mxPoint>. This implementation returns null.\r\n         *\r\n         * Example:\r\n         *\r\n         * To keep the children at their absolute position while stepping into groups,\r\n         * this function can be overridden as follows.\r\n         *\r\n         * (code)\r\n         * var offset = new mxPoint(0, 0);\r\n         *\r\n         * while (cell != null)\r\n         * {\r\n         *   var geo = this.model.getGeometry(cell);\r\n         *\r\n         *   if (geo != null)\r\n         *   {\r\n         *     offset.x -= geo.x;\r\n         *     offset.y -= geo.y;\r\n         *   }\r\n         *\r\n         *   cell = this.model.getParent(cell);\r\n         * }\r\n         *\r\n         * return offset;\r\n         * (end)\r\n         *\r\n         * @param cell - <mxCell> that represents the root.\r\n         */\r\n        getTranslateForRoot(cell: mxCell): any;\r\n        /**\r\n         * Returns true if the given cell is a \"port\", that is, when connecting to\r\n         * it, the cell returned by getTerminalForPort should be used as the\r\n         * terminal and the port should be referenced by the ID in either the\r\n         * mxConstants.STYLE_SOURCE_PORT or the or the\r\n         * mxConstants.STYLE_TARGET_PORT. Note that a port should not be movable.\r\n         * This implementation always returns false.\r\n         *\r\n         * A typical implementation is the following:\r\n         *\r\n         * (code)\r\n         * graph.isPort = function(cell)\r\n         * {\r\n         *   var geo = this.getCellGeometry(cell);\r\n         *\r\n         *   return (geo != null) ? geo.relative : false;\r\n         * };\r\n         * (end)\r\n         *\r\n         * @param cell - <mxCell> that represents the port.\r\n         */\r\n        isPort(cell: mxCell): boolean;\r\n        /**\r\n         * Returns the terminal to be used for a given port. This implementation\r\n         * always returns the parent cell.\r\n         *\r\n         * @param cell - <mxCell> that represents the port.\r\n         * @param source - If the cell is the source or target port.\r\n         */\r\n        getTerminalForPort(cell: mxCell, source: any): mxCell;\r\n        /**\r\n         * Returns the offset to be used for the cells inside the given cell. The\r\n         * root and layer cells may be identified using <mxGraphModel.isRoot> and\r\n         * <mxGraphModel.isLayer>. For all other current roots, the\r\n         * <mxGraphView.currentRoot> field points to the respective cell, so that\r\n         * the following holds: cell == this.view.currentRoot. This implementation\r\n         * returns null.\r\n         *\r\n         * @param cell - <mxCell> whose offset should be returned.\r\n         */\r\n        getChildOffsetForCell(cell: mxCell): any;\r\n        /**\r\n         * Uses the given cell as the root of the displayed cell hierarchy. If no\r\n         * cell is specified then the selection cell is used. The cell is only used\r\n         * if <isValidRoot> returns true.\r\n         *\r\n         * @param cell - Optional <mxCell> to be used as the new root. Default is the\r\n         * selection cell.\r\n         */\r\n        enterGroup(cell?: mxCell): void;\r\n        /**\r\n         * Changes the current root to the next valid root in the displayed cell\r\n         * hierarchy.\r\n         */\r\n        exitGroup(): void;\r\n        /**\r\n         * Uses the root of the model as the root of the displayed cell hierarchy\r\n         * and selects the previous root.\r\n         */\r\n        home(): void;\r\n        /**\r\n         * Returns true if the given cell is a valid root for the cell display\r\n         * hierarchy. This implementation returns true for all non-null values.\r\n         *\r\n         * cell - <mxCell> which should be checked as a possible root.\r\n         */\r\n        isValidRoot(cell: any): boolean;\r\n        /**\r\n         * Returns the bounds of the visible graph. Shortcut to\r\n         * <mxGraphView.getGraphBounds>. See also: <getBoundingBoxFromGeometry>.\r\n         */\r\n        getGraphBounds(): mxRectangle;\r\n        /**\r\n         * Returns the scaled, translated bounds for the given cell. See\r\n         * <mxGraphView.getBounds> for arrays.\r\n         *\r\n         * @param cell - <mxCell> whose bounds should be returned.\r\n         * @param includeEdge - Optional boolean that specifies if the bounds of\r\n         * the connected edges should be included. Default is false.\r\n         * @param includeDescendants - Optional boolean that specifies if the bounds\r\n         * of all descendants should be included. Default is false.\r\n         */\r\n        getCellBounds(cell: mxCell, includeEdges?: boolean, includeDescendants?: boolean): mxRectangle;\r\n        /**\r\n         * Returns the bounding box for the geometries of the vertices in the\r\n         * given array of cells. This can be used to find the graph bounds during\r\n         * a layout operation (ie. before the last endUpdate) as follows:\r\n         *\r\n         * (code)\r\n         * var cells = graph.getChildCells(graph.getDefaultParent(), true, true);\r\n         * var bounds = graph.getBoundingBoxFromGeometry(cells, true);\r\n         * (end)\r\n         *\r\n         * This can then be used to move cells to the origin:\r\n         *\r\n         * (code)\r\n         * if (bounds.x < 0 || bounds.y < 0)\r\n         * {\r\n         *   graph.moveCells(cells, -Math.min(bounds.x, 0), -Math.min(bounds.y, 0))\r\n         * }\r\n         * (end)\r\n         *\r\n         * Or to translate the graph view:\r\n         *\r\n         * (code)\r\n         * if (bounds.x < 0 || bounds.y < 0)\r\n         * {\r\n         *   graph.view.setTranslate(-Math.min(bounds.x, 0), -Math.min(bounds.y, 0));\r\n         * }\r\n         * (end)\r\n         *\r\n         * @param cells - Array of <mxCells> whose bounds should be returned.\r\n         * @param includeEdges - Specifies if edge bounds should be included by computing\r\n         * the bounding box for all points in geometry. Default is false.\r\n         */\r\n        getBoundingBoxFromGeometry(cells: mxCell[], includeEdges?: boolean): mxRectangle;\r\n        /**\r\n         * Clears all cell states or the states for the hierarchy starting at the\r\n         * given cell and validates the graph. This fires a refresh event as the\r\n         * last step.\r\n         *\r\n         * @param cell - Optional <mxCell> for which the cell states should be cleared.\r\n         */\r\n        refresh(cell?: mxCell): void;\r\n        /**\r\n         * Snaps the given numeric value to the grid if <gridEnabled> is true.\r\n         *\r\n         * value - Numeric value to be snapped to the grid.\r\n         */\r\n        snap(value: any): any;\r\n        /**\r\n         * Shifts the graph display by the given amount. This is used to preview\r\n         * panning operations, use <mxGraphView.setTranslate> to set a persistent\r\n         * translation of the view. Fires <mxEvent.PAN>.\r\n         *\r\n         * dx - Amount to shift the graph along the x-axis.\r\n         * dy - Amount to shift the graph along the y-axis.\r\n         */\r\n        panGraph(dx: any, dy: any): void;\r\n        /**\r\n         * Zooms into the graph by <zoomFactor>.\r\n         */\r\n        zoomIn(): void;\r\n        /**\r\n         * Zooms out of the graph by <zoomFactor>.\r\n         */\r\n        zoomOut(): void;\r\n        /**\r\n         * Resets the zoom and panning in the view.\r\n         */\r\n        zoomActual(): void;\r\n        /**\r\n         * Zooms the graph to the given scale with an optional boolean center\r\n         * argument, which is passd to <zoom>.\r\n         */\r\n        zoomTo(scale: any, center?: any): void;\r\n        /**\r\n         * Centers the graph in the container.\r\n         *\r\n         * horizontal - Optional boolean that specifies if the graph should be centered\r\n         * horizontally. Default is true.\r\n         * vertical - Optional boolean that specifies if the graph should be centered\r\n         * vertically. Default is true.\r\n         * cx - Optional float that specifies the horizontal center. Default is 0.5.\r\n         * cy - Optional float that specifies the vertical center. Default is 0.5.\r\n         */\r\n        center(horizontal: any, vertical: any, cx: any, cy: any): void;\r\n        /**\r\n         * Zooms the graph using the given factor. Center is an optional boolean\r\n         * argument that keeps the graph scrolled to the center. If the center argument\r\n         * is omitted, then <centerZoom> will be used as its value.\r\n         */\r\n        zoom(factor: number, center?: boolean): void;\r\n        /**\r\n         * Zooms the graph to the specified rectangle. If the rectangle does not have same aspect\r\n         * ratio as the display container, it is increased in the smaller relative dimension only\r\n         * until the aspect match. The original rectangle is centralised within this expanded one.\r\n         *\r\n         * Note that the input rectangular must be un-scaled and un-translated.\r\n         *\r\n         * rect - The un-scaled and un-translated rectangluar region that should be just visible\r\n         * after the operation\r\n         */\r\n        zoomToRect(rect: any): void;\r\n        /**\r\n         * Pans the graph so that it shows the given cell. Optionally the cell may\r\n         * be centered in the container.\r\n         *\r\n         * To center a given graph if the <container> has no scrollbars, use the following code.\r\n         *\r\n         * [code]\r\n         * var bounds = graph.getGraphBounds();\r\n         * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,\r\n         * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);\r\n         * [/code]\r\n         *\r\n         * cell - <mxCell> to be made visible.\r\n         * center - Optional boolean flag. Default is false.\r\n         */\r\n        scrollCellToVisible(cell: any, center?: any): void;\r\n        /**\r\n         * Pans the graph so that it shows the given rectangle.\r\n         *\r\n         * rect - <mxRectangle> to be made visible.\r\n         */\r\n        scrollRectToVisible(rect: any): boolean;\r\n        /**\r\n         * Returns the <mxGeometry> for the given cell. This implementation uses\r\n         * <mxGraphModel.getGeometry>. Subclasses can override this to implement\r\n         * specific geometries for cells in only one graph, that is, it can return\r\n         * geometries that depend on the current state of the view.\r\n         *\r\n         * cell - <mxCell> whose geometry should be returned.\r\n         */\r\n        getCellGeometry(cell: any): mxGeometry;\r\n        /**\r\n         * Returns true if the given cell is visible in this graph. This\r\n         * implementation uses <mxGraphModel.isVisible>. Subclassers can override\r\n         * this to implement specific visibility for cells in only one graph, that\r\n         * is, without affecting the visible state of the cell.\r\n         *\r\n         * When using dynamic filter expressions for cell visibility, then the\r\n         * graph should be revalidated after the filter expression has changed.\r\n         *\r\n         * cell - <mxCell> whose visible state should be returned.\r\n         */\r\n        isCellVisible(cell: any): boolean;\r\n        /**\r\n         * Returns true if the given cell is collapsed in this graph. This\r\n         * implementation uses <mxGraphModel.isCollapsed>. Subclassers can override\r\n         * this to implement specific collapsed states for cells in only one graph,\r\n         * that is, without affecting the collapsed state of the cell.\r\n         *\r\n         * When using dynamic filter expressions for the collapsed state, then the\r\n         * graph should be revalidated after the filter expression has changed.\r\n         *\r\n         * cell - <mxCell> whose collapsed state should be returned.\r\n         */\r\n        isCellCollapsed(cell: any): boolean;\r\n        /**\r\n         * Returns true if the given cell is connectable in this graph. This\r\n         * implementation uses <mxGraphModel.isConnectable>. Subclassers can override\r\n         * this to implement specific connectable states for cells in only one graph,\r\n         * that is, without affecting the connectable state of the cell in the model.\r\n         *\r\n         * cell - <mxCell> whose connectable state should be returned.\r\n         */\r\n        isCellConnectable(cell: any): boolean;\r\n        /**\r\n         * Returns true if perimeter points should be computed such that the\r\n         * resulting edge has only horizontal or vertical segments.\r\n         *\r\n         * edge - <mxCellState> that represents the edge.\r\n         */\r\n        isOrthogonal(edge: mxCellState): any;\r\n        /**\r\n         * Returns true if the given cell state is a loop.\r\n         *\r\n         * state - <mxCellState> that represents a potential loop.\r\n         */\r\n        isLoop(state: any): boolean;\r\n        /**\r\n         * Returns true if the given event is a clone event. This implementation\r\n         * returns true if control is pressed.\r\n         */\r\n        isCloneEvent(evt: any): boolean;\r\n        /**\r\n         * Hook for implementing click-through behaviour on selected cells. If this\r\n         * returns true the cell behind the selected cell will be selected. This\r\n         * implementation returns false;\r\n         */\r\n        isTransparentClickEvent(evt: any): boolean;\r\n        /**\r\n         * Returns true if the given event is a toggle event. This implementation\r\n         * returns true if the meta key (Cmd) is pressed on Macs or if control is\r\n         * pressed on any other platform.\r\n         */\r\n        isToggleEvent(evt: any): boolean;\r\n        /**\r\n         * Returns true if the given mouse event should be aligned to the grid.\r\n         */\r\n        isGridEnabledEvent(evt: any): boolean;\r\n        /**\r\n         * Returns true if the given mouse event should be aligned to the grid.\r\n         */\r\n        isConstrainedEvent(evt: any): boolean;\r\n        /**\r\n         * Returns true if the given mouse event should not allow any connections to be\r\n         * made. This implementation returns false.\r\n         */\r\n        isIgnoreTerminalEvent(evt: any): boolean;\r\n        /**\r\n         * Displays the given validation error in a dialog. This implementation uses\r\n         * mxUtils.alert.\r\n         */\r\n        validationAlert(message: any): void;\r\n        /**\r\n         * Checks if the return value of <getEdgeValidationError> for the given\r\n         * arguments is null.\r\n         *\r\n         * edge - <mxCell> that represents the edge to validate.\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         */\r\n        isEdgeValid(edge: any, source: any, target: any): boolean;\r\n        /**\r\n         * Returns the validation error message to be displayed when inserting or\r\n         * changing an edges' connectivity. A return value of null means the edge\r\n         * is valid, a return value of '' means it's not valid, but do not display\r\n         * an error message. Any other (non-empty) string returned from this method\r\n         * is displayed as an error message when trying to connect an edge to a\r\n         * source and target. This implementation uses the <multiplicities>, and\r\n         * checks <multigraph>, <allowDanglingEdges> and <allowLoops> to generate\r\n         * validation errors.\r\n         *\r\n         * For extending this method with specific checks for source/target cells,\r\n         * the method can be extended as follows. Returning an empty string means\r\n         * the edge is invalid with no error message, a non-null string specifies\r\n         * the error message, and null means the edge is valid.\r\n         *\r\n         * (code)\r\n         * graph.getEdgeValidationError = function(edge, source, target)\r\n         * {\r\n         *   if (source != null && target != null &&\r\n         *     this.model.getValue(source) != null &&\r\n         *     this.model.getValue(target) != null)\r\n         *   {\r\n         *     if (target is not valid for source)\r\n         *     {\r\n         *       return 'Invalid Target';\r\n         *     }\r\n         *   }\r\n         *\r\n         *   // \"Supercall\"\r\n         *   return mxGraph.prototype.getEdgeValidationError.apply(this, arguments);\r\n         * }\r\n         * (end)\r\n         *\r\n         * edge - <mxCell> that represents the edge to validate.\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         */\r\n        getEdgeValidationError(edge: any, source: any, target: any): string;\r\n        /**\r\n         * Hook method for subclassers to return an error message for the given\r\n         * edge and terminals. This implementation returns null.\r\n         *\r\n         * edge - <mxCell> that represents the edge to validate.\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         */\r\n        validateEdge(edge: any, source: any, target: any): any;\r\n        /**\r\n         * Validates the graph by validating each descendant of the given cell or\r\n         * the root of the model. Context is an object that contains the validation\r\n         * state for the complete validation run. The validation errors are\r\n         * attached to their cells using <setCellWarning>. Returns null in the case of\r\n         * successful validation or an array of strings (warnings) in the case of\r\n         * failed validations.\r\n         *\r\n         * Paramters:\r\n         *\r\n         * cell - Optional <mxCell> to start the validation recursion. Default is\r\n         * the graph root.\r\n         * context - Object that represents the global validation state.\r\n         */\r\n        validateGraph(cell: any, context: any): any;\r\n        /**\r\n         * Checks all <multiplicities> that cannot be enforced while the graph is\r\n         * being modified, namely, all multiplicities that require a minimum of\r\n         * 1 edge.\r\n         *\r\n         * cell - <mxCell> for which the multiplicities should be checked.\r\n         */\r\n        getCellValidationError(cell: any): string;\r\n        /**\r\n         * Hook method for subclassers to return an error message for the given\r\n         * cell and validation context. This implementation returns null. Any HTML\r\n         * breaks will be converted to linefeeds in the calling method.\r\n         *\r\n         * cell - <mxCell> that represents the cell to validate.\r\n         * context - Object that represents the global validation state.\r\n         */\r\n        validateCell(cell: any, context: any): any;\r\n        /**\r\n         * Returns the <backgroundImage> as an <mxImage>.\r\n         */\r\n        getBackgroundImage(): mxImage;\r\n        /**\r\n         * Sets the new <backgroundImage>.\r\n         *\r\n         * image - New <mxImage> to be used for the background.\r\n         */\r\n        setBackgroundImage(image: any): void;\r\n        /**\r\n         * Returns the <mxImage> used to display the collapsed state of\r\n         * the specified cell state. This returns null for all edges.\r\n         */\r\n        getFoldingImage(state: any): mxImage;\r\n        /**\r\n         * Returns the textual representation for the given cell. This\r\n         * implementation returns the nodename or string-representation of the user\r\n         * object.\r\n         *\r\n         * Example:\r\n         *\r\n         * The following returns the label attribute from the cells user\r\n         * object if it is an XML node.\r\n         *\r\n         * (code)\r\n         * graph.convertValueToString = function(cell)\r\n         * {\r\n         * \treturn cell.getAttribute('label');\r\n         * }\r\n         * (end)\r\n         *\r\n         * See also: <cellLabelChanged>.\r\n         *\r\n         * cell - <mxCell> whose textual representation should be returned.\r\n         */\r\n        convertValueToString(cell: any): Node | string;\r\n        /**\r\n         * Returns a string or DOM node that represents the label for the given\r\n         * cell. This implementation uses <convertValueToString> if <labelsVisible>\r\n         * is true. Otherwise it returns an empty string.\r\n         *\r\n         * To truncate a label to match the size of the cell, the following code\r\n         * can be used.\r\n         *\r\n         * (code)\r\n         * graph.getLabel = function(cell)\r\n         * {\r\n         *   var label = mxGraph.prototype.getLabel.apply(this, arguments);\r\n         *\r\n         *   if (label != null && this.model.isVertex(cell))\r\n         *   {\r\n         *     var geo = this.getCellGeometry(cell);\r\n         *\r\n         *     if (geo != null)\r\n         *     {\r\n         *       var max = parseInt(geo.width / 8);\r\n         *\r\n         *       if (label.length > max)\r\n         *       {\r\n         *         label = label.substring(0, max)+'...';\r\n         *       }\r\n         *     }\r\n         *   }\r\n         *   return mxUtils.htmlEntities(label);\r\n         * }\r\n         * (end)\r\n         *\r\n         * A resize listener is needed in the graph to force a repaint of the label\r\n         * after a resize.\r\n         *\r\n         * (code)\r\n         * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)\r\n         * {\r\n         *   var cells = evt.getProperty('cells');\r\n         *\r\n         *   for (var i = 0; i < cells.length; i++)\r\n         *   {\r\n         *     this.view.removeState(cells[i]);\r\n         *   }\r\n         * });\r\n         * (end)\r\n         *\r\n         * cell - <mxCell> whose label should be returned.\r\n         */\r\n        getLabel(cell: any): string;\r\n        /**\r\n         * Returns true if the label must be rendered as HTML markup. The default\r\n         * implementation returns <htmlLabels>.\r\n         *\r\n         * cell - <mxCell> whose label should be displayed as HTML markup.\r\n         */\r\n        isHtmlLabel(cell: any): boolean;\r\n        /**\r\n         * Returns <htmlLabels>.\r\n         */\r\n        isHtmlLabels(): boolean;\r\n        /**\r\n         * Sets <htmlLabels>.\r\n         */\r\n        setHtmlLabels(value: any): void;\r\n        /**\r\n         * This enables wrapping for HTML labels.\r\n         *\r\n         * Returns true if no white-space CSS style directive should be used for\r\n         * displaying the given cells label. This implementation returns true if\r\n         * <mxConstants.STYLE_WHITE_SPACE> in the style of the given cell is 'wrap'.\r\n         *\r\n         * This is used as a workaround for IE ignoring the white-space directive\r\n         * of child elements if the directive appears in a parent element. It\r\n         * should be overridden to return true if a white-space directive is used\r\n         * in the HTML markup that represents the given cells label. In order for\r\n         * HTML markup to work in labels, <isHtmlLabel> must also return true\r\n         * for the given cell.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * graph.getLabel = function(cell)\r\n         * {\r\n         *   var tmp = mxGraph.prototype.getLabel.apply(this, arguments); // \"supercall\"\r\n         *\r\n         *   if (this.model.isEdge(cell))\r\n         *   {\r\n         *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';\r\n         *   }\r\n         *\r\n         *   return tmp;\r\n         * }\r\n         *\r\n         * graph.isWrapping = function(state)\r\n         * {\r\n         * \t return this.model.isEdge(state.cell);\r\n         * }\r\n         * (end)\r\n         *\r\n         * Makes sure no edge label is wider than 150 pixels, otherwise the content\r\n         * is wrapped. Note: No width must be specified for wrapped vertex labels as\r\n         * the vertex defines the width in its geometry.\r\n         *\r\n         * state - <mxCell> whose label should be wrapped.\r\n         */\r\n        isWrapping(cell: any): boolean;\r\n        /**\r\n         * Returns true if the overflow portion of labels should be hidden. If this\r\n         * returns true then vertex labels will be clipped to the size of the vertices.\r\n         * This implementation returns true if <mxConstants.STYLE_OVERFLOW> in the\r\n         * style of the given cell is 'hidden'.\r\n         *\r\n         * state - <mxCell> whose label should be clipped.\r\n         */\r\n        isLabelClipped(cell: any): boolean;\r\n        /**\r\n         * Returns the string or DOM node that represents the tooltip for the given\r\n         * state, node and coordinate pair. This implementation checks if the given\r\n         * node is a folding icon or overlay and returns the respective tooltip. If\r\n         * this does not result in a tooltip, the handler for the cell is retrieved\r\n         * from <selectionCellsHandler> and the optional getTooltipForNode method is\r\n         * called. If no special tooltip exists here then <getTooltipForCell> is used\r\n         * with the cell in the given state as the argument to return a tooltip for the\r\n         * given state.\r\n         *\r\n         * state - <mxCellState> whose tooltip should be returned.\r\n         * node - DOM node that is currently under the mouse.\r\n         * x - X-coordinate of the mouse.\r\n         * y - Y-coordinate of the mouse.\r\n         */\r\n        getTooltip(state: any, node: any, x: any, y: any): any;\r\n        /**\r\n         * Returns the string or DOM node to be used as the tooltip for the given\r\n         * cell. This implementation uses the cells getTooltip function if it\r\n         * exists, or else it returns <convertValueToString> for the cell.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * graph.getTooltipForCell = function(cell)\r\n         * {\r\n         *   return 'Hello, World!';\r\n         * }\r\n         * (end)\r\n         *\r\n         * Replaces all tooltips with the string Hello, World!\r\n         *\r\n         * cell - <mxCell> whose tooltip should be returned.\r\n         */\r\n        getTooltipForCell(cell: any): any;\r\n        /**\r\n         * Returns the cursor value to be used for the CSS of the shape for the\r\n         * given event. This implementation calls <getCursorForCell>.\r\n         *\r\n         * me - <mxMouseEvent> whose cursor should be returned.\r\n         */\r\n        getCursorForMouseEvent(me: any): any;\r\n        /**\r\n         * Returns the cursor value to be used for the CSS of the shape for the\r\n         * given cell. This implementation returns null.\r\n         *\r\n         * cell - <mxCell> whose cursor should be returned.\r\n         */\r\n        getCursorForCell(cell: any): any;\r\n        /**\r\n         * Returns the start size of the given swimlane, that is, the width or\r\n         * height of the part that contains the title, depending on the\r\n         * horizontal style. The return value is an <mxRectangle> with either\r\n         * width or height set as appropriate.\r\n         *\r\n         * swimlane - <mxCell> whose start size should be returned.\r\n         */\r\n        getStartSize(swimlane: any): mxRectangle;\r\n        /**\r\n         * Returns the image URL for the given cell state. This implementation\r\n         * returns the value stored under <mxConstants.STYLE_IMAGE> in the cell\r\n         * style.\r\n         *\r\n         * state - <mxCellState> whose image URL should be returned.\r\n         */\r\n        getImage(state: any): any;\r\n        /**\r\n         * Returns the vertical alignment for the given cell state. This\r\n         * implementation returns the value stored under\r\n         * <mxConstants.STYLE_VERTICAL_ALIGN> in the cell style.\r\n         *\r\n         * state - <mxCellState> whose vertical alignment should be\r\n         * returned.\r\n         */\r\n        getVerticalAlign(state: any): any;\r\n        /**\r\n         * Returns the indicator color for the given cell state. This\r\n         * implementation returns the value stored under\r\n         * <mxConstants.STYLE_INDICATOR_COLOR> in the cell style.\r\n         *\r\n         * state - <mxCellState> whose indicator color should be\r\n         * returned.\r\n         */\r\n        getIndicatorColor(state: any): any;\r\n        /**\r\n         * Returns the indicator gradient color for the given cell state. This\r\n         * implementation returns the value stored under\r\n         * <mxConstants.STYLE_INDICATOR_GRADIENTCOLOR> in the cell style.\r\n         *\r\n         * state - <mxCellState> whose indicator gradient color should be\r\n         * returned.\r\n         */\r\n        getIndicatorGradientColor(state: any): any;\r\n        /**\r\n         * Returns the indicator shape for the given cell state. This\r\n         * implementation returns the value stored under\r\n         * <mxConstants.STYLE_INDICATOR_SHAPE> in the cell style.\r\n         *\r\n         * state - <mxCellState> whose indicator shape should be returned.\r\n         */\r\n        getIndicatorShape(state: any): any;\r\n        /**\r\n         * Returns the indicator image for the given cell state. This\r\n         * implementation returns the value stored under\r\n         * <mxConstants.STYLE_INDICATOR_IMAGE> in the cell style.\r\n         *\r\n         * state - <mxCellState> whose indicator image should be returned.\r\n         */\r\n        getIndicatorImage(state: any): any;\r\n        /**\r\n         * Returns the value of <border>.\r\n         */\r\n        getBorder(): number;\r\n        /**\r\n         * Sets the value of <border>.\r\n         *\r\n         * value - Positive integer that represents the border to be used.\r\n         */\r\n        setBorder(value: any): void;\r\n        /**\r\n         * Returns true if the given cell is a swimlane in the graph. A swimlane is\r\n         * a container cell with some specific behaviour. This implementation\r\n         * checks if the shape associated with the given cell is a <mxSwimlane>.\r\n         *\r\n         * cell - <mxCell> to be checked.\r\n         */\r\n        isSwimlane(cell: any): boolean;\r\n        /**\r\n         * Returns <resizeContainer>.\r\n         */\r\n        isResizeContainer(): boolean;\r\n        /**\r\n         * Sets <resizeContainer>.\r\n         *\r\n         * value - Boolean indicating if the container should be resized.\r\n         */\r\n        setResizeContainer(value: any): void;\r\n        /**\r\n         * Returns true if the graph is <enabled>.\r\n         */\r\n        isEnabled(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow any interactions. This\r\n         * implementation updates <enabled>.\r\n         *\r\n         * value - Boolean indicating if the graph should be enabled.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Returns <escapeEnabled>.\r\n         */\r\n        isEscapeEnabled(): boolean;\r\n        /**\r\n         * Sets <escapeEnabled>.\r\n         *\r\n         * enabled - Boolean indicating if escape should be enabled.\r\n         */\r\n        setEscapeEnabled(value: any): void;\r\n        /**\r\n         * Returns <invokesStopCellEditing>.\r\n         */\r\n        isInvokesStopCellEditing(): boolean;\r\n        /**\r\n         * Sets <invokesStopCellEditing>.\r\n         */\r\n        setInvokesStopCellEditing(value: any): void;\r\n        /**\r\n         * Returns <enterStopsCellEditing>.\r\n         */\r\n        isEnterStopsCellEditing(): boolean;\r\n        /**\r\n         * Sets <enterStopsCellEditing>.\r\n         */\r\n        setEnterStopsCellEditing(value: any): void;\r\n        /**\r\n         * Returns true if the given cell may not be moved, sized, bended,\r\n         * disconnected, edited or selected. This implementation returns true for\r\n         * all vertices with a relative geometry if <locked> is false.\r\n         *\r\n         * cell - <mxCell> whose locked state should be returned.\r\n         */\r\n        isCellLocked(cell: any): boolean;\r\n        /**\r\n         * Returns true if the given cell may not be moved, sized, bended,\r\n         * disconnected, edited or selected. This implementation returns true for\r\n         * all vertices with a relative geometry if <locked> is false.\r\n         *\r\n         * cell - <mxCell> whose locked state should be returned.\r\n         */\r\n        isCellsLocked(): boolean;\r\n        /**\r\n         * Sets if any cell may be moved, sized, bended, disconnected, edited or\r\n         * selected.\r\n         *\r\n         * value - Boolean that defines the new value for <cellsLocked>.\r\n         */\r\n        setCellsLocked(value: any): void;\r\n        /**\r\n         * Returns the cells which may be exported in the given array of cells.\r\n         */\r\n        getCloneableCells(cells: any): mxCell[];\r\n        /**\r\n         * Returns true if the given cell is cloneable. This implementation returns\r\n         * <isCellsCloneable> for all cells unless a cell style specifies\r\n         * <mxConstants.STYLE_CLONEABLE> to be 0.\r\n         *\r\n         * cell - Optional <mxCell> whose cloneable state should be returned.\r\n         */\r\n        isCellCloneable(cell: any): boolean;\r\n        /**\r\n         * Returns <cellsCloneable>, that is, if the graph allows cloning of cells\r\n         * by using control-drag.\r\n         */\r\n        isCellsCloneable(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow cloning of cells by holding down the\r\n         * control key while cells are being moved. This implementation updates\r\n         * <cellsCloneable>.\r\n         *\r\n         * value - Boolean indicating if the graph should be cloneable.\r\n         */\r\n        setCellsCloneable(value: any): void;\r\n        /**\r\n         * Returns the cells which may be exported in the given array of cells.\r\n         */\r\n        getExportableCells(cells: any): mxCell[];\r\n        /**\r\n         * Returns true if the given cell may be exported to the clipboard. This\r\n         * implementation returns <exportEnabled> for all cells.\r\n         *\r\n         * cell - <mxCell> that represents the cell to be exported.\r\n         */\r\n        canExportCell(cell: any): boolean;\r\n        /**\r\n         * Returns the cells which may be imported in the given array of cells.\r\n         */\r\n        getImportableCells(cells: any): mxCell[];\r\n        /**\r\n         * Returns true if the given cell may be imported from the clipboard.\r\n         * This implementation returns <importEnabled> for all cells.\r\n         *\r\n         * cell - <mxCell> that represents the cell to be imported.\r\n         */\r\n        canImportCell(cell: any): boolean;\r\n        /**\r\n         * Returns true if the given cell is selectable. This implementation\r\n         * returns <cellsSelectable>.\r\n         *\r\n         * To add a new style for making cells (un)selectable, use the following code.\r\n         *\r\n         * (code)\r\n         * mxGraph.prototype.isCellSelectable = function(cell)\r\n         * {\r\n         *   var state = this.view.getState(cell);\r\n         *   var style = (state != null) ? state.style : this.getCellStyle(cell);\r\n         *\r\n         *   return this.isCellsSelectable() && !this.isCellLocked(cell) && style['selectable'] != 0;\r\n         * };\r\n         * (end)\r\n         *\r\n         * You can then use the new style as shown in this example.\r\n         *\r\n         * (code)\r\n         * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'selectable=0');\r\n         * (end)\r\n         *\r\n         * cell - <mxCell> whose selectable state should be returned.\r\n         */\r\n        isCellSelectable(cell: any): boolean;\r\n        /**\r\n         * Returns <cellsSelectable>.\r\n         */\r\n        isCellsSelectable(): boolean;\r\n        /**\r\n         * Sets <cellsSelectable>.\r\n         */\r\n        setCellsSelectable(value: any): void;\r\n        /**\r\n         * Returns the cells which may be exported in the given array of cells.\r\n         */\r\n        getDeletableCells(cells: any): mxCell[];\r\n        /**\r\n         * Returns true if the given cell is moveable. This returns\r\n         * <cellsDeletable> for all given cells if a cells style does not specify\r\n         * <mxConstants.STYLE_DELETABLE> to be 0.\r\n         *\r\n         * cell - <mxCell> whose deletable state should be returned.\r\n         */\r\n        isCellDeletable(cell: any): boolean;\r\n        /**\r\n         * Returns <cellsDeletable>.\r\n         */\r\n        isCellsDeletable(): boolean;\r\n        /**\r\n         * Sets <cellsDeletable>.\r\n         *\r\n         * value - Boolean indicating if the graph should allow deletion of cells.\r\n         */\r\n        setCellsDeletable(value: any): void;\r\n        /**\r\n         * Returns true if the given edges's label is moveable. This returns\r\n         * <movable> for all given cells if <isLocked> does not return true\r\n         * for the given cell.\r\n         *\r\n         * cell - <mxCell> whose label should be moved.\r\n         */\r\n        isLabelMovable(cell: any): boolean;\r\n        /**\r\n         * Returns true if the given cell is rotatable. This returns true for the given\r\n         * cell if its style does not specify <mxConstants.STYLE_ROTATABLE> to be 0.\r\n         *\r\n         * cell - <mxCell> whose rotatable state should be returned.\r\n         */\r\n        isCellRotatable(cell: any): boolean;\r\n        /**\r\n         * Returns the cells which are movable in the given array of cells.\r\n         */\r\n        getMovableCells(cells: any): mxCell[];\r\n        /**\r\n         * Returns true if the given cell is moveable. This returns <cellsMovable>\r\n         * for all given cells if <isCellLocked> does not return true for the given\r\n         * cell and its style does not specify <mxConstants.STYLE_MOVABLE> to be 0.\r\n         *\r\n         * cell - <mxCell> whose movable state should be returned.\r\n         */\r\n        isCellMovable(cell: any): boolean;\r\n        /**\r\n         * Returns <cellsMovable>.\r\n         */\r\n        isCellsMovable(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow moving of cells. This implementation\r\n         * updates <cellsMsovable>.\r\n         *\r\n         * value - Boolean indicating if the graph should allow moving of cells.\r\n         */\r\n        setCellsMovable(value: any): void;\r\n        /**\r\n         * Returns <gridEnabled> as a boolean.\r\n         */\r\n        isGridEnabled(): boolean;\r\n        /**\r\n         * Specifies if the grid should be enabled.\r\n         *\r\n         * value - Boolean indicating if the grid should be enabled.\r\n         */\r\n        setGridEnabled(value: any): void;\r\n        /**\r\n         * Returns <portsEnabled> as a boolean.\r\n         */\r\n        isPortsEnabled(): boolean;\r\n        /**\r\n         * Specifies if the ports should be enabled.\r\n         *\r\n         * value - Boolean indicating if the ports should be enabled.\r\n         */\r\n        setPortsEnabled(value: any): void;\r\n        /**\r\n         * Returns <gridSize>.\r\n         */\r\n        getGridSize(): number;\r\n        /**\r\n         * Sets <gridSize>.\r\n         */\r\n        setGridSize(value: any): void;\r\n        /**\r\n         * Returns <tolerance>.\r\n         */\r\n        getTolerance(): number;\r\n        /**\r\n         * Sets <tolerance>.\r\n         */\r\n        setTolerance(value: any): void;\r\n        /**\r\n         * Returns <vertexLabelsMovable>.\r\n         */\r\n        isVertexLabelsMovable(): boolean;\r\n        /**\r\n         * Sets <vertexLabelsMovable>.\r\n         */\r\n        setVertexLabelsMovable(value: any): void;\r\n        /**\r\n         * Returns <edgeLabelsMovable>.\r\n         */\r\n        isEdgeLabelsMovable(): boolean;\r\n        /**\r\n         * Sets <edgeLabelsMovable>.\r\n         */\r\n        setEdgeLabelsMovable(value: any): void;\r\n        /**\r\n         * Returns <swimlaneNesting> as a boolean.\r\n         */\r\n        isSwimlaneNesting(): boolean;\r\n        /**\r\n         * Specifies if swimlanes can be nested by drag and drop. This is only\r\n         * taken into account if dropEnabled is true.\r\n         *\r\n         * value - Boolean indicating if swimlanes can be nested.\r\n         */\r\n        setSwimlaneNesting(value: any): void;\r\n        /**\r\n         * Returns <swimlaneSelectionEnabled> as a boolean.\r\n         */\r\n        isSwimlaneSelectionEnabled(): boolean;\r\n        /**\r\n         * Specifies if swimlanes should be selected if the mouse is released\r\n         * over their content area.\r\n         *\r\n         * value - Boolean indicating if swimlanes content areas\r\n         * should be selected when the mouse is released over them.\r\n         */\r\n        setSwimlaneSelectionEnabled(value: any): void;\r\n        /**\r\n         * Returns <multigraph> as a boolean.\r\n         */\r\n        isMultigraph(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow multiple connections between the\r\n         * same pair of vertices.\r\n         *\r\n         * value - Boolean indicating if the graph allows multiple connections\r\n         * between the same pair of vertices.\r\n         */\r\n        setMultigraph(value: any): void;\r\n        /**\r\n         * Returns <allowLoops> as a boolean.\r\n         */\r\n        isAllowLoops(): boolean;\r\n        /**\r\n         * Specifies if dangling edges are allowed, that is, if edges are allowed\r\n         * that do not have a source and/or target terminal defined.\r\n         *\r\n         * value - Boolean indicating if dangling edges are allowed.\r\n         */\r\n        setAllowDanglingEdges(value: any): void;\r\n        /**\r\n         * Returns <allowDanglingEdges> as a boolean.\r\n         */\r\n        isAllowDanglingEdges(): boolean;\r\n        /**\r\n         * Specifies if edges should be connectable.\r\n         *\r\n         * value - Boolean indicating if edges should be connectable.\r\n         */\r\n        setConnectableEdges(value: any): void;\r\n        /**\r\n         * Returns <connectableEdges> as a boolean.\r\n         */\r\n        isConnectableEdges(): boolean;\r\n        /**\r\n         * Specifies if edges should be inserted when cloned but not valid wrt.\r\n         * <getEdgeValidationError>. If false such edges will be silently ignored.\r\n         *\r\n         * value - Boolean indicating if cloned invalid edges should be\r\n         * inserted into the graph or ignored.\r\n         */\r\n        setCloneInvalidEdges(value: any): void;\r\n        /**\r\n         * Returns <cloneInvalidEdges> as a boolean.\r\n         */\r\n        isCloneInvalidEdges(): boolean;\r\n        /**\r\n         * Specifies if loops are allowed.\r\n         *\r\n         * value - Boolean indicating if loops are allowed.\r\n         */\r\n        setAllowLoops(value: any): void;\r\n        /**\r\n         * Returns <disconnectOnMove> as a boolean.\r\n         */\r\n        isDisconnectOnMove(): boolean;\r\n        /**\r\n         * Specifies if edges should be disconnected when moved. (Note: Cloned\r\n         * edges are always disconnected.)\r\n         *\r\n         * value - Boolean indicating if edges should be disconnected\r\n         * when moved.\r\n         */\r\n        setDisconnectOnMove(value: any): void;\r\n        /**\r\n         * Returns <dropEnabled> as a boolean.\r\n         */\r\n        isDropEnabled(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow dropping of cells onto or into other\r\n         * cells.\r\n         *\r\n         * dropEnabled - Boolean indicating if the graph should allow dropping\r\n         * of cells into other cells.\r\n         */\r\n        setDropEnabled(value: any): void;\r\n        /**\r\n         * Returns <splitEnabled> as a boolean.\r\n         */\r\n        isSplitEnabled(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow dropping of cells onto or into other\r\n         * cells.\r\n         *\r\n         * dropEnabled - Boolean indicating if the graph should allow dropping\r\n         * of cells into other cells.\r\n         */\r\n        setSplitEnabled(value: any): void;\r\n        /**\r\n         * Returns true if the given cell is resizable. This returns\r\n         * <cellsResizable> for all given cells if <isCellLocked> does not return\r\n         * true for the given cell and its style does not specify\r\n         * <mxConstants.STYLE_RESIZABLE> to be 0.\r\n         *\r\n         * cell - <mxCell> whose resizable state should be returned.\r\n         */\r\n        isCellResizable(cell: any): boolean;\r\n        /**\r\n         * Returns <cellsResizable>.\r\n         */\r\n        isCellsResizable(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow resizing of cells. This\r\n         * implementation updates <cellsResizable>.\r\n         *\r\n         * value - Boolean indicating if the graph should allow resizing of\r\n         * cells.\r\n         */\r\n        setCellsResizable(value: any): void;\r\n        /**\r\n         * Returns true if the given terminal point is movable. This is independent\r\n         * from <isCellConnectable> and <isCellDisconnectable> and controls if terminal\r\n         * points can be moved in the graph if the edge is not connected. Note that it\r\n         * is required for this to return true to connect unconnected edges. This\r\n         * implementation returns true.\r\n         *\r\n         * cell - <mxCell> whose terminal point should be moved.\r\n         * source - Boolean indicating if the source or target terminal should be moved.\r\n         */\r\n        isTerminalPointMovable(cell: any, source: any): boolean;\r\n        /**\r\n         * Returns true if the given cell is bendable. This returns <cellsBendable>\r\n         * for all given cells if <isLocked> does not return true for the given\r\n         * cell and its style does not specify <mxConstants.STYLE_BENDABLE> to be 0.\r\n         *\r\n         * cell - <mxCell> whose bendable state should be returned.\r\n         */\r\n        isCellBendable(cell: any): boolean;\r\n        /**\r\n         * Returns <cellsBenadable>.\r\n         */\r\n        isCellsBendable(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow bending of edges. This\r\n         * implementation updates <bendable>.\r\n         *\r\n         * value - Boolean indicating if the graph should allow bending of\r\n         * edges.\r\n         */\r\n        setCellsBendable(value: any): void;\r\n        /**\r\n         * Returns true if the given cell is editable. This returns <cellsEditable> for\r\n         * all given cells if <isCellLocked> does not return true for the given cell\r\n         * and its style does not specify <mxConstants.STYLE_EDITABLE> to be 0.\r\n         *\r\n         * cell - <mxCell> whose editable state should be returned.\r\n         */\r\n        isCellEditable(cell: any): boolean;\r\n        /**\r\n         * Returns <cellsEditable>.\r\n         */\r\n        isCellsEditable(): boolean;\r\n        /**\r\n         * Specifies if the graph should allow in-place editing for cell labels.\r\n         * This implementation updates <cellsEditable>.\r\n         *\r\n         * value - Boolean indicating if the graph should allow in-place\r\n         * editing.\r\n         */\r\n        setCellsEditable(value: any): void;\r\n        /**\r\n         * Returns true if the given cell is disconnectable from the source or\r\n         * target terminal. This returns <isCellsDisconnectable> for all given\r\n         * cells if <isCellLocked> does not return true for the given cell.\r\n         *\r\n         * cell - <mxCell> whose disconnectable state should be returned.\r\n         * terminal - <mxCell> that represents the source or target terminal.\r\n         * source - Boolean indicating if the source or target terminal is to be\r\n         * disconnected.\r\n         */\r\n        isCellDisconnectable(cell: any, terminal: any, source: any): boolean;\r\n        /**\r\n         * Returns <cellsDisconnectable>.\r\n         */\r\n        isCellsDisconnectable(): boolean;\r\n        /**\r\n         * Sets <cellsDisconnectable>.\r\n         */\r\n        setCellsDisconnectable(value: any): void;\r\n        /**\r\n         * Returns true if the given cell is a valid source for new connections.\r\n         * This implementation returns true for all non-null values and is\r\n         * called by is called by <isValidConnection>.\r\n         *\r\n         * cell - <mxCell> that represents a possible source or null.\r\n         */\r\n        isValidSource(cell: any): boolean;\r\n        /**\r\n         * Returns <isValidSource> for the given cell. This is called by\r\n         * <isValidConnection>.\r\n         *\r\n         * cell - <mxCell> that represents a possible target or null.\r\n         */\r\n        isValidTarget(cell: any): boolean;\r\n        /**\r\n         * Returns true if the given target cell is a valid target for source.\r\n         * This is a boolean implementation for not allowing connections between\r\n         * certain pairs of vertices and is called by <getEdgeValidationError>.\r\n         * This implementation returns true if <isValidSource> returns true for\r\n         * the source and <isValidTarget> returns true for the target.\r\n         *\r\n         * source - <mxCell> that represents the source cell.\r\n         * target - <mxCell> that represents the target cell.\r\n         */\r\n        isValidConnection(source: any, target: any): boolean;\r\n        /**\r\n         * Specifies if the graph should allow new connections. This implementation\r\n         * updates <mxConnectionHandler.enabled> in <connectionHandler>.\r\n         *\r\n         * connectable - Boolean indicating if new connections should be allowed.\r\n         */\r\n        setConnectable(connectable: any): void;\r\n        /**\r\n         * Returns true if the <connectionHandler> is enabled.\r\n         */\r\n        isConnectable(connectable: any): boolean;\r\n        /**\r\n         * Specifies if tooltips should be enabled. This implementation updates\r\n         * <mxTooltipHandler.enabled> in <tooltipHandler>.\r\n         *\r\n         * enabled - Boolean indicating if tooltips should be enabled.\r\n         */\r\n        setTooltips(enabled: any): void;\r\n        /**\r\n         * Specifies if panning should be enabled. This implementation updates\r\n         * <mxPanningHandler.panningEnabled> in <panningHandler>.\r\n         *\r\n         * enabled - Boolean indicating if panning should be enabled.\r\n         */\r\n        setPanning(enabled: any): void;\r\n        /**\r\n         * Returns true if the given cell is currently being edited.\r\n         * If no cell is specified then this returns true if any\r\n         * cell is currently being edited.\r\n         *\r\n         * @param cell - <mxCell> that should be checked.\r\n         */\r\n        isEditing(cell?: mxCell): boolean;\r\n        /**\r\n         * Returns true if the size of the given cell should automatically be\r\n         * updated after a change of the label. This implementation returns\r\n         * <autoSizeCells> or checks if the cell style does specify\r\n         * <mxConstants.STYLE_AUTOSIZE> to be 1.\r\n         *\r\n         * cell - <mxCell> that should be resized.\r\n         */\r\n        isAutoSizeCell(cell: any): boolean;\r\n        /**\r\n         * Returns <autoSizeCells>.\r\n         */\r\n        isAutoSizeCells(): boolean;\r\n        /**\r\n         * Specifies if cell sizes should be automatically updated after a label\r\n         * change. This implementation sets <autoSizeCells> to the given parameter.\r\n         * To update the size of cells when the cells are added, set\r\n         * <autoSizeCellsOnAdd> to true.\r\n         *\r\n         * value - Boolean indicating if cells should be resized\r\n         * automatically.\r\n         */\r\n        setAutoSizeCells(value: any): void;\r\n        /**\r\n         * Returns true if the parent of the given cell should be extended if the\r\n         * child has been resized so that it overlaps the parent. This\r\n         * implementation returns <isExtendParents> if the cell is not an edge.\r\n         *\r\n         * cell - <mxCell> that has been resized.\r\n         */\r\n        isExtendParent(cell: any): boolean;\r\n        /**\r\n         * Returns <extendParents>.\r\n         */\r\n        isExtendParents(): boolean;\r\n        /**\r\n         * Sets <extendParents>.\r\n         *\r\n         * value - New boolean value for <extendParents>.\r\n         */\r\n        setExtendParents(value: any): void;\r\n        /**\r\n         * Returns <extendParentsOnAdd>.\r\n         */\r\n        isExtendParentsOnAdd(cell: any): boolean;\r\n        /**\r\n         * Sets <extendParentsOnAdd>.\r\n         *\r\n         * value - New boolean value for <extendParentsOnAdd>.\r\n         */\r\n        setExtendParentsOnAdd(value: any): void;\r\n        /**\r\n         * Returns <extendParentsOnMove>.\r\n         */\r\n        isExtendParentsOnMove(): boolean;\r\n        /**\r\n         * Sets <extendParentsOnMove>.\r\n         *\r\n         * value - New boolean value for <extendParentsOnAdd>.\r\n         */\r\n        setExtendParentsOnMove(value: any): void;\r\n        /**\r\n         * Returns <recursiveResize>.\r\n         *\r\n         * state - <mxCellState> that is being resized.\r\n         */\r\n        isRecursiveResize(state?: mxCellState): boolean;\r\n        /**\r\n         * Sets <recursiveResize>.\r\n         *\r\n         * value - New boolean value for <recursiveResize>.\r\n         */\r\n        setRecursiveResize(value: any): void;\r\n        /**\r\n         * Returns true if the given cell should be kept inside the bounds of its\r\n         * parent according to the rules defined by <getOverlap> and\r\n         * <isAllowOverlapParent>. This implementation returns false for all children\r\n         * of edges and <isConstrainChildren> otherwise.\r\n         *\r\n         * cell - <mxCell> that should be constrained.\r\n         */\r\n        isConstrainChild(cell: any): boolean;\r\n        /**\r\n         * Returns <constrainChildren>.\r\n         */\r\n        isConstrainChildren(): boolean;\r\n        /**\r\n         * Sets <constrainChildren>.\r\n         */\r\n        setConstrainChildren(value: any): void;\r\n        /**\r\n         * Returns <constrainRelativeChildren>.\r\n         */\r\n        isConstrainRelativeChildren(): boolean;\r\n        /**\r\n         * Sets <constrainRelativeChildren>.\r\n         */\r\n        setConstrainRelativeChildren(value: any): void;\r\n        /**\r\n         * Returns <allowNegativeCoordinates>.\r\n         */\r\n        isAllowNegativeCoordinates(): boolean;\r\n        /**\r\n         * Sets <allowNegativeCoordinates>.\r\n         */\r\n        setAllowNegativeCoordinates(value: any): void;\r\n        /**\r\n         * Returns a decimal number representing the amount of the width and height\r\n         * of the given cell that is allowed to overlap its parent. A value of 0\r\n         * means all children must stay inside the parent, 1 means the child is\r\n         * allowed to be placed outside of the parent such that it touches one of\r\n         * the parents sides. If <isAllowOverlapParent> returns false for the given\r\n         * cell, then this method returns 0.\r\n         *\r\n         * cell - <mxCell> for which the overlap ratio should be returned.\r\n         */\r\n        getOverlap(cell: any): number;\r\n        /**\r\n         * Returns true if the given cell is allowed to be placed outside of the\r\n         * parents area.\r\n         *\r\n         * cell - <mxCell> that represents the child to be checked.\r\n         */\r\n        isAllowOverlapParent(cell: any): boolean;\r\n        /**\r\n         * Returns the cells which are movable in the given array of cells.\r\n         */\r\n        getFoldableCells(cells: any, collapse: any): mxCell[];\r\n        /**\r\n         * Returns true if the given cell is foldable. This implementation\r\n         * returns true if the cell has at least one child and its style\r\n         * does not specify <mxConstants.STYLE_FOLDABLE> to be 0.\r\n         *\r\n         * cell - <mxCell> whose foldable state should be returned.\r\n         */\r\n        isCellFoldable(cell: any, collapse: any): boolean;\r\n        /**\r\n         * Returns true if the given cell is a valid drop target for the specified\r\n         * cells. If <splitEnabled> is true then this returns <isSplitTarget> for\r\n         * the given arguments else it returns true if the cell is not collapsed\r\n         * and its child count is greater than 0.\r\n         *\r\n         * cell - <mxCell> that represents the possible drop target.\r\n         * cells - <mxCells> that should be dropped into the target.\r\n         * evt - Mouseevent that triggered the invocation.\r\n         */\r\n        isValidDropTarget(cell: any, cells: any, evt: any): boolean;\r\n        /**\r\n         * Returns true if the given edge may be splitted into two edges with the\r\n         * given cell as a new terminal between the two.\r\n         *\r\n         * target - <mxCell> that represents the edge to be splitted.\r\n         * cells - <mxCells> that should split the edge.\r\n         * evt - Mouseevent that triggered the invocation.\r\n         */\r\n        isSplitTarget(target: mxCell, cells: mxCell[], evt: MouseEvent): boolean;\r\n        /**\r\n         * Returns the given cell if it is a drop target for the given cells or the\r\n         * nearest ancestor that may be used as a drop target for the given cells.\r\n         * If the given array contains a swimlane and <swimlaneNesting> is false\r\n         * then this always returns null. If no cell is given, then the bottommost\r\n         * swimlane at the location of the given event is returned.\r\n         *\r\n         * This function should only be used if <isDropEnabled> returns true.\r\n         *\r\n         * cells - Array of <mxCells> which are to be dropped onto the target.\r\n         * evt - Mouseevent for the drag and drop.\r\n         * cell - <mxCell> that is under the mousepointer.\r\n         * clone - Optional boolean to indicate of cells will be cloned.\r\n         */\r\n        getDropTarget(cells: any, evt: any, cell: any, clone: any): any;\r\n        /**\r\n         * Returns <defaultParent> or <mxGraphView.currentRoot> or the first child\r\n         * child of <mxGraphModel.root> if both are null. The value returned by\r\n         * this function should be used as the parent for new cells (aka default\r\n         * layer).\r\n         */\r\n        getDefaultParent(): mxCell;\r\n        /**\r\n         * Sets the <defaultParent> to the given cell. Set this to null to return\r\n         * the first child of the root in getDefaultParent.\r\n         */\r\n        setDefaultParent(cell: any): void;\r\n        /**\r\n         * Returns the nearest ancestor of the given cell which is a swimlane, or\r\n         * the given cell, if it is itself a swimlane.\r\n         *\r\n         * cell - <mxCell> for which the ancestor swimlane should be returned.\r\n         */\r\n        getSwimlane(cell: any): any;\r\n        /**\r\n         * Returns the bottom-most swimlane that intersects the given point (x, y)\r\n         * in the cell hierarchy that starts at the given parent.\r\n         *\r\n         * x - X-coordinate of the location to be checked.\r\n         * y - Y-coordinate of the location to be checked.\r\n         * parent - <mxCell> that should be used as the root of the recursion.\r\n         * Default is <defaultParent>.\r\n         */\r\n        getSwimlaneAt(x: number, y: number, parent?: mxCell): any;\r\n        /**\r\n         * Returns the bottom-most cell that intersects the given point (x, y) in\r\n         * the cell hierarchy starting at the given parent. This will also return\r\n         * swimlanes if the given location intersects the content area of the\r\n         * swimlane. If this is not desired, then the <hitsSwimlaneContent> may be\r\n         * used if the returned cell is a swimlane to determine if the location\r\n         * is inside the content area or on the actual title of the swimlane.\r\n         *\r\n         * @param x - X-coordinate of the location to be checked.\r\n         * @param y - Y-coordinate of the location to be checked.\r\n         * @param parent - <mxCell> that should be used as the root of the recursion.\r\n         * Default is current root of the view or the root of the model.\r\n         * @param vertices - Optional boolean indicating if vertices should be returned.\r\n         * Default is true.\r\n         * @param edges - Optional boolean indicating if edges should be returned. Default\r\n         * is true.\r\n         * @param ignoreFn - Optional function that returns true if cell should be ignored.\r\n         * The function is passed the cell state and the x and y parameter.\r\n         */\r\n        getCellAt(x: number, y: number, parent?: mxCell, vertices?: boolean, edges?: boolean, ignoreFn?: (cell: mxCellState, x: number, y: number) => boolean): any;\r\n        /**\r\n         * Returns the bottom-most cell that intersects the given point (x, y) in\r\n         * the cell hierarchy that starts at the given parent.\r\n         *\r\n         * state - <mxCellState> that represents the cell state.\r\n         * x - X-coordinate of the location to be checked.\r\n         * y - Y-coordinate of the location to be checked.\r\n         */\r\n        intersects(state: any, x: any, y: any): boolean;\r\n        /**\r\n         * Returns true if the given coordinate pair is inside the content\r\n         * are of the given swimlane.\r\n         *\r\n         * swimlane - <mxCell> that specifies the swimlane.\r\n         * x - X-coordinate of the mouse event.\r\n         * y - Y-coordinate of the mouse event.\r\n         */\r\n        hitsSwimlaneContent(swimlane: any, x: any, y: any): boolean;\r\n        /**\r\n         * Returns the visible child vertices of the given parent.\r\n         *\r\n         * parent - <mxCell> whose children should be returned.\r\n         */\r\n        getChildVertices(parent: any): mxCell[];\r\n        /**\r\n         * Returns the visible child edges of the given parent.\r\n         *\r\n         * @param parent - <mxCell> whose child vertices should be returned.\r\n         */\r\n        getChildEdges(parent: mxCell): mxCell[];\r\n        /**\r\n         * Returns the visible child vertices or edges in the given parent. If\r\n         * vertices and edges is false, then all children are returned.\r\n         *\r\n         * @param parent - <mxCell> whose children should be returned.\r\n         * @param vertices - Optional boolean that specifies if child vertices should\r\n         * be returned. Default is false.\r\n         * @param edges - Optional boolean that specifies if child edges should\r\n         * be returned. Default is false.\r\n         */\r\n        getChildCells(parent: mxCell, vertices?: boolean, edges?: boolean): mxCell[];\r\n        /**\r\n         * Returns all visible edges connected to the given cell without loops.\r\n         *\r\n         * @param cell - <mxCell> whose connections should be returned.\r\n         * @param parent - Optional parent of the opposite end for a connection to be\r\n         * returned.\r\n         */\r\n        getConnections(cell: mxCell, parent?: mxCell): any[];\r\n        /**\r\n         * Returns the visible incoming edges for the given cell. If the optional\r\n         * parent argument is specified, then only child edges of the given parent\r\n         * are returned.\r\n         *\r\n         * @param cell - <mxCell> whose incoming edges should be returned.\r\n         * @param parent - Optional parent of the opposite end for an edge to be\r\n         * returned.\r\n         */\r\n        getIncomingEdges(cell: mxCell, parent?: mxCell): any[];\r\n        /**\r\n         * Returns the visible outgoing edges for the given cell. If the optional\r\n         * parent argument is specified, then only child edges of the given parent\r\n         * are returned.\r\n         *\r\n         * @param cell - <mxCell> whose outgoing edges should be returned.\r\n         * @param parent - Optional parent of the opposite end for an edge to be\r\n         * returned.\r\n         */\r\n        getOutgoingEdges(cell: mxCell, parent?: mxCell): any[];\r\n        /**\r\n         * Returns the incoming and/or outgoing edges for the given cell.\r\n         * If the optional parent argument is specified, then only edges are returned\r\n         * where the opposite is in the given parent cell. If at least one of incoming\r\n         * or outgoing is true, then loops are ignored, if both are false, then all\r\n         * edges connected to the given cell are returned including loops.\r\n         *\r\n         * @param cell - <mxCell> whose edges should be returned.\r\n         * @param parent - Optional parent of the opposite end for an edge to be\r\n         * returned.\r\n         * @param incoming - Optional boolean that specifies if incoming edges should\r\n         * be included in the result. Default is true.\r\n         * @param outgoing - Optional boolean that specifies if outgoing edges should\r\n         * be included in the result. Default is true.\r\n         * @param includeLoops - Optional boolean that specifies if loops should be\r\n         * included in the result. Default is true.\r\n         * @param recurse - Optional boolean the specifies if the parent specified only\r\n         * need be an ancestral parent, true, or the direct parent, false.\r\n         * Default is false\r\n         */\r\n        getEdges(cell: mxCell, parent?: mxCell, incoming?: boolean, outgoing?: boolean, includeLoops?: boolean, recurse?: boolean): any[];\r\n        /**\r\n         * Returns whether or not the specified parent is a valid\r\n         * ancestor of the specified cell, either direct or indirectly\r\n         * based on whether ancestor recursion is enabled.\r\n         *\r\n         * cell - <mxCell> the possible child cell\r\n         * parent - <mxCell> the possible parent cell\r\n         * recurse - boolean whether or not to recurse the child ancestors\r\n         */\r\n        isValidAncestor(cell: any, parent: any, recurse: any): boolean;\r\n        /**\r\n         * Returns all distinct visible opposite cells for the specified terminal\r\n         * on the given edges.\r\n         *\r\n         * edges - Array of <mxCells> that contains the edges whose opposite\r\n         * terminals should be returned.\r\n         * terminal - Terminal that specifies the end whose opposite should be\r\n         * returned.\r\n         * source - Optional boolean that specifies if source terminals should be\r\n         * included in the result. Default is true.\r\n         * targets - Optional boolean that specifies if targer terminals should be\r\n         * included in the result. Default is true.\r\n         */\r\n        getOpposites(edges: any, terminal: any, sources: any, targets: any): any[];\r\n        /**\r\n         * Returns the edges between the given source and target. This takes into\r\n         * account collapsed and invisible cells and returns the connected edges\r\n         * as displayed on the screen.\r\n         *\r\n         * source -\r\n         * target -\r\n         * directed -\r\n         */\r\n        getEdgesBetween(source: any, target: any, directed: any): any[];\r\n        /**\r\n         * Returns an <mxPoint> representing the given event in the unscaled,\r\n         * non-translated coordinate space of <container> and applies the grid.\r\n         *\r\n         * @param evt - Mousevent that contains the mouse pointer location.\r\n         * @param addOffset - Optional boolean that specifies if the position should be\r\n         * offset by half of the <gridSize>. Default is true.\r\n         */\r\n        getPointForEvent(evt: MouseEvent, addOffset?: boolean): mxPoint;\r\n        /**\r\n         * Returns the child vertices and edges of the given parent that are contained\r\n         * in the given rectangle. The result is added to the optional result array,\r\n         * which is returned. If no result array is specified then a new array is\r\n         * created and returned.\r\n         *\r\n         * @param x - X-coordinate of the rectangle.\r\n         * @param y - Y-coordinate of the rectangle.\r\n         * @param width - Width of the rectangle.\r\n         * @param height - Height of the rectangle.\r\n         * @param parent - <mxCell> that should be used as the root of the recursion.\r\n         * Default is current root of the view or the root of the model.\r\n         * @param result - Optional array to store the result in.\r\n         */\r\n        getCells(x: number, y: number, width: number, height: number, parent?: mxCell, result?: mxCell[]): mxCell[];\r\n        /**\r\n         * Returns the children of the given parent that are contained in the\r\n         * halfpane from the given point (x0, y0) rightwards or downwards\r\n         * depending on rightHalfpane and bottomHalfpane.\r\n         *\r\n         * x0 - X-coordinate of the origin.\r\n         * y0 - Y-coordinate of the origin.\r\n         * parent - Optional <mxCell> whose children should be checked. Default is\r\n         * <defaultParent>.\r\n         * rightHalfpane - Boolean indicating if the cells in the right halfpane\r\n         * from the origin should be returned.\r\n         * bottomHalfpane - Boolean indicating if the cells in the bottom halfpane\r\n         * from the origin should be returned.\r\n         */\r\n        getCellsBeyond(x0: any, y0: any, parent: any, rightHalfpane: any, bottomHalfpane: any): any[];\r\n        /**\r\n         * Returns all children in the given parent which do not have incoming\r\n         * edges. If the result is empty then the with the greatest difference\r\n         * between incoming and outgoing edges is returned.\r\n         *\r\n         * parent - <mxCell> whose children should be checked.\r\n         * isolate - Optional boolean that specifies if edges should be ignored if\r\n         * the opposite end is not a child of the given parent cell. Default is\r\n         * false.\r\n         * invert - Optional boolean that specifies if outgoing or incoming edges\r\n         * should be counted for a tree root. If false then outgoing edges will be\r\n         * counted. Default is false.\r\n         */\r\n        findTreeRoots(parent: any, isolate: any, invert: any): any[];\r\n        /**\r\n         * Traverses the (directed) graph invoking the given function for each\r\n         * visited vertex and edge. The function is invoked with the current vertex\r\n         * and the incoming edge as a parameter. This implementation makes sure\r\n         * each vertex is only visited once. The function may return false if the\r\n         * traversal should stop at the given vertex.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * mxLog.show();\r\n         * var cell = graph.getSelectionCell();\r\n         * graph.traverse(cell, false, function(vertex, edge)\r\n         * {\r\n         *   mxLog.debug(graph.getLabel(vertex));\r\n         * });\r\n         * (end)\r\n         *\r\n         * vertex - <mxCell> that represents the vertex where the traversal starts.\r\n         * directed - Optional boolean indicating if edges should only be traversed\r\n         * from source to target. Default is true.\r\n         * func - Visitor function that takes the current vertex and the incoming\r\n         * edge as arguments. The traversal stops if the function returns false.\r\n         * edge - Optional <mxCell> that represents the incoming edge. This is\r\n         * null for the first step of the traversal.\r\n         * visited - Optional <mxDictionary> from cells to true for the visited cells.\r\n         * inverse - Optional boolean to traverse in inverse direction. Default is false.\r\n         * This is ignored if directed is false.\r\n         */\r\n        traverse(vertex: any, directed: any, func: any, edge: any, visited: any, inverse: any): void;\r\n        /**\r\n         * Returns true if the given cell is selected.\r\n         *\r\n         * cell - <mxCell> for which the selection state should be returned.\r\n         */\r\n        isCellSelected(cell: any): boolean;\r\n        /**\r\n         * Returns true if the selection is empty.\r\n         */\r\n        isSelectionEmpty(): boolean;\r\n        /**\r\n         * Clears the selection using <mxGraphSelectionModel.clear>.\r\n         */\r\n        clearSelection(): void;\r\n        /**\r\n         * Returns the number of selected cells.\r\n         */\r\n        getSelectionCount(): number;\r\n        /**\r\n         * Returns the first cell from the array of selected <mxCells>.\r\n         */\r\n        getSelectionCell(): mxCell;\r\n        /**\r\n         * Returns the array of selected <mxCells>.\r\n         */\r\n        getSelectionCells(): mxCell[];\r\n        /**\r\n         * Sets the selection cell.\r\n         *\r\n         * cell - <mxCell> to be selected.\r\n         */\r\n        setSelectionCell(cell: any): void;\r\n        /**\r\n         * Sets the selection cell.\r\n         *\r\n         * cells - Array of <mxCells> to be selected.\r\n         */\r\n        setSelectionCells(cells: any): void;\r\n        /**\r\n         * Adds the given cell to the selection.\r\n         *\r\n         * cell - <mxCell> to be add to the selection.\r\n         */\r\n        addSelectionCell(cell: any): void;\r\n        /**\r\n         * Adds the given cells to the selection.\r\n         *\r\n         * cells - Array of <mxCells> to be added to the selection.\r\n         */\r\n        addSelectionCells(cells: any): void;\r\n        /**\r\n         * Removes the given cell from the selection.\r\n         *\r\n         * cell - <mxCell> to be removed from the selection.\r\n         */\r\n        removeSelectionCell(cell: any): void;\r\n        /**\r\n         * Removes the given cells from the selection.\r\n         *\r\n         * cells - Array of <mxCells> to be removed from the selection.\r\n         */\r\n        removeSelectionCells(cells: any): void;\r\n        /**\r\n         * Selects and returns the cells inside the given rectangle for the\r\n         * specified event.\r\n         *\r\n         * @param rect - <mxRectangle> that represents the region to be selected.\r\n         * @param evt - Mouseevent that triggered the selection.\r\n         */\r\n        selectRegion(rect: mxRectangle, evt: MouseEvent): mxCell[];\r\n        /**\r\n         * Selects the next cell.\r\n         */\r\n        selectNextCell(): void;\r\n        /**\r\n         * Selects the previous cell.\r\n         */\r\n        selectPreviousCell(): void;\r\n        /**\r\n         * Selects the parent cell.\r\n         */\r\n        selectParentCell(): void;\r\n        /**\r\n         * Selects the first child cell.\r\n         */\r\n        selectChildCell(): void;\r\n        /**\r\n         * Selects the next, parent, first child or previous cell, if all arguments\r\n         * are false.\r\n         *\r\n         * @param isNext - Boolean indicating if the next cell should be selected.\r\n         * @param isParent - Boolean indicating if the parent cell should be selected.\r\n         * @param isChild - Boolean indicating if the first child cell should be selected.\r\n         */\r\n        selectCell(isNext?: boolean, isParent?: boolean, isChild?: boolean): void;\r\n        /**\r\n         * Selects all children of the given parent cell or the children of the\r\n         * default parent if no parent is specified. To select leaf vertices and/or\r\n         * edges use <selectCells>.\r\n         *\r\n         * parent - Optional <mxCell> whose children should be selected.\r\n         * Default is <defaultParent>.\r\n         * descendants - Optional boolean specifying whether all descendants should be\r\n         * selected. Default is false.\r\n         */\r\n        selectAll(parent: any, descendants: any): void;\r\n        /**\r\n         * Select all vertices inside the given parent or the default parent.\r\n         */\r\n        selectVertices(parent?: any): void;\r\n        /**\r\n         * Select all vertices inside the given parent or the default parent.\r\n         */\r\n        selectEdges(parent?: any): void;\r\n        /**\r\n         * Selects all vertices and/or edges depending on the given boolean\r\n         * arguments recursively, starting at the given parent or the default\r\n         * parent if no parent is specified. Use <selectAll> to select all cells.\r\n         * For vertices, only cells with no children are selected.\r\n         *\r\n         * vertices - Boolean indicating if vertices should be selected.\r\n         * edges - Boolean indicating if edges should be selected.\r\n         * parent - Optional <mxCell> that acts as the root of the recursion.\r\n         * Default is <defaultParent>.\r\n         */\r\n        selectCells(vertices: any, edges: any, parent: any): void;\r\n        /**\r\n         * Selects the given cell by either adding it to the selection or\r\n         * replacing the selection depending on whether the given mouse event is a\r\n         * toggle event.\r\n         *\r\n         * cell - <mxCell> to be selected.\r\n         * evt - Optional mouseevent that triggered the selection.\r\n         */\r\n        selectCellForEvent(cell: any, evt: any): void;\r\n        /**\r\n         * Selects the given cells by either adding them to the selection or\r\n         * replacing the selection depending on whether the given mouse event is a\r\n         * toggle event.\r\n         *\r\n         * cells - Array of <mxCells> to be selected.\r\n         * evt - Optional mouseevent that triggered the selection.\r\n         */\r\n        selectCellsForEvent(cells: any, evt: any): void;\r\n        /**\r\n         * Creates a new handler for the given cell state. This implementation\r\n         * returns a new <mxEdgeHandler> of the corresponding cell is an edge,\r\n         * otherwise it returns an <mxVertexHandler>.\r\n         *\r\n         * state - <mxCellState> whose handler should be created.\r\n         */\r\n        createHandler(state: any): any;\r\n        /**\r\n         * Hooks to create a new <mxVertexHandler> for the given <mxCellState>.\r\n         *\r\n         * state - <mxCellState> to create the handler for.\r\n         */\r\n        createVertexHandler(state: any): mxVertexHandler;\r\n        /**\r\n         * Hooks to create a new <mxEdgeHandler> for the given <mxCellState>.\r\n         *\r\n         * state - <mxCellState> to create the handler for.\r\n         */\r\n        createEdgeHandler(state: any, edgeStyle: any): any;\r\n        /**\r\n         * Hooks to create a new <mxEdgeSegmentHandler> for the given <mxCellState>.\r\n         *\r\n         * state - <mxCellState> to create the handler for.\r\n         */\r\n        createEdgeSegmentHandler(state: any): mxEdgeSegmentHandler;\r\n        /**\r\n         * Hooks to create a new <mxElbowEdgeHandler> for the given <mxCellState>.\r\n         *\r\n         * state - <mxCellState> to create the handler for.\r\n         */\r\n        createElbowEdgeHandler(state: any): mxElbowEdgeHandler;\r\n        /**\r\n         * Adds a listener to the graph event dispatch loop. The listener\r\n         * must implement the mouseDown, mouseMove and mouseUp methods\r\n         * as shown in the <mxMouseEvent> class.\r\n         *\r\n         * listener - Listener to be added to the graph event listeners.\r\n         */\r\n        addMouseListener(listener: any): void;\r\n        /**\r\n         * Removes the specified graph listener.\r\n         *\r\n         * listener - Listener to be removed from the graph event listeners.\r\n         */\r\n        removeMouseListener(listener: any): void;\r\n        /**\r\n         * Sets the graphX and graphY properties if the given <mxMouseEvent> if\r\n         * required and returned the event.\r\n         *\r\n         * me - <mxMouseEvent> to be updated.\r\n         * evtName - Name of the mouse event.\r\n         */\r\n        updateMouseEvent(me: any, evtName: any): any;\r\n        /**\r\n         * Returns the state for the given touch event.\r\n         */\r\n        getStateForTouchEvent(evt: any): mxCellState;\r\n        /**\r\n         * Returns true if the event should be ignored in <fireMouseEvent>.\r\n         */\r\n        isEventIgnored(evtName: any, me: any, sender: any): boolean;\r\n        /**\r\n         * Hook for ignoring synthetic mouse events after touchend in Firefox.\r\n         */\r\n        isSyntheticEventIgnored(evtName: any, me: any, sender: any): boolean;\r\n        /**\r\n         * Returns true if the event should be ignored in <fireMouseEvent>. This\r\n         * implementation returns true for select, option and input (if not of type\r\n         * checkbox, radio, button, submit or file) event sources if the event is not\r\n         * a mouse event or a left mouse button press event.\r\n         *\r\n         * evtName - The name of the event.\r\n         * me - <mxMouseEvent> that should be ignored.\r\n         */\r\n        isEventSourceIgnored(evtName: any, me: any): boolean;\r\n        /**\r\n         * Returns the <mxCellState> to be used when firing the mouse event for the\r\n         * given state. This implementation returns the given state.\r\n         *\r\n         * <mxCellState> - State whose event source should be returned.\r\n         */\r\n        getEventState(state: any): any;\r\n        /**\r\n         * Dispatches the given event in the graph event dispatch loop. Possible\r\n         * event names are <mxEvent.MOUSE_DOWN>, <mxEvent.MOUSE_MOVE> and\r\n         * <mxEvent.MOUSE_UP>. All listeners are invoked for all events regardless\r\n         * of the consumed state of the event.\r\n         *\r\n         * evtName - String that specifies the type of event to be dispatched.\r\n         * me - <mxMouseEvent> to be fired.\r\n         * sender - Optional sender argument. Default is this.\r\n         */\r\n        fireMouseEvent(evtName: any, me: any, sender?: any): void;\r\n        /**\r\n         * Consumes the given <mxMouseEvent> if it's a touchStart event.\r\n         */\r\n        consumeMouseEvent(evtName: any, me: any, sender: any): void;\r\n        /**\r\n         * Dispatches a <mxEvent.GESTURE> event. The following example will resize the\r\n         * cell under the mouse based on the scale property of the native touch event.\r\n         *\r\n         * (code)\r\n         * graph.addListener(mxEvent.GESTURE, function(sender, eo)\r\n         * {\r\n         *   var evt = eo.getProperty('event');\r\n         *   var state = graph.view.getState(eo.getProperty('cell'));\r\n         *\r\n         *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)\r\n         *   {\r\n         *     var scale = graph.view.scale;\r\n         *     var tr = graph.view.translate;\r\n         *\r\n         *     var w = state.width * evt.scale;\r\n         *     var h = state.height * evt.scale;\r\n         *     var x = state.x - (w - state.width) / 2;\r\n         *     var y = state.y - (h - state.height) / 2;\r\n         *\r\n         *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,\r\n         *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));\r\n         *     graph.resizeCell(state.cell, bounds);\r\n         *     eo.consume();\r\n         *   }\r\n         * });\r\n         * (end)\r\n         *\r\n         * evt - Gestureend event that represents the gesture.\r\n         * cell - Optional <mxCell> associated with the gesture.\r\n         */\r\n        fireGestureEvent(evt: any, cell: any): void;\r\n        /**\r\n         * Destroys the graph and all its resources.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxEventSource> to implement a graph overlay, represented by an icon\r\n     * and a tooltip. Overlays can handle and fire <click> events and are added to\r\n     * the graph using <mxGraph.addCellOverlay>, and removed using\r\n     * <mxGraph.removeCellOverlay>, or <mxGraph.removeCellOverlays> to remove all overlays.\r\n     * The <mxGraph.getCellOverlays> function returns the array of overlays for a given\r\n     * cell in a graph. If multiple overlays exist for the same cell, then\r\n     * <getBounds> should be overridden in at least one of the overlays.\r\n     *\r\n     * Overlays appear on top of all cells in a special layer. If this is not\r\n     * desirable, then the image must be rendered as part of the shape or label of\r\n     * the cell instead.\r\n     *\r\n     * Example:\r\n     *\r\n     * The following adds a new overlays for a given vertex and selects the cell\r\n     * if the overlay is clicked.\r\n     *\r\n     * (code)\r\n     * var overlay = new mxCellOverlay(img, html);\r\n     * graph.addCellOverlay(vertex, overlay);\r\n     * overlay.addListener(mxEvent.CLICK, function(sender, evt)\r\n     * {\r\n     *   var cell = evt.getProperty('cell');\r\n     *   graph.setSelectionCell(cell);\r\n     * });\r\n     * (end)\r\n     *\r\n     * For cell overlays to be printed use <mxPrintPreview.printOverlays>.\r\n     *\r\n     * Event: mxEvent.CLICK\r\n     *\r\n     * Fires when the user clicks on the overlay. The <code>event</code> property\r\n     * contains the corresponding mouse event and the <code>cell</code> property\r\n     * contains the cell. For touch devices this is fired if the element receives\r\n     * a touchend event.\r\n     */\r\n    export declare class mxCellOverlay extends mxEventSource {\r\n        /**\r\n         * Holds the <mxImage> to be used as the icon.\r\n         */\r\n        image: any;\r\n        /**\r\n         * Holds the optional string to be used as the tooltip.\r\n         */\r\n        tooltip: any;\r\n        /**\r\n         * Holds the horizontal alignment for the overlay. Default is\r\n         * <mxConstants.ALIGN_RIGHT>. For edges, the overlay always appears in the\r\n         * center of the edge.\r\n         */\r\n        align: string;\r\n        /**\r\n         * Holds the vertical alignment for the overlay. Default is\r\n         * <mxConstants.ALIGN_BOTTOM>. For edges, the overlay always appears in the\r\n         * center of the edge.\r\n         */\r\n        verticalAlign: string;\r\n        /**\r\n         * Holds the offset as an <mxPoint>. The offset will be scaled according to the\r\n         * current scale.\r\n         */\r\n        offset: any;\r\n        /**\r\n         * Holds the cursor for the overlay. Default is 'help'.\r\n         */\r\n        cursor: any;\r\n        /**\r\n         * Defines the overlapping for the overlay, that is, the proportional distance\r\n         * from the origin to the point defined by the alignment. Default is 0.5.\r\n         */\r\n        defaultOverlap: number;\r\n        /**\r\n         * Constructs a new overlay using the given image and tooltip.\r\n         *\r\n         * @param image - <mxImage> that represents the icon to be displayed.\r\n         * @param tooltip - Optional string that specifies the tooltip.\r\n         * @param align - Optional horizontal alignment for the overlay. Possible\r\n         * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>\r\n         * (default).\r\n         * @param verticalAlign - Vertical alignment for the overlay. Possible\r\n         * values are <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>\r\n         * (default).\r\n         * @param offset ?\r\n         * @param cursor ?\r\n         */\r\n        constructor(image: mxImage, tooltip?: string, align?: any, verticalAlign?: any, offset?: mxPoint, cursor?: string);\r\n        /**\r\n         * Returns the bounds of the overlay for the given <mxCellState> as an\r\n         * <mxRectangle>. This should be overridden when using multiple overlays\r\n         * per cell so that the overlays do not overlap.\r\n         *\r\n         * The following example will place the overlay along an edge (where\r\n         * x=[-1..1] from the start to the end of the edge and y is the\r\n         * orthogonal offset in px).\r\n         *\r\n         * (code)\r\n         * overlay.getBounds = function(state)\r\n         * {\r\n         *   var bounds = mxCellOverlay.prototype.getBounds.apply(this, arguments);\r\n         *\r\n         *   if (state.view.graph.getModel().isEdge(state.cell))\r\n         *   {\r\n         *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});\r\n         *\r\n         *     bounds.x = pt.x - bounds.width / 2;\r\n         *     bounds.y = pt.y - bounds.height / 2;\r\n         *   }\r\n         *\r\n         *   return bounds;\r\n         * };\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> that represents the current state of the\r\n         * associated cell.\r\n         */\r\n        getBounds(state: any): mxRectangle;\r\n        /**\r\n         * Returns the textual representation of the overlay to be used as the\r\n         * tooltip. This implementation returns <tooltip>.\r\n         */\r\n        toString(): any;\r\n    }\r\n\r\n    /**\r\n     * Implements an outline (aka overview) for a graph. Set <updateOnPan> to true\r\n     * to enable updates while the source graph is panning.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var outline = new mxOutline(graph, div);\r\n     * (end)\r\n     *\r\n     * If an outline is used in an <mxWindow> in IE8 standards mode, the following\r\n     * code makes sure that the shadow filter is not inherited and that any\r\n     * transparent elements in the graph do not show the page background, but the\r\n     * background of the graph container.\r\n     *\r\n     * (code)\r\n     * if (document.documentMode == 8)\r\n     * {\r\n     *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\r\n     * }\r\n     * (end)\r\n     *\r\n     * To move the graph to the top, left corner the following code can be used.\r\n     *\r\n     * (code)\r\n     * var scale = graph.view.scale;\r\n     * var bounds = graph.getGraphBounds();\r\n     * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);\r\n     * (end)\r\n     *\r\n     * To toggle the suspended mode, the following can be used.\r\n     *\r\n     * (code)\r\n     * outline.suspended = !outln.suspended;\r\n     * if (!outline.suspended)\r\n     * {\r\n     *   outline.update(true);\r\n     * }\r\n     * (end)\r\n     *\r\n     * Constructor: mxOutline\r\n     *\r\n     * Constructs a new outline for the specified graph inside the given\r\n     * container.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * source - <mxGraph> to create the outline for.\r\n     * container - DOM node that will contain the outline.\r\n     */\r\n    export declare class mxOutline {\r\n        /**\r\n         * Variable: sizerImage\r\n         * \r\n         * Optional <mxImage> to be used for the sizer. Default is null.\r\n         */\r\n        sizerImage: mxImage;\r\n        graphRenderHint: MxGraphNS.renderingHint;\r\n        source: mxGraph;\r\n        suspended: boolean;\r\n        outline: mxGraph;\r\n        border: number;\r\n        minScale: number;\r\n        constructor(source: any, container?: any);\r\n        /**\r\n         * Creates the <mxGraph> used in the outline.\r\n         */\r\n        createGraph(container: any): mxGraph;\r\n        /**\r\n         * Initializes the outline inside the given container.\r\n         */\r\n        init(container: any): void;\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Enables or disables the zoom handling by showing or hiding the respective\r\n         * handle.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Boolean that specifies the new enabled state.\r\n         */\r\n        setZoomEnabled(value: any): void;\r\n        /**\r\n         * Invokes <update> and revalidate the outline. This method is deprecated.\r\n         */\r\n        refresh(): void;\r\n        /**\r\n         * Creates the shape used as the sizer.\r\n         */\r\n        createSizer(): any;\r\n        /**\r\n         * Returns the size of the source container.\r\n         */\r\n        getSourceContainerSize(): mxRectangle;\r\n        /**\r\n         * Returns the offset for drawing the outline graph.\r\n         */\r\n        getOutlineOffset(scale: any): any;\r\n        /**\r\n         * Returns the offset for drawing the outline graph.\r\n         */\r\n        getSourceGraphBounds(): any;\r\n        /**\r\n         * Updates the outline.\r\n         */\r\n        update(revalidate?: any): void;\r\n        /**\r\n         * Handles the event by starting a translation or zoom.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by previewing the viewrect in <graph> and updating the\r\n         * rectangle that represents the viewrect in the outline.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Gets the translate for the given mouse event. Here is an example to limit\r\n         * the outline to stay within positive coordinates:\r\n         *\r\n         * (code)\r\n         * outline.getTranslateForEvent = function(me)\r\n         * {\r\n         *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\r\n         *\r\n         *   if (!this.zoom)\r\n         *   {\r\n         *     var tr = this.source.view.translate;\r\n         *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);\r\n         *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);\r\n         *   }\r\n         *\r\n         *   return pt;\r\n         * };\r\n         * (end)\r\n         */\r\n        getTranslateForEvent(me: any): mxPoint;\r\n        /**\r\n         * Handles the event by applying the translation or zoom to <graph>.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Destroy this outline and removes all listeners from <source>.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Defines invalid connections along with the error messages that they produce.\r\n     * To add or remove rules on a graph, you must add/remove instances of this\r\n     * class to <mxGraph.multiplicities>.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * graph.multiplicities.push(new mxMultiplicity(\r\n     *   true, 'rectangle', null, null, 0, 2, ['circle'],\r\n     *   'Only 2 targets allowed',\r\n     *   'Only circle targets allowed'));\r\n     * (end)\r\n     *\r\n     * Defines a rule where each rectangle must be connected to no more than 2\r\n     * circles and no other types of targets are allowed.\r\n     */\r\n    export declare class mxMultiplicity {\r\n        /**\r\n         * Defines the type of the source or target terminal. The type is a string\r\n         * passed to <mxUtils.isNode> together with the source or target vertex\r\n         * value as the first argument.\r\n         */\r\n        type: any;\r\n        /**\r\n         * Optional string that specifies the attributename to be passed to\r\n         * <mxUtils.isNode> to check if the rule applies to a cell.\r\n         */\r\n        attr: any;\r\n        /**\r\n         * Optional string that specifies the value of the attribute to be passed\r\n         * to <mxUtils.isNode> to check if the rule applies to a cell.\r\n         */\r\n        value: any;\r\n        /**\r\n         * Boolean that specifies if the rule is applied to the source or target\r\n         * terminal of an edge.\r\n         */\r\n        source: any;\r\n        /**\r\n         * Defines the minimum number of connections for which this rule applies.\r\n         * Default is 0.\r\n         */\r\n        min: any;\r\n        /**\r\n         * Defines the maximum number of connections for which this rule applies.\r\n         * A value of 'n' means unlimited times. Default is 'n'.\r\n         */\r\n        max: any;\r\n        /**\r\n         * Holds an array of strings that specify the type of neighbor for which\r\n         * this rule applies. The strings are used in <mxCell.is> on the opposite\r\n         * terminal to check if the rule applies to the connection.\r\n         */\r\n        validNeighbors: any;\r\n        /**\r\n         * Boolean indicating if the list of validNeighbors are those that are allowed\r\n         * for this rule or those that are not allowed for this rule.\r\n         */\r\n        validNeighborsAllowed: boolean;\r\n        /**\r\n         * Holds the localized error message to be displayed if the number of\r\n         * connections for which the rule applies is smaller than <min> or greater\r\n         * than <max>.\r\n         */\r\n        countError: any;\r\n        /**\r\n         * Holds the localized error message to be displayed if the type of the\r\n         * neighbor for a connection does not match the rule.\r\n         */\r\n        typeError: any;\r\n        /**\r\n         * Instantiate class mxMultiplicity in order to describe allowed\r\n         * connections in a graph. Not all constraints can be enforced while\r\n         * editing, some must be checked at validation time. The <countError> and\r\n         * <typeError> are treated as resource keys in <mxResources>.\r\n         *\r\n         * @param source - Boolean indicating if this rule applies to the source or target\r\n         * terminal.\r\n         * @param type - Type of the source or target terminal that this rule applies to.\r\n         * See <type> for more information.\r\n         * @param attr - Optional attribute name to match the source or target terminal.\r\n         * @param value - Optional attribute value to match the source or target terminal.\r\n         * @param min - Minimum number of edges for this rule. Default is 1.\r\n         * @param max - Maximum number of edges for this rule. n means infinite. Default\r\n         * is n.\r\n         * @param validNeighbors - Array of types of the opposite terminal for which this\r\n         * rule applies.\r\n         * @param countError - Error to be displayed for invalid number of edges.\r\n         * @param typeError - Error to be displayed for invalid opposite terminals.\r\n         * @param validNeighborsAllowed - Optional boolean indicating if the array of\r\n         * opposite types should be valid or invalid.\r\n         */\r\n        constructor(source: boolean, type: any, attr: any, value: any, min: number, max: number | 'n', validNeighbors: any, countError: string, typeError: string, validNeighborsAllowed?: boolean);\r\n        /**\r\n         * Checks the multiplicity for the given arguments and returns the error\r\n         * for the given connection or null if the multiplicity does not apply.\r\n         *\r\n         * graph - Reference to the enclosing <mxGraph> instance.\r\n         * edge - <mxCell> that represents the edge to validate.\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         * sourceOut - Number of outgoing edges from the source terminal.\r\n         * targetIn - Number of incoming edges for the target terminal.\r\n         */\r\n        check(graph: any, edge: any, source: any, target: any, sourceOut: any, targetIn: any): string;\r\n        /**\r\n         * Checks if there are any valid neighbours in <validNeighbors>. This is only\r\n         * called if <validNeighbors> is a non-empty array.\r\n         */\r\n        checkNeighbors(graph: any, edge: any, source: any, target: any): boolean;\r\n        /**\r\n         * Checks the given terminal cell and returns true if this rule applies. The\r\n         * given cell is the source or target of the given edge, depending on\r\n         * <source>. This implementation uses <checkType> on the terminal's value.\r\n         */\r\n        checkTerminal(graph: any, terminal: any, edge: any): any;\r\n        /**\r\n         * Checks the type of the given value.\r\n         */\r\n        checkType(graph: any, value: any, type: any, attr: any, attrValue: any): any;\r\n    }\r\n\r\n    /**\r\n     * Implements a layout manager that runs a given layout after any changes to the graph:\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var layoutMgr = new mxLayoutManager(graph);\r\n     * layoutMgr.getLayout = function(cell)\r\n     * {\r\n     *   return layout;\r\n     * };\r\n     * (end)\r\n     *\r\n     * Event: mxEvent.LAYOUT_CELLS\r\n     *\r\n     * Fires between begin- and endUpdate after all cells have been layouted in\r\n     * <layoutCells>. The <code>cells</code> property contains all cells that have\r\n     * been passed to <layoutCells>.\r\n     *\r\n     * Constructor: mxLayoutManager\r\n     *\r\n     * Constructs a new automatic layout for the given graph.\r\n     *\r\n     * Arguments:\r\n     *\r\n     * graph - Reference to the enclosing graph.\r\n     */\r\n    export declare class mxLayoutManager extends mxEventSource {\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enabled - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Returns true if a layout should bubble, that is, if the parent layout\r\n         * should be executed whenever a cell layout (layout of the children of\r\n         * a cell) has been executed. This implementation returns <bubbling>.\r\n         */\r\n        isBubbling(): any;\r\n        /**\r\n         * Sets <bubbling>.\r\n         */\r\n        setBubbling(value: any): void;\r\n        /**\r\n         * Returns the graph that this layout operates on.\r\n         */\r\n        getGraph(): any;\r\n        /**\r\n         * Sets the graph that the layouts operate on.\r\n         */\r\n        setGraph(graph: any): void;\r\n        /**\r\n         * Returns the layout to be executed for the given graph and parent.\r\n         */\r\n        getLayout(parent: any): any;\r\n        /**\r\n         * Called from the undoHandler.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - Array of <mxCells> that have been moved.\r\n         * evt - Mouse event that represents the mousedown.\r\n         */\r\n        beforeUndo(undoableEdit: any): void;\r\n        /**\r\n         * Executes the given layout on the given parent.\r\n         */\r\n        executeLayoutForCells(cells: any): void;\r\n        /**\r\n         * Called from the moveHandler.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - Array of <mxCells> that have been moved.\r\n         * evt - Mouse event that represents the mousedown.\r\n         */\r\n        cellsMoved(cells: any, evt: any): void;\r\n        /**\r\n         * Returns the cells to be layouted for the given sequence of changes.\r\n         */\r\n        getCellsForChanges(changes: any): any[];\r\n        /**\r\n         * Executes all layouts which have been scheduled during the\r\n         * changes.\r\n         */\r\n        getCellsForChange(change: any): any[];\r\n        /**\r\n         * Executes all layouts which have been scheduled during the\r\n         * changes.\r\n         */\r\n        layoutCells(cells: any): void;\r\n        /**\r\n         * Executes the given layout on the given parent.\r\n         */\r\n        executeLayout(layout: any, parent: any): boolean;\r\n        /**\r\n         * Removes all handlers from the <graph> and deletes the reference to it.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Manager for swimlanes and nested swimlanes that sets the size of newly added\r\n     * swimlanes to that of their siblings, and propagates changes to the size of a\r\n     * swimlane to its siblings, if <siblings> is true, and its ancestors, if\r\n     * <bubbling> is true.\r\n     *\r\n     * Constructor: mxSwimlaneManager\r\n     *\r\n     * Constructs a new swimlane manager for the given graph.\r\n     *\r\n     * Arguments:\r\n     *\r\n     * graph - Reference to the enclosing graph.\r\n     */\r\n    export declare class mxSwimlaneManager extends mxEventSource {\r\n        constructor(graph: any, horizontal: any, addEnabled: any, resizeEnabled: any);\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enabled - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Returns <horizontal>.\r\n         */\r\n        isHorizontal(): any;\r\n        /**\r\n         * Sets <horizontal>.\r\n         */\r\n        setHorizontal(value: any): void;\r\n        /**\r\n         * Returns <addEnabled>.\r\n         */\r\n        isAddEnabled(): any;\r\n        /**\r\n         * Sets <addEnabled>.\r\n         */\r\n        setAddEnabled(value: any): void;\r\n        /**\r\n         * Returns <resizeEnabled>.\r\n         */\r\n        isResizeEnabled(): any;\r\n        /**\r\n         * Sets <resizeEnabled>.\r\n         */\r\n        setResizeEnabled(value: any): void;\r\n        /**\r\n         * Returns the graph that this manager operates on.\r\n         */\r\n        getGraph(): any;\r\n        /**\r\n         * Sets the graph that the manager operates on.\r\n         */\r\n        setGraph(graph: any): void;\r\n        /**\r\n         * Returns true if the given swimlane should be ignored.\r\n         */\r\n        isSwimlaneIgnored(swimlane: any): boolean;\r\n        /**\r\n         * Returns true if the given cell is horizontal. If the given cell is not a\r\n         * swimlane, then the global orientation is returned.\r\n         */\r\n        isCellHorizontal(cell: any): boolean;\r\n        /**\r\n         * Called if any cells have been added.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - Array of <mxCells> that have been added.\r\n         */\r\n        cellsAdded(cells: any): void;\r\n        /**\r\n         * Updates the size of the given swimlane to match that of any existing\r\n         * siblings swimlanes.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * swimlane - <mxCell> that represents the new swimlane.\r\n         */\r\n        swimlaneAdded(swimlane: any): void;\r\n        /**\r\n         * Called if any cells have been resizes. Calls <swimlaneResized> for all\r\n         * swimlanes where <isSwimlaneIgnored> returns false.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cells - Array of <mxCells> whose size was changed.\r\n         */\r\n        cellsResized(cells: any): void;\r\n        /**\r\n         * Called from <cellsResized> for all swimlanes that are not ignored to update\r\n         * the size of the siblings and the size of the parent swimlanes, recursively,\r\n         * if <bubbling> is true.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * swimlane - <mxCell> whose size has changed.\r\n         */\r\n        resizeSwimlane(swimlane: any, w: any, h: any, parentHorizontal: any): void;\r\n        /**\r\n         * Removes all handlers from the <graph> and deletes the reference to it.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Creates a temporary set of cell states.\r\n     */\r\n    export declare class mxTemporaryCellStates {\r\n        constructor(view: any, scale: any, cells: any, isCellVisibleFn: any, getLinkForCellState: any);\r\n        /**\r\n         * Returns the top, left corner as a new <mxPoint>.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Implements a live preview for moving cells.\r\n     *\r\n     * Constructor: mxCellStatePreview\r\n     *\r\n     * Constructs a move preview for the given graph.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     */\r\n    export declare class mxCellStatePreview {\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns true if this contains no entries.\r\n         */\r\n        isEmpty(): boolean;\r\n        /**\r\n         * Function: moveState\r\n         */\r\n        moveState(state: any, dx: any, dy: any, add: any, includeEdges: any): any;\r\n        /**\r\n         * Function: show\r\n         */\r\n        show(visitor: any): void;\r\n        /**\r\n         * Function: translateState\r\n         */\r\n        translateState(state: any, dx: any, dy: any): void;\r\n        /**\r\n         * Function: revalidateState\r\n         */\r\n        revalidateState(state: any, dx: any, dy: any, visitor: any): void;\r\n        /**\r\n         * Function: addEdges\r\n         */\r\n        addEdges(state: any): void;\r\n    }\r\n\r\n    /**\r\n     * Defines an object that contains the constraints about how to connect one\r\n     * side of an edge to its terminal.\r\n     */\r\n    export declare class mxConnectionConstraint {\r\n        id: any;\r\n        /**\r\n         * <mxPoint> that specifies the fixed location of the connection point.\r\n         */\r\n        point: mxPoint;\r\n        /**\r\n         * Boolean that specifies if the point should be projected onto the perimeter\r\n         * of the terminal.\r\n         */\r\n        perimeter: any;\r\n        /**\r\n         * Optional string that specifies the name of the constraint.\r\n         */\r\n        name: any;\r\n        /**\r\n         * Optional float that specifies the horizontal offset of the constraint.\r\n         */\r\n        dx: number;\r\n        /**\r\n         * Optional float that specifies the vertical offset of the constraint.\r\n         */\r\n        dy: number;\r\n        /**\r\n         * Constructs a new connection constraint for the given point and boolean\r\n         * arguments.\r\n         *\r\n         * @param point - Optional <mxPoint> that specifies the fixed location of the point\r\n         * in relative coordinates. Default is null.\r\n         * @param perimeter - Optional boolean that specifies if the fixed point should be\r\n         * projected onto the perimeter of the terminal. Default is true.\r\n         */\r\n        constructor(point?: mxPoint, perimeter?: boolean, name?: string, dx?: number, dy?: number);\r\n    }\r\n\r\n    /**\r\n     * Graph event handler that handles selection. Individual cells are handled\r\n     * separately using <mxVertexHandler> or one of the edge handlers. These\r\n     * handlers are created using <mxGraph.createHandler> in\r\n     * <mxGraphSelectionModel.cellAdded>.\r\n     *\r\n     * To avoid the container to scroll a moved cell into view, set\r\n     * <scrollAfterMove> to false.\r\n     *\r\n     * Constructor: mxGraphHandler\r\n     *\r\n     * Constructs an event handler that creates handles for the\r\n     * selection cells.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     */\r\n    export declare class mxGraphHandler {\r\n        /**\r\n         * Variable: maxLivePreview\r\n         * \r\n         * Maximum number of cells for which live preview should be used. Default is 0\r\n         * which means no live preview.\r\n         */\r\n        maxLivePreview: number;\r\n        /**\r\n         * Variable: removeEmptyParents\r\n         * \r\n         * If empty parents should be removed from the model after all child cells\r\n         * have been moved out. Default is true.\r\n         */\r\n        removeEmptyParents: boolean;\r\n\r\n        /**\r\n         * Variable: previewColor\r\n         * \r\n         * Specifies the color of the preview shape. Default is black.\r\n         */\r\n        previewColor: string;\r\n        guidesEnabled: boolean;\r\n        /**\r\n         * Specifies if the view should be scrolled so that a moved cell is visible.  Default is true.\r\n         */\r\n        scrollOnMove: boolean;\r\n        /**\r\n         * Specifies if the grid should be scaled.  Default is false.\r\n         */\r\n        scaleGrid: boolean;\r\n\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Sets <enabled>.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Returns <cloneEnabled>.\r\n         */\r\n        isCloneEnabled(): any;\r\n        /**\r\n         * Sets <cloneEnabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Boolean that specifies the new clone enabled state.\r\n         */\r\n        setCloneEnabled(value: any): void;\r\n        /**\r\n         * Returns <moveEnabled>.\r\n         */\r\n        isMoveEnabled(): any;\r\n        /**\r\n         * Sets <moveEnabled>.\r\n         */\r\n        setMoveEnabled(value: any): void;\r\n        /**\r\n         * Returns <selectEnabled>.\r\n         */\r\n        isSelectEnabled(): any;\r\n        /**\r\n         * Sets <selectEnabled>.\r\n         */\r\n        setSelectEnabled(value: any): void;\r\n        /**\r\n         * Returns <removeCellsFromParent>.\r\n         */\r\n        isRemoveCellsFromParent(): any;\r\n        /**\r\n         * Sets <removeCellsFromParent>.\r\n         */\r\n        setRemoveCellsFromParent(value: any): void;\r\n        /**\r\n         * Hook to return initial cell for the given event.\r\n         */\r\n        getInitialCellForEvent(me: any): any;\r\n        /**\r\n         * Hook to return true for delayed selections.\r\n         */\r\n        isDelayedSelection(cell: any, me: any): any;\r\n        /**\r\n         * Consumes the given mouse event. NOTE: This may be used to enable click\r\n         * events for links in labels on iOS as follows as consuming the initial\r\n         * touchStart disables firing the subsequent click evnent on the link.\r\n         *\r\n         * <code>\r\n         * mxGraphHandler.prototype.consumeMouseEvent = function(evtName, me)\r\n         * {\r\n         *   var source = mxEvent.getSource(me.getEvent());\r\n         *\r\n         *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')\r\n         *   {\r\n         *     me.consume();\r\n         *   }\r\n         * }\r\n         * </code>\r\n         */\r\n        consumeMouseEvent(evtName: any, me: any): void;\r\n        /**\r\n         * Handles the event by selecing the given cell and creating a handle for\r\n         * it. By consuming the event all subsequent events of the gesture are\r\n         * redirected to this handler.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Creates an array of cell states which should be used as guides.\r\n         */\r\n        getGuideStates(): any;\r\n        /**\r\n         * Returns the cells to be modified by this handler. This implementation\r\n         * returns all selection cells that are movable, or the given initial cell if\r\n         * the given cell is not selected and movable. This handles the case of moving\r\n         * unselectable or unselected cells.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * initialCell - <mxCell> that triggered this handler.\r\n         */\r\n        getCells(initialCell: any): any;\r\n        /**\r\n         * Returns the <mxRectangle> used as the preview bounds for\r\n         * moving the given cells.\r\n         */\r\n        getPreviewBounds(cells: any): any;\r\n        /**\r\n         * Returns the union of the <mxCellStates> for the given array of <mxCells>.\r\n         * For vertices, this method uses the bounding box of the corresponding shape\r\n         * if one exists. The bounding box of the corresponding text label and all\r\n         * controls and overlays are ignored. See also: <mxGraphView.getBounds> and\r\n         * <mxGraph.getBoundingBox>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cells - Array of <mxCells> whose bounding box should be returned.\r\n         */\r\n        getBoundingBox(cells: any): any;\r\n        /**\r\n         * Creates the shape used to draw the preview for the given bounds.\r\n         */\r\n        createPreviewShape(bounds: any): mxRectangleShape;\r\n        /**\r\n         * Starts the handling of the mouse gesture.\r\n         */\r\n        start(cell: any, x: any, y: any): void;\r\n        /**\r\n         * Returns true if the guides should be used for the given <mxMouseEvent>.\r\n         * This implementation returns <mxGuide.isEnabledForEvent>.\r\n         */\r\n        useGuidesForEvent(me: any): any;\r\n        /**\r\n         * Snaps the given vector to the grid and returns the given mxPoint instance.\r\n         */\r\n        snap(vector: any): any;\r\n        /**\r\n         * Returns an <mxPoint> that represents the vector for moving the cells\r\n         * for the given <mxMouseEvent>.\r\n         */\r\n        getDelta(me: any): mxPoint;\r\n        /**\r\n         * Hook for subclassers do show details while the handler is active.\r\n         */\r\n        updateHint(me: any): void;\r\n        /**\r\n         * Hooks for subclassers to hide details when the handler gets inactive.\r\n         */\r\n        removeHint(): void;\r\n        /**\r\n         * Hook for rounding the unscaled vector. This uses Math.round.\r\n         */\r\n        roundLength(length: any): number;\r\n        /**\r\n         * Handles the event by highlighting possible drop targets and updating the\r\n         * preview.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Updates the bounds of the preview shape.\r\n         */\r\n        updatePreviewShape(): void;\r\n        /**\r\n         * Sets the color of the rectangle used to highlight drop targets.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * color - String that represents the new highlight color.\r\n         */\r\n        setHighlightColor(color: any): void;\r\n        /**\r\n         * Handles the event by applying the changes to the selection cells.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Implements the delayed selection for the given mouse event.\r\n         */\r\n        selectDelayed(me: any): void;\r\n        /**\r\n         * Resets the state of this handler.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Returns true if the given cells should be removed from the parent for the specified\r\n         * mousereleased event.\r\n         */\r\n        shouldRemoveCellsFromParent(parent: any, cells: any, evt: any): boolean;\r\n        /**\r\n         * Moves the given cells by the specified amount.\r\n         */\r\n        moveCells(cells: any, dx: any, dy: any, clone: any, target: any, evt: any): void;\r\n        /**\r\n         * Destroy the preview and highlight shapes.\r\n         */\r\n        destroyShapes(): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Event handler that pans and creates popupmenus. To use the left\r\n     * mousebutton for panning without interfering with cell moving and\r\n     * resizing, use <isUseLeftButton> and <isIgnoreCell>. For grid size\r\n     * steps while panning, use <useGrid>. This handler is built-into\r\n     * <mxGraph.panningHandler> and enabled using <mxGraph.setPanning>.\r\n     *\r\n     * Event: mxEvent.PAN_START\r\n     *\r\n     * Fires when the panning handler changes its <active> state to true. The\r\n     * <code>event</code> property contains the corresponding <mxMouseEvent>.\r\n     *\r\n     * Event: mxEvent.PAN\r\n     *\r\n     * Fires while handle is processing events. The <code>event</code> property contains\r\n     * the corresponding <mxMouseEvent>.\r\n     *\r\n     * Event: mxEvent.PAN_END\r\n     *\r\n     * Fires when the panning handler changes its <active> state to false. The\r\n     * <code>event</code> property contains the corresponding <mxMouseEvent>.\r\n     */\r\n    export declare class mxPanningHandler extends mxEventSource {\r\n        /**\r\n         * Reference to the enclosing <mxGraph>.\r\n         */\r\n        graph: mxGraph;\r\n        /**\r\n         * Specifies if panning should be active for the left mouse button.\r\n         * Setting this to true may conflict with <mxRubberband>. Default is false.\r\n         */\r\n        useLeftButtonForPanning: boolean;\r\n        /**\r\n         * Specifies if <mxEvent.isPopupTrigger> should also be used for panning.\r\n         */\r\n        usePopupTrigger: boolean;\r\n        /**\r\n         * Specifies if panning should be active even if there is a cell under the\r\n         * mousepointer. Default is false.\r\n         */\r\n        ignoreCell: boolean;\r\n        /**\r\n         * Specifies if the panning should be previewed. Default is true.\r\n         */\r\n        previewEnabled: boolean;\r\n        /**\r\n         * Specifies if the panning steps should be aligned to the grid size.\r\n         * Default is false.\r\n         */\r\n        useGrid: boolean;\r\n        /**\r\n         * Specifies if panning should be enabled. Default is true.\r\n         */\r\n        panningEnabled: boolean;\r\n        /**\r\n         * Specifies if pinch gestures should be handled as zoom. Default is true.\r\n         */\r\n        pinchEnabled: boolean;\r\n        /**\r\n         * Specifies the maximum scale. Default is 8.\r\n         */\r\n        maxScale: number;\r\n        /**\r\n         * Specifies the minimum scale. Default is 0.01.\r\n         */\r\n        minScale: number;\r\n        /**\r\n         * Holds the current horizontal offset.\r\n         */\r\n        dx: number;\r\n        /**\r\n         * Holds the current vertical offset.\r\n         */\r\n        dy: number;\r\n        /**\r\n         * Holds the x-coordinate of the start point.\r\n         */\r\n        startX: number;\r\n        /**\r\n         * Holds the y-coordinate of the start point.\r\n         */\r\n        startY: number;\r\n        /**\r\n         * Implicit variable declarations\r\n         */\r\n        forcePanningHandler: any;\r\n        panningTrigger: any;\r\n        gestureHandler: any;\r\n        /** True if the handler is currently active. */\r\n        active: boolean;\r\n        initialScale: any;\r\n        mouseDownEvent: any;\r\n        dx0: number;\r\n        dy0: number;\r\n        /**\r\n         * Constructs an event handler that creates a <mxPopupMenu>\r\n         * and pans the graph.\r\n         * @param graph\r\n         */\r\n        constructor(graph: mxGraph);\r\n        /**\r\n         * Returns true if the handler is currently active.\r\n         */\r\n        isActive(): boolean;\r\n        /**\r\n         * Returns <panningEnabled>.\r\n         */\r\n        isPanningEnabled(): boolean;\r\n        /**\r\n         * Sets <panningEnabled>.\r\n         */\r\n        setPanningEnabled(value: boolean): void;\r\n        /**\r\n         * Returns <pinchEnabled>.\r\n         */\r\n        isPinchEnabled(): boolean;\r\n        /**\r\n         * Sets <pinchEnabled>.\r\n         */\r\n        setPinchEnabled(value: boolean): void;\r\n        /**\r\n         * Returns true if the given event is a panning trigger for the optional\r\n         * given cell. This returns true if control-shift is pressed or if\r\n         * <usePopupTrigger> is true and the event is a popup trigger.\r\n         */\r\n        isPanningTrigger(me: any): boolean;\r\n        /**\r\n         * Returns true if the given <mxMouseEvent> should start panning. This\r\n         * implementation always returns true if <ignoreCell> is true or for\r\n         * multi touch events.\r\n         */\r\n        isForcePanningEvent(me: any): boolean;\r\n        /**\r\n         * Handles the event by initiating the panning. By consuming the event all\r\n         * subsequent events of the gesture are redirected to this handler.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Starts panning at the given event.\r\n         */\r\n        start(me: any): void;\r\n        /**\r\n         * Consumes the given <mxMouseEvent> if it was a panning trigger in\r\n         * <mouseDown>. The default is to invoke <mxMouseEvent.consume>. Note that this\r\n         * will block any further event processing. If you haven't disabled built-in\r\n         * context menus and require immediate selection of the cell on mouseDown in\r\n         * Safari and/or on the Mac, then use the following code:\r\n         *\r\n         * (code)\r\n         * mxPanningHandler.prototype.consumePanningTrigger = function(me)\r\n         * {\r\n         *   if (me.evt.preventDefault)\r\n         *   {\r\n         *     me.evt.preventDefault();\r\n         *   }\r\n         *\r\n         *   // Stops event processing in IE\r\n         *   me.evt.returnValue = false;\r\n         *\r\n         *   // Sets local consumed state\r\n         *   if (!mxClient.IS_SF && !mxClient.IS_MAC)\r\n         *   {\r\n         *     me.consumed = true;\r\n         *   }\r\n         * };\r\n         * (end)\r\n         */\r\n        consumePanningTrigger(me: any): void;\r\n        /**\r\n         * Handles the event by updating the panning on the graph.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by setting the translation on the view or showing the\r\n         * popupmenu.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Pans <graph> by the given amount.\r\n         */\r\n        panGraph(dx: number, dy: number): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Event handler that creates popupmenus.\r\n     *\r\n     * Constructor: mxPopupMenuHandler\r\n     *\r\n     * Constructs an event handler that creates a <mxPopupMenu>.\r\n     */\r\n    export declare class mxPopupMenuHandler extends mxPopupMenu {\r\n        triggerY: number;\r\n        triggerX: number;\r\n        factoryMethod: any;\r\n        constructor(graph?: any, factoryMethod?: any);\r\n        /**\r\n         * Initializes the shapes required for this vertex handler.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Hook for returning if a cell should be selected for a given <mxMouseEvent>.\r\n         * This implementation returns <selectOnPopup>.\r\n         */\r\n        isSelectOnPopup(me: any): any;\r\n        /**\r\n         * Handles the event by initiating the panning. By consuming the event all\r\n         * subsequent events of the gesture are redirected to this handler.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by updating the panning on the graph.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by setting the translation on the view or showing the\r\n         * popupmenu.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Hook to return the cell for the mouse up popup trigger handling.\r\n         */\r\n        getCellForPopupEvent(me: any): any;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * A helper class to process mouse locations and highlight cells.\r\n     *\r\n     * Helper class to highlight cells. To add a cell marker to an existing graph\r\n     * for highlighting all cells, the following code is used:\r\n     *\r\n     * (code)\r\n     * var marker = new mxCellMarker(graph);\r\n     * graph.addMouseListener({\r\n     *   mouseDown: function() {},\r\n     *   mouseMove: function(sender, me)\r\n     *   {\r\n     *     marker.process(me);\r\n     *   },\r\n     *   mouseUp: function() {}\r\n     * });\r\n     * (end)\r\n     *\r\n     * Event: mxEvent.MARK\r\n     *\r\n     * Fires after a cell has been marked or unmarked. The <code>state</code>\r\n     * property contains the marked <mxCellState> or null if no state is marked.\r\n     *\r\n     * Constructor: mxCellMarker\r\n     *\r\n     * Constructs a new cell marker.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     * validColor - Optional marker color for valid states. Default is\r\n     * <mxConstants.DEFAULT_VALID_COLOR>.\r\n     * invalidColor - Optional marker color for invalid states. Default is\r\n     * <mxConstants.DEFAULT_INVALID_COLOR>.\r\n     * hotspot - Portion of the width and hight where a state intersects a\r\n     * given coordinate pair. A value of 0 means always highlight. Default is\r\n     * <mxConstants.DEFAULT_HOTSPOT>.\r\n     */\r\n    export declare class mxCellMarker extends mxEventSource {\r\n        constructor(graph: any, validColor: any, invalidColor: any, hotspot: any);\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enabled - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Sets the <hotspot>.\r\n         */\r\n        setHotspot(hotspot: any): void;\r\n        /**\r\n         * Returns the <hotspot>.\r\n         */\r\n        getHotspot(): any;\r\n        /**\r\n         * Specifies whether the hotspot should be used in <intersects>.\r\n         */\r\n        setHotspotEnabled(enabled: any): void;\r\n        /**\r\n         * Returns true if hotspot is used in <intersects>.\r\n         */\r\n        isHotspotEnabled(): any;\r\n        /**\r\n         * Returns true if <validState> is not null.\r\n         */\r\n        hasValidState(): boolean;\r\n        /**\r\n         * Returns the <validState>.\r\n         */\r\n        getValidState(): any;\r\n        /**\r\n         * Returns the <markedState>.\r\n         */\r\n        getMarkedState(): any;\r\n        /**\r\n         * Resets the state of the cell marker.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Processes the given event and cell and marks the state returned by\r\n         * <getState> with the color returned by <getMarkerColor>. If the\r\n         * markerColor is not null, then the state is stored in <markedState>. If\r\n         * <isValidState> returns true, then the state is stored in <validState>\r\n         * regardless of the marker color. The state is returned regardless of the\r\n         * marker color and valid state.\r\n         */\r\n        process(me: any): any;\r\n        /**\r\n         * Sets and marks the current valid state.\r\n         */\r\n        setCurrentState(state: any, me: any, color: any): void;\r\n        /**\r\n         * Marks the given cell using the given color, or <validColor> if no color is specified.\r\n         */\r\n        markCell(cell: any, color: any): void;\r\n        /**\r\n         * Marks the <markedState> and fires a <mark> event.\r\n         */\r\n        mark(): void;\r\n        /**\r\n         * Hides the marker and fires a <mark> event.\r\n         */\r\n        unmark(): void;\r\n        /**\r\n         * Returns true if the given <mxCellState> is a valid state. If this\r\n         * returns true, then the state is stored in <validState>. The return value\r\n         * of this method is used as the argument for <getMarkerColor>.\r\n         */\r\n        isValidState(state: any): boolean;\r\n        /**\r\n         * Returns the valid- or invalidColor depending on the value of isValid.\r\n         * The given <mxCellState> is ignored by this implementation.\r\n         */\r\n        getMarkerColor(evt: any, state: any, isValid: any): any;\r\n        /**\r\n         * Uses <getCell>, <getStateToMark> and <intersects> to return the\r\n         * <mxCellState> for the given <mxMouseEvent>.\r\n         */\r\n        getState(me: any): any;\r\n        /**\r\n         * Returns the <mxCell> for the given event and cell. This returns the\r\n         * given cell.\r\n         */\r\n        getCell(me: any): any;\r\n        /**\r\n         * Returns the <mxCellState> to be marked for the given <mxCellState> under\r\n         * the mouse. This returns the given state.\r\n         */\r\n        getStateToMark(state: any): any;\r\n        /**\r\n         * Returns true if the given coordinate pair intersects the given state.\r\n         * This returns true if the <hotspot> is 0 or the coordinates are inside\r\n         * the hotspot for the given cell state.\r\n         */\r\n        intersects(state: any, me: any): any;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * An event handler that manages cell handlers and invokes their mouse event\r\n     * processing functions.\r\n     *\r\n     * Group: Events\r\n     *\r\n     * Event: mxEvent.ADD\r\n     *\r\n     * Fires if a cell has been added to the selection. The <code>state</code>\r\n     * property contains the <mxCellState> that has been added.\r\n     *\r\n     * Event: mxEvent.REMOVE\r\n     *\r\n     * Fires if a cell has been remove from the selection. The <code>state</code>\r\n     * property contains the <mxCellState> that has been removed.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     */\r\n    export declare class mxSelectionCellsHandler extends mxEventSource {\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Sets <enabled>.\r\n         */\r\n        setEnabled(value: any): void;\r\n        /**\r\n         * Returns the handler for the given cell.\r\n         */\r\n        getHandler(cell: any): any;\r\n        /**\r\n         * Resets all handlers.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Reloads or updates all handlers.\r\n         */\r\n        refresh(): void;\r\n        /**\r\n         * Returns true if the given handler is active and should not be redrawn.\r\n         */\r\n        isHandlerActive(handler: any): boolean;\r\n        /**\r\n         * Updates the handler for the given shape if one exists.\r\n         */\r\n        updateHandler(state: any): void;\r\n        /**\r\n         * Redirects the given event to the handlers.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Redirects the given event to the handlers.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Redirects the given event to the handlers.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Graph event handler that creates new connections. Uses <mxTerminalMarker>\r\n     * for finding and highlighting the source and target vertices and\r\n     * <factoryMethod> to create the edge instance. This handler is built-into\r\n     * <mxGraph.connectionHandler> and enabled using <mxGraph.setConnectable>.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * new mxConnectionHandler(graph, function(source, target, style)\r\n     * {\r\n     *   edge = new mxCell('', new mxGeometry());\r\n     *   edge.setEdge(true);\r\n     *   edge.setStyle(style);\r\n     *   edge.geometry.relative = true;\r\n     *   return edge;\r\n     * });\r\n     * (end)\r\n     *\r\n     * Here is an alternative solution that just sets a specific user object for\r\n     * new edges by overriding <insertEdge>.\r\n     *\r\n     * (code)\r\n     * mxConnectionHandlerInsertEdge = mxConnectionHandler.prototype.insertEdge;\r\n     * mxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\r\n     * {\r\n     *   value = 'Test';\r\n     *\r\n     *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\r\n     * };\r\n     * (end)\r\n     *\r\n     * Using images to trigger connections:\r\n     *\r\n     * This handler uses mxTerminalMarker to find the source and target cell for\r\n     * the new connection and creates a new edge using <connect>. The new edge is\r\n     * created using <createEdge> which in turn uses <factoryMethod> or creates a\r\n     * new default edge.\r\n     *\r\n     * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\r\n     * used as a source or target terminal, as seen in other diagramming products.\r\n     * In order to allow both, moving and connecting cells at the same time,\r\n     * <mxConstants.DEFAULT_HOTSPOT> is used in the handler to determine the hotspot\r\n     * of a cell, that is, the region of the cell which is used to trigger a new\r\n     * connection. The constant is a value between 0 and 1 that specifies the\r\n     * amount of the width and height around the center to be used for the hotspot\r\n     * of a cell and its default value is 0.5. In addition,\r\n     * <mxConstants.MIN_HOTSPOT_SIZE> defines the minimum number of pixels for the\r\n     * width and height of the hotspot.\r\n     *\r\n     * This solution, while standards compliant, may be somewhat confusing because\r\n     * there is no visual indicator for the hotspot and the highlight is seen to\r\n     * switch on and off while the mouse is being moved in and out. Furthermore,\r\n     * this paradigm does not allow to create different connections depending on\r\n     * the highlighted hotspot as there is only one hotspot per cell and it\r\n     * normally does not allow cells to be moved and connected at the same time as\r\n     * there is no clear indication of the connectable area of the cell.\r\n     *\r\n     * To come across these issues, the handle has an additional <createIcons> hook\r\n     * with a default implementation that allows to create one icon to be used to\r\n     * trigger new connections. If this icon is specified, then new connections can\r\n     * only be created if the image is clicked while the cell is being highlighted.\r\n     * The <createIcons> hook may be overridden to create more than one\r\n     * <mxImageShape> for creating new connections, but the default implementation\r\n     * supports one image and is used as follows:\r\n     *\r\n     * In order to display the \"connect image\" whenever the mouse is over the cell,\r\n     * an DEFAULT_HOTSPOT of 1 should be used:\r\n     *\r\n     * (code)\r\n     * mxConstants.DEFAULT_HOTSPOT = 1;\r\n     * (end)\r\n     *\r\n     * In order to avoid confusion with the highlighting, the highlight color\r\n     * should not be used with a connect image:\r\n     *\r\n     * (code)\r\n     * mxConstants.HIGHLIGHT_COLOR = null;\r\n     * (end)\r\n     *\r\n     * To install the image, the connectImage field of the mxConnectionHandler must\r\n     * be assigned a new <mxImage> instance:\r\n     *\r\n     * (code)\r\n     * mxConnectionHandler.prototype.connectImage = new mxImage('images/green-dot.gif', 14, 14);\r\n     * (end)\r\n     *\r\n     * This will use the green-dot.gif with a width and height of 14 pixels as the\r\n     * image to trigger new connections. In createIcons the icon field of the\r\n     * handler will be set in order to remember the icon that has been clicked for\r\n     * creating the new connection. This field will be available under selectedIcon\r\n     * in the connect method, which may be overridden to take the icon that\r\n     * triggered the new connection into account. This is useful if more than one\r\n     * icon may be used to create a connection.\r\n     *\r\n     * Group: Events\r\n     *\r\n     * Event: mxEvent.START\r\n     *\r\n     * Fires when a new connection is being created by the user. The <code>state</code>\r\n     * property contains the state of the source cell.\r\n     *\r\n     * Event: mxEvent.CONNECT\r\n     *\r\n     * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\r\n     * property contains the inserted edge, the <code>event</code> and <code>target</code>\r\n     * properties contain the respective arguments that were passed to <connect> (where\r\n     * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\r\n     * property corresponds to the target argument in <connect> or the clone of the source\r\n     * terminal if <createTarget> is enabled.\r\n     *\r\n     * Note that the target is the cell under the mouse where the mouse button was released.\r\n     * Depending on the logic in the handler, this doesn't necessarily have to be the target\r\n     * of the inserted edge. To print the source, target or any optional ports IDs that the\r\n     * edge is connected to, the following code can be used. To get more details about the\r\n     * actual connection point, <mxGraph.getConnectionConstraint> can be used. To resolve\r\n     * the port IDs, use <mxGraphModel.getCell>.\r\n     *\r\n     * (code)\r\n     * graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt)\r\n     * {\r\n     *   var edge = evt.getProperty('cell');\r\n     *   var source = graph.getModel().getTerminal(edge, true);\r\n     *   var target = graph.getModel().getTerminal(edge, false);\r\n     *\r\n     *   var style = graph.getCellStyle(edge);\r\n     *   var sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\r\n     *   var targetPortId = style[mxConstants.STYLE_TARGET_PORT];\r\n     *\r\n     *   mxLog.show();\r\n     *   mxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\r\n     * });\r\n     * (end)\r\n     *\r\n     * Event: mxEvent.RESET\r\n     *\r\n     * Fires when the <reset> method is invoked.\r\n     */\r\n    export declare class mxConnectionHandler extends mxEventSource {\r\n        /**\r\n         * Function: isCellEnabled\r\n         * \r\n         * Returns true if the given cell does not allow new connections to be created.\r\n         */\r\n        isCellEnabled(cell: mxCell): boolean;\r\n        shape: any;\r\n        /**\r\n         * Reference to the enclosing <mxGraph>.\r\n         */\r\n        graph: any;\r\n        /**\r\n         * Function that is used for creating new edges. The function takes the\r\n         * source and target <mxCell> as the first and second argument and returns\r\n         * a new <mxCell> that represents the edge. This is used in <createEdge>.\r\n         */\r\n        factoryMethod: boolean;\r\n        /**\r\n         * Specifies if icons should be displayed inside the graph container instead\r\n         * of the overlay pane. This is used for HTML labels on vertices which hide\r\n         * the connect icon. This has precendence over <moveIconBack> when set\r\n         * to true. Default is false.\r\n         */\r\n        moveIconFront: boolean;\r\n        /**\r\n         * Specifies if icons should be moved to the back of the overlay pane. This can\r\n         * be set to true if the icons of the connection handler conflict with other\r\n         * handles, such as the vertex label move handle. Default is false.\r\n         */\r\n        moveIconBack: boolean;\r\n        /**\r\n         * <mxImage> that is used to trigger the creation of a new connection. This\r\n         * is used in <createIcons>. Default is null.\r\n         */\r\n        connectImage: any;\r\n        /**\r\n         * Specifies if the connect icon should be centered on the target state\r\n         * while connections are being previewed. Default is false.\r\n         */\r\n        targetConnectImage: boolean;\r\n        /**\r\n         * Specifies if events are handled. Default is true.\r\n         */\r\n        enabled: boolean;\r\n        /**\r\n         * Specifies if new edges should be selected. Default is true.\r\n         */\r\n        select: boolean;\r\n        /**\r\n         * Specifies if <createTargetVertex> should be called if no target was under the\r\n         * mouse for the new connection. Setting this to true means the connection\r\n         * will be drawn as valid if no target is under the mouse, and\r\n         * <createTargetVertex> will be called before the connection is created between\r\n         * the source cell and the newly created vertex in <createTargetVertex>, which\r\n         * can be overridden to create a new target. Default is false.\r\n         */\r\n        createTarget: boolean;\r\n        /**\r\n         * Holds the <mxTerminalMarker> used for finding source and target cells.\r\n         */\r\n        marker: any;\r\n        /**\r\n         * Holds the <mxConstraintHandler> used for drawing and highlighting\r\n         * constraints.\r\n         */\r\n        constraintHandler: any;\r\n        /**\r\n         * Holds the current validation error while connections are being created.\r\n         */\r\n        error: any;\r\n        /**\r\n         * Specifies if single clicks should add waypoints on the new edge. Default is\r\n         * false.\r\n         */\r\n        waypointsEnabled: boolean;\r\n        /**\r\n         * Specifies if the connection handler should ignore the state of the mouse\r\n         * button when highlighting the source. Default is false, that is, the\r\n         * handler only highlights the source if no button is being pressed.\r\n         */\r\n        ignoreMouseDown: boolean;\r\n        /**\r\n         * Holds the <mxPoint> where the mouseDown took place while the handler is\r\n         * active.\r\n         */\r\n        first: any;\r\n        /**\r\n         * Holds the offset for connect icons during connection preview.\r\n         * Default is mxPoint(0, <mxConstants.TOOLTIP_VERTICAL_OFFSET>).\r\n         * Note that placing the icon under the mouse pointer with an\r\n         * offset of (0,0) will affect hit detection.\r\n         */\r\n        connectIconOffset: mxPoint;\r\n        /**\r\n         * Optional <mxCellState> that represents the preview edge while the\r\n         * handler is active. This is created in <createEdgeState>.\r\n         */\r\n        edgeState: any;\r\n        /**\r\n         * Holds the change event listener for later removal.\r\n         */\r\n        changeHandler: any;\r\n        /**\r\n         * Holds the drill event listener for later removal.\r\n         */\r\n        drillHandler: any;\r\n        /**\r\n         * Counts the number of mouseDown events since the start. The initial mouse\r\n         * down event counts as 1.\r\n         */\r\n        mouseDownCounter: number;\r\n        /**\r\n         * Switch to enable moving the preview away from the mousepointer. This is required in browsers\r\n         * where the preview cannot be made transparent to events and if the built-in hit detection on\r\n         * the HTML elements in the page should be used. Default is the value of <mxClient.IS_VML>.\r\n         */\r\n        movePreviewAway: boolean;\r\n        /**\r\n         * Specifies if connections to the outline of a highlighted target should be\r\n         * enabled. This will allow to place the connection point along the outline of\r\n         * the highlighted target. Default is false.\r\n         */\r\n        outlineConnect: boolean;\r\n        /**\r\n         * Specifies if the actual shape of the edge state should be used for the preview.\r\n         * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\r\n         */\r\n        livePreview: boolean;\r\n        /**\r\n         * Specifies the cursor to be used while the handler is active. Default is null.\r\n         */\r\n        cursor: any;\r\n        /**\r\n         * Specifies if new edges should be inserted before the source vertex in the\r\n         * cell hierarchy. Default is false for backwards compatibility.\r\n         */\r\n        insertBeforeSource: boolean;\r\n        /**\r\n         * Implicit variable declarations\r\n         */\r\n        previous: any;\r\n        escapeHandler: any;\r\n        /**\r\n         * Constructs an event handler that connects vertices using the specified\r\n         * factory method to create the new edges. Modify\r\n         * <mxConstants.ACTIVE_REGION> to setup the region on a cell which triggers\r\n         * the creation of a new connection or use connect icons as explained\r\n         * above.\r\n         *\r\n         * @param graph - Reference to the enclosing <mxGraph>.\r\n         * @param factoryMethod - Optional function to create the edge. The function takes\r\n         * the source and target <mxCell> as the first and second argument and an\r\n         * optional cell style from the preview as the third argument. It returns\r\n         * the <mxCell> that represents the new edge.\r\n         */\r\n        constructor(graph?: any, factoryMethod?: any);\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): boolean;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enabled - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Returns <insertBeforeSource> for non-loops and false for loops.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * edge - <mxCell> that represents the edge to be inserted.\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         * evt - Mousedown event of the connect gesture.\r\n         * dropTarget - <mxCell> that represents the cell under the mouse when it was\r\n         * released.\r\n         */\r\n        isInsertBefore(edge: any, source: any, target: any, evt: any, dropTarget: any): boolean;\r\n        /**\r\n         * Returns <createTarget>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Current active native pointer event.\r\n         */\r\n        isCreateTarget(evt: any): boolean;\r\n        /**\r\n         * Sets <createTarget>.\r\n         */\r\n        setCreateTarget(value: any): void;\r\n        /**\r\n         * Creates the preview shape for new connections.\r\n         */\r\n        createShape(): any;\r\n        /**\r\n         * Initializes the shapes required for this connection handler. This should\r\n         * be invoked if <mxGraph.container> is assigned after the connection\r\n         * handler has been created.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Returns true if the given cell is connectable. This is a hook to\r\n         * disable floating connections. This implementation returns true.\r\n         */\r\n        isConnectableCell(cell: any): boolean;\r\n        /**\r\n         * Creates and returns the <mxCellMarker> used in <marker>.\r\n         */\r\n        createMarker(): any;\r\n        /**\r\n         * Starts a new connection for the given state and coordinates.\r\n         */\r\n        start(state: any, x: any, y: any, edgeState?: any): void;\r\n        /**\r\n         * Returns true if the source terminal has been clicked and a new\r\n         * connection is currently being previewed.\r\n         */\r\n        isConnecting(): boolean;\r\n        /**\r\n         * Returns <mxGraph.isValidSource> for the given source terminal.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> that represents the source terminal.\r\n         * me - <mxMouseEvent> that is associated with this call.\r\n         */\r\n        isValidSource(cell: any, me: any): any;\r\n        /**\r\n         * Returns true. The call to <mxGraph.isValidTarget> is implicit by calling\r\n         * <mxGraph.getEdgeValidationError> in <validateConnection>. This is an\r\n         * additional hook for disabling certain targets in this specific handler.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> that represents the target terminal.\r\n         */\r\n        isValidTarget(cell: any): boolean;\r\n        /**\r\n         * Returns the error message or an empty string if the connection for the\r\n         * given source target pair is not valid. Otherwise it returns null. This\r\n         * implementation uses <mxGraph.getEdgeValidationError>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         */\r\n        validateConnection(source: any, target: any): any;\r\n        /**\r\n         * Hook to return the <mxImage> used for the connection icon of the given\r\n         * <mxCellState>. This implementation returns <connectImage>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose connect image should be returned.\r\n         */\r\n        getConnectImage(state: any): any;\r\n        /**\r\n         * Returns true if the state has a HTML label in the graph's container, otherwise\r\n         * it returns <moveIconFront>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose connect icons should be returned.\r\n         */\r\n        isMoveIconToFrontForState(state: any): boolean;\r\n        /**\r\n         * Creates the array <mxImageShapes> that represent the connect icons for\r\n         * the given <mxCellState>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> whose connect icons should be returned.\r\n         */\r\n        createIcons(state: any): any[];\r\n        /**\r\n         * Redraws the given array of <mxImageShapes>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * icons - Optional array of <mxImageShapes> to be redrawn.\r\n         */\r\n        redrawIcons(icons: any, state: any): void;\r\n        /**\r\n         * Redraws the given array of <mxImageShapes>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * icons - Optional array of <mxImageShapes> to be redrawn.\r\n         */\r\n        getIconPosition(icon: any, state: any): mxPoint;\r\n        /**\r\n         * Destroys the connect icons and resets the respective state.\r\n         */\r\n        destroyIcons(): void;\r\n        /**\r\n         * Returns true if the given mouse down event should start this handler. The\r\n         * This implementation returns true if the event does not force marquee\r\n         * selection, and the currentConstraint and currentFocus of the\r\n         * <constraintHandler> are not null, or <previous> and <error> are not null and\r\n         * <icons> is null or <icons> and <icon> are not null.\r\n         */\r\n        isStartEvent(me: any): boolean;\r\n        /**\r\n         * Handles the event by initiating a new connection.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Returns true if a tap on the given source state should immediately start\r\n         * connecting. This implementation returns true if the state is not movable\r\n         * in the graph.\r\n         */\r\n        isImmediateConnectSource(state: any): boolean;\r\n        /**\r\n         * Hook to return an <mxCellState> which may be used during the preview.\r\n         * This implementation returns null.\r\n         *\r\n         * Use the following code to create a preview for an existing edge style:\r\n         *\r\n         * (code)\r\n         * graph.connectionHandler.createEdgeState = function(me)\r\n         * {\r\n         *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\r\n         *\r\n         *   return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));\r\n         * };\r\n         * (end)\r\n         */\r\n        createEdgeState(me: any): any;\r\n        /**\r\n         * Returns true if <outlineConnect> is true and the source of the event is the outline shape\r\n         * or shift is pressed.\r\n         */\r\n        isOutlineConnectEvent(me: any): any;\r\n        /**\r\n         * Updates the current state for a given mouse move event by using\r\n         * the <marker>.\r\n         */\r\n        updateCurrentState(me: any, point: any): void;\r\n        /**\r\n         * Converts the given point from screen coordinates to model coordinates.\r\n         */\r\n        convertWaypoint(point: any): void;\r\n        /**\r\n         * Called to snap the given point to the current preview. This snaps to the\r\n         * first point of the preview if alt is not pressed.\r\n         */\r\n        snapToPreview(me: any, point: any): void;\r\n        /**\r\n         * Handles the event by updating the preview edge or by highlighting\r\n         * a possible source or target terminal.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Updates <edgeState>.\r\n         */\r\n        updateEdgeState(current: any, constraint: any): void;\r\n        /**\r\n         * Returns the perimeter point for the given target state.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> that represents the target cell state.\r\n         * me - <mxMouseEvent> that represents the mouse move.\r\n         */\r\n        getTargetPerimeterPoint(state: any, me: any): any;\r\n        /**\r\n         * Hook to update the icon position(s) based on a mouseOver event. This is\r\n         * an empty implementation.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> that represents the target cell state.\r\n         * next - <mxPoint> that represents the next point along the previewed edge.\r\n         * me - <mxMouseEvent> that represents the mouse move.\r\n         */\r\n        getSourcePerimeterPoint(state: any, next: any, me: any): any;\r\n        /**\r\n         * Hook to update the icon position(s) based on a mouseOver event. This is\r\n         * an empty implementation.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * state - <mxCellState> under the mouse.\r\n         * icons - Array of currently displayed icons.\r\n         * me - <mxMouseEvent> that contains the mouse event.\r\n         */\r\n        updateIcons(state: any, icons: any, me: any): void;\r\n        /**\r\n         * Returns true if the given mouse up event should stop this handler. The\r\n         * connection will be created if <error> is null. Note that this is only\r\n         * called if <waypointsEnabled> is true. This implemtation returns true\r\n         * if there is a cell state in the given event.\r\n         */\r\n        isStopEvent(me: any): boolean;\r\n        /**\r\n         * Adds the waypoint for the given event to <waypoints>.\r\n         */\r\n        addWaypointForEvent(me: any): void;\r\n        /**\r\n         * Handles the event by inserting the new connection.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Resets the state of this handler.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Redraws the preview edge using the color and width returned by\r\n         * <getEdgeColor> and <getEdgeWidth>.\r\n         */\r\n        drawPreview(): void;\r\n        /**\r\n         * Returns the color used to draw the preview edge. This returns green if\r\n         * there is no edge validation error and red otherwise.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * valid - Boolean indicating if the color for a valid edge should be\r\n         * returned.\r\n         */\r\n        updatePreview(valid: any): void;\r\n        /**\r\n         * Returns the color used to draw the preview edge. This returns green if\r\n         * there is no edge validation error and red otherwise.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * valid - Boolean indicating if the color for a valid edge should be\r\n         * returned.\r\n         */\r\n        getEdgeColor(valid: any): string;\r\n        /**\r\n         * Returns the width used to draw the preview edge. This returns 3 if\r\n         * there is no edge validation error and 1 otherwise.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * valid - Boolean indicating if the width for a valid edge should be\r\n         * returned.\r\n         */\r\n        getEdgeWidth(valid: any): 1 | 3;\r\n        /**\r\n         * Connects the given source and target using a new edge. This\r\n         * implementation uses <createEdge> to create the edge.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         * evt - Mousedown event of the connect gesture.\r\n         * dropTarget - <mxCell> that represents the cell under the mouse when it was\r\n         * released.\r\n         */\r\n        connect(source: any, target: any, evt: any, dropTarget: any): void;\r\n        /**\r\n         * Selects the given edge after adding a new connection. The target argument\r\n         * contains the target vertex if one has been inserted.\r\n         */\r\n        selectCells(edge: any, target: any): void;\r\n        /**\r\n         * Creates, inserts and returns the new edge for the given parameters. This\r\n         * implementation does only use <createEdge> if <factoryMethod> is defined,\r\n         * otherwise <mxGraph.insertEdge> will be used.\r\n         */\r\n        insertEdge(parent: any, id: any, value: any, source: any, target: any, style: any): any;\r\n        /**\r\n         * Hook method for creating new vertices on the fly if no target was\r\n         * under the mouse. This is only called if <createTarget> is true and\r\n         * returns null.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Mousedown event of the connect gesture.\r\n         * source - <mxCell> that represents the source terminal.\r\n         */\r\n        createTargetVertex(evt: any, source: any): any;\r\n        /**\r\n         * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\r\n         */\r\n        getAlignmentTolerance(evt: any): any;\r\n        /**\r\n         * Creates and returns a new edge using <factoryMethod> if one exists. If\r\n         * no factory method is defined, then a new default edge is returned. The\r\n         * source and target arguments are informal, the actual connection is\r\n         * setup later by the caller of this function.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * value - Value to be used for creating the edge.\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         * style - Optional style from the preview edge.\r\n         */\r\n        createEdge(value: any, source: any, target: any, style: any): any;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes. This should be\r\n         * called on all instances. It is called automatically for the built-in\r\n         * instance created for each <mxGraph>.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Handles constraints on connection targets. This class is in charge of\r\n     * showing fixed points when the mouse is over a vertex and handles constraints\r\n     * to establish new connections.\r\n     *\r\n     * Constructor: mxConstraintHandler\r\n     *\r\n     * Constructs an new constraint handler.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     * factoryMethod - Optional function to create the edge. The function takes\r\n     * the source and target <mxCell> as the first and second argument and\r\n     * returns the <mxCell> that represents the new edge.\r\n     */\r\n    export declare class mxConstraintHandler {\r\n        /**\r\n         * mxImage to be used as the image for fixed connection points.\r\n         */\r\n        pointImage: mxImage;\r\n\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enabled - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Resets the state of this handler.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Returns the tolerance to be used for intersecting connection points. This\r\n         * implementation returns <mxGraph.tolerance>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * me - <mxMouseEvent> whose tolerance should be returned.\r\n         */\r\n        getTolerance(me: any): any;\r\n        /**\r\n         * Returns the tolerance to be used for intersecting connection points.\r\n         */\r\n        getImageForConstraint(state: any, constraint: any, point: any): any;\r\n        /**\r\n         * Returns true if the given <mxMouseEvent> should be ignored in <update>. This\r\n         * implementation always returns false.\r\n         */\r\n        isEventIgnored(me: any, source: any): boolean;\r\n        /**\r\n         * Returns true if the given state should be ignored. This always returns false.\r\n         */\r\n        isStateIgnored(state: any, source: any): boolean;\r\n        /**\r\n         * Destroys the <focusIcons> if they exist.\r\n         */\r\n        destroyIcons(): void;\r\n        /**\r\n         * Destroys the <focusHighlight> if one exists.\r\n         */\r\n        destroyFocusHighlight(): void;\r\n        /**\r\n         * Returns true if the current focused state should not be changed for the given event.\r\n         * This returns true if shift and alt are pressed.\r\n         */\r\n        isKeepFocusEvent(me: any): boolean;\r\n        /**\r\n         * Returns the cell for the given event.\r\n         */\r\n        getCellForEvent(me: any, point: any): any;\r\n        /**\r\n         * Updates the state of this handler based on the given <mxMouseEvent>.\r\n         * Source is a boolean indicating if the cell is a source or target.\r\n         */\r\n        update(me: any, source: any, existingEdge: any, point: any): void;\r\n        /**\r\n         * Transfers the focus to the given state as a source or target terminal. If\r\n         * the handler is not enabled then the outline is painted, but the constraints\r\n         * are ignored.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Transfers the focus to the given state as a source or target terminal. If\r\n         * the handler is not enabled then the outline is painted, but the constraints\r\n         * are ignored.\r\n         */\r\n        setFocus(me: any, state: any, source: any): void;\r\n        /**\r\n         * Create the shape used to paint the highlight.\r\n         *\r\n         * Returns true if the given icon intersects the given point.\r\n         */\r\n        createHighlightShape(): mxRectangleShape;\r\n        /**\r\n         * Returns true if the given icon intersects the given rectangle.\r\n         */\r\n        intersects(icon: any, mouse: any, source: any, existingEdge: any): any;\r\n        /**\r\n         * Destroy this handler.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Event handler that selects rectangular regions. This is not built-into\r\n     * <mxGraph>. To enable rubberband selection in a graph, use the following code.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var rubberband = new mxRubberband(graph);\r\n     * (end)\r\n     *\r\n     * Constructor: mxRubberband\r\n     *\r\n     * Constructs an event handler that selects rectangular regions in the graph\r\n     * using rubberband selection.\r\n     */\r\n    export declare class mxRubberband {\r\n        /**\r\n         * Variable: defaultOpacity\r\n         * \r\n         * Specifies the default opacity to be used for the rubberband div. Default\r\n         * is 20.\r\n         */\r\n        defaultOpacity: number;\r\n        /**\r\n         * Variable: fadeOut\r\n         * \r\n         * Optional fade out effect. Default is false.\r\n         */\r\n        fadeOut: boolean;\r\n        constructor(graph: any);\r\n        /**\r\n         * Returns true if events are handled. This implementation returns\r\n         * <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation updates\r\n         * <enabled>.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Returns true if the given <mxMouseEvent> should start rubberband selection.\r\n         * This implementation returns true if the alt key is pressed.\r\n         */\r\n        isForceRubberbandEvent(me: any): boolean;\r\n        /**\r\n         * Handles the event by initiating a rubberband selection. By consuming the\r\n         * event all subsequent events of the gesture are redirected to this\r\n         * handler.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Sets the start point for the rubberband selection.\r\n         */\r\n        start(x: any, y: any): void;\r\n        /**\r\n         * Handles the event by updating therubberband selection.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Creates the rubberband selection shape.\r\n         */\r\n        createShape(): any;\r\n        /**\r\n         * Returns true if this handler is active.\r\n         */\r\n        isActive(sender: any, me: any): boolean;\r\n        /**\r\n         * Handles the event by selecting the region of the rubberband using\r\n         * <mxGraph.selectRegion>.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Resets the state of this handler and selects the current region\r\n         * for the given event.\r\n         */\r\n        execute(evt: any): void;\r\n        /**\r\n         * Resets the state of the rubberband selection.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Sets <currentX> and <currentY> and calls <repaint>.\r\n         */\r\n        update(x: any, y: any): void;\r\n        /**\r\n         * Computes the bounding box and updates the style of the <div>.\r\n         */\r\n        repaint(): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes. This does\r\n         * normally not need to be called, it is called automatically when the\r\n         * window unloads.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Implements a single custom handle for vertices.\r\n     *\r\n     * Constructor: mxHandle\r\n     *\r\n     * Constructs a new handle for the given state.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * state - <mxCellState> of the cell to be handled.\r\n     */\r\n    export declare class mxHandle {\r\n        constructor(state: any, cursor: any, image: any);\r\n        /**\r\n         * Hook for subclassers to return the current position of the handle.\r\n         */\r\n        getPosition(bounds: any): void;\r\n        /**\r\n         * Hooks for subclassers to update the style in the <state>.\r\n         */\r\n        setPosition(bounds: any, pt: any, me: any): void;\r\n        /**\r\n         * Hook for subclassers to execute the handle.\r\n         */\r\n        execute(): void;\r\n        /**\r\n         * Sets the cell style with the given name to the corresponding value in <state>.\r\n         */\r\n        copyStyle(key: any): void;\r\n        /**\r\n         * Processes the given <mxMouseEvent> and invokes <setPosition>.\r\n         */\r\n        processEvent(me: any): void;\r\n        /**\r\n         * Called after <setPosition> has been called in <processEvent>. This repaints\r\n         * the state using <mxCellRenderer>.\r\n         */\r\n        positionChanged(): void;\r\n        /**\r\n         * Returns the rotation defined in the style of the cell.\r\n         */\r\n        getRotation(): any;\r\n        /**\r\n         * Returns the rotation from the style and the rotation from the direction of\r\n         * the cell.\r\n         */\r\n        getTotalRotation(): any;\r\n        /**\r\n         * Creates and initializes the shapes required for this handle.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Creates and returns the shape for this handle.\r\n         */\r\n        createShape(html: any): mxRectangleShape;\r\n        /**\r\n         * Initializes <shape> and sets its cursor.\r\n         */\r\n        initShape(html: any): void;\r\n        /**\r\n         * Renders the shape for this handle.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Returns true if this handle should be rendered in HTML. This returns true if\r\n         * the text node is in the graph container.\r\n         */\r\n        isHtmlRequired(): boolean;\r\n        /**\r\n         * Rotates the point by the given angle.\r\n         */\r\n        rotatePoint(pt: any, alpha: any): any;\r\n        /**\r\n         * Flips the given point vertically and/or horizontally.\r\n         */\r\n        flipPoint(pt: any): any;\r\n        /**\r\n         * Snaps the given point to the grid if ignore is false. This modifies\r\n         * the given point in-place and also returns it.\r\n         */\r\n        snapPoint(pt: any, ignore: any): any;\r\n        /**\r\n         * Shows or hides this handle.\r\n         */\r\n        setVisible(visible: any): void;\r\n        /**\r\n         * Resets the state of this handle by setting its visibility to true.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Destroys this handle.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Event handler for resizing cells. This handler is automatically created in\r\n     * <mxGraph.createHandler>.\r\n     *\r\n     * Constructor: mxVertexHandler\r\n     *\r\n     * Constructs an event handler that allows to resize vertices\r\n     * and groups.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * state - <mxCellState> of the cell to be resized.\r\n     */\r\n    export declare class mxVertexHandler {\r\n        /**\r\n         * Variable: singleSizer\r\n         * \r\n         * Specifies if only one sizer handle at the bottom, right corner should be\r\n         * used. Default is false.\r\n         */\r\n        singleSizer: boolean;\r\n        /**\r\n         * Variable: tolerance\r\n         * \r\n         * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\r\n         */\r\n        tolerance: number;\r\n        /**\r\n         * Variable: rotationHandleVSpacing\r\n         * \r\n         * Vertical spacing for rotation icon. Default is -16.\r\n         */\r\n        rotationHandleVSpacing: number;\r\n        /**\r\n         * Variable: parentHighlightEnabled\r\n         * \r\n         * Specifies if the parent should be highlighted if a child cell is selected.\r\n         * Default is false.\r\n         */\r\n        parentHighlightEnabled: boolean;\r\n        /**\r\n         * Variable: rotationEnabled\r\n         * \r\n         * Specifies if a rotation handle should be visible. Default is false.\r\n         */\r\n        rotationEnabled: boolean;\r\n\r\n        /**\r\n         * Variable: manageSizers\r\n         * \r\n         * Specifies if sizers should be hidden and spaced if the vertex is small.\r\n         * Default is false.\r\n         */\r\n        manageSizers: boolean;\r\n\r\n        /**\r\n         * Variable: livePreview\r\n         * \r\n         * Specifies if resize should change the cell in-place. This is an experimental\r\n         * feature for non-touch devices. Default is false.\r\n         */\r\n        livePreview: boolean;\r\n        handleImage: mxImage;\r\n        sizers: any[];\r\n        state: mxCellState;\r\n\r\n        constructor(state: any);\r\n        /**\r\n         * Initializes the shapes required for this vertex handler.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Returns true if the rotation handle should be showing.\r\n         */\r\n        isRotationHandleVisible(): boolean;\r\n        /**\r\n         * Returns true if the aspect ratio if the cell should be maintained.\r\n         */\r\n        isConstrainedEvent(me: any): boolean;\r\n        /**\r\n         * Returns true if the center of the vertex should be maintained during the resize.\r\n         */\r\n        isCenteredEvent(state: any, me: any): boolean;\r\n        /**\r\n         * Returns an array of custom handles. This implementation returns null.\r\n         */\r\n        createCustomHandles(): any;\r\n        /**\r\n         * Initializes the shapes required for this vertex handler.\r\n         */\r\n        updateMinBounds(): void;\r\n        /**\r\n         * Returns the mxRectangle that defines the bounds of the selection\r\n         * border.\r\n         */\r\n        getSelectionBounds(state: any): mxRectangle;\r\n        /**\r\n         * Creates the shape used to draw the selection border.\r\n         */\r\n        createParentHighlightShape(bounds: any): mxRectangleShape;\r\n        /**\r\n         * Creates the shape used to draw the selection border.\r\n         */\r\n        createSelectionShape(bounds: any): mxRectangleShape;\r\n        /**\r\n         * Returns <mxConstants.VERTEX_SELECTION_COLOR>.\r\n         */\r\n        getSelectionColor(): string;\r\n        /**\r\n         * Returns <mxConstants.VERTEX_SELECTION_STROKEWIDTH>.\r\n         */\r\n        getSelectionStrokeWidth(): number;\r\n        /**\r\n         * Returns <mxConstants.VERTEX_SELECTION_DASHED>.\r\n         */\r\n        isSelectionDashed(): boolean;\r\n        /**\r\n         * Creates a sizer handle for the specified cursor and index and returns\r\n         * the new <mxRectangleShape> that represents the handle.\r\n         */\r\n        createSizer(cursor: any, index: any, size: any, fillColor: any): any;\r\n        /**\r\n         * Returns true if the sizer for the given index is visible.\r\n         * This returns true for all given indices.\r\n         */\r\n        isSizerVisible(index: any): boolean;\r\n        /**\r\n         * Creates the shape used for the sizer handle for the specified bounds an\r\n         * index. Only images and rectangles should be returned if support for HTML\r\n         * labels with not foreign objects is required.\r\n         */\r\n        createSizerShape(bounds: any, index: any, fillColor: any): any;\r\n        /**\r\n         * Helper method to create an <mxRectangle> around the given centerpoint\r\n         * with a width and height of 2*s or 6, if no s is given.\r\n         */\r\n        moveSizerTo(shape: any, x: any, y: any): void;\r\n        /**\r\n         * Returns the index of the handle for the given event. This returns the index\r\n         * of the sizer from where the event originated or <mxEvent.LABEL_INDEX>.\r\n         */\r\n        getHandleForEvent(me: any): number;\r\n        /**\r\n         * Returns true if the given event allows custom handles to be changed. This\r\n         * implementation returns true.\r\n         */\r\n        isCustomHandleEvent(me: any): boolean;\r\n        /**\r\n         * Handles the event if a handle has been clicked. By consuming the\r\n         * event all subsequent events of the gesture are redirected to this\r\n         * handler.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Called if <livePreview> is enabled to check if a border should be painted.\r\n         * This implementation returns true if the shape is transparent.\r\n         */\r\n        isLivePreviewBorder(): boolean;\r\n        /**\r\n         * Starts the handling of the mouse gesture.\r\n         */\r\n        start(x: any, y: any, index: any): void;\r\n        /**\r\n         * Shortcut to <hideSizers>.\r\n         */\r\n        setHandlesVisible(visible: any): void;\r\n        /**\r\n         * Hides all sizers except.\r\n         *\r\n         * Starts the handling of the mouse gesture.\r\n         */\r\n        hideSizers(): void;\r\n        /**\r\n         * Checks if the coordinates for the given event are within the\r\n         * <mxGraph.tolerance>. If the event is a mouse event then the tolerance is\r\n         * ignored.\r\n         */\r\n        checkTolerance(me: any): void;\r\n        /**\r\n         * Hook for subclassers do show details while the handler is active.\r\n         */\r\n        updateHint(me: any): void;\r\n        /**\r\n         * Hooks for subclassers to hide details when the handler gets inactive.\r\n         */\r\n        removeHint(): void;\r\n        /**\r\n         * Hook for rounding the angle. This uses Math.round.\r\n         */\r\n        roundAngle(angle: any): number;\r\n        /**\r\n         * Hook for rounding the unscaled width or height. This uses Math.round.\r\n         */\r\n        roundLength(length: any): number;\r\n        /**\r\n         * Handles the event by updating the preview.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Rotates the vertex.\r\n         */\r\n        moveLabel(me: any): void;\r\n        /**\r\n         * Rotates the vertex.\r\n         */\r\n        rotateVertex(me: any): void;\r\n        /**\r\n         * Rotates the vertex.\r\n         */\r\n        resizeVertex(me: any): void;\r\n        /**\r\n         * Repaints the live preview.\r\n         */\r\n        updateLivePreview(me: any): void;\r\n        /**\r\n         * Handles the event by applying the changes to the geometry.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Rotates the given cell to the given rotation.\r\n         */\r\n        isRecursiveResize(state: any, me: any): any;\r\n        /**\r\n         * Hook for subclassers to implement a single click on the rotation handle.\r\n         * This code is executed as part of the model transaction. This implementation\r\n         * is empty.\r\n         */\r\n        rotateClick(): void;\r\n        /**\r\n         * Rotates the given cell and its children by the given angle in degrees.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> to be rotated.\r\n         * angle - Angle in degrees.\r\n         */\r\n        rotateCell(cell: any, angle: any, parent: any): void;\r\n        /**\r\n         * Resets the state of this handler.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Uses the given vector to change the bounds of the given cell\r\n         * in the graph using <mxGraph.resizeCell>.\r\n         */\r\n        resizeCell(cell: any, dx: any, dy: any, index: any, gridEnabled: any, constrained: any, recurse: any): void;\r\n        /**\r\n         * Moves the children of the given cell by the given vector.\r\n         */\r\n        moveChildren(cell: any, dx: any, dy: any): void;\r\n        /**\r\n         * Returns the union of the given bounds and location for the specified\r\n         * handle index.\r\n         *\r\n         * To override this to limit the size of vertex via a minWidth/-Height style,\r\n         * the following code can be used.\r\n         *\r\n         * (code)\r\n         * var vertexHandlerUnion = mxVertexHandler.prototype.union;\r\n         * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\r\n         * {\r\n         *   var result = vertexHandlerUnion.apply(this, arguments);\r\n         *\r\n         *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));\r\n         *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));\r\n         *\r\n         *   return result;\r\n         * };\r\n         * (end)\r\n         *\r\n         * The minWidth/-Height style can then be used as follows:\r\n         *\r\n         * (code)\r\n         * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\r\n         * (end)\r\n         *\r\n         * To override this to update the height for a wrapped text if the width of a vertex is\r\n         * changed, the following can be used.\r\n         *\r\n         * (code)\r\n         * var mxVertexHandlerUnion = mxVertexHandler.prototype.union;\r\n         * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\r\n         * {\r\n         *   var result = mxVertexHandlerUnion.apply(this, arguments);\r\n         *   var s = this.state;\r\n         *\r\n         *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\r\n         *       s.text != null && s.style[mxConstants.STYLE_WHITE_SPACE] == 'wrap')\r\n         *   {\r\n         *     var label = this.graph.getLabel(s.cell);\r\n         *     var fontSize = mxUtils.getNumber(s.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);\r\n         *     var ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\r\n         *\r\n         *     result.height = mxUtils.getSizeForString(label, fontSize, s.style[mxConstants.STYLE_FONTFAMILY], ww).height;\r\n         *   }\r\n         *\r\n         *   return result;\r\n         * };\r\n         * (end)\r\n         */\r\n        union(bounds: any, dx: any, dy: any, index: any, gridEnabled: any, scale: any, tr: any, constrained: any, centered: any): mxRectangle;\r\n        /**\r\n         * Redraws the handles and the preview.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Returns the padding to be used for drawing handles for the current <bounds>.\r\n         */\r\n        getHandlePadding(): mxPoint;\r\n        /**\r\n         * Redraws the handles. To hide certain handles the following code can be used.\r\n         *\r\n         * (code)\r\n         * mxVertexHandler.prototype.redrawHandles = function()\r\n         * {\r\n         *   mxVertexHandlerRedrawHandles.apply(this, arguments);\r\n         *\r\n         *   if (this.sizers != null && this.sizers.length > 7)\r\n         *   {\r\n         *     this.sizers[1].node.style.display = 'none';\r\n         *     this.sizers[6].node.style.display = 'none';\r\n         *   }\r\n         * };\r\n         * (end)\r\n         */\r\n        redrawHandles(): void;\r\n        /**\r\n         * Updates the highlight of the parent if <parentHighlightEnabled> is true.\r\n         */\r\n        updateParentHighlight(): void;\r\n        /**\r\n         * Redraws the preview.\r\n         */\r\n        drawPreview(): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Graph event handler that reconnects edges and modifies control points and\r\n     * the edge label location. Uses <mxTerminalMarker> for finding and\r\n     * highlighting new source and target vertices. This handler is automatically\r\n     * created in <mxGraph.createHandler> for each selected edge.\r\n     *\r\n     * To enable adding/removing control points, the following code can be used:\r\n     *\r\n     * (code)\r\n     * mxEdgeHandler.prototype.addEnabled = true;\r\n     * mxEdgeHandler.prototype.removeEnabled = true;\r\n     * (end)\r\n     *\r\n     * Note: This experimental feature is not recommended for production use.\r\n     *\r\n     * Constructor: mxEdgeHandler\r\n     *\r\n     * Constructs an edge handler for the specified <mxCellState>.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * state - <mxCellState> of the cell to be handled.\r\n     */\r\n    export declare class mxEdgeHandler {\r\n        /**\r\n         * Variable: handleImage\r\n         * \r\n         * Optional <mxImage> to be used as handles. Default is null.\r\n         */\r\n        handleImage: mxImage;\r\n        /**\r\n         * Variable: tolerance\r\n         * \r\n         * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\r\n         */\r\n        tolerance: number;\r\n        /**\r\n         * Variable: outlineConnect\r\n         * \r\n         * Specifies if connections to the outline of a highlighted target should be\r\n         * enabled. This will allow to place the connection point along the outline of\r\n         * the highlighted target. Default is false.\r\n         */\r\n        outlineConnect: boolean;\r\n        /**\r\n         * Variable: manageLabelHandle\r\n         * \r\n         * Specifies if the label handle should be moved if it intersects with another\r\n         * handle. Uses <checkLabelHandle> for checking and moving. Default is false.\r\n         */\r\n        manageLabelHandle: boolean;\r\n        /**\r\n         * Variable: mergeRemoveEnabled\r\n         * \r\n         * Specifies if removing bends by dropping them on other bends is enabled.\r\n         * Default is false.\r\n         */\r\n        mergeRemoveEnabled: boolean;\r\n        /**\r\n         * Variable: virtualBendsEnabled\r\n         * \r\n         * Specifies if virtual bends should be added in the center of each\r\n         * segments. These bends can then be used to add new waypoints.\r\n         * Default is false.\r\n         */\r\n        virtualBendsEnabled: boolean;\r\n        /**\r\n         * Variable: straightRemoveEnabled\r\n         * \r\n         * Specifies if removing bends by creating straight segments should be enabled.\r\n         * If enabled, this can be overridden by holding down the alt key while moving.\r\n         * Default is false.\r\n         */\r\n        straightRemoveEnabled: boolean;\r\n        /**\r\n         * Variable: dblClickRemoveEnabled\r\n         * \r\n         * Specifies if removing bends by double click is enabled. Default is false.\r\n         */\r\n        dblClickRemoveEnabled: boolean;\r\n        /**\r\n         * Variable: parentHighlightEnabled\r\n         * \r\n         * Specifies if the parent should be highlighted if a child cell is selected.\r\n         * Default is false.\r\n         */\r\n        parentHighlightEnabled: boolean;\r\n        /**\r\n         * Variable: snapToTerminals\r\n         * \r\n         * Specifies if waypoints should snap to the routing centers of terminals.\r\n         * Default is false.\r\n         */\r\n        snapToTerminals: boolean;\r\n        constructor(state: any);\r\n        /**\r\n         * Initializes the shapes required for this edge handler.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Returns an array of custom handles. This implementation returns null.\r\n         */\r\n        createCustomHandles(): any;\r\n        /**\r\n         * Returns true if virtual bends should be added. This returns true if\r\n         * <virtualBendsEnabled> is true and the current style allows and\r\n         * renders custom waypoints.\r\n         */\r\n        isVirtualBendsEnabled(evt: any): boolean;\r\n        /**\r\n         * Returns true if the given event is a trigger to add a new point. This\r\n         * implementation returns true if shift is pressed.\r\n         */\r\n        isAddPointEvent(evt: any): boolean;\r\n        /**\r\n         * Returns true if the given event is a trigger to remove a point. This\r\n         * implementation returns true if shift is pressed.\r\n         */\r\n        isRemovePointEvent(evt: any): boolean;\r\n        /**\r\n         * Returns the list of points that defines the selection stroke.\r\n         */\r\n        getSelectionPoints(state: any): any;\r\n        /**\r\n         * Creates the shape used to draw the selection border.\r\n         */\r\n        createParentHighlightShape(bounds: any): mxRectangleShape;\r\n        /**\r\n         * Creates the shape used to draw the selection border.\r\n         */\r\n        createSelectionShape(points: any): any;\r\n        /**\r\n         * Returns <mxConstants.EDGE_SELECTION_COLOR>.\r\n         */\r\n        getSelectionColor(): string;\r\n        /**\r\n         * Returns <mxConstants.EDGE_SELECTION_STROKEWIDTH>.\r\n         */\r\n        getSelectionStrokeWidth(): number;\r\n        /**\r\n         * Returns <mxConstants.EDGE_SELECTION_DASHED>.\r\n         */\r\n        isSelectionDashed(): boolean;\r\n        /**\r\n         * Returns true if the given cell is connectable. This is a hook to\r\n         * disable floating connections. This implementation returns true.\r\n         */\r\n        isConnectableCell(cell: any): boolean;\r\n        /**\r\n         * Creates and returns the <mxCellMarker> used in <marker>.\r\n         */\r\n        getCellAt(x: any, y: any): any;\r\n        /**\r\n         * Creates and returns the <mxCellMarker> used in <marker>.\r\n         */\r\n        createMarker(): any;\r\n        /**\r\n         * Returns the error message or an empty string if the connection for the\r\n         * given source, target pair is not valid. Otherwise it returns null. This\r\n         * implementation uses <mxGraph.getEdgeValidationError>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * source - <mxCell> that represents the source terminal.\r\n         * target - <mxCell> that represents the target terminal.\r\n         */\r\n        validateConnection(source: any, target: any): any;\r\n        /**\r\n         * Creates and returns the bends used for modifying the edge. This is\r\n         * typically an array of <mxRectangleShapes>.\r\n         */\r\n        createBends(): any[];\r\n        /**\r\n         * Creates and returns the bends used for modifying the edge. This is\r\n         * typically an array of <mxRectangleShapes>.\r\n         */\r\n        createVirtualBends(): any[];\r\n        /**\r\n         * Creates the shape used to display the given bend.\r\n         */\r\n        isHandleEnabled(index: any): boolean;\r\n        /**\r\n         * Returns true if the handle at the given index is visible.\r\n         */\r\n        isHandleVisible(index: any): boolean;\r\n        /**\r\n         * Creates the shape used to display the given bend. Note that the index may be\r\n         * null for special cases, such as when called from\r\n         * <mxElbowEdgeHandler.createVirtualBend>. Only images and rectangles should be\r\n         * returned if support for HTML labels with not foreign objects is required.\r\n         * Index if null for virtual handles.\r\n         */\r\n        createHandleShape(index: any): any;\r\n        /**\r\n         * Creates the shape used to display the the label handle.\r\n         */\r\n        createLabelHandleShape(): any;\r\n        /**\r\n         * Helper method to initialize the given bend.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * bend - <mxShape> that represents the bend to be initialized.\r\n         */\r\n        initBend(bend: any, dblClick: any): void;\r\n        /**\r\n         * Returns the index of the handle for the given event.\r\n         */\r\n        getHandleForEvent(me: any): any;\r\n        /**\r\n         * Returns true if the given event allows virtual bends to be added. This\r\n         * implementation returns true.\r\n         */\r\n        isAddVirtualBendEvent(me: any): boolean;\r\n        /**\r\n         * Returns true if the given event allows custom handles to be changed. This\r\n         * implementation returns true.\r\n         */\r\n        isCustomHandleEvent(me: any): boolean;\r\n        /**\r\n         * Handles the event by checking if a special element of the handler\r\n         * was clicked, in which case the index parameter is non-null. The\r\n         * indices may be one of <LABEL_HANDLE> or the number of the respective\r\n         * control point. The source and target points are used for reconnecting\r\n         * the edge.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Starts the handling of the mouse gesture.\r\n         */\r\n        start(x: any, y: any, index: any): void;\r\n        /**\r\n         * Returns a clone of the current preview state for the given point and terminal.\r\n         */\r\n        clonePreviewState(point: any, terminal: any): any;\r\n        /**\r\n         * Returns the tolerance for the guides. Default value is\r\n         * gridSize * scale / 2.\r\n         */\r\n        getSnapToTerminalTolerance(): number;\r\n        /**\r\n         * Hook for subclassers do show details while the handler is active.\r\n         */\r\n        updateHint(me: any, point: any): void;\r\n        /**\r\n         * Hooks for subclassers to hide details when the handler gets inactive.\r\n         */\r\n        removeHint(): void;\r\n        /**\r\n         * Hook for rounding the unscaled width or height. This uses Math.round.\r\n         */\r\n        roundLength(length: any): number;\r\n        /**\r\n         * Returns true if <snapToTerminals> is true and if alt is not pressed.\r\n         */\r\n        isSnapToTerminalsEvent(me: any): boolean;\r\n        /**\r\n         * Returns the point for the given event.\r\n         */\r\n        getPointForEvent(me: any): mxPoint;\r\n        /**\r\n         * Updates the given preview state taking into account the state of the constraint handler.\r\n         */\r\n        getPreviewTerminalState(me: any): any;\r\n        /**\r\n         * Updates the given preview state taking into account the state of the constraint handler.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * pt - <mxPoint> that contains the current pointer position.\r\n         * me - Optional <mxMouseEvent> that contains the current event.\r\n         */\r\n        getPreviewPoints(pt: any, me: any): any;\r\n        /**\r\n         * Returns true if <outlineConnect> is true and the source of the event is the outline shape\r\n         * or shift is pressed.\r\n         */\r\n        isOutlineConnectEvent(me: any): any;\r\n        /**\r\n         * Updates the given preview state taking into account the state of the constraint handler.\r\n         */\r\n        updatePreviewState(edge: any, point: any, terminalState: any, me: any, outline: any): void;\r\n        /**\r\n         * Handles the event by updating the preview.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event to applying the previewed changes on the edge by\r\n         * using <moveLabel>, <connect> or <changePoints>.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Resets the state of this handler.\r\n         */\r\n        reset(): void;\r\n        /**\r\n         * Sets the color of the preview to the given value.\r\n         */\r\n        setPreviewColor(color: any): void;\r\n        /**\r\n         * Converts the given point in-place from screen to unscaled, untranslated\r\n         * graph coordinates and applies the grid. Returns the given, modified\r\n         * point instance.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * point - <mxPoint> to be converted.\r\n         * gridEnabled - Boolean that specifies if the grid should be applied.\r\n         */\r\n        convertPoint(point: any, gridEnabled: any): any;\r\n        /**\r\n         * Changes the coordinates for the label of the given edge.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * edge - <mxCell> that represents the edge.\r\n         * x - Integer that specifies the x-coordinate of the new location.\r\n         * y - Integer that specifies the y-coordinate of the new location.\r\n         */\r\n        moveLabel(edgeState: any, x: any, y: any): void;\r\n        /**\r\n         * Changes the terminal or terminal point of the given edge in the graph\r\n         * model.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * edge - <mxCell> that represents the edge to be reconnected.\r\n         * terminal - <mxCell> that represents the new terminal.\r\n         * isSource - Boolean indicating if the new terminal is the source or\r\n         * target terminal.\r\n         * isClone - Boolean indicating if the new connection should be a clone of\r\n         * the old edge.\r\n         * me - <mxMouseEvent> that contains the mouse up event.\r\n         */\r\n        connect(edge: any, terminal: any, isSource: any, isClone: any, me: any): any;\r\n        /**\r\n         * Changes the terminal point of the given edge.\r\n         */\r\n        changeTerminalPoint(edge: any, point: any, isSource: any, clone: any): any;\r\n        /**\r\n         * Changes the control points of the given edge in the graph model.\r\n         */\r\n        changePoints(edge: any, points: any, clone: any): any;\r\n        /**\r\n         * Adds a control point for the given state and event.\r\n         */\r\n        addPoint(state: any, evt: any): void;\r\n        /**\r\n         * Adds a control point at the given point.\r\n         */\r\n        addPointAt(state: any, x: any, y: any): void;\r\n        /**\r\n         * Removes the control point at the given index from the given state.\r\n         */\r\n        removePoint(state: any, index: any): void;\r\n        /**\r\n         * Returns the fillcolor for the handle at the given index.\r\n         */\r\n        getHandleFillColor(index: any): string;\r\n        /**\r\n         * Redraws the preview, and the bends- and label control points.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Redraws the handles.\r\n         */\r\n        redrawHandles(): void;\r\n        /**\r\n         * Shortcut to <hideSizers>.\r\n         */\r\n        setHandlesVisible(visible: any): void;\r\n        /**\r\n         * Updates and redraws the inner bends.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * p0 - <mxPoint> that represents the location of the first point.\r\n         * pe - <mxPoint> that represents the location of the last point.\r\n         */\r\n        redrawInnerBends(p0: any, pe: any): void;\r\n        /**\r\n         * Checks if the label handle intersects the given bounds and moves it if it\r\n         * intersects.\r\n         */\r\n        checkLabelHandle(b: any): void;\r\n        /**\r\n         * Redraws the preview.\r\n         */\r\n        drawPreview(): void;\r\n        /**\r\n         * Refreshes the bends of this handler.\r\n         */\r\n        refresh(): void;\r\n        /**\r\n         * Destroys all elements in <bends>.\r\n         */\r\n        destroyBends(bends: any): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes. This does\r\n         * normally not need to be called as handlers are destroyed automatically\r\n         * when the corresponding cell is deselected.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Graph event handler that reconnects edges and modifies control points and\r\n     * the edge label location. Uses <mxTerminalMarker> for finding and\r\n     * highlighting new source and target vertices. This handler is automatically\r\n     * created in <mxGraph.createHandler>. It extends <mxEdgeHandler>.\r\n     *\r\n     * Constructor: mxEdgeHandler\r\n     *\r\n     * Constructs an edge handler for the specified <mxCellState>.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * state - <mxCellState> of the cell to be modified.\r\n     */\r\n    export declare class mxElbowEdgeHandler extends mxEdgeHandler {\r\n        constructor(state: any);\r\n        /**\r\n         * Overrides <mxEdgeHandler.createBends> to create custom bends.\r\n         */\r\n        createBends(): any[];\r\n        /**\r\n         * Creates a virtual bend that supports double clicking and calls\r\n         * <mxGraph.flipEdge>.\r\n         */\r\n        createVirtualBend(dblClickHandler: any): any;\r\n        /**\r\n         * Returns the cursor to be used for the bend.\r\n         */\r\n        getCursorForBend(): \"row-resize\" | \"col-resize\";\r\n        /**\r\n         * Returns the tooltip for the given node.\r\n         */\r\n        getTooltipForNode(node: any): any;\r\n        /**\r\n         * Converts the given point in-place from screen to unscaled, untranslated\r\n         * graph coordinates and applies the grid.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * point - <mxPoint> to be converted.\r\n         * gridEnabled - Boolean that specifies if the grid should be applied.\r\n         */\r\n        convertPoint(point: any, gridEnabled: any): any;\r\n        /**\r\n         * Updates and redraws the inner bends.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * p0 - <mxPoint> that represents the location of the first point.\r\n         * pe - <mxPoint> that represents the location of the last point.\r\n         */\r\n        redrawInnerBends(p0: any, pe: any): void;\r\n    }\r\n\r\n\r\n    export declare class mxEdgeSegmentHandler extends mxElbowEdgeHandler {\r\n        constructor(state: any);\r\n        /**\r\n         * Returns the current absolute points.\r\n         */\r\n        getCurrentPoints(): any;\r\n        /**\r\n         * Updates the given preview state taking into account the state of the constraint handler.\r\n         */\r\n        getPreviewPoints(point: any): any;\r\n        /**\r\n         * Overridden to perform optimization of the edge style result.\r\n         */\r\n        updatePreviewState(edge: any, point: any, terminalState: any, me: any): void;\r\n        /**\r\n         * Overriden to merge edge segments.\r\n         */\r\n        connect(edge: any, terminal: any, isSource: any, isClone: any, me: any): any;\r\n        /**\r\n         * Returns no tooltips.\r\n         */\r\n        getTooltipForNode(node: any): any;\r\n        /**\r\n         * Adds custom bends for the center of each segment.\r\n         */\r\n        start(x: any, y: any, index: any): void;\r\n        /**\r\n         * Adds custom bends for the center of each segment.\r\n         */\r\n        createBends(): any[];\r\n        /**\r\n         * Overridden to invoke <refresh> before the redraw.\r\n         */\r\n        redraw(): void;\r\n        /**\r\n         * Updates the position of the custom bends.\r\n         */\r\n        redrawInnerBends(p0: any, pe: any): void;\r\n    }\r\n\r\n    /**\r\n     * Event handler that listens to keystroke events. This is not a singleton,\r\n     * however, it is normally only required once if the target is the document\r\n     * element (default).\r\n     *\r\n     * This handler installs a key event listener in the topmost DOM node and\r\n     * processes all events that originate from descandants of <mxGraph.container>\r\n     * or from the topmost DOM node. The latter means that all unhandled keystrokes\r\n     * are handled by this object regardless of the focused state of the <graph>.\r\n     *\r\n     * Example:\r\n     *\r\n     * The following example creates a key handler that listens to the delete key\r\n     * (46) and deletes the selection cells if the graph is enabled.\r\n     *\r\n     * (code)\r\n     * var keyHandler = new mxKeyHandler(graph);\r\n     * keyHandler.bindKey(46, function(evt)\r\n     * {\r\n     *   if (graph.isEnabled())\r\n     *   {\r\n     *     graph.removeCells();\r\n     *   }\r\n     * });\r\n     * (end)\r\n     *\r\n     * Keycodes:\r\n     *\r\n     * See http://tinyurl.com/yp8jgl or http://tinyurl.com/229yqw for a list of\r\n     * keycodes or install a key event listener into the document element and print\r\n     * the key codes of the respective events to the console.\r\n     *\r\n     * To support the Command key and the Control key on the Mac, the following\r\n     * code can be used.\r\n     *\r\n     * (code)\r\n     * keyHandler.getFunction = function(evt)\r\n     * {\r\n     *   if (evt != null)\r\n     *   {\r\n     *     return (mxEvent.isControlDown(evt) || (mxClient.IS_MAC && evt.metaKey)) ? this.controlKeys[evt.keyCode] : this.normalKeys[evt.keyCode];\r\n     *   }\r\n     *\r\n     *   return null;\r\n     * };\r\n     * (end)\r\n     *\r\n     * Constructor: mxKeyHandler\r\n     *\r\n     * Constructs an event handler that executes functions bound to specific\r\n     * keystrokes.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the associated <mxGraph>.\r\n     * target - Optional reference to the event target. If null, the document\r\n     * element is used as the event target, that is, the object where the key\r\n     * event listener is installed.\r\n     */\r\n    export declare class mxKeyHandler {\r\n        constructor(graph: any, target?: any);\r\n        /**\r\n         * Returns true if events are handled. This implementation returns\r\n         * <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling by updating <enabled>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enabled - Boolean that specifies the new enabled state.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Binds the specified keycode to the given function. This binding is used\r\n         * if the control key is not pressed.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * code - Integer that specifies the keycode.\r\n         * funct - JavaScript function that takes the key event as an argument.\r\n         */\r\n        bindKey(code: any, funct: any): void;\r\n        /**\r\n         * Binds the specified keycode to the given function. This binding is used\r\n         * if the shift key is pressed.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * code - Integer that specifies the keycode.\r\n         * funct - JavaScript function that takes the key event as an argument.\r\n         */\r\n        bindShiftKey(code: any, funct: any): void;\r\n        /**\r\n         * Binds the specified keycode to the given function. This binding is used\r\n         * if the control key is pressed.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * code - Integer that specifies the keycode.\r\n         * funct - JavaScript function that takes the key event as an argument.\r\n         */\r\n        bindControlKey(code: any, funct: any): void;\r\n        /**\r\n         * Binds the specified keycode to the given function. This binding is used\r\n         * if the control and shift key are pressed.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * code - Integer that specifies the keycode.\r\n         * funct - JavaScript function that takes the key event as an argument.\r\n         */\r\n        bindControlShiftKey(code: any, funct: any): void;\r\n        /**\r\n         * Returns true if the control key is pressed. This uses <mxEvent.isControlDown>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Key event whose control key pressed state should be returned.\r\n         */\r\n        isControlDown(evt: any): boolean;\r\n        /**\r\n         * Returns the function associated with the given key event or null if no\r\n         * function is associated with the given event.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Key event whose associated function should be returned.\r\n         */\r\n        getFunction(evt: any): any;\r\n        /**\r\n         * Returns true if the event should be processed by this handler, that is,\r\n         * if the event source is either the target, one of its direct children, a\r\n         * descendant of the <mxGraph.container>, or the <mxGraph.cellEditor> of the\r\n         * <graph>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Key event that represents the keystroke.\r\n         */\r\n        isGraphEvent(evt: any): any;\r\n        /**\r\n         * Handles the event by invoking the function bound to the respective keystroke\r\n         * if <isEnabledForEvent> returns true for the given event and if\r\n         * <isEventIgnored> returns false, except for escape for which\r\n         * <isEventIgnored> is not invoked.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Key event that represents the keystroke.\r\n         */\r\n        keyDown(evt: any): void;\r\n        /**\r\n         * Returns true if the given event should be handled. <isEventIgnored> is\r\n         * called later if the event is not an escape key stroke, in which case\r\n         * <escape> is called. This implementation returns true if <isEnabled>\r\n         * returns true for both, this handler and <graph>, if the event is not\r\n         * consumed and if <isGraphEvent> returns true.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Key event that represents the keystroke.\r\n         */\r\n        isEnabledForEvent(evt: any): any;\r\n        /**\r\n         * Returns true if the given keystroke should be ignored. This returns\r\n         * graph.isEditing().\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Key event that represents the keystroke.\r\n         */\r\n        isEventIgnored(evt: any): any;\r\n        /**\r\n         * Hook to process ESCAPE keystrokes. This implementation invokes\r\n         * <mxGraph.stopEditing> to cancel the current editing, connecting\r\n         * and/or other ongoing modifications.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * evt - Key event that represents the keystroke. Possible keycode in this\r\n         * case is 27 (ESCAPE).\r\n         */\r\n        escape(evt: any): void;\r\n        /**\r\n         * Destroys the handler and all its references into the DOM. This does\r\n         * normally not need to be called, it is called automatically when the\r\n         * window unloads (in IE).\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Graph event handler that displays tooltips. <mxGraph.getTooltip> is used to\r\n     * get the tooltip for a cell or handle. This handler is built-into\r\n     * <mxGraph.tooltipHandler> and enabled using <mxGraph.setTooltips>.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code>\r\n     * new mxTooltipHandler(graph);\r\n     * (end)\r\n     *\r\n     * Constructor: mxTooltipHandler\r\n     *\r\n     * Constructs an event handler that displays tooltips with the specified\r\n     * delay (in milliseconds). If no delay is specified then a default delay\r\n     * of 500 ms (0.5 sec) is used.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     * delay - Optional delay in milliseconds.\r\n     */\r\n    export declare class mxTooltipHandler {\r\n        /**\r\n         * Function: getStateForEvent\r\n         * \r\n         * Returns the <mxCellState> to be used for showing a tooltip for this event.\r\n         */\r\n        getStateForEvent(me: any): any;\r\n        constructor(graph: any, delay?: number);\r\n        /**\r\n         * Returns true if events are handled. This implementation\r\n         * returns <enabled>.\r\n         */\r\n        isEnabled(): any;\r\n        /**\r\n         * Enables or disables event handling. This implementation\r\n         * updates <enabled>.\r\n         */\r\n        setEnabled(enabled: any): void;\r\n        /**\r\n         * Returns <hideOnHover>.\r\n         */\r\n        isHideOnHover(): any;\r\n        /**\r\n         * Sets <hideOnHover>.\r\n         */\r\n        setHideOnHover(value: any): void;\r\n        /**\r\n         * Initializes the DOM nodes required for this tooltip handler.\r\n         */\r\n        init(): void;\r\n        /**\r\n         * Handles the event by initiating a rubberband selection. By consuming the\r\n         * event all subsequent events of the gesture are redirected to this\r\n         * handler.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by updating the rubberband selection.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by resetting the tooltip timer or hiding the existing\r\n         * tooltip.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Resets the timer.\r\n         */\r\n        resetTimer(): void;\r\n        /**\r\n         * Resets and/or restarts the timer to trigger the display of the tooltip.\r\n         */\r\n        reset(me: any, restart: any): void;\r\n        /**\r\n         * Hides the tooltip and resets the timer.\r\n         */\r\n        hide(): void;\r\n        /**\r\n         * Hides the tooltip.\r\n         */\r\n        hideTooltip(): void;\r\n        /**\r\n         * Shows the tooltip for the specified cell and optional index at the\r\n         * specified location (with a vertical offset of 10 pixels).\r\n         */\r\n        show(tip: any, x: any, y: any): void;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Event handler that highlights cells. Inherits from <mxCellMarker>.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * new mxCellTracker(graph, '#00FF00');\r\n     * (end)\r\n     *\r\n     * For detecting dragEnter, dragOver and dragLeave on cells, the following\r\n     * code can be used:\r\n     *\r\n     * (code)\r\n     * graph.addMouseListener(\r\n     * {\r\n     *   cell: null,\r\n     *   mouseDown: function(sender, me) { },\r\n     *   mouseMove: function(sender, me)\r\n     *   {\r\n     *     var tmp = me.getCell();\r\n     *\r\n     *     if (tmp != this.cell)\r\n     *     {\r\n     *       if (this.cell != null)\r\n     *       {\r\n     *         this.dragLeave(me.getEvent(), this.cell);\r\n     *       }\r\n     *\r\n     *       this.cell = tmp;\r\n     *\r\n     *       if (this.cell != null)\r\n     *       {\r\n     *         this.dragEnter(me.getEvent(), this.cell);\r\n     *       }\r\n     *     }\r\n     *\r\n     *     if (this.cell != null)\r\n     *     {\r\n     *       this.dragOver(me.getEvent(), this.cell);\r\n     *     }\r\n     *   },\r\n     *   mouseUp: function(sender, me) { },\r\n     *   dragEnter: function(evt, cell)\r\n     *   {\r\n     *     mxLog.debug('dragEnter', cell.value);\r\n     *   },\r\n     *   dragOver: function(evt, cell)\r\n     *   {\r\n     *     mxLog.debug('dragOver', cell.value);\r\n     *   },\r\n     *   dragLeave: function(evt, cell)\r\n     *   {\r\n     *     mxLog.debug('dragLeave', cell.value);\r\n     *   }\r\n     * });\r\n     * (end)\r\n     *\r\n     * Constructor: mxCellTracker\r\n     *\r\n     * Constructs an event handler that highlights cells.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * graph - Reference to the enclosing <mxGraph>.\r\n     * color - Color of the highlight. Default is blue.\r\n     * funct - Optional JavaScript function that is used to override\r\n     * <mxCellMarker.getCell>.\r\n     */\r\n    export declare class mxCellTracker extends mxCellMarker {\r\n        constructor(graph: any, color?: any, funct?: any);\r\n        /**\r\n         * Ignores the event. The event is not consumed.\r\n         */\r\n        mouseDown(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by highlighting the cell under the mousepointer if it\r\n         * is over the hotspot region of the cell.\r\n         */\r\n        mouseMove(sender: any, me: any): void;\r\n        /**\r\n         * Handles the event by reseting the highlight.\r\n         */\r\n        mouseUp(sender: any, me: any): void;\r\n        /**\r\n         * Destroys the object and all its resources and DOM nodes. This doesn't\r\n         * normally need to be called. It is called automatically when the window\r\n         * unloads.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * A helper class to highlight cells. Here is an example for a given cell.\r\n     *\r\n     * (code)\r\n     * var highlight = new mxCellHighlight(graph, '#ff0000', 2);\r\n     * highlight.highlight(graph.view.getState(cell)));\r\n     * (end)\r\n     *\r\n     * Constructor: mxCellHighlight\r\n     *\r\n     * Constructs a cell highlight.\r\n     */\r\n    export declare class mxCellHighlight {\r\n        /**\r\n         * Variable: keepOnTop\r\n         * \r\n         * Specifies if the highlights should appear on top of everything\r\n         * else in the overlay pane. Default is false.\r\n         */\r\n        keepOnTop: boolean;\r\n        /**\r\n         * Variable: state\r\n         * \r\n         * Reference to the <mxCellState>.\r\n         */\r\n        state: mxCellState;\r\n        constructor(graph: any, highlightColor: any, strokeWidth: any, dashed: any);\r\n        /**\r\n         * Sets the color of the rectangle used to highlight drop targets.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * color - String that represents the new highlight color.\r\n         */\r\n        setHighlightColor(color: any): void;\r\n        /**\r\n         * Creates and returns the highlight shape for the given state.\r\n         */\r\n        drawHighlight(): void;\r\n        /**\r\n         * Creates and returns the highlight shape for the given state.\r\n         */\r\n        createShape(): any;\r\n        /**\r\n         * Updates the highlight after a change of the model or view.\r\n         */\r\n        getStrokeWidth(state: any): any;\r\n        /**\r\n         * Updates the highlight after a change of the model or view.\r\n         */\r\n        repaint(): void;\r\n        /**\r\n         * Resets the state of the cell marker.\r\n         */\r\n        hide(): void;\r\n        /**\r\n         * Marks the <markedState> and fires a <mark> event.\r\n         */\r\n        highlight(state: any): void;\r\n        /**\r\n         * Returns true if this highlight is at the given position.\r\n         */\r\n        isHighlightAt(x: any, y: any): boolean;\r\n        /**\r\n         * Destroys the handler and all its resources and DOM nodes.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Binds keycodes to actionnames in an editor. This aggregates an internal\r\n     * <handler> and extends the implementation of <mxKeyHandler.escape> to not\r\n     * only cancel the editing, but also hide the properties dialog and fire an\r\n     * <mxEditor.escape> event via <editor>. An instance of this class is created\r\n     * by <mxEditor> and stored in <mxEditor.keyHandler>.\r\n     *\r\n     * Example:\r\n     *\r\n     * Bind the delete key to the delete action in an existing editor.\r\n     *\r\n     * (code)\r\n     * var keyHandler = new mxDefaultKeyHandler(editor);\r\n     * keyHandler.bindAction(46, 'delete');\r\n     * (end)\r\n     *\r\n     * Codec:\r\n     *\r\n     * This class uses the <mxDefaultKeyHandlerCodec> to read configuration\r\n     * data into an existing instance. See <mxDefaultKeyHandlerCodec> for a\r\n     * description of the configuration format.\r\n     *\r\n     * Keycodes:\r\n     *\r\n     * See <mxKeyHandler>.\r\n     *\r\n     * An <mxEvent.ESCAPE> event is fired via the editor if the escape key is\r\n     * pressed.\r\n     *\r\n     * Constructor: mxDefaultKeyHandler\r\n     *\r\n     * Constructs a new default key handler for the <mxEditor.graph> in the\r\n     * given <mxEditor>. (The editor may be null if a prototypical instance for\r\n     * a <mxDefaultKeyHandlerCodec> is created.)\r\n     *\r\n     * Parameters:\r\n     *\r\n     * editor - Reference to the enclosing <mxEditor>.\r\n     */\r\n    export declare class mxDefaultKeyHandler {\r\n        constructor(editor: any);\r\n        /**\r\n         * Binds the specified keycode to the given action in <editor>. The\r\n         * optional control flag specifies if the control key must be pressed\r\n         * to trigger the action.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * code - Integer that specifies the keycode.\r\n         * action - Name of the action to execute in <editor>.\r\n         * control - Optional boolean that specifies if control must be pressed.\r\n         * Default is false.\r\n         */\r\n        bindAction(code: any, action: any, control: any): void;\r\n        /**\r\n         * Destroys the <handler> associated with this object. This does normally\r\n         * not need to be called, the <handler> is destroyed automatically when the\r\n         * window unloads (in IE) by <mxEditor>.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Creates popupmenus for mouse events. This object holds an XML node\r\n     * which is a description of the popup menu to be created. In\r\n     * <createMenu>, the configuration is applied to the context and\r\n     * the resulting menu items are added to the menu dynamically. See\r\n     * <createMenu> for a description of the configuration format.\r\n     *\r\n     * This class does not create the DOM nodes required for the popup menu, it\r\n     * only parses an XML description to invoke the respective methods on an\r\n     * <mxPopupMenu> each time the menu is displayed.\r\n     *\r\n     * Codec:\r\n     *\r\n     * This class uses the <mxDefaultPopupMenuCodec> to read configuration\r\n     * data into an existing instance, however, the actual parsing is done\r\n     * by this class during program execution, so the format is described\r\n     * below.\r\n     *\r\n     * Constructor: mxDefaultPopupMenu\r\n     *\r\n     * Constructs a new popupmenu-factory based on given configuration.\r\n     *\r\n     * Paramaters:\r\n     *\r\n     * config - XML node that contains the configuration data.\r\n     */\r\n    export declare class mxDefaultPopupMenu {\r\n        constructor(config: any);\r\n        /**\r\n         * This function is called from <mxEditor> to add items to the\r\n         * given menu based on <config>. The config is a sequence of\r\n         * the following nodes and attributes.\r\n         *\r\n         * Child Nodes:\r\n         *\r\n         * add - Adds a new menu item. See below for attributes.\r\n         * separator - Adds a separator. No attributes.\r\n         * condition - Adds a custom condition. Name attribute.\r\n         *\r\n         * The add-node may have a child node that defines a function to be invoked\r\n         * before the action is executed (or instead of an action to be executed).\r\n         *\r\n         * Attributes:\r\n         *\r\n         * as - Resource key for the label (needs entry in property file).\r\n         * action - Name of the action to execute in enclosing editor.\r\n         * icon - Optional icon (relative/absolute URL).\r\n         * iconCls - Optional CSS class for the icon.\r\n         * if - Optional name of condition that must be true (see below).\r\n         * enabled-if - Optional name of condition that specifies if the menu item\r\n         * should be enabled.\r\n         * name - Name of custom condition. Only for condition nodes.\r\n         *\r\n         * Conditions:\r\n         *\r\n         * nocell - No cell under the mouse.\r\n         * ncells - More than one cell selected.\r\n         * notRoot - Drilling position is other than home.\r\n         * cell - Cell under the mouse.\r\n         * notEmpty - Exactly one cell with children under mouse.\r\n         * expandable - Exactly one expandable cell under mouse.\r\n         * collapsable - Exactly one collapsable cell under mouse.\r\n         * validRoot - Exactly one cell which is a possible root under mouse.\r\n         * swimlane - Exactly one cell which is a swimlane under mouse.\r\n         *\r\n         * Example:\r\n         *\r\n         * To add a new item for a given action to the popupmenu:\r\n         *\r\n         * (code)\r\n         * <mxDefaultPopupMenu as=\"popupHandler\">\r\n         *   <add as=\"delete\" action=\"delete\" icon=\"images/delete.gif\" if=\"cell\"/>\r\n         * </mxDefaultPopupMenu>\r\n         * (end)\r\n         *\r\n         * To add a new item for a custom function:\r\n         *\r\n         * (code)\r\n         * <mxDefaultPopupMenu as=\"popupHandler\">\r\n         *   <add as=\"action1\"><![CDATA[\r\n         *\t\tfunction (editor, cell, evt)\r\n        *\t\t{\r\n        *\t\t\teditor.execute('action1', cell, 'myArg');\r\n        *\t\t}\r\n        *   ]]></add>\r\n        * </mxDefaultPopupMenu>\r\n        * (end)\r\n        *\r\n        * The above example invokes action1 with an additional third argument via\r\n        * the editor instance. The third argument is passed to the function that\r\n        * defines action1. If the add-node has no action-attribute, then only the\r\n        * function defined in the text content is executed, otherwise first the\r\n        * function and then the action defined in the action-attribute is\r\n        * executed. The function in the text content has 3 arguments, namely the\r\n        * <mxEditor> instance, the <mxCell> instance under the mouse, and the\r\n        * native mouse event.\r\n        *\r\n        * Custom Conditions:\r\n        *\r\n        * To add a new condition for popupmenu items:\r\n        *\r\n        * (code)\r\n        * <condition name=\"condition1\"><![CDATA[\r\n        *   function (editor, cell, evt)\r\n        *   {\r\n        *     return cell != null;\r\n        *   }\r\n        * ]]></condition>\r\n        * (end)\r\n        *\r\n        * The new condition can then be used in any item as follows:\r\n        *\r\n        * (code)\r\n        * <add as=\"action1\" action=\"action1\" icon=\"action1.gif\" if=\"condition1\"/>\r\n        * (end)\r\n        *\r\n        * The order in which the items and conditions appear is not significant as\r\n        * all connditions are evaluated before any items are created.\r\n        *\r\n        * Parameters:\r\n        *\r\n        * editor - Enclosing <mxEditor> instance.\r\n        * menu - <mxPopupMenu> that is used for adding items and separators.\r\n        * cell - Optional <mxCell> which is under the mousepointer.\r\n        * evt - Optional mouse event which triggered the menu.\r\n        */\r\n        createMenu(editor: any, menu: any, cell: any, evt: any): void;\r\n        /**\r\n         * Recursively adds the given items and all of its children into the given menu.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * editor - Enclosing <mxEditor> instance.\r\n         * menu - <mxPopupMenu> that is used for adding items and separators.\r\n         * cell - Optional <mxCell> which is under the mousepointer.\r\n         * evt - Optional mouse event which triggered the menu.\r\n         * conditions - Array of names boolean conditions.\r\n         * item - XML node that represents the current menu item.\r\n         * parent - DOM node that represents the parent menu item.\r\n         */\r\n        addItems(editor: any, menu: any, cell: any, evt: any, conditions: any, item: any, parent: any): void;\r\n        /**\r\n         * Helper method to bind an action to a new menu item.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * menu - <mxPopupMenu> that is used for adding items and separators.\r\n         * editor - Enclosing <mxEditor> instance.\r\n         * lab - String that represents the label of the menu item.\r\n         * icon - Optional URL that represents the icon of the menu item.\r\n         * action - Optional name of the action to execute in the given editor.\r\n         * funct - Optional function to execute before the optional action. The\r\n         * function takes an <mxEditor>, the <mxCell> under the mouse and the\r\n         * mouse event that triggered the call.\r\n         * cell - Optional <mxCell> to use as an argument for the action.\r\n         * parent - DOM node that represents the parent menu item.\r\n         * iconCls - Optional CSS class for the menu icon.\r\n         * enabled - Optional boolean that specifies if the menu item is enabled.\r\n         * Default is true.\r\n         */\r\n        addAction(menu: any, editor: any, lab: any, icon: any, funct: any, action: any, cell: any, parent: any, iconCls: any, enabled: any): any;\r\n        /**\r\n         * Evaluates the default conditions for the given context.\r\n         */\r\n        createConditions(editor: any, cell: any, evt: any): any[];\r\n    }\r\n\r\n    /**\r\n     * Toolbar for the editor. This modifies the state of the graph\r\n     * or inserts new cells upon mouse clicks.\r\n     *\r\n     * Example:\r\n     *\r\n     * Create a toolbar with a button to copy the selection into the clipboard,\r\n     * and a combo box with one action to paste the selection from the clipboard\r\n     * into the graph.\r\n     *\r\n     * (code)\r\n     * var toolbar = new mxDefaultToolbar(container, editor);\r\n     * toolbar.addItem('Copy', null, 'copy');\r\n     *\r\n     * var combo = toolbar.addActionCombo('More actions...');\r\n     * toolbar.addActionOption(combo, 'Paste', 'paste');\r\n     * (end)\r\n     *\r\n     * Codec:\r\n     *\r\n     * This class uses the <mxDefaultToolbarCodec> to read configuration\r\n     * data into an existing instance. See <mxDefaultToolbarCodec> for a\r\n     * description of the configuration format.\r\n     *\r\n     * Constructor: mxDefaultToolbar\r\n     *\r\n     * Constructs a new toolbar for the given container and editor. The\r\n     * container and editor may be null if a prototypical instance for a\r\n     * <mxDefaultKeyHandlerCodec> is created.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * container - DOM node that contains the toolbar.\r\n     * editor - Reference to the enclosing <mxEditor>.\r\n     */\r\n    export declare class mxDefaultToolbar {\r\n        constructor(container: any, editor: any);\r\n        /**\r\n         * Constructs the <toolbar> for the given container and installs a listener\r\n         * that updates the <mxEditor.insertFunction> on <editor> if an item is\r\n         * selected in the toolbar. This assumes that <editor> is not null.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * container - DOM node that contains the toolbar.\r\n         */\r\n        init(container: any): void;\r\n        /**\r\n         * Adds a new item that executes the given action in <editor>. The title,\r\n         * icon and pressedIcon are used to display the toolbar item.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * title - String that represents the title (tooltip) for the item.\r\n         * icon - URL of the icon to be used for displaying the item.\r\n         * action - Name of the action to execute when the item is clicked.\r\n         * pressed - Optional URL of the icon for the pressed state.\r\n         */\r\n        addItem(title: any, icon: any, action: any, pressed: any): any;\r\n        /**\r\n         * Adds a vertical separator using the optional icon.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * icon - Optional URL of the icon that represents the vertical separator.\r\n         * Default is <mxClient.imageBasePath> + '/separator.gif'.\r\n         */\r\n        addSeparator(icon: any): void;\r\n        /**\r\n         * Helper method to invoke <mxToolbar.addCombo> on <toolbar> and return the\r\n         * resulting DOM node.\r\n         */\r\n        addCombo(): any;\r\n        /**\r\n         * Helper method to invoke <mxToolbar.addActionCombo> on <toolbar> using\r\n         * the given title and return the resulting DOM node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * title - String that represents the title of the combo.\r\n         */\r\n        addActionCombo(title: any): any;\r\n        /**\r\n         * Binds the given action to a option with the specified label in the\r\n         * given combo. Combo is an object returned from an earlier call to\r\n         * <addCombo> or <addActionCombo>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * combo - DOM node that represents the combo box.\r\n         * title - String that represents the title of the combo.\r\n         * action - Name of the action to execute in <editor>.\r\n         */\r\n        addActionOption(combo: any, title: any, action: any): void;\r\n        /**\r\n         * Helper method to invoke <mxToolbar.addOption> on <toolbar> and return\r\n         * the resulting DOM node that represents the option.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * combo - DOM node that represents the combo box.\r\n         * title - String that represents the title of the combo.\r\n         * value - Object that represents the value of the option.\r\n         */\r\n        addOption(combo: any, title: any, value: any): any;\r\n        /**\r\n         * Creates an item for selecting the given mode in the <editor>'s graph.\r\n         * Supported modenames are select, connect and pan.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * title - String that represents the title of the item.\r\n         * icon - URL of the icon that represents the item.\r\n         * mode - String that represents the mode name to be used in\r\n         * <mxEditor.setMode>.\r\n         * pressed - Optional URL of the icon that represents the pressed state.\r\n         * funct - Optional JavaScript function that takes the <mxEditor> as the\r\n         * first and only argument that is executed after the mode has been\r\n         * selected.\r\n         */\r\n        addMode(title: any, icon: any, mode: any, pressed: any, funct: any): any;\r\n        /**\r\n         * Creates an item for inserting a clone of the specified prototype cell into\r\n         * the <editor>'s graph. The ptype may either be a cell or a function that\r\n         * returns a cell.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * title - String that represents the title of the item.\r\n         * icon - URL of the icon that represents the item.\r\n         * ptype - Function or object that represents the prototype cell. If ptype\r\n         * is a function then it is invoked with no arguments to create new\r\n         * instances.\r\n         * pressed - Optional URL of the icon that represents the pressed state.\r\n         * insert - Optional JavaScript function that handles an insert of the new\r\n         * cell. This function takes the <mxEditor>, new cell to be inserted, mouse\r\n         * event and optional <mxCell> under the mouse pointer as arguments.\r\n         * toggle - Optional boolean that specifies if the item can be toggled.\r\n         * Default is true.\r\n         */\r\n        addPrototype(title: any, icon: any, ptype: any, pressed: any, insert: any, toggle: any): any;\r\n        /**\r\n         * Handles a drop from a toolbar item to the graph. The given vertex\r\n         * represents the new cell to be inserted. This invokes <insert> or\r\n         * <connect> depending on the given target cell.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> to be inserted.\r\n         * evt - Mouse event that represents the drop.\r\n         * target - Optional <mxCell> that represents the drop target.\r\n         */\r\n        drop(vertex: any, evt: any, target: any): void;\r\n        /**\r\n         * Handles a drop by inserting the given vertex into the given parent cell\r\n         * or the default parent if no parent is specified.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> to be inserted.\r\n         * evt - Mouse event that represents the drop.\r\n         * parent - Optional <mxCell> that represents the parent.\r\n         */\r\n        insert(vertex: any, evt: any, target: any): any;\r\n        /**\r\n         * Handles a drop by connecting the given vertex to the given source cell.\r\n         *\r\n         * vertex - <mxCell> to be inserted.\r\n         * evt - Mouse event that represents the drop.\r\n         * source - Optional <mxCell> that represents the source terminal.\r\n         */\r\n        connect(vertex: any, evt: any, source: any): void;\r\n        /**\r\n         * Makes the given img draggable using the given function for handling a\r\n         * drop event.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * img - DOM node that represents the image.\r\n         * dropHandler - Function that handles a drop of the image.\r\n         */\r\n        installDropHandler(img: any, dropHandler: any): void;\r\n        /**\r\n         * Destroys the <toolbar> associated with this object and removes all\r\n         * installed listeners. This does normally not need to be called, the\r\n         * <toolbar> is destroyed automatically when the window unloads (in IE) by\r\n         * <mxEditor>.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    /**\r\n     * Extends <mxEventSource> to implement a application wrapper for a graph that\r\n     * adds <actions>, I/O using <mxCodec>, auto-layout using <mxLayoutManager>,\r\n     * command history using <undoManager>, and standard dialogs and widgets, eg.\r\n     * properties, help, outline, toolbar, and popupmenu. It also adds <templates>\r\n     * to be used as cells in toolbars, auto-validation using the <validation>\r\n     * flag, attribute cycling using <cycleAttributeValues>, higher-level events\r\n     * such as <root>, and backend integration using <urlPost> and <urlImage>.\r\n     *\r\n     * Actions:\r\n     *\r\n     * Actions are functions stored in the <actions> array under their names. The\r\n     * functions take the <mxEditor> as the first, and an optional <mxCell> as the\r\n     * second argument and are invoked using <execute>. Any additional arguments\r\n     * passed to execute are passed on to the action as-is.\r\n     *\r\n     * A list of built-in actions is available in the <addActions> description.\r\n     *\r\n     * Read/write Diagrams:\r\n     *\r\n     * To read a diagram from an XML string, for example from a textfield within the\r\n     * page, the following code is used:\r\n     *\r\n     * (code)\r\n     * var doc = mxUtils.parseXML(xmlString);\r\n     * var node = doc.documentElement;\r\n     * editor.readGraphModel(node);\r\n     * (end)\r\n     *\r\n     * For reading a diagram from a remote location, use the <open> method.\r\n     *\r\n     * To save diagrams in XML on a server, you can set the <urlPost> variable.\r\n     * This variable will be used in <getUrlPost> to construct a URL for the post\r\n     * request that is issued in the <save> method. The post request contains the\r\n     * XML representation of the diagram as returned by <writeGraphModel> in the\r\n     * xml parameter.\r\n     *\r\n     * On the server side, the post request is processed using standard\r\n     * technologies such as Java Servlets, CGI, .NET or ASP.\r\n     *\r\n     * Here are some examples of processing a post request in various languages.\r\n     *\r\n     * - Java: URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\")\r\n     *\r\n     * Note that the linefeeds should only be replaced if the XML is\r\n     * processed in Java, for example when creating an image, but not\r\n     * if the XML is passed back to the client-side.\r\n     *\r\n     * - .NET: HttpUtility.UrlDecode(context.Request.Params[\"xml\"])\r\n     * - PHP: urldecode($_POST[\"xml\"])\r\n     *\r\n     * Creating images:\r\n     *\r\n     * A backend (Java, PHP or C#) is required for creating images. The\r\n     * distribution contains an example for each backend (ImageHandler.java,\r\n     * ImageHandler.cs and graph.php). More information about using a backend\r\n     * to create images can be found in the readme.html files. Note that the\r\n     * preview is implemented using VML/SVG in the browser and does not require\r\n     * a backend. The backend is only required to creates images (bitmaps).\r\n     *\r\n     * Special characters:\r\n     *\r\n     * Note There are five characters that should always appear in XML content as\r\n     * escapes, so that they do not interact with the syntax of the markup. These\r\n     * are part of the language for all documents based on XML and for HTML.\r\n     *\r\n     * - &lt; (<)\r\n     * - &gt; (>)\r\n     * - &amp; (&)\r\n     * - &quot; (\")\r\n     * - &apos; (')\r\n     *\r\n     * Although it is part of the XML language, &apos; is not defined in HTML.\r\n     * For this reason the XHTML specification recommends instead the use of\r\n     * &#39; if text may be passed to a HTML user agent.\r\n     *\r\n     * If you are having problems with special characters on the server-side then\r\n     * you may want to try the <escapePostData> flag.\r\n     *\r\n     * For converting decimal escape sequences inside strings, a user has provided\r\n     * us with the following function:\r\n     *\r\n     * (code)\r\n     * function html2js(text)\r\n     * {\r\n     *   var entitySearch = /&#[0-9]+;/;\r\n     *   var entity;\r\n     *\r\n     *   while (entity = entitySearch.exec(text))\r\n     *   {\r\n     *     var charCode = entity[0].substring(2, entity[0].length -1);\r\n     *     text = text.substring(0, entity.index)\r\n     *            + String.fromCharCode(charCode)\r\n     *            + text.substring(entity.index + entity[0].length);\r\n     *   }\r\n     *\r\n     *   return text;\r\n     * }\r\n     * (end)\r\n     *\r\n     * Otherwise try using hex escape sequences and the built-in unescape function\r\n     * for converting such strings.\r\n     *\r\n     * Local Files:\r\n     *\r\n     * For saving and opening local files, no standardized method exists that\r\n     * works across all browsers. The recommended way of dealing with local files\r\n     * is to create a backend that streams the XML data back to the browser (echo)\r\n     * as an attachment so that a Save-dialog is displayed on the client-side and\r\n     * the file can be saved to the local disk.\r\n     *\r\n     * For example, in PHP the code that does this looks as follows.\r\n     *\r\n     * (code)\r\n     * $xml = stripslashes($_POST[\"xml\"]);\r\n     * header(\"Content-Disposition: attachment; filename=\\\"diagram.xml\\\"\");\r\n     * echo($xml);\r\n     * (end)\r\n     *\r\n     * To open a local file, the file should be uploaded via a form in the browser\r\n     * and then opened from the server in the editor.\r\n     *\r\n     * Cell Properties:\r\n     *\r\n     * The properties displayed in the properties dialog are the attributes and\r\n     * values of the cell's user object, which is an XML node. The XML node is\r\n     * defined in the templates section of the config file.\r\n     *\r\n     * The templates are stored in <mxEditor.templates> and contain cells which\r\n     * are cloned at insertion time to create new vertices by use of drag and\r\n     * drop from the toolbar. Each entry in the toolbar for adding a new vertex\r\n     * must refer to an existing template.\r\n     *\r\n     * In the following example, the task node is a business object and only the\r\n     * mxCell node and its mxGeometry child contain graph information:\r\n     *\r\n     * (code)\r\n     * <Task label=\"Task\" description=\"\">\r\n     *   <mxCell vertex=\"true\">\r\n     *     <mxGeometry as=\"geometry\" width=\"72\" height=\"32\"/>\r\n     *   </mxCell>\r\n     * </Task>\r\n     * (end)\r\n     *\r\n     * The idea is that the XML representation is inverse from the in-memory\r\n     * representation: The outer XML node is the user object and the inner node is\r\n     * the cell. This means the user object of the cell is the Task node with no\r\n     * children for the above example:\r\n     *\r\n     * (code)\r\n     * <Task label=\"Task\" description=\"\"/>\r\n     * (end)\r\n     *\r\n     * The Task node can have any tag name, attributes and child nodes. The\r\n     * <mxCodec> will use the XML hierarchy as the user object, while removing the\r\n     * \"known annotations\", such as the mxCell node. At save-time the cell data\r\n     * will be \"merged\" back into the user object. The user object is only modified\r\n     * via the properties dialog during the lifecycle of the cell.\r\n     *\r\n     * In the default implementation of <createProperties>, the user object's\r\n     * attributes are put into a form for editing. Attributes are changed using\r\n     * the <mxCellAttributeChange> action in the model. The dialog can be replaced\r\n     * by overriding the <createProperties> hook or by replacing the showProperties\r\n     * action in <actions>. Alternatively, the entry in the config file's popupmenu\r\n     * section can be modified to invoke a different action.\r\n     *\r\n     * If you want to displey the properties dialog on a doubleclick, you can set\r\n     * <mxEditor.dblClickAction> to showProperties as follows:\r\n     *\r\n     * (code)\r\n     * editor.dblClickAction = 'showProperties';\r\n     * (end)\r\n     *\r\n     * Popupmenu and Toolbar:\r\n     *\r\n     * The toolbar and popupmenu are typically configured using the respective\r\n     * sections in the config file, that is, the popupmenu is defined as follows:\r\n     *\r\n     * (code)\r\n     * <mxEditor>\r\n     *   <mxDefaultPopupMenu as=\"popupHandler\">\r\n     * \t\t<add as=\"cut\" action=\"cut\" icon=\"images/cut.gif\"/>\r\n     *      ...\r\n     * (end)\r\n     *\r\n     * New entries can be added to the toolbar by inserting an add-node into the\r\n     * above configuration. Existing entries may be removed and changed by\r\n     * modifying or removing the respective entries in the configuration.\r\n     * The configuration is read by the <mxDefaultPopupMenuCodec>, the format of the\r\n     * configuration is explained in <mxDefaultPopupMenu.decode>.\r\n     *\r\n     * The toolbar is defined in the mxDefaultToolbar section. Items can be added\r\n     * and removed in this section.\r\n     *\r\n     * (code)\r\n     * <mxEditor>\r\n     *   <mxDefaultToolbar>\r\n     *     <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\r\n     *     <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"/>\r\n     *     ...\r\n     * (end)\r\n     *\r\n     * The format of the configuration is described in\r\n     * <mxDefaultToolbarCodec.decode>.\r\n     *\r\n     * Ids:\r\n     *\r\n     * For the IDs, there is an implicit behaviour in <mxCodec>: It moves the Id\r\n     * from the cell to the user object at encoding time and vice versa at decoding\r\n     * time. For example, if the Task node from above has an id attribute, then\r\n     * the <mxCell.id> of the corresponding cell will have this value. If there\r\n     * is no Id collision in the model, then the cell may be retrieved using this\r\n     * Id with the <mxGraphModel.getCell> function. If there is a collision, a new\r\n     * Id will be created for the cell using <mxGraphModel.createId>. At encoding\r\n     * time, this new Id will replace the value previously stored under the id\r\n     * attribute in the Task node.\r\n     *\r\n     * See <mxEditorCodec>, <mxDefaultToolbarCodec> and <mxDefaultPopupMenuCodec>\r\n     * for information about configuring the editor and user interface.\r\n     *\r\n     * Programmatically inserting cells:\r\n     *\r\n     * For inserting a new cell, say, by clicking a button in the document,\r\n     * the following code can be used. This requires an reference to the editor.\r\n     *\r\n     * (code)\r\n     * var userObject = new Object();\r\n     * var parent = editor.graph.getDefaultParent();\r\n     * var model = editor.graph.model;\r\n     * model.beginUpdate();\r\n     * try\r\n     * {\r\n     *   editor.graph.insertVertex(parent, null, userObject, 20, 20, 80, 30);\r\n     * }\r\n     * finally\r\n     * {\r\n     *   model.endUpdate();\r\n     * }\r\n     * (end)\r\n     *\r\n     * If a template cell from the config file should be inserted, then a clone\r\n     * of the template can be created as follows. The clone is then inserted using\r\n     * the add function instead of addVertex.\r\n     *\r\n     * (code)\r\n     * var template = editor.templates['task'];\r\n     * var clone = editor.graph.model.cloneCell(template);\r\n     * (end)\r\n     *\r\n     * Resources:\r\n     *\r\n     * resources/editor - Language resources for mxEditor\r\n     *\r\n     * Callback: onInit\r\n     *\r\n     * Called from within the constructor. In the callback,\r\n     * \"this\" refers to the editor instance.\r\n     *\r\n     * Cookie: mxgraph=seen\r\n     *\r\n     * Set when the editor is started. Never expires. Use\r\n     * <resetFirstTime> to reset this cookie. This cookie\r\n     * only exists if <onInit> is implemented.\r\n     *\r\n     * Event: mxEvent.OPEN\r\n     *\r\n     * Fires after a file was opened in <open>. The <code>filename</code> property\r\n     * contains the filename that was used. The same value is also available in\r\n     * <filename>.\r\n     *\r\n     * Event: mxEvent.SAVE\r\n     *\r\n     * Fires after the current file was saved in <save>. The <code>url</code>\r\n     * property contains the URL that was used for saving.\r\n     *\r\n     * Event: mxEvent.POST\r\n     *\r\n     * Fires if a successful response was received in <postDiagram>. The\r\n     * <code>request</code> property contains the <mxXmlRequest>, the\r\n     * <code>url</code> and <code>data</code> properties contain the URL and the\r\n     * data that were used in the post request.\r\n     *\r\n     * Event: mxEvent.ROOT\r\n     *\r\n     * Fires when the current root has changed, or when the title of the current\r\n     * root has changed. This event has no properties.\r\n     *\r\n     * Event: mxEvent.BEFORE_ADD_VERTEX\r\n     *\r\n     * Fires before a vertex is added in <addVertex>. The <code>vertex</code>\r\n     * property contains the new vertex and the <code>parent</code> property\r\n     * contains its parent.\r\n     *\r\n     * Event: mxEvent.ADD_VERTEX\r\n     *\r\n     * Fires between begin- and endUpdate in <addVertex>. The <code>vertex</code>\r\n     * property contains the vertex that is being inserted.\r\n     *\r\n     * Event: mxEvent.AFTER_ADD_VERTEX\r\n     *\r\n     * Fires after a vertex was inserted and selected in <addVertex>. The\r\n     * <code>vertex</code> property contains the new vertex.\r\n     *\r\n     * Example:\r\n     *\r\n     * For starting an in-place edit after a new vertex has been added to the\r\n     * graph, the following code can be used.\r\n     *\r\n     * (code)\r\n     * editor.addListener(mxEvent.AFTER_ADD_VERTEX, function(sender, evt)\r\n     * {\r\n     *   var vertex = evt.getProperty('vertex');\r\n     *\r\n     *   if (editor.graph.isCellEditable(vertex))\r\n     *   {\r\n     *   \teditor.graph.startEditingAtCell(vertex);\r\n     *   }\r\n     * });\r\n     * (end)\r\n     *\r\n     * Event: mxEvent.ESCAPE\r\n     *\r\n     * Fires when the escape key is pressed. The <code>event</code> property\r\n     * contains the key event.\r\n     *\r\n     * Constructor: mxEditor\r\n     *\r\n     * Constructs a new editor. This function invokes the <onInit> callback\r\n     * upon completion.\r\n     *\r\n     * Example:\r\n     *\r\n     * (code)\r\n     * var config = mxUtils.load('config/diagrameditor.xml').getDocumentElement();\r\n     * var editor = new mxEditor(config);\r\n     * (end)\r\n     *\r\n     * Parameters:\r\n     *\r\n     * config - Optional XML node that contains the configuration.\r\n     */\r\n    export declare class mxEditor extends mxEventSource {\r\n        constructor(config: any);\r\n        /**\r\n         * Returns <modified>.\r\n         */\r\n        isModified(): any;\r\n        /**\r\n         * Sets <modified> to the specified boolean value.\r\n         */\r\n        setModified(value: any): void;\r\n        /**\r\n         * Adds the built-in actions to the editor instance.\r\n         *\r\n         * save - Saves the graph using <urlPost>.\r\n         * print - Shows the graph in a new print preview window.\r\n         * show - Shows the graph in a new window.\r\n         * exportImage - Shows the graph as a bitmap image using <getUrlImage>.\r\n         * refresh - Refreshes the graph's display.\r\n         * cut - Copies the current selection into the clipboard\r\n         * and removes it from the graph.\r\n         * copy - Copies the current selection into the clipboard.\r\n         * paste - Pastes the clipboard into the graph.\r\n         * delete - Removes the current selection from the graph.\r\n         * group - Puts the current selection into a new group.\r\n         * ungroup - Removes the selected groups and selects the children.\r\n         * undo - Undoes the last change on the graph model.\r\n         * redo - Redoes the last change on the graph model.\r\n         * zoom - Sets the zoom via a dialog.\r\n         * zoomIn - Zooms into the graph.\r\n         * zoomOut - Zooms out of the graph\r\n         * actualSize - Resets the scale and translation on the graph.\r\n         * fit - Changes the scale so that the graph fits into the window.\r\n         * showProperties - Shows the properties dialog.\r\n         * selectAll - Selects all cells.\r\n         * selectNone - Clears the selection.\r\n         * selectVertices - Selects all vertices.\r\n         * selectEdges = Selects all edges.\r\n         * edit - Starts editing the current selection cell.\r\n         * enterGroup - Drills down into the current selection cell.\r\n         * exitGroup - Moves up in the drilling hierachy\r\n         * home - Moves to the topmost parent in the drilling hierarchy\r\n         * selectPrevious - Selects the previous cell.\r\n         * selectNext - Selects the next cell.\r\n         * selectParent - Selects the parent of the selection cell.\r\n         * selectChild - Selects the first child of the selection cell.\r\n         * collapse - Collapses the currently selected cells.\r\n         * expand - Expands the currently selected cells.\r\n         * bold - Toggle bold text style.\r\n         * italic - Toggle italic text style.\r\n         * underline - Toggle underline text style.\r\n         * alignCellsLeft - Aligns the selection cells at the left.\r\n         * alignCellsCenter - Aligns the selection cells in the center.\r\n         * alignCellsRight - Aligns the selection cells at the right.\r\n         * alignCellsTop - Aligns the selection cells at the top.\r\n         * alignCellsMiddle - Aligns the selection cells in the middle.\r\n         * alignCellsBottom - Aligns the selection cells at the bottom.\r\n         * alignFontLeft - Sets the horizontal text alignment to left.\r\n         * alignFontCenter - Sets the horizontal text alignment to center.\r\n         * alignFontRight - Sets the horizontal text alignment to right.\r\n         * alignFontTop - Sets the vertical text alignment to top.\r\n         * alignFontMiddle - Sets the vertical text alignment to middle.\r\n         * alignFontBottom - Sets the vertical text alignment to bottom.\r\n         * toggleTasks - Shows or hides the tasks window.\r\n         * toggleHelp - Shows or hides the help window.\r\n         * toggleOutline - Shows or hides the outline window.\r\n         * toggleConsole - Shows or hides the console window.\r\n         */\r\n        addActions(): void;\r\n        /**\r\n         * Configures the editor using the specified node. To load the\r\n         * configuration from a given URL the following code can be used to obtain\r\n         * the XML node.\r\n         *\r\n         * (code)\r\n         * var node = mxUtils.load(url).getDocumentElement();\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * node - XML node that contains the configuration.\r\n         */\r\n        configure(node: any): void;\r\n        /**\r\n         * Resets the cookie that is used to remember if the editor has already\r\n         * been used.\r\n         */\r\n        resetFirstTime(): void;\r\n        /**\r\n         * Resets the command history, modified state and counters.\r\n         */\r\n        resetHistory(): void;\r\n        /**\r\n         * Binds the specified actionname to the specified function.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * actionname - String that specifies the name of the action\r\n         * to be added.\r\n         * funct - Function that implements the new action. The first\r\n         * argument of the function is the editor it is used\r\n         * with, the second argument is the cell it operates\r\n         * upon.\r\n         *\r\n         * Example:\r\n         * (code)\r\n         * editor.addAction('test', function(editor, cell)\r\n         * {\r\n         * \t\tmxUtils.alert(\"test \"+cell);\r\n         * });\r\n         * (end)\r\n         */\r\n        addAction(actionname: any, funct: any): void;\r\n        /**\r\n         * Executes the function with the given name in <actions> passing the\r\n         * editor instance and given cell as the first and second argument. All\r\n         * additional arguments are passed to the action as well. This method\r\n         * contains a try-catch block and displays an error message if an action\r\n         * causes an exception. The exception is re-thrown after the error\r\n         * message was displayed.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * editor.execute(\"showProperties\", cell);\r\n         * (end)\r\n         */\r\n        execute(actionname: any, cell: any, evt: any): void;\r\n        /**\r\n         * Adds the specified template under the given name in <templates>.\r\n         */\r\n        addTemplate(name: any, template: any): void;\r\n        /**\r\n         * Returns the template for the given name.\r\n         */\r\n        getTemplate(name: any): any;\r\n        /**\r\n         * Creates the <graph> for the editor. The graph is created with no\r\n         * container and is initialized from <setGraphContainer>.\r\n         */\r\n        createGraph(): any;\r\n        /**\r\n         * Sets the graph's container using <mxGraph.init>.\r\n         */\r\n        createSwimlaneManager(graph: any): any;\r\n        /**\r\n         * Creates a layout manager for the swimlane and diagram layouts, that\r\n         * is, the locally defined inter- and intraswimlane layouts.\r\n         */\r\n        createLayoutManager(graph: any): mxLayoutManager;\r\n        /**\r\n         * Sets the graph's container using <mxGraph.init>.\r\n         */\r\n        setGraphContainer(container: any): void;\r\n        /**\r\n         * Overrides <mxGraph.dblClick> to invoke <dblClickAction>\r\n         * on a cell and reset the selection tool in the toolbar.\r\n         */\r\n        installDblClickHandler(graph: any): void;\r\n        /**\r\n         * Adds the <undoManager> to the graph model and the view.\r\n         */\r\n        installUndoHandler(graph: any): void;\r\n        /**\r\n         * Installs listeners for dispatching the <root> event.\r\n         */\r\n        installDrillHandler(graph: any): void;\r\n        /**\r\n         * Installs the listeners required to automatically validate\r\n         * the graph. On each change of the root, this implementation\r\n         * fires a <root> event.\r\n         */\r\n        installChangeHandler(graph: any): void;\r\n        /**\r\n         * Installs the handler for invoking <insertFunction> if\r\n         * one is defined.\r\n         */\r\n        installInsertHandler(graph: any): void;\r\n        /**\r\n         * Creates the layout instance used to layout the\r\n         * swimlanes in the diagram.\r\n         */\r\n        createDiagramLayout(): any;\r\n        /**\r\n         * Creates the layout instance used to layout the\r\n         * children of each swimlane.\r\n         */\r\n        createSwimlaneLayout(): any;\r\n        /**\r\n         * Creates the <toolbar> with no container.\r\n         */\r\n        createToolbar(): mxDefaultToolbar;\r\n        /**\r\n         * Initializes the toolbar for the given container.\r\n         */\r\n        setToolbarContainer(container: any): void;\r\n        /**\r\n         * Creates the <status> using the specified container.\r\n         *\r\n         * This implementation adds listeners in the editor to\r\n         * display the last saved time and the current filename\r\n         * in the status bar.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * container - DOM node that will contain the statusbar.\r\n         */\r\n        setStatusContainer(container: any): void;\r\n        /**\r\n         * Display the specified message in the status bar.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * message - String the specified the message to\r\n         * be displayed.\r\n         */\r\n        setStatus(message: any): void;\r\n        /**\r\n         * Creates a listener to update the inner HTML of the\r\n         * specified DOM node with the value of <getTitle>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * container - DOM node that will contain the title.\r\n         */\r\n        setTitleContainer(container: any): void;\r\n        /**\r\n         * Executes a vertical or horizontal compact tree layout\r\n         * using the specified cell as an argument. The cell may\r\n         * either be a group or the root of a tree.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> to use in the compact tree layout.\r\n         * horizontal - Optional boolean to specify the tree's\r\n         * orientation. Default is true.\r\n         */\r\n        treeLayout(cell: any, horizontal: any): void;\r\n        /**\r\n         * Returns the string value for the current root of the\r\n         * diagram.\r\n         */\r\n        getTitle(): string;\r\n        /**\r\n         * Returns the string value of the root cell in\r\n         * <mxGraph.model>.\r\n         */\r\n        getRootTitle(): any;\r\n        /**\r\n         * Undo the last change in <graph>.\r\n         */\r\n        undo(): void;\r\n        /**\r\n         * Redo the last change in <graph>.\r\n         */\r\n        redo(): void;\r\n        /**\r\n         * Invokes <createGroup> to create a new group cell and the invokes\r\n         * <mxGraph.groupCells>, using the grid size of the graph as the spacing\r\n         * in the group's content area.\r\n         */\r\n        groupCells(): any;\r\n        /**\r\n         * Creates and returns a clone of <defaultGroup> to be used\r\n         * as a new group cell in <group>.\r\n         */\r\n        createGroup(): any;\r\n        /**\r\n         * Opens the specified file synchronously and parses it using\r\n         * <readGraphModel>. It updates <filename> and fires an <open>-event after\r\n         * the file has been opened. Exceptions should be handled as follows:\r\n         *\r\n         * (code)\r\n         * try\r\n         * {\r\n         *   editor.open(filename);\r\n         * }\r\n         * catch (e)\r\n         * {\r\n         *   mxUtils.error('Cannot open ' + filename +\r\n         *     ': ' + e.message, 280, true);\r\n         * }\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * filename - URL of the file to be opened.\r\n         */\r\n        open(filename: any): void;\r\n        /**\r\n         * Reads the specified XML node into the existing graph model and resets\r\n         * the command history and modified state.\r\n         */\r\n        readGraphModel(node: any): void;\r\n        /**\r\n         * Posts the string returned by <writeGraphModel> to the given URL or the\r\n         * URL returned by <getUrlPost>. The actual posting is carried out by\r\n         * <postDiagram>. If the URL is null then the resulting XML will be\r\n         * displayed using <mxUtils.popup>. Exceptions should be handled as\r\n         * follows:\r\n         *\r\n         * (code)\r\n         * try\r\n         * {\r\n         *   editor.save();\r\n         * }\r\n         * catch (e)\r\n         * {\r\n         *   mxUtils.error('Cannot save : ' + e.message, 280, true);\r\n         * }\r\n         * (end)\r\n         */\r\n        save(url: any, linefeed: any): void;\r\n        /**\r\n         * Hook for subclassers to override the posting of a diagram\r\n         * represented by the given node to the given URL. This fires\r\n         * an asynchronous <post> event if the diagram has been posted.\r\n         *\r\n         * Example:\r\n         *\r\n         * To replace the diagram with the diagram in the response, use the\r\n         * following code.\r\n         *\r\n         * (code)\r\n         * editor.addListener(mxEvent.POST, function(sender, evt)\r\n         * {\r\n         *   // Process response (replace diagram)\r\n         *   var req = evt.getProperty('request');\r\n         *   var root = req.getDocumentElement();\r\n         *   editor.graph.readGraphModel(root)\r\n         * });\r\n         * (end)\r\n         */\r\n        postDiagram(url: any, data: any): void;\r\n        /**\r\n         * Hook to create the string representation of the diagram. The default\r\n         * implementation uses an <mxCodec> to encode the graph model as\r\n         * follows:\r\n         *\r\n         * (code)\r\n         * var enc = new mxCodec();\r\n         * var node = enc.encode(this.graph.getModel());\r\n         * return mxUtils.getXml(node, this.linefeed);\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * linefeed - Optional character to be used as the linefeed. Default is\r\n         * <linefeed>.\r\n         */\r\n        writeGraphModel(linefeed: any): any;\r\n        /**\r\n         * Returns the URL to post the diagram to. This is used\r\n         * in <save>. The default implementation returns <urlPost>,\r\n         * adding <code>?draft=true</code>.\r\n         */\r\n        getUrlPost(): any;\r\n        /**\r\n         * Returns the URL to create the image with. This is typically\r\n         * the URL of a backend which accepts an XML representation\r\n         * of a graph view to create an image. The function is used\r\n         * in the image action to create an image. This implementation\r\n         * returns <urlImage>.\r\n         */\r\n        getUrlImage(): any;\r\n        /**\r\n         * Swaps the styles for the given names in the graph's\r\n         * stylesheet and refreshes the graph.\r\n         */\r\n        swapStyles(first: any, second: any): void;\r\n        /**\r\n         * Creates and shows the properties dialog for the given\r\n         * cell. The content area of the dialog is created using\r\n         * <createProperties>.\r\n         */\r\n        showProperties(cell: any): void;\r\n        /**\r\n         * Returns true if the properties dialog is currently visible.\r\n         */\r\n        isPropertiesVisible(): boolean;\r\n        /**\r\n         * Creates and returns the DOM node that represents the contents\r\n         * of the properties dialog for the given cell. This implementation\r\n         * works for user objects that are XML nodes and display all the\r\n         * node attributes in a form.\r\n         */\r\n        createProperties(cell: any): any;\r\n        /**\r\n         * Hides the properties dialog.\r\n         */\r\n        hideProperties(): void;\r\n        /**\r\n         * Shows the tasks window. The tasks window is created using <createTasks>. The\r\n         * default width of the window is 200 pixels, the y-coordinate of the location\r\n         * can be specifies in <tasksTop> and the x-coordinate is right aligned with a\r\n         * 20 pixel offset from the right border. To change the location of the tasks\r\n         * window, the following code can be used:\r\n         *\r\n         * (code)\r\n         * var oldShowTasks = mxEditor.prototype.showTasks;\r\n         * mxEditor.prototype.showTasks = function()\r\n         * {\r\n         *   oldShowTasks.apply(this, arguments); // \"supercall\"\r\n         *\r\n         *   if (this.tasks != null)\r\n         *   {\r\n         *     this.tasks.setLocation(10, 10);\r\n         *   }\r\n         * };\r\n         * (end)\r\n         */\r\n        showTasks(): void;\r\n        /**\r\n         * Updates the contents of the tasks window using <createTasks>.\r\n         */\r\n        refreshTasks(div: any): void;\r\n        /**\r\n         * Updates the contents of the given DOM node to\r\n         * display the tasks associated with the current\r\n         * editor state. This is invoked whenever there\r\n         * is a possible change of state in the editor.\r\n         * Default implementation is empty.\r\n         */\r\n        createTasks(div: any): void;\r\n        /**\r\n         * Shows the help window. If the help window does not exist\r\n         * then it is created using an iframe pointing to the resource\r\n         * for the <code>urlHelp</code> key or <urlHelp> if the resource\r\n         * is undefined.\r\n         */\r\n        showHelp(tasks: any): void;\r\n        /**\r\n         * Shows the outline window. If the window does not exist, then it is\r\n         * created using an <mxOutline>.\r\n         */\r\n        showOutline(): void;\r\n        /**\r\n         * Puts the graph into the specified mode. The following modenames are\r\n         * supported:\r\n         *\r\n         * select - Selects using the left mouse button, new connections\r\n         * are disabled.\r\n         * connect - Selects using the left mouse button or creates new\r\n         * connections if mouse over cell hotspot. See <mxConnectionHandler>.\r\n         * pan - Pans using the left mouse button, new connections are disabled.\r\n         */\r\n        setMode(modename: any): void;\r\n        /**\r\n         * Uses <popupHandler> to create the menu in the graph's\r\n         * panning handler. The redirection is setup in\r\n         * <setToolbarContainer>.\r\n         */\r\n        createPopupMenu(menu: any, cell: any, evt: any): void;\r\n        /**\r\n         * Uses <defaultEdge> as the prototype for creating new edges\r\n         * in the connection handler of the graph. The style of the\r\n         * edge will be overridden with the value returned by\r\n         * <getEdgeStyle>.\r\n         */\r\n        createEdge(source: any, target: any): any;\r\n        /**\r\n         * Returns a string identifying the style of new edges.\r\n         * The function is used in <createEdge> when new edges\r\n         * are created in the graph.\r\n         */\r\n        getEdgeStyle(): any;\r\n        /**\r\n         * Returns the next attribute in <cycleAttributeValues>\r\n         * or null, if not attribute should be used in the\r\n         * specified cell.\r\n         */\r\n        consumeCycleAttribute(cell: any): any;\r\n        /**\r\n         * Uses the returned value from <consumeCycleAttribute>\r\n         * as the value for the <cycleAttributeName> key in\r\n         * the given cell's style.\r\n         */\r\n        cycleAttribute(cell: any): void;\r\n        /**\r\n         * Adds the given vertex as a child of parent at the specified\r\n         * x and y coordinate and fires an <addVertex> event.\r\n         */\r\n        addVertex(parent: any, vertex: any, x: any, y: any): any;\r\n        /**\r\n         * Removes the editor and all its associated resources. This does not\r\n         * normally need to be called, it is called automatically when the window\r\n         * unloads.\r\n         */\r\n        destroy(): void;\r\n    }\r\n\r\n    export declare var mxCodecRegistry: {\r\n        codecs: any[];\r\n        aliases: any[];\r\n        register(codec: any): any;\r\n        addAlias(classname: any, codecname: any): void;\r\n        getCodec(ctor: any): any;\r\n    };\r\n\r\n    /**\r\n     * XML codec for JavaScript object graphs. See <mxObjectCodec> for a\r\n     * description of the general encoding/decoding scheme. This class uses the\r\n     * codecs registered in <mxCodecRegistry> for encoding/decoding each object.\r\n     *\r\n     * References:\r\n     *\r\n     * In order to resolve references, especially forward references, the mxCodec\r\n     * constructor must be given the document that contains the referenced\r\n     * elements.\r\n     *\r\n     * Examples:\r\n     *\r\n     * The following code is used to encode a graph model.\r\n     *\r\n     * (code)\r\n     * var encoder = new mxCodec();\r\n     * var result = encoder.encode(graph.getModel());\r\n     * var xml = mxUtils.getXml(result);\r\n     * (end)\r\n     *\r\n     * Example:\r\n     *\r\n     * Using the code below, an XML document is decoded into an existing model. The\r\n     * document may be obtained using one of the functions in mxUtils for loading\r\n     * an XML file, eg. <mxUtils.get>, or using <mxUtils.parseXml> for parsing an\r\n     * XML string.\r\n     *\r\n     * (code)\r\n     * var doc = mxUtils.parseXml(xmlString);\r\n     * var codec = new mxCodec(doc);\r\n     * codec.decode(doc.documentElement, graph.getModel());\r\n     * (end)\r\n     *\r\n     * Example:\r\n     *\r\n     * This example demonstrates parsing a list of isolated cells into an existing\r\n     * graph model. Note that the cells do not have a parent reference so they can\r\n     * be added anywhere in the cell hierarchy after parsing.\r\n     *\r\n     * (code)\r\n     * var xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';\r\n     * var doc = mxUtils.parseXml(xml);\r\n     * var codec = new mxCodec(doc);\r\n     * var elt = doc.documentElement.firstChild;\r\n     * var cells = [];\r\n     *\r\n     * while (elt != null)\r\n     * {\r\n     *   cells.push(codec.decode(elt));\r\n     *   elt = elt.nextSibling;\r\n     * }\r\n     *\r\n     * graph.addCells(cells);\r\n     * (end)\r\n     *\r\n     * Example:\r\n     *\r\n     * Using the following code, the selection cells of a graph are encoded and the\r\n     * output is displayed in a dialog box.\r\n     *\r\n     * (code)\r\n     * var enc = new mxCodec();\r\n     * var cells = graph.getSelectionCells();\r\n     * mxUtils.alert(mxUtils.getPrettyXml(enc.encode(cells)));\r\n     * (end)\r\n     *\r\n     * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\r\n     * must be passed to <mxUtils.getXml> as the second argument.\r\n     *\r\n     * Debugging:\r\n     *\r\n     * For debugging I/O you can use the following code to get the sequence of\r\n     * encoded objects:\r\n     *\r\n     * (code)\r\n     * var oldEncode = mxCodec.prototype.encode;\r\n     * mxCodec.prototype.encode = function(obj)\r\n     * {\r\n     *   mxLog.show();\r\n     *   mxLog.debug('mxCodec.encode: obj='+mxUtils.getFunctionName(obj.constructor));\r\n     *\r\n     *   return oldEncode.apply(this, arguments);\r\n     * };\r\n     * (end)\r\n     *\r\n     * Note that the I/O system adds object codecs for new object automatically. For\r\n     * decoding those objects, the constructor should be written as follows:\r\n     *\r\n     * (code)\r\n     * var MyObj = function(name)\r\n     * {\r\n     *   // ...\r\n     * };\r\n     * (end)\r\n     *\r\n     * Constructor: mxCodec\r\n     *\r\n     * Constructs an XML encoder/decoder for the specified\r\n     * owner document.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * document - Optional XML document that contains the data.\r\n     * If no document is specified then a new document is created\r\n     * using <mxUtils.createXmlDocument>.\r\n     */\r\n    export declare class mxCodec {\r\n        constructor(document?: any);\r\n        /**\r\n         * Assoiates the given object with the given ID and returns the given object.\r\n         *\r\n         * Parameters\r\n         *\r\n         * id - ID for the object to be associated with.\r\n         * obj - Object to be associated with the ID.\r\n         */\r\n        putObject(id: any, obj: any): any;\r\n        /**\r\n         * Returns the decoded object for the element with the specified ID in\r\n         * <document>. If the object is not known then <lookup> is used to find an\r\n         * object. If no object is found, then the element with the respective ID\r\n         * from the document is parsed using <decode>.\r\n         */\r\n        getObject(id: any): any;\r\n        /**\r\n         * Hook for subclassers to implement a custom lookup mechanism for cell IDs.\r\n         * This implementation always returns null.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * var codec = new mxCodec();\r\n         * codec.lookup = function(id)\r\n         * {\r\n         *   return model.getCell(id);\r\n         * };\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * id - ID of the object to be returned.\r\n         */\r\n        lookup(id: any): any;\r\n        /**\r\n         * Returns the element with the given ID from <document>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * id - String that contains the ID.\r\n         */\r\n        getElementById(id: any): any;\r\n        /**\r\n         * Adds the given element to <elements> if it has an ID.\r\n         */\r\n        addElement(node: any): void;\r\n        /**\r\n         * Returns the ID of the specified object. This implementation\r\n         * calls <reference> first and if that returns null handles\r\n         * the object as an <mxCell> by returning their IDs using\r\n         * <mxCell.getId>. If no ID exists for the given cell, then\r\n         * an on-the-fly ID is generated using <mxCellPath.create>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * obj - Object to return the ID for.\r\n         */\r\n        getId(obj: any): any;\r\n        /**\r\n         * Hook for subclassers to implement a custom method\r\n         * for retrieving IDs from objects. This implementation\r\n         * always returns null.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * var codec = new mxCodec();\r\n         * codec.reference = function(obj)\r\n         * {\r\n         *   return obj.getCustomId();\r\n         * };\r\n         * (end)\r\n         *\r\n         * Parameters:\r\n         *\r\n         * obj - Object whose ID should be returned.\r\n         */\r\n        reference(obj: any): any;\r\n        /**\r\n         * Encodes the specified object and returns the resulting\r\n         * XML node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * obj - Object to be encoded.\r\n         */\r\n        encode(obj: any): any;\r\n        /**\r\n         * Decodes the given XML node. The optional \"into\"\r\n         * argument specifies an existing object to be\r\n         * used. If no object is given, then a new instance\r\n         * is created using the constructor from the codec.\r\n         *\r\n         * The function returns the passed in object or\r\n         * the new instance if no object was given.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * node - XML node to be decoded.\r\n         * into - Optional object to be decodec into.\r\n         */\r\n        decode(node: any, into: any): any;\r\n        /**\r\n         * Encoding of cell hierarchies is built-into the core, but\r\n         * is a higher-level function that needs to be explicitely\r\n         * used by the respective object encoders (eg. <mxModelCodec>,\r\n         * <mxChildChangeCodec> and <mxRootChangeCodec>). This\r\n         * implementation writes the given cell and its children as a\r\n         * (flat) sequence into the given node. The children are not\r\n         * encoded if the optional includeChildren is false. The\r\n         * function is in charge of adding the result into the\r\n         * given node and has no return value.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> to be encoded.\r\n         * node - Parent XML node to add the encoded cell into.\r\n         * includeChildren - Optional boolean indicating if the\r\n         * function should include all descendents. Default is true.\r\n         */\r\n        encodeCell(cell: any, node: any, includeChildren: any): void;\r\n        /**\r\n         * Returns true if the given codec is a cell codec. This uses\r\n         * <mxCellCodec.isCellCodec> to check if the codec is of the\r\n         * given type.\r\n         */\r\n        isCellCodec(codec: any): any;\r\n        /**\r\n         * Decodes cells that have been encoded using inversion, ie.\r\n         * where the user object is the enclosing node in the XML,\r\n         * and restores the group and graph structure in the cells.\r\n         * Returns a new <mxCell> instance that represents the\r\n         * given node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * node - XML node that contains the cell data.\r\n         * restoreStructures - Optional boolean indicating whether\r\n         * the graph structure should be restored by calling insert\r\n         * and insertEdge on the parent and terminals, respectively.\r\n         * Default is true.\r\n         */\r\n        decodeCell(node: any, restoreStructures: any): any;\r\n        /**\r\n         * Inserts the given cell into its parent and terminal cells.\r\n         */\r\n        insertIntoGraph(cell: any): void;\r\n        /**\r\n         * Sets the attribute on the specified node to value. This is a\r\n         * helper method that makes sure the attribute and value arguments\r\n         * are not null.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * node - XML node to set the attribute for.\r\n         * attributes - Attributename to be set.\r\n         * value - New value of the attribute.\r\n         */\r\n        setAttribute(node: any, attribute: any, value: any): void;\r\n    }\r\n\r\n    /**\r\n     * Class: mxCellCodec\r\n     *\r\n     * Codec for <mxCell>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec>\r\n     * and the <mxCodecRegistry>.\r\n     *\r\n     * Transient Fields:\r\n     *\r\n     * - children\r\n     * - edges\r\n     * - overlays\r\n     * - mxTransient\r\n     *\r\n     * Reference Fields:\r\n     *\r\n     * - parent\r\n     * - source\r\n     * - target\r\n     * \r\n     * Transient fields can be added using the following code:\r\n     * \r\n     * mxCodecRegistry.getCodec(mxCell).exclude.push('name_of_field');\r\n     * \r\n     * To subclass <mxCell>, replace the template and add an alias as\r\n     * follows.\r\n     * \r\n     * (code)\r\n     * function CustomCell(value, geometry, style)\r\n     * {\r\n     *   mxCell.apply(this, arguments);\r\n     * }\r\n     * \r\n     * mxUtils.extend(CustomCell, mxCell);\r\n     * \r\n     * mxCodecRegistry.getCodec(mxCell).template = new CustomCell();\r\n     * mxCodecRegistry.addAlias('CustomCell', 'mxCell');\r\n     * (end)\r\n     */\r\n    export declare class mxCellCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: isCellCodec\r\n         *\r\n         * Returns true since this is a cell codec.\r\n         */\r\n        isCellCodec(): boolean;\r\n        /**\r\n         * Overidden to disable conversion of value to number.\r\n         */\r\n        isNumericAttribute(dec: any, attr: any, obj: any): boolean;\r\n        /**\r\n         * Function: isExcluded\r\n         *\r\n         * Excludes user objects that are XML nodes.\r\n         */\r\n        isExcluded(obj: any, attr: any, value: any, isWrite: any): boolean;\r\n        /**\r\n         * Function: afterEncode\r\n         *\r\n         * Encodes an <mxCell> and wraps the XML up inside the\r\n         * XML of the user object (inversion).\r\n         */\r\n        afterEncode(enc: any, obj: any, node: any): any;\r\n        /**\r\n         * Function: beforeDecode\r\n         *\r\n         * Decodes an <mxCell> and uses the enclosing XML node as\r\n         * the user object for the cell (inversion).\r\n         */\r\n        beforeDecode(dec: any, node: any, obj: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxChildChangeCodec\r\n     *\r\n     * Codec for <mxChildChange>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec> and\r\n     * the <mxCodecRegistry>.\r\n     *\r\n     * Transient Fields:\r\n     *\r\n     * - model\r\n     * - previous\r\n     * - previousIndex\r\n     * - child\r\n     *\r\n     * Reference Fields:\r\n     *\r\n     * - parent\r\n     */\r\n    export declare class mxChildChangeCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: isReference\r\n         *\r\n         * Returns true for the child attribute if the child\r\n         * cell had a previous parent or if we're reading the\r\n         * child as an attribute rather than a child node, in\r\n         * which case it's always a reference.\r\n         */\r\n        isReference(obj: any, attr: any, value: any, isWrite: any): boolean;\r\n        /**\r\n         * Function: isExcluded\r\n         *\r\n         * Excludes references to parent or previous if not in the model.\r\n         */\r\n        isExcluded(obj: any, attr: any, value: any, write: any): boolean;\r\n        /**\r\n         * Function: afterEncode\r\n         *\r\n         * Encodes the child recusively and adds the result\r\n         * to the given node.\r\n         */\r\n        afterEncode(enc: any, obj: any, node: any): any;\r\n        /**\r\n         * Function: beforeDecode\r\n         *\r\n         * Decodes the any child nodes as using the respective\r\n         * codec from the registry.\r\n         */\r\n        beforeDecode(dec: any, node: any, obj: any): any;\r\n        /**\r\n         * Function: afterDecode\r\n         *\r\n         * Restores object state in the child change.\r\n         */\r\n        afterDecode(dec: any, node: any, obj: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxDefaultKeyHandlerCodec\r\n     *\r\n     * Custom codec for configuring <mxDefaultKeyHandler>s. This class is created\r\n     * and registered dynamically at load time and used implicitely via\r\n     * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\r\n     * data for existing key handlers, it does not encode or create key handlers.\r\n     */\r\n    export declare class mxDefaultKeyHandlerCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: encode\r\n         *\r\n         * Returns null.\r\n         */\r\n        encode(enc: any, obj: any): any;\r\n\r\n        /**\r\n         * Function: decode\r\n         *\r\n         * Reads a sequence of the following child nodes\r\n         * and attributes:\r\n         *\r\n         * Child Nodes:\r\n         *\r\n         * add - Binds a keystroke to an actionname.\r\n         *\r\n         * Attributes:\r\n         *\r\n         * as - Keycode.\r\n         * action - Actionname to execute in editor.\r\n         * control - Optional boolean indicating if\r\n         * \t\tthe control key must be pressed.\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * <mxDefaultKeyHandler as=\"keyHandler\">\r\n         *   <add as=\"88\" control=\"true\" action=\"cut\"/>\r\n         *   <add as=\"67\" control=\"true\" action=\"copy\"/>\r\n         *   <add as=\"86\" control=\"true\" action=\"paste\"/>\r\n         * </mxDefaultKeyHandler>\r\n         * (end)\r\n         *\r\n         * The keycodes are for the x, c and v keys.\r\n         *\r\n         * See also: <mxDefaultKeyHandler.bindAction>,\r\n         * http://www.js-examples.com/page/tutorials__key_codes.html\r\n         */\r\n        decode(dec: any, node: any, into: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxDefaultPopupMenuCodec\r\n     *\r\n     * Custom codec for configuring <mxDefaultPopupMenu>s. This class is created\r\n     * and registered dynamically at load time and used implicitely via\r\n     * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\r\n     * data for existing popup menus, it does not encode or create menus. Note\r\n     * that this codec only passes the configuration node to the popup menu,\r\n     * which uses the config to dynamically create menus. See\r\n     * <mxDefaultPopupMenu.createMenu>.\r\n     */\r\n    export declare class mxDefaultPopupMenuCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: encode\r\n         *\r\n         * Returns null.\r\n         */\r\n        encode(enc: any, obj: any): any;\r\n        /**\r\n         * Function: decode\r\n         *\r\n         * Uses the given node as the config for <mxDefaultPopupMenu>.\r\n         */\r\n        decode(dec: any, node: any, into: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxDefaultToolbarCodec\r\n     *\r\n     * Custom codec for configuring <mxDefaultToolbar>s. This class is created\r\n     * and registered dynamically at load time and used implicitely via\r\n     * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\r\n     * data for existing toolbars handlers, it does not encode or create toolbars.\r\n     */\r\n    export declare class mxDefaultToolbarCodec extends mxObjectCodec {\r\n        /**\r\n         * Variable: allowEval\r\n         * \r\n         * Static global switch that specifies if the use of eval is allowed for\r\n         * evaluating text content. Default is true. Set this to false if stylesheets\r\n         * may contain user input\r\n         */\r\n        allowEval: boolean;\r\n        /**\r\n         * Function: encode\r\n         *\r\n         * Returns null.\r\n         */\r\n        encode(enc: any, obj: any): any;\r\n        /**\r\n         * Function: decode\r\n         *\r\n         * Reads a sequence of the following child nodes\r\n         * and attributes:\r\n         *\r\n         * Child Nodes:\r\n         *\r\n         * add - Adds a new item to the toolbar. See below for attributes.\r\n         * separator - Adds a vertical separator. No attributes.\r\n         * hr - Adds a horizontal separator. No attributes.\r\n         * br - Adds a linefeed. No attributes. \r\n         *\r\n         * Attributes:\r\n         *\r\n         * as - Resource key for the label.\r\n         * action - Name of the action to execute in enclosing editor.\r\n         * mode - Modename (see below).\r\n         * template - Template name for cell insertion.\r\n         * style - Optional style to override the template style.\r\n         * icon - Icon (relative/absolute URL).\r\n         * pressedIcon - Optional icon for pressed state (relative/absolute URL).\r\n         * id - Optional ID to be used for the created DOM element.\r\n         * toggle - Optional 0 or 1 to disable toggling of the element. Default is\r\n         * 1 (true).\r\n         *\r\n         * The action, mode and template attributes are mutually exclusive. The\r\n         * style can only be used with the template attribute. The add node may\r\n         * contain another sequence of add nodes with as and action attributes\r\n         * to create a combo box in the toolbar. If the icon is specified then\r\n         * a list of the child node is expected to have its template attribute\r\n         * set and the action is ignored instead.\r\n         * \r\n         * Nodes with a specified template may define a function to be used for\r\n         * inserting the cloned template into the graph. Here is an example of such\r\n         * a node:\r\n         * \r\n         * (code)\r\n         * <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"><![CDATA[\r\n         *   function (editor, cell, evt, targetCell)\r\n         *   {\r\n         *     var pt = mxUtils.convertPoint(\r\n         *       editor.graph.container, mxEvent.getClientX(evt),\r\n         *         mxEvent.getClientY(evt));\r\n         *     return editor.addVertex(targetCell, cell, pt.x, pt.y);\r\n         *   }\r\n         * ]]></add>\r\n         * (end)\r\n         * \r\n         * In the above function, editor is the enclosing <mxEditor> instance, cell\r\n         * is the clone of the template, evt is the mouse event that represents the\r\n         * drop and targetCell is the cell under the mousepointer where the drop\r\n         * occurred. The targetCell is retrieved using <mxGraph.getCellAt>.\r\n         *\r\n         * Futhermore, nodes with the mode attribute may define a function to\r\n         * be executed upon selection of the respective toolbar icon. In the\r\n         * example below, the default edge style is set when this specific\r\n         * connect-mode is activated:\r\n         *\r\n         * (code)\r\n         * <add as=\"connect\" mode=\"connect\"><![CDATA[\r\n         *   function (editor)\r\n         *   {\r\n         *     if (editor.defaultEdge != null)\r\n         *     {\r\n         *       editor.defaultEdge.style = 'straightEdge';\r\n         *     }\r\n         *   }\r\n         * ]]></add>\r\n         * (end)\r\n         * \r\n         * Both functions require <mxDefaultToolbarCodec.allowEval> to be set to true.\r\n         *\r\n         * Modes:\r\n         *\r\n         * select - Left mouse button used for rubberband- & cell-selection.\r\n         * connect - Allows connecting vertices by inserting new edges.\r\n         * pan - Disables selection and switches to panning on the left button.\r\n         *\r\n         * Example:\r\n         *\r\n         * To add items to the toolbar:\r\n         * \r\n         * (code)\r\n         * <mxDefaultToolbar as=\"toolbar\">\r\n         *   <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\r\n         *   <br/><hr/>\r\n         *   <add as=\"select\" mode=\"select\" icon=\"images/select.gif\"/>\r\n         *   <add as=\"connect\" mode=\"connect\" icon=\"images/connect.gif\"/>\r\n         * </mxDefaultToolbar>\r\n         * (end)\r\n         */\r\n        decode(dec: any, node: any, into: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxEditorCodec\r\n     *\r\n     * Codec for <mxEditor>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec>\r\n     * and the <mxCodecRegistry>.\r\n     *\r\n     * Transient Fields:\r\n     *\r\n     * - modified\r\n     * - lastSnapshot\r\n     * - ignoredChanges\r\n     * - undoManager\r\n     * - graphContainer\r\n     * - toolbarContainer\r\n     */\r\n    export declare class mxEditorCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: beforeDecode\r\n         *\r\n         * Decodes the ui-part of the configuration node by reading\r\n         * a sequence of the following child nodes and attributes\r\n         * and passes the control to the default decoding mechanism:\r\n         *\r\n         * Child Nodes:\r\n         *\r\n         * stylesheet - Adds a CSS stylesheet to the document.\r\n         * resource - Adds the basename of a resource bundle.\r\n         * add - Creates or configures a known UI element.\r\n         *\r\n         * These elements may appear in any order given that the\r\n         * graph UI element is added before the toolbar element\r\n         * (see Known Keys).\r\n         *\r\n         * Attributes:\r\n         *\r\n         * as - Key for the UI element (see below).\r\n         * element - ID for the element in the document.\r\n         * style - CSS style to be used for the element or window.\r\n         * x - X coordinate for the new window.\r\n         * y - Y coordinate for the new window.\r\n         * width - Width for the new window.\r\n         * height - Optional height for the new window.\r\n         * name - Name of the stylesheet (absolute/relative URL).\r\n         * basename - Basename of the resource bundle (see <mxResources>).\r\n         *\r\n         * The x, y, width and height attributes are used to create a new\r\n         * <mxWindow> if the element attribute is not specified in an add\r\n         * node. The name and basename are only used in the stylesheet and\r\n         * resource nodes, respectively.\r\n         *\r\n         * Known Keys:\r\n         *\r\n         * graph - Main graph element (see <mxEditor.setGraphContainer>).\r\n         * title - Title element (see <mxEditor.setTitleContainer>).\r\n         * toolbar - Toolbar element (see <mxEditor.setToolbarContainer>).\r\n         * status - Status bar element (see <mxEditor.setStatusContainer>).\r\n         *\r\n         * Example:\r\n         *\r\n         * (code)\r\n         * <ui>\r\n         *   <stylesheet name=\"css/process.css\"/>\r\n         *   <resource basename=\"resources/app\"/>\r\n         *   <add as=\"graph\" element=\"graph\"\r\n         *     style=\"left:70px;right:20px;top:20px;bottom:40px\"/>\r\n         *   <add as=\"status\" element=\"status\"/>\r\n         *   <add as=\"toolbar\" x=\"10\" y=\"20\" width=\"54\"/>\r\n         * </ui>\r\n         * (end)\r\n         */\r\n        afterDecode(dec: any, node: any, obj: any): any;\r\n        /**\r\n         * Function: decodeChild\r\n         * \r\n         * Overrides decode child to handle special child nodes.\r\n         */\r\n        decodeChild(dec: any, child: any, obj: any): any;\r\n        /**\r\n         * Function: decodeTemplates\r\n         *\r\n         * Decodes the cells from the given node as templates.\r\n         */\r\n        decodeUi(dec: any, node: any, editor: any): any;\r\n        /**\r\n         * Function: decodeTemplates\r\n         *\r\n         * Decodes the cells from the given node as templates.\r\n         */\r\n        decodeTemplates(dec: any, node: any, editor: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxGenericChangeCodec\r\n     *\r\n     * Codec for <mxValueChange>s, <mxStyleChange>s, <mxGeometryChange>s,\r\n     * <mxCollapseChange>s and <mxVisibleChange>s. This class is created\r\n     * and registered dynamically at load time and used implicitely\r\n     * via <mxCodec> and the <mxCodecRegistry>.\r\n     *\r\n     * Transient Fields:\r\n     *\r\n     * - model\r\n     * - previous\r\n     *\r\n     * Reference Fields:\r\n     *\r\n     * - cell\r\n     * \r\n     * Constructor: mxGenericChangeCodec\r\n     *\r\n     * Factory function that creates a <mxObjectCodec> for\r\n     * the specified change and fieldname.\r\n     *\r\n     * Parameters:\r\n     *\r\n     * obj - An instance of the change object.\r\n     * variable - The fieldname for the change data.\r\n     */\r\n    export declare class mxGenericChangeCodec {\r\n        constructor(obj: any, variable: any);\r\n        /**\r\n         * Function: afterDecode\r\n         *\r\n         * Restores the state by assigning the previous value.\r\n         */\r\n        afterDecode(dec: any, node: any, obj: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxGraphCodec\r\n     *\r\n     * Codec for <mxGraph>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec>\r\n     * and the <mxCodecRegistry>.\r\n     *\r\n     * Transient Fields:\r\n     *\r\n     * - graphListeners\r\n     * - eventListeners\r\n     * - view\r\n     * - container\r\n     * - cellRenderer\r\n     * - editor\r\n     * - selection\r\n     */\r\n    export declare class mxGraphCodec extends mxObjectCodec {\r\n\r\n    }\r\n\r\n    /**\r\n     * Class: mxGraphViewCodec\r\n     *\r\n     * Custom encoder for <mxGraphView>s. This class is created\r\n     * and registered dynamically at load time and used implicitely via\r\n     * <mxCodec> and the <mxCodecRegistry>. This codec only writes views\r\n     * into a XML format that can be used to create an image for\r\n     * the graph, that is, it contains absolute coordinates with\r\n     * computed perimeters, edge styles and cell styles.\r\n     */\r\n    export declare class mxGraphViewCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: encode\r\n         *\r\n         * Encodes the given <mxGraphView> using <encodeCell>\r\n         * starting at the model's root. This returns the\r\n         * top-level graph node of the recursive encoding.\r\n         */\r\n        encode(enc: any, view: any): any;\r\n        /**\r\n         * Function: encodeCell\r\n         *\r\n         * Recursively encodes the specifed cell. Uses layer\r\n         * as the default nodename. If the cell's parent is\r\n         * null, then graph is used for the nodename. If\r\n         * <mxGraphModel.isEdge> returns true for the cell,\r\n         * then edge is used for the nodename, else if\r\n         * <mxGraphModel.isVertex> returns true for the cell,\r\n         * then vertex is used for the nodename.\r\n         *\r\n         * <mxGraph.getLabel> is used to create the label\r\n         * attribute for the cell. For graph nodes and vertices\r\n         * the bounds are encoded into x, y, width and height.\r\n         * For edges the points are encoded into a points\r\n         * attribute as a space-separated list of comma-separated\r\n         * coordinate pairs (eg. x0,y0 x1,y1 ... xn,yn). All\r\n         * values from the cell style are added as attribute\r\n         * values to the node. \r\n         */\r\n        encodeCell(enc: any, view: any, cell: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxModelCodec\r\n     *\r\n     * Codec for <mxGraphModel>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec>\r\n     * and the <mxCodecRegistry>.\r\n     */\r\n    export declare class mxModelCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: encodeObject\r\n         *\r\n         * Encodes the given <mxGraphModel> by writing a (flat) XML sequence of\r\n         * cell nodes as produced by the <mxCellCodec>. The sequence is\r\n         * wrapped-up in a node with the name root.\r\n         */\r\n        encodeObject(enc: any, obj: any, node: any): any;\r\n        /**\r\n         * Function: decodeChild\r\n         * \r\n         * Overrides decode child to handle special child nodes.\r\n         */\r\n        decodeChild(dec: any, child: any, obj: any): any;\r\n        /**\r\n         * Function: decodeRoot\r\n         *\r\n         * Reads the cells into the graph model. All cells\r\n         * are children of the root element in the node.\r\n         */\r\n        decodeRoot(dec: any, root: any, model: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxRootChangeCodec\r\n     *\r\n     * Codec for <mxRootChange>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec> and\r\n     * the <mxCodecRegistry>.\r\n     *\r\n     * Transient Fields:\r\n     *\r\n     * - model\r\n     * - previous\r\n     * - root\r\n     */\r\n    export declare class mxRootChangeCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: onEncode\r\n         *\r\n         * Encodes the child recursively.\r\n         */\r\n        afterEncode(enc: any, obj: any, node: any): any;\r\n        /**\r\n         * Function: beforeDecode\r\n         *\r\n         * Decodes the optional children as cells\r\n         * using the respective decoder.\r\n         */\r\n        beforeDecode(dec: any, node: any, obj: any): any;\r\n        /**\r\n         * Function: afterDecode\r\n         *\r\n         * Restores the state by assigning the previous value.\r\n         */\r\n        afterDecode(dec: any, node: any, obj: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxStylesheetCodec\r\n     *\r\n     * Codec for <mxStylesheet>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec>\r\n     * and the <mxCodecRegistry>.\r\n     */\r\n    export declare class mxStylesheetCodec extends mxObjectCodec {\r\n        /**\r\n         * Variable: allowEval\r\n         * \r\n         * Static global switch that specifies if the use of eval is allowed for\r\n         * evaluating text content. Default is true. Set this to false if stylesheets\r\n         * may contain user input.\r\n         */\r\n        allowEval: boolean;\r\n        /**\r\n         * Function: encode\r\n         *\r\n         * Encodes a stylesheet. See <decode> for a description of the\r\n         * format.\r\n         */\r\n        encode(enc: any, obj: any): any;\r\n        /**\r\n         * Function: getStringValue\r\n         *\r\n         * Returns the string for encoding the given value.\r\n         */\r\n        getStringValue(key: any, value: any): any;\r\n        /**\r\n         * Function: decode\r\n         *\r\n         * Reads a sequence of the following child nodes\r\n         * and attributes:\r\n         *\r\n         * Child Nodes:\r\n         *\r\n         * add - Adds a new style.\r\n         *\r\n         * Attributes:\r\n         *\r\n         * as - Name of the style.\r\n         * extend - Name of the style to inherit from.\r\n         *\r\n         * Each node contains another sequence of add and remove nodes with the following\r\n         * attributes:\r\n         *\r\n         * as - Name of the style (see <mxConstants>).\r\n         * value - Value for the style.\r\n         *\r\n         * Instead of the value-attribute, one can put Javascript expressions into\r\n         * the node as follows if <mxStylesheetCodec.allowEval> is true:\r\n         * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>\r\n         *\r\n         * A remove node will remove the entry with the name given in the as-attribute\r\n         * from the style.\r\n         * \r\n         * Example:\r\n         *\r\n         * (code)\r\n         * <mxStylesheet as=\"stylesheet\">\r\n         *   <add as=\"text\">\r\n         *     <add as=\"fontSize\" value=\"12\"/>\r\n         *   </add>\r\n         *   <add as=\"defaultVertex\" extend=\"text\">\r\n         *     <add as=\"shape\" value=\"rectangle\"/>\r\n         *   </add>\r\n         * </mxStylesheet>\r\n         * (end)\r\n         */\r\n        decode(dec: any, node: any, into: any): any;\r\n    }\r\n\r\n    /**\r\n     * Class: mxTerminalChangeCodec\r\n     *\r\n     * Codec for <mxTerminalChange>s. This class is created and registered\r\n     * dynamically at load time and used implicitely via <mxCodec> and\r\n     * the <mxCodecRegistry>.\r\n     *\r\n     * Transient Fields:\r\n     *\r\n     * - model\r\n     * - previous\r\n     *\r\n     * Reference Fields:\r\n     *\r\n     * - cell\r\n     * - terminal\r\n     */\r\n    export declare class mxTerminalChangeCodec extends mxObjectCodec {\r\n        /**\r\n         * Function: afterDecode\r\n         *\r\n         * Restores the state by assigning the previous value.\r\n         */\r\n        afterDecode(dec: any, node: any, obj: any): any;\r\n    }\r\n\r\n    /**\r\n     * Generic codec for JavaScript objects that implements a mapping between\r\n     * JavaScript objects and XML nodes that maps each field or element to an\r\n     * attribute or child node, and vice versa.\r\n     *\r\n     * Atomic Values:\r\n     *\r\n     * Consider the following example.\r\n     *\r\n     * (code)\r\n     * var obj = new Object();\r\n     * obj.foo = \"Foo\";\r\n     * obj.bar = \"Bar\";\r\n     * (end)\r\n     *\r\n     * This object is encoded into an XML node using the following.\r\n     *\r\n     * (code)\r\n     * var enc = new mxCodec();\r\n     * var node = enc.encode(obj);\r\n     * (end)\r\n     *\r\n     * The output of the encoding may be viewed using <mxLog> as follows.\r\n     *\r\n     * (code)\r\n     * mxLog.show();\r\n     * mxLog.debug(mxUtils.getPrettyXml(node));\r\n     * (end)\r\n     *\r\n     * Finally, the result of the encoding looks as follows.\r\n     *\r\n     * (code)\r\n     * <Object foo=\"Foo\" bar=\"Bar\"/>\r\n     * (end)\r\n     *\r\n     * In the above output, the foo and bar fields have been mapped to attributes\r\n     * with the same names, and the name of the constructor was used for the\r\n     * nodename.\r\n     *\r\n     * Booleans:\r\n     *\r\n     * Since booleans are numbers in JavaScript, all boolean values are encoded\r\n     * into 1 for true and 0 for false. The decoder also accepts the string true\r\n     * and false for boolean values.\r\n     *\r\n     * Objects:\r\n     *\r\n     * The above scheme is applied to all atomic fields, that is, to all non-object\r\n     * fields of an object. For object fields, a child node is created with a\r\n     * special attribute that contains the fieldname. This special attribute is\r\n     * called \"as\" and hence, as is a reserved word that should not be used for a\r\n     * fieldname.\r\n     *\r\n     * Consider the following example where foo is an object and bar is an atomic\r\n     * property of foo.\r\n     *\r\n     * (code)\r\n     * var obj = {foo: {bar: \"Bar\"}};\r\n     * (end)\r\n     *\r\n     * This will be mapped to the following XML structure by mxObjectCodec.\r\n     *\r\n     * (code)\r\n     * <Object>\r\n     *   <Object bar=\"Bar\" as=\"foo\"/>\r\n     * </Object>\r\n     * (end)\r\n     *\r\n     * In the above output, the inner Object node contains the as-attribute that\r\n     * specifies the fieldname in the enclosing object. That is, the field foo was\r\n     * mapped to a child node with an as-attribute that has the value foo.\r\n     *\r\n     * Arrays:\r\n     *\r\n     * Arrays are special objects that are either associative, in which case each\r\n     * key, value pair is treated like a field where the key is the fieldname, or\r\n     * they are a sequence of atomic values and objects, which is mapped to a\r\n     * sequence of child nodes. For object elements, the above scheme is applied\r\n     * without the use of the special as-attribute for creating each child. For\r\n     * atomic elements, a special add-node is created with the value stored in the\r\n     * value-attribute.\r\n     *\r\n     * For example, the following array contains one atomic value and one object\r\n     * with a field called bar. Furthermore it contains two associative entries\r\n     * called bar with an atomic value, and foo with an object value.\r\n     *\r\n     * (code)\r\n     * var obj = [\"Bar\", {bar: \"Bar\"}];\r\n     * obj[\"bar\"] = \"Bar\";\r\n     * obj[\"foo\"] = {bar: \"Bar\"};\r\n     * (end)\r\n     *\r\n     * This array is represented by the following XML nodes.\r\n     *\r\n     * (code)\r\n     * <Array bar=\"Bar\">\r\n     *   <add value=\"Bar\"/>\r\n     *   <Object bar=\"Bar\"/>\r\n     *   <Object bar=\"Bar\" as=\"foo\"/>\r\n     * </Array>\r\n     * (end)\r\n     *\r\n     * The Array node name is the name of the constructor. The additional\r\n     * as-attribute in the last child contains the key of the associative entry,\r\n     * whereas the second last child is part of the array sequence and does not\r\n     * have an as-attribute.\r\n     *\r\n     * References:\r\n     *\r\n     * Objects may be represented as child nodes or attributes with ID values,\r\n     * which are used to lookup the object in a table within <mxCodec>. The\r\n     * <isReference> function is in charge of deciding if a specific field should\r\n     * be encoded as a reference or not. Its default implementation returns true if\r\n     * the fieldname is in <idrefs>, an array of strings that is used to configure\r\n     * the <mxObjectCodec>.\r\n     *\r\n     * Using this approach, the mapping does not guarantee that the referenced\r\n     * object itself exists in the document. The fields that are encoded as\r\n     * references must be carefully chosen to make sure all referenced objects\r\n     * exist in the document, or may be resolved by some other means if necessary.\r\n     *\r\n     * For example, in the case of the graph model all cells are stored in a tree\r\n     * whose root is referenced by the model's root field. A tree is a structure\r\n     * that is well suited for an XML representation, however, the additional edges\r\n     * in the graph model have a reference to a source and target cell, which are\r\n     * also contained in the tree. To handle this case, the source and target cell\r\n     * of an edge are treated as references, whereas the children are treated as\r\n     * objects. Since all cells are contained in the tree and no edge references a\r\n     * source or target outside the tree, this setup makes sure all referenced\r\n     * objects are contained in the document.\r\n     *\r\n     * In the case of a tree structure we must further avoid infinite recursion by\r\n     * ignoring the parent reference of each child. This is done by returning true\r\n     * in <isExcluded>, whose default implementation uses the array of excluded\r\n     * fieldnames passed to the mxObjectCodec constructor.\r\n     *\r\n     * References are only used for cells in mxGraph. For defining other\r\n     * referencable object types, the codec must be able to work out the ID of an\r\n     * object. This is done by implementing <mxCodec.reference>. For decoding a\r\n     * reference, the XML node with the respective id-attribute is fetched from the\r\n     * document, decoded, and stored in a lookup table for later reference. For\r\n     * looking up external objects, <mxCodec.lookup> may be implemented.\r\n     *\r\n     * Expressions:\r\n     *\r\n     * For decoding JavaScript expressions, the add-node may be used with a text\r\n     * content that contains the JavaScript expression. For example, the following\r\n     * creates a field called foo in the enclosing object and assigns it the value\r\n     * of <mxConstants.ALIGN_LEFT>.\r\n     *\r\n     * (code)\r\n     * <Object>\r\n     *   <add as=\"foo\">mxConstants.ALIGN_LEFT</add>\r\n     * </Object>\r\n     * (end)\r\n     *\r\n     * The resulting object has a field called foo with the value \"left\". Its XML\r\n     * representation looks as follows.\r\n     *\r\n     * (code)\r\n     * <Object foo=\"left\"/>\r\n     * (end)\r\n     *\r\n     * This means the expression is evaluated at decoding time and the result of\r\n     * the evaluation is stored in the respective field. Valid expressions are all\r\n     * JavaScript expressions, including function definitions, which are mapped to\r\n     * functions on the resulting object.\r\n     *\r\n     * Expressions are only evaluated if <allowEval> is true.\r\n     *\r\n     * Constructor: mxObjectCodec\r\n     *\r\n     * Constructs a new codec for the specified template object.\r\n     * The variables in the optional exclude array are ignored by\r\n     * the codec. Variables in the optional idrefs array are\r\n     * turned into references in the XML. The optional mapping\r\n     * may be used to map from variable names to XML attributes.\r\n     * The argument is created as follows:\r\n     *\r\n     * (code)\r\n     * var mapping = new Object();\r\n     * mapping['variableName'] = 'attribute-name';\r\n     * (end)\r\n     *\r\n     * Parameters:\r\n     *\r\n     * template - Prototypical instance of the object to be\r\n     * encoded/decoded.\r\n     * exclude - Optional array of fieldnames to be ignored.\r\n     * idrefs - Optional array of fieldnames to be converted to/from\r\n     * references.\r\n     * mapping - Optional mapping from field- to attributenames.\r\n     */\r\n    export declare class mxObjectCodec {\r\n        constructor(template: any, exclude: any, idrefs: any, mapping: any);\r\n        /**\r\n         * Returns the name used for the nodenames and lookup of the codec when\r\n         * classes are encoded and nodes are decoded. For classes to work with\r\n         * this the codec registry automatically adds an alias for the classname\r\n         * if that is different than what this returns. The default implementation\r\n         * returns the classname of the template class.\r\n         */\r\n        getName(): any;\r\n        /**\r\n         * Returns a new instance of the template for this codec.\r\n         */\r\n        cloneTemplate(): any;\r\n        /**\r\n         * Returns the fieldname for the given attributename.\r\n         * Looks up the value in the <reverse> mapping or returns\r\n         * the input if there is no reverse mapping for the\r\n         * given name.\r\n         */\r\n        getFieldName(attributename: any): any;\r\n        /**\r\n         * Returns the attributename for the given fieldname.\r\n         * Looks up the value in the <mapping> or returns\r\n         * the input if there is no mapping for the\r\n         * given name.\r\n         */\r\n        getAttributeName(fieldname: any): any;\r\n        /**\r\n         * Returns true if the given attribute is to be ignored by the codec. This\r\n         * implementation returns true if the given fieldname is in <exclude> or\r\n         * if the fieldname equals <mxObjectIdentity.FIELD_NAME>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * obj - Object instance that contains the field.\r\n         * attr - Fieldname of the field.\r\n         * value - Value of the field.\r\n         * write - Boolean indicating if the field is being encoded or decoded.\r\n         * Write is true if the field is being encoded, else it is being decoded.\r\n         */\r\n        isExcluded(obj: any, attr: any, value: any, write: any): boolean;\r\n        /**\r\n         * Returns true if the given fieldname is to be treated\r\n         * as a textual reference (ID). This implementation returns\r\n         * true if the given fieldname is in <idrefs>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * obj - Object instance that contains the field.\r\n         * attr - Fieldname of the field.\r\n         * value - Value of the field.\r\n         * write - Boolean indicating if the field is being encoded or decoded.\r\n         * Write is true if the field is being encoded, else it is being decoded.\r\n         */\r\n        isReference(obj: any, attr: any, value: any, write: any): boolean;\r\n        /**\r\n         * Encodes the specified object and returns a node\r\n         * representing then given object. Calls <beforeEncode>\r\n         * after creating the node and <afterEncode> with the\r\n         * resulting node after processing.\r\n         *\r\n         * Enc is a reference to the calling encoder. It is used\r\n         * to encode complex objects and create references.\r\n         *\r\n         * This implementation encodes all variables of an\r\n         * object according to the following rules:\r\n         *\r\n         * - If the variable name is in <exclude> then it is ignored.\r\n         * - If the variable name is in <idrefs> then <mxCodec.getId>\r\n         * is used to replace the object with its ID.\r\n         * - The variable name is mapped using <mapping>.\r\n         * - If obj is an array and the variable name is numeric\r\n         * (ie. an index) then it is not encoded.\r\n         * - If the value is an object, then the codec is used to\r\n         * create a child node with the variable name encoded into\r\n         * the \"as\" attribute.\r\n         * - Else, if <encodeDefaults> is true or the value differs\r\n         * from the template value, then ...\r\n         * - ... if obj is not an array, then the value is mapped to\r\n         * an attribute.\r\n         * - ... else if obj is an array, the value is mapped to an\r\n         * add child with a value attribute or a text child node,\r\n         * if the value is a function.\r\n         *\r\n         * If no ID exists for a variable in <idrefs> or if an object\r\n         * cannot be encoded, a warning is issued using <mxLog.warn>.\r\n         *\r\n         * Returns the resulting XML node that represents the given\r\n         * object.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * obj - Object to be encoded.\r\n         */\r\n        encode(enc: any, obj: any): any;\r\n        /**\r\n         * Encodes the value of each member in then given obj into the given node using\r\n         * <encodeValue>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * obj - Object to be encoded.\r\n         * node - XML node that contains the encoded object.\r\n         */\r\n        encodeObject(enc: any, obj: any, node: any): void;\r\n        /**\r\n         * Converts the given value according to the mappings\r\n         * and id-refs in this codec and uses <writeAttribute>\r\n         * to write the attribute into the given node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * obj - Object whose property is going to be encoded.\r\n         * name - XML node that contains the encoded object.\r\n         * value - Value of the property to be encoded.\r\n         * node - XML node that contains the encoded object.\r\n         */\r\n        encodeValue(enc: any, obj: any, name: any, value: any, node: any): void;\r\n        /**\r\n         * Writes the given value into node using <writePrimitiveAttribute>\r\n         * or <writeComplexAttribute> depending on the type of the value.\r\n         */\r\n        writeAttribute(enc: any, obj: any, name: any, value: any, node: any): void;\r\n        /**\r\n         * Writes the given value as an attribute of the given node.\r\n         */\r\n        writePrimitiveAttribute(enc: any, obj: any, name: any, value: any, node: any): void;\r\n        /**\r\n         * Writes the given value as a child node of the given node.\r\n         */\r\n        writeComplexAttribute(enc: any, obj: any, name: any, value: any, node: any): void;\r\n        /**\r\n         * Converts true to \"1\" and false to \"0\" is <isBooleanAttribute> returns true.\r\n         * All other values are not converted.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * obj - Objec to convert the attribute for.\r\n         * name - Name of the attribute to be converted.\r\n         * value - Value to be converted.\r\n         */\r\n        convertAttributeToXml(enc: any, obj: any, name: any, value: any): any;\r\n        /**\r\n         * Returns true if the given object attribute is a boolean value.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * obj - Objec to convert the attribute for.\r\n         * name - Name of the attribute to be converted.\r\n         * value - Value of the attribute to be converted.\r\n         */\r\n        isBooleanAttribute(enc: any, obj: any, name: any, value: any): boolean;\r\n        /**\r\n         * Converts booleans and numeric values to the respective types. Values are\r\n         * numeric if <isNumericAttribute> returns true.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * attr - XML attribute to be converted.\r\n         * obj - Objec to convert the attribute for.\r\n         */\r\n        convertAttributeFromXml(dec: any, attr: any, obj: any): any;\r\n        /**\r\n         * Returns true if the given XML attribute is a numeric value.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * attr - XML attribute to be converted.\r\n         * obj - Objec to convert the attribute for.\r\n         */\r\n        isNumericAttribute(dec: any, attr: any, obj: any): any;\r\n        /**\r\n         * Hook for subclassers to pre-process the object before\r\n         * encoding. This returns the input object. The return\r\n         * value of this function is used in <encode> to perform\r\n         * the default encoding into the given node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * obj - Object to be encoded.\r\n         * node - XML node to encode the object into.\r\n         */\r\n        beforeEncode(enc: any, obj: any, node: any): any;\r\n        /**\r\n         * Hook for subclassers to post-process the node\r\n         * for the given object after encoding and return the\r\n         * post-processed node. This implementation returns\r\n         * the input node. The return value of this method\r\n         * is returned to the encoder from <encode>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * obj - Object to be encoded.\r\n         * node - XML node that represents the default encoding.\r\n         */\r\n        afterEncode(enc: any, obj: any, node: any): any;\r\n        /**\r\n         * Parses the given node into the object or returns a new object\r\n         * representing the given node.\r\n         *\r\n         * Dec is a reference to the calling decoder. It is used to decode\r\n         * complex objects and resolve references.\r\n         *\r\n         * If a node has an id attribute then the object cache is checked for the\r\n         * object. If the object is not yet in the cache then it is constructed\r\n         * using the constructor of <template> and cached in <mxCodec.objects>.\r\n         *\r\n         * This implementation decodes all attributes and childs of a node\r\n         * according to the following rules:\r\n         *\r\n         * - If the variable name is in <exclude> or if the attribute name is \"id\"\r\n         * or \"as\" then it is ignored.\r\n         * - If the variable name is in <idrefs> then <mxCodec.getObject> is used\r\n         * to replace the reference with an object.\r\n         * - The variable name is mapped using a reverse <mapping>.\r\n         * - If the value has a child node, then the codec is used to create a\r\n         * child object with the variable name taken from the \"as\" attribute.\r\n         * - If the object is an array and the variable name is empty then the\r\n         * value or child object is appended to the array.\r\n         * - If an add child has no value or the object is not an array then\r\n         * the child text content is evaluated using <mxUtils.eval>.\r\n         *\r\n         * For add nodes where the object is not an array and the variable name\r\n         * is defined, the default mechanism is used, allowing to override/add\r\n         * methods as follows:\r\n         *\r\n         * (code)\r\n         * <Object>\r\n         *   <add as=\"hello\"><![CDATA[\r\n         *     function(arg1) {\r\n         *       mxUtils.alert('Hello '+arg1);\r\n         *     }\r\n         *   ]]></add>\r\n         * </Object>\r\n         * (end)\r\n         *\r\n         * If no object exists for an ID in <idrefs> a warning is issued\r\n         * using <mxLog.warn>.\r\n         *\r\n         * Returns the resulting object that represents the given XML node\r\n         * or the object given to the method as the into parameter.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * node - XML node to be decoded.\r\n         * into - Optional objec to encode the node into.\r\n         */\r\n        decode(dec: any, node: any, into: any): any;\r\n        /**\r\n         * Calls <decodeAttributes> and <decodeChildren> for the given node.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * node - XML node to be decoded.\r\n         * obj - Objec to encode the node into.\r\n         */\r\n        decodeNode(dec: any, node: any, obj: any): void;\r\n        /**\r\n         * Decodes all attributes of the given node using <decodeAttribute>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * node - XML node to be decoded.\r\n         * obj - Objec to encode the node into.\r\n         */\r\n        decodeAttributes(dec: any, node: any, obj: any): void;\r\n        /**\r\n         * Returns true if the given attribute should be ignored. This implementation\r\n         * returns true if the attribute name is \"as\" or \"id\".\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * attr - XML attribute to be decoded.\r\n         * obj - Objec to encode the attribute into.\r\n         */\r\n        isIgnoredAttribute(dec: any, attr: any, obj: any): boolean;\r\n        /**\r\n         * Reads the given attribute into the specified object.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * attr - XML attribute to be decoded.\r\n         * obj - Objec to encode the attribute into.\r\n         */\r\n        decodeAttribute(dec: any, attr: any, obj: any): void;\r\n        /**\r\n         * Decodes all children of the given node using <decodeChild>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * node - XML node to be decoded.\r\n         * obj - Objec to encode the node into.\r\n         */\r\n        decodeChildren(dec: any, node: any, obj: any): void;\r\n        /**\r\n         * Reads the specified child into the given object.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * child - XML child element to be decoded.\r\n         * obj - Objec to encode the node into.\r\n         */\r\n        decodeChild(dec: any, child: any, obj: any): void;\r\n        /**\r\n         * Returns the template instance for the given field. This returns the\r\n         * value of the field, null if the value is an array or an empty collection\r\n         * if the value is a collection. The value is then used to populate the\r\n         * field for a new instance. For strongly typed languages it may be\r\n         * required to override this to return the correct collection instance\r\n         * based on the encoded child.\r\n         */\r\n        getFieldTemplate(obj: any, fieldname: any, child: any): any;\r\n        /**\r\n         * Sets the decoded child node as a value of the given object. If the\r\n         * object is a map, then the value is added with the given fieldname as a\r\n         * key. If the fieldname is not empty, then setFieldValue is called or\r\n         * else, if the object is a collection, the value is added to the\r\n         * collection. For strongly typed languages it may be required to\r\n         * override this with the correct code to add an entry to an object.\r\n         */\r\n        addObjectValue(obj: any, fieldname: any, value: any, template: any): void;\r\n        /**\r\n         * Returns true if the given node is an include directive and\r\n         * executes the include by decoding the XML document. Returns\r\n         * false if the given node is not an include directive.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the encoding/decoding process.\r\n         * node - XML node to be checked.\r\n         * into - Optional object to pass-thru to the codec.\r\n         */\r\n        processInclude(dec: any, node: any, into: any): boolean;\r\n        /**\r\n         * Hook for subclassers to pre-process the node for\r\n         * the specified object and return the node to be\r\n         * used for further processing by <decode>.\r\n         * The object is created based on the template in the\r\n         * calling method and is never null. This implementation\r\n         * returns the input node. The return value of this\r\n         * function is used in <decode> to perform\r\n         * the default decoding into the given object.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * dec - <mxCodec> that controls the decoding process.\r\n         * node - XML node to be decoded.\r\n         * obj - Object to encode the node into.\r\n         */\r\n        beforeDecode(dec: any, node: any, obj: any): any;\r\n        /**\r\n         * Hook for subclassers to post-process the object after\r\n         * decoding. This implementation returns the given object\r\n         * without any changes. The return value of this method\r\n         * is returned to the decoder from <decode>.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * enc - <mxCodec> that controls the encoding process.\r\n         * node - XML node to be decoded.\r\n         * obj - Object that represents the default decoding.\r\n         */\r\n        afterDecode(dec: any, node: any, obj: any): any;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n        * A hierarchical layout algorithm.\r\n        *\r\n        * Constructor: mxHierarchicalLayout\r\n        *\r\n        * Constructs a new hierarchical layout algorithm.\r\n        *\r\n        * Arguments:\r\n        *\r\n        * graph - Reference to the enclosing <mxGraph>.\r\n        * orientation - Optional constant that defines the orientation of this\r\n        * layout.\r\n        * deterministic - Optional boolean that specifies if this layout should be\r\n        * deterministic. Default is true.\r\n        */\r\n    export declare class mxHierarchicalLayout extends mxGraphLayout {\r\n        parallelEdgeSpacing: any;\r\n        interHierarchySpacing: any;\r\n        interRankCellSpacing: any;\r\n        intraCellSpacing: any;\r\n        maintainParentLocation: boolean;\r\n        parentBorder: any;\r\n        resizeParent: boolean;\r\n        constructor(graph: any, orientation: any, deterministic?: any);\r\n        /**\r\n         * Returns the internal <mxGraphHierarchyModel> for this layout algorithm.\r\n         */\r\n        getModel(): any;\r\n        /**\r\n         * Executes the layout for the children of the specified parent.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - Parent <mxCell> that contains the children to be laid out.\r\n         * roots - Optional starting roots of the layout.\r\n         */\r\n        execute(parent: any, roots?: any): void;\r\n        /**\r\n         * Returns all visible children in the given parent which do not have\r\n         * incoming edges. If the result is empty then the children with the\r\n         * maximum difference between incoming and outgoing edges are returned.\r\n         * This takes into account edges that are being promoted to the given\r\n         * root due to invisible children or collapsed cells.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - <mxCell> whose children should be checked.\r\n         * vertices - array of vertices to limit search to\r\n         */\r\n        findRoots(parent: any, vertices: any): any[];\r\n        /**\r\n         * Returns the connected edges for the given cell.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> whose edges should be returned.\r\n         */\r\n        getEdges(cell: any): any;\r\n        /**\r\n         * Helper function to return visible terminal for edge allowing for ports\r\n         *\r\n         * Parameters:\r\n         *\r\n         * edge - <mxCell> whose edges should be returned.\r\n         * source - Boolean that specifies whether the source or target terminal is to be returned\r\n         */\r\n        getVisibleTerminal(edge: any, source: any): any;\r\n        /**\r\n         * The API method used to exercise the layout upon the graph description\r\n         * and produce a separate description of the vertex position and edge\r\n         * routing changes made. It runs each stage of the layout that has been\r\n         * created.\r\n         */\r\n        run(parent: any): void;\r\n        /**\r\n         * Creates an array of descendant cells\r\n         */\r\n        filterDescendants(cell: any, result: any): void;\r\n        /**\r\n         * Returns true if the given cell is a \"port\", that is, when connecting to\r\n         * it, its parent is the connecting vertex in terms of graph traversal\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> that represents the port.\r\n         */\r\n        isPort(cell: any): boolean;\r\n        /**\r\n         * Returns the edges between the given source and target. This takes into\r\n         * account collapsed and invisible cells and ports.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * source -\r\n         * target -\r\n         * directed -\r\n         */\r\n        getEdgesBetween(source: any, target: any, directed: any): any[];\r\n        /**\r\n         * Traverses the (directed) graph invoking the given function for each\r\n         * visited vertex and edge. The function is invoked with the current vertex\r\n         * and the incoming edge as a parameter. This implementation makes sure\r\n         * each vertex is only visited once. The function may return false if the\r\n         * traversal should stop at the given vertex.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> that represents the vertex where the traversal starts.\r\n         * directed - boolean indicating if edges should only be traversed\r\n         * from source to target. Default is true.\r\n         * edge - Optional <mxCell> that represents the incoming edge. This is\r\n         * null for the first step of the traversal.\r\n         * allVertices - Array of cell paths for the visited cells.\r\n         */\r\n        traverse(vertex: any, directed: any, edge: any, allVertices: any, currentComp: any, hierarchyVertices: any, filledVertexSet: any): any;\r\n        /**\r\n         * Executes the cycle stage using mxMinimumCycleRemover.\r\n         */\r\n        cycleStage(parent: any): void;\r\n        /**\r\n         * Implements first stage of a Sugiyama layout.\r\n         */\r\n        layeringStage(): void;\r\n        /**\r\n         * Executes the crossing stage using mxMedianHybridCrossingReduction.\r\n         */\r\n        crossingStage(parent: any): void;\r\n        /**\r\n         * Executes the placement stage using mxCoordinateAssignment.\r\n         */\r\n        placementStage(initialX: any, parent: any): any;\r\n    }\r\n    export declare var mxHierarchicalEdgeStyle: {\r\n        ORTHOGONAL: number;\r\n        POLYLINE: number;\r\n        STRAIGHT: number;\r\n        CURVE: number;\r\n    };\r\n\r\n    /**\r\n        * A hierarchical layout algorithm.\r\n        *\r\n        * Constructor: mxSwimlaneLayout\r\n        *\r\n        * Constructs a new hierarchical layout algorithm.\r\n        *\r\n        * Arguments:\r\n        *\r\n        * graph - Reference to the enclosing <mxGraph>.\r\n        * orientation - Optional constant that defines the orientation of this\r\n        * layout.\r\n        * deterministic - Optional boolean that specifies if this layout should be\r\n        * deterministic. Default is true.\r\n        */\r\n    export declare class mxSwimlaneLayout extends mxGraphLayout {\r\n        constructor(graph: any, orientation?: any, deterministic?: any);\r\n        /**\r\n         * Returns the internal <mxSwimlaneModel> for this layout algorithm.\r\n         */\r\n        getModel(): any;\r\n        /**\r\n         * Executes the layout for the children of the specified parent.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - Parent <mxCell> that contains the children to be laid out.\r\n         * swimlanes - Ordered array of swimlanes to be laid out\r\n         */\r\n        execute(parent: any, swimlanes?: any): void;\r\n        /**\r\n         * Updates the bounds of the given array of groups so that it includes\r\n         * all child vertices.\r\n         *\r\n         */\r\n        updateGroupBounds(): void;\r\n        /**\r\n         * Returns all visible children in the given parent which do not have\r\n         * incoming edges. If the result is empty then the children with the\r\n         * maximum difference between incoming and outgoing edges are returned.\r\n         * This takes into account edges that are being promoted to the given\r\n         * root due to invisible children or collapsed cells.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - <mxCell> whose children should be checked.\r\n         * vertices - array of vertices to limit search to\r\n         */\r\n        findRoots(parent: any, vertices: any): any[];\r\n        /**\r\n         * Returns the connected edges for the given cell.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> whose edges should be returned.\r\n         */\r\n        getEdges(cell: any): any;\r\n        /**\r\n         * Helper function to return visible terminal for edge allowing for ports\r\n         *\r\n         * Parameters:\r\n         *\r\n         * edge - <mxCell> whose edges should be returned.\r\n         * source - Boolean that specifies whether the source or target terminal is to be returned\r\n         */\r\n        getVisibleTerminal(edge: any, source: any): any;\r\n        /**\r\n         * The API method used to exercise the layout upon the graph description\r\n         * and produce a separate description of the vertex position and edge\r\n         * routing changes made. It runs each stage of the layout that has been\r\n         * created.\r\n         */\r\n        run(parent: any): void;\r\n        /**\r\n         * Creates an array of descendant cells\r\n         */\r\n        filterDescendants(cell: any, result: any): void;\r\n        /**\r\n         * Returns true if the given cell is a \"port\", that is, when connecting to\r\n         * it, its parent is the connecting vertex in terms of graph traversal\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - <mxCell> that represents the port.\r\n         */\r\n        isPort(cell: any): boolean;\r\n        /**\r\n         * Returns the edges between the given source and target. This takes into\r\n         * account collapsed and invisible cells and ports.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * source -\r\n         * target -\r\n         * directed -\r\n         */\r\n        getEdgesBetween(source: any, target: any, directed: any): any[];\r\n        /**\r\n         * Traverses the (directed) graph invoking the given function for each\r\n         * visited vertex and edge. The function is invoked with the current vertex\r\n         * and the incoming edge as a parameter. This implementation makes sure\r\n         * each vertex is only visited once. The function may return false if the\r\n         * traversal should stop at the given vertex.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * vertex - <mxCell> that represents the vertex where the traversal starts.\r\n         * directed - boolean indicating if edges should only be traversed\r\n         * from source to target. Default is true.\r\n         * edge - Optional <mxCell> that represents the incoming edge. This is\r\n         * null for the first step of the traversal.\r\n         * allVertices - Array of cell paths for the visited cells.\r\n         * swimlaneIndex - the laid out order index of the swimlane vertex is contained in\r\n         */\r\n        traverse(vertex: any, directed: any, edge: any, allVertices: any, currentComp: any, hierarchyVertices: any, filledVertexSet: any, swimlaneIndex: any): any;\r\n        /**\r\n         * Executes the cycle stage using mxMinimumCycleRemover.\r\n         */\r\n        cycleStage(parent: any): void;\r\n        /**\r\n         * Implements first stage of a Sugiyama layout.\r\n         */\r\n        layeringStage(): void;\r\n        /**\r\n         * Executes the crossing stage using mxMedianHybridCrossingReduction.\r\n         */\r\n        crossingStage(parent: any): void;\r\n        /**\r\n         * Executes the placement stage using mxCoordinateAssignment.\r\n         */\r\n        placementStage(initialX: any, parent: any): any;\r\n    }\r\n\r\n    /**\r\n        * The specific layout interface for hierarchical layouts. It adds a\r\n        * <code>run</code> method with a parameter for the hierarchical layout model\r\n        * that is shared between the layout stages.\r\n        *\r\n        * Constructor: mxHierarchicalLayoutStage\r\n        *\r\n        * Constructs a new hierarchical layout stage.\r\n        */\r\n    export declare class mxHierarchicalLayoutStage {\r\n        /**\r\n         * Takes the graph detail and configuration information within the facade\r\n         * and creates the resulting laid out graph within that facade for further\r\n         * use.\r\n         */\r\n        execute(parent: any): void;\r\n    }\r\n\r\n    /**\r\n        * Sets the horizontal locations of node and edge dummy nodes on each layer.\r\n        * Uses median down and up weighings as well heuristic to straighten edges as\r\n        * far as possible.\r\n        *\r\n        * Constructor: mxMedianHybridCrossingReduction\r\n        *\r\n        * Creates a coordinate assignment.\r\n        *\r\n        * Arguments:\r\n        *\r\n        * intraCellSpacing - the minimum buffer between cells on the same rank\r\n        * interRankCellSpacing - the minimum distance between cells on adjacent ranks\r\n        * orientation - the position of the root node(s) relative to the graph\r\n        * initialX - the leftmost coordinate node placement starts at\r\n        */\r\n    export declare class mxMedianHybridCrossingReduction extends mxHierarchicalLayoutStage {\r\n        constructor(layout: any);\r\n        /**\r\n         * Performs a vertex ordering within ranks as described by Gansner et al\r\n         * 1993\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Calculates the total number of edge crossing in the current graph.\r\n         * Returns the current number of edge crossings in the hierarchy graph\r\n         * model in the current candidate layout\r\n         *\r\n         * Parameters:\r\n         *\r\n         * model - the internal model describing the hierarchy\r\n         */\r\n        calculateCrossings(model: any): number;\r\n        /**\r\n         * Calculates the number of edges crossings between the specified rank and\r\n         * the rank below it. Returns the number of edges crossings with the rank\r\n         * beneath\r\n         *\r\n         * Parameters:\r\n         *\r\n         * i -  the topmost rank of the pair ( higher rank value )\r\n         * model - the internal model describing the hierarchy\r\n         */\r\n        calculateRankCrossing(i: any, model: any): number;\r\n        /**\r\n         * Takes each possible adjacent cell pair on each rank and checks if\r\n         * swapping them around reduces the number of crossing\r\n         *\r\n         * Parameters:\r\n         *\r\n         * mainLoopIteration - the iteration number of the main loop\r\n         * model - the internal model describing the hierarchy\r\n         */\r\n        transpose(mainLoopIteration: any, model: any): void;\r\n        /**\r\n         * Sweeps up or down the layout attempting to minimise the median placement\r\n         * of connected cells on adjacent ranks\r\n         *\r\n         * Parameters:\r\n         *\r\n         * iteration - the iteration number of the main loop\r\n         * model - the internal model describing the hierarchy\r\n         */\r\n        weightedMedian(iteration: any, model: any): void;\r\n        /**\r\n         * Attempts to minimise the median placement of connected cells on this rank\r\n         * and one of the adjacent ranks\r\n         *\r\n         * Parameters:\r\n         *\r\n         * rankValue - the layer number of this rank\r\n         * downwardSweep - whether or not this is a downward sweep through the graph\r\n         */\r\n        medianRank(rankValue: any, downwardSweep: any): void;\r\n        /**\r\n         * Calculates the median rank order positioning for the specified cell using\r\n         * the connected cells on the specified rank. Returns the median rank\r\n         * ordering value of the connected cells\r\n         *\r\n         * Parameters:\r\n         *\r\n         * connectedCells - the cells on the specified rank connected to the\r\n         * specified cell\r\n         * rankValue - the rank that the connected cell lie upon\r\n         */\r\n        medianValue(connectedCells: any, rankValue: any): any;\r\n    }\r\n    /**\r\n        * A utility class used to track cells whilst sorting occurs on the median\r\n        * values. Does not violate (x.compareTo(y)==0) == (x.equals(y))\r\n        *\r\n        * Constructor: MedianCellSorter\r\n        *\r\n        * Constructs a new median cell sorter.\r\n        */\r\n    export declare class MedianCellSorter {\r\n        /**\r\n         * Compares two MedianCellSorters.\r\n         */\r\n        compare(a: any, b: any): 1 | 0 | -1;\r\n    }\r\n\r\n    /**\r\n        * An implementation of the first stage of the Sugiyama layout. Straightforward\r\n        * longest path calculation of layer assignment\r\n        *\r\n        * Constructor: mxMinimumCycleRemover\r\n        *\r\n        * Creates a cycle remover for the given internal model.\r\n        */\r\n    export declare class mxMinimumCycleRemover extends mxHierarchicalLayoutStage {\r\n        constructor(layout: any);\r\n        /**\r\n         * Takes the graph detail and configuration information within the facade\r\n         * and creates the resulting laid out graph within that facade for further\r\n         * use.\r\n         */\r\n        execute(parent: any): void;\r\n    }\r\n\r\n    /**\r\n        * Sets the horizontal locations of node and edge dummy nodes on each layer.\r\n        * Uses median down and up weighings as well as heuristics to straighten edges as\r\n        * far as possible.\r\n        *\r\n        * Constructor: mxCoordinateAssignment\r\n        *\r\n        * Creates a coordinate assignment.\r\n        *\r\n        * Arguments:\r\n        *\r\n        * intraCellSpacing - the minimum buffer between cells on the same rank\r\n        * interRankCellSpacing - the minimum distance between cells on adjacent ranks\r\n        * orientation - the position of the root node(s) relative to the graph\r\n        * initialX - the leftmost coordinate node placement starts at\r\n        */\r\n    export declare class mxCoordinateAssignment extends mxHierarchicalLayoutStage {\r\n        constructor(layout: any, intraCellSpacing: any, interRankCellSpacing: any, orientation: any, initialX: any, parallelEdgeSpacing: any);\r\n        /**\r\n         * Utility method to display current positions\r\n         */\r\n        printStatus(): void;\r\n        /**\r\n         * A basic horizontal coordinate assignment algorithm\r\n         */\r\n        execute(parent: any): void;\r\n        /**\r\n         * Performs one median positioning sweep in both directions\r\n         */\r\n        minNode(model: any): void;\r\n        /**\r\n         * Performs one median positioning sweep in one direction\r\n         *\r\n         * Parameters:\r\n         *\r\n         * i - the iteration of the whole process\r\n         * model - an internal model of the hierarchical layout\r\n         */\r\n        medianPos(i: any, model: any): void;\r\n        /**\r\n         * Performs median minimisation over one rank.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * rankValue - the layer number of this rank\r\n         * model - an internal model of the hierarchical layout\r\n         * nextRankValue - the layer number whose connected cels are to be laid out\r\n         * relative to\r\n         */\r\n        rankMedianPosition(rankValue: any, model: any, nextRankValue: any): void;\r\n        /**\r\n         * Calculates the priority the specified cell has based on the type of its\r\n         * cell and the cells it is connected to on the next layer\r\n         *\r\n         * Parameters:\r\n         *\r\n         * currentCell - the cell whose weight is to be calculated\r\n         * collection - the cells the specified cell is connected to\r\n         */\r\n        calculatedWeightedValue(currentCell: any, collection: any): number;\r\n        /**\r\n         * Calculates the median position of the connected cell on the specified\r\n         * rank\r\n         *\r\n         * Parameters:\r\n         *\r\n         * connectedCells - the cells the candidate connects to on this level\r\n         * rankValue - the layer number of this rank\r\n         */\r\n        medianXValue(connectedCells: any, rankValue: any): any;\r\n        /**\r\n         * Sets up the layout in an initial positioning. The ranks are all centered\r\n         * as much as possible along the middle vertex in each rank. The other cells\r\n         * are then placed as close as possible on either side.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * facade - the facade describing the input graph\r\n         * model - an internal model of the hierarchical layout\r\n         */\r\n        initialCoords(facade: any, model: any): void;\r\n        /**\r\n         * Sets up the layout in an initial positioning. All the first cells in each\r\n         * rank are moved to the left and the rest of the rank inserted as close\r\n         * together as their size and buffering permits. This method works on just\r\n         * the specified rank.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * rankValue - the current rank being processed\r\n         * graph - the facade describing the input graph\r\n         * model - an internal model of the hierarchical layout\r\n         */\r\n        rankCoordinates(rankValue: any, graph: any, model: any): void;\r\n        /**\r\n         * Calculates the width rank in the hierarchy. Also set the y value of each\r\n         * rank whilst performing the calculation\r\n         *\r\n         * Parameters:\r\n         *\r\n         * graph - the facade describing the input graph\r\n         * model - an internal model of the hierarchical layout\r\n         */\r\n        calculateWidestRank(graph: any, model: any): void;\r\n        /**\r\n         * Straightens out chains of virtual nodes where possibleacade to those stored after this layout\r\n         * processing step has completed.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * graph - the facade describing the input graph\r\n         * model - an internal model of the hierarchical layout\r\n         */\r\n        minPath(graph: any, model: any): void;\r\n        /**\r\n         * Determines whether or not a node may be moved to the specified x\r\n         * position on the specified rank\r\n         *\r\n         * Parameters:\r\n         *\r\n         * model - the layout model\r\n         * cell - the cell being analysed\r\n         * rank - the layer of the cell\r\n         * position - the x position being sought\r\n         */\r\n        repositionValid(model: any, cell: any, rank: any, position: any): boolean;\r\n        /**\r\n         * Sets the cell locations in the facade to those stored after this layout\r\n         * processing step has completed.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * graph - the input graph\r\n         * model - the layout model\r\n         */\r\n        setCellLocations(graph: any, model: any): void;\r\n        /**\r\n         * Separates the x position of edges as they connect to vertices\r\n         *\r\n         * Parameters:\r\n         *\r\n         * model - the layout model\r\n         */\r\n        localEdgeProcessing(model: any): void;\r\n        /**\r\n         * Fixes the control points\r\n         */\r\n        setEdgePosition(cell: any): void;\r\n        /**\r\n         * Fixes the position of the specified vertex.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * cell - the vertex to position\r\n         */\r\n        setVertexLocation(cell: any): void;\r\n        /**\r\n         * Hook to add additional processing\r\n         *\r\n         * Parameters:\r\n         *\r\n         * edge - the hierarchical model edge\r\n         * realEdge - the real edge in the graph\r\n         */\r\n        processReversedEdge(graph: any, model: any): void;\r\n    }\r\n\r\n    /**\r\n        * An implementation of the first stage of the Sugiyama layout. Straightforward\r\n        * longest path calculation of layer assignment\r\n        *\r\n        * Constructor: mxSwimlaneOrdering\r\n        *\r\n        * Creates a cycle remover for the given internal model.\r\n        */\r\n    export declare class mxSwimlaneOrdering extends mxHierarchicalLayoutStage {\r\n        constructor(layout: any);\r\n        /**\r\n         * Takes the graph detail and configuration information within the facade\r\n         * and creates the resulting laid out graph within that facade for further\r\n         * use.\r\n         */\r\n        execute(parent: any): void;\r\n    }\r\n\r\n    /**\r\n        * An abstraction of an internal hierarchy node or edge\r\n        *\r\n        * Constructor: mxGraphAbstractHierarchyCell\r\n        *\r\n        * Constructs a new hierarchical layout algorithm.\r\n        *\r\n        * Arguments:\r\n        *\r\n        * graph - Reference to the enclosing <mxGraph>.\r\n        * deterministic - Optional boolean that specifies if this layout should be\r\n        * deterministic. Default is true.\r\n        */\r\n    export declare class mxGraphAbstractHierarchyCell {\r\n        constructor();\r\n        /**\r\n         * Returns the cells this cell connects to on the next layer up\r\n         */\r\n        getNextLayerConnectedCells(layer: any): any;\r\n        /**\r\n         * Returns the cells this cell connects to on the next layer down\r\n         */\r\n        getPreviousLayerConnectedCells(layer: any): any;\r\n        /**\r\n         * Returns whether or not this cell is an edge\r\n         */\r\n        isEdge(): boolean;\r\n        /**\r\n         * Returns whether or not this cell is a node\r\n         */\r\n        isVertex(): boolean;\r\n        /**\r\n         * Gets the value of temp for the specified layer\r\n         */\r\n        getGeneralPurposeVariable(layer: any): any;\r\n        /**\r\n         * Set the value of temp for the specified layer\r\n         */\r\n        setGeneralPurposeVariable(layer: any, value: any): any;\r\n        /**\r\n         * Set the value of x for the specified layer\r\n         */\r\n        setX(layer: any, value: any): void;\r\n        /**\r\n         * Gets the value of x on the specified layer\r\n         */\r\n        getX(layer: any): any;\r\n        /**\r\n         * Set the value of y for the specified layer\r\n         */\r\n        setY(layer: any, value: any): void;\r\n    }\r\n\r\n    /**\r\n        * An abstraction of a hierarchical edge for the hierarchy layout\r\n        *\r\n        * Constructor: mxGraphHierarchyNode\r\n        *\r\n        * Constructs an internal node to represent the specified real graph cell\r\n        *\r\n        * Arguments:\r\n        *\r\n        * cell - the real graph cell this node represents\r\n        */\r\n    export declare class mxGraphHierarchyNode extends mxGraphAbstractHierarchyCell {\r\n        constructor(cell: any);\r\n        /**\r\n         * Returns the integer value of the layer that this node resides in\r\n         */\r\n        getRankValue(layer: any): any;\r\n        /**\r\n         * Returns the cells this cell connects to on the next layer up\r\n         */\r\n        getNextLayerConnectedCells(layer: any): any;\r\n        /**\r\n         * Returns the cells this cell connects to on the next layer down\r\n         */\r\n        getPreviousLayerConnectedCells(layer: any): any;\r\n        /**\r\n         * Returns true.\r\n         */\r\n        isVertex(): boolean;\r\n        /**\r\n         * Gets the value of temp for the specified layer\r\n         */\r\n        getGeneralPurposeVariable(layer: any): any;\r\n        /**\r\n         * Set the value of temp for the specified layer\r\n         */\r\n        setGeneralPurposeVariable(layer: any, value: any): void;\r\n        /**\r\n         * Function: isAncestor\r\n         */\r\n        isAncestor(otherNode: any): boolean;\r\n        /**\r\n         * Gets the core vertex associated with this wrapper\r\n         */\r\n        getCoreCell(): any;\r\n    }\r\n\r\n    /**\r\n        * An abstraction of a hierarchical edge for the hierarchy layout\r\n        *\r\n        * Constructor: mxGraphHierarchyEdge\r\n        *\r\n        * Constructs a hierarchy edge\r\n        *\r\n        * Arguments:\r\n        *\r\n        * edges - a list of real graph edges this abstraction represents\r\n        */\r\n    export declare class mxGraphHierarchyEdge extends mxGraphAbstractHierarchyCell {\r\n        constructor(edges: any);\r\n        /**\r\n         * Inverts the direction of this internal edge(s)\r\n         */\r\n        invert(layer: any): void;\r\n        /**\r\n         * Returns the cells this cell connects to on the next layer up\r\n         */\r\n        getNextLayerConnectedCells(layer: any): any;\r\n        /**\r\n         * Returns the cells this cell connects to on the next layer down\r\n         */\r\n        getPreviousLayerConnectedCells(layer: any): any;\r\n        /**\r\n         * Returns true.\r\n         */\r\n        isEdge(): boolean;\r\n        /**\r\n         * Gets the value of temp for the specified layer\r\n         */\r\n        getGeneralPurposeVariable(layer: any): any;\r\n        /**\r\n         * Set the value of temp for the specified layer\r\n         */\r\n        setGeneralPurposeVariable(layer: any, value: any): void;\r\n        /**\r\n         * Gets the first core edge associated with this wrapper\r\n         */\r\n        getCoreCell(): any;\r\n    }\r\n\r\n    /**\r\n        * Internal model of a hierarchical graph. This model stores nodes and edges\r\n        * equivalent to the real graph nodes and edges, but also stores the rank of the\r\n        * cells, the order within the ranks and the new candidate locations of cells.\r\n        * The internal model also reverses edge direction were appropriate , ignores\r\n        * self-loop and groups parallels together under one edge object.\r\n        *\r\n        * Constructor: mxGraphHierarchyModel\r\n        *\r\n        * Creates an internal ordered graph model using the vertices passed in. If\r\n        * there are any, leftward edge need to be inverted in the internal model\r\n        *\r\n        * Arguments:\r\n        *\r\n        * graph - the facade describing the graph to be operated on\r\n        * vertices - the vertices for this hierarchy\r\n        * ordered - whether or not the vertices are already ordered\r\n        * deterministic - whether or not this layout should be deterministic on each\r\n        * tightenToSource - whether or not to tighten vertices towards the sources\r\n        * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\r\n        * usage\r\n        */\r\n    export declare class mxGraphHierarchyModel {\r\n        constructor(layout: any, vertices: any, roots: any, parent: any, tightenToSource: any);\r\n        /**\r\n         * Creates all edges in the internal model\r\n         *\r\n         * Parameters:\r\n         *\r\n         * layout - Reference to the <mxHierarchicalLayout> algorithm.\r\n         * vertices - Array of <mxCells> that represent the vertices whom are to\r\n         * have an internal representation created.\r\n         * internalVertices - The array of <mxGraphHierarchyNodes> to have their\r\n         * information filled in using the real vertices.\r\n         */\r\n        createInternalCells(layout: any, vertices: any, internalVertices: any): void;\r\n        /**\r\n         * Basic determination of minimum layer ranking by working from from sources\r\n         * or sinks and working through each node in the relevant edge direction.\r\n         * Starting at the sinks is basically a longest path layering algorithm.\r\n         */\r\n        initialRank(): void;\r\n        /**\r\n         * Fixes the layer assignments to the values stored in the nodes. Also needs\r\n         * to create dummy nodes for edges that cross layers.\r\n         */\r\n        fixRanks(): void;\r\n        /**\r\n         * A depth first search through the internal heirarchy model.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * visitor - The visitor function pattern to be called for each node.\r\n         * trackAncestors - Whether or not the search is to keep track all nodes\r\n         * directly above this one in the search path.\r\n         */\r\n        visit(visitor: any, dfsRoots: any, trackAncestors: any, seenNodes: any): void;\r\n        /**\r\n         * Performs a depth first search on the internal hierarchy model\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - the parent internal node of the current internal node\r\n         * root - the current internal node\r\n         * connectingEdge - the internal edge connecting the internal node and the parent\r\n         * internal node, if any\r\n         * visitor - the visitor pattern to be called for each node\r\n         * seen - a set of all nodes seen by this dfs a set of all of the\r\n         * ancestor node of the current node\r\n         * layer - the layer on the dfs tree ( not the same as the model ranks )\r\n         */\r\n        dfs(parent: any, root: any, connectingEdge: any, visitor: any, seen: any, layer: any): void;\r\n        /**\r\n         * Performs a depth first search on the internal hierarchy model. This dfs\r\n         * extends the default version by keeping track of cells ancestors, but it\r\n         * should be only used when necessary because of it can be computationally\r\n         * intensive for deep searches.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - the parent internal node of the current internal node\r\n         * root - the current internal node\r\n         * connectingEdge - the internal edge connecting the internal node and the parent\r\n         * internal node, if any\r\n         * visitor - the visitor pattern to be called for each node\r\n         * seen - a set of all nodes seen by this dfs\r\n         * ancestors - the parent hash code\r\n         * childHash - the new hash code for this node\r\n         * layer - the layer on the dfs tree ( not the same as the model ranks )\r\n         */\r\n        extendedDfs(parent: any, root: any, connectingEdge: any, visitor: any, seen: any, ancestors: any, childHash: any, layer: any): void;\r\n    }\r\n\r\n    /**\r\n        * Internal model of a hierarchical graph. This model stores nodes and edges\r\n        * equivalent to the real graph nodes and edges, but also stores the rank of the\r\n        * cells, the order within the ranks and the new candidate locations of cells.\r\n        * The internal model also reverses edge direction were appropriate , ignores\r\n        * self-loop and groups parallels together under one edge object.\r\n        *\r\n        * Constructor: mxSwimlaneModel\r\n        *\r\n        * Creates an internal ordered graph model using the vertices passed in. If\r\n        * there are any, leftward edge need to be inverted in the internal model\r\n        *\r\n        * Arguments:\r\n        *\r\n        * graph - the facade describing the graph to be operated on\r\n        * vertices - the vertices for this hierarchy\r\n        * ordered - whether or not the vertices are already ordered\r\n        * deterministic - whether or not this layout should be deterministic on each\r\n        * tightenToSource - whether or not to tighten vertices towards the sources\r\n        * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\r\n        * usage\r\n        */\r\n    export declare class mxSwimlaneModel {\r\n        constructor(layout: any, vertices: any, roots: any, parent: any, tightenToSource: any);\r\n        /**\r\n         * Creates all edges in the internal model\r\n         *\r\n         * Parameters:\r\n         *\r\n         * layout - Reference to the <mxHierarchicalLayout> algorithm.\r\n         * vertices - Array of <mxCells> that represent the vertices whom are to\r\n         * have an internal representation created.\r\n         * internalVertices - The array of <mxGraphHierarchyNodes> to have their\r\n         * information filled in using the real vertices.\r\n         */\r\n        createInternalCells(layout: any, vertices: any, internalVertices: any): void;\r\n        /**\r\n         * Basic determination of minimum layer ranking by working from from sources\r\n         * or sinks and working through each node in the relevant edge direction.\r\n         * Starting at the sinks is basically a longest path layering algorithm.\r\n         */\r\n        initialRank(): void;\r\n        /**\r\n         * Performs a depth first search on the internal hierarchy model. This dfs\r\n         * extends the default version by keeping track of chains within groups.\r\n         * Any cycles should be removed prior to running, but previously seen cells\r\n         * are ignored.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - the parent internal node of the current internal node\r\n         * root - the current internal node\r\n         * connectingEdge - the internal edge connecting the internal node and the parent\r\n         * internal node, if any\r\n         * seen - a set of all nodes seen by this dfs\r\n         * chainCount - the number of edges in the chain of vertices going through\r\n         * the current swimlane\r\n         */\r\n        maxChainDfs(parent: any, root: any, connectingEdge: any, seen: any, chainCount: any): void;\r\n        /**\r\n         * Fixes the layer assignments to the values stored in the nodes. Also needs\r\n         * to create dummy nodes for edges that cross layers.\r\n         */\r\n        fixRanks(): void;\r\n        /**\r\n         * A depth first search through the internal heirarchy model.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * visitor - The visitor function pattern to be called for each node.\r\n         * trackAncestors - Whether or not the search is to keep track all nodes\r\n         * directly above this one in the search path.\r\n         */\r\n        visit(visitor: any, dfsRoots: any, trackAncestors: any, seenNodes: any): void;\r\n        /**\r\n         * Performs a depth first search on the internal hierarchy model\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - the parent internal node of the current internal node\r\n         * root - the current internal node\r\n         * connectingEdge - the internal edge connecting the internal node and the parent\r\n         * internal node, if any\r\n         * visitor - the visitor pattern to be called for each node\r\n         * seen - a set of all nodes seen by this dfs a set of all of the\r\n         * ancestor node of the current node\r\n         * layer - the layer on the dfs tree ( not the same as the model ranks )\r\n         */\r\n        dfs(parent: any, root: any, connectingEdge: any, visitor: any, seen: any, layer: any): void;\r\n        /**\r\n         * Performs a depth first search on the internal hierarchy model. This dfs\r\n         * extends the default version by keeping track of cells ancestors, but it\r\n         * should be only used when necessary because of it can be computationally\r\n         * intensive for deep searches.\r\n         *\r\n         * Parameters:\r\n         *\r\n         * parent - the parent internal node of the current internal node\r\n         * root - the current internal node\r\n         * connectingEdge - the internal edge connecting the internal node and the parent\r\n         * internal node, if any\r\n         * visitor - the visitor pattern to be called for each node\r\n         * seen - a set of all nodes seen by this dfs\r\n         * ancestors - the parent hash code\r\n         * childHash - the new hash code for this node\r\n         * layer - the layer on the dfs tree ( not the same as the model ranks )\r\n         */\r\n        extendedDfs(parent: any, root: any, connectingEdge: any, visitor: any, seen: any, ancestors: any, childHash: any, layer: any): void;\r\n    }\r\n}"]}