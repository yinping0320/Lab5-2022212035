"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graph = void 0;
var tslib_1 = require("tslib");
var bpmn_model_1 = require("@edp-pmf/bpmn-model");
var mxgraph_ts_1 = require("@edp-pmf/mxgraph-ts");
var SequenceFlowEdge_1 = require("../model/bpmn-cell/SequenceFlowEdge");
var Cell_1 = require("../model/Cell");
var EdgeCell_1 = require("../model/EdgeCell");
var NodeCell_1 = require("../model/NodeCell");
var BpmnCellHelper_1 = require("../util/BpmnCellHelper");
var Constant_1 = require("../util/Constant");
var PmfEvents_1 = require("../util/PmfEvents");
var GraphView_1 = require("./GraphView");
var MxGraphHelper_1 = require("../util/MxGraphHelper");
var ProcessCell_1 = require("../model/ProcessCell");
/**
 * 画布
 */
var Graph = /** @class */ (function (_super) {
    tslib_1.__extends(Graph, _super);
    function Graph(editorUi, container, model, renderHint, stylesheet, themes) {
        var _this = _super.call(this, container, model, renderHint, stylesheet) || this;
        /**
         * BPMN模型是否加载完成
         * todo：借用此属性来作为坐标修改事件是否真正触发的依据感觉仍然存在问题，待进一步优化
         */
        _this.bpmnModelLoaded = false;
        /**
         * 可滚动区域大小
         */
        _this.scrollTileSize = new mxgraph_ts_1.mxRectangle(0, 0, 400, 400);
        _this.editorUi = editorUi;
        _this.themes = themes;
        if (stylesheet == null) {
            _this.loadStylesheet();
        }
        // 可连线
        _this.setConnectable(true);
        // 不可重复连线
        _this.setMultigraph(false);
        // 不可悬空连线
        _this.setAllowDanglingEdges(false);
        // 不允许有环路，不生效？
        _this.setAllowLoops(false);
        // 不可双击编辑标签
        _this.setCellsEditable(false);
        // 不允许活动节点改变大小
        _this.setCellsResizable(false);
        // 连线标签可移动
        _this.setEdgeLabelsMovable(true);
        // 禁止Ctrl + 拖动进行复制操作
        _this.setCellsCloneable(false);
        // 启用引导线
        _this.graphHandler.guidesEnabled = true;
        // 启用网格状态变化时
        _this.addListener(PmfEvents_1.PmfEvents.GridEnabledChanged, function () {
            _this.view.validateBackground();
        });
        // 启用网格
        _this.setGridEnabled(true);
        // 禁用自动滚动
        _this.autoScroll = false;
        // 启用自动扩展
        _this.autoExtend = true;
        // 禁用页面视图
        _this.pageVisible = false;
        // 禁用节点分割连线
        _this.setSplitEnabled(false);
        // 设置默认样式
        _this.setDefaultStyles();
        // 创建多连接点
        _this.setMultiConstraints();
        // 设置默认BPMN模型与流程元素实例
        _this.setDefaultBpmnModel();
        return _this;
    }
    /**
     * 设置默认样式
     */
    Graph.prototype.setDefaultStyles = function () {
        var styleSheet = this.getStylesheet();
        // 节点默认样式
        var vertexStyle = styleSheet.getDefaultVertexStyle();
        vertexStyle[mxgraph_ts_1.mxConstants.STYLE_SHAPE] = mxgraph_ts_1.mxConstants.SHAPE_IMAGE;
        vertexStyle[mxgraph_ts_1.mxConstants.STYLE_VERTICAL_LABEL_POSITION] = mxgraph_ts_1.mxConstants.ALIGN_BOTTOM;
        vertexStyle[mxgraph_ts_1.mxConstants.STYLE_FONTSIZE] = 12;
        // 连线样式默认为正交
        var edgeStyle = styleSheet.getDefaultEdgeStyle();
        edgeStyle[mxgraph_ts_1.mxConstants.STYLE_EDGE] = mxgraph_ts_1.mxConstants.EDGESTYLE_ORTHOGONAL;
        edgeStyle[mxgraph_ts_1.mxConstants.STYLE_STROKECOLOR] = '#6482B9';
        edgeStyle[mxgraph_ts_1.mxConstants.STYLE_ENDARROW] = mxgraph_ts_1.mxConstants.ARROW_BLOCK;
        edgeStyle[mxgraph_ts_1.mxConstants.STYLE_ROUNDED] = 1;
        edgeStyle[mxgraph_ts_1.mxConstants.STYLE_ENDFILL] = 1;
        edgeStyle[mxgraph_ts_1.mxConstants.STYLE_ENDSIZE] = 6;
    };
    /**
     * 加载样式
     */
    Graph.prototype.loadStylesheet = function () {
        var node = this.themes || mxgraph_ts_1.mxUtils.load(Constant_1.Constant.STYLE_PATH + '/default.xml').getDocumentElement();
        if (node != null) {
            var dec = new mxgraph_ts_1.mxCodec(node.ownerDocument);
            dec.decode(node, this.getStylesheet());
        }
    };
    /**
     * 选中cell变化后事件处理
     * @param cells
     */
    Graph.prototype.bpmnCellsSelectionChanged = function (cells, sender, eventObject) {
        //该段代码仅为了解决父页面属性框值修改后，点击画布内活动节点时不会触发其失去焦点事件的问题
        focus();
        this.editorUi.fireEvent(new mxgraph_ts_1.mxEventObject(PmfEvents_1.PmfEvents.ShowProperty, "cells", cells));
    };
    /**
     * 删除cell后同时从bpmnmodel中删除
     * @param cells
     */
    Graph.prototype.bpmnCellsRemoved = function (cells, sender, eventObject) {
        // 先删除边
        cells && cells.forEach(function (cell) {
            if (cell instanceof EdgeCell_1.EdgeCell) {
                cell.unbindBpmnModel();
            }
        });
        // 再删除节点
        cells && cells.forEach(function (cell) {
            if (cell instanceof NodeCell_1.NodeCell) {
                cell.unbindBpmnModel();
            }
        });
    };
    /**
     * 连接两个节点后为edge绑定bpmn相关属性
     * @param edge
     */
    Graph.prototype.bpmnCellsConnected = function (edge, sender, eventObject) {
        var _this = this;
        this.bindBpmnElements([edge]);
        // 此时无法拿到mxCellState，故延时操作
        setTimeout(function () {
            _this.updateEdgeState(edge);
        }, 0);
    };
    /**
     * 连线端点改变后同步修改Bpmn相关属性
     * @param source true表示来源端点改变，false表示目标端点改变
     */
    Graph.prototype.bpmnEdgeTerminalChanged = function (edge, terminal, source, previous, sender, eventObject, change) {
        // 更新相关连线路径点与标签
        this.updateEdgeState(edge);
        // 添加连线时同样会执行此方法，需根据previous与terminal判断是否为新增连线
        if (terminal == previous) {
            return;
        }
        // 端点改变时执行下列代码
        if (edge instanceof EdgeCell_1.EdgeCell && edge.flowElement != null) {
            var seqFlow = edge.flowElement;
            var diagElt = edge.diagramElement;
            var srcFlowNode = edge.source && edge.source.flowElement;
            var srcDiagElt = edge.source && edge.source.diagramElement;
            var tarFlowNode = edge.target && edge.target.flowElement;
            var tarDiagElt = edge.target && edge.target.diagramElement;
            var oldSeqFlowId_1 = seqFlow.Id;
            // 先删除原flowElt和diagElt
            this.bpmnModel.DefaultProcess.RemoveFlowElement(seqFlow.Id);
            this.bpmnModel.DefaultDiagram.BpmnPlane.RemoveDiagramElement(diagElt.Id);
            // 赋值新来源端点Id
            seqFlow.SourceRef = srcFlowNode && srcFlowNode.Id;
            // 赋值新目标端点Id
            seqFlow.TargetRef = tarFlowNode && tarFlowNode.Id;
            // 重新赋值Id
            seqFlow.Id = seqFlow.SourceRef + '_' + seqFlow.TargetRef;
            diagElt.BpmnElementId = seqFlow.Id;
            diagElt.SourceShapeElementId = srcDiagElt.Id;
            diagElt.TargetShapeElementId = tarDiagElt.Id;
            // 重新添加
            this.bpmnModel.DefaultProcess.AddFlowElement(seqFlow);
            this.bpmnModel.DefaultDiagram.BpmnPlane.AddDiagramElement(diagElt);
            // 变得是来源端点
            if (source) {
                var oldSrcFlowNode = previous && previous.flowElement;
                // 挪动的线为默认分支时，取消默认分支限制
                if (oldSrcFlowNode.Default && oldSrcFlowNode.Default == oldSeqFlowId_1) {
                    oldSrcFlowNode.Default = null;
                }
                // 原来源端点删除去向
                if (oldSrcFlowNode != null && oldSrcFlowNode != srcFlowNode) {
                    oldSrcFlowNode.Outgoings = oldSrcFlowNode.Outgoings ? oldSrcFlowNode.Outgoings.filter(function (it) {
                        return it != oldSeqFlowId_1;
                    }) : [];
                }
                // 新来源端点增加去向
                if (srcFlowNode != null && !edge.existOutging(this.bpmnModel, srcFlowNode, tarFlowNode)) {
                    srcFlowNode.Outgoings.push(seqFlow.Id);
                }
                // 目标节点删除来源
                if (tarFlowNode != null) {
                    tarFlowNode.Incomings = tarFlowNode.Incomings ? tarFlowNode.Incomings.filter(function (it) {
                        return it != oldSeqFlowId_1;
                    }) : [];
                }
                // 目标端点增加来源
                if (tarFlowNode != null && !edge.existIncoming(this.bpmnModel, srcFlowNode, tarFlowNode)) {
                    tarFlowNode.Incomings.push(seqFlow.Id);
                }
            }
            else {
                var oldTarFlowNode = previous && previous.flowElement;
                // 原目标端点删除来源
                if (oldTarFlowNode != null && oldTarFlowNode != tarFlowNode) {
                    oldTarFlowNode.Incomings = oldTarFlowNode.Incomings ? oldTarFlowNode.Incomings.filter(function (it) {
                        return it != oldSeqFlowId_1;
                    }) : [];
                }
                // 新目标端点增加来源
                if (tarFlowNode != null && !edge.existIncoming(this.bpmnModel, tarFlowNode, srcFlowNode)) {
                    tarFlowNode.Incomings.push(seqFlow.Id);
                }
                // 来源节点删除去向
                if (srcFlowNode != null) {
                    srcFlowNode.Outgoings = srcFlowNode.Outgoings ? srcFlowNode.Outgoings.filter(function (it) {
                        return it != oldSeqFlowId_1;
                    }) : [];
                }
                // 来源端点增加去向
                if (srcFlowNode != null && !edge.existOutging(this.bpmnModel, srcFlowNode, tarFlowNode)) {
                    srcFlowNode.Outgoings.push(seqFlow.Id);
                }
            }
        }
    };
    /**
     * cell几何信息改变后同步修改Bpmn相关属性
     * @param cell
     */
    Graph.prototype.bpmnCellGeometryChanged = function (cell, sender, eventObject, change) {
        var _this = this;
        if (this.bpmnModelLoaded == false || cell.flowElement == null) {
            return;
        }
        if (cell instanceof NodeCell_1.NodeCell) {
            var shape = cell.diagramElement;
            shape.Bounds.X = cell.geometry.x;
            shape.Bounds.Y = cell.geometry.y;
            shape.Bounds.Height = cell.geometry.height;
            shape.Bounds.Width = cell.geometry.width;
            // 更新相关连线路径点与标签
            cell.edges && cell.edges.forEach(function (edge) {
                _this.updateEdgeState(edge);
            });
        }
        else if (cell instanceof EdgeCell_1.EdgeCell) {
            // 更新相关连线路径点与标签
            this.updateEdgeState(cell);
        }
    };
    /**
     * cell名称修改后同步修改Bpmn相关属性
     * @param cell
     * @param sender
     * @param evt
     */
    Graph.prototype.bpmnCellNameChanged = function (cell, sender, evt) {
        this.getModel().beginUpdate();
        try {
            this.labelChanged(cell, cell.flowElement && cell.flowElement.Name, undefined);
        }
        finally {
            this.getModel().endUpdate();
        }
        if (cell instanceof EdgeCell_1.EdgeCell) {
            this.updateEdgeState(cell);
        }
    };
    /**
     * 设置默认BPMN模型与流程元素实例
     */
    Graph.prototype.setDefaultBpmnModel = function () {
        this.bpmnModel = this.createBpmnModel();
        this.processCell = this.createProcessCell(this.bpmnModel);
        this.bpmnModelLoaded = true;
    };
    /**
     * 创建BpmnModel
     */
    Graph.prototype.createBpmnModel = function () {
        var bpmnModel = new bpmn_model_1.BpmnModel();
        bpmnModel.TargetNamespace = "Default_Namespace";
        bpmnModel.DefaultProcess = new bpmn_model_1.Process(bpmnModel);
        bpmnModel.DefaultDiagram = new bpmn_model_1.BPMNDiagram(bpmnModel);
        bpmnModel.DefaultDiagram.BpmnPlane.BpmnElementId = bpmnModel.DefaultProcess.Id;
        return bpmnModel;
    };
    /**
     * 加载BpmnModel并画图
     */
    Graph.prototype.loadBpmnModel = function (json) {
        this.bpmnModelLoaded = false;
        var bpmnModel = this.createBpmnModel();
        bpmnModel.LoadFromJson(json);
        this.drawBpmnGraph(bpmnModel);
        this.bpmnModel = bpmnModel;
        this.processCell = this.createProcessCell(this.bpmnModel);
        this.bpmnModelLoaded = true;
    };
    /**
     * 创建流程元素实例
     * @param bpmnModel
     * @returns
     */
    Graph.prototype.createProcessCell = function (bpmnModel) {
        var processCell = new ProcessCell_1.ProcessCell();
        processCell.process = bpmnModel.DefaultProcess;
        processCell.plane = bpmnModel.DefaultDiagram.BpmnPlane;
        processCell.editorUi = this.editorUi;
        return processCell;
    };
    /**
     * 根据BpmnModel画图
     */
    Graph.prototype.drawBpmnGraph = function (bpmnModel) {
        var _a = this.buildFlowDiagDict(bpmnModel), nodeDict = _a.nodeDict, edgeDict = _a.edgeDict;
        var flowDict = this.buildFlowDict(bpmnModel);
        this.drawNodeCells(flowDict, nodeDict);
        this.drawEdgeCells(flowDict, edgeDict);
    };
    /**
     * 画节点
     */
    Graph.prototype.drawNodeCells = function (flowDict, nodeDict) {
        var _this = this;
        Object.keys(nodeDict).forEach(function (bpmnModelElementId) {
            var flowElt = flowDict[bpmnModelElementId];
            var diagElt = nodeDict[bpmnModelElementId];
            if (flowElt == null) {
                return;
            }
            _this.drawNodeCell(flowElt, diagElt);
        });
    };
    /**
     * 画单个节点
     */
    Graph.prototype.drawNodeCell = function (flowElt, diagElt) {
        var cell = BpmnCellHelper_1.BpmnCellHelper.generate(flowElt.ClrTypeID, undefined, new mxgraph_ts_1.mxGeometry(diagElt.Bounds.X, diagElt.Bounds.Y, diagElt.Bounds.Width, diagElt.Bounds.Height));
        cell.flowElement = flowElt;
        cell.diagramElement = diagElt;
        cell.editorUi = this.editorUi;
        this.moveCells([cell], undefined, undefined, undefined, this.getDefaultParent());
    };
    /**
     * 画连线
     */
    Graph.prototype.drawEdgeCells = function (flowDict, edgeDict) {
        var _this = this;
        Object.keys(edgeDict).forEach(function (bpmnModelElementId) {
            var flowElt = flowDict[bpmnModelElementId];
            var diagElt = edgeDict[bpmnModelElementId];
            if (flowElt == null) {
                return;
            }
            _this.drawEdgeCell(flowElt, diagElt);
        });
    };
    /**
     * 画单个连线
     */
    Graph.prototype.drawEdgeCell = function (flowElt, diagElt) {
        // 获取已画好的所有节点
        var nodeCells = (this.getChildCells(this.getDefaultParent(), true) || []);
        var source = nodeCells.find(function (it) {
            return it.flowElement && it.flowElement.Id === flowElt.SourceRef;
        });
        var target = nodeCells.find(function (it) {
            return it.flowElement && it.flowElement.Id === flowElt.TargetRef;
        });
        var cell = BpmnCellHelper_1.BpmnCellHelper.generate(flowElt.ClrTypeID, undefined, new mxgraph_ts_1.mxGeometry());
        cell.geometry.relative = true;
        cell.flowElement = flowElt;
        cell.diagramElement = diagElt;
        cell.editorUi = this.editorUi;
        cell.source = source;
        cell.target = target;
        cell.geometry.points = cell.geometry.points || [];
        // 判断是否为旧版本连线
        if (this.isOldBpmnEdge(diagElt)) {
            for (var i = 2; i < diagElt.Points.length; i++) {
                var pt = diagElt.Points[i];
                cell.geometry.points.push(new mxgraph_ts_1.mxPoint(pt.X, pt.Y));
            }
            // 此行代码执行后可获取mxCellState
            this.moveCells([cell], undefined, undefined, undefined, this.getDefaultParent());
            //按坐标插入label
            var state = this.view.getState(cell);
            if (diagElt.BpmnLabel && state) {
                if (diagElt.BpmnLabel.Bounds.X === 0 && diagElt.BpmnLabel.Bounds.Y === 0) {
                    return;
                }
                var x = diagElt.BpmnLabel.Bounds.X + (state.x - state.paintBounds.x);
                var y = diagElt.BpmnLabel.Bounds.Y + (state.y - state.paintBounds.y);
                var edgeHandler = this.createEdgeHandler(state, undefined);
                edgeHandler.moveLabel(state, x, y);
                edgeHandler.destroy();
            }
        }
        else {
            // 根据连线的起点和终点坐标可以判断具体的连接点信息
            // 根据起点判断来源端点的连接点位置
            var exitX = (diagElt.Points[0].X - source.geometry.x) / source.geometry.width;
            var exitY = (diagElt.Points[0].Y - source.geometry.y) / source.geometry.height;
            // 根据终点判断目标端点的连接点位置
            var entryX = (diagElt.Points[diagElt.Points.length - 1].X - target.geometry.x) / source.geometry.width;
            var entryY = (diagElt.Points[diagElt.Points.length - 1].Y - target.geometry.y) / source.geometry.height;
            // 设置连线的起点和终点的指定连接点
            cell.style = mxgraph_ts_1.mxConstants.STYLE_EXIT_X + "=" + exitX + ";" + mxgraph_ts_1.mxConstants.STYLE_EXIT_Y + "=" + exitY + ";" + mxgraph_ts_1.mxConstants.STYLE_ENTRY_X + "=" + entryX + ";" + mxgraph_ts_1.mxConstants.STYLE_ENTRY_Y + "=" + entryY + ";";
            // todo：取包含起终点的路径点数组和排除起终点的路径点数组画图结果相同，出现问题时待进一步分析
            for (var i = 1; i < diagElt.Points.length - 1; i++) {
                var pt = diagElt.Points[i];
                cell.geometry.points.push(new mxgraph_ts_1.mxPoint(pt.X, pt.Y));
            }
            // 此行代码执行后可获取mxCellState
            this.moveCells([cell], undefined, undefined, undefined, this.getDefaultParent());
            //按坐标插入label
            var state = this.view.getState(cell);
            var scale = this.view.getScale();
            var translate = this.view.getTranslate();
            if (diagElt.BpmnLabel && state) {
                if (diagElt.BpmnLabel.Bounds.X === 0 && diagElt.BpmnLabel.Bounds.Y === 0) {
                    return;
                }
                var x = diagElt.BpmnLabel.Bounds.X * scale + translate.x;
                var y = diagElt.BpmnLabel.Bounds.Y * scale + translate.y;
                var edgeHandler = this.createEdgeHandler(state, undefined);
                edgeHandler.moveLabel(state, x, y);
                edgeHandler.destroy();
            }
        }
        // 画完后清除拐点，否则这几个路径点会一直存在，连线位置更新时看起来非常别扭
        cell.geometry.points = [];
    };
    /**
     * 构建FlowElement字典，{ [flowEltId: string]: FlowElement }
     */
    Graph.prototype.buildFlowDict = function (bpmnModel) {
        var flowDict = bpmnModel.DefaultProcess.GetFlowElements();
        return flowDict;
    };
    /**
     * 构建DiagramElement字典，{ [flowEltId: string]: DiagramElement }
     */
    Graph.prototype.buildFlowDiagDict = function (bpmnModel) {
        var nodeDict = {};
        var edgeDict = {};
        var diagramElts = bpmnModel.DefaultDiagram.BpmnPlane.GetDiagramElements();
        diagramElts && diagramElts.forEach(function (elt) {
            if (elt instanceof bpmn_model_1.Node) {
                nodeDict[elt.BpmnElementId] = elt;
            }
            else if (elt instanceof bpmn_model_1.Edge) {
                edgeDict[elt.BpmnElementId] = elt;
            }
        });
        return {
            nodeDict: nodeDict,
            edgeDict: edgeDict,
        };
    };
    /**
     * cell绑定bpmn相关信息
     */
    Graph.prototype.bindBpmnElements = function (cells, formFormats) {
        var _this = this;
        cells && cells.forEach(function (cell) {
            if (cell instanceof Cell_1.Cell) {
                cell.editorUi = _this.editorUi;
                cell.bindBpmnModel();
            }
        });
    };
    /**
     * 根据flowElementId获取cell
     */
    Graph.prototype.getCellByFlowElementId = function (flowEltId, parent) {
        if (flowEltId == null) {
            return null;
        }
        parent = parent ? parent : this.getDefaultParent();
        var cells = this.getChildCells(parent);
        var cell = cells.find(function (it) {
            if (it instanceof Cell_1.Cell) {
                return it.flowElement && it.flowElement.Id == flowEltId;
            }
            else {
                return false;
            }
        });
        return cell;
    };
    /**
     * 更新连线状态
     * @param cell
     */
    Graph.prototype.updateEdgeState = function (cell) {
        this.updateEdgeWaypoints(cell);
        this.updateEdgeLabel(cell);
    };
    /**
     * 更新路径点
     * @param cell
     */
    Graph.prototype.updateEdgeWaypoints = function (cell) {
        if (cell == null) {
            return;
        }
        var state = this.view.getState(cell);
        var scale = this.view.getScale();
        var translate = this.view.getTranslate();
        // 路径点列表
        var waypoints = [];
        state && state.absolutePoints && state.absolutePoints.forEach(function (pt, idx) {
            waypoints.push(MxGraphHelper_1.MxGraphHelper.getRelativePositon(pt, scale, translate));
        });
        cell.setPoints(waypoints);
    };
    /**
     * 更新连线标签
     */
    Graph.prototype.updateEdgeLabel = function (cell) {
        var state = this.view.getState(cell);
        var scale = this.view.getScale();
        var translate = this.view.getTranslate();
        // 对于边来说，在默认的非相对位置模式下，absoluteOffset是边的标签的绝对坐标
        var pt = MxGraphHelper_1.MxGraphHelper.getRelativePositon(state.absoluteOffset, scale, translate);
        var width = state.text && state.text.boundingBox ? state.text.boundingBox.width / scale : 0;
        var height = state.text && state.text.boundingBox ? state.text.boundingBox.height / scale : 0;
        var rect = state.text && state.text.boundingBox ? new mxgraph_ts_1.mxRectangle(pt.x, pt.y, width, height) : null;
        cell.setBpmnLabel(rect);
    };
    /**
     * 创建无限大画布
     */
    Graph.prototype.createInfiniteCanvas = function () {
        var _this = this;
        this.getPagePadding = function () {
            return new mxgraph_ts_1.mxPoint(Math.max(0, Math.round(_this.container.offsetWidth - 34)), Math.max(0, Math.round(_this.container.offsetHeight - 34)));
        };
        this.getScrollTileSize = function () {
            if (_this.scrollTileSize == null) {
                _this.scrollTileSize = new mxgraph_ts_1.mxRectangle(0, 0, 400, 600);
            }
            return _this.scrollTileSize;
        };
        this.getPageSize = function () {
            return (_this.pageVisible) ? new mxgraph_ts_1.mxRectangle(0, 0, _this.pageFormat.width * _this.pageScale, _this.pageFormat.height * _this.pageScale) : _this.getScrollTileSize();
        };
        this.getPageLayout = function () {
            var size = (_this.pageVisible) ? _this.getPageSize() : _this.getScrollTileSize();
            var bounds = _this.getGraphBounds();
            if (bounds.width == 0 || bounds.height == 0) {
                return new mxgraph_ts_1.mxRectangle(0, 0, 1, 1);
            }
            else {
                // Computes untransformed graph bounds
                var x = Math.ceil(bounds.x / _this.view.scale - _this.view.translate.x);
                var y = Math.ceil(bounds.y / _this.view.scale - _this.view.translate.y);
                var w = Math.floor(bounds.width / _this.view.scale);
                var h = Math.floor(bounds.height / _this.view.scale);
                var x0 = Math.floor(x / size.width);
                var y0 = Math.floor(y / size.height);
                var w0 = Math.ceil((x + w) / size.width) - x0;
                var h0 = Math.ceil((y + h) / size.height) - y0;
                return new mxgraph_ts_1.mxRectangle(x0, y0, w0, h0);
            }
        };
        this.getPreferredPageSize = function (bounds, width, height) {
            var pages = _this.getPageLayout();
            var size = _this.getPageSize();
            return new mxgraph_ts_1.mxRectangle(0, 0, pages.width * size.width, pages.height * size.height);
        };
        // 重写画布大小变化后方法
        var graphSizeDidChange = this.sizeDidChange;
        this.sizeDidChange = function () {
            if (_this.container != null && mxgraph_ts_1.mxUtils.hasScrollbars(_this.container)) {
                var pages = _this.getPageLayout();
                var pad = _this.getPagePadding();
                var size = _this.getPageSize();
                // Updates the minimum graph size
                var minw = Math.ceil(2 * pad.x / _this.view.scale + pages.width * size.width);
                var minh = Math.ceil(2 * pad.y / _this.view.scale + pages.height * size.height);
                var min = _this.minimumGraphSize;
                // LATER: Fix flicker of scrollbar size in IE quirks mode
                // after delayed call in window.resize event handler
                if (min == null || min.width != minw || min.height != minh) {
                    _this.minimumGraphSize = new mxgraph_ts_1.mxRectangle(0, 0, minw, minh);
                }
                // Updates auto-translate to include padding and graph size
                var dx = pad.x / _this.view.scale - pages.x * size.width;
                var dy = pad.y / _this.view.scale - pages.y * size.height;
                if (!_this.autoTranslate && (_this.view.translate.x != dx || _this.view.translate.y != dy)) {
                    _this.autoTranslate = true;
                    _this.view.x0 = pages.x;
                    _this.view.y0 = pages.y;
                    var tx = _this.view.translate.x;
                    var ty = _this.view.translate.y;
                    _this.view.setTranslate(dx, dy);
                    _this.container.scrollLeft += (dx - tx) * _this.view.scale;
                    _this.container.scrollTop += (dy - ty) * _this.view.scale;
                    _this.autoTranslate = false;
                    return;
                }
                graphSizeDidChange.apply(_this, []);
            }
        };
        // 重写view获取背景页大小
        this.view.getBackgroundPageBounds = function () {
            var layout = _this.getPageLayout();
            var page = _this.getPageSize();
            return new mxgraph_ts_1.mxRectangle(_this.view.scale * (_this.view.translate.x + layout.x * page.width), _this.view.scale * (_this.view.translate.y + layout.y * page.height), _this.view.scale * layout.width * page.width, _this.view.scale * layout.height * page.height);
        };
        // 重写view validate方法
        var graphViewValidate = this.view.validate;
        this.view.validate = function (cell) {
            if (_this.container != null && mxgraph_ts_1.mxUtils.hasScrollbars(_this.container)) {
                var pad = _this.getPagePadding();
                var size = _this.getPageSize();
                var tx = _this.view.translate.x;
                var ty = _this.view.translate.y;
                _this.view.translate.x = pad.x / _this.view.scale - (_this.view.x0 || 0) * size.width;
                _this.view.translate.y = pad.y / _this.view.scale - (_this.view.y0 || 0) * size.height;
            }
            graphViewValidate.apply(_this.view, [cell]);
        };
        // 方法重写完成后，需重新调用一次sizeDidChange()才可生效
        // this.sizeDidChange();
    };
    /**
     * 创建多连接点，重写getAllConnectionConstraints方法
     */
    Graph.prototype.setMultiConstraints = function () {
        var _this = this;
        // 修改连接点样式
        mxgraph_ts_1.mxConstraintHandler.prototype.pointImage = new mxgraph_ts_1.mxImage(Constant_1.Constant.IMAGE_PATH + "/round-drop.png", 8, 8);
        // mxShape新增getConstraints方法
        mxgraph_ts_1.mxShape.prototype.getConstraints = function (style, w, h) {
            return null;
        };
        // 为mxImageShape添加默认连接点
        mxgraph_ts_1.mxImageShape.prototype.constraints = [
            new mxgraph_ts_1.mxConnectionConstraint(new mxgraph_ts_1.mxPoint(0.5, 0), true),
            new mxgraph_ts_1.mxConnectionConstraint(new mxgraph_ts_1.mxPoint(0, 0.5), true),
            new mxgraph_ts_1.mxConnectionConstraint(new mxgraph_ts_1.mxPoint(1, 0.5), true),
            new mxgraph_ts_1.mxConnectionConstraint(new mxgraph_ts_1.mxPoint(0.5, 1), true),
        ];
        this.setPortsEnabled(false);
        // Disables floating connections (only connections via ports allowed)
        this.connectionHandler.isConnectableCell = function (cell) {
            return false;
        };
        mxgraph_ts_1.mxEdgeHandler.prototype.isConnectableCell = function (cell) {
            return _this.connectionHandler.isConnectableCell(cell);
        };
        // Disables existing port functionality
        this.view.getTerminalPort = function (state, terminal, source) {
            return terminal;
        };
        // 重写获取所有连接点方法
        this.getAllConnectionConstraints = function (terminal, source) {
            if (terminal != null) {
                var constraints = mxgraph_ts_1.mxUtils.getValue(terminal.style, 'points', null);
                if (constraints != null) {
                    // Requires an array of arrays with x, y (0..1), an optional
                    // [perimeter (0 or 1), dx, and dy] eg. points=[[0,0,1,-10,10],[0,1,0],[1,1]]
                    var result = [];
                    try {
                        var c = JSON.parse(constraints);
                        for (var i = 0; i < c.length; i++) {
                            var tmp = c[i];
                            result.push(new mxgraph_ts_1.mxConnectionConstraint(new mxgraph_ts_1.mxPoint(tmp[0], tmp[1]), (tmp.length > 2) ? tmp[2] != '0' : true, null, (tmp.length > 3) ? tmp[3] : 0, (tmp.length > 4) ? tmp[4] : 0));
                        }
                    }
                    catch (e) {
                        // ignore
                    }
                    return result;
                }
                else if (terminal.shape != null && terminal.shape.bounds != null) {
                    var dir = terminal.shape.direction;
                    var bounds = terminal.shape.bounds;
                    var scale = terminal.shape.scale;
                    var w = bounds.width / scale;
                    var h = bounds.height / scale;
                    if (dir == mxgraph_ts_1.mxConstants.DIRECTION_NORTH || dir == mxgraph_ts_1.mxConstants.DIRECTION_SOUTH) {
                        var tmp = w;
                        w = h;
                        h = tmp;
                    }
                    constraints = terminal.shape.getConstraints(terminal.style, w, h);
                    if (constraints != null) {
                        return constraints;
                    }
                    else if (terminal.shape.stencil != null && terminal.shape.stencil.constraints != null) {
                        return terminal.shape.stencil.constraints;
                    }
                    else if (terminal.shape.constraints != null) {
                        return terminal.shape.constraints;
                    }
                }
            }
            return null;
        };
        // 为连线的style设置连接点信息
        this.setConnectionConstraint = function (edge, terminal, source, constraint) {
            if (constraint != null && constraint.point != null) {
                if (source) {
                    _this.setCellStyles(mxgraph_ts_1.mxConstants.STYLE_EXIT_X, constraint.point.x, [edge]);
                    _this.setCellStyles(mxgraph_ts_1.mxConstants.STYLE_EXIT_Y, constraint.point.y, [edge]);
                }
                else {
                    _this.setCellStyles(mxgraph_ts_1.mxConstants.STYLE_ENTRY_X, constraint.point.x, [edge]);
                    _this.setCellStyles(mxgraph_ts_1.mxConstants.STYLE_ENTRY_Y, constraint.point.y, [edge]);
                }
            }
        };
        // 从连线的style获取连接点信息
        this.getConnectionConstraint = function (edge, terminal, source) {
            var point = new mxgraph_ts_1.mxPoint();
            if (source) {
                point.x = edge.style[mxgraph_ts_1.mxConstants.STYLE_EXIT_X];
                point.y = edge.style[mxgraph_ts_1.mxConstants.STYLE_EXIT_Y];
            }
            else {
                point.x = edge.style[mxgraph_ts_1.mxConstants.STYLE_ENTRY_X];
                point.y = edge.style[mxgraph_ts_1.mxConstants.STYLE_ENTRY_Y];
            }
            var constraint = mxgraph_ts_1.mxImageShape.prototype.constraints ? mxgraph_ts_1.mxImageShape.prototype.constraints.find(function (it) { return it.point.x == point.x && it.point.y == point.y; }) : null;
            return constraint;
        };
    };
    /**
     * 分布排列节点
     * @param horizontal true: 横向分布，false：纵向分布
     * @param cells
     * @returns
     */
    Graph.prototype.distributeCells = function (horizontal, cells) {
        if (cells == null) {
            cells = this.getSelectionCells();
        }
        if (cells != null && cells.length > 1) {
            var vertices = [];
            var max = null;
            var min = null;
            for (var i = 0; i < cells.length; i++) {
                if (this.getModel().isVertex(cells[i])) {
                    var state = this.view.getState(cells[i]);
                    if (state != null) {
                        var tmp = (horizontal) ? state.getCenterX() : state.getCenterY();
                        max = (max != null) ? Math.max(max, tmp) : tmp;
                        min = (min != null) ? Math.min(min, tmp) : tmp;
                        vertices.push(state);
                    }
                }
            }
            if (vertices.length > 2) {
                vertices.sort(function (a, b) {
                    return (horizontal) ? a.x - b.x : a.y - b.y;
                });
                var t = this.view.translate;
                var s = this.view.scale;
                min = min / s - ((horizontal) ? t.x : t.y);
                max = max / s - ((horizontal) ? t.x : t.y);
                this.getModel().beginUpdate();
                try {
                    var dt = (max - min) / (vertices.length - 1);
                    var t0 = min;
                    for (var i = 1; i < vertices.length - 1; i++) {
                        var pstate = this.view.getState(this.model.getParent(vertices[i].cell));
                        var geo = this.getCellGeometry(vertices[i].cell);
                        t0 += dt;
                        if (geo != null && pstate != null) {
                            geo = geo.clone();
                            if (horizontal) {
                                geo.x = Math.round(t0 - geo.width / 2) - pstate.origin.x;
                            }
                            else {
                                geo.y = Math.round(t0 - geo.height / 2) - pstate.origin.y;
                            }
                            this.getModel().setGeometry(vertices[i].cell, geo);
                        }
                    }
                }
                finally {
                    this.getModel().endUpdate();
                }
            }
        }
        return cells;
    };
    /**
     * 重写创建GraphView方法
     * @override
     */
    Graph.prototype.createGraphView = function () {
        return new GraphView_1.GraphView(this);
    };
    /**
     * 重写连线处理器创建方法，默认创建SequenceFlowEdge
     * @override
     */
    Graph.prototype.createConnectionHandler = function () {
        var handler = new mxgraph_ts_1.mxConnectionHandler(this, function (source, target, style) {
            var edge = BpmnCellHelper_1.BpmnCellHelper.generate(SequenceFlowEdge_1.SequenceFlowEdge.CLR_TYPE_ID, undefined, new mxgraph_ts_1.mxGeometry(), style);
            edge.geometry.relative = true;
            edge.source = source;
            edge.target = target;
            return edge;
        });
        return handler;
    };
    /**
     * 设置元素显示标签内容
     * @override
     */
    Graph.prototype.getLabel = function (cell) {
        if (cell instanceof Cell_1.Cell) {
            if (this.editorUi.multiLangEnabled) {
                var label = _super.prototype.getLabel.call(this, cell);
                if (cell.flowElement != null) {
                    label = cell.flowElement.Name;
                    if (cell.flowElement.NameLanguage && cell.flowElement.NameLanguage[this.editorUi.langCode] != null && cell.flowElement.NameLanguage[this.editorUi.langCode] != "") {
                        label = cell.flowElement.NameLanguage[this.editorUi.langCode];
                    }
                }
                return label;
            }
            else {
                return (cell.flowElement && cell.flowElement.Name) || _super.prototype.getLabel.call(this, cell);
            }
        }
        return _super.prototype.getLabel.call(this, cell);
    };
    /**
     * 设置网格状态
     * @override
     * @param value
     */
    Graph.prototype.setGridEnabled = function (value) {
        _super.prototype.setGridEnabled.call(this, value);
        this.fireEvent(new mxgraph_ts_1.mxEventObject(PmfEvents_1.PmfEvents.GridEnabledChanged));
    };
    /**
     * 判断是否是泳道
     * @override
     * @param cell
     * @returns
     */
    Graph.prototype.isSwimlane = function (cell) {
        if (typeof this.model.getValue(cell) == 'string') {
            return this.model.getValue(cell).toString().indexOf('Container') > -1;
        }
        return false;
    };
    /**
     * 判断是否为旧版本BPMNEdge
     *
     * 旧版本连线Points数组中[0]和[1]分别表示起点和终点，因取值错误，[0]和[1]坐标均为(0,0)，以此为依据判断是否为旧版本的连线
     * 新版本从起点到终点按顺序记录每一个点坐标
     * @param bpmnEdge
     * @returns
     */
    Graph.prototype.isOldBpmnEdge = function (bpmnEdge) {
        if (bpmnEdge.Points.length >= 2) {
            var pt1 = bpmnEdge.Points[0];
            var pt2 = bpmnEdge.Points[1];
            if (pt1.X == 0 && pt1.Y == 0 && pt2.X == 0 && pt2.Y == 0) {
                return true;
            }
        }
        return false;
    };
    /**
     * 默认页面背景色
     */
    Graph.defaultPageBackgroundColor = '#ffffff';
    /**
     * 默认页面边框色
     */
    Graph.defaultPageBorderColor = '#ffffff';
    return Graph;
}(mxgraph_ts_1.mxGraph));
exports.Graph = Graph;
//# sourceMappingURL=Graph.js.map