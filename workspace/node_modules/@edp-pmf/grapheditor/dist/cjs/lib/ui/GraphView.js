"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphView = void 0;
var tslib_1 = require("tslib");
var mxgraph_ts_1 = require("@edp-pmf/mxgraph-ts");
var Base64_1 = require("../util/Base64");
var Constant_1 = require("../util/Constant");
var Graph_1 = require("./Graph");
/**
 * 画布视图类，可通过mxCellState获取元素的绝对坐标等信息
 */
var GraphView = /** @class */ (function (_super) {
    tslib_1.__extends(GraphView, _super);
    function GraphView(graph) {
        var _this = _super.call(this, graph) || this;
        /**
         * 网格图片
         */
        _this.gridImage = Constant_1.Constant.IMAGE_PATH + '/grid.gif';
        /**
         * 网格颜色
         */
        _this.gridColor = '#e0e0e0';
        /**
         * 网格间隔
         */
        _this.gridSteps = 4;
        /**
         * 网格大小
         */
        _this.minGridSize = 4;
        return _this;
    }
    /**
     * 画布网格背景
     */
    GraphView.prototype.validateBackgroundPage = function () {
        _super.prototype.validateBackgroundPage.call(this);
        var graph = this.graph;
        if (graph.container != null) {
            this.validateBackgroundStyles();
        }
    };
    /**
     * 画布网格背景
     */
    GraphView.prototype.validateBackgroundStyles = function () {
        // Updates the CSS of the background to draw the grid
        var graph = this.graph;
        var color = (graph.background == null || graph.background == mxgraph_ts_1.mxConstants.NONE) ? Graph_1.Graph.defaultPageBackgroundColor : graph.background;
        var gridColor = (color != null && this.gridColor != color.toLowerCase()) ? this.gridColor : '#ffffff';
        var image = 'none';
        var position = '';
        if (graph.isGridEnabled()) {
            var phase = 10;
            if (mxgraph_ts_1.mxClient.IS_SVG) {
                // Generates the SVG required for drawing the dynamic grid
                image = unescape(encodeURIComponent(this.createSvgGrid(gridColor)));
                image = (window.btoa) ? btoa(image) : Base64_1.Base64.encode(image, true);
                image = 'url(' + 'data:image/svg+xml;base64,' + image + ')';
                phase = graph.gridSize * this.scale * this.gridSteps;
            }
            else {
                // Fallback to grid wallpaper with fixed size
                image = 'url(' + this.gridImage + ')';
            }
            var x0 = 0;
            var y0 = 0;
            if (graph.view.backgroundPageShape != null) {
                var bds = this.getBackgroundPageBounds();
                x0 = 1 + bds.x;
                y0 = 1 + bds.y;
            }
            // Computes the offset to maintain origin for grid
            position = -Math.round(phase - mxgraph_ts_1.mxUtils.mod(this.translate.x * this.scale - x0, phase)) + 'px ' +
                -Math.round(phase - mxgraph_ts_1.mxUtils.mod(this.translate.y * this.scale - y0, phase)) + 'px';
        }
        var canvas = graph.view.canvas;
        if (canvas.ownerSVGElement != null) {
            canvas = canvas.ownerSVGElement;
        }
        if (graph.view.backgroundPageShape != null) {
            graph.view.backgroundPageShape.node.style.backgroundPosition = position;
            graph.view.backgroundPageShape.node.style.backgroundImage = image;
            graph.view.backgroundPageShape.node.style.backgroundColor = color;
            graph.container.className = 'geDiagramContainer geDiagramBackdrop';
            canvas.style.backgroundImage = 'none';
            canvas.style.backgroundColor = '';
        }
        else {
            graph.container.className = 'geDiagramContainer';
            canvas.style.backgroundPosition = position;
            canvas.style.backgroundColor = color;
            canvas.style.backgroundImage = image;
        }
    };
    /**
     * 画布网格背景
     */
    GraphView.prototype.createSvgGrid = function (color) {
        // Returns the SVG required for painting the background grid.
        var tmp = this.graph.gridSize * this.scale;
        while (tmp < this.minGridSize) {
            tmp *= 2;
        }
        var tmp2 = this.gridSteps * tmp;
        // Small grid lines
        var d = [];
        for (var i = 1; i < this.gridSteps; i++) {
            var tmp3 = i * tmp;
            d.push('M 0 ' + tmp3 + ' L ' + tmp2 + ' ' + tmp3 + ' M ' + tmp3 + ' 0 L ' + tmp3 + ' ' + tmp2);
        }
        // KNOWN: Rounding errors for certain scales (eg. 144%, 121% in Chrome, FF and Safari). Workaround
        // in Chrome is to use 100% for the svg size, but this results in blurred grid for large diagrams.
        var size = tmp2;
        var svg = '<svg width="' + size + '" height="' + size + '" xmlns="' + mxgraph_ts_1.mxConstants.NS_SVG + '">' +
            '<defs><pattern id="grid" width="' + tmp2 + '" height="' + tmp2 + '" patternUnits="userSpaceOnUse">' +
            '<path d="' + d.join(' ') + '" fill="none" stroke="' + color + '" opacity="0.2" stroke-width="1"/>' +
            '<path d="M ' + tmp2 + ' 0 L 0 0 0 ' + tmp2 + '" fill="none" stroke="' + color + '" stroke-width="1"/>' +
            '</pattern></defs><rect width="100%" height="100%" fill="url(#grid)"/></svg>';
        return svg;
    };
    return GraphView;
}(mxgraph_ts_1.mxGraphView));
exports.GraphView = GraphView;
//# sourceMappingURL=GraphView.js.map