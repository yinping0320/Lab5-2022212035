import { RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
import { NgModule, Injectable, Optional, defineInjectable } from '@angular/core';
import { CookieService } from 'ngx-cookie-service';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommonSharedModule {
}
CommonSharedModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule
                ],
                declarations: [],
                exports: [],
                providers: [],
                entryComponents: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract cache storage
 * @abstract
 */
class CacheStorageAbstract {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in session storage
 */
class CacheSessionStorage extends CacheStorageAbstract {
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        /** @type {?} */
        const value = sessionStorage.getItem(key);
        return value ? JSON.parse(value) : null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setItem(key, value) {
        try {
            sessionStorage.setItem(key, JSON.stringify(value));
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        sessionStorage.removeItem(key);
    }
    /**
     * @return {?}
     */
    clear() {
        sessionStorage.clear();
    }
    /**
     * @return {?}
     */
    type() {
        return 1 /* SESSION_STORAGE */;
    }
    /**
     * @return {?}
     */
    isEnabled() {
        try {
            sessionStorage.setItem('test', 'test');
            sessionStorage.removeItem('test');
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
CacheSessionStorage.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in local storage
 */
class CacheLocalStorage extends CacheStorageAbstract {
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        /** @type {?} */
        const value = localStorage.getItem(key);
        return value ? JSON.parse(value) : null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setItem(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        localStorage.removeItem(key);
    }
    /**
     * @return {?}
     */
    clear() {
        localStorage.clear();
    }
    /**
     * @return {?}
     */
    type() {
        return 0 /* LOCAL_STORAGE */;
    }
    /**
     * @return {?}
     */
    isEnabled() {
        try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
CacheLocalStorage.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WindowVariableService {
    constructor() { }
    /**
     * 从当前window遍历到框架顶级window
     * 并获取一个非空的自定义变量
     * @param {?} key
     * @return {?}
     */
    getVariableFromWindow(key) {
        /** @type {?} */
        const topWin = this.getTopWindow();
        /** @type {?} */
        let frmWin = window;
        while (!frmWin[key] && frmWin !== topWin) {
            frmWin = frmWin.parent;
        }
        return frmWin[key];
    }
    /**
     * 从当前window遍历到框架顶级window
     * 并获取一个非空且含有元素的自定义数组变量
     * @param {?} key
     * @return {?}
     */
    getArrayFromWindow(key) {
        /** @type {?} */
        const topWin = this.getTopWindow();
        /** @type {?} */
        let frmWin = window;
        while ((!frmWin[key] || frmWin[key].length === 0) && frmWin !== topWin) {
            frmWin = frmWin.parent;
        }
        return (/** @type {?} */ (frmWin[key])) || [];
    }
    /**
     * 获取框架的顶级window
     * 进行跨域封装
     * @return {?}
     */
    getTopWindow() {
        /** @type {?} */
        let curWin = window.self;
        try {
            while (curWin.location.origin === curWin.parent.location.origin) {
                if (curWin !== curWin.parent && !((/** @type {?} */ (curWin))).isRTFTopWin) {
                    curWin = curWin.parent;
                }
                else {
                    break;
                }
            }
        }
        catch (e) { }
        return curWin;
    }
}
WindowVariableService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
WindowVariableService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in local storage
 */
class CacheMemoryStorage extends CacheStorageAbstract {
    constructor() {
        super(...arguments);
        this._data = {};
        this.windowSvc = new WindowVariableService();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        /** @type {?} */
        const cache = this.getGlobleCache(key);
        if (cache) {
            this._data[key] = cache;
        }
        return this._data[key] ? this._data[key] : null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setItem(key, value) {
        this.setGlobleCache(key, value);
        this._data[key] = value;
        return true;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        delete this._data[key];
    }
    /**
     * @return {?}
     */
    clear() {
        this._data = [];
    }
    /**
     * @return {?}
     */
    type() {
        return 2 /* MEMORY */;
    }
    /**
     * @return {?}
     */
    isEnabled() {
        return true;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setGlobleCache(key, value) {
        /** @type {?} */
        const topWindow = this.windowSvc.getTopWindow();
        try {
            if (topWindow.name) {
                /** @type {?} */
                let exist = false;
                /** @type {?} */
                const ary = topWindow.name.split('&|&');
                // tslint:disable-next-line: prefer-for-of
                for (let i = 0; i < ary.length; i++) {
                    if (ary[i]) {
                        /** @type {?} */
                        const obj = JSON.parse(ary[i]);
                        if (obj[key]) {
                            topWindow.name = topWindow.name.replace(ary[i], this.serializeData(key, value));
                            exist = true;
                            break;
                        }
                    }
                }
                if (!exist) {
                    topWindow.name += '&|&' + this.serializeData(key, value);
                }
            }
            else {
                topWindow.name = this.serializeData(key, value);
            }
        }
        catch (_a) {
            topWindow.name = '';
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    getGlobleCache(key) {
        /** @type {?} */
        const topWindow = this.windowSvc.getTopWindow();
        try {
            /** @type {?} */
            let result;
            if (topWindow.name) {
                if (topWindow.name.indexOf('&|&') >= 0) {
                    /** @type {?} */
                    const ary = topWindow.name.split('&|&');
                    for (let i = 0; i < ary.length; i++) {
                        if (ary[i]) {
                            /** @type {?} */
                            const obj = JSON.parse(ary[i]);
                            if (obj[key]) {
                                result = obj[key].value;
                                if (i === 0) {
                                    topWindow.name = topWindow.name.replace(ary[i] + '&|&', '');
                                }
                                else {
                                    topWindow.name = topWindow.name.replace('&|&' + ary[i], '');
                                }
                                break;
                            }
                        }
                    }
                }
                else {
                    /** @type {?} */
                    const obj = JSON.parse(topWindow.name);
                    if (obj[key]) {
                        result = obj[key].value;
                        topWindow.name = '';
                    }
                }
            }
            return result;
        }
        catch (_a) {
            topWindow.name = '';
            return null;
        }
    }
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    serializeData(key, value) {
        /** @type {?} */
        const obj = {};
        obj[key] = {
            value
        };
        return JSON.stringify(obj);
    }
}
CacheMemoryStorage.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CACHE_PREFIX = 'CacheService';
/** @type {?} */
const DEFAULT_STORAGE = 2 /* MEMORY */;
/** @type {?} */
const DEFAULT_ENABLED_STORAGE = 1 /* SESSION_STORAGE */;
class CacheService {
    /**
     * @param {?} _storage
     */
    constructor(_storage) {
        this._storage = _storage;
        /**
         * Default cache options
         * CacheOptionsInterface
         *
         */
        this._defaultOptions = {
            expires: Number.MAX_VALUE,
            maxAge: Number.MAX_VALUE
        };
        /**
         * Cache prefix
         */
        this._prefix = CACHE_PREFIX;
        this._validateStorage();
    }
    /**
     * Set data to cache
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    set(key, value, options) {
        /** @type {?} */
        const storageKey = this._toStorageKey(key);
        options = options ? options : this._defaultOptions;
        if (this._storage.setItem(storageKey, this._toStorageValue(value, options))) {
            if (!this._isSystemKey(key) && options.tag) {
                this._saveTag(options.tag, storageKey);
            }
            return true;
        }
        return false;
    }
    /**
     * Get data from cache
     * @param {?} key
     * @return {?}
     */
    get(key) {
        /** @type {?} */
        const storageValue = this._storage.getItem(this._toStorageKey(key));
        /** @type {?} */
        let value = null;
        if (storageValue) {
            if (this._validateStorageValue(storageValue)) {
                value = storageValue.value;
            }
            else {
                this.remove(key);
            }
        }
        return value;
    }
    /**
     * Check if value exists
     * @param {?} key
     * @return {?}
     */
    exists(key) {
        return !!this.get(key);
    }
    /**
     * Remove item from cache
     * @param {?} key
     * @return {?}
     */
    remove(key) {
        this._storage.removeItem(this._toStorageKey(key));
        this._removeFromTag(this._toStorageKey(key));
    }
    /**
     * Remove all from cache
     * @return {?}
     */
    removeAll() {
        this._storage.clear();
    }
    /**
     * Get all tag data
     * @param {?} tag
     * @return {?}
     */
    getTagData(tag) {
        /** @type {?} */
        const tags = this.get(this._tagsStorageKey()) || {};
        /** @type {?} */
        const result = {};
        if (tags[tag]) {
            tags[tag].forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                /** @type {?} */
                const data = this.get(this._fromStorageKey(key));
                if (data) {
                    result[this._fromStorageKey(key)] = data;
                }
            }));
        }
        return result;
    }
    /**
     * Create a new instance of cache with needed storage
     * @param {?} type
     * @return {?}
     */
    useStorage(type) {
        /** @type {?} */
        const service = new CacheService(this._initStorage(type));
        service.setGlobalPrefix(this._getCachePrefix());
        return service;
    }
    /**
     * Remove all by tag
     * @param {?} tag
     * @return {?}
     */
    removeTag(tag) {
        /** @type {?} */
        const tags = this.get(this._tagsStorageKey()) || {};
        if (tags[tag]) {
            tags[tag].forEach((/**
             * @param {?} key
             * @return {?}
             */
            (key) => {
                this._storage.removeItem(key);
            }));
            delete tags[tag];
            this.set(this._tagsStorageKey(), tags);
        }
    }
    /**
     * Set global cache key prefix
     * @param {?} prefix
     * @return {?}
     */
    setGlobalPrefix(prefix) {
        this._prefix = prefix;
    }
    /**
     * Validate cache storage
     *
     * @private
     * @return {?}
     */
    _validateStorage() {
        if (!this._storage) {
            this._storage = this._initStorage(DEFAULT_STORAGE);
        }
        if (!this._storage.isEnabled()) {
            this._storage = this._initStorage(DEFAULT_ENABLED_STORAGE);
        }
    }
    /**
     * Remove key from tags keys list
     * @private
     * @param {?} key
     * @return {?}
     */
    _removeFromTag(key) {
        // tslint:disable-next-line:prefer-const
        /** @type {?} */
        let tags = this.get(this._tagsStorageKey()) || {};
        /** @type {?} */
        let index;
        // tslint:disable-next-line:forin
        for (const tag in tags) {
            index = tags[tag].indexOf(key);
            if (index !== -1) {
                tags[tag].splice(index, 1);
                this.set(this._tagsStorageKey(), tags);
                break;
            }
        }
    }
    /**
     * Init storage by type
     * @private
     * @param {?} type
     * @return {?}
     */
    _initStorage(type) {
        /** @type {?} */
        let storage;
        switch (type) {
            case 1 /* SESSION_STORAGE */:
                storage = new CacheSessionStorage();
                break;
            case 0 /* LOCAL_STORAGE */:
                storage = new CacheLocalStorage();
                break;
            default: storage = new CacheMemoryStorage();
        }
        return storage;
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    _toStorageKey(key) {
        return this._getCachePrefix() + key;
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    _fromStorageKey(key) {
        return key.replace(this._getCachePrefix(), '');
    }
    /**
     * Prepare value to set to storage
     *
     * @private
     * @param {?} value
     * @param {?} options
     * @return {?}
     */
    _toStorageValue(value, options) {
        return {
            value: value,
            options: this._toStorageOptions(options)
        };
    }
    /**
     * Prepare options to set to storage
     *
     * @private
     * @param {?} options
     * @return {?}
     */
    _toStorageOptions(options) {
        /** @type {?} */
        const storageOptions = {};
        storageOptions.expires = options.expires ? options.expires :
            (options.maxAge ? Date.now() + (options.maxAge * 1000) : this._defaultOptions.expires);
        storageOptions.maxAge = options.maxAge ? options.maxAge : this._defaultOptions.maxAge;
        return storageOptions;
    }
    /**
     * Validate storage value
     *
     * @private
     * @param {?} value
     * @return {?}
     */
    _validateStorageValue(value) {
        return !!value.options.expires && value.options.expires > Date.now();
    }
    /**
     * check if its system cache key
     *
     * @private
     * @param {?} key
     * @return {?}
     */
    _isSystemKey(key) {
        return [this._tagsStorageKey()].indexOf(key) !== -1;
    }
    /**
     * Save tag to list of tags
     *
     *
     * @private
     * @param {?} tag
     * @param {?} key
     * @return {?}
     */
    _saveTag(tag, key) {
        /** @type {?} */
        const tags = this.get(this._tagsStorageKey()) || {};
        if (!tags[tag]) {
            tags[tag] = [key];
        }
        else {
            tags[tag].push(key);
        }
        this.set(this._tagsStorageKey(), tags);
    }
    /**
     * Get global cache prefix
     *
     *
     * @private
     * @return {?}
     */
    _getCachePrefix() {
        return this._prefix;
    }
    /**
     * @private
     * @return {?}
     */
    _tagsStorageKey() {
        return 'CacheService_tags';
    }
}
CacheService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CacheService.ctorParameters = () => [
    { type: CacheStorageAbstract, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommonUtil {
    /**
     * @param {?} paraName
     * @return {?}
     */
    static getQueryString(paraName) {
        /** @type {?} */
        const reg = new RegExp('(^|&)' + paraName + '=([^&]*)(&|$)', 'i');
        /** @type {?} */
        const r = window.location.search.substr(1).match(reg);
        /** @type {?} */
        let paraValue = '';
        if (r) {
            paraValue = r[2];
        }
        return paraValue;
    }
    /**
     * @param {?} paraName
     * @return {?}
     */
    static getQueryStringFromHash(paraName) {
        /** @type {?} */
        const url = window.location.hash;
        /** @type {?} */
        const arrObj = url && url.split('?');
        if (arrObj && arrObj.length > 1) {
            /** @type {?} */
            const arrPara = arrObj[1].split('&');
            if (!arrPara) {
                return '';
            }
            /** @type {?} */
            let arr;
            // tslint:disable-next-line: prefer-for-of
            for (let i = 0; i < arrPara.length; i++) {
                arr = arrPara[i].split('=');
                if (arr != null && arr[0] === paraName) {
                    return arr[1];
                }
            }
            return '';
        }
        else {
            return '';
        }
    }
    /**
     * @return {?}
     */
    static getCookieMapFromDoc() {
        /** @type {?} */
        const cookieArr = document.cookie && document.cookie.split(';');
        /** @type {?} */
        const cookieMap = new Map();
        if (cookieArr) {
            cookieArr.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                /** @type {?} */
                const params = item.split('=');
                cookieMap.set(params[0], params[1]);
            }));
        }
        return cookieMap;
    }
    /**
     * 获取当前window 中funcId appId等公共变量
     * 返回结果格式：funcId=xx&appType=xxx&
     * @return {?}
     */
    static getCommonVariables() {
        return CommonUtil.getQueryStringFromHash('cvft');
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    static matchCommonVariableKey(item) {
        /** @type {?} */
        const itemArr = item.split('=');
        if (!itemArr || itemArr.length !== 2 || !itemArr[0]) {
            return false;
        }
        switch (itemArr[0].toLowerCase()) {
            case 'funcid': return true;
            case 'appid': return true;
            case 'appentrance': return true;
            case 'apptype': return true;
        }
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SessionService {
    constructor() {
        this.SessionKey = 'session';
        this.SessionKeyForIde = 'sessionId';
        this.FuncSessionKey = 'FuncSession';
        window[this.FuncSessionKey] = window[this.FuncSessionKey] || new Map();
        this.windowService = new WindowVariableService();
    }
    /**
     * 获取用户sessionid
     * @return {?}
     */
    getUserSessionId() {
        return localStorage.getItem(this.SessionKey) || '';
    }
    /**
     * 获取当前session 之前依赖router的方式改掉
     * 从url hash中获取query
     * N 栈为funcSession
     * J 栈为formToken
     * @param {?=} tabId
     * @return {?}
     */
    getCurrentSeesionId(tabId) {
        if (!!tabId) {
            /** @type {?} */
            const tab = this.getTabArray().find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.id === tabId));
            return tab && (tab.formToken || tab.sessionId);
        }
        /** @type {?} */
        let ssid = CommonUtil.getQueryStringFromHash('cvft');
        if (!ssid) {
            /** @type {?} */
            const pageId = CommonUtil.getQueryStringFromHash('tabId');
            /** @type {?} */
            const tab = this.getTabArray().find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.id === pageId));
            if (tab) {
                ssid = (tab.formToken || tab.sessionId);
            }
        }
        return ssid || this.getUserSessionId();
    }
    /**
     *
     * 获取功能的session(功能重复打开，会存在多个)
     * (1912 框架移除funcSession，接口作废)
     * @param {?} funcId
     * @return {?}
     */
    getFuncSessionId(funcId) {
        /** @type {?} */
        const ssMap = new Map();
        /** @type {?} */
        const tabs = this.getTabArray().filter((/**
         * @param {?} t
         * @return {?}
         */
        t => t.funcId === funcId));
        if (!tabs || tabs.length === 0) {
            return ssMap;
        }
        // tslint:disable-next-line: prefer-for-of
        for (let i = 0; i < tabs.length; i++) {
            ssMap.set(tabs[i].tabId, tabs[i].sessionId);
        }
        return ssMap;
    }
    /**
     * 获取应用session（应用重复打开会存在多个）
     * (1912 框架移除funcSession，接口作废)
     * @param {?} appId
     * @param {?} appEntrance
     * @return {?}
     */
    getAppSessionId(appId, appEntrance) {
        /** @type {?} */
        const ssMap = new Map();
        /** @type {?} */
        const tabs = this.getTabArray().filter((/**
         * @param {?} t
         * @return {?}
         */
        t => t.appId === appId && t.appEntrance === appEntrance));
        if (!tabs || tabs.length === 0) {
            return ssMap;
        }
        // tslint:disable-next-line: prefer-for-of
        for (let i = 0; i < tabs.length; i++) {
            ssMap.set(tabs[i].tabId, tabs[i].sessionId);
        }
        return ssMap;
    }
    /**
     * 设置用户sessionid
     * 只是用于N版
     * @param {?} ssid
     * @return {?}
     */
    setUserSessionId(ssid) {
        // todo框架修改之后，要和IDE同步
        localStorage.setItem(this.SessionKey, ssid);
        localStorage.setItem(this.SessionKeyForIde, ssid);
    }
    /**
     * 缓存当前功能的sessionid
     * (1912 框架移除funcSession，接口作废)
     * @param {?} key
     * @param {?} ssid
     * @return {?}
     */
    setFuncSessionId(key, ssid) {
        this.getFuncSessionCache().set(key, ssid);
    }
    /**
     * 缓存当前应用的sessionId
     * (1912 框架移除funcSession，接口作废)
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?} ssid
     * @return {?}
     */
    setAppSessionId(appId, appEntrance, ssid) {
        this.setFuncSessionId(`${appId}#${appEntrance}`, ssid);
    }
    /**
     * @private
     * @return {?}
     */
    getFuncSessionCache() {
        /** @type {?} */
        const sessionValue = this.windowService.getVariableFromWindow(this.FuncSessionKey);
        return (/** @type {?} */ (sessionValue));
    }
    /**
     * @private
     * @return {?}
     */
    getTabArray() {
        /** @type {?} */
        const iframeTabarray = 'iframeTabarray';
        /** @type {?} */
        const iframArr = this.windowService.getArrayFromWindow(iframeTabarray);
        return iframArr;
    }
}
SessionService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SessionService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpService {
    /**
     * @param {?} http
     * @param {?} sessionService
     */
    constructor(http, sessionService) {
        this.http = http;
        this.sessionService = sessionService;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    get(url) {
        return this.request('Get', url, this.setHeader({}));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    post(url, body) {
        return this.request('Post', url, this.setHeader({ body }));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    put(url, body) {
        return this.request('Put', url, this.setHeader({ body }));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    delete(url, body) {
        return this.request('Delete', url, this.setHeader({ body }));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    patch(url, body) {
        return this.request('Patch', url, this.setHeader({ body }));
    }
    /**
     * 默认用当前sessionid
     * @param {?} options
     * @param {?=} bizContextId
     * @return {?}
     */
    setHeader(options, bizContextId) {
        options.headers = {
            'Content-Type': 'application/json'
        };
        /** @type {?} */
        const commonVariables = CommonUtil.getCommonVariables();
        if (commonVariables) {
            /** @type {?} */
            const commonVariableKey = 'X-CAF-Runtime-CommonVariable';
            options.headers[commonVariableKey] = commonVariables;
        }
        if (bizContextId) {
            /** @type {?} */
            const bizContextKey = 'X-CAF-Runtime-Context';
            options.headers[bizContextKey] = bizContextId;
        }
        return options;
    }
    /**
     * @param {?} method
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    request(method, url, options) {
        if (options.body) {
            if (typeof options.body !== 'string') {
                options.body = JSON.stringify(options.body);
            }
        }
        return this.http.request(method, url, options)
            .pipe(map((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            return data;
        })));
    }
    /**
     * @param {?} method
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    request$(method, url, options) {
        return this.http.request(method, url, options);
    }
}
HttpService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HttpService.ctorParameters = () => [
    { type: HttpClient },
    { type: SessionService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LanguageService {
    /**
     * @param {?} cookieService
     */
    constructor(cookieService) {
        this.cookieService = cookieService;
        this.languageKey = 'languageCode';
        this.curLangugaeKey = 'caf_web_language';
    }
    /**
     * @param {?} languageCode
     * @return {?}
     */
    setLanguageCode(languageCode) {
        localStorage.setItem(this.languageKey, languageCode);
    }
    /**
     * @return {?}
     */
    getLanguageCode() {
        /** @type {?} */
        let curLancode = this.cookieService && this.cookieService.get(this.curLangugaeKey);
        if (!curLancode) {
            curLancode = CommonUtil.getCookieMapFromDoc().get(this.curLangugaeKey) ||
                localStorage.getItem(this.languageKey) ||
                'zh-CHS';
        }
        return curLancode;
    }
}
LanguageService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LanguageService.ctorParameters = () => [
    { type: CookieService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabEntityService {
    constructor() {
        this.nameSpace = 'gsp-rtf-tabarr-service';
        this.tabarrayKey = 'tab-arry';
        this.windowService = new WindowVariableService();
        this.topWin = this.windowService.getTopWindow();
        this.topWin[this.nameSpace] = this.topWin[this.nameSpace] || {};
    }
    /**
     * @param {?} tabs
     * @return {?}
     */
    setTabs(tabs) {
        if (!tabs || tabs.length === 0) {
            return;
        }
        /** @type {?} */
        const copy = this.deepClone(tabs);
        this.topWin[this.nameSpace][this.tabarrayKey] = copy;
    }
    /**
     * @return {?}
     */
    getTabs() {
        /** @type {?} */
        const tabs = this.topWin[this.nameSpace][this.tabarrayKey] || [];
        if (!tabs || tabs.length === 0) {
            return tabs;
        }
        return this.deepClone(tabs);
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    setActiveTab(tab) {
        /** @type {?} */
        const tabs = this.getTabs();
        /** @type {?} */
        const activeOld = tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t.active));
        if (!tab) {
            if (!!activeOld) {
                activeOld.active = false;
            }
            return;
        }
        if (tabs.length > 0) {
            /** @type {?} */
            let activeNew = tabs.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.id === tab.id));
            if (!activeNew) {
                activeNew = tab;
                if (!!activeOld) {
                    activeOld.active = false;
                }
                activeNew.active = true;
                tabs.push(activeNew);
            }
            else {
                if (!!activeOld) {
                    if (activeOld === activeNew) {
                        return;
                    }
                    else {
                        activeOld.active = false;
                        activeNew.active = true;
                    }
                }
                else {
                    activeNew.active = true;
                }
            }
            this.setTabs(tabs);
        }
    }
    /**
     * @return {?}
     */
    getActiveTab() {
        /** @type {?} */
        const tabs = this.getTabs();
        /** @type {?} */
        const activeTab = tabs && tabs.find((/**
         * @param {?} t
         * @return {?}
         */
        t => t.active));
        /** @type {?} */
        const res = activeTab && {
            tabId: activeTab.id,
            appType: activeTab.appType,
            funcId: activeTab.funcId,
            appId: activeTab.appId,
            appEntrance: activeTab.appEntrance,
            name: activeTab.FuncName
        };
        return res;
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    deepClone(target) {
        /** @type {?} */
        let result;
        if (typeof target === 'object') {
            if (Array.isArray(target)) {
                result = [];
                for (let i in target) {
                    result.push(this.deepClone(target[i]));
                }
            }
            else if (target === null) {
                result = null;
            }
            else if (target.constructor === RegExp) {
                result = target;
            }
            else {
                result = {};
                for (let i in target) {
                    result[i] = this.deepClone(target[i]);
                }
            }
        }
        else {
            result = target;
        }
        return result;
    }
}
TabEntityService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TabEntityService.ctorParameters = () => [];
/** @nocollapse */ TabEntityService.ngInjectableDef = defineInjectable({ factory: function TabEntityService_Factory() { return new TabEntityService(); }, token: TabEntityService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrmCommonModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: FrmCommonModule,
            providers: [
                CacheService,
                { provide: CacheStorageAbstract, useClass: CacheMemoryStorage },
                HttpService,
                SessionService,
                LanguageService,
                WindowVariableService,
                TabEntityService,
                CookieService
            ]
        };
    }
}
FrmCommonModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [],
                exports: [],
                providers: [],
                entryComponents: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CommonUtil, CommonSharedModule, FrmCommonModule, CacheService, CacheStorageAbstract, CacheLocalStorage, CacheMemoryStorage, CacheSessionStorage, HttpService, SessionService, LanguageService, WindowVariableService, TabEntityService };

//# sourceMappingURL=ecp-caf-caf-common.js.map