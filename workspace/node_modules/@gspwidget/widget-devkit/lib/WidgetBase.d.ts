export declare abstract class WidgetBase {
    title: string;
    /** @deprecated */
    /** 留给筛选触发 load data，元部件可以触发，并传入额外参数，但实际 load 由 wc 来做。因为 wc 知道 id。 */
    /** 编译时将 @Widget 中的 name 赋值给 widgetName, 构造器中会检查是否有值，没有就报错 */
    widgetName: any;
    /** @deprecated 当前部件 id */
    portletId: string;
    /** @deprecated 当前部件实例 id */
    id: string;
    /** @deprecated 是否使用外部数据源。是的话，wc 就拿它的 portlet id 请求数据去。应改为 dataEngine 写法。 */
    useDataEngine: boolean;
    /**
     * @deprecated
     * assets 文件路径必需加上这个 base 前缀。注意在构造函数或之前使用时其值会为 undefined，
     * 因为实例化完成后，widget-container 才会给它赋正确的值。
     */
    assetsBaseUrl: string;
    /**
     * 因为是父类构造函数所以无法依赖注入, 也没法传入参数;
     * compInstance.field = xxx 的方式又发生在构造函数后而不太好,
     * 所以考虑此父类不提供成员属性, 而通过依赖注入, 在子组件自取.
     */
    constructor();
    /**
     * 元部件容器大小变化事件，参数 width 为容器宽度，单位 px。
     * 可重写此方法以处理复杂的响应式样式。
     */
    onResized(width: number, height: number): void;
    onPropertyChange(propName: string, value: any): void;
    /**
     * @deprecated
     * 请用 this.dataService.loadData() 代替
     * @param data 获得的数据
     */
    onGetData(data: any[]): void;
}
