import { HttpClient } from '@angular/common/http';
import { ChangeDetectorRef, EventEmitter, Injector, OnChanges, OnInit, SimpleChanges, ViewContainerRef } from '@angular/core';
import { BasicWidgetInfo, DataWithDims, Dimension, DpValue, EppPortlet, LinkMap, RuntimeAggOption, WidgetContainerMode } from '@gspwidget/util';
import { RegisteredWidgetConfig, WidgetBase, WidgetEventService, WidgetPropertyService } from '@gspwidget/widget-devkit';
import { TranslateService } from '@ngx-translate/core';
import { NzModalService } from 'ng-zorro-antd/modal';
import { Observable } from 'rxjs';
import { DynamicLoaderService } from '../dynamic-loader.service';
import { InstanceService } from '../instance.service';
import { TitleBarComponent } from '../title-bar/title-bar.component';
declare global {
    interface Window {
        widgetI18nResLoaded: boolean;
        widgetStyleLoaded: boolean;
        define: any;
    }
}
export declare enum WCStatus {
    LoadingWidget = 0,
    LoadingData = 1,
    DataEmpty = 2,
    Normal = 3,
    DataError = 4,
    WidgetLoadError = 5
}
export interface GetDataOptions {
    dpValues: DpValue[];
    runtimeAgg: RuntimeAggOption;
}
/**
 * 兼容阶段数据加载逻辑
 * 1. 若元部件 useDataEngine === true, 说明是老写法、且需要数据的元部件，但其内部未调用加载数据，所以初始化完成后加载一下；
 *    新数据加载请求处理永远启用，因为仅有新写法元部件会触发；
 * 2. 若 getData 有值，则用它获得数据，不用真数据
 * 3. 若名中带有 '演示'，则用演示数据
 * 4. 都不满足再用真数据
 */
export declare class WidgetComponent implements OnInit, OnChanges {
    private loader;
    private cd;
    private injector;
    private modal;
    private http;
    private translate;
    private widgetPropertyService;
    private widgetEventService;
    private insSerivce;
    /** 必选，要渲染的 widget 信息 */
    basicWidgetInfo: BasicWidgetInfo;
    /** 必选，此 widget 的配置信息；仅在元部件加载时起作用，若属性改变，必需调用 setPropValues() */
    propValues: any;
    linkMap: LinkMap;
    /** 可选 */
    mode: WidgetContainerMode;
    /** 可选，widget 的静态资源地址，一般不用管，特殊情况可配置，默认值为 this.basicWidgetInfo.baseUrl + '/assets/' */
    assetsBaseUrl: string;
    /** 可选，部件信息，需要注入到元部件 */
    portlet: EppPortlet;
    /** 可选，部件实例 id, 获取数据可能用到 */
    instanceId: string;
    /**
     * 必选，
     * 若指定，则元部件主动加载数据时使用它获取数据，
     * 不再加载真实数据。用于给元部件设置假数据
     */
    getData: (getDataOpts: GetDataOptions) => Observable<DataWithDims>;
    status: WCStatus;
    /** widget 加载完成，发出当前 widget 的信息 */
    widgetLoaded: EventEmitter<{}>;
    /** widget component create 完成，发出当前 widget 的信息 */
    widgetInit: EventEmitter<{}>;
    runtimeAggChange: EventEmitter<{}>;
    resizeTarget: any;
    widgetContainer: ViewContainerRef;
    titleBar: TitleBarComponent;
    WCStatus: typeof WCStatus;
    IGIX_HOME_PATH: string;
    FILTER_PROP_NAME: string;
    width: number;
    height: number;
    curWidgetConfig: RegisteredWidgetConfig;
    /** 存在此层的数据。可用于前端筛选、数据获取状态判断 */
    data: any[];
    /** 获取数据后存起来的维度。可用于页面设计时、运行时获取、显示维度 */
    dims: Dimension[];
    widgetInstance: WidgetBase;
    showRuntimeAgg: boolean;
    private widgetDataService;
    /** 公共头上是否显示运行时聚合配置 */
    constructor(loader: DynamicLoaderService, cd: ChangeDetectorRef, injector: Injector, modal: NzModalService, http: HttpClient, translate: TranslateService, widgetPropertyService: WidgetPropertyService, widgetEventService: WidgetEventService, insSerivce: InstanceService);
    /**
     * 全局初始化
     */
    private _initWidgetEnv;
    ngOnInit(): void;
    ngOnChanges(c: SimpleChanges): void;
    /**
     * 此 container 被 gridster 渲染出正确的大小事件
     */
    triggerWidgetResize(): void;
    /**
     * 外部更新元部件 propValues 的某属性后，需要调用此方法，否则我们不知道 propValues 发生了变化。
     * 不太好精简掉这个方法。尝试过用 keyValueDiffer 在 ngDoCheck 中检测 propValues 变化，但仅能检测一层。
     */
    setPropertyValue(propName: string, pValue: any): void;
    private processPV;
    renderWidget(): Promise<void>;
    private loadI18nRes;
    /**
     * pv 中包含 {fs,dp}[]（筛选控件+取数参数=筛选）
     * 部件实例中保存 {fs,dp}: filterValue
     */
    dpValues: DpValue[];
    /**
     * 塞数据入口 1/2: 加载数据并塞给部件
     */
    loadNSetData(param?: {
        dpValues?: DpValue[];
    }): void;
    /**
     * 给元部件重新设置数据结果，外部可调用此方法给部件设置数据。
     */
    setData(pDataWithDims: DataWithDims): void;
    handleDataError: () => void;
    handleClickStatusMore(): void;
    filterValues: any[];
    handleFilterChange(dpValues: DpValue[]): void;
    /**
     * 此 runtimeAgg 存储当前运行时用户选的、最新的 runtimeAgg。
     * extra 中的是存储在部件中的。
     * widget 不负责把 runtimeAgg 放到 extra 里，因为这里不确定是否需要持久化。
     */
    runtimeAgg: RuntimeAggOption;
    handleRuntimeAggChange(runtimeAgg: RuntimeAggOption): void;
    /** 当前写法需要保证 renderWidget() 已完成 */
    handleTitleBarInit(titleBar: TitleBarComponent): void;
    initRuntimeAgg(): void;
    /**
     * 初始化部件事件监听
     */
    private initWidgetEventListener;
    /**
     * eventPropName 是事件对应的实际属性名，
     * eventKey 配置在 link 里的事件名。
     * 一般他俩是一样的，后者可以不传。
     * 若是筛选部件，则两者不同，一个是 'filter'，一个是实际的事件（筛选）名称。
     */
    private initOneEventListener;
    setRuntimeAggDims(): void;
    amIFilterWidget(): boolean;
}
