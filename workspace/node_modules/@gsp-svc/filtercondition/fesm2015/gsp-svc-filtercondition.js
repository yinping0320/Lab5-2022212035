import { CommonModule } from '@angular/common';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { ButtonModule, DropDownButtonModule } from '@progress/kendo-angular-buttons';
import { InputsModule } from '@progress/kendo-angular-inputs';
import { FormsModule } from '@angular/forms';
import { PopupModule } from '@progress/kendo-angular-popup';
import { TreeTableModule } from '@farris/ui-treetable';
import { Pipe, Inject, LOCALE_ID, Component, ViewChild, Input, EventEmitter, Output, ViewEncapsulation, Injectable, Injector, ApplicationRef, ComponentFactoryResolver, NgModule } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { GSPElementDataType, GSPElementObjectType } from '@gsp-bef/gsp-cm-metadata';
import { ExpressionService, Schema, InjectedEntity, ExpressionModule } from '@gsp-svc/expression';
import { BsModalService, ModalModule } from '@farris/ui-modal';
import { FDropdownDirectiveTypeModule } from '@farris/ui-dropdown';
import { ComboListModule } from '@farris/ui-combo-list';
import { InputGroupModule } from '@farris/ui-input-group';
import { NotifyService, NotifyModule } from '@farris/ui-notify';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 表达式实体基础类
 */
class FilterExpressionBase {
}
/**
 * 过滤表达式复杂项
 * \@property relationOperator 关系操作符
 * \@property expressItems 表达式子项集合
 */
class FilterExpression extends FilterExpressionBase {
    constructor() {
        super(...arguments);
        this.expressItems = [];
    }
}
/**
 * 表达式属性项
 * \@property propertyName 属性名
 * \@property propertyDataType 属性数据类型
 * \@property operator 操作符
 * \@property expressType 表达式类型
 * \@property value 值
 * \@property parentItem 父项
 */
class ExpressionItem extends FilterExpressionBase {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ExpressTypeEnum = {
    Value: 0,
    Expression: 1,
};
ExpressTypeEnum[ExpressTypeEnum.Value] = 'Value';
ExpressTypeEnum[ExpressTypeEnum.Expression] = 'Expression';
/** @enum {number} */
const RelationTypeEnum = {
    And: 0,
    Or: 1,
    AddProperty: 2,
    AddRelation: 3,
};
RelationTypeEnum[RelationTypeEnum.And] = 'And';
RelationTypeEnum[RelationTypeEnum.Or] = 'Or';
RelationTypeEnum[RelationTypeEnum.AddProperty] = 'AddProperty';
RelationTypeEnum[RelationTypeEnum.AddRelation] = 'AddRelation';
/** @enum {number} */
const CompareTypeEnum = {
    GreaterThan: 0,
    GreaterThanOrEqual: 1,
    LessThan: 2,
    LessThanOrEqual: 3,
    Equal: 4,
    NotEqual: 5,
    Contains: 6,
    NotContains: 7,
    StartsWith: 8,
    NotStartsWith: 9,
    EndsWith: 10,
    NotEndsWith: 11,
    IsNull: 12,
    IsNotNull: 13,
    In: 14,
    NotIn: 15,
};
CompareTypeEnum[CompareTypeEnum.GreaterThan] = 'GreaterThan';
CompareTypeEnum[CompareTypeEnum.GreaterThanOrEqual] = 'GreaterThanOrEqual';
CompareTypeEnum[CompareTypeEnum.LessThan] = 'LessThan';
CompareTypeEnum[CompareTypeEnum.LessThanOrEqual] = 'LessThanOrEqual';
CompareTypeEnum[CompareTypeEnum.Equal] = 'Equal';
CompareTypeEnum[CompareTypeEnum.NotEqual] = 'NotEqual';
CompareTypeEnum[CompareTypeEnum.Contains] = 'Contains';
CompareTypeEnum[CompareTypeEnum.NotContains] = 'NotContains';
CompareTypeEnum[CompareTypeEnum.StartsWith] = 'StartsWith';
CompareTypeEnum[CompareTypeEnum.NotStartsWith] = 'NotStartsWith';
CompareTypeEnum[CompareTypeEnum.EndsWith] = 'EndsWith';
CompareTypeEnum[CompareTypeEnum.NotEndsWith] = 'NotEndsWith';
CompareTypeEnum[CompareTypeEnum.IsNull] = 'IsNull';
CompareTypeEnum[CompareTypeEnum.IsNotNull] = 'IsNotNull';
CompareTypeEnum[CompareTypeEnum.In] = 'In';
CompareTypeEnum[CompareTypeEnum.NotIn] = 'NotIn';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 属性实体
 */
class PropertyEntity {
}
/** @enum {number} */
const PropertyDataType = {
    String: 0,
    Int16: 1,
    Int32: 2,
    Int64: 3,
    Decimal: 4,
    Double: 5,
    Byte: 6,
    Char: 7,
    Boolean: 8,
    DateTime: 9,
    Array: 10,
};
PropertyDataType[PropertyDataType.String] = 'String';
PropertyDataType[PropertyDataType.Int16] = 'Int16';
PropertyDataType[PropertyDataType.Int32] = 'Int32';
PropertyDataType[PropertyDataType.Int64] = 'Int64';
PropertyDataType[PropertyDataType.Decimal] = 'Decimal';
PropertyDataType[PropertyDataType.Double] = 'Double';
PropertyDataType[PropertyDataType.Byte] = 'Byte';
PropertyDataType[PropertyDataType.Char] = 'Char';
PropertyDataType[PropertyDataType.Boolean] = 'Boolean';
PropertyDataType[PropertyDataType.DateTime] = 'DateTime';
PropertyDataType[PropertyDataType.Array] = 'Array';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 注入实体信息
 * \@property name 注入对象在schema中的名称
 * \@property schemaName 注入对象所在schema
 * \@property injectedType 注入对象类型
 */
class FilterInjectedEntity {
}
/** @enum {number} */
const FilterInjectedType = {
    EntitySet: 0,
    EntityType: 1,
};
FilterInjectedType[FilterInjectedType.EntitySet] = 'EntitySet';
FilterInjectedType[FilterInjectedType.EntityType] = 'EntityType';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const Filter_Condition_LANG_RESOURCES = {
    "zh-CHS": {
        "Item": "选择项",
        "Operator": "操作符",
        "ExpressType": "值类型",
        "Value": "值",
        "Operation": "操作",
        "WindowTitle": "过滤条件表达式",
        "Confirm": "确定",
        "Reset": "重置",
        "Cancle": "取消",
        "Add": "添加",
        "Delete": "删除",
        "AddGroup": "添加条件分组",
        "AddItem": "添加条件",
        "PlaceHolder": "请输入值",
        "Expression": "表达式",
        "SelectItem": "请选择项目",
        "And": "并且",
        "Or": "或者",
        "SelectProperty": "选择属性",
        "GreaterThan": "大于",
        "GreaterThanOrEqual": "大于等于",
        "LessThan": "小于",
        "LessThanOrEqual": "小于等于",
        "Equal": "等于",
        "NotEqual": "不等于",
        "Contains": "包含",
        "NotContains": "不包含",
        "StartsWith": "开头是",
        "NotStartsWith": "不包含开头是",
        "EndsWith": "结尾是",
        "NotEndsWith": "不包含结尾是",
        "IsNull": "为空",
        "IsNotNull": "不为(空)",
        "In": "在",
        "NotIn": "不在",
        "Success": "表达式已生成！",
        "Warning_SelectRelation": "请选择关系值！",
        "Warning_ContainsFilters": "请保证关系中包含过滤项！",
        "Warning_ConditionsComplete": "请保证过滤条件完整！",
        "Warning_NumericMatch": "数值型字段不可填字符！",
    },
    "en": {
        "Item": "Item",
        "Operator": "Operator",
        "ExpressType": "ExpressType",
        "Value": "Value",
        "Operation": "Operation",
        "WindowTitle": "FilterCondition",
        "Confirm": "Confirm",
        "Reset": "Reset",
        "Cancle": "Cancle",
        "Add": "Add",
        "Delete": "Delete",
        "AddGroup": "AddGroup",
        "AddItem": "AddItem",
        "PlaceHolder": "Please Input Value",
        "Expression": "Expression",
        "SelectItem": "Please Select Item",
        "And": "And",
        "Or": "Or",
        "SelectProperty": "SelectProperty",
        "GreaterThan": "GreaterThan",
        "GreaterThanOrEqual": "GreaterThanOrEqual",
        "LessThan": "LessThan",
        "LessThanOrEqual": "LessThanOrEqual",
        "Equal": "Equal",
        "NotEqual": "NotEqual",
        "Contains": "Contains",
        "NotContains": "NotContains",
        "StartsWith": "StartsWith",
        "NotStartsWith": "NotStartsWith",
        "EndsWith": "EndsWith",
        "NotEndsWith": "NotEndsWith",
        "IsNull": "IsNull",
        "IsNotNull": "IsNotNull",
        "In": "In",
        "NotIn": "NotIn",
        "Success": "Expression Has Been Created！",
        "Warning_SelectRelation": "Please Select Relations!",
        "Warning_ContainsFilters": "Please ensure that the relationship contains filters!",
        "Warning_ConditionsComplete": "Please ensure that the filter conditions are complete!",
        "Warning_NumericMatch": "Numeric fields cannot be filled with characters",
    },
    "en-US": {
        "Item": "Item",
        "Operator": "Operator",
        "ExpressType": "ExpressType",
        "Value": "Value",
        "Operation": "Operation",
        "WindowTitle": "FilterCondition",
        "Confirm": "Confirm",
        "Reset": "Reset",
        "Cancle": "Cancle",
        "Add": "Add",
        "Delete": "Delete",
        "AddGroup": "AddGroup",
        "AddItem": "AddItem",
        "PlaceHolder": "Please Input Value",
        "Expression": "Expression",
        "SelectItem": "Please Select Item",
        "And": "And",
        "Or": "Or",
        "SelectProperty": "SelectProperty",
        "GreaterThan": "GreaterThan",
        "GreaterThanOrEqual": "GreaterThanOrEqual",
        "LessThan": "LessThan",
        "LessThanOrEqual": "LessThanOrEqual",
        "Equal": "Equal",
        "NotEqual": "NotEqual",
        "Contains": "Contains",
        "NotContains": "NotContains",
        "StartsWith": "StartsWith",
        "NotStartsWith": "NotStartsWith",
        "EndsWith": "EndsWith",
        "NotEndsWith": "NotEndsWith",
        "IsNull": "IsNull",
        "IsNotNull": "IsNotNull",
        "In": "In",
        "NotIn": "NotIn",
        "Success": "Expression has been created！",
        "Warning_SelectRelation": "Please Select Relations!",
        "Warning_ContainsFilters": "Please ensure that the relationship contains filters!",
        "Warning_ConditionsComplete": "Please ensure that the filter conditions are complete!",
        "Warning_NumericMatch": "Numeric fields cannot be filled with characters",
    },
    "zh-CHT": {
        "Item": "選擇項",
        "Operator": "操作符",
        "ExpressType": "值類型",
        "Value": "值",
        "Operation": "操作",
        "WindowTitle": "過濾條件錶達式",
        "Confirm": "確定",
        "Reset": "重置",
        "Cancle": "取消",
        "Add": "添加",
        "Delete": "刪除",
        "AddGroup": "添加條件分組",
        "AddItem": "添加條件",
        "PlaceHolder": "請輸入值",
        "Expression": "錶達式",
        "SelectItem": "請選擇項目",
        "And": "並且",
        "Or": "或者",
        "SelectProperty": "選擇屬性",
        "GreaterThan": "大於",
        "GreaterThanOrEqual": "大於等於",
        "LessThan": "小於",
        "LessThanOrEqual": "小於等於",
        "Equal": "等於",
        "NotEqual": "不等於",
        "Contains": "包含",
        "NotContains": "不包含",
        "StartsWith": "開頭是",
        "NotStartsWith": "不包含開頭是",
        "EndsWith": "結尾是",
        "NotEndsWith": "不包含結尾是",
        "IsNull": "為空",
        "IsNotNull": "不為空",
        "In": "在",
        "NotIn": "不在",
        "Success": "錶達式已生成！",
        "Warning_SelectRelation": "請選擇關係值！",
        "Warning_ContainsFilters": "請保證關係中包含過濾項！",
        "Warning_ConditionsComplete": "請保證過濾條件完整！",
        "Warning_NumericMatch": "數值型字段不可填字符！",
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FilterConditionLocalePipe {
    /**
     * @param {?} localeId
     */
    constructor(localeId) {
        this.defaultLang = "zh-CHS";
        localeId = localStorage.getItem('languageCode');
        this.langCode = localeId || this.defaultLang;
        this.lang = Filter_Condition_LANG_RESOURCES[this.langCode] || Filter_Condition_LANG_RESOURCES[this.defaultLang];
    }
    /**
     * @param {?} name
     * @return {?}
     */
    transform(name) {
        return this.lang[name] || name;
    }
}
FilterConditionLocalePipe.decorators = [
    { type: Pipe, args: [{ name: 'locale' },] }
];
/** @nocollapse */
FilterConditionLocalePipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 过滤条件弹出框逻辑类
 */
class FilterConditionComponent {
    /**
     * @param {?} expr
     * @param {?} notifyservice
     * @param {?} localeId
     */
    constructor(expr, notifyservice, localeId) {
        this.expr = expr;
        this.notifyservice = notifyservice;
        //关闭窗口事件
        this.closed = new EventEmitter();
        this.result = new EventEmitter();
        //预置计算表达式上下文实体
        this.contextEntity = [];
        //预置计算默认表达式显示
        this.expressionText = "";
        //预置计算表达式中的schema
        this.expressionSchema = [];
        //预置计算表达式中的注入实体
        this.expressionInjectedEntities = [];
        //预置计算表达式cdt集
        this.expressionCDT = [];
        //预置属性列表
        this.propertyList = [];
        //预置过滤表达式串
        this.filterExpressionString = null;
        //预置过滤表达式schema
        this.schemaMap = new Map();
        //==============新加入的newSchemaMap=======================
        //预置过滤表达式newSchema
        this.newSchemaMap = new Map();
        //========================================================
        //预置过滤表达式注入实体
        this.injectedEntity = new FilterInjectedEntity();
        //预置计算表达式弹出框宽度
        this.exprWinWidth = 850;
        this.popupSettings = {
            popupClass: "lpopup"
        };
        this.operatorView = [];
        //操作比较符集
        this.operators = [];
        this.stringOperators = [];
        this.NumberOperators = [];
        //关系集
        this.relations = [];
        //表达式类型集
        this.expressTypes = [];
        //判断是否保存编辑后的过滤表达式
        this.isEdited = false;
        this.displayPopup = false;
        this.groupIcon = '<span class="f-icon f-icon-windows"></span>';
        this.treeData = [];
        //消息提示
        this.notifies = {};
        localeId = localStorage.getItem('languageCode');
        this.localePipe = new FilterConditionLocalePipe(localeId);
    }
    //初始化，复制treeData值,treeDataTemp用于转换为FilterExpression实体
    /**
     * @return {?}
     */
    ngOnInit() {
        //并且树形表绑定的显示的列 
        this.cols = [
            { field: 'item', title: this.localePipe.transform("Item"), width: 271 },
            { field: 'operator', title: this.localePipe.transform("Operator"), width: 191 },
            { field: 'expressType', title: this.localePipe.transform("ExpressType"), width: 180 },
            { field: 'value', title: this.localePipe.transform("Value"), width: 214 },
            { field: 'operation', title: this.localePipe.transform("Operation"), width: 130 }
        ];
        if (!(this.filterExpressionString) || this.filterExpressionString == "") {
            this.treeData = [
                {
                    data: {
                        "id": 1,
                        //树形结构中每个节点的id
                        "item": this.localePipe.transform("And"),
                        //属性项
                        "propertyDataType": null,
                        //属性数据类型
                        "operator": null,
                        //操作比较符
                        "expressType": null,
                        //表达式类型
                        "value": null,
                        //值
                        "displaySelect": false,
                        //选择项显示
                        "displayOperator": false,
                        //操作符项显示
                        "displayExpressType": false,
                        //表达式类型显示
                        "displayValue": false,
                        //值显示
                        "parentItem": null //父子项 
                    },
                    children: [],
                    //子节点集合
                    expanded: true //是否展开
                }
            ];
        }
        else {
            this.filterExpressionPre = JSON.parse(this.filterExpressionString);
            this.treeData.push(this.unConvert(this.filterExpressionPre));
            this.treeData[0].data.id = 1;
        }
        this.treeDataTemp = this.treeData;
        this.defaultSelectItem = this.localePipe.transform("SelectItem");
        this.defaultExpressTypeText = this.localePipe.transform("Value");
        this.defaultSelectGroup = this.localePipe.transform("And");
        this.defaultOperatorText = this.localePipe.transform("GreaterThan");
        this.notifies = {
            1: { type: 'success', msg: this.localePipe.transform("Success") },
            2: { type: 'warning', msg: this.localePipe.transform("Warning_SelectRelation") },
            3: { type: 'warning', msg: this.localePipe.transform("Warning_ContainsFilters") },
            4: { type: 'warning', msg: this.localePipe.transform("Warning_ConditionsComplete") },
            5: { type: 'warning', msg: this.localePipe.transform("Warning_NumericMatch") }
        };
        this.expressTypes = [
            { id: this.localePipe.transform("Value") },
            { id: this.localePipe.transform("Expression") }
        ];
        this.relations = [
            { id: this.localePipe.transform("And") },
            { id: this.localePipe.transform("Or") },
        ];
        this.operators = [
            { id: this.localePipe.transform("GreaterThan") },
            { id: this.localePipe.transform("GreaterThanOrEqual") },
            { id: this.localePipe.transform("LessThan") },
            { id: this.localePipe.transform("LessThanOrEqual") },
            { id: this.localePipe.transform("Equal") },
            { id: this.localePipe.transform("NotEqual") },
            { id: this.localePipe.transform("Contains") },
            { id: this.localePipe.transform("NotContains") },
            { id: this.localePipe.transform("StartsWith") },
            { id: this.localePipe.transform("EndsWith") },
            { id: this.localePipe.transform("NotStartsWith") },
            { id: this.localePipe.transform("NotEndsWith") },
            { id: this.localePipe.transform("IsNull") },
            { id: this.localePipe.transform("IsNotNull") },
            { id: this.localePipe.transform("In") },
            { id: this.localePipe.transform("NotIn") },
        ];
        this.NumberOperators = [
            { id: this.localePipe.transform("GreaterThan") },
            { id: this.localePipe.transform("GreaterThanOrEqual") },
            { id: this.localePipe.transform("LessThan") },
            { id: this.localePipe.transform("LessThanOrEqual") },
            { id: this.localePipe.transform("Equal") },
            { id: this.localePipe.transform("NotEqual") },
            { id: this.localePipe.transform("IsNull") },
            { id: this.localePipe.transform("IsNotNull") },
        ];
        this.stringOperators = [
            { id: this.localePipe.transform("Equal") },
            { id: this.localePipe.transform("NotEqual") },
            { id: this.localePipe.transform("Contains") },
            { id: this.localePipe.transform("NotContains") },
            { id: this.localePipe.transform("StartsWith") },
            { id: this.localePipe.transform("EndsWith") },
            { id: this.localePipe.transform("NotStartsWith") },
            { id: this.localePipe.transform("NotEndsWith") },
            { id: this.localePipe.transform("IsNull") },
            { id: this.localePipe.transform("IsNotNull") },
        ];
    }
    /**
     * 树形表中节点选择触发函数
     * @param {?} $event 所选节点信息
     * @return {?}
     */
    nodeSelected($event) {
        //隐藏掉所有的节点选择编辑框，包括子节点的
        this.hideNodeEditor(this.treeData);
        //将所选节点比较项、表达式类型项、值编辑框显示，并将所选对应数据赋给默认项进行显示 
        this.defaultOperatorText = $event.node.data.operator;
        this.defaultExpressTypeText = $event.node.data.expressType;
        if ($event.node.data.item == this.localePipe.transform("And") || $event.node.data.item == this.localePipe.transform("Or")) {
            this.defaultSelectGroup = $event.node.data.item;
        }
        else if ($event.node.data.item !== this.localePipe.transform("SelectProperty")) {
            /** @type {?} */
            let properties = this.propertyList.filter((/**
             * @param {?} x
             * @return {?}
             */
            x => x.text == $event.node.data.item));
            this.defaultSelectItem = properties[0].value;
            if (properties[0].propertyDataType == PropertyDataType.String) {
                this.operatorView = this.stringOperators;
            }
            else if (properties[0].propertyDataType == PropertyDataType.Int16 ||
                properties[0].propertyDataType == PropertyDataType.Int32 ||
                properties[0].propertyDataType == PropertyDataType.Int64 ||
                properties[0].propertyDataType == PropertyDataType.Decimal ||
                properties[0].propertyDataType == PropertyDataType.Double) {
                this.operatorView = this.NumberOperators;
            }
            else
                this.operatorView = this.operators;
        }
        $event.node.data.displayOperator = true;
        $event.node.data.displayExpressType = true;
        $event.node.data.displayValue = true;
        $event.node.data.displaySelect = true;
    }
    ;
    /**
     * 隐藏掉所有的节点选择编辑框，包括子节点的
     * @param {?} treeNodes 树形表绑定结构
     * @return {?}
     */
    hideNodeEditor(treeNodes) {
        treeNodes.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            element.data.displayOperator = false;
            element.data.displayExpressType = false;
            element.data.displayValue = false;
            element.data.displaySelect = false;
            //若有子节点，则将其子节点的编辑选择框隐藏
            if ((element.children) && element.children.length != 0) {
                this.hideNodeEditor(element.children);
            }
        }));
    }
    ;
    /**
     *
     * 选择逻辑集时
     * @param {?} $event
     * @return {?}
     */
    selectGroup($event) {
        this.propertyNodeOperate($event, this.treeData, 0 /* Group */);
    }
    /**
     *
     * 选择项时
     * @param {?} $event
     * @return {?}
     */
    selectItem($event) {
        this.propertyNodeOperate($event, this.treeData, 1 /* Item */);
    }
    /**
     * 选择比较操作符时
     * @param {?} $event 比较操作项信息
     * @return {?}
     */
    selectOperator($event) {
        this.propertyNodeOperate($event, this.treeData, 2 /* Operation */);
    }
    ;
    /**
     * 选择值类型时
     * @param {?} $event 值类型项信息
     * @return {?}
     */
    selectExpressType($event) {
        this.propertyNodeOperate($event, this.treeData, 3 /* Valuetype */);
    }
    ;
    /**
     * 选择结束后隐藏该字段选择框
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} fieldType 所选字段
     * @return {?}
     */
    hideFieldEditor(treeNodes, fieldType) {
        //找到所操作的节点，根据所选择的字段将对应选择编辑框隐藏
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (this.tt.isSelected(treeNode)) {
                switch (fieldType) {
                    case 1 /* Item */:
                        treeNode.data.displaySelect = false;
                        break;
                    case 2 /* Operation */:
                        treeNode.data.displayOperator = false;
                        break;
                    case 3 /* Valuetype */:
                        treeNode.data.displayExpressType = false;
                        break;
                }
                return;
            }
            //若未找到所选节点，则找其子节点
            else if ((treeNode.children) && treeNode.children.length != 0) {
                this.hideFieldEditor(treeNode.children, fieldType);
            }
        }));
    }
    /**
     * 打开计算表达式编辑器
     * @return {?}
     */
    openExpressEditor() {
        /** @type {?} */
        let that = this;
        //预置计算表达式弹出框宽度
        //this.expr.addWindowWidth(this.exprWinWidth);
        //添加预置上下文变量
        if (this.contextEntity && this.contextEntity.length != 0) {
            this.contextEntity.forEach((/**
             * @param {?} element
             * @return {?}
             */
            element => {
                this.expr.addContext(element);
            }));
        }
        //添加预置表达式文本
        /** @type {?} */
        let selectNode = this.isSelected(this.treeData);
        if ((selectNode) && (selectNode.data.value != "") && (selectNode.data.value != null)) {
            this.expr.addExpressionText(selectNode.data.value);
        }
        else
            this.expr.addExpressionText(this.expressionText);
        //添加注入实体
        this.expressionInjectedEntities.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            this.expr.addInjectedEntity(element.name, element.schemaName, element.injectedName, element.injectedType);
        }));
        //添加schema
        this.expressionSchema.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            this.expr.addSchema(element.name, element.schema);
        }));
        //添加cdt
        this.expr.addCDT(this.expressionCDT);
        //打开表达式编辑器并返回编辑结果
        this.expr.buildExpression().then((/**
         * @param {?} info
         * @return {?}
         */
        info => {
            /** @type {?} */
            let expressInfo = info;
            this.displayExpressResult(that.treeData, expressInfo);
        }));
    }
    /**
     * 选中节点选择
     * @param {?} treeNodes 关系组
     * @return {?}
     */
    isSelected(treeNodes) {
        /** @type {?} */
        let treeNode;
        for (var i = 0; i < treeNodes.length; i++) {
            if (this.tt.isSelected(treeNodes[i])) {
                treeNode = treeNodes[i];
                break;
            }
            //若在该层节点中未找到所选节点，则找其子节点
            else if ((treeNodes[i].children) && treeNodes[i].children.length != 0) {
                treeNode = this.isSelected(treeNodes[i].children);
                if ((treeNode))
                    break;
            }
        }
        return treeNode;
    }
    /**
     * 将计算表达式结果展示到对应节点
     * @param {?} treeNodes 树表绑定结构
     * @param {?} expressInfo 计算表达式得到结果
     * @return {?}
     */
    displayExpressResult(treeNodes, expressInfo) {
        //找到所选节点实体，并将计算表达式所得结果赋给对应属性进行显示
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (this.tt.isSelected(treeNode)) {
                treeNode.data.value = expressInfo;
                return;
            }
            //若在该层节点中未找到所选节点，则找其子节点
            else if ((treeNode.children) && treeNode.children.length != 0) {
                this.displayExpressResult(treeNode.children, expressInfo);
            }
            //若仍未找到，则不进行任何操作
        }));
    }
    /**
     * 关系选择按钮选择事件
     * @param {?} $event 选择按钮所选信息
     * @return {?}
     */
    itemClick($event) {
        //若选择添加关系
        if ($event.value == RelationTypeEnum.AddRelation) {
            this.addNode(this.treeData, this.localePipe.transform("And"), null, null);
        }
        //若选择添加属性
        else if ($event.value == RelationTypeEnum.AddProperty) {
            this.addNode(this.treeData, this.localePipe.transform("SelectProperty"), this.localePipe.transform("Equal"), this.localePipe.transform("Value"));
        }
        else
            this.propertyNodeOperate($event, this.treeData, 1 /* Item */);
    }
    /**
     * 选择属性节点操作
     * 对新添加的属性节点进行逻辑处理
     * @param {?} event
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} fieldType 节点类型
     * @return {?}
     */
    propertyNodeOperate(event, treeNodes, fieldType) {
        treeNodes.forEach((/**
         * @param {?} treenode
         * @return {?}
         */
        treenode => {
            if (this.tt.isSelected(treenode)) {
                //对所选节点进行赋值操作
                switch (fieldType) {
                    case 0 /* Group */:
                        {
                            treenode.data.item = event.data.id;
                            this.defaultSelectGroup = event.data.id;
                        }
                        break;
                    case 1 /* Item */:
                        {
                            treenode.data.item = event.data.text;
                            this.defaultSelectItem = event.data.value;
                            treenode.data.parentItem = event.data.parentItem;
                            treenode.data.propertyDataType = event.data.propertyDataType;
                            if (treenode.data.propertyDataType == PropertyDataType.String) {
                                this.operatorView = this.stringOperators;
                            }
                            else if (treenode.data.propertyDataType == PropertyDataType.Int16 ||
                                treenode.data.propertyDataType == PropertyDataType.Int32 ||
                                treenode.data.propertyDataType == PropertyDataType.Int64 ||
                                treenode.data.propertyDataType == PropertyDataType.Decimal ||
                                treenode.data.propertyDataType == PropertyDataType.Double) {
                                this.operatorView = this.NumberOperators;
                            }
                            else
                                this.operatorView = this.operators;
                        }
                        break;
                    case 2 /* Operation */:
                        {
                            treenode.data.operator = event.data.id;
                            this.defaultOperatorText = event.data.id;
                        }
                        break;
                    case 3 /* Valuetype */:
                        {
                            treenode.data.expressType = event.data.id;
                            this.defaultExpressTypeText = event.data.id;
                        }
                        break;
                }
                return;
            }
            //否则对其子节点进行赋值操作
            else if ((treenode.children) && treenode.children.length != 0) {
                this.propertyNodeOperate(event, treenode.children, fieldType);
            }
        }));
    }
    /**
     * 根据所选为关系或者属性对新节点进行初始化
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} defaultString 新节点显示默认值
     * @param {?} defaultOperator
     * @param {?} defalutExpressType
     * @return {?}
     */
    addNode(treeNodes, defaultString, defaultOperator, defalutExpressType) {
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (this.tt.isSelected(treeNode)) {
                //若关系值为空
                if (!(treeNode.data.item)) {
                    this.notifyservice[this.notifies['2'].type]({
                        msg: this.notifies['2'].msg
                    });
                    return;
                }
                //若为所选的关系节点，则在其子项里添加新子节点
                /** @type {?} */
                let newNode = {
                    data: {
                        "item": defaultString,
                        "propertyDataType": null,
                        //属性数据类型
                        "operator": defaultOperator,
                        "expressType": defalutExpressType,
                        "value": null,
                        "id": Math.random(),
                        "parentItem": null
                    },
                    parent: treeNode,
                    children: [],
                    expanded: true
                };
                //向该所选节点的子项添加新节点
                treeNode.children.push(newNode);
                return;
            }
            //若未找到所选节点，且该节点子项不为空，则在其子项中查找所选节点
            else if ((treeNode.children) && treeNode.children.length != 0) {
                this.addNode(treeNode.children, defaultString, defaultOperator, defalutExpressType);
            }
        }));
        this.tt.updateSerializedValue();
    }
    /**
     * 删除节点
     * @param {?} $event
     * @return {?}
     */
    deleteNode($event) {
        this.onDelete(this.treeData, $event);
    }
    /**
     * 删除节点具体实现类
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} id
     * @return {?}
     */
    onDelete(treeNodes, id) {
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (treeNode.data.id == id) {
                if (treeNode.data.id == 1) {
                    this.treeData = [
                        {
                            data: {
                                "id": 1,
                                //树形结构中每个节点的id
                                "propertyDataType": null,
                                //属性数据类型
                                "item": this.localePipe.transform("And"),
                                //属性项
                                "operator": null,
                                //操作比较符
                                "expressType": null,
                                //表达式类型
                                "value": null,
                                //值
                                "displaySelect": false,
                                //选择项显示
                                "displayOperator": false,
                                //操作符项显示
                                "displayExpressType": false,
                                //表达式类型显示
                                "displayValue": false,
                                //值显示
                                "parentItem": null //父项
                            },
                            children: [],
                            //子节点集合
                            expanded: true //是否展开
                        }
                    ];
                    return;
                }
                //所选节点所在数
                /** @type {?} */
                let index = treeNodes.indexOf(treeNode);
                //将所选节点剔除
                treeNodes.splice(index, 1);
            }
            else if ((treeNode.children) && treeNode.children.length != 0) {
                treeNode.children = this.onDelete(treeNode.children, id);
            }
        }));
        this.tt.updateSerializedValue();
        return treeNodes;
    }
    /**
     * 确定
     * 生成过滤表达式
     * @return {?}
     */
    onConfirm() {
        this.treeDataTemp = this.treeData;
        /** @type {?} */
        let isNull = true;
        /** @type {?} */
        let isMatch = true;
        if (this.checkNull(this.treeDataTemp[0].children, isNull) && this.checkMatch(this.treeDataTemp[0].children, isMatch)) {
            this.filterExpression = new FilterExpression();
            //根据树形数据结构转化为过滤表达式实体
            this.convert(this.filterExpression, this.treeDataTemp[0]);
            this.isEdited = true;
            this.notifyservice[this.notifies['1'].type]({
                msg: this.notifies['1'].msg
            });
            this.close();
            this.closed.emit("close");
        }
    }
    //递归检查整个过滤表达式是否有漏填的项
    /**
     * @param {?} treeNodes
     * @param {?} isNull
     * @return {?}
     */
    checkNull(treeNodes, isNull) {
        for (var i = 0; i < treeNodes.length; i++) {
            if (treeNodes[i].data.item == this.localePipe.transform("And") || treeNodes[i].data.item == this.localePipe.transform("Or")) {
                if (!(treeNodes[i].children) || treeNodes[i].children.length == 0) {
                    this.notifyservice[this.notifies['3'].type]({
                        msg: this.notifies['3'].msg
                    });
                    isNull = false;
                    break;
                }
                else if (!this.checkNull(treeNodes[i].children, isNull)) {
                    isNull = false;
                    break;
                }
            }
            else {
                if (!(treeNodes[i].data.item) || treeNodes[i].data.item == this.localePipe.transform("SelectProperty")
                    || !(treeNodes[i].data.operator) || !(treeNodes[i].data.expressType)
                    || treeNodes[i].data.value == null || treeNodes[i].data.value == undefined) {
                    this.notifyservice[this.notifies['4'].type]({
                        msg: this.notifies['4'].msg
                    });
                    isNull = false;
                    break;
                }
            }
        }
        return isNull;
    }
    /**
     * 重置
     * 重置为初始状态
     * @return {?}
     */
    onCancel() {
        this.isEdited = false;
        if (this.filterExpressionString == null || this.filterExpressionString == "") {
            this.treeData = [
                {
                    data: {
                        "id": 1,
                        //树形结构中每个节点的id
                        "item": null,
                        //属性项
                        "propertyDataType": null,
                        //属性数据类型
                        "operator": null,
                        //操作比较符
                        "expressType": null,
                        //表达式类型
                        "value": null,
                        //值
                        "displaySelect": false,
                        //选择项显示
                        "displayOperator": false,
                        //操作符项显示
                        "displayExpressType": false,
                        //表达式类型显示
                        "displayValue": false,
                        //值显示
                        "parentItem": null //父项
                    },
                    children: [],
                    //子节点集合
                    expanded: true //是否展开
                }
            ];
        }
        else {
            this.filterExpressionPre = JSON.parse(this.filterExpressionString);
            this.treeData = [];
            this.treeData.push(this.unConvert(this.filterExpressionPre));
            this.treeData[0].data.id = 1;
        }
    }
    /**
     * 取消
     * @return {?}
     */
    cancle() {
        this.closed.emit("close");
    }
    /**
     * 关闭窗口
     * @return {?}
     */
    close() {
        if (this.isEdited == true) {
            //若只包含关系项则返回空
            if (this.filterExpression.expressItems.length == 0)
                this.result.next(null);
            //若最后一次点了确定，则将过滤表达式JSON序列化输出
            else
                this.result.next(JSON.stringify(this.filterExpression));
        }
        //若未点确定，默认无任何编辑文本，则输出空串
        else
            this.result.next(this.filterExpressionString);
    }
    /**
     * 将treeData转化为filetrExpression实体
     * @param {?} filterExpression 过滤表达式实体
     * @param {?} treeNode 最外层的treeNode
     * @return {?}
     */
    convert(filterExpression, treeNode) {
        //得到最外层的关系符
        filterExpression.relationOperator = this.typeMatch(treeNode.data.item);
        //若其子项不为空
        if (treeNode.children.length != 0) {
            //对其每一个子项进行转化操作
            treeNode.children.forEach((/**
             * @param {?} treeNodeItem
             * @return {?}
             */
            treeNodeItem => {
                //若子项为并且、或者，则新建复杂过滤表达式
                if (this.typeMatch(treeNodeItem.data.item) == RelationTypeEnum.And ||
                    this.typeMatch(treeNodeItem.data.item) == RelationTypeEnum.Or) {
                    /** @type {?} */
                    let filterExpressionItem = new FilterExpression();
                    filterExpression.expressItems.push(this.convert(filterExpressionItem, treeNodeItem));
                }
                //若子项为属性表达式
                else {
                    /** @type {?} */
                    let filterItem = new ExpressionItem();
                    //根据属性名展示值找到其在预置列表中的语义化值，将语义化值赋给实体保存
                    /** @type {?} */
                    let properties = this.propertyList.filter((/**
                     * @param {?} x
                     * @return {?}
                     */
                    x => x.text == treeNodeItem.data.item));
                    filterItem.propertyName = properties[0].value;
                    filterItem.propertyDataType = treeNodeItem.data.propertyDataType;
                    filterItem.operator = this.typeMatch(treeNodeItem.data.operator);
                    filterItem.expressType = this.typeMatch(treeNodeItem.data.expressType);
                    filterItem.value = treeNodeItem.data.value;
                    filterItem.parentItem = treeNodeItem.data.parentItem;
                    //若为数值型比较，则将value值强制转换为数字
                    if (filterItem.expressType == ExpressTypeEnum.Value &&
                        (filterItem.operator == CompareTypeEnum.GreaterThan
                            || filterItem.operator == CompareTypeEnum.GreaterThanOrEqual
                            || filterItem.operator == CompareTypeEnum.LessThan
                            || filterItem.operator == CompareTypeEnum.LessThanOrEqual)) {
                        filterItem.value = Number(treeNodeItem.data.value);
                    }
                    if (filterItem.expressType == ExpressTypeEnum.Value &&
                        (filterItem.operator == CompareTypeEnum.Equal
                            || filterItem.operator == CompareTypeEnum.NotEqual)) {
                        if (filterItem.propertyDataType == PropertyDataType.Decimal
                            || filterItem.propertyDataType == PropertyDataType.Double
                            || filterItem.propertyDataType == PropertyDataType.Int16
                            || filterItem.propertyDataType == PropertyDataType.Int32
                            || filterItem.propertyDataType == PropertyDataType.Int64) {
                            filterItem.value = Number(treeNodeItem.data.value);
                        }
                    }
                    //将子项放入父项的字段中
                    filterExpression.expressItems.push(filterItem);
                }
            }));
        }
        return filterExpression;
    }
    /**
     * filetrExpression反转化为TreeNode
     * @param {?} filterExpress 待转化的filetrExpression实体
     * @return {?}
     */
    unConvert(filterExpress) {
        /** @type {?} */
        let treeData = {
            data: {
                "id": Math.random(),
                //树形结构中每个节点的id
                "item": this.relationTypeReverseMatch(filterExpress.relationOperator),
                //属性项
                "propertyDataType": null,
                //属性数据类型
                "operator": null,
                //操作比较符
                "expressType": null,
                //表达式类型
                "value": null,
                //值
                "displaySelect": false,
                //选择项显示
                "displayOperator": false,
                //操作符项显示
                "displayExpressType": false,
                //表达式类型显示
                "displayValue": false,
                //值显示
                "parentItem": null //父项
            },
            children: [],
            //子节点集合
            expanded: true //是否展开
        };
        //对于每一个子项
        filterExpress.expressItems.forEach((/**
         * @param {?} expressItem
         * @return {?}
         */
        expressItem => {
            /** @type {?} */
            let filterExpressItem = (/** @type {?} */ (expressItem));
            //若子项为FilterExpression类型，赋值
            if ((filterExpressItem.relationOperator == RelationTypeEnum.And || filterExpressItem.relationOperator == RelationTypeEnum.Or)) {
                /** @type {?} */
                let treeDataChild = this.unConvert(filterExpressItem);
                treeDataChild.data.parent = treeData; //添加父节点
                treeData.children.push(treeDataChild);
            }
            else //若子项为ExpressionItem类型，赋值
             {
                /** @type {?} */
                let expressionItem = (/** @type {?} */ (expressItem));
                /** @type {?} */
                let properties = this.propertyList.filter((/**
                 * @param {?} x
                 * @return {?}
                 */
                x => x.value == expressionItem.propertyName));
                /** @type {?} */
                let treeDataChild = {
                    data: {
                        "id": Math.random(),
                        //树形结构中每个节点的id
                        "item": properties[0].text,
                        //属性项
                        "propertyDataType": expressionItem.propertyDataType,
                        //属性数据类型
                        "operator": this.operatorReverseMatch(expressionItem.operator),
                        //操作比较符
                        "expressType": this.expressTypeReverseMatch(expressionItem.expressType),
                        //表达式类型
                        "value": expressionItem.value,
                        //值
                        "parentItem": expressionItem.parentItem //父项
                    },
                    parent: treeData,
                    //添加父节点
                    children: [],
                    //子节点集合
                    expanded: true //是否展开
                };
                treeData.children.push(treeDataChild);
            }
        }));
        return treeData;
    }
    /**
     *
     * 添加条件项
     * @return {?}
     */
    addItem() {
        this.defaultSelectItem = this.localePipe.transform("SelectItem");
        this.hideNodeEditor(this.treeData);
        this.addNode(this.treeData, this.localePipe.transform("SelectProperty"), this.localePipe.transform("Equal"), this.localePipe.transform("Value"));
    }
    /**
     *
     * 添加条件组
     * @return {?}
     */
    addGroup() {
        this.addNode(this.treeData, this.localePipe.transform("And"), null, null);
    }
    /**
     * 类型信息匹配
     * @param {?} type 类型
     * @return {?}
     */
    typeMatch(type) {
        switch (type) {
            case this.localePipe.transform("And"): return RelationTypeEnum.And;
            case this.localePipe.transform("Or"): return RelationTypeEnum.Or;
            case this.localePipe.transform("GreaterThan"): return CompareTypeEnum.GreaterThan;
            case this.localePipe.transform("GreaterThanOrEqual"): return CompareTypeEnum.GreaterThanOrEqual;
            case this.localePipe.transform("LessThan"): return CompareTypeEnum.LessThan;
            case this.localePipe.transform("LessThanOrEqual"): return CompareTypeEnum.LessThanOrEqual;
            case this.localePipe.transform("Equal"): return CompareTypeEnum.Equal;
            case this.localePipe.transform("NotEqual"): return CompareTypeEnum.NotEqual;
            case this.localePipe.transform("Contains"): return CompareTypeEnum.Contains;
            case this.localePipe.transform("NotContains"): return CompareTypeEnum.NotContains;
            case this.localePipe.transform("StartsWith"): return CompareTypeEnum.StartsWith;
            case this.localePipe.transform("EndsWith"): return CompareTypeEnum.EndsWith;
            case this.localePipe.transform("NotStartsWith"): return CompareTypeEnum.NotStartsWith;
            case this.localePipe.transform("NotEndsWith"): return CompareTypeEnum.NotEndsWith;
            case this.localePipe.transform("IsNull"): return CompareTypeEnum.IsNull;
            case this.localePipe.transform("IsNotNull"): return CompareTypeEnum.IsNotNull;
            case this.localePipe.transform("In"): return CompareTypeEnum.In;
            case this.localePipe.transform("NotIn"): return CompareTypeEnum.NotIn;
            case this.localePipe.transform("Value"): return ExpressTypeEnum.Value;
            case this.localePipe.transform("Expression"): return ExpressTypeEnum.Expression;
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    relationTypeReverseMatch(type) {
        switch (type) {
            case RelationTypeEnum.And: return this.localePipe.transform("And");
            case RelationTypeEnum.Or: return this.localePipe.transform("Or");
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    operatorReverseMatch(type) {
        switch (type) {
            case CompareTypeEnum.GreaterThan: return this.localePipe.transform("GreaterThan");
            case CompareTypeEnum.GreaterThanOrEqual: return this.localePipe.transform("GreaterThanOrEqual");
            case CompareTypeEnum.LessThan: return this.localePipe.transform("LessThan");
            case CompareTypeEnum.LessThanOrEqual: return this.localePipe.transform("LessThanOrEqual");
            case CompareTypeEnum.Equal: return this.localePipe.transform("Equal");
            case CompareTypeEnum.NotEqual: return this.localePipe.transform("NotEqual");
            case CompareTypeEnum.Contains: return this.localePipe.transform("Contains");
            case CompareTypeEnum.NotContains: return this.localePipe.transform("NotContains");
            case CompareTypeEnum.StartsWith: return this.localePipe.transform("StartsWith");
            case CompareTypeEnum.EndsWith: return this.localePipe.transform("EndsWith");
            case CompareTypeEnum.NotStartsWith: return this.localePipe.transform("NotStartsWith");
            case CompareTypeEnum.NotEndsWith: return this.localePipe.transform("NotEndsWith");
            case CompareTypeEnum.IsNull: return this.localePipe.transform("IsNull");
            case CompareTypeEnum.IsNotNull: return this.localePipe.transform("IsNotNull");
            case CompareTypeEnum.In: return this.localePipe.transform("In");
            case CompareTypeEnum.NotIn: return this.localePipe.transform("NotIn");
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    expressTypeReverseMatch(type) {
        switch (type) {
            case ExpressTypeEnum.Value: return this.localePipe.transform("Value");
            case ExpressTypeEnum.Expression: return this.localePipe.transform("Expression");
        }
    }
    /**
     * @return {?}
     */
    onfocus() {
        this.displayPopup = true;
    }
    /**
     * @return {?}
     */
    onblur() {
        this.displayPopup = false;
    }
    /**
     * @param {?} treeNodes
     * @param {?} isMatch
     * @return {?}
     */
    checkMatch(treeNodes, isMatch) {
        for (var i = 0; i < treeNodes.length; i++) {
            if (treeNodes[i].data.item != this.localePipe.transform("And") && treeNodes[i].data.item != this.localePipe.transform("Or")) {
                if (treeNodes[i].data.expressType == this.localePipe.transform("Value")) {
                    if ((treeNodes[i].data.propertyDataType == PropertyDataType.Int16 || treeNodes[i].data.propertyDataType == PropertyDataType.Int32 || treeNodes[i].data.propertyDataType == PropertyDataType.Int64) && isNaN(treeNodes[i].data.value)) {
                        this.notifyservice[this.notifies['5'].type]({
                            msg: this.notifies['5'].msg
                        });
                        isMatch = false;
                        break;
                    }
                }
            }
            else
                isMatch = this.checkMatch(treeNodes[i].children, isMatch);
        }
        return isMatch;
    }
}
FilterConditionComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-filter-condition',
                template: "<div class=\"filter \">   \r\n    <farris-treetable #tt\r\n    class=\"farristreetable\"\r\n    [data]=\"treeData\" \r\n    [columns]=\"cols\" \r\n    [idField]=\"'id'\" \r\n    [showIcon]=\"false\" \r\n    [resizableColumns]=\"true\"\r\n    (nodeSelected)=\"nodeSelected($event)\" \r\n    [fitColumns]=\"true\" \r\n    [showFilterBar]=\"false\"\r\n    [showHeader]=\"true\"\r\n    [enableFindText]=\"true\"\r\n    [fit]=\"true\"\r\n    [fixedHeader]=\"true\"\r\n    [showBorder]=\"false\"\r\n    >\r\n      <ng-template farrisTemplate=\"body\" let-rowNode let-rowData=\"rowData\" let-columns=\"columns\">\r\n        <tr [selectRow]=\"rowNode\" [dblclick]=\"true\">\r\n          <td *ngFor=\"let col of columns; let i = index\"\r\n          [ngStyle]=\"{'text-align':col.title=='' ?'center':'left'}\">\r\n            <farris-treeTableToggler [rowNode]=\"rowNode\" *ngIf=\"i == 0\"></farris-treeTableToggler>\r\n            <ng-container *ngIf=\"i==0\">\r\n                <span style=\"display: inline-block;\" id=\"groupAnd\" *ngIf=\"rowData['item']==this.localePipe.transform('And') || rowData['item']==null\"><img src='/platform/common/web/assets/filter-icon/and.svg'></span>\r\n                <span style=\"display: inline-block;\" id=\"groupOr\" *ngIf=\"rowData['item']==this.localePipe.transform('Or')\"><img src='/platform/common/web/assets/filter-icon/or.svg'></span>\r\n\r\n                <farris-combo-list *ngIf=\"(rowData['item']==this.localePipe.transform('Or') || rowData['item']==this.localePipe.transform('And') || rowData['item']==null)&& rowData['displaySelect']\"\r\n                style=\"display: inline-block;\"\r\n                [(ngModel)]=\"defaultSelectGroup\"\r\n                [idField]=\"'id'\"\r\n                [textField]=\"'id'\"\r\n                [data]=\"relations\" \r\n                (selectChange)=\"selectGroup($event)\">\r\n                </farris-combo-list>\r\n                <farris-combo-list *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displaySelect']\"\r\n                style=\"display: inline-block;\"\r\n                [(ngModel)]=\"defaultSelectItem\"\r\n                [idField]=\"'value'\"\r\n                [textField]=\"'text'\"\r\n                [data]=\"propertyList\" \r\n                (selectChange)=\"selectItem($event)\">\r\n                </farris-combo-list>\r\n                <ng-container *ngIf=\"!rowData['displaySelect']\">\r\n                     {{rowData[col.field]}}\r\n                </ng-container>\r\n            </ng-container>\r\n          \r\n            <ng-container *ngIf=\"i==1\">\r\n              <farris-combo-list *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displayExpressType']\"\r\n                [(ngModel)]=\"defaultOperatorText\"\r\n                [idField]=\"'id'\"\r\n                [textField]=\"'id'\"\r\n                [data]=\"operatorView\"\r\n                [panelHeight]=200\r\n                (selectChange)=\"selectOperator($event)\">\r\n              </farris-combo-list>\r\n              <ng-container *ngIf=\"!rowData['displayOperator']\">\r\n                {{rowData[col.field]}}\r\n              </ng-container>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"i==2\">\r\n              <farris-combo-list *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displayExpressType']\"\r\n                [(ngModel)]=\"defaultExpressTypeText\"\r\n                [idField]=\"'id'\"\r\n                [textField]=\"'id'\"\r\n                [data]=\"expressTypes\"\r\n                (selectChange)=\"selectExpressType($event)\">\r\n              </farris-combo-list>\r\n              <ng-container *ngIf=\"!rowData['displayExpressType']\">\r\n                {{rowData[col.field]}}\r\n              </ng-container>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"i==3\">\r\n              <ng-container *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displayValue']\">\r\n              <div class=\"input-group\">\r\n                <input type=\"text\" class=\"form-control\" placeholder=\"{{ 'PlaceHolder' | locale }}\" aria-describedby=\"button-addon\" [(ngModel)]=\"rowData['value']\"/>\r\n                <button *ngIf=\"rowData['expressType']==this.localePipe.transform('Expression')\" class=\"btn btn-outline-secondary\" style=\"border: none;width: 25px;padding-left: 4px\" type=\"button\" id=\"button-addon\" (click)=\"openExpressEditor()\"><span class=\"f-icon f-icon-windows\"></span></button>\r\n              </div>\r\n              </ng-container>\r\n              <ng-container *ngIf=\"!rowData['displayValue']\">\r\n                <span style=\"display: inline-block;overflow: hidden;width: 100%\">{{rowData[col.field]}}</span>\r\n              </ng-container>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"i==4\">\r\n                <div class=\"btn-group mr-3\" fDropdown>\r\n                  <button class=\"btn btn-link\" fDropdownToggle type=\"button\">\r\n                    {{ 'Add' | locale }}\r\n                  </button>\r\n                  <div class=\"dropdown-menu\" fDropdownMenu>\r\n                    <li class=\"dropdown-item\" (click)=\"addGroup()\"><span> {{ 'AddGroup' | locale }}</span></li>\r\n                    <li class=\"dropdown-item\" (click)=\"addItem()\"><span> {{ 'AddItem' | locale }}</span></li>\r\n                  </div>\r\n                </div>\r\n                <button style=\"padding-left: 16px;\" type=\"button\" class=\"btn btn-link\" (click)=\"deleteNode(rowData['id'])\">{{ 'Delete' | locale }}</button> \r\n            </ng-container>\r\n          </td>\r\n        </tr>\r\n      </ng-template>\r\n    </farris-treetable>\r\n</div>\r\n<div class=\"modal-footer footer\">\r\n  <button type=\"button\" class=\"btn f-btn-mr btn-primary\" (click)=\"onConfirm()\">{{ 'Confirm' | locale }}</button>\r\n  <button type=\"button\" class=\"k-button k-button-icon k-flat\" (click)=\"onCancel()\">{{ 'Reset' | locale }}</button>\r\n  <button type=\"button\" class=\"k-button k-button-icon k-flat\" (click)=\"cancle()\">{{ 'Cancle' | locale }}</button>\r\n</div>\r\n",
                providers: [ExpressionService],
                encapsulation: ViewEncapsulation.None,
                styles: [".lpopup kendo-button-list{height:250px;overflow-y:auto}.footer{position:fixed;bottom:0;left:0;right:0}.farristreetable .farris-treetable .farris-treetable-tbody tr td{overflow:inherit}.filter{padding-left:20px;padding-right:20px}"]
            }] }
];
/** @nocollapse */
FilterConditionComponent.ctorParameters = () => [
    { type: ExpressionService },
    { type: NotifyService },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
FilterConditionComponent.propDecorators = {
    tt: [{ type: ViewChild, args: ['tt',] }],
    closed: [{ type: Output }],
    result: [{ type: Output }],
    contextEntity: [{ type: Input }],
    expressionText: [{ type: Input }],
    expressionSchema: [{ type: Input }],
    expressionInjectedEntities: [{ type: Input }],
    expressionCDT: [{ type: Input }],
    propertyList: [{ type: Input }],
    filterExpressionString: [{ type: Input }],
    schemaMap: [{ type: Input }],
    newSchemaMap: [{ type: Input }],
    injectedEntity: [{ type: Input }],
    exprWinWidth: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 导航属性类
 * \@property name 导航属性语义化名称
 * \@property navigationType 导航属性类型
 */
class NavigationProperty {
}
/** @enum {number} */
const NavigationType = {
    EntitySet: 0,
    EntityType: 1,
};
NavigationType[NavigationType.EntitySet] = 'EntitySet';
NavigationType[NavigationType.EntityType] = 'EntityType';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * schema实体类
 * \@property entitySets  实体集集合
 * \@property entityTypes 实体类型集合
 */
class FilterEntitySchema {
    constructor() {
        this.entitySets = [];
        this.entityTypes = [];
    }
}
/**
 * 过滤实体类型
 * 用于多级嵌套实体显示
 * \@property name 实体名(用于实体间导航使用)
 * \@property displayName 展示名称
 * \@property properties 属性集
 * \@property navigationProperties 导航属性集
 */
class FilterEntityType {
    constructor() {
        this.properties = [];
        this.navigationProperties = [];
    }
}
/**
 * 过滤实体类型集
 * 用于多级嵌套实体显示
 * \@property name 实体集名
 * \@property entityTypeName 包含的实体类型名
 */
class FilterEntitySet {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@description 统一结构Schema
 * @param name 名称
 * @param description 描述
 * @param entitySets 实体集
 * @param entityTypes 实体类型
 * @param associations 关联集合
 * \@date 2021-04-14
 * @author Wenxing Man
 */
class NewSchema {
    constructor() {
        this.entitySets = [];
        this.entityTypes = [];
        this.associations = [];
    }
}
/**
 * @param code 属性名
 * @param name 实体语义化名
 * @param master  是否是主实体
 * @param properties    属性集合
 * @param keys  主键集合
 * @param navigationPorperties 导航集合属性
 * \@date 2021-04-14
 * @author Wenxing Man
 */
class NewEntityType {
    constructor() {
        this.properties = [];
        this.keys = [];
        this.navigationProperties = [];
    }
}
/**
 * @param code 属性名
 * @param name 属性语义化名
 * @param dataType 属性值类型
 * @param nullable 是否允许为空值
 * @param dafaultValue 属性默认值
 * \@date 2021-04-14
 * @author Wenxing Man
 */
class NewProperty {
}
/**
 * @param code 导航属性名称
 * @param name 导航属性语义化名
 * @param navigationName 导航对象的名称
 * @param navigationType 属性类型
 * @param relationShip 关联的对象
 * \@date 2021-04-14
 * @author Wenxing Man
 */
class NewNavigationProperty {
}
/** @enum {number} */
const NewDataType = {
    String: 0,
    Byte: 1,
    Boolean: 2,
    Date: 3,
    DateTime: 4,
    Decimal: 5,
    Integer: 6,
};
NewDataType[NewDataType.String] = 'String';
NewDataType[NewDataType.Byte] = 'Byte';
NewDataType[NewDataType.Boolean] = 'Boolean';
NewDataType[NewDataType.Date] = 'Date';
NewDataType[NewDataType.DateTime] = 'DateTime';
NewDataType[NewDataType.Decimal] = 'Decimal';
NewDataType[NewDataType.Integer] = 'Integer';
/** @enum {string} */
const NewNavigationType = {
    EntitySet: "EntitySet",
    EntityType: "EntityType",
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Adapter {
    /**
     * @param {?} commonObject
     * @return {?}
     */
    convertCO(commonObject) {
        /** @type {?} */
        let entityTypes = [];
        entityTypes.push(this.adaptCO(commonObject, entityTypes));
        return entityTypes;
    }
    /**
     * CO转化递归方法
     * @private
     * @param {?} gspCO 待转化gspCO
     * @param {?} entityTypes 从gspCO提取的所有主从表
     * @return {?}
     */
    adaptCO(gspCO, entityTypes) {
        /** @type {?} */
        let entityType = new FilterEntityType();
        entityType.name = gspCO.Code;
        entityType.displayName = gspCO.Name;
        //每个属性转化
        if ((gspCO.ContainElements) && gspCO.ContainElements.length != 0) {
            gspCO.ContainElements.forEach((/**
             * @param {?} element
             * @return {?}
             */
            element => {
                if (!element.IsUdt && element.ObjectType != GSPElementObjectType.Association) {
                    /** @type {?} */
                    let property = new PropertyEntity();
                    property.name = element.Code;
                    property.displayName = element.Name;
                    property.propertyDataType = this.convertPropertyDataType(element.MDataType);
                    entityType.properties.push(property);
                }
            }));
        }
        //子表转化为导航属性
        if ((gspCO.ContainChildObjects) && gspCO.ContainChildObjects.length != 0) {
            gspCO.ContainChildObjects.forEach((/**
             * @param {?} childObject
             * @return {?}
             */
            childObject => {
                /** @type {?} */
                let naviproperty = new NavigationProperty();
                naviproperty.displayName = childObject.Name;
                naviproperty.name = childObject.Code + "s";
                naviproperty.navigationEntity = childObject.Code;
                naviproperty.navigationType = NavigationType.EntityType;
                entityType.navigationProperties.push(naviproperty);
                entityTypes.push(this.adaptCO(childObject, entityTypes));
            }));
        }
        return entityType;
    }
    /**
     * 属性数据类型转换
     * @private
     * @param {?} dataType
     * @return {?}
     */
    convertPropertyDataType(dataType) {
        switch (dataType) {
            case GSPElementDataType.String:
            case GSPElementDataType.Text:
                return PropertyDataType.String;
            case GSPElementDataType.Integer:
                return PropertyDataType.Int32;
            case GSPElementDataType.Decimal:
                return PropertyDataType.Decimal;
            case GSPElementDataType.DateTime:
            case GSPElementDataType.Date:
                return PropertyDataType.DateTime;
            case GSPElementDataType.Boolean:
                return PropertyDataType.Boolean;
            case GSPElementDataType.Binary:
                return PropertyDataType.Array;
            default: return null;
        }
    }
    //=====================================转换CO---->NewSchema===================================
    /**
     * \@description 将CO转化为NewEntityType[]
     * @param {?} co 待转换CO
     * @return {?} NewEntityType[] NewEntityType[]
     */
    convertCOOfNewSchema(co) {
        /** @type {?} */
        let types = [];
        types.push(this.adaptCOOfNewSchema(co, types));
        return types;
    }
    /**
     * \@description 将CO转化为NewEntityType[]
     * @param {?} co 待转换CO
     * @param {?} types 数组:EntityType[]
     * @return {?} NewEntityType[] NewEntityType[]
     */
    adaptCOOfNewSchema(co, types) {
        /** @type {?} */
        let type = new NewEntityType();
        type.code = co.Code;
        type.name = co.Name;
        //一般属性转化
        if (co.ContainElements && co.ContainElements.length > 0) {
            co.ContainElements.forEach((/**
             * @param {?} ele
             * @return {?}
             */
            ele => {
                if (!ele.IsUdt && ele.ObjectType != GSPElementObjectType.Association) {
                    /** @type {?} */
                    let pro = new NewProperty();
                    pro.code = ele.Code;
                    pro.name = ele.Name;
                    pro.dataType = this.convertCOEleTypeProType(ele.MDataType);
                    type.properties.push(pro);
                }
            }));
        }
        //导航属性转化
        if (co.ContainChildObjects && co.ContainChildObjects.length > 0) {
            co.ContainChildObjects.forEach((/**
             * @param {?} obj
             * @return {?}
             */
            obj => {
                /** @type {?} */
                let naPro = new NewNavigationProperty();
                naPro.code = obj.Code + "s";
                naPro.name = obj.Name;
                naPro.navigationName = obj.ID;
                naPro.navigationType = NewNavigationType.EntityType;
                naPro.relationShip = "";
                type.navigationProperties.push(naPro);
                types.push(this.adaptCOOfNewSchema((/** @type {?} */ (obj)), types));
            }));
        }
        return type;
    }
    /**
     * \@description 将BE定义的字段类型转换为统一Schema的字段类型
     * @param {?} dataType BE定义的属性类型
     * @return {?} NewDataType 统一Schema的属性类型
     */
    convertCOEleTypeProType(dataType) {
        /** @type {?} */
        let type = NewDataType.String;
        switch (dataType) {
            case GSPElementDataType.String:
            case GSPElementDataType.Text:
                type = NewDataType.String;
                break;
            case GSPElementDataType.Integer:
                type = NewDataType.Integer;
                break;
            case GSPElementDataType.Decimal:
                type = NewDataType.Decimal;
                break;
            case GSPElementDataType.DateTime:
                type = NewDataType.DateTime;
                break;
            case GSPElementDataType.Date:
                type = NewDataType.Date;
                break;
            case GSPElementDataType.Boolean:
                type = NewDataType.Boolean;
                break;
            case GSPElementDataType.Binary:
                type = NewDataType.Byte;
                break;
        }
        return type;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 过滤表达式服务类
 * @author linchang 2018/12/10
 */
class FilterService {
    /**
     * @param {?} injector
     * @param {?} applicationRef
     * @param {?} compFactRes
     * @param {?} http
     */
    constructor(injector, applicationRef, compFactRes, http) {
        this.injector = injector;
        this.applicationRef = applicationRef;
        this.compFactRes = compFactRes;
        this.http = http;
        this.i = 0;
        this.adapter = new Adapter();
        //属性列表
        this.propertyList = [];
        //预置计算表达式变量
        this.contextEntity = [];
        this.expressionText = null;
        this.expressionSchema = Array();
        this.expressionInjectedEntities = [];
        this.expressionCDT = [];
        //预置条件表达式变量
        this.filterExpressionString = null; //过滤表达式序列化串
        //过滤表达式序列化串
        this.schemaMap = new Map();
        this.newSchemaMap = new Map(); //过滤表达式添加NewSchema
        this.exprWinWidth = 850;
        this.modalService = this.injector.get(BsModalService);
    }
    // 创建表达式
    /**
     * @return {?}
     */
    buildExpression() {
        /** @type {?} */
        let that = this;
        return new Promise((/**
         * @param {?} resolve
         * @return {?}
         */
        function (resolve) {
            /** @type {?} */
            const compFactory = that.compFactRes.resolveComponentFactory(FilterConditionComponent);
            /** @type {?} */
            const compRef = compFactory.create(that.injector);
            compRef.instance.propertyList = that.propertyList;
            compRef.instance.contextEntity = that.contextEntity;
            compRef.instance.expressionCDT = that.expressionCDT;
            compRef.instance.expressionSchema = that.expressionSchema;
            compRef.instance.expressionText = that.expressionText;
            compRef.instance.expressionInjectedEntities = that.expressionInjectedEntities;
            compRef.instance.filterExpressionString = that.filterExpressionString;
            compRef.instance.schemaMap = that.schemaMap;
            //===================组件加入newSchemaMap===============
            compRef.instance.newSchemaMap = that.newSchemaMap;
            //=====================================================    
            compRef.instance.exprWinWidth = that.exprWinWidth;
            that.localePipe = compRef.instance.localePipe;
            /** @type {?} */
            const dialog = that.modalService.show(compRef, {
                title: that.localePipe.transform("WindowTitle"),
                width: 1010,
                height: 550,
                showButtons: false
            });
            compRef.instance.closed.subscribe((/**
             * @param {?} $event
             * @return {?}
             */
            $event => dialog.close()));
            compRef.instance.result.subscribe((/**
             * @param {?} expressionContent
             * @return {?}
             */
            (expressionContent) => {
                return resolve(expressionContent);
            }));
        }));
    }
    /**
     *  预置属性列表
     * @param {?} name 属性语义
     * @param {?} displayName 展示名称
     * @param {?} propertyDataType 属性数据类型
     * @return {?}
     */
    addProperty(name, displayName, propertyDataType) {
        /** @type {?} */
        let propertyEntity = {
            text: displayName,
            propertyDataType: propertyDataType,
            value: name,
            parentItem: null
        };
        this.propertyList = this.propertyList.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item.value !== name));
        this.propertyList.push(propertyEntity);
    }
    /**
     * 添加上下文变量
     * @param {?} contextEntity 上下文变量
     * @return {?}
     */
    addExpressionContext(contextEntity) {
        this.contextEntity = this.contextEntity.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item.key !== contextEntity.key));
        this.contextEntity.push(contextEntity);
    }
    /**
     * 预置表达式默认显示
     * @param {?} text 预置文本
     * @return {?}
     */
    addExpressionText(text) {
        this.expressionText = text;
    }
    /**
     * 预置Schema
     * @param {?} name schema名称
     * @param {?} schema schema实体
     * @return {?}
     */
    addExpressionSchema(name, schema) {
        this.expressionSchema = this.expressionSchema.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => item.name !== name));
        this.expressionSchema.push({ name, schema });
    }
    /**
     * 预置注册实体
     * @author linchang 2018/12/10
     * @param {?} name 注册实体名
     * @param {?} schemaName 所在schema的名
     * @param {?} typeNameInSchema 在schema中名称
     * @param {?} injectedType 注册的类型
     * @return {?}
     */
    addExpressionInjectedEntity(name, schemaName, typeNameInSchema, injectedType) {
        //构造注入实体对象
        /** @type {?} */
        let injectedEntity = new InjectedEntity();
        injectedEntity.name = name;
        injectedEntity.schemaName = schemaName;
        injectedEntity.injectedName = typeNameInSchema;
        injectedEntity.injectedType = injectedType;
        this.expressionInjectedEntities.push(injectedEntity);
    }
    /**
     * 预置CDT
     * @param {?} gspCDTs 预置的CDT集合
     * @return {?}
     */
    addExpressionCDT(gspCDTs) {
        this.expressionCDT = gspCDTs;
    }
    /**
     * 预置过滤条件表达式
     * @param {?} filterExpression 预置的过滤表达式串
     * @return {?}
     */
    addFilterCondition(filterExpression) {
        this.filterExpressionString = filterExpression;
    }
    /**
     * 预置schema
     * @param {?} name schema名,默认为CO
     * @param {?} filterSchema schema实体
     * @return {?}
     */
    addSchema(name, filterSchema) {
        if (filterSchema == null) {
            alert("Schema Cannot Null");
        }
        else
            this.schemaMap.set(name, filterSchema);
    }
    /**
     * 添加注入实体
     * @param {?} name 注入实体在schema中的名称
     * @param {?} schemaName 注入实体所在的schema名
     * @param {?=} injectedType 注入类型，不填默认为EntityType
     * @return {?}
     */
    addInjectedEntity(name, schemaName, injectedType = FilterInjectedType.EntityType) {
        this.injectedEntity = new FilterInjectedEntity();
        this.injectedEntity.name = name;
        this.injectedEntity.schemaName = schemaName;
        this.injectedEntity.injectedType = injectedType;
        /** @type {?} */
        let propertyAdapter = new PropertyAdapter();
        this.propertyList = propertyAdapter.adapter(this.injectedEntity, this.schemaMap);
    }
    /**
     * 添加GSPCommonObject
     * @param {?} commonObject 待转化CO
     * @return {?}
     */
    addCommonObject(commonObject) {
        /** @type {?} */
        let schema;
        //若schemaMap中存在CO的schema
        if (this.schemaMap.get("CommonObject")) {
            schema = this.schemaMap.get("CommonObject");
        }
        else
            schema = new Schema;
        //将每一个CO转化为schema内部结构中的entityType
        /** @type {?} */
        let entityTypes = this.adapter.convertCO(commonObject);
        entityTypes.forEach((/**
         * @param {?} entityType
         * @return {?}
         */
        entityType => {
            schema.entityTypes = schema.entityTypes.filter((/**
             * @param {?} item
             * @return {?}
             */
            item => item.name !== entityType.name));
            schema.entityTypes.push(entityType);
        }));
        //将合并后的schema放入内部上下文实体中
        this.addSchema("CommonObject", schema);
    }
    /**
     * 设置计算表达式弹出框宽度
     * @param {?} exprWinWidth
     * @return {?}
     */
    addExprWinWidth(exprWinWidth) {
        this.exprWinWidth = exprWinWidth;
    }
    //======================华丽分割线之统一结构Schema============================================================
    /**
     * \@description 向newSchemaMap中添加NewSchema
     * @param {?} name Map中的key值
     * @param {?} schema Map的value
     * @return {?}
     */
    addNewSchema(name, schema) {
        if (name != null && name != "" && schema != null) {
            this.newSchemaMap.set(name, schema);
        }
        else {
            alert("Name or Schema is null !");
        }
    }
    /**
     * 添加注入实体
     * @param {?} name 注入实体在schema中的名称
     * @param {?} schemaName 注入实体所在的schema名
     * @param {?=} injectedType 注入类型，默认为EntityType
     * @return {?}
     */
    addInjectedEntityOfNewSchema(name, schemaName, injectedType = FilterInjectedType.EntityType) {
        this.injectedEntity = new FilterInjectedEntity();
        this.injectedEntity.name = name;
        this.injectedEntity.schemaName = schemaName;
        this.injectedEntity.injectedType = injectedType;
        /** @type {?} */
        let propertyAdapter = new PropertyAdapter();
        this.propertyList = propertyAdapter.adapterOfNewSchema(this.injectedEntity, this.newSchemaMap);
    }
}
FilterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FilterService.ctorParameters = () => [
    { type: Injector },
    { type: ApplicationRef },
    { type: ComponentFactoryResolver },
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyAdapter {
    /**
     * 属性适配器，注入多级实体转化为Array
     * @param {?} injectedEntity 注入的实体
     * @param {?} schemaMap 注入的schema
     * @return {?}
     */
    adapter(injectedEntity, schemaMap) {
        //根据注入schema名得到schema
        /** @type {?} */
        let schema = schemaMap.get(injectedEntity.schemaName);
        //根据注入类型分别进行转化
        switch (injectedEntity.injectedType) {
            case FilterInjectedType.EntitySet:
                {
                    /** @type {?} */
                    let entitySet = schema.entitySets.find((/**
                     * @param {?} entitySet
                     * @return {?}
                     */
                    entitySet => entitySet.name == injectedEntity.name));
                    return this.convertEntitySet(entitySet, schema);
                }
            case FilterInjectedType.EntityType:
                {
                    /** @type {?} */
                    let entityType = schema.entityTypes.find((/**
                     * @param {?} entityType
                     * @return {?}
                     */
                    entityType => entityType.name == injectedEntity.name));
                    return this.convertEntityType(entityType, schema);
                }
            default: break;
        }
    }
    /**
     * 将实体类转化成Arrray
     * @param {?} entityType 被转换的实体类
     * @param {?} schema
     * @return {?}
     */
    convertEntityType(entityType, schema) {
        /** @type {?} */
        let propertyList = Array();
        //常规属性转化
        entityType.properties.forEach((/**
         * @param {?} property
         * @return {?}
         */
        property => {
            /** @type {?} */
            let propertyListItem = {
                text: property.displayName,
                propertyDataType: property.propertyDataType,
                value: property.name,
                parentItem: null
            };
            propertyList.push(propertyListItem);
        }));
        //导航属性转化
        entityType.navigationProperties.forEach((/**
         * @param {?} navigationProperty
         * @return {?}
         */
        navigationProperty => {
            //根据导航属性类型进行转化
            switch (navigationProperty.navigationType) {
                //若导航属性为EntitySet
                case NavigationType.EntitySet:
                    {
                        //根据导航属性名找到schema中的EntitySet
                        /** @type {?} */
                        let entitySet = schema.entitySets.find((/**
                         * @param {?} entitySet
                         * @return {?}
                         */
                        entitySet => entitySet.name == navigationProperty.navigationEntity));
                        //子实体集转化为Array
                        this.convertEntitySet(entitySet, schema).forEach((/**
                         * @param {?} element
                         * @return {?}
                         */
                        element => {
                            //若子实体中的每个属性父项不为空，则在父项名前添加该导航属性名，例如OrderItem前加Order为Orders.OrderItem
                            if (element.parentItem != null) {
                                element.parentItem = navigationProperty.name + "." + element.parentItem;
                            }
                            //若父项为空，则设置该属性父项为导航属性名
                            else {
                                element.parentItem = navigationProperty.name;
                            }
                            //设置该属性的显示名称
                            element.text = navigationProperty.displayName + "." + element.text;
                            propertyList.push(element);
                        }));
                    }
                    break;
                //若导航属性类型为EntityType
                case NavigationType.EntityType:
                    {
                        //根据导航属性名找到schema中的EntityType
                        /** @type {?} */
                        let entityType = schema.entityTypes.find((/**
                         * @param {?} entityType
                         * @return {?}
                         */
                        entityType => entityType.name == navigationProperty.navigationEntity));
                        //子实体转化为Array
                        this.convertEntityType(entityType, schema).forEach((/**
                         * @param {?} element
                         * @return {?}
                         */
                        element => {
                            //若子实体中的每个属性父项不为空，则在父项名前添加该导航属性名，例如OrderItem前加Order为Order.OrderItem
                            if (element.parentItem != null) {
                                element.parentItem = navigationProperty.name + "." + element.parentItem;
                            }
                            //若父项为空，则设置该属性父项为导航属性名
                            else {
                                element.parentItem = navigationProperty.name;
                            }
                            //设置该属性的显示名称
                            element.text = navigationProperty.displayName + "." + element.text;
                            propertyList.push(element);
                        }));
                    }
                    break;
            }
        }));
        return propertyList;
    }
    /**
     * 实体集转化为属性列表
     * @param {?} entitySet 待转化实体集
     * @param {?} schema 所在schema
     * @return {?}
     */
    convertEntitySet(entitySet, schema) {
        /** @type {?} */
        let propertyList = Array();
        /** @type {?} */
        let entityType = schema.entityTypes.find((/**
         * @param {?} entityType
         * @return {?}
         */
        entityType => entityType.name == entitySet.entityTypeName));
        entityType.properties.forEach((/**
         * @param {?} property
         * @return {?}
         */
        property => {
            /** @type {?} */
            let propertyListItem = {
                text: property.displayName,
                propertyDataType: property.propertyDataType,
                value: property.name,
                parentItem: null
            };
            propertyList.push(propertyListItem);
        }));
        if (entityType.navigationProperties.length != 0) {
            //导航属性转化
            entityType.navigationProperties.forEach((/**
             * @param {?} navigationProperty
             * @return {?}
             */
            navigationProperty => {
                switch (navigationProperty.navigationType) {
                    case NavigationType.EntitySet:
                        {
                            /** @type {?} */
                            let entitySet = schema.entitySets.find((/**
                             * @param {?} entitySet
                             * @return {?}
                             */
                            entitySet => entitySet.name == navigationProperty.navigationEntity));
                            this.convertEntitySet(entitySet, schema).forEach((/**
                             * @param {?} element
                             * @return {?}
                             */
                            element => {
                                if (element.parentItem != null) {
                                    element.parentItem = navigationProperty.name + "." + element.parentItem;
                                }
                                else {
                                    element.parentItem = navigationProperty.name;
                                }
                                element.text = navigationProperty.displayName + "." + element.text;
                                propertyList.push(element);
                            }));
                        }
                        break;
                    case NavigationType.EntityType:
                        {
                            /** @type {?} */
                            let entityType = schema.entityTypes.find((/**
                             * @param {?} entityType
                             * @return {?}
                             */
                            entityType => entityType.name == navigationProperty.navigationEntity));
                            this.convertEntityType(entityType, schema).forEach((/**
                             * @param {?} element
                             * @return {?}
                             */
                            element => {
                                if (element.parentItem != null) {
                                    element.parentItem = navigationProperty.name + "." + element.parentItem;
                                }
                                else {
                                    element.parentItem = navigationProperty.name;
                                }
                                element.text = navigationProperty.displayName + "." + element.text;
                                propertyList.push(element);
                            }));
                        }
                        break;
                }
            }));
        }
        return propertyList;
    }
    //==========================分割线（NewSchema）============================================
    /**
     *
     * @param {?} injectedEntity
     * @param {?} newSchemaMap
     * @return {?}
     */
    adapterOfNewSchema(injectedEntity, newSchemaMap) {
        //injectedEntity.schemaName找到Schema
        /** @type {?} */
        let schema = newSchemaMap.get(injectedEntity.schemaName);
        //injectedEntity.injectedType确定找sets还是types
        switch (injectedEntity.injectedType) {
            case FilterInjectedType.EntitySet: {
                /** @type {?} */
                let set = schema.entitySets.find((/**
                 * @param {?} set
                 * @return {?}
                 */
                set => set.code == injectedEntity.name));
                return this.convertNewEntitySet(set, schema);
            }
            case FilterInjectedType.EntityType: {
                /** @type {?} */
                let type = schema.entityTypes.find((/**
                 * @param {?} type
                 * @return {?}
                 */
                type => type.code == injectedEntity.name));
                return this.convertNewEntityType(type, schema);
            }
            default:
                break;
        }
    }
    /**
     * \@description 转换EntityType
     * @param {?} type NewEntityType
     * @param {?} schema NewSchema
     * @return {?}
     */
    convertNewEntityType(type, schema) {
        /** @type {?} */
        let propertyList = Array();
        //property转换
        type.properties.forEach((/**
         * @param {?} pro
         * @return {?}
         */
        pro => {
            /** @type {?} */
            let propertyListItem = {
                value: pro.code,
                text: pro.name,
                propertyDataType: this.convertNewDataType2PropertyDataType(pro.dataType),
                parentItem: null
            };
            propertyList.push(propertyListItem);
        }));
        //navigationProperty转换
        type.navigationProperties.forEach((/**
         * @param {?} naPro
         * @return {?}
         */
        naPro => {
            switch (naPro.navigationType) {
                case NewNavigationType.EntitySet:
                    {
                        /** @type {?} */
                        let naProSet = schema.entitySets.find((/**
                         * @param {?} naProSet
                         * @return {?}
                         */
                        naProSet => naProSet.code == naPro.navigationName));
                        this.convertNewEntitySet(naProSet, schema).forEach((/**
                         * @param {?} ele
                         * @return {?}
                         */
                        ele => {
                            if (ele.parentItem != null) {
                                ele.parentItem = naPro.code + "." + ele.parentItem;
                            }
                            else {
                                ele.parentItem = naPro.code;
                            }
                            ele.text = naPro.name + "." + ele.text;
                            propertyList.push(ele);
                        }));
                    }
                    break;
                case NewNavigationType.EntityType:
                    {
                        /** @type {?} */
                        let naProType = schema.entityTypes.find((/**
                         * @param {?} naProType
                         * @return {?}
                         */
                        naProType => naProType.code == naPro.navigationName));
                        this.convertNewEntityType(naProType, schema).forEach((/**
                         * @param {?} ele
                         * @return {?}
                         */
                        ele => {
                            if (ele.parentItem != null) {
                                ele.parentItem = naPro.code + "." + ele.parentItem;
                            }
                            else {
                                ele.parentItem = naPro.code;
                            }
                            ele.text = naPro.name + "." + ele.text;
                            propertyList.push(ele);
                        }));
                    }
                    break;
            }
        }));
        return propertyList;
    }
    /**
     * @param {?} set
     * @param {?} schema
     * @return {?}
     */
    convertNewEntitySet(set, schema) {
        /** @type {?} */
        let propertyList = Array();
        /** @type {?} */
        let type = schema.entityTypes.find((/**
         * @param {?} type
         * @return {?}
         */
        type => type.code == set.entityType));
        type.properties.forEach((/**
         * @param {?} pro
         * @return {?}
         */
        pro => {
            /** @type {?} */
            let propertyListItem = {
                value: pro.code,
                text: pro.name,
                propertyDataType: this.convertNewDataType2PropertyDataType(pro.dataType),
                parentItem: null
            };
            propertyList.push(propertyListItem);
        }));
        if (type.navigationProperties.length != 0) {
            type.navigationProperties.forEach((/**
             * @param {?} naPro
             * @return {?}
             */
            naPro => {
                switch (naPro.navigationType) {
                    case NewNavigationType.EntitySet:
                        {
                            /** @type {?} */
                            let naProSet = schema.entitySets.find((/**
                             * @param {?} naProSet
                             * @return {?}
                             */
                            naProSet => naProSet.code == naPro.navigationName));
                            this.convertNewEntitySet(naProSet, schema).forEach((/**
                             * @param {?} ele
                             * @return {?}
                             */
                            ele => {
                                if (ele.parentItem != null) {
                                    ele.parentItem = naPro.code + "." + ele.parentItem;
                                }
                                else {
                                    ele.parentItem = naPro.code;
                                }
                                ele.text = naPro.name + "." + ele.text;
                                propertyList.push(ele);
                            }));
                        }
                        break;
                    case NewNavigationType.EntityType:
                        {
                            /** @type {?} */
                            let naProType = schema.entityTypes.find((/**
                             * @param {?} naProType
                             * @return {?}
                             */
                            naProType => naProType.code == naPro.navigationName));
                            this.convertNewEntityType(naProType, schema).forEach((/**
                             * @param {?} ele
                             * @return {?}
                             */
                            ele => {
                                if (ele.parentItem != null) {
                                    ele.parentItem = naPro.code + "." + ele.parentItem;
                                }
                                else {
                                    ele.parentItem = naPro.code;
                                }
                                ele.text = naPro.name + "." + ele.text;
                                propertyList.push(ele);
                            }));
                        }
                        break;
                }
            }));
        }
        return propertyList;
    }
    /**
     *
     * @param {?} newType 统一Schema的属性
     * @return {?}
     */
    convertNewDataType2PropertyDataType(newType) {
        /** @type {?} */
        let type = PropertyDataType.String;
        switch (newType) {
            case NewDataType.Boolean:
                type = PropertyDataType.Boolean;
                break;
            case NewDataType.Byte:
                type = PropertyDataType.Byte;
                break;
            case NewDataType.Date:
                type = PropertyDataType.DateTime;
                break;
            case NewDataType.DateTime:
                type = PropertyDataType.DateTime;
                break;
            case NewDataType.Decimal:
                type = PropertyDataType.Decimal;
                break;
            case NewDataType.Integer:
                type = PropertyDataType.Int32;
                break;
            case NewDataType.String:
                type = PropertyDataType.String;
                break;
        }
        return type;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 过滤条件面板逻辑类
 */
class FilterExpressionComponent {
    /**
     * @param {?} expr
     * @param {?} propertyAdapter
     * @param {?} notifyservice
     * @param {?} injector
     * @param {?} localeId
     */
    constructor(expr, propertyAdapter, notifyservice, injector, localeId) {
        this.expr = expr;
        this.propertyAdapter = propertyAdapter;
        this.notifyservice = notifyservice;
        this.injector = injector;
        //预置计算表达式上下文实体
        this.contextEntity = [];
        //预置计算默认表达式显示
        this.expressionText = "";
        //预置计算表达式中的schema
        this.expressionSchema = [];
        //预置计算表达式中的注入实体
        this.expressionInjectedEntities = [];
        //预置计算表达式cdt集
        this.expressionCDT = [];
        //预置属性列表
        this.propertyList = [];
        //预置过滤表达式串
        this.filterExpressionString = null;
        //schema存储结构
        this.filterNewSchemaMap = new Map();
        this.disabled = false;
        //内部属性列表使用
        this.propertyListInner = [];
        //操作比较符集
        this.operators = [];
        this.stringOperators = [];
        this.NumberOperators = [];
        //关系集
        this.relations = [];
        //表达式类型集
        this.expressTypes = [];
        this.displayPopup = false;
        //检查过滤条件实体是否完整正确
        this.checkFilterStruc = true;
        //schema存储结构
        this.filterSchemaMap = new Map();
        this.adapter = new Adapter();
        this.treeData = [];
        this.columnWidth = ["30%", "20%", "20%", "20%", "10%"];
        //消息提示
        this.notifies = {};
        this.localePipe = new FilterConditionLocalePipe(localeId);
    }
    //初始化，复制treeData值,treeDataTemp用于转换为FilterExpression实体
    /**
     * @return {?}
     */
    ngOnChanges() {
        //并且树形表绑定的显示的列 
        this.cols = [
            { field: 'item', title: this.localePipe.transform("Item"), width: 271 },
            { field: 'operator', title: this.localePipe.transform("Operator"), width: 191 },
            { field: 'expressType', title: this.localePipe.transform("ExpressType"), width: 180 },
            { field: 'value', title: this.localePipe.transform("Value"), width: 214 },
            { field: 'operation', title: this.localePipe.transform("Operation"), width: 130 }
        ];
        this.propertyListInner = [];
        this.treeDataTemp = this.treeData;
        //=================================分割线之NewSchema====================================
        //注入NewSchema
        if (this.schemaName && this.newSchema) {
            this.addNewSchema(this.schemaName, this.newSchema);
            //注入co
            if (this.gspCommonObject) {
                /** @type {?} */
                let newSchema;
                //若schemaMap中存在CO的schema
                if ((this.filterNewSchemaMap.get("CommonObject"))) {
                    newSchema = this.filterNewSchemaMap.get("CommonObject");
                }
                else {
                    newSchema = new NewSchema();
                }
                //将每一个CO转化为schema内部结构中的entityType
                /** @type {?} */
                let entityTypes = this.adapter.convertCOOfNewSchema(this.gspCommonObject);
                if ((entityTypes) && entityTypes.length != 0) {
                    entityTypes.forEach((/**
                     * @param {?} entityType
                     * @return {?}
                     */
                    entityType => {
                        if (newSchema.entityTypes.find((/**
                         * @param {?} x
                         * @return {?}
                         */
                        x => x.code == entityType.code)) == null) {
                            newSchema.entityTypes.push(entityType);
                        }
                    }));
                }
                //将合并后的schema放入内部上下文实体中
                this.addNewSchema("CommonObject", newSchema);
            }
            //添加属性列表
            this.propertyList.forEach((/**
             * @param {?} property
             * @return {?}
             */
            property => {
                /** @type {?} */
                let propertyInner = {
                    value: property.value,
                    text: property.text,
                    propertyDataType: property.propertyFieldType,
                    parentItem: null
                };
                this.propertyListInner.push(propertyInner);
            }));
            if ((this.injectedEntity)) {
                this.propertyAdapter.adapterOfNewSchema(this.injectedEntity, this.filterNewSchemaMap).forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                element => {
                    this.propertyListInner.push(element);
                }));
            }
        }
        else {
            //===========================================旧Schema==========================================
            if (this.schemaName != null && (this.schema)) {
                this.addSchema(this.schemaName, this.schema);
            }
            if ((this.gspCommonObject)) {
                /** @type {?} */
                let schema;
                //若schemaMap中存在CO的schema
                if ((this.filterSchemaMap.get("CommonObject"))) {
                    schema = this.filterSchemaMap.get("CommonObject");
                }
                else
                    schema = new FilterEntitySchema();
                //将每一个CO转化为schema内部结构中的entityType
                /** @type {?} */
                let entityTypes = this.adapter.convertCO(this.gspCommonObject);
                if ((entityTypes) && entityTypes.length != 0) {
                    entityTypes.forEach((/**
                     * @param {?} entityType
                     * @return {?}
                     */
                    entityType => {
                        if (schema.entityTypes.find((/**
                         * @param {?} x
                         * @return {?}
                         */
                        x => x.name == entityType.name)) == null) {
                            schema.entityTypes.push(entityType);
                        }
                    }));
                }
                //将合并后的schema放入内部上下文实体中
                this.addSchema("CommonObject", schema);
            }
            this.propertyList.forEach((/**
             * @param {?} property
             * @return {?}
             */
            property => {
                /** @type {?} */
                let propertyInner = {
                    text: property.text,
                    propertyDataType: property.propertyFieldType,
                    value: property.value,
                    parentItem: null
                };
                this.propertyListInner.push(propertyInner);
            }));
            if ((this.injectedEntity)) {
                this.propertyAdapter.adapter(this.injectedEntity, this.filterSchemaMap).forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                element => {
                    this.propertyListInner.push(element);
                }));
            }
        }
        this.defaultExpressTypeText = this.localePipe.transform("Value");
        this.defaultSelectGroup = this.localePipe.transform('And');
        this.defaultSelectItem = this.localePipe.transform("SelectItem");
        this.defaultOperatorText = this.localePipe.transform("GreaterThan");
        this.notifies = {
            1: { type: 'success', msg: this.localePipe.transform("Success") },
            2: { type: 'warning', msg: this.localePipe.transform("Warning_SelectRelation") },
            3: { type: 'warning', msg: this.localePipe.transform("Warning_ContainsFilters") },
            4: { type: 'warning', msg: this.localePipe.transform("Warning_ConditionsComplete") },
            5: { type: 'warning', msg: this.localePipe.transform("Warning_NumericMatch") }
        };
        this.expressTypes = [
            { id: this.localePipe.transform("Value") },
            { id: this.localePipe.transform("Expression") }
        ];
        this.relations = [
            { id: this.localePipe.transform("And") },
            { id: this.localePipe.transform("Or") },
        ];
        this.NumberOperators = [
            { id: this.localePipe.transform("GreaterThan") },
            { id: this.localePipe.transform("GreaterThanOrEqual") },
            { id: this.localePipe.transform("LessThan") },
            { id: this.localePipe.transform("LessThanOrEqual") },
            { id: this.localePipe.transform("Equal") },
            { id: this.localePipe.transform("NotEqual") },
            { id: this.localePipe.transform("IsNull") },
            { id: this.localePipe.transform("IsNotNull") },
        ];
        this.stringOperators = [
            { id: this.localePipe.transform("Equal") },
            { id: this.localePipe.transform("NotEqual") },
            { id: this.localePipe.transform("Contains") },
            { id: this.localePipe.transform("NotContains") },
            { id: this.localePipe.transform("StartsWith") },
            { id: this.localePipe.transform("EndsWith") },
            { id: this.localePipe.transform("NotStartsWith") },
            { id: this.localePipe.transform("NotEndsWith") },
            { id: this.localePipe.transform("IsNull") },
            { id: this.localePipe.transform("IsNotNull") },
        ];
        this.operators = [
            { id: this.localePipe.transform("GreaterThan") },
            { id: this.localePipe.transform("GreaterThanOrEqual") },
            { id: this.localePipe.transform("LessThan") },
            { id: this.localePipe.transform("LessThanOrEqual") },
            { id: this.localePipe.transform("Equal") },
            { id: this.localePipe.transform("NotEqual") },
            { id: this.localePipe.transform("Contains") },
            { id: this.localePipe.transform("NotContains") },
            { id: this.localePipe.transform("StartsWith") },
            { id: this.localePipe.transform("EndsWith") },
            { id: this.localePipe.transform("NotStartsWith") },
            { id: this.localePipe.transform("NotEndsWith") },
            { id: this.localePipe.transform("IsNull") },
            { id: this.localePipe.transform("IsNotNull") },
            { id: this.localePipe.transform("In") },
            { id: this.localePipe.transform("NotIn") },
        ];
        this.onCancel();
    }
    //=================添加NewSchema=====================
    /**
     * \@description 添加NewSchema到Map中
     * @param {?} name schema名称
     * @param {?} filterNewSchema 注入的统一结构NewSchema
     * @return {?}
     */
    addNewSchema(name, filterNewSchema) {
        this.filterNewSchemaMap.set(name, filterNewSchema);
    }
    //==================================================
    /**
     * 添加schema入Map
     * @param {?} name schema名
     * @param {?} filterSchema
     * @return {?}
     */
    addSchema(name, filterSchema) {
        this.filterSchemaMap.set(name, filterSchema);
    }
    /**
     * 树形表中节点选择触发函数
     * @param {?} $event 所选节点信息
     * @return {?}
     */
    nodeSelected($event) {
        //隐藏掉所有的节点选择编辑框，包括子节点的
        this.hideNodeEditor(this.treeData);
        //将所选节点比较项、表达式类型项、值编辑框显示，并将所选对应数据赋给默认项进行显示
        this.defaultOperatorText = $event.node.data.operator;
        this.defaultExpressTypeText = $event.node.data.expressType;
        if ($event.node.data.item == this.localePipe.transform('And') || $event.node.data.item == this.localePipe.transform('Or')) {
            this.defaultSelectGroup = $event.node.data.item;
        }
        else if ($event.node.data.item !== this.localePipe.transform("SelectProperty")) {
            /** @type {?} */
            let properties = this.propertyListInner.filter((/**
             * @param {?} x
             * @return {?}
             */
            x => x.text == $event.node.data.item));
            this.defaultSelectItem = properties[0].value;
        }
        else if ($event.node.data.item == this.localePipe.transform("SelectProperty")) {
            this.defaultSelectItem = $event.node.data.item;
        }
        this.treeData = [...this.treeData];
        $event.node.data.displayOperator = true;
        $event.node.data.displayExpressType = true;
        $event.node.data.displayValue = true;
        $event.node.data.displaySelect = true;
    }
    ;
    /**
     * 隐藏掉所有的节点选择编辑框，包括子节点的
     * @param {?} treeNodes 树形表绑定结构
     * @return {?}
     */
    hideNodeEditor(treeNodes) {
        treeNodes.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            element.data.displayOperator = false;
            element.data.displayExpressType = false;
            element.data.displayValue = false;
            element.data.displaySelect = false;
            //若有子节点，则将其子节点的编辑选择框隐藏
            if ((element.children) && element.children.length != 0) {
                this.hideNodeEditor(element.children);
            }
        }));
    }
    ;
    //节点未选择函数
    /**
     * @return {?}
     */
    nodeUnSelect() {
        console.log("nodeUnselect");
    }
    ;
    /**
     *
     * 选择逻辑集时
     * @param {?} $event
     * @return {?}
     */
    selectGroup($event) {
        this.propertyNodeOperate($event, this.treeData, 0 /* Group */);
    }
    /**
     *
     * 选择项时
     * @param {?} $event
     * @return {?}
     */
    selectItem($event) {
        this.propertyNodeOperate($event, this.treeData, 1 /* Item */);
    }
    /**
     * 选择比较操作符时
     * @param {?} $event 比较操作项信息
     * @return {?}
     */
    selectOperator($event) {
        this.propertyNodeOperate($event, this.treeData, 2 /* Operation */);
    }
    ;
    /**
     * 选择值类型时
     * @param {?} $event 值类型项信息
     * @return {?}
     */
    selectExpressType($event) {
        this.propertyNodeOperate($event, this.treeData, 3 /* Valuetype */);
    }
    ;
    /**
     * 选择结束后隐藏该字段选择框
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} fieldType 所选字段
     * @return {?}
     */
    hideFieldEditor(treeNodes, fieldType) {
        //找到所操作的节点，根据所选择的字段将对应选择编辑框隐藏
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (this.tt.isSelected(treeNode)) {
                switch (fieldType) {
                    case 1 /* Item */:
                        treeNode.data.displaySelect = false;
                        break;
                    case 2 /* Operation */:
                        treeNode.data.displayOperator = false;
                        break;
                    case 3 /* Valuetype */:
                        treeNode.data.displayExpressType = false;
                        break;
                }
                return;
            }
            //若未找到所选节点，则找其子节点
            else if ((treeNode.children) && treeNode.children.length != 0) {
                this.hideFieldEditor(treeNode.children, fieldType);
            }
        }));
    }
    /**
     * 打开计算表达式编辑器
     * @return {?}
     */
    openExpressEditor() {
        /** @type {?} */
        let that = this;
        //添加预置上下文变量
        if (this.contextEntity && this.contextEntity.length != 0) {
            this.contextEntity.forEach((/**
             * @param {?} element
             * @return {?}
             */
            element => {
                this.expr.addContext(element);
            }));
        }
        //添加预置表达式文本
        /** @type {?} */
        let selectNode = this.isSelected(this.treeData);
        if ((selectNode) && (selectNode.data.value != "") && (selectNode.data.value != null)) {
            this.expr.addExpressionText(selectNode.data.value);
        }
        else
            this.expr.addExpressionText(this.expressionText);
        //添加注入实体
        this.expressionInjectedEntities.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            this.expr.addInjectedEntity(element.name, element.schemaName, element.injectedName, element.injectedType);
        }));
        //添加CDT
        this.expr.addCDT(this.expressionCDT);
        //添加schema
        this.expressionSchema.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            this.expr.addSchema(element.name, element.schema);
        }));
        //打开表达式编辑器并返回编辑结果
        this.expr.buildExpression().then((/**
         * @param {?} info
         * @return {?}
         */
        info => {
            /** @type {?} */
            let expressInfo = info;
            this.displayExpressResult(that.treeData, expressInfo);
        }));
    }
    /**
     * 选中节点选择
     * @param {?} treeNodes 关系组
     * @return {?}
     */
    isSelected(treeNodes) {
        /** @type {?} */
        let treeNode;
        for (var i = 0; i < treeNodes.length; i++) {
            if (this.tt.isSelected(treeNodes[i])) {
                treeNode = treeNodes[i];
                break;
            }
            //若在该层节点中未找到所选节点，则找其子节点
            else if ((treeNodes[i].children) && treeNodes[i].children.length != 0) {
                treeNode = this.isSelected(treeNodes[i].children);
                if ((treeNode))
                    break;
            }
        }
        return treeNode;
    }
    /**
     * 将计算表达式结果展示到对应节点
     * @param {?} treeNodes 树表绑定结构
     * @param {?} expressInfo 计算表达式得到结果
     * @return {?}
     */
    displayExpressResult(treeNodes, expressInfo) {
        //找到所选节点实体，并将计算表达式所得结果赋给对应属性进行显示
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (this.tt.isSelected(treeNode)) {
                treeNode.data.value = expressInfo;
                return;
            }
            //若在该层节点中未找到所选节点，则找其子节点
            else if ((treeNode.children) && treeNode.children.length != 0) {
                this.displayExpressResult(treeNode.children, expressInfo);
            }
            //若仍未找到，则不进行任何操作
        }));
    }
    /**
     * 关系选择按钮选择事件
     * @param {?} $event 选择按钮所选信息
     * @return {?}
     */
    itemClick($event) {
        //若选择添加关系
        if ($event.value == RelationTypeEnum.AddRelation) {
            this.addNode(this.treeData, this.localePipe.transform('And'), null, null);
        }
        //若选择添加属性
        else if ($event.value == RelationTypeEnum.AddProperty) {
            this.addNode(this.treeData, this.localePipe.transform("SelectProperty"), this.localePipe.transform("Equal"), this.localePipe.transform("Value"));
        }
        else
            this.propertyNodeOperate($event, this.treeData, 1 /* Item */);
    }
    /**
     * 选择属性节点操作
     * 对新添加的属性节点进行逻辑处理
     * @param {?} event 点击事件
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} fieldType 节点类型
     * @return {?}
     */
    propertyNodeOperate(event, treeNodes, fieldType) {
        treeNodes.forEach((/**
         * @param {?} treenode
         * @return {?}
         */
        treenode => {
            if (this.tt.isSelected(treenode)) {
                //对所选节点进行赋值操作
                switch (fieldType) {
                    case 0 /* Group */:
                        {
                            treenode.data.item = event.data.id;
                            this.defaultSelectGroup = event.data.id;
                        }
                        break;
                    case 1 /* Item */:
                        {
                            treenode.data.item = event.data.text;
                            this.defaultSelectItem = event.data.value;
                            treenode.data.parentItem = event.data.parentItem;
                            treenode.data.propertyDataType = event.data.propertyDataType;
                        }
                        break;
                    case 2 /* Operation */:
                        {
                            treenode.data.operator = event.data.id;
                            this.defaultOperatorText = event.data.id;
                        }
                        break;
                    case 3 /* Valuetype */:
                        {
                            treenode.data.expressType = event.data.id;
                            this.defaultExpressTypeText = event.data.id;
                        }
                        break;
                }
                return;
            }
            //否则对其子节点进行赋值操作
            else if ((treenode.children) && treenode.children.length != 0) {
                this.propertyNodeOperate(event, treenode.children, fieldType);
            }
        }));
    }
    /**
     * 根据所选为关系或者属性对新节点进行初始化
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} defaultString 新节点显示默认值
     * @param {?} defaultOperator
     * @param {?} defalutExpressType
     * @return {?}
     */
    addNode(treeNodes, defaultString, defaultOperator, defalutExpressType) {
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (this.tt.isSelected(treeNode)) {
                //若关系值为空
                if (!(treeNode.data.item)) {
                    this.notifyservice[this.notifies['2'].type]({
                        msg: this.notifies['2'].msg
                    });
                    return;
                }
                //若为所选的关系节点，则在其子项里添加新子节点
                /** @type {?} */
                let newNode = {
                    data: {
                        "item": defaultString,
                        "propertyDataType": null,
                        //属性数据类型
                        "operator": defaultOperator,
                        "expressType": defalutExpressType,
                        "value": null,
                        "id": Math.random(),
                        "parentItem": null
                    },
                    parent: treeNode,
                    children: [],
                    expanded: true
                };
                //向该所选节点的子项添加新节点
                treeNode.children.push(newNode);
                return;
            }
            //若未找到所选节点，且该节点子项不为空，则在其子项中查找所选节点
            else if ((treeNode.children) && treeNode.children.length != 0) {
                this.addNode(treeNode.children, defaultString, defaultOperator, defalutExpressType);
            }
        }));
        this.tt.updateSerializedValue();
    }
    /**
     * 删除节点
     * @param {?} $event
     * @return {?}
     */
    deleteNode($event) {
        this.onDelete(this.treeData, $event);
    }
    /**
     * 重置(外部调用)
     * 重置为初始状态
     * @return {?}
     */
    onCancel() {
        if (this.filterExpressionString == null || this.filterExpressionString == "") {
            this.treeData = [
                {
                    data: {
                        "id": 1,
                        //树形结构中每个节点的id
                        "item": this.localePipe.transform('And'),
                        //属性项
                        "propertyDataType": null,
                        //属性数据类型
                        "operator": null,
                        //操作比较符
                        "expressType": null,
                        //表达式类型
                        "value": null,
                        //值
                        "displaySelect": false,
                        //选择项显示
                        "displayOperator": false,
                        //操作符项显示
                        "displayExpressType": false,
                        //表达式类型显示
                        "displayValue": false,
                        //值显示
                        "parentItem": null //父项
                    },
                    children: [],
                    //子节点集合
                    expanded: true //是否展开
                }
            ];
        }
        else {
            this.filterExpressionPre = JSON.parse(this.filterExpressionString);
            this.treeData = [];
            this.treeData.push(this.unConvert(this.filterExpressionPre));
            this.treeData[0].data.id = 1;
        }
    }
    /**
     * 删除节点具体实现类
     * @param {?} treeNodes 树形表绑定结构
     * @param {?} id
     * @return {?}
     */
    onDelete(treeNodes, id) {
        treeNodes.forEach((/**
         * @param {?} treeNode
         * @return {?}
         */
        treeNode => {
            if (treeNode.data.id == id) {
                if (treeNode.data.id == 1) {
                    this.treeData = [
                        {
                            data: {
                                "id": 1,
                                //树形结构中每个节点的id
                                "item": this.localePipe.transform('And'),
                                //属性项
                                "propertyDataType": null,
                                //属性数据类型
                                "operator": null,
                                //操作比较符
                                "expressType": null,
                                //表达式类型
                                "value": null,
                                //值
                                "displaySelect": false,
                                //选择项显示
                                "displayOperator": false,
                                //操作符项显示
                                "displayExpressType": false,
                                //表达式类型显示
                                "displayValue": false,
                                //值显示
                                "parentItem": null //父项
                            },
                            children: [],
                            //子节点集合
                            expanded: true //是否展开
                        }
                    ];
                    return;
                }
                //所选节点所在数
                /** @type {?} */
                let index = treeNodes.indexOf(treeNode);
                //将所选节点剔除
                treeNodes.splice(index, 1);
            }
            else if ((treeNode.children) && treeNode.children.length != 0) {
                treeNode.children = this.onDelete(treeNode.children, id);
            }
        }));
        this.tt.updateSerializedValue();
        return treeNodes;
    }
    /**
     *
     * 添加条件项
     * @return {?}
     */
    addItem() {
        this.defaultSelectItem = this.localePipe.transform("SelectItem");
        this.hideNodeEditor(this.treeData);
        this.addNode(this.treeData, this.localePipe.transform("SelectProperty"), this.localePipe.transform("Equal"), this.localePipe.transform("Value"));
    }
    /**
     *
     * 添加条件组
     * @return {?}
     */
    addGroup() {
        this.addNode(this.treeData, this.localePipe.transform('And'), null, null);
    }
    /**
     * 将treeData转化为filetrExpression实体
     * @param {?} filterExpression 过滤表达式实体
     * @param {?} treeNode 最外层的treeNode
     * @return {?}
     */
    convert(filterExpression, treeNode) {
        //得到最外层的关系符
        filterExpression.relationOperator = this.typeMatch(treeNode.data.item);
        //若其子项不为空
        if (treeNode.children.length != 0) {
            //对其每一个子项进行转化操作
            treeNode.children.forEach((/**
             * @param {?} treeNodeItem
             * @return {?}
             */
            treeNodeItem => {
                //若子项为并且、或者，则新建复杂过滤表达式
                if (this.typeMatch(treeNodeItem.data.item) == RelationTypeEnum.And ||
                    this.typeMatch(treeNodeItem.data.item) == RelationTypeEnum.Or) {
                    /** @type {?} */
                    let filterExpressionItem = new FilterExpression();
                    filterExpression.expressItems.push(this.convert(filterExpressionItem, treeNodeItem));
                }
                //若子项为属性表达式
                else {
                    /** @type {?} */
                    let filterItem = new ExpressionItem();
                    /** @type {?} */
                    let properties = this.propertyListInner.filter((/**
                     * @param {?} x
                     * @return {?}
                     */
                    x => x.text == treeNodeItem.data.item));
                    filterItem.propertyName = properties[0].value;
                    filterItem.propertyDataType = treeNodeItem.data.propertyDataType;
                    filterItem.operator = this.typeMatch(treeNodeItem.data.operator);
                    filterItem.expressType = this.typeMatch(treeNodeItem.data.expressType);
                    filterItem.value = treeNodeItem.data.value;
                    filterItem.parentItem = treeNodeItem.data.parentItem;
                    //若为数值型比较，则将value值强制转换为数字
                    if (filterItem.expressType == ExpressTypeEnum.Value &&
                        (filterItem.operator == CompareTypeEnum.GreaterThan
                            || filterItem.operator == CompareTypeEnum.GreaterThanOrEqual
                            || filterItem.operator == CompareTypeEnum.LessThan
                            || filterItem.operator == CompareTypeEnum.LessThanOrEqual)) {
                        filterItem.value = Number(treeNodeItem.data.value);
                    }
                    if (filterItem.expressType == ExpressTypeEnum.Value &&
                        (filterItem.operator == CompareTypeEnum.Equal
                            || filterItem.operator == CompareTypeEnum.NotEqual)) {
                        if (filterItem.propertyDataType == PropertyDataType.Decimal
                            || filterItem.propertyDataType == PropertyDataType.Double
                            || filterItem.propertyDataType == PropertyDataType.Int16
                            || filterItem.propertyDataType == PropertyDataType.Int32
                            || filterItem.propertyDataType == PropertyDataType.Int64) {
                            filterItem.value = Number(treeNodeItem.data.value);
                        }
                    }
                    //将子项放入父项的字段中
                    filterExpression.expressItems.push(filterItem);
                }
            }));
        }
        return filterExpression;
    }
    /**
     * filetrExpression反转化为TreeNode
     * @param {?} filterExpress 待转化的filetrExpression实体
     * @return {?}
     */
    unConvert(filterExpress) {
        /** @type {?} */
        let treeData = {
            data: {
                "id": Math.random(),
                //树形结构中每个节点的id
                "item": this.relationTypeReverseMatch(filterExpress.relationOperator),
                //属性项
                "propertyDataType": null,
                //属性数据类型
                "operator": null,
                //操作比较符
                "expressType": null,
                //表达式类型
                "value": null,
                //值
                "displaySelect": false,
                //选择项显示
                "displayOperator": false,
                //操作符项显示
                "displayExpressType": false,
                //表达式类型显示
                "displayValue": false,
                //值显示
                "parentItem": null //父项
            },
            children: [],
            //子节点集合
            expanded: true //是否展开
        };
        //对于每一个子项
        filterExpress.expressItems.forEach((/**
         * @param {?} expressItem
         * @return {?}
         */
        expressItem => {
            /** @type {?} */
            let filterExpressItem = (/** @type {?} */ (expressItem));
            //若子项为FilterExpression类型，赋值
            if ((filterExpressItem.relationOperator == RelationTypeEnum.And || filterExpressItem.relationOperator == RelationTypeEnum.Or)) {
                /** @type {?} */
                let treeDataChild = this.unConvert(filterExpressItem);
                treeDataChild.data.parent = treeData; //添加父节点
                treeData.children.push(treeDataChild);
            }
            else //若子项为ExpressionItem类型，赋值
             {
                /** @type {?} */
                let expressionItem = (/** @type {?} */ (expressItem));
                /** @type {?} */
                let properties = this.propertyListInner.filter((/**
                 * @param {?} x
                 * @return {?}
                 */
                x => x.value == expressionItem.propertyName));
                /** @type {?} */
                let treeDataChild = {
                    data: {
                        "id": Math.random(),
                        //树形结构中每个节点的id
                        "item": properties[0].text,
                        //属性项
                        "propertyDataType": expressionItem.propertyDataType,
                        "operator": this.operatorReverseMatch(expressionItem.operator),
                        //操作比较符
                        "expressType": this.expressTypeReverseMatch(expressionItem.expressType),
                        //表达式类型
                        "value": expressionItem.value,
                        //值
                        "parentItem": expressionItem.parentItem //父项
                    },
                    parent: treeData,
                    //添加父节点
                    children: [],
                    //子节点集合
                    expanded: true //是否展开
                };
                treeData.children.push(treeDataChild);
            }
        }));
        return treeData;
    }
    /**
     * 类型信息匹配
     * @param {?} type 类型
     * @return {?}
     */
    typeMatch(type) {
        switch (type) {
            case this.localePipe.transform("And"): return RelationTypeEnum.And;
            case this.localePipe.transform("Or"): return RelationTypeEnum.Or;
            case this.localePipe.transform("GreaterThan"): return CompareTypeEnum.GreaterThan;
            case this.localePipe.transform("GreaterThanOrEqual"): return CompareTypeEnum.GreaterThanOrEqual;
            case this.localePipe.transform("LessThan"): return CompareTypeEnum.LessThan;
            case this.localePipe.transform("LessThanOrEqual"): return CompareTypeEnum.LessThanOrEqual;
            case this.localePipe.transform("Equal"): return CompareTypeEnum.Equal;
            case this.localePipe.transform("NotEqual"): return CompareTypeEnum.NotEqual;
            case this.localePipe.transform("Contains"): return CompareTypeEnum.Contains;
            case this.localePipe.transform("NotContains"): return CompareTypeEnum.NotContains;
            case this.localePipe.transform("StartsWith"): return CompareTypeEnum.StartsWith;
            case this.localePipe.transform("EndsWith"): return CompareTypeEnum.EndsWith;
            case this.localePipe.transform("NotStartsWith"): return CompareTypeEnum.NotStartsWith;
            case this.localePipe.transform("NotEndsWith"): return CompareTypeEnum.NotEndsWith;
            case this.localePipe.transform("IsNull"): return CompareTypeEnum.IsNull;
            case this.localePipe.transform("IsNotNull"): return CompareTypeEnum.IsNotNull;
            case this.localePipe.transform("In"): return CompareTypeEnum.In;
            case this.localePipe.transform("NotIn"): return CompareTypeEnum.NotIn;
            case this.localePipe.transform("Value"): return ExpressTypeEnum.Value;
            case this.localePipe.transform("Expression"): return ExpressTypeEnum.Expression;
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    relationTypeReverseMatch(type) {
        switch (type) {
            case RelationTypeEnum.And: return this.localePipe.transform('And');
            case RelationTypeEnum.Or: return this.localePipe.transform('Or');
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    operatorReverseMatch(type) {
        switch (type) {
            case CompareTypeEnum.GreaterThan: return this.localePipe.transform("GreaterThan");
            case CompareTypeEnum.GreaterThanOrEqual: return this.localePipe.transform("GreaterThanOrEqual");
            case CompareTypeEnum.LessThan: return this.localePipe.transform("LessThan");
            case CompareTypeEnum.LessThanOrEqual: return this.localePipe.transform("LessThanOrEqual");
            case CompareTypeEnum.Equal: return this.localePipe.transform("Equal");
            case CompareTypeEnum.NotEqual: return this.localePipe.transform("NotEqual");
            case CompareTypeEnum.Contains: return this.localePipe.transform("Contains");
            case CompareTypeEnum.NotContains: return this.localePipe.transform("NotContains");
            case CompareTypeEnum.StartsWith: return this.localePipe.transform("StartsWith");
            case CompareTypeEnum.EndsWith: return this.localePipe.transform("EndsWith");
            case CompareTypeEnum.NotStartsWith: return this.localePipe.transform("NotStartsWith");
            case CompareTypeEnum.NotEndsWith: return this.localePipe.transform("NotEndsWith");
            case CompareTypeEnum.IsNull: return this.localePipe.transform("IsNull");
            case CompareTypeEnum.IsNotNull: return this.localePipe.transform("IsNotNull");
            case CompareTypeEnum.In: return this.localePipe.transform("In");
            case CompareTypeEnum.NotIn: return this.localePipe.transform("NotIn");
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    expressTypeReverseMatch(type) {
        switch (type) {
            case ExpressTypeEnum.Value: return this.localePipe.transform("Value");
            case ExpressTypeEnum.Expression: return this.localePipe.transform('Expression');
        }
    }
    /**
     * 过滤表达式获取(外部调用)
     * @return {?}
     */
    getFilterExpression() {
        this.treeDataTemp = this.treeData;
        /** @type {?} */
        let isNull = true;
        /** @type {?} */
        let isMatch = true;
        if (this.checkNull(this.treeDataTemp[0].children, isNull) && this.checkMatch(this.treeDataTemp[0].children, isMatch)) {
            this.filterExpression = new FilterExpression();
            //根据树形数据结构转化为过滤表达式实体
            this.convert(this.filterExpression, this.treeDataTemp[0]);
            //若只包含关系项则返回空
            if (this.filterExpression.expressItems.length == 0)
                return null;
            else {
                if (this.filterExpression.relationOperator == null) {
                    this.filterExpression.relationOperator = RelationTypeEnum.Or;
                }
                return JSON.stringify(this.filterExpression);
            }
        }
    }
    //递归检查整个过滤表达式是否有漏填的项
    /**
     * @param {?} treeNodes
     * @param {?} isNull
     * @return {?}
     */
    checkNull(treeNodes, isNull) {
        for (var i = 0; i < treeNodes.length; i++) {
            if (treeNodes[i].data.item == this.localePipe.transform('And') || treeNodes[i].data.item == this.localePipe.transform('Or')) {
                if (!(treeNodes[i].children) || treeNodes[i].children.length == 0) {
                    this.checkFilterStruc = false;
                    this.notifyservice[this.notifies['3'].type]({
                        msg: this.notifies['3'].msg
                    });
                    isNull = false;
                    break;
                }
                else if (!this.checkNull(treeNodes[i].children, isNull)) {
                    isNull = false;
                    break;
                }
            }
            else {
                if (!(treeNodes[i].data.item) || treeNodes[i].data.item == this.localePipe.transform("SelectProperty")
                    || !(treeNodes[i].data.operator) || !(treeNodes[i].data.expressType)
                    || !(treeNodes[i].data.value)) {
                    this.notifyservice[this.notifies['4'].type]({
                        msg: this.notifies['4'].msg
                    });
                    this.checkFilterStruc = false;
                    isNull = false;
                    break;
                }
            }
        }
        return isNull;
    }
    /**
     * @return {?}
     */
    onfocus() {
        this.displayPopup = true;
    }
    /**
     * @return {?}
     */
    onblur() {
        this.displayPopup = false;
    }
    /**
     * @param {?} treeNodes
     * @param {?} isMatch
     * @return {?}
     */
    checkMatch(treeNodes, isMatch) {
        for (var i = 0; i < treeNodes.length; i++) {
            if (treeNodes[i].data.item != this.localePipe.transform('And') && treeNodes[i].data.item != this.localePipe.transform('Or')) {
                if (treeNodes[i].data.expressType == this.localePipe.transform("Value")) {
                    if ((treeNodes[i].data.propertyDataType == PropertyDataType.Int16 || treeNodes[i].data.propertyDataType == PropertyDataType.Int32 || treeNodes[i].data.propertyDataType == PropertyDataType.Int64) && isNaN(treeNodes[i].data.value)) {
                        this.notifyservice[this.notifies['5'].type]({
                            msg: this.notifies['5'].msg
                        });
                        isMatch = false;
                        break;
                    }
                }
            }
            else
                isMatch = this.checkMatch(treeNodes[i].children, isMatch);
        }
        return isMatch;
    }
}
FilterExpressionComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-filter-expression',
                template: "<div class=\"filter \">   \r\n    <farris-treetable #tt\r\n    class=\"farristreetable\"\r\n    [data]=\"treeData\" \r\n    [columns]=\"cols\" \r\n    [idField]=\"'id'\" \r\n    [showIcon]=\"false\" \r\n    [resizableColumns]=\"true\"\r\n    (nodeSelected)=\"nodeSelected($event)\" \r\n    [fitColumns]=\"true\" \r\n    [showFilterBar]=\"false\"\r\n    [showHeader]=\"true\"\r\n    [enableFindText]=\"true\"\r\n    [fit]=\"true\"\r\n    [disabled]=\"disabled\"\r\n    [fixedHeader]=\"true\"\r\n    [showBorder]=\"false\"\r\n    >\r\n      <ng-template farrisTemplate=\"body\" let-rowNode let-rowData=\"rowData\" let-columns=\"columns\">\r\n        <tr [selectRow]=\"rowNode\" [dblclick]=\"true\">\r\n          <td *ngFor=\"let col of columns; let i = index\"\r\n          [ngStyle]=\"{'text-align':col.title=='' ?'center':'left'}\">\r\n          <div class=\"treetable-cell-content p-0 d-flex\">\r\n            <farris-treeTableToggler [rowNode]=\"rowNode\" *ngIf=\"i == 0\"></farris-treeTableToggler>\r\n            <ng-container *ngIf=\"i==0\">\r\n              <div class=\"flex-grow-1 text d-flex\">\r\n                <span id=\"groupAnd\" *ngIf=\"rowData['item']==this.localePipe.transform('And') || rowData['item']==null\"><img src='/platform/common/web/assets/filter-icon/and.svg'></span>\r\n                <span id=\"groupOr\" *ngIf=\"rowData['item']==this.localePipe.transform('Or')\"><img src='/platform/common/web/assets/filter-icon/or.svg'></span>\r\n                <div class=\"flex-grow-1 text\">\r\n                <farris-combo-list *ngIf=\"(rowData['item']==this.localePipe.transform('Or') || rowData['item']==this.localePipe.transform('And') || rowData['item']==null)&& rowData['displaySelect']\"\r\n     \r\n                [(ngModel)]=\"defaultSelectGroup\"\r\n                [idField]=\"'id'\"\r\n                [textField]=\"'id'\"\r\n                [data]=\"relations\" \r\n                (selectChange)=\"selectGroup($event)\">\r\n                </farris-combo-list>\r\n                \r\n                <farris-combo-list *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displaySelect']\"\r\n              \r\n                [(ngModel)]=\"defaultSelectItem\"\r\n                [idField]=\"'value'\"\r\n                [textField]=\"'text'\"\r\n                [data]=\"propertyListInner\" \r\n                (selectChange)=\"selectItem($event)\">\r\n                </farris-combo-list>\r\n              \r\n                <ng-container *ngIf=\"!rowData['displaySelect']\">\r\n                  <span>{{rowData[col.field]}}</span>\r\n                </ng-container>\r\n              </div>\r\n            </div>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"i==1\">\r\n              <farris-combo-list *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displayExpressType']\"\r\n                [(ngModel)]=\"defaultOperatorText\"\r\n                [idField]=\"'id'\"\r\n                [textField]=\"'id'\"\r\n                [data]=\"operators\"\r\n                [panelHeight]=200\r\n                (selectChange)=\"selectOperator($event)\">\r\n              </farris-combo-list>\r\n              <ng-container *ngIf=\"!rowData['displayOperator']\">\r\n                {{rowData[col.field]}}\r\n              </ng-container>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"i==2\">\r\n              <farris-combo-list *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displayExpressType']\"\r\n                [(ngModel)]=\"defaultExpressTypeText\"\r\n                [idField]=\"'id'\"\r\n                [textField]=\"'id'\"\r\n                [data]=\"expressTypes\"\r\n                (selectChange)=\"selectExpressType($event)\">\r\n              </farris-combo-list>\r\n              <ng-container *ngIf=\"!rowData['displayExpressType']\">\r\n                {{rowData[col.field]}}\r\n              </ng-container>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"i==3\">\r\n              <ng-container *ngIf=\"rowData['item']!=this.localePipe.transform('Or') && rowData['item']!=this.localePipe.transform('And') && rowData['item']!=null && rowData['displayValue']\">\r\n              <div class=\"input-group\">\r\n                <input type=\"text\" class=\"form-control\" placeholder=\"{{ 'PlaceHolder' | locale }}\" aria-describedby=\"button-addon\" [(ngModel)]=\"rowData['value']\"/>\r\n                <button *ngIf=\"rowData['expressType']==this.localePipe.transform('Expression')\" class=\"btn btn-outline-secondary\" style=\"border: none;width: 25px;padding-left: 4px\" type=\"button\" id=\"button-addon\" (click)=\"openExpressEditor()\"><span class=\"f-icon f-icon-windows\"></span></button>\r\n              </div>\r\n              </ng-container>\r\n              <ng-container *ngIf=\"!rowData['displayValue']\">\r\n                <span style=\"display: inline-block;overflow: hidden;width: 100%\">{{rowData[col.field]}}</span>\r\n              </ng-container>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"i==4\">\r\n                <div class=\"btn-group mr-3\" fDropdown>\r\n                  <button class=\"btn btn-link\" fDropdownToggle type=\"button\">\r\n                    {{ 'Add' | locale }}\r\n                  </button>\r\n                  <div class=\"dropdown-menu\" fDropdownMenu>\r\n                    <li class=\"dropdown-item\" (click)=\"addGroup()\"><span>{{ 'AddGroup' | locale }}</span></li>\r\n                    <li class=\"dropdown-item\" (click)=\"addItem()\"><span>{{ 'AddItem' | locale }}</span></li>\r\n                  </div>\r\n                </div>\r\n                <button style=\"padding-left: 16px;\" type=\"button\" class=\"btn btn-link\" (click)=\"deleteNode(rowData['id'])\">{{ 'Delete' | locale }}</button> \r\n            </ng-container>\r\n          </div>\r\n          </td>\r\n        </tr>\r\n      </ng-template>\r\n    </farris-treetable>\r\n</div>\r\n",
                providers: [ExpressionService, PropertyAdapter],
                encapsulation: ViewEncapsulation.None,
                styles: [".lpopup kendo-button-list{height:250px;overflow-y:auto}.footer{position:fixed;bottom:0;left:0;right:0}.farristreetable .farris-treetable .farris-treetable-tbody tr td{overflow:inherit}.filter{height:100%}"]
            }] }
];
/** @nocollapse */
FilterExpressionComponent.ctorParameters = () => [
    { type: ExpressionService },
    { type: PropertyAdapter },
    { type: NotifyService },
    { type: Injector },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
FilterExpressionComponent.propDecorators = {
    tt: [{ type: ViewChild, args: ['tt',] }],
    contextEntity: [{ type: Input }],
    expressionText: [{ type: Input }],
    expressionSchema: [{ type: Input }],
    expressionInjectedEntities: [{ type: Input }],
    expressionCDT: [{ type: Input }],
    propertyList: [{ type: Input }],
    filterExpressionString: [{ type: Input }],
    schemaName: [{ type: Input }],
    schema: [{ type: Input }],
    newSchema: [{ type: Input }],
    injectedEntity: [{ type: Input }],
    gspCommonObject: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = localStorage.getItem('languageCode') || 'zh-CHS';
class FilterConditionModule {
}
FilterConditionModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    DropDownsModule,
                    ButtonModule,
                    DropDownButtonModule,
                    InputsModule,
                    FormsModule,
                    PopupModule,
                    ComboListModule,
                    ExpressionModule,
                    TreeTableModule,
                    InputGroupModule,
                    NotifyModule,
                    FDropdownDirectiveTypeModule,
                    ModalModule.forRoot(),
                ],
                declarations: [FilterConditionComponent, FilterExpressionComponent, FilterConditionLocalePipe],
                entryComponents: [FilterConditionComponent, FilterExpressionComponent],
                exports: [FilterConditionComponent, FilterExpressionComponent],
                providers: [
                    BsModalService,
                    { provide: LOCALE_ID, useValue: ɵ0 }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { FilterConditionModule, FilterService, PropertyEntity, PropertyDataType, FilterExpressionComponent, FilterConditionComponent, FilterEntitySchema, FilterEntityType, FilterEntitySet, FilterInjectedType, FilterInjectedEntity, FilterExpressionBase, FilterExpression, ExpressionItem, NavigationProperty, NavigationType, ExpressTypeEnum, RelationTypeEnum, FilterConditionLocalePipe as ɵb, PropertyAdapter as ɵa };

//# sourceMappingURL=gsp-svc-filtercondition.js.map