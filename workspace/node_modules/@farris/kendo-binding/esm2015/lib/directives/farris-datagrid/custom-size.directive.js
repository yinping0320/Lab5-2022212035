import { ChangeDetectorRef, Directive, ElementRef, Injector, Input } from '@angular/core';
import { DatagridComponent } from '@farris/ui-datagrid';
import { FrameContext } from '@farris/devkit';
export class CustomDatagridSizeDirective {
    constructor(dg, injector, cd, el, frameContext) {
        this.dg = dg;
        this.injector = injector;
        this.cd = cd;
        this.el = el;
        this.frameContext = frameContext;
        this.useCustomSize = false;
        this.sizeApiUri = '';
    }
    restService() {
        return this.frameContext.repository.restService;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (changes.sizeApiUri && !changes.sizeApiUri.isFirstChange()) {
            this.applyNewSize();
        }
    }
    ngAfterViewInit() {
        this.applyNewSize();
    }
    applyNewSize() {
        if (this.useCustomSize && this.sizeApiUri) {
            this.getSizeConfig().subscribe((cfg) => {
                if (this.dg && typeof this.dg.applyNewSize === 'function') {
                    this.dg.applyNewSize(cfg);
                }
            });
        }
    }
    getSizeConfig() {
        return this.restService().request(this.sizeApiUri, 'get');
    }
}
CustomDatagridSizeDirective.decorators = [
    { type: Directive, args: [{ selector: '[custom-size]' },] }
];
/** @nocollapse */
CustomDatagridSizeDirective.ctorParameters = () => [
    { type: DatagridComponent },
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: FrameContext }
];
CustomDatagridSizeDirective.propDecorators = {
    useCustomSize: [{ type: Input, args: ['custom-size',] }],
    sizeApiUri: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLXNpemUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZhcnJpcy9rZW5kby1iaW5kaW5nLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZmFycmlzLWRhdGFncmlkL2N1c3RvbS1zaXplLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWlCLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBb0MsTUFBTSxlQUFlLENBQUM7QUFDM0ksT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBYzlDLE1BQU0sT0FBTywyQkFBMkI7SUFRdEMsWUFBb0IsRUFBcUIsRUFBVSxRQUFrQixFQUFVLEVBQXFCLEVBQVUsRUFBYyxFQUNsSCxZQUEwQjtRQURoQixPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQUFVLGFBQVEsR0FBUixRQUFRLENBQVU7UUFBVSxPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQUFVLE9BQUUsR0FBRixFQUFFLENBQVk7UUFDbEgsaUJBQVksR0FBWixZQUFZLENBQWM7UUFSZCxrQkFBYSxHQUFHLEtBQUssQ0FBQztRQUNuQyxlQUFVLEdBQUcsRUFBRSxDQUFDO0lBT2UsQ0FBQztJQUxqQyxXQUFXO1FBQ2pCLE9BQVEsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUE0QixDQUFDLFdBQVcsQ0FBQztJQUNyRSxDQUFDO0lBS0QsUUFBUTtJQUVSLENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxPQUFPLENBQUMsVUFBVSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsRUFBRTtZQUM3RCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDckI7SUFDSCxDQUFDO0lBRUQsZUFBZTtRQUNiLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRU8sWUFBWTtRQUNsQixJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUN6QyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBZSxFQUFFLEVBQUU7Z0JBQ2pELElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxLQUFLLFVBQVUsRUFBRTtvQkFDekQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzNCO1lBQ0gsQ0FBQyxDQUFDLENBQUM7U0FDSjtJQUNILENBQUM7SUFHTyxhQUFhO1FBQ25CLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzVELENBQUM7OztZQXZDRixTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFOzs7O1lBZC9CLGlCQUFpQjtZQUR3QyxRQUFRO1lBQWxELGlCQUFpQjtZQUFhLFVBQVU7WUFFdkQsWUFBWTs7OzRCQWVsQixLQUFLLFNBQUMsYUFBYTt5QkFDbkIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT25Jbml0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRGF0YWdyaWRDb21wb25lbnQgfSBmcm9tICdAZmFycmlzL3VpLWRhdGFncmlkJztcclxuaW1wb3J0IHsgRnJhbWVDb250ZXh0IH0gZnJvbSAnQGZhcnJpcy9kZXZraXQnO1xyXG5pbXBvcnQgeyBCZWZSZXBvc2l0b3J5LCBCZWZSZXN0U2VydmljZSB9IGZyb20gJy4uL2FwcG9pbnRtZW50LWNhbGVuZGFyL3R5cGVzJztcclxuXHJcbnR5cGUgU2l6ZUNvbmZpZyA9IHtcclxuICAnaGVhZGVySGVpZ2h0Jz86IG51bWJlcixcclxuICAnZm9vdGVySGVpZ2h0Jz86IG51bWJlcixcclxuICAncm93SGVpZ2h0Jz86IG51bWJlcixcclxuICAnY2hlY2tib3hDb2x1bW5XaWR0aCc/OiBudW1iZXIsXHJcbiAgJ2xpbmVOdW1iZXJXaWR0aCc/OiBudW1iZXIsXHJcbiAgJ2ZpbHRlclJvd0hlaWdodCc/OiBudW1iZXJcclxufTtcclxuXHJcblxyXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY3VzdG9tLXNpemVdJyB9KVxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tRGF0YWdyaWRTaXplRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMge1xyXG4gIEBJbnB1dCgnY3VzdG9tLXNpemUnKSB1c2VDdXN0b21TaXplID0gZmFsc2U7XHJcbiAgQElucHV0KCkgc2l6ZUFwaVVyaSA9ICcnO1xyXG5cclxuICBwcml2YXRlIHJlc3RTZXJ2aWNlKCk6IEJlZlJlc3RTZXJ2aWNlIHtcclxuICAgIHJldHVybiAodGhpcy5mcmFtZUNvbnRleHQucmVwb3NpdG9yeSBhcyBCZWZSZXBvc2l0b3J5KS5yZXN0U2VydmljZTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGc6IERhdGFncmlkQ29tcG9uZW50LCBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvciwgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXHJcbiAgICBwcml2YXRlIGZyYW1lQ29udGV4dDogRnJhbWVDb250ZXh0KSB7IH1cclxuXHJcbiAgbmdPbkluaXQoKTogdm9pZCB7XHJcblxyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgaWYgKGNoYW5nZXMuc2l6ZUFwaVVyaSAmJiAhY2hhbmdlcy5zaXplQXBpVXJpLmlzRmlyc3RDaGFuZ2UoKSkge1xyXG4gICAgICB0aGlzLmFwcGx5TmV3U2l6ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5hcHBseU5ld1NpemUoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXBwbHlOZXdTaXplKCkge1xyXG4gICAgaWYgKHRoaXMudXNlQ3VzdG9tU2l6ZSAmJiB0aGlzLnNpemVBcGlVcmkpIHtcclxuICAgICAgdGhpcy5nZXRTaXplQ29uZmlnKCkuc3Vic2NyaWJlKChjZmc6IFNpemVDb25maWcpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5kZyAmJiB0eXBlb2YgdGhpcy5kZy5hcHBseU5ld1NpemUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHRoaXMuZGcuYXBwbHlOZXdTaXplKGNmZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBwcml2YXRlIGdldFNpemVDb25maWcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXN0U2VydmljZSgpLnJlcXVlc3QodGhpcy5zaXplQXBpVXJpLCAnZ2V0Jyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==