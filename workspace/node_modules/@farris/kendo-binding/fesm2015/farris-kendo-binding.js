import { NumberHelperService } from '@farris/ui-common/number';
import { DropDownListComponent, ComboBoxComponent } from '@progress/kendo-angular-dropdowns';
import { FFilePreviewComponent, UploadAndPreviewComponent } from '@farris/extend-file-upload';
import { TreeTable } from 'primeng/treetable';
import { DateTimeHelperService } from '@farris/ui-common/date';
import { EditorComponent } from '@farris/ui-editor';
import { QuerySolutionComponent } from '@gsp-cmp/querysolution';
import { TextComponent } from '@farris/ui-text';
import { ListNavComponent } from '@farris/ui-list-nav';
import { ListViewComponent } from '@farris/ui-list-view';
import { ViewChangeComponent } from '@farris/ui-view-change';
import { HtmlEditorComponent } from '@farris/ui-html-editor';
import { FarrisSectionComponent } from '@farris/ui-section';
import { InputGroupComponent } from '@farris/ui-input-group';
import { FarrisDatepickerComponent } from '@farris/ui-datepicker';
import { TimePickerComponent } from '@farris/ui-time-picker';
import { NumberSpinnerComponent } from '@farris/ui-number-spinner';
import { ComboListComponent } from '@farris/ui-combo-list';
import { LookupGridComponent } from '@farris/ui-lookup';
import { TreeTableComponent } from '@farris/ui-treetable';
import { WizardComponent } from '@farris/ui-wizard';
import { DiscussionEditorComponent, DiscussionListComponent, DiscussionListDirective } from '@farris/discussion-group';
import { NavComponent } from '@farris/ui-nav';
import { MultiSelectComponent } from '@farris/ui-multi-select';
import { ScrollspyComponent } from '@farris/ui-scrollspy';
import { ComboLookupComponent } from '@farris/ui-combo-lookup';
import { AppointmentCalendarComponent } from '@farris/appointment-calendar';
import { isNumber, isEqual } from 'lodash-es';
import { DatagridComponent } from '@farris/ui-datagrid';
import { FilterComponent } from '@farris/ui-filter';
import { ListFilterComponent } from '@farris/ui-list-filter';
import { of, Subject, BehaviorSubject, EMPTY } from 'rxjs';
import { debounceTime, finalize, tap, catchError, takeUntil } from 'rxjs/operators';
import { DownloadService } from '@gsp-svc/formdoc-upload';
import { BasePathService } from '@farris/rtf';
import { LocaleService } from '@farris/ui-locale';
import { ColumnFormatService } from '@farris/ui-common/column';
import { DateUtil, ViewModel, BindingData, ChangeType, FrameEventBus, UIState, ComponentType, FrameContext, DataTypeInfo, EntityPathConverter, RunMode, ExpressionUtil, ENABLE_EDIT_STATE_FILTER_SORTING, AppContext, BindingList, UserSettingsToken } from '@farris/devkit';
import { BigNumber } from 'bignumber.js';
import moment from 'moment';
import { DialogService } from '@farris/ui-dialog';
import { Injectable, Pipe, Directive, Input, HostListener, NgZone, Optional, EventEmitter, Output, ContentChildren, Self, Host, KeyValueDiffers, ElementRef, Renderer2, Injector, Inject, ChangeDetectorRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FilterService, BaseFilterCellComponent, ColumnComponent, GridComponent, DataBindingDirective, SelectionDirective } from '@progress/kendo-angular-grid';
import { RuntimeStateService, FarrisCommonModule } from '@farris/ui-common';

class ArrayConverter {
    constructor(separator = ',') {
        this.separator = separator;
    }
    convertFrom(value) {
        return value.split(this.separator);
    }
    convertTo(value) {
        return value.join(this.separator);
    }
}

/*
 * @Author: Witt
 * @Date: 2018-10-29 10:26:58
 * @Last Modified by: Witt
 * @Last Modified time: 2018-10-29 15:49:12
 */
/**
 * 日期转换器
 */
class DateConverter {
    /**
     * 构造函数
     * @param format 日期格式
     */
    constructor(format) {
        this.format = format;
    }
    /**
     * 字符串=> 日期
     * @param value 待转换的值
     */
    convertFrom(value) {
        if (DateUtil.isEmptyDateString(value) === true) {
            return null;
        }
        return DateUtil.parse(value);
    }
    /**
     * 日期=>字符串
     * @param value
     */
    convertTo(value) {
        if (!value) {
            return null;
        }
        // 如果value不是日期类型，则不做处理，返回原始value
        if (Object.prototype.toString.call(value) !== '[object Date]') {
            return value;
        }
        // 年
        let year = value.getFullYear().toString();
        year = year.length < 4 ? '0'.repeat(4 - year.length) + year : year;
        // 月
        let month = (value.getMonth() + 1).toString();
        month = month.length === 1 ? ('0' + month) : month;
        // 日
        let day = value.getDate().toString();
        day = day.length === 1 ? ('0' + day) : day;
        // 时分秒
        let hours = value.getHours().toString();
        hours = hours.length === 1 ? ('0' + hours) : hours;
        let minutes = value.getMinutes().toString();
        minutes = minutes.length === 1 ? ('0' + minutes) : minutes;
        let seconds = value.getSeconds().toString();
        seconds = seconds.length === 1 ? ('0' + seconds) : seconds;
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }
}

/**
 * 多语言转换器
 */
class MultiLangConverter {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 将数据源中的原始值=>多语控件识别的对象值
     */
    convertFrom(value) {
        const multiLangControlValue = Object.assign({}, value);
        return multiLangControlValue;
    }
    /**
     * 多语控件识别的对象值=>将数据源中的原始值
     */
    convertTo(multiLangControlValue) {
        const value = multiLangControlValue;
        return value;
    }
}

class FilterConditionsConverter {
    constructor() {
    }
    convertFrom(conditionsString) {
        if (!conditionsString) {
            return [];
        }
        return JSON.parse(conditionsString);
    }
    convertTo(conditions) {
        return JSON.stringify(conditions);
    }
}

class FarrisKendoGridFormatService {
    constructor(dateService, numberService) {
        this.dateService = dateService;
        this.numberService = numberService;
    }
    /**
     * 列格式化 方法
     * @param dataItem  行数据
     * @param column 列对象
     */
    getColumnFormat(dataItem, column) {
        const value = this.getValue(dataItem, column['dataField']);
        // 没有设置行编辑器
        const type = column['dataType'];
        if (type === 'enum') {
            return this.getEnumText(value, column);
        }
        else if (type === 'boolean') {
            return value ? '是' : '否';
        }
        else if (type === 'date') {
            return this.getFormatDate(value, column);
        }
        else if (type === 'number') {
            return this.getFormatNumber(value, column);
        }
        else {
            // 格式化多行文本  和string
            return this.getMultiText(value, column);
        }
    }
    /**
     * 根据id获取value
     * @param dataItem  行数据
     * @param field id,也可能是name.Name这种形式(关联对象id或者udt)
     */
    getValue(dataItem, field) {
        const index = field.indexOf('.');
        if (index < 0) {
            return dataItem[field];
        }
        const fields = field.split('.');
        // field字符串组合
        const a = fields.reduce((result, next) => {
            return result[next];
        }, dataItem);
        return a;
    }
    /**
     * 枚举值格式化
     */
    getEnumText(value, column) {
        const enumData = column.enumData;
        if (!enumData) {
            return;
        }
        let tempColumnText;
        enumData.forEach((ele) => {
            if (ele.value === value) {
                tempColumnText = ele.name;
            }
        });
        return tempColumnText;
    }
    /**
     * 日期格式化
     * @param value  单元格值
     * @param column 列对象
     */
    getFormatDate(value, column) {
        if (DateUtil.isEmptyDateString(value) === true) {
            return '';
        }
        const dateFormat = column.format;
        if (!dateFormat) {
            return value;
        }
        return this.dateService.formatTo(value, dateFormat);
    }
    /**
     * 数字格式化
     * @param value  单元格值
     * @param column 列对象
     * @todo 数字格式化还不完善  这个只是金额形式的格式化;   初始化value===null时,应该显示为'' 这个还没有
     */
    getFormatNumber(value, column) {
        let precision;
        if (column && column.format) {
            precision = parseInt(column.format.substr(1), 10);
        }
        else if (column && column.editor) {
            precision = column.editor.precision;
        }
        if (isNaN(precision)) {
            precision = 2;
        }
        if (!value && value !== 0) {
            return '';
        }
        const opts = {
            prefix: column.prefix ? column.prefix : '',
            suffix: column.suffix ? column.suffix : '',
            precision: precision,
            thousand: ',',
            stripZeros: false,
        };
        return this.numberService.formatMoney(value, opts);
    }
    /**
     * 多行文本格式化 shift+enter换行  失去焦点保留原格式
     * @param value  单元格值
     * @param column 列对象
     */
    getMultiText(value, column) {
        let strValue = value;
        if (strValue !== '' && !strValue) {
            strValue = '';
        }
        if (typeof strValue !== 'string') {
            const valueType = typeof strValue;
            throw new Error(`${valueType}类型值不合法，无法进行格式化`);
        }
        // 防止xss
        strValue = strValue.replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\"/g, '&quot;')
            .replace(/\'/g, '&#39;')
            .replace(/\//g, '&#x2F;');
        // 如果是多行文本框  保留格式
        if (column.editor && column.editor.type === 'MultiTextBox') {
            const INDEX = strValue.indexOf('\n');
            if (INDEX > -1) {
                return strValue.replace(/\n/g, '<br>');
            }
            return strValue;
        }
        // 若为string
        return strValue;
    }
}
FarrisKendoGridFormatService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FarrisKendoGridFormatService.ctorParameters = () => [
    { type: DateTimeHelperService },
    { type: NumberHelperService }
];

class FarrisTreetableFormatService {
    constructor() {
    }
    setFormat(treeTable) {
        const columns = treeTable.columns;
        columns.forEach((column) => {
            const dataType = column.dataType;
            if (!column.formatter) {
                if (dataType === 'date') {
                    column.formatter = {
                        type: 'datetime',
                        options: {
                            format: column.format
                        }
                    };
                }
                else if (dataType === 'number') {
                    column.formatter = {
                        type: 'number',
                        options: {
                            prefix: column.prefix ? column.prefix : '',
                            suffix: column.suffix ? column.suffix : '',
                            precision: column.precision,
                            thousand: ',',
                            stripZeros: false,
                        }
                    };
                }
                else if (dataType === 'enum') {
                    column.formatter = {
                        type: 'enum',
                        options: {
                            data: column.enumData,
                            valueField: 'value',
                            textField: 'name'
                        }
                    };
                }
                else if (dataType === 'boolean') {
                    column.formatter = {
                        type: 'enum',
                        options: {
                            data: [{ name: '是', value: true }, { name: '否', value: false }],
                            valueField: 'value',
                            textField: 'name'
                        }
                    };
                }
            }
        });
    }
}
FarrisTreetableFormatService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FarrisTreetableFormatService.ctorParameters = () => [];

class StringToDatePipe {
    transform(value, exponent) {
        if (DateUtil.isEmptyDateString(value) === true) {
            return null;
        }
        if (value.includes('年')) {
            const strDate = value.replace('年', '-').replace('月', '-').replace('日', '');
            return new Date(strDate);
        }
        return new Date(value);
    }
}
StringToDatePipe.decorators = [
    { type: Pipe, args: [{ name: 'parseStrToDate' },] }
];

class KendoGridFilterDirective extends BaseFilterCellComponent {
    constructor(dropdownList, filterService) {
        super(filterService);
        this.dropdownList = dropdownList;
        this.filterService = filterService;
    }
    get selectedValue() {
        const filter = this.filterByField(this.column.dataField);
        return filter ? filter.value : null;
    }
    get defaultItem() {
        return {
            value: null,
            name: '全部'
        };
    }
    ngOnInit() {
        this.dropdownList.valueField = 'value';
        this.dropdownList.textField = 'name';
        this.dropdownList.valuePrimitive = true;
        this.dropdownList.defaultItem = this.defaultItem;
        this.dropdownList.value = this.selectedValue;
        if (this.column.dataType === 'enum') {
            this.dropdownList.data = this.column.enumData;
        }
        else if (this.column.dataType === 'boolean') {
            this.dropdownList.data = [{ value: true, name: '是' }, { value: false, name: '否' }];
        }
    }
    onChange(value) {
        this.applyFilter(value === null ?
            this.removeFilter(this.column.dataField) :
            this.updateFilter({
                field: this.column.dataField,
                operator: 'eq',
                value: value
            }));
    }
    /*
   * 获取 单元格值  主从表支持
   * @param dataItem 行数据
   * @param field 字段
   */
    getValue(dataItem, field) {
        const index = field.indexOf('.');
        if (index < 0) {
            return dataItem[field];
        }
        const fields = field.split('.');
        // field字符串组合
        return fields.reduce((result, next) => {
            return result[next];
        }, dataItem);
    }
}
KendoGridFilterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendogridFilter]'
            },] }
];
/** @nocollapse */
KendoGridFilterDirective.ctorParameters = () => [
    { type: DropDownListComponent },
    { type: FilterService }
];
KendoGridFilterDirective.propDecorators = {
    filter: [{ type: Input }],
    column: [{ type: Input }],
    onChange: [{ type: HostListener, args: ['valueChange', ['$event'],] }]
};

class DateFormatPlaceholderPipe {
    constructor(viewModel) {
        this.viewModel = viewModel;
    }
    transform(format, controlName) {
        if (!this.viewModel.form || !this.viewModel.form.get(controlName)) {
            return {
                year: '年',
                month: '月',
                day: '日'
            };
        }
        const value = this.viewModel.form.get(controlName).value;
        let dateStr = value;
        if (dateStr) {
            dateStr = value.toISOString();
        }
        if ((DateUtil.isEmptyDateString(dateStr) === true) && format === 'yyyy年MM月dd日') {
            return {
                year: ' ',
                month: ' ',
                day: ' '
            };
        }
        return {
            year: '年',
            month: '月',
            day: '日'
        };
    }
}
DateFormatPlaceholderPipe.decorators = [
    { type: Pipe, args: [{ name: 'dateFormatPlaceholder' },] }
];
/** @nocollapse */
DateFormatPlaceholderPipe.ctorParameters = () => [
    { type: ViewModel }
];

class FormatTotalPipe {
    transform(value, exponent) {
        // 判断值是否合法
        if (!value && value !== 0) {
            return '';
        }
        if (exponent.dataType === 'number') {
            // 保留小数点后几位
            const dataFormat = exponent.format;
            return value.toFixed(Number(dataFormat.substring(1)));
        }
        return value;
    }
}
FormatTotalPipe.decorators = [
    { type: Pipe, args: [{ name: 'formatTotal' },] }
];

class GridColumnAggregateDirective {
    constructor(column, ngZone) {
        this.column = column;
        this.ngZone = ngZone;
    }
    get field() {
        return this.column.field;
    }
    get aggrType() {
        let type = 'none';
        if (typeof (this.aggregate) === 'boolean') {
            // 默认为sum，如果使用指令时传入的input为布尔类型，使用sum。
            if (this.aggregate) {
                type = 'sum';
            }
        }
        else if (typeof (this.aggregate) === 'string') {
            type = this.aggregate;
        }
        return type;
    }
    recalculateSummary(bindingList) {
        let summary = null;
        if (this.aggrType === 'sum') {
            const plainData = bindingList.toJSON().map(item => {
                // 考虑帮助和udt的情况，field是a.b的格式。
                return this.field.split('.').reduce((prevPath, currPath) => {
                    return prevPath[currPath];
                }, item);
            });
            if (plainData && plainData.length) {
                summary = plainData.reduce((prev, curr) => {
                    return prev + curr;
                });
            }
        }
        else if (this.aggrType === 'count') {
            // 计数，如果启用分页，只计算当前页，因此使用length而非total。
            summary = bindingList.length;
        }
        this.updateFooter(summary);
    }
    updateFooter(content) {
        if (this.aggregate) {
            // 存在性能问题，去掉setTimeout。
            // 列表的列越多，此处问题越严重，需要正向解决以下错误。
            // todo: settimeout是为了解决数据变化时angular报错，如果更新页脚的逻辑不在gridbinding发起，是否还存在问题？
            // setTimeout(() => {
            this.column['summary'] = content;
            // });
        }
    }
}
GridColumnAggregateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[aggregate]',
            },] }
];
/** @nocollapse */
GridColumnAggregateDirective.ctorParameters = () => [
    { type: ColumnComponent },
    { type: NgZone }
];
GridColumnAggregateDirective.propDecorators = {
    aggregate: [{ type: Input }]
};
class GridSummaryDirective /* implements OnInit, AfterViewInit*/ {
    constructor(bindingData) {
        this.bindingData = bindingData;
    }
}
GridSummaryDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisSummary]'
            },] }
];
/** @nocollapse */
GridSummaryDirective.ctorParameters = () => [
    { type: BindingData }
];
GridSummaryDirective.propDecorators = {
    summary: [{ type: Input, args: ['farrisSummary',] }]
};

/**
 * 多选列表工具类
 */
class MultiSelectGridUtility {
    /**
     * 渲染切换行
     */
    static renderClickChangedRow(gridComponent, selectedRowContext) {
        if (!gridComponent) {
            return;
        }
        const currentRowIndex = selectedRowContext.currentRowIndex;
        // 渲染当前行
        this.addRowSelectedStyle(gridComponent, currentRowIndex);
        // 渲染上一行
        const lastRowIndex = selectedRowContext.lastRowIndex;
        if (!this.checIfIsSameRelativeIndex(gridComponent, currentRowIndex, lastRowIndex)) {
            this.removeRowSelectedStyle(gridComponent, lastRowIndex);
        }
    }
    /**
     * 检查当前行索引值和上一个选中行索引值的相对当前页面的索引值是否相同
     */
    static checIfIsSameRelativeIndex(gridComponent, currentRowIndex, lastRowIndex) {
        let isSameRelativeIndex = false;
        if (currentRowIndex === lastRowIndex) {
            isSameRelativeIndex = true;
            return isSameRelativeIndex;
        }
        if ((Math.abs(currentRowIndex - lastRowIndex)) % (gridComponent.pageSize) === 0) {
            isSameRelativeIndex = true;
            return isSameRelativeIndex;
        }
        return isSameRelativeIndex;
    }
    /**
     * 检测是否启用分页功能
     */
    static checkIfEnablePaging(gridComponent) {
        let isPageable = false; // 默认未启用分页
        if (!gridComponent) {
            return isPageable;
        }
        if (typeof gridComponent.pageable === 'boolean') {
            isPageable = gridComponent.pageable;
        }
        else if (typeof gridComponent.pageable === 'object') {
            isPageable = true;
        }
        return isPageable;
    }
    /**
     * 渲染checkbox选择
     */
    static renderSelectedChangeCheckbox(elementRef, $event) {
        const currentRowIndex = $event.index;
        const trCollection = this.getTrCollection(elementRef);
        if (trCollection == null || trCollection.length <= 0 || trCollection.length < currentRowIndex) {
            return;
        }
        // 渲染checked行
        const currentTableRowElement = trCollection[currentRowIndex];
        if (!currentTableRowElement) {
            return;
        }
        if ($event.selected) { // checked
            this.appendAtrributeValue(currentTableRowElement, 'class', this.CHECKBOXED_ROW_STYLE_NAME);
        }
        else { // unchecked
            this.removeAttributeSpecificValue(currentTableRowElement, 'class', this.CHECKBOXED_ROW_STYLE_NAME);
        }
    }
    /**
     * 添加行的“已选中样式”
     * 暂无需求，不对外暴露
     */
    static addRowSelectedStyle(gridComponent, rowIndex) {
        if (!gridComponent || rowIndex < 0) {
            return;
        }
        const currentRowElement = this.getRelativeRowInCurrentPage(gridComponent, rowIndex);
        if (!currentRowElement) {
            return;
        }
        this.appendAtrributeValue(currentRowElement, 'class', this.CURRENT_ROW_STYLE_NAME);
    }
    /**
     * 移除行的“已选中样式”
     * 需求：kendo-grid在分页时，不会移除已选中样式
     */
    static removeRowSelectedStyle(gridComponent, rowIndex) {
        if (!gridComponent || rowIndex < 0) {
            return;
        }
        const currentRowElement = this.getRelativeRowInCurrentPage(gridComponent, rowIndex);
        if (!currentRowElement) {
            return;
        }
        this.removeAttributeSpecificValue(currentRowElement, 'class', this.CURRENT_ROW_STYLE_NAME);
    }
    /**
     * 获取指定行在当前页面对应的行元素
     */
    static getRelativeRowInCurrentPage(gridComponent, rowIndex) {
        let rowElementInCurrentPage = null;
        if (!gridComponent || rowIndex < 0) {
            return rowElementInCurrentPage;
        }
        const gridElement = gridComponent.wrapper;
        // 启用分页后，需要更新当前行
        const isPaging = this.checkIfEnablePaging(gridComponent);
        if (isPaging) {
            rowIndex = rowIndex % (gridComponent.pageSize); // 对pageSize取模
        }
        const trCollection = this.getTrCollection(gridElement);
        if (trCollection == null || trCollection.length <= 0) {
            return rowElementInCurrentPage;
        }
        rowElementInCurrentPage = trCollection[rowIndex];
        return rowElementInCurrentPage;
    }
    /**
     * 获取当前grid的tr集合
     */
    static getTrCollection(elementRef) {
        if (!elementRef || !elementRef.nativeElement) {
            return null;
        }
        const kendoGridTbodyElements = elementRef.nativeElement.getElementsByTagName('tbody');
        if (!kendoGridTbodyElements || kendoGridTbodyElements.length <= 0) {
            return null;
        }
        const trCollection = kendoGridTbodyElements[0].getElementsByTagName('tr');
        return trCollection;
    }
    /**
     * 向元素的指定属性追加值
     */
    static appendAtrributeValue(currentElement, attributeName, attributeValue) {
        let newAttributeValue = currentElement.getAttribute(attributeName);
        if (newAttributeValue === null || newAttributeValue === '' || newAttributeValue.length <= 0) {
            newAttributeValue = attributeValue;
        }
        else {
            if (newAttributeValue.indexOf(attributeValue) < 0) { // 存在检测，避免重复添加
                newAttributeValue += ' ' + attributeValue;
            }
        }
        currentElement.setAttribute(attributeName, newAttributeValue);
    }
    /**
     * 移除元数据指定属性的特性属性值
     */
    static removeAttributeSpecificValue(currentElement, attributeName, needRemoveAttributeValue) {
        let lastClassAttributeValue = currentElement.getAttribute(attributeName);
        if (!lastClassAttributeValue) {
            return;
        }
        const index = lastClassAttributeValue.lastIndexOf(needRemoveAttributeValue);
        if (index < 0) {
            return;
        }
        const tempLastClassAttributeValue = lastClassAttributeValue.substring(0, index - 1);
        lastClassAttributeValue = tempLastClassAttributeValue + ' '
            + lastClassAttributeValue.substring(index + needRemoveAttributeValue.length);
        currentElement.setAttribute(attributeName, lastClassAttributeValue);
    }
}
MultiSelectGridUtility.CURRENT_ROW_STYLE_NAME = 'f-state-selected';
MultiSelectGridUtility.CHECKBOXED_ROW_STYLE_NAME = 'f-state-checked';

/**
 * 选中行上下文
 */
class SelectedRowContext {
}

/*
 * Kendo Grid 数据绑定指令
 *
 * TODO:
 * 1、整体刷存在性能问题；
 * 2、选中和当前行没有区分开；
 */
class KendoGridBindingDirective extends DataBindingDirective {
    /**
     * 构造函数
     * @param  grid 宿主Grid
     */
    constructor(bindingData, uiState, eventBus, viewModel, grid, selectionDir, dialogSer, dateService, kendogridFormatSer, rts, ngZone) {
        super(grid);
        this.bindingData = bindingData;
        this.uiState = uiState;
        this.eventBus = eventBus;
        this.viewModel = viewModel;
        this.grid = grid;
        this.selectionDir = selectionDir;
        this.dialogSer = dialogSer;
        this.dateService = dateService;
        this.kendogridFormatSer = kendogridFormatSer;
        this.rts = rts;
        this.ngZone = ngZone;
        /* 行样式事件 */
        // @Input()
        // rowClassName: (context: any) => any;
        // tslint:disable-next-line:no-output-rename
        this.appendRow = new EventEmitter();
        /* 绑定排序事件 */
        this.sortChangeEvent = new EventEmitter();
        /* 行样式事件 */
        this.rowClass = new EventEmitter();
        this.hiddenColLen = 0;
        /**
         * TODO: 从实体获取其默认值
         * 当前行索引值，默认第一个
         */
        this.rowIndex = 0;
        this.columnIndex = 0;
        this.currentSkip = 0;
        /**
         * 是否启用多选，默认未启用
         */
        this.isMultipleSelectionMode = false;
        /**
         * 上一个选中行，默认不存在
         */
        this.lastRowIndex = -1;
        /**
         * 选中行切换事件
         */
        this.selectedRowChange = new EventEmitter();
        /**
         * checkbox选择事件
         */
        this.selectedCheckboxChange = new EventEmitter();
        this.selectionDir.selectedKeys = [];
        this.viewModel.uiState.setPropertyValue('ids', this.selectionDir.selectedKeys);
        const appContext = this.viewModel.frameContext.getFormAppContext();
        if (appContext && appContext.hasOwnProperty('messagePipe')) {
            appContext.messagePipe.subscribe((message) => {
                this.grid.closeCell();
            });
        }
    }
    get gridOption() {
        return this.grid['gridOption'];
    }
    get len() {
        return this.grid.columns.length;
    }
    get IsMultipleSelectionMode() {
        if (!this.grid) {
            return this.isMultipleSelectionMode;
        }
        if (this.grid.selectable) { // 优先尝试从this.grid.selectable获取
            // tslint:disable-next-line: no-string-literal
            if (this.grid.selectable['mode'] === 'multiple') {
                this.isMultipleSelectionMode = true;
            }
            else {
                this.isMultipleSelectionMode = false;
            }
        }
        else {
            if (this.grid.selectableSettings && this.grid.selectableSettings.mode === 'multiple') {
                this.isMultipleSelectionMode = true;
            }
        }
        return this.isMultipleSelectionMode;
    }
    /**
     * 绑定列表(Grid对应数据源)
     */
    get bindingList() {
        // 根实体
        if (this.viewModel.bindingPath === '/' || !this.viewModel.bindingPath) {
            return this.bindingData.list;
        }
        // 子实体
        let bindingPath = this.viewModel.bindingPath.substr(1);
        bindingPath = bindingPath[0].toLowerCase() + bindingPath.substring(1, bindingPath.length);
        const paths = bindingPath.split('/');
        const filteredPaths = paths.filter((part) => {
            return part !== '';
        });
        return this.bindingData.getValue(filteredPaths);
    }
    /**
     * 获取分页信息
     */
    getPagingInfo() {
        const bindingPath = this.viewModel.bindingPath;
        const bindingData = this.viewModel.bindingData;
        let pagingInfo = bindingData.pagingInfo;
        if (bindingPath === '/') {
            return pagingInfo;
        }
        else {
            const bindingPaths = bindingPath.substr(1).split('/').filter(item => !!item && item.length > 0).map(item => {
                return item.substring(0, item.length - 1);
            });
            bindingPaths.forEach(path => {
                pagingInfo = pagingInfo && pagingInfo[path] || {};
            });
            return pagingInfo;
        }
    }
    /**
     * 指令初始化后
     */
    ngOnInit() {
        super.ngOnInit();
        // 初始化state，分组使用。
        this.initDataState();
        this.refreshView();
        if (this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.frameComponent) {
            this.viewModel.frameContext.frameComponent.componentType = ComponentType.kendoGridComponent;
        }
        // 数据变化
        this.bindingChangeSubscription = this.bindingData.changes.subscribe((change) => {
            this.refreshView(change);
            if (change.type === ChangeType.Load) {
                // load时，在多选模式下，需清空选中集合
                if (this.isMultipleSelectionMode) {
                    const isMatch = this.checkIfChangeMatchBindingPath(change);
                    if (isMatch) {
                        // 清空多选集合
                        this.selectionDir.selectedKeys = [];
                        this.viewModel.uiState.setPropertyValue('ids', this.selectionDir.selectedKeys);
                        this.ngZone.runOutsideAngular(() => {
                            // 渲染初始选中行
                            setTimeout(() => {
                                const rowSelectedContext = new SelectedRowContext();
                                const isPageable = MultiSelectGridUtility.checkIfEnablePaging(this.grid);
                                if (isPageable) {
                                    this.rowIndex = this.grid.skip;
                                }
                                else {
                                    this.rowIndex = 0;
                                }
                                rowSelectedContext.currentRowIndex = this.rowIndex;
                                rowSelectedContext.lastRowIndex = this.lastRowIndex;
                                this.handleSelectedRowChange(rowSelectedContext);
                            }, 300);
                        });
                    }
                }
            }
            // TODO: 使用策略模式重构
            // bindingData 同步 SelectedKeys
            if (change.type === ChangeType.Remove) {
                this.syncDeletedKeys(change.value);
            }
            const isMatch = this.checkIfChangeMatchBindingPath(change);
            if (isMatch) {
                this.handleSelectedKeyChange(this.bindingList.currentId);
            }
            // 渲染当前行
            if (isMatch && this.checkCurrentRowIdExists() && change.type === ChangeType.SelectionChanged && !this.dataId) {
                this.renderCurrentRow(this.bindingList.currentId);
            }
            // tslint:disable-next-line: max-line-length
            // FIXME:需要有重置页码的时机
            /*if ((change.type === ChangeType.SelectionChanged || change.type === ChangeType.GlobalSelectionChanged) && this.currentRowId !== this.bindingList.currentId) {
                this.resetPageInfo();
            }*/
            // 触发变更检测
            if (change.type === ChangeType.Load || change.type === ChangeType.SelectionChanged
                || change.type === ChangeType.Append || change.type === ChangeType.Remove) {
                // 触发变更检测
                if (this.grid && this.grid['changeDetectorRef'] && this.grid['changeDetectorRef']['detectChanges']) {
                    this.grid['changeDetectorRef']['detectChanges']();
                }
            }
        });
        if (this.editable === true && this.form === null) {
            throw Error('启用编辑时，必须指定form');
        }
        if (!this.grid || !this.farrisBindingGridOption || !this.farrisBindingGridOption['fields']) {
            return;
        }
        const gridColumns = this.farrisBindingGridOption['fields'];
        const gridOption = this.farrisBindingGridOption;
        // 判断列中是否存在固定列
        gridOption.lockable = (columns) => {
            return columns.some(ele => {
                return ele.frozen;
            });
        };
        this.rowClass.emit(this.grid);
        // 添加列属性或者方法
        gridColumns.forEach((element) => {
            // 自定义超链
            if (element.linkedLabelEnabled && !element.linkEvent) {
                element.linkEvent = () => {
                    return;
                };
            }
            // 若没有自定义格式化方法  每个列对象绑定格式化方法
            if (!element.getColumnFormat) {
                element.getColumnFormat = (dataItem, column) => {
                    return this.kendogridFormatSer.getColumnFormat(dataItem, column);
                };
            }
            // 如果没有自定义类样式 每个列绑定 格式化方法
            if (!element.getClassName) {
                element.getClassName = (dataItem, column) => '';
            }
            // 自定义帮助前后事件
            if (element.editor && element.editor.type === 'LookupEdit') {
                // 帮助前事件
                if (!element.dictPicking) {
                    element.dictPicking = (param) => {
                        return of(true);
                    };
                }
                // 帮助后事件
                if (!element.dictPicked) {
                    element.dictPicked = (param) => {
                        // 重新进入编辑
                        this.cellClickHandler(this.cellClickParam);
                        return of(true);
                    };
                }
            }
        });
        // 绑定gridOption
        this.bindingGridOption();
        // 多选模式下，设置初始选中行
        if (this.IsMultipleSelectionMode) {
            // TODO: 移除 setTimeout
            const self = this;
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    const rowSelectedContext = new SelectedRowContext();
                    rowSelectedContext.currentRowIndex = self.rowIndex;
                    rowSelectedContext.lastRowIndex = self.lastRowIndex;
                    self.handleSelectedRowChange(rowSelectedContext);
                }, 300);
            });
        }
    }
    ngAfterViewInit() {
        // this.gridElement = document.querySelector('.k-grid');
        // // 绑定grid keydown对象的方法
        // this.ngZone.runOutsideAngular(() => {
        //   this.gridKeydownEvent = this.enterCell.bind(this);
        //   this.gridCellClickEvent = this.cellClickHandler.bind(this);
        //   this.gridCellCloseEvent = this.cellCloseHandler.bind(this);
        //   this.gridElement.addEventListener('keydown', this.gridKeydownEvent);
        //   this.gridElement.addEventListener('cellClick', this.gridCellClickEvent);
        //   this.gridElement.addEventListener('cellClose', this.gridCellCloseEvent);
        // });
    }
    /**
     * 检测change的路径和BindingPath是否匹配
     */
    checkIfChangeMatchBindingPath(change) {
        let isMatch = false;
        if (!change || !change.path) {
            return isMatch;
        }
        const changePathArray = change.path;
        if (!changePathArray) {
            return isMatch;
        }
        if (!(this.bindingData) && !(this.bindingData.bindingPath)) {
            return isMatch;
        }
        const bingdingPathArray = this.bindingData.bindingPath.split('/');
        if (bingdingPathArray.length <= 0) {
            return isMatch;
        }
        if (changePathArray.length === 0) { // 主表
            if (this.bindingData.bindingPath === '/') {
                isMatch = true;
            }
        }
        else if (change.path.length === 1) { // 主从表
            if (bingdingPathArray.length === 2 && bingdingPathArray[1] === change.path[0]) {
                isMatch = true;
            }
        }
        else if (change.path.length === 2) { // 主从从表
            if (bingdingPathArray.length === 3 && bingdingPathArray[1] === change.path[0] && bingdingPathArray[2] === change.path[1]) {
                isMatch = true;
            }
        }
        return isMatch;
    }
    /**
     * 处理选中主键变更
     */
    handleSelectedKeyChange(currentId) {
        const selectedKeys = this.selectionDir.selectedKeys;
        if (!currentId) {
            // 如果当前行时null，但selectedKeys里有值，清空并发送一次行切换
            if (selectedKeys.length > 0) {
                const removedSelectedKeys = selectedKeys.splice(0, selectedKeys.length);
                if (removedSelectedKeys.indexOf(null) === -1) {
                    this.emitSelectedRowChange({ currentRowId: null });
                }
            }
            return;
        }
        let oldCurrentRowId = null;
        if (this.IsMultipleSelectionMode) {
            oldCurrentRowId = this.currentRowId;
        }
        else {
            oldCurrentRowId = this.selectionDir.selectedKeys.length === 0
                ? null : this.selectionDir.selectedKeys[0];
        }
        // TODO:if (this.currentRowId !== currentId) {
        if (oldCurrentRowId !== currentId) {
            const selectedRowContext = {};
            selectedRowContext.currentRowId = currentId;
            this.currentRowId = currentId;
            this.emitSelectedRowChange(selectedRowContext);
        }
    }
    /**
     * 发射选中行切换事件
     * @description 统一单选模式和多选模式下的行切换事件
     */
    emitSelectedRowChange(selectedRowContext) {
        if (!this.IsMultipleSelectionMode) { // 向后兼容
            const currentId = selectedRowContext.currentRowId;
            this.selectionDir.selectedKeys = [currentId];
            this.selectionDir.selectedKeysChange.emit(this.selectionDir.selectedKeys);
        }
        this.selectedRowChange.emit(selectedRowContext);
    }
    checkCurrentRowIdExists() {
        let isExist = false;
        if (this.bindingList && this.bindingList.currentId && this.bindingList.currentId.length > 0) {
            isExist = true;
        }
        return isExist;
    }
    /**
     * 同步已删除键到选中集合
     */
    syncDeletedKeys(deletedValueCollection) {
        if (!deletedValueCollection) {
            return;
        }
        deletedValueCollection.forEach((id) => {
            const index = this.selectionDir.selectedKeys.indexOf(id);
            if (index > -1) {
                this.selectionDir.selectedKeys.splice(index, 1);
                // selectedKeys被清空的时候，触发一次行变更
                if (this.selectionDir.selectedKeys.length === 0) {
                    this.emitSelectedRowChange({ currentRowId: null });
                }
            }
        });
    }
    renderCurrentRow(currentId) {
        if (!currentId || currentId === '') { // 不存在当前行
            return;
        }
        // TODO:使用策略模式重构
        if (this.IsMultipleSelectionMode) {
            return;
        }
        this.renderSelectionRow(this.bindingList.currentId, this.selectionDir.selectedKeys);
    }
    /**
     * 指令输入变更处理
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        this.refreshView();
    }
    /**
     * 指令销毁，注销订阅
     */
    ngOnDestroy() {
        if (this.bindingChangeSubscription) {
            this.bindingChangeSubscription.unsubscribe();
        }
    }
    refreshView(change) {
        // this.bindData();
        this.refreshData(change);
        // 刷新页脚合计信息。客户端合计，暂时放这里，服务端合计时最好从这里移走。by justin
        this.refreshSummary();
    }
    /**
     * 绑定data到宿主grid上
     * @deprecated
     */
    bindData() {
        /*const data = this.bindingList.toJSON();
        let skip = 0;
        if (this.bindingList.pageIndex > 0) {
          skip = (this.bindingList.pageIndex - 1) * this.bindingList.pageSize;
        }
        this.updatePager(this.bindingList.pageSize, skip);
        const processed = process(data, Object.assign({}, this.state, { skip: 0 }));
        processed.total = this.bindingList.total;
        this.grid.data = processed;*/
    }
    refreshData(change) {
        let skip = 0;
        const { pageIndex = 1, pageSize = 0 } = this.getPagingInfo() || {};
        if (pageIndex > 0) {
            skip = (pageIndex - 1) * pageSize;
        }
        this.updatePager(pageSize, skip);
        this.endCellEdit(change);
        this.data = this.bindingList.toJSON({ ignoreMultiLangInput: true });
    }
    /**
     * 退出编辑状态
     * @param change 变更
     */
    endCellEdit(change) {
        const isEditing = this.grid.isEditing;
        if (change && change.type === ChangeType.Load && isEditing) {
            this.grid.cancelCell();
        }
    }
    refreshSummary() {
        if (this.aggrColumns) {
            this.aggrColumns.forEach(aggrCol => {
                if (aggrCol.aggregate) {
                    aggrCol.recalculateSummary(this.bindingList);
                }
            });
        }
    }
    onPageChange(event) {
        const { skip = 0, take = 0 } = event || {};
        // this.bindingList.setPaginationInfo(skip, take);
        this.bindingData.setPagingInfo(skip, take, this.viewModel.bindingPath);
        // 移除选中行样式
        MultiSelectGridUtility.removeRowSelectedStyle(this.grid, this.rowIndex);
    }
    /**
     * 重置grid分页信息
     */
    resetPageInfo() {
        const { pageSize = 0 } = this.getPagingInfo() || {};
        this.bindingData.setPagingInfo(0, pageSize, this.viewModel.bindingPath);
    }
    initDataState() {
        // const groups: GroupDescriptor[] = [];
        // if (this.groupField) {
        //   groups.push({field: this.groupField, aggregates: this.aggregates||[]});
        //   this.grid.group = groups;
        // }
        // this.state = Object.assign(this.state, {group: groups});
        const aggregatesDes = [];
        if (this.groupAggrFields) {
            for (const groupAggrField of this.groupAggrFields) {
                aggregatesDes.push({ field: groupAggrField, aggregate: 'sum' });
            }
        }
        const group = [];
        if (this.groupField) {
            group.push({ field: this.groupField, aggregates: aggregatesDes });
        }
        this.group = group;
    }
    /*
     * @override
     * @param state State
     */
    onStateChange(state) {
        // 说明：pager根据skip计算当前页码。kendo grid内部会在filter state变化时把skip变为0（重置到第一页）。
        // 因此需要重写onStateChange方法，修正skip
        if (state.skip !== this.currentSkip) {
            state.skip = this.currentSkip;
        }
        // 使用kendo默认的处理state的逻辑
        this.applyState(state);
        this.rebind();
    }
    // protected applyState({skip, take, sort, group, filter}: State): void {
    //   this.skip = skip;
    //   this.pageSize = take;
    //   this.sort = sort;
    //   this.group = group;
    //   this.filter = filter;
    // }
    /*
     * @override 服务器端分页取数。process使用的state中skip应为0，否则不显示数据
     * @param state State
     */
    process(state) {
        // if (this.editing) {
        //   state.sort = null;
        // } else {
        //   state.sort = this.originalSort;
        // }
        state.skip = 0;
        const { pageSize = 0, total: totalCount = 0 } = this.getPagingInfo() || {};
        // fix：不启用分页时，take=0导致process不返回数据
        if (state.take === 0) {
            state.take = this.bindingList.length;
        }
        else {
            state.take = pageSize;
        }
        // 编辑模式的判断依据为pageSize小于绑定数据的数量且启用分页
        const isEditMode = state.take < this.bindingList.length;
        if (isEditMode) {
            state.take = this.bindingList.length;
        }
        const processed = super.process(state);
        // fix:数据从无到有时分页不启用
        processed.total = Math.max(totalCount, this.bindingList.length);
        // 分页编辑模式下数据总记录数不能等于真实的数据数据，否则分页工具条就会自动增加分页页签
        if (isEditMode) {
            processed.total = totalCount || 1;
        }
        return processed;
    }
    /*
     * 选中行主键变化处理
     * @param event { SelectionEvent} 选中行变化处理
     */
    selectedKeysChangeHandler(selectedKeys) {
        if (!(this.IsMultipleSelectionMode)) { // 单选模式下
            // 设置BindingData中的当前行
            this.setSelectionIdToBindingData(selectedKeys[selectedKeys.length - 1]);
        }
        this.viewModel.uiState.setPropertyValue('ids', this.selectionDir.selectedKeys); // 更新集合
    }
    /*
     * 处理Grid行切换事件
     * @param event { SelectionEvent} 行切换事件对象
     */
    selectionChangeHandler(event) {
        if (this.IsMultipleSelectionMode) {
            this.handleSelectedCheckboxChange(this.grid.wrapper, event);
        }
    }
    /**
     * 处理checkbox选中事件
     */
    handleSelectedCheckboxChange(elementRef, event) {
        MultiSelectGridUtility.renderSelectedChangeCheckbox(elementRef, event);
        this.selectedCheckboxChange.emit(event);
    }
    /*
     * 单元格点击处理
     * @param event { CellClickEvent } 单元格单击事件对象
     */
    cellClickHandler(event) {
        this.cellClickParam = event;
        this.cellClickEvent = event;
        this.rowIndex = event.rowIndex;
        this.columnIndex = event.columnIndex;
        this.sender = event.sender;
        // 多选模式下，且不分组的情况下，检测行切换
        if (this.IsMultipleSelectionMode && !this.gridOption.groupable) {
            const currentRowIndex = event.rowIndex;
            if (currentRowIndex !== this.lastRowIndex) {
                const rowSelectedContext = new SelectedRowContext();
                rowSelectedContext.currentRowIndex = currentRowIndex;
                rowSelectedContext.lastRowIndex = this.lastRowIndex;
                this.handleSelectedRowChange(rowSelectedContext);
            }
        }
        // 设置实体的当前行
        this.dataId = this.getSelectedIdFromGrid(event.dataItem);
        this.setSelectionIdToBindingData(this.dataId);
        // 若状态机不是可编辑状态 不可编辑
        if (!this.isEditable()) {
            return;
        }
        // 列模板不存在  不可编辑
        if (!event.column.editTemplate) {
            return;
        }
        if (event.type === 'click' && !event.isEdited) {
            // 如果存在显隐状况  确定正确的columnIndex
            const originColums = this.getColumns(this.gridOption.fields);
            const columns = this.getColumns(originColums);
            const currentColumnIndex = columns.findIndex((col) => col.dataField === event.column.field);
            const hiddenColLen = columns.slice(0, currentColumnIndex + 1).filter(col => !col.visible).length;
            // 赋值全局行索引  列索引
            this.rowIndex = event.rowIndex;
            this.columnIndex = event.columnIndex + hiddenColLen;
            this.hiddenColLen = hiddenColLen;
            this.sender = event.sender;
            this.setEditable(this.rowIndex, this.columnIndex);
        }
    }
    /**
     * 处理选中行切换事件
     */
    handleSelectedRowChange(rowSelectedContext) {
        MultiSelectGridUtility.renderClickChangedRow(this.grid, rowSelectedContext);
        this.rowIndex = rowSelectedContext.currentRowIndex;
        this.lastRowIndex = rowSelectedContext.currentRowIndex;
        // 更新当前行
        const id = this.getPrimary(this.rowIndex);
        this.setSelectionIdToBindingData(id);
    }
    /**
     * 获取指定行的主键
     * @param row 行号
     */
    getPrimary(row) {
        let data = this.grid.data;
        if (data && !Array.isArray(data) && data.hasOwnProperty('data')) {
            data = data.data;
        }
        const { pageIndex = 1, pageSize = 0 } = this.getPagingInfo() || {};
        const skip = this.bindingList.skip;
        // 不分页或者第一页时取不需要修改行号
        const rowNumber = pageSize === 0 || pageIndex === 1 ? row : row - skip;
        if (data.length > rowNumber) {
            return data[rowNumber][this.bindingList.primaryKey];
        }
        return null;
    }
    /*
     * 单元格结束编辑处理
     * @param event 单元格结束编辑事件对象
     */
    cellCloseHandler(event) {
        if (this.dialogSer.hasDialogOpened()) {
            event.preventDefault();
            return;
        }
        if (this.rts) {
            // 帮助组件文本变化后去查询
            if (this.rts.getFormState('lookup.pending')) {
                event.preventDefault();
                return;
            }
            // 点击帮助确定可取消按钮后不结束当前单元格编辑
            if (event.originalEvent) {
                if (this.rts.eventPath(event.originalEvent).find(n => n.tagName === 'FARRIS-DIALOG')) {
                    event.preventDefault();
                    return;
                }
            }
        }
        const { formGroup, column, dataItem, rowIndex } = event;
        const columns = this.getColumns(this.gridOption.fields);
        let currentCol = columns.find((element) => {
            return element.dataField === column.field;
        });
        const formControlValue = formGroup[currentCol.editor.binding.path].value;
        if (currentCol.getDynamicData) {
            // 若此列是动态单元格列
            currentCol = currentCol.getDynamicData(dataItem, currentCol);
        }
        this.setValue(formControlValue, currentCol);
    }
    /*
       * 回车  切换单元格
       * @param event 键盘按下事件
       */
    enterCell(e) {
        // 回车键
        if (!e.shiftKey && e.keyCode === 13) {
            // textarea enter 屏蔽换行操作
            e.preventDefault();
            if (!this.sender) {
                return;
            }
            // 由于keydown 事件会先执行，所以这里先要执行blur 事件；
            e.target.blur();
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    if (this.rts && this.rts.getFormState('lookup.pending')) {
                        e.preventDefault();
                        return;
                    }
                    this.enterNextCell();
                }, 201);
            });
        }
    }
    /*
       * 绑定grid option
       * @param dataItem 行数据
       */
    bindingGridOption() {
        if (!this.farrisBindingGridOption) {
            return;
        }
        Object.defineProperty(this.grid, 'gridOption', { value: this.farrisBindingGridOption });
    }
    /*
     * 更新Grid分页状态
     * @param take
     * @param skip
     */
    updatePager(take, skip) {
        if (take === 0) {
            this.currentSkip = 0;
            this.pageSize = 0;
            this.skip = 0;
            this.grid.pageable = false;
        }
        else {
            this.currentSkip = skip;
            this.skip = skip;
            this.pageSize = take;
            this.grid.pageable = {
                buttonCount: 10,
                info: true,
                type: 'numeric',
                pageSizes: false,
                previousNext: true
            };
        }
    }
    /*
     * 设置单元格可编辑性
     * @param dataItem 行数据
     * @param column 列对象
     * @param rowIndex 行索引
     * @param columnIndex 列索引
     * @param sender grid实例
     */
    setEditable(rowNumber, columnNumber) {
        const data = this.grid.data['data'];
        const { pageIndex = 1, pageSize = 0 } = this.getPagingInfo() || {};
        const skip = this.bindingList.skip;
        // 不分页或者第一页时取不需要修改行号
        const dataRowNumber = pageSize === 0 || pageIndex === 1 ? rowNumber : rowNumber - skip;
        let item = data[dataRowNumber];
        if (this.gridOption.groupable) {
            item = this.getGroupItem(data, dataRowNumber);
        }
        const originColums = this.getColumns(this.gridOption.fields);
        const columns = this.getColumns(originColums);
        /* 假如列的顺序改变 比如存在固定列  那么应该获取真正的列对象 */
        // let col = columns[columnNumber];
        let tempIndex = columnNumber;
        // 当前列索引不为0
        if (this.grid['gridOption'].showLineNumber) {
            tempIndex = tempIndex - 1;
        }
        if (this.grid.selectable && this.grid.selectable['mode'] === 'multiple') {
            tempIndex = tempIndex - 1;
        }
        const col = columns[tempIndex];
        const params = {
            dataItem: item,
            column: col,
            rowIndex: rowNumber,
            columnIndex: tempIndex,
        };
        // 控制单元格的可编辑性
        if (col && !col.editable) {
            col.editable = (param) => true;
        }
        if (col && this.notReadOnly(col, params)) {
            // 设置当前行
            this.dataId = this.getSelectedIdFromGrid(item);
            this.setSelectionIdToBindingData(this.dataId);
            // const value = this.getValue(item, col.dataField);
            // this.setValue(value, col);
            this.sender.editCell(rowNumber, columnNumber - this.hiddenColLen, this.viewModel.form);
        }
    }
    /*
    获取更新 rowIndex columnIndex
     */
    updateIndex(rowNumber, columnIndex) {
        const newColumnIndex = (columnIndex + 1) % this.len;
        if (!newColumnIndex) {
            const dataLen = this.bindingList.toJSON().length;
            const newRowIndex = (rowNumber + 1) % dataLen;
            return { rowIndex: newRowIndex, columnIndex: newColumnIndex };
        }
        return {
            rowIndex: rowNumber,
            columnIndex: newColumnIndex
        };
    }
    /* 是否只读 */
    notReadOnly(column, param) {
        if (!column) {
            return false;
        }
        return column.editable(param) && !column.editor.readonly;
    }
    /*
       * 给列表赋值 或给formcontrol赋值
        */
    setValue(value, column) {
        const currentColumnType = column.dataType;
        // 同时判断gridOption的列对象
        const bindingData = this.viewModel.bindingData;
        const fieldPaths = this.getFieldPaths(bindingData.bindingPath, column.dataField);
        // 存在行编辑器
        if (currentColumnType === 'date') {
            let dateStr = this.dateService.formatTo(value, 'yyyy-MM-dd HH:mm:ss');
            if (!dateStr) {
                dateStr = '';
            }
            this.viewModel.bindingData.setValue(fieldPaths, dateStr, true, true);
        }
        else {
            this.viewModel.bindingData.setValue(fieldPaths, value, true, true);
        }
    }
    /* 分组时 获取点击行数据 */
    getGroupItem(data, rowNumber) {
        let index = rowNumber;
        for (const i in data) {
            if (index < data[i].items.length) {
                return data[i].items[index];
            }
            else {
                index = index - data[i].items.length;
            }
        }
    }
    /*
     * 获取 单元格值  主从表支持
     * @param dataItem 行数据
     * @param field 字段
     */
    getValue(dataItem, field) {
        const index = field.indexOf('.');
        if (index < 0) {
            return dataItem[field];
        }
        const fields = field.split('.');
        // field字符串组合
        return fields.reduce((result, next) => {
            return result[next];
        }, dataItem);
    }
    /*
    * 获取 bindingData 路径
    * @param bindingPath 当前绑定的字段路径
    * @param fieldName 字段
    */
    getFieldPaths(bindingPath, field) {
        let fieldPath = '';
        if (bindingPath.length > 1) {
            fieldPath = bindingPath.substr(1).replace(/\//g, '.') + '.' + field;
        }
        else {
            fieldPath = field;
        }
        return fieldPath.split('.');
    }
    /**
     * 回车进入下一个单元格
     */
    enterNextCell() {
        const index = this.updateIndex(this.rowIndex, this.columnIndex);
        if (!index.columnIndex && !index.rowIndex) {
            const len = this.bindingList.toJSON().length;
            // 如果存在添加数据的API
            this.appendRow.emit();
            if (this.appendRow.observers && this.appendRow.observers.length) {
                this.interVal = setInterval(() => {
                    if (this.bindingList.toJSON().length - 1 === len) {
                        this.setEditable(this.bindingList.toJSON().length - 1, 0);
                        this.rowIndex = this.bindingList.toJSON().length - 1;
                        this.columnIndex = 0;
                        clearInterval(this.interVal);
                    }
                }, 0);
                return;
            }
        }
        this.setEditable(index.rowIndex, index.columnIndex);
        this.rowIndex = index.rowIndex;
        this.columnIndex = index.columnIndex;
    }
    /* 获取真正的列对象 */
    getColumns(columns) {
        // 判断是否存在固定列
        const hasLocked = columns.some((ele) => {
            return ele.frozen;
        });
        if (hasLocked) {
            const lockedColumns = columns.filter((ele) => {
                return ele.frozen;
            });
            const notLockedColumns = columns.filter((ele) => {
                return !ele.frozen;
            });
            return [...lockedColumns, ...notLockedColumns];
        }
        return columns;
    }
    /*
     * 渲染指定行为选中行：将指定行的key添加到选中行集合中
     */
    renderSelectionRow(key, selectedKeys) {
        if (!key || key === '') {
            return;
        }
        // TODO:使用策略模式重构
        if (this.IsMultipleSelectionMode) {
            const index = selectedKeys.indexOf(key);
            if (index >= 0) {
                return;
            }
            selectedKeys.push(key);
        }
        else {
            if (selectedKeys.length === 1 && selectedKeys[0] === key) {
                return;
            }
            selectedKeys.splice(0, selectedKeys.length);
            selectedKeys.push(key);
        }
        this.selectionDir.selectedKeysChange.emit(selectedKeys); // 手动触发selectedKeysChange事件
    }
    /*
     * 获取Grid上的当前行内码
     * @param dataItem 行数据
     */
    getSelectedIdFromGrid(dataItem) {
        const primaryKey = this.bindingList.primaryKey;
        return dataItem[primaryKey];
    }
    /*
     * 设置BindingList的当前行
     * @param id 当前行内码
     */
    setSelectionIdToBindingData(id) {
        this.bindingList.setCurrentId(id, true);
    }
    /*
    *列表整体是否可编辑
     */
    isEditable() {
        if (this.editable === undefined) {
            if (!this.viewModel.stateMachine) {
                // 状态机不存在的时候
                return false;
            }
            // 状态机存在的时候
            return this.viewModel.stateMachine['editable'];
        }
        // 自定义赋值
        return this.editable;
    }
    /*  */
    isDataChanged() {
        let hasUnsavedData = false;
        const entityArray = this.viewModel.frameContext.repository.entityCollection.toArray();
        for (const entity of entityArray) {
            if (entity.changes.length > 0) {
                hasUnsavedData = true;
                break;
            }
        }
        return hasUnsavedData;
    }
}
KendoGridBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisBindingPath]'
            },] }
];
/** @nocollapse */
KendoGridBindingDirective.ctorParameters = () => [
    { type: BindingData },
    { type: UIState, decorators: [{ type: Optional }] },
    { type: FrameEventBus, decorators: [{ type: Optional }] },
    { type: ViewModel, decorators: [{ type: Optional }] },
    { type: GridComponent },
    { type: SelectionDirective },
    { type: DialogService },
    { type: DateTimeHelperService },
    { type: FarrisKendoGridFormatService },
    { type: RuntimeStateService },
    { type: NgZone }
];
KendoGridBindingDirective.propDecorators = {
    editable: [{ type: Input, args: ['farrisEditable',] }],
    form: [{ type: Input, args: ['farrisForm',] }],
    groupField: [{ type: Input, args: ['groupField',] }],
    groupAggrFields: [{ type: Input, args: ['groupAggrFields',] }],
    farrisBindingGridOption: [{ type: Input }],
    rowClassName: [{ type: Input }],
    appendRow: [{ type: Output, args: ['append-row',] }],
    sortChangeEvent: [{ type: Output }],
    rowClass: [{ type: Output }],
    selectedRowChange: [{ type: Output }],
    selectedCheckboxChange: [{ type: Output }],
    aggrColumns: [{ type: ContentChildren, args: [GridColumnAggregateDirective,] }],
    onPageChange: [{ type: HostListener, args: ['pageChange', ['$event'],] }],
    selectedKeysChangeHandler: [{ type: HostListener, args: ['selectedKeysChange', ['$event'],] }],
    selectionChangeHandler: [{ type: HostListener, args: ['selectionChange', ['$event'],] }],
    cellClickHandler: [{ type: HostListener, args: ['cellClick', ['$event'],] }],
    cellCloseHandler: [{ type: HostListener, args: ['cellClose', ['$event'],] }],
    enterCell: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

// tslint:disable: no-string-literal
/**
 * 树节点构造器
 * @summary
 * 将BindingData中的数据集合转换成TreeTable节点集合
 */
class PathTreeNodeBuilder {
    /**
     * 构造函数
     */
    constructor(allNodesData, oldTreeNodes, primaryKey, hierarchyInfoKey, context) {
        this.levelGroup = {};
        /**
         * 等待展开的节点
         * @description 节点结构
         * ```
         * {id:'xxx',expanded:false}
         * ```
         */
        this.nodesWaitExpand = [];
        this.primaryKey = primaryKey;
        this.hierarchyInfoKey = hierarchyInfoKey;
        this.allNodes = [];
        this.allNodesData = allNodesData;
        this.context = context || {};
        this.nodesWaitExpand = [];
        this.nodesShouldExpand = context && context.nodesShouldExpand || [];
        this.frameContext = context && context.frameContext || null;
        this.addTreeLoadCompleteListener(this.onTreeLoadComplete.bind(this));
        this.initLevelGroup();
        this.allNodesMap = new Map();
        this.allOldNodesMap = new Map();
        this.buildNodesDataMap(oldTreeNodes);
    }
    /**
     * 展开至层级
     * @description -1为不展开
     */
    get expandLevel() {
        return this.context && this.context.hasOwnProperty('expandLevel') ? this.context['expandLevel'] : -1;
    }
    get component() {
        return this.context && this.context['component'];
    }
    get addTreeLoadCompleteListener() {
        return this.context && this.context['addTreeLoadCompleteListener'] || function (args) { };
    }
    updateTreeNode(allNodesData, data) {
        this.allNodesData = allNodesData;
        this.initLevelGroup();
        this.buildNodesDataMap(data);
    }
    build() {
        const tree = [];
        const childrenOf = {};
        const nodes = {};
        this.allNodesData.forEach(item => {
            const id = item.id;
            const parentId = this.getParentId(item);
            // item.parentId = parentId;
            // 展开新增节点的父节点
            const isNewNode = this.isNewNode(item);
            if (isNewNode === true) {
                this.expandParentNode(item);
            }
            // 构造树节点
            const node = this.buildNode(item);
            nodes[id] = node;
            childrenOf[id] = childrenOf[id] || [];
            node.children = childrenOf[id];
            this.allNodesMap.set(item[this.primaryKey], node);
            if (parentId) {
                if (nodes[parentId] && nodes[parentId].unstableState === true) {
                    nodes[parentId].expanded = true;
                    nodes[parentId].unstableState = false;
                }
                childrenOf[parentId] = childrenOf[parentId] || [];
                childrenOf[parentId].push(node);
            }
            else {
                if ((!node.children || node.children.length < 1) && node.expanded === true) {
                    node.unstableState = true;
                    node.expanded = false;
                }
                tree.push(node);
            }
        });
        return tree;
    }
    /**
     * 构造树节点
     */
    build1() {
        let minLayer;
        // 获取最顶级节点的layer
        this.allNodesData.forEach(node => {
            const hierarchyInfo = this.getHierarchyInfo(node);
            if (hierarchyInfo) {
                const layer = hierarchyInfo['layer'];
                if (!isNaN(layer)) {
                    if (minLayer === undefined) {
                        minLayer = layer;
                    }
                    else if (layer < minLayer) {
                        minLayer = layer;
                    }
                }
            }
        });
        const topLayer = minLayer - 1;
        this.buildNodes('', topLayer, this.allNodesData, this.allNodes);
        return this.allNodes;
    }
    /**
     * 构造树节点集合
     */
    buildNodes(fPath, fLayer, allNodesData, treeNodes) {
        const childNodesData = this.getChildNodesData(fPath, fLayer);
        childNodesData.forEach((nodeData) => {
            // 展开新增节点的父节点
            const isNewNode = this.isNewNode(nodeData);
            if (isNewNode === true) {
                this.expandParentNode(nodeData);
            }
            // 构造树节点
            const node = this.buildNode(nodeData);
            treeNodes.push(node);
            this.allNodesMap.set(nodeData[this.primaryKey], node);
            // 递归遍历下级节点
            const hierarchyInfo = this.getHierarchyInfo(nodeData); //nodeData[this.hierarchyInfoKey];
            const currentLayer = hierarchyInfo['layer'];
            const currentPath = hierarchyInfo['path'];
            this.buildNodes(currentPath, currentLayer, allNodesData, node.children);
        });
    }
    /**
     * 创建树节点
     */
    buildNode(nodeData) {
        const isLeaf = this.isLeaf(nodeData);
        // 获取节点的展开状态
        const shouldExpand = this.shouldExpand(nodeData);
        // 节点虽然应该展开，但可能是因为之前就是展开状态，所以应该检查节点之前的状态
        const originExpandStatus = this.isExpanded(nodeData);
        // 如果应该展开该节点，但是该节点之前有状态，那么该节点不应该再由程序展开。
        if (!originExpandStatus && shouldExpand) {
            this.expandNode(nodeData);
        }
        const paginationInfo = this.buildPaginationInfo(nodeData);
        const treeNode = {
            data: Object.assign({}, nodeData),
            children: [],
            expanded: shouldExpand,
            leaf: isLeaf
        };
        if (paginationInfo) {
            treeNode.pagination = paginationInfo;
        }
        return treeNode;
    }
    /**
     * 构造分页信息
     * @param nodeData nodeData
     * @returns
     */
    buildPaginationInfo(nodeData) {
        let result = null;
        if (this.frameContext) {
            const id = this.getPrimary(nodeData);
            // 获取分页信息
            const key = `_NODE_${id}_PAGINATION_INFO_`;
            const pagination = this.frameContext.params.get(key) || null;
            if (pagination && pagination.pageCount > 1) {
                result = {
                    pageIndex: pagination.pageIndex,
                    pageSize: pagination.pageSize,
                    total: pagination.totalCount
                };
            }
        }
        return result;
    }
    /**
     * 计算节点是否需要展开
     * @param nodeData nodeData
     */
    shouldExpand(nodeData) {
        const [layer, isLeaf] = [this.getNodeLayer(nodeData), this.isLeaf(nodeData)];
        // 永远不展开叶子节点
        if (isLeaf) {
            return false;
        }
        let expanded = this.isExpanded(nodeData);
        if (!expanded) {
            const id = this.getPrimary(nodeData);
            if (this.nodesWaitExpand.findIndex(node => node && node.id === id) > -1) {
                return false;
            }
            if (this.nodesShouldExpand.findIndex(nodeId => nodeId === id) > -1) {
                return true;
            }
            if (this.expandLevel === -1) {
                // -1 为不展开
                expanded = false;
            }
            else if (this.expandLevel === 0) {
                // 0 为全部展开
                expanded = true;
            }
            else {
                // 没有启用分层加载，通过展开层级确定是否展开该节点
                expanded = layer <= this.expandLevel;
                // 如果节点原本存在且节点没有展开则不展开
                const oldTreeNode = this.getOldNode(nodeData);
                if (oldTreeNode && !oldTreeNode.expanded) {
                    expanded = false;
                }
            }
        }
        return expanded;
    }
    /**
     * 展开树节点
     * @description 完全加载树使用展开属性在buildNode时已经展开，此函数的主要用于展开分级加载树
     * @param nodeData nodeData
     */
    expandNode(nodeData) {
        const [path, layer] = [this.getNodePath(nodeData), this.getNodeLayer(nodeData)];
        const childs = this.getChildNodesData(path, layer);
        // 当前节点不是叶子节点，但在节点数据中又找不到该节点的子节点，则认为树启用了分层加载
        if (!childs || childs.length < 1) {
            // 分层加载树需要通过触发节点展开事件才加载下层，目前树上还不存在该节点，无法直接展开，需要等树加载完之后再展开
            const id = this.getPrimary(nodeData);
            if (this.nodesWaitExpand.findIndex(node => node && node.id === id) < 0) {
                this.nodesWaitExpand.push({ id, expanded: false });
            }
        }
    }
    /**
     * 树加载完成事件
     */
    onTreeLoadComplete() {
        const index = this.nodesWaitExpand.findIndex(node => !node.expanded);
        const nodeData = this.nodesWaitExpand[index] || {};
        const { id } = nodeData;
        if (id) {
            const rowNode = this.component.findRowNode(id);
            if (rowNode) {
                nodeData.expanded = true;
                // if (nodeData && nodeData.node && !nodeData.node.expanded) {
                //   return;
                // }
                this.component.expandNode(id);
            }
        }
    }
    /**
     * 获取主键
     * @param nodeData nodeData
     */
    getPrimary(nodeData) {
        return nodeData[this.primaryKey];
    }
    // #region 工具方法，待单独封装
    /**
     * 获取子级节点的数据集合
     */
    getChildNodesData(fPath, fLayer) {
        const childNodesData = [];
        this.allNodesData.forEach((nodeData) => {
            // @todo：待删除，兼容没有hierarchyInfo的数据
            const hierarchyInfo = this.getHierarchyInfo(nodeData); //this.getValue(nodeData, this.hierarchyInfoKey); /// nodeData[this.hierarchyInfoKey];
            if (!hierarchyInfo) {
                return;
            }
            // 匹配节点
            const currentLayer = hierarchyInfo['layer'];
            const currentPath = hierarchyInfo['path'];
            if ((currentLayer === fLayer + 1) && currentPath && currentPath.startsWith(fPath)) {
                childNodesData.push(nodeData);
            }
        });
        return childNodesData;
    }
    getHierarchyInfo(nodeData) {
        return this.getValue(nodeData, this.hierarchyInfoKey); //nodeData[this.hierarchyInfoKey];
    }
    initLevelGroup() {
        this.levelGroup = {};
        this.allNodesData.forEach((nodeData) => {
            const hierarchyInfo = this.getHierarchyInfo(nodeData);
            const key = `level${hierarchyInfo.layer}`;
            if (this.levelGroup[key]) {
                this.levelGroup[key].push(nodeData);
            }
            else {
                this.levelGroup[key] = [nodeData];
            }
        });
    }
    getParentId(node) {
        const hierarchyInfo = this.getHierarchyInfo(node);
        const parentLevelGroup = this.levelGroup[this.getLevelGroupKey(hierarchyInfo.layer - 1)] || [];
        const parent = parentLevelGroup.find(nodeData => {
            const currentHierarchyInfo = this.getHierarchyInfo(nodeData);
            if (currentHierarchyInfo.isDetail === true) {
                return false;
            }
            return hierarchyInfo.path.startsWith(currentHierarchyInfo.path);
        });
        if (parent) {
            return parent.id;
        }
        else {
            return null;
        }
    }
    getLevelGroupKey(level) {
        return `level${level}`;
    }
    /**
     * 根据路径获取数据
     * @param target target
     * @param path 路径
     */
    getValue(target, path) {
        if (path.indexOf('/') === -1) {
            return target[path];
        }
        const paths = path.split('/').filter(p => p);
        if (paths.length < 1) {
            return target;
        }
        return paths.reduce((result, path) => {
            return result && result[path];
        }, target);
    }
    /**
     * 获取分级信息中的层级
     * @param nodeData nodeData
     */
    getNodeLayer(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData);
        return hierarchyInfo['layer'];
    }
    /**
     * 获取分级信息中的路径
     * @param nodeData nodeData
     */
    getNodePath(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData);
        return hierarchyInfo['path'];
    }
    /**
     * 获取展开状态
     */
    isExpanded(newData) {
        const oldTreeNode = this.getOldNode(newData);
        return oldTreeNode ? oldTreeNode.expanded : undefined;
    }
    /**
     * 是否是叶子节点
     * @todo：服务器端对isDetail的目前没有与前端同步，isDetail不准确。
     */
    isLeaf(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData); // nodeData[this.hierarchyInfoKey];
        const isDetail = hierarchyInfo['isDetail'];
        return isDetail;
    }
    /**
     * 判断节点是否是新增
     * @todo：不应该这样判断，待优化。
     * @summary
     * 1、非空树（空树视为初次加载数据）；
     * 2、找不到oldNode。
     */
    isNewNode(nodeData) {
        if (this.allOldNodesMap.size === 0) {
            return false;
        }
        const oldTreeNode = this.getOldNode(nodeData);
        return oldTreeNode ? false : true;
    }
    /**
     * 展开父节点
     */
    expandParentNode(nodeData) {
        const parentTreeNode = this.getParentNode(nodeData);
        if (!parentTreeNode) {
            return;
        }
        parentTreeNode.leaf = false;
        parentTreeNode.expanded = true;
    }
    /**
     * 查找父节点
     */
    getParentNode(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData); //nodeData[this.hierarchyInfoKey];
        const layer = hierarchyInfo['layer'];
        const path = hierarchyInfo['path'];
        const allNodes = Array.from(this.allNodesMap.values());
        const parentNode = allNodes.find((currentNode) => {
            const currentLayer = this.getValue(currentNode.data, this.hierarchyInfoKey)['layer']; //currentNode.data[this.hierarchyInfoKey]['layer'];
            const currentPath = this.getValue(currentNode.data, this.hierarchyInfoKey)['path']; //  currentNode.data[this.hierarchyInfoKey]['path'];
            if ((layer === currentLayer + 1) && path.startsWith(currentPath) === true) {
                return true;
            }
            return false;
        });
        return parentNode;
    }
    /**
     * 获取老的树节点
     */
    getOldNode(nodeData) {
        const id = nodeData[this.primaryKey];
        return this.allOldNodesMap.get(id);
    }
    /**
     * 打平TreeNodes，并放入一个Map中
     */
    buildNodesDataMap(treeNodes) {
        treeNodes.forEach((treeNode) => {
            this.allOldNodesMap.set(treeNode.data[this.primaryKey], treeNode);
            if (treeNode.children) {
                this.buildNodesDataMap(treeNode.children);
            }
        });
    }
}

/*
 * @Author: aalizzwell
 * @Date: 2019-05-31 09:48:10
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-06-24 17:00:58
 */
// tslint:disable: no-string-literal max-line-length
/**
 * 树节点构造器
 * @summary
 * 将BindingData中的数据集合转换成TreeTable节点集合
 */
class ParentTreeNodeBuilder {
    /**
     * 构造函数
     */
    constructor(allNodesData, oldTreeNodes, primaryKey, hierarchyInfoKey, context) {
        /**
         * 等待展开的节点
         * @description 节点结构
         * ```
         * {id:'xxx',expanded:false}
         * ```
         */
        this.nodesWaitExpand = [];
        this.primaryKey = primaryKey;
        this.hierarchyInfoKey = hierarchyInfoKey;
        this.allNodes = [];
        this.allNodesData = allNodesData;
        this.context = context || {};
        this.nodesWaitExpand = [];
        this.nodesShouldExpand = context && context.nodesShouldExpand || [];
        this.frameContext = context && context.frameContext || null;
        this.addTreeLoadCompleteListener(this.onTreeLoadComplete.bind(this));
        this.allNodesMap = new Map();
        this.allOldNodesMap = new Map();
        this.buildNodesDataMap(oldTreeNodes);
    }
    /**
     * 展开至层级
     * @description -1为不展开
     */
    get expandLevel() {
        return this.context && this.context.hasOwnProperty('expandLevel') ? this.context['expandLevel'] : -1;
    }
    get component() {
        return this.context && this.context['component'];
    }
    get addTreeLoadCompleteListener() {
        return this.context && this.context['addTreeLoadCompleteListener'] || function (args) { };
    }
    updateTreeNode(allNodesData, data) {
        this.allNodesData = allNodesData;
        this.buildNodesDataMap(data);
    }
    build() {
        let tree = [];
        const childrenOf = {};
        const parents = {};
        const nodes = {};
        this.allNodesData.forEach(item => {
            const id = item.id;
            const parentId = this.getHierarchyInfo(item).parentElement;
            // item.parentId = parentId;
            // 展开新增节点的父节点
            const isNewNode = this.isNewNode(item);
            if (isNewNode === true) {
                this.expandParentNode(item);
            }
            // 构造树节点
            const node = this.buildNode(item);
            nodes[id] = node;
            childrenOf[id] = childrenOf[id] || [];
            node.children = childrenOf[id];
            parents[parentId] = parents[parentId] || [];
            parents[parentId].push(node);
            this.allNodesMap.set(item[this.primaryKey], node);
            if (parentId) {
                if (nodes[parentId] && nodes[parentId].unstableState === true) {
                    nodes[parentId].expanded = true;
                    nodes[parentId].unstableState = false;
                }
                childrenOf[parentId] = childrenOf[parentId] || [];
                childrenOf[parentId].push(node);
            }
            else {
                if ((!node.children || node.children.length < 1) && node.expanded === true) {
                    node.unstableState = true;
                    node.expanded = false;
                }
                tree.push(node);
            }
        });
        // 所有节点都是parentId，没有返回根节点
        if ((!tree || tree.length < 1) && this.allNodesData && this.allNodesData.length > 0) {
            const parentIds = Object.keys(parents);
            parentIds.forEach(parentId => {
                if (!this.allNodesData.find(item => item.id === parentId)) {
                    tree = tree.concat(parents[parentId]);
                }
            });
        }
        return tree;
    }
    /**
     * 构造树节点
     */
    build1() {
        let minLayer;
        // 获取最顶级节点的layer
        this.allNodesData.forEach(node => {
            const hierarchyInfo = this.getHierarchyInfo(node);
            if (hierarchyInfo) {
                const layer = hierarchyInfo['layer'];
                if (!isNaN(layer)) {
                    if (minLayer === undefined) {
                        minLayer = layer;
                    }
                    else if (layer < minLayer) {
                        minLayer = layer;
                    }
                }
            }
        });
        const topLayer = minLayer - 1;
        this.buildNodes('', topLayer, this.allNodesData, this.allNodes);
        return this.allNodes;
    }
    /**
     * 构造树节点集合
     */
    buildNodes(fParentElement, fLayer, allNodesData, treeNodes) {
        const childNodesData = this.getChildNodesData(fParentElement, fLayer);
        childNodesData.forEach((nodeData) => {
            // 展开新增节点的父节点
            const isNewNode = this.isNewNode(nodeData);
            if (isNewNode === true) {
                this.expandParentNode(nodeData);
            }
            // 构造树节点
            const node = this.buildNode(nodeData);
            treeNodes.push(node);
            this.allNodesMap.set(nodeData[this.primaryKey], node);
            // 递归遍历下级节点
            const hierarchyInfo = this.getHierarchyInfo(nodeData); //nodeData[this.hierarchyInfoKey];
            const currentLayer = hierarchyInfo['layer'];
            const currentId = nodeData[this.primaryKey];
            this.buildNodes(currentId, currentLayer, allNodesData, node.children);
        });
    }
    /**
     * 创建树节点
     */
    buildNode(nodeData) {
        const isLeaf = this.isLeaf(nodeData);
        // 获取节点的展开状态
        const shouldExpand = this.shouldExpand(nodeData);
        // 节点虽然应该展开，但可能是因为之前就是展开状态，所以应该检查节点之前的状态
        const originExpandStatus = this.isExpanded(nodeData);
        // 如果应该展开该节点，但是该节点之前有状态，那么该节点不应该再由程序展开。
        if (!originExpandStatus && shouldExpand) {
            this.expandNode(nodeData);
        }
        const paginationInfo = this.buildPaginationInfo(nodeData);
        const treeNode = {
            data: Object.assign({}, nodeData),
            children: [],
            expanded: shouldExpand,
            leaf: isLeaf
        };
        if (paginationInfo) {
            treeNode.pagination = paginationInfo;
        }
        return treeNode;
    }
    /**
     * 构造分页信息
     * @param nodeData nodeData
     * @returns
     */
    buildPaginationInfo(nodeData) {
        let result = null;
        if (this.frameContext) {
            const id = this.getPrimary(nodeData);
            // 获取分页信息
            const key = `_NODE_${id}_PAGINATION_INFO_`;
            const pagination = this.frameContext.params.get(key) || null;
            if (pagination && pagination.pageCount > 1) {
                result = {
                    pageIndex: pagination.pageIndex,
                    pageSize: pagination.pageSize,
                    total: pagination.totalCount
                };
            }
        }
        return result;
    }
    /**
     * 计算节点是否要展开
     * @param nodeData nodeData
     */
    shouldExpand(nodeData) {
        const [isLeaf, layer] = [this.isLeaf(nodeData), this.getNodeLayer(nodeData)];
        // 永远不展开叶子节点
        if (isLeaf) {
            return false;
        }
        let expanded = this.isExpanded(nodeData);
        if (!expanded) {
            const id = this.getPrimary(nodeData);
            if (this.nodesWaitExpand.findIndex(node => node && node.id === id) > -1) {
                return false;
            }
            if (this.nodesShouldExpand.findIndex(nodeId => nodeId === id) > -1) {
                return true;
            }
            if (this.expandLevel === -1) {
                // -1 为不展开
                expanded = false;
            }
            else if (this.expandLevel === 0) {
                // 0 为全部展开
                expanded = true;
            }
            else {
                // 没有启用分层加载，通过展开层级确定是否展开该节点
                expanded = layer <= this.expandLevel;
                // 如果节点原本存在且节点没有展开则不展开
                const oldTreeNode = this.getOldNode(nodeData);
                if (oldTreeNode && !oldTreeNode.expanded) {
                    expanded = false;
                }
            }
        }
        return expanded;
    }
    /**
     * 展开树节点
     * @description 完全加载树使用展开属性在buildNode时已经展开，此函数的主要用于展开分级加载树
     * @param nodeData nodeData
     */
    expandNode(nodeData) {
        const [element, layer] = [nodeData[this.primaryKey], this.getNodeLayer(nodeData)];
        const childs = this.getChildNodesData(element, layer);
        // 当前节点不是叶子节点，但在节点数据中又找不到该节点的子节点，则认为树启用了分层加载
        if (!childs || childs.length < 1) {
            // 分层加载树需要通过触发节点展开事件才加载下层,目前树上还不存在该节点，无法直接展开，需要等树加载完之后再展开
            const id = this.getPrimary(nodeData);
            if (this.nodesWaitExpand.findIndex(node => node && node.id === id) < 0) {
                this.nodesWaitExpand.push({ id, expanded: false });
            }
        }
    }
    /**
     * 树加载完成事件
     */
    onTreeLoadComplete() {
        const index = this.nodesWaitExpand.findIndex(node => !node.expanded);
        const nodeData = this.nodesWaitExpand[index] || {};
        const { id } = nodeData;
        if (id) {
            const rowNode = this.component.findRowNode(id);
            if (rowNode) {
                nodeData.expanded = true;
                // if (nodeData && nodeData.node && !nodeData.node.expanded) {
                //   return;
                // }
                this.component.expandNode(id);
            }
        }
    }
    /**
     * 获取主键
     * @param nodeData nodeData
     */
    getPrimary(nodeData) {
        return nodeData[this.primaryKey];
    }
    // #region 工具方法，待单独封装
    /**
     * 获取子级节点的数据集合
     */
    getChildNodesData(fParentElement, fLayer) {
        const childNodesData = [];
        this.allNodesData.forEach((nodeData) => {
            // @todo：待删除，兼容没有hierarchyInfo的数据 
            const hierarchyInfo = this.getHierarchyInfo(nodeData); //nodeData[this.hierarchyInfoKey];
            if (!hierarchyInfo) {
                return;
            }
            // 匹配节点
            const currentLayer = hierarchyInfo['layer'];
            const currentParentElement = hierarchyInfo['parentElement'];
            if ((currentLayer === fLayer + 1) && (currentParentElement === fParentElement || (!currentParentElement && fParentElement === ''))) {
                childNodesData.push(nodeData);
            }
        });
        return childNodesData;
    }
    getHierarchyInfo(nodeData) {
        return this.getValue(nodeData, this.hierarchyInfoKey); //nodeData[this.hierarchyInfoKey];
    }
    getValue(target, path) {
        if (path.indexOf('/') === -1) {
            return target[path];
        }
        const paths = path.split('/').filter(p => p);
        return paths.reduce((result, path) => {
            return result && result[path];
        }, target);
    }
    /**
     * 获取分级信息中的层级
     * @param nodeData nodeData
     */
    getNodeLayer(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData);
        return hierarchyInfo['layer'];
    }
    /**
     * 获取分级信息中的父节点
     * @param nodeData nodeData
     */
    getNodeParentElement(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData);
        return hierarchyInfo['parentElement'];
    }
    /**
     * 获取展开状态
     */
    isExpanded(newData) {
        const oldTreeNode = this.getOldNode(newData);
        return oldTreeNode ? oldTreeNode.expanded : undefined;
    }
    /**
     * 是否是叶子节点
     * @todo：应该用数据本身的isDetail来保证，但目前不准确，强制前端计算
     */
    isLeaf(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData); //nodeData[this.hierarchyInfoKey];
        const isDetail = hierarchyInfo['isDetail'];
        return isDetail;
    }
    /**
     * 判断节点是否是新增
     * @todo：不应该这样判断，待优化。
     * @summary
     * 1、非空树（空树视为初次加载数据）；
     * 2、找不到oldNode。
     */
    isNewNode(nodeData) {
        if (this.allOldNodesMap.size === 0) {
            return false;
        }
        const oldTreeNode = this.getOldNode(nodeData);
        return oldTreeNode ? false : true;
    }
    /**
     * 展开父节点
     */
    expandParentNode(nodeData) {
        const parentTreeNode = this.getParentNode(nodeData);
        if (!parentTreeNode) {
            return;
        }
        parentTreeNode.leaf = false;
        parentTreeNode.expanded = true;
    }
    /**
     * 查找父节点
     */
    getParentNode(nodeData) {
        const hierarchyInfo = this.getHierarchyInfo(nodeData); //nodeData[this.hierarchyInfoKey];
        const layer = hierarchyInfo['layer'];
        const parentElement = hierarchyInfo['parentElement'];
        const allNodes = Array.from(this.allNodesMap.values());
        const parentNode = allNodes.find((node) => {
            const currentLayer = this.getValue(node.data, this.hierarchyInfoKey)['layer']; //node.data[this.hierarchyInfoKey]['layer'];
            const currentId = node.data[this.primaryKey];
            return currentId === parentElement && layer === (currentLayer + 1);
        });
        return parentNode;
    }
    /**
     * 获取老的树节点
     */
    getOldNode(nodeData) {
        const id = nodeData[this.primaryKey];
        return this.allOldNodesMap.get(id);
    }
    /**
     * 打平TreeNodes，并放入一个Map中
     */
    buildNodesDataMap(treeNodes) {
        treeNodes.forEach((treeNode) => {
            this.allOldNodesMap.set(treeNode.data[this.primaryKey], treeNode);
            if (treeNode.children) {
                this.buildNodesDataMap(treeNode.children);
            }
        });
    }
}

/*
 * @Author: aalizzwell
 * @Date: 2019-05-30 18:57:34
 * @Last Modified by:   aalizzwell
 * @Last Modified time: 2019-05-30 18:57:34
 */
class TreeNodeBuilderFactory {
    static getBuilder(hierarchyInfo) {
        let builder = PathTreeNodeBuilder;
        if (hierarchyInfo.hasOwnProperty("path")) {
            builder = PathTreeNodeBuilder;
        }
        else if (hierarchyInfo.hasOwnProperty("parentElement")) {
            builder = ParentTreeNodeBuilder;
        }
        return builder;
    }
}

/*
 * @Author: aalizzwell
 * @Date: 2020-02-27 11:33:41
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2020-02-27 11:34:16
 */
/**
 * 树表格绑定指令
 */
class FarrisTreeTableBindingDirective {
    /**
     * 构造函数
     */
    constructor(treeTable, treetableFormatSer, frameContext) {
        this.treeTable = treeTable;
        this.treetableFormatSer = treetableFormatSer;
        this.frameContext = frameContext;
        this.renderSubject = new Subject();
        /**
         * 启用节点分页
         */
        // @Input('enableNodePagination')
        // public enableNodePagination: boolean;
        /**
         * 节点分页大小
         */
        this.nodePageSize = 100;
        /* 设置行样式 */
        this.rowClass = new EventEmitter();
        /* 设置列样式 */
        this.cellClass = new EventEmitter();
        this._PROP = null;
        this.listeners = [];
        this.storage = [];
        this.viewModel.uiState.setPropertyValue('ids', this.treeTable.checkValues);
        this.renderSubject.pipe(debounceTime(500)).subscribe(() => {
            this.bindData();
        });
    }
    /**
     * 绑定数据
     */
    get bindingData() {
        return this.frameContext.bindingData;
    }
    /**
     * 绑定数据列表
     */
    get bindingList() {
        // @todo：只支持主表，没有处理bindingPath
        return this.bindingData.list;
    }
    get prop() {
        return this._PROP;
    }
    set prop(value) {
        this._PROP = value;
    }
    /**
     * 获取当前vm
     */
    get viewModel() {
        return this.frameContext.viewModel;
    }
    /**
     * 指令初始化
     */
    ngOnInit() {
        // 将分级码信息保存到root-component，而非整个表单的app-context
        const virtualRootFrameContext = this.frameContext.getVirtualRootFrameContext();
        virtualRootFrameContext.setParam('hierarchyInfoKey', this.hierarchyInfoKey);
        this.bindData();
        this.bindingData.changes.subscribe((change) => {
            if (change && (change.type === ChangeType.ValueChanged || change.type === ChangeType.PaginationInfoChange)) {
                this.renderSubject.next(change);
            }
            else {
                this.bindData();
            }
            // 设置当前行
            const currentId = this.bindingList.currentId;
            if (!this.frameContext.bindingData.rowSelectedEventSuspend && currentId) {
                this.setSelectedIdToTree(this.bindingList.currentId);
            }
            this.updateCheckedRows(change);
        });
        // 设置 树表 格式化
        this.treetableFormatSer.setFormat(this.treeTable);
        /* 行样式 */
        this.rowClass.emit(this.treeTable);
        /* 列样式  单元格样式 */
        this.cellClass.emit(this.treeTable);
        this.setComponentRef();
        this.setNodePaginationInfo();
        this.registerEvent();
        if (this.frameContext && this.frameContext.frameComponent) {
            this.frameContext.frameComponent.componentType = ComponentType.farrisTreeTalbeComponent;
        }
    }
    /**
     * 指令输入变更
     */
    ngOnChanges(changes) {
    }
    registerEvent() {
        this.treeTable.columnSorted.subscribe((event) => {
            const { sortName = null, sortOrder = null } = event;
            const remoteSort = this.treeTable.remoteSort;
            if (remoteSort === false) {
                if (sortName && sortOrder) {
                    this.bindingList.sortBy(sortName, sortOrder);
                }
            }
            this.bindData();
        });
    }
    /**
     * 收集树组件实例
     */
    setComponentRef() {
        const appContext = this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.getFormAppContext();
        const frameId = this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.frameId;
        const id = this.treeTable && this.treeTable.el.nativeElement.id || null;
        // 如果frameId不存在或treetable没有id属性，说明不符合使用场景
        if (!frameId || !id) {
            return;
        }
        const map = appContext && appContext.componentRefs && appContext.componentRefs.get(frameId) || new Map();
        appContext && appContext.componentRefs && appContext.componentRefs.set(frameId, map.set(id, this.treeTable));
    }
    setNodePaginationInfo() {
        if (this.frameContext) {
            const enableNodePagination = this.treeTable.paginationForChildren || false; //this.enableNodePagination || false;
            this.frameContext.params.set('enableNodePagination', enableNodePagination);
            const nodePageSize = this.nodePageSize || 0;
            this.frameContext.params.set('nodePageSize', nodePageSize);
        }
    }
    /**
     * 绑定数据
     */
    bindData() {
        const oldTreeNodes = this.treeTable.data;
        const treeNodesData = this.bindingList.toJSON({ ignoreMultiLangInput: true });
        // if (!this.shouldComponentUpdate(treeNodesData)) {
        //   return;
        // }
        this.prop = treeNodesData;
        let treeNodes = [];
        if (!!treeNodesData && treeNodesData.length > 0) {
            const hierarchyInfo = treeNodesData[0][this.hierarchyInfoKey];
            let builder = this.builder;
            if (!builder) {
                this.builder = TreeNodeBuilderFactory.getBuilder(hierarchyInfo);
                builder = this.builder;
            }
            // 服务器返回的分级节点信息匹配不到现有工厂里面的任何一种情况。确认新加的builder已经在工厂中注册
            if (builder == null) {
                throw new Error('TreeTable builder is null!');
            }
            let expandLevel = -1;
            const treeExpandLevel = this.treeTable['expandLevel'];
            if (typeof treeExpandLevel !== 'undefined') {
                expandLevel = treeExpandLevel;
            }
            const virtualRootFrameContext = this.frameContext.getVirtualRootFrameContext();
            const nodesShouldExpand = (virtualRootFrameContext.params.get('_DEVKIT_expandRowIds') || '').split(',') || [];
            const context = {
                expandLevel,
                addTreeLoadCompleteListener: this.addTreeLoadCompleteListener.bind(this),
                component: this.treeTable,
                storage: this.storage,
                nodesShouldExpand: nodesShouldExpand,
                frameContext: this.frameContext,
            };
            //if (!this.treeNodesBuilder) {
            this.treeNodesBuilder = new builder(treeNodesData, oldTreeNodes, this.bindingList.primaryKey, this.hierarchyInfoKey, context);
            //}
            // this.treeNodesBuilder.updateTreeNode(treeNodesData, oldTreeNodes);
            treeNodes = this.treeNodesBuilder.build();
        }
        this.treeTable.data = treeNodes;
        // 设置分页信息
        this.updatePageInfo(this.treeTable);
        this.onTreeLoadComplete();
    }
    onTreeLoadComplete() {
        if (this.listeners && this.listeners.length > 0) {
            this.listeners.forEach(listener => {
                listener();
            });
        }
    }
    addTreeLoadCompleteListener(listener) {
        this.listeners.push(listener);
    }
    shouldComponentUpdate(newProp) {
        if (JSON.stringify(this.prop) === JSON.stringify(newProp)) {
            return false;
        }
        return true;
    }
    /**
     * 从树组件上获取选中行的id
     */
    getSelectedIdFromTree() {
        const selectedRow = this.treeTable.selectedRow;
        return selectedRow ? selectedRow.data['id'] : null;
    }
    /**
     * 设置TreeTable的当前行
     */
    setSelectedIdToTree(selectedId) {
        if (!selectedId) {
            return;
        }
        // 如果新的currentId和树上的selectedId不一致，重置树的当前行
        const oldSelectedId = this.getSelectedIdFromTree();
        const nodePageChanged = this.frameContext.params.get('_NODE_PAGE_CHANGED_') || false;
        if (!oldSelectedId && nodePageChanged) {
            this.frameContext.params.delete('_NODE_PAGE_CHANGED_');
            return;
        }
        if (oldSelectedId !== selectedId) {
            this.treeTable.clearSelections();
            this.treeTable.selectNode(selectedId);
        }
    }
    /**
     * 设置BindingList的CurrentId
     */
    setCurrentIdToBindingList(selectedId) {
        const oldCurrentId = this.bindingData.list.currentId;
        // 单选模式下将当前行设置到ids
        if (!this.treeTable.multiSelect) {
            this.setChecks(selectedId);
            this.setCheckedRows([selectedId]);
        }
        if (oldCurrentId === selectedId) {
            return;
        }
        this.bindingData.list.setCurrentId(selectedId, true);
    }
    updateCheckedRows(changes) {
        if (changes.type === ChangeType.Load) {
            this.setCheckedRows();
        }
        else if (changes.type === ChangeType.ValueChanged || changes.type === ChangeType.Remove) {
            const ids = this.getChecks();
            if (changes.id && ids.includes(changes.id)) {
                this.setCheckedRows();
            }
        }
    }
    /**
     * 更新勾选行数据
     */
    setCheckedRows(ids) {
        if (typeof ids === 'undefined') {
            ids = this.viewModel.uiState['ids'] || [];
        }
        if (!Array.isArray(ids)) {
            return;
        }
        const list = this.bindingList.toJSON();
        const rows = this.viewModel.uiState['rows'] || new Map();
        const result = new Map();
        ids.forEach((id) => {
            const item = list.find(item => item[this.bindingList.primaryKey] === id);
            const otherPageItem = rows.get(id);
            if (item) {
                result.set(id, item);
            }
            else if (otherPageItem) {
                result.set(id, otherPageItem);
            }
        });
        this.viewModel.uiState.setPropertyValue('rows', result);
    }
    /**
     * 设置ids变量
     * @param idOrIds id or ids
     */
    setChecks(idOrIds) {
        if (typeof idOrIds === 'string') {
            idOrIds = idOrIds.split(',').filter(p => p);
        }
        this.viewModel.uiState.setPropertyValue('ids', idOrIds);
    }
    /**
     * 获取勾选行id数组
     * @returns
     */
    getChecks() {
        return this.viewModel.uiState['ids'] || [];
    }
    /**
     * 获取分页信息
     */
    getPagingInfo() {
        const bindingPath = this.viewModel.bindingPath;
        const bindingData = this.viewModel.bindingData;
        let pagingInfo = bindingData.pagingInfo;
        if (bindingPath === '/') {
            return pagingInfo;
        }
        else {
            const bindingPaths = bindingPath.substr(1).split('/').filter(item => !!item && item.length > 0).map(item => {
                return item.substring(0, item.length - 1);
            });
            bindingPaths.forEach(path => {
                pagingInfo = pagingInfo && pagingInfo[path];
            });
            return pagingInfo;
        }
    }
    updatePageInfo(treeTable) {
        const { pageIndex, pageSize, total } = this.getPagingInfo();
        if (pageSize === 0) {
            treeTable.pagination = false;
            return;
        }
        treeTable.pagination = true;
        treeTable.updatePageInfo({ pageIndex, pageSize, total });
    }
    //#region 组件事件
    /**
     * 行切换
     */
    selectionChangeHandler(event) {
        if (event && event.node && event.node.hasOwnProperty('data')) {
            const idField = this.treeTable.idField;
            const id = event.node.data[idField];
            this.setCurrentIdToBindingList(id);
        }
    }
    /**
     * 勾选节点发生变化
     * @param event event
     */
    checkValuesChange(event) {
        // this.viewModel.uiState.setPropertyValue('ids', this.treeTable.checkValues);
        this.setChecks(this.treeTable.checkValues);
        this.setCheckedRows();
    }
    /**
     * 将被展开的节点设置为当前行
     */
    expandHandler(event) {
        const selectedId = event.data['id'];
        const virtualRootFrameContext = this.frameContext.getVirtualRootFrameContext();
        // 展开时不再选中
        // this.setSelectedIdToTree(selectedId);
        const expandNodes = virtualRootFrameContext.getParam('TREE_LATEST_EXPANDED_ID') || [];
        expandNodes.push(selectedId);
        virtualRootFrameContext.setParam('TREE_LATEST_EXPANDED_ID', expandNodes);
    }
    onPageChanged(event) {
        let { pageSize = 20, pageIndex = 1 } = event || {};
        if (pageIndex < 1) {
            pageIndex = 1;
        }
        const skip = (pageIndex - 1) * pageSize;
        this.bindingData.setPagingInfo(skip, pageSize, this.bindingData.bindingPath);
    }
    onPageSizeChanged(event) {
        const pageSize = event ? event : 20;
        const skip = 0;
        this.bindingData.setPagingInfo(skip, pageSize, this.bindingData.bindingPath);
    }
    /**
     * 节点页码切换事件
     * @param event event
     */
    onNodePageChanged(event) {
        const { pageIndex = 1, pageSize = this.nodePageSize, node = {} } = event;
        const id = node && node.id || null;
        if (id) {
            const virtualRootFrameContext = this.frameContext.getVirtualRootFrameContext();
            const expandNodes = virtualRootFrameContext.getParam('TREE_LATEST_EXPANDED_ID') || [];
            expandNodes.push(id);
            virtualRootFrameContext.setParam('TREE_LATEST_EXPANDED_ID', expandNodes);
            this.frameContext.params.set(`_NODE_${id}_PAGE_INDEX_`, pageIndex);
            this.frameContext.params.set(`_RELOAD_CHILDREN_`, true);
            this.frameContext.params.set('_NODE_PAGE_CHANGED_', true);
        }
    }
}
FarrisTreeTableBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisTreeTableBinding]'
            },] }
];
/** @nocollapse */
FarrisTreeTableBindingDirective.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: FarrisTreetableFormatService },
    { type: FrameContext }
];
FarrisTreeTableBindingDirective.propDecorators = {
    hierarchyInfoKey: [{ type: Input, args: ['farrisHierarchyInfoKey',] }],
    rowClassName: [{ type: Input }],
    cellClassName: [{ type: Input }],
    nodePageSize: [{ type: Input, args: ['nodePageSize',] }],
    rowClass: [{ type: Output }],
    cellClass: [{ type: Output }],
    selectionChangeHandler: [{ type: HostListener, args: ['nodeSelected', ['$event'],] }],
    checkValuesChange: [{ type: HostListener, args: ['checkValuesChange', ['$event'],] }],
    expandHandler: [{ type: HostListener, args: ['expand', ['$event'],] }],
    onPageChanged: [{ type: HostListener, args: ['pageChanged', ['$event'],] }],
    onPageSizeChanged: [{ type: HostListener, args: ['pageSizeChanged', ['$event'],] }],
    onNodePageChanged: [{ type: HostListener, args: ['childsPageChanged', ['$event'],] }]
};

/**
 * 帮助映射基类
 */
class DataMapping {
    constructor() {
        /**
         * 多选帮助默认分隔符
         */
        this.defaultSpliter = ',';
    }
    /**
     * 映射数据
     * @param helpData 清空时，值为null
     * @param mapFields 格式形如：{id: "assoField.assoField", code: "assoField.assoField_Code", name: "assoField.assoField_Name"}
     * @param asClear 类似清空
     * @param [spliter=','] 多选分隔符
     */
    mappingData(helpData, mapFields, asClear = false, spliter = ',') {
        if (!mapFields) {
            return;
        }
        // 关闭变更检测
        const appContext = this.vm.frameContext.appContext;
        appContext.changeDetectionController.detach();
        let helpFields = Object.keys(mapFields);
        const basePaths = this.getBindingPathArray();
        const primaryInfo = this.getMapFieldsPrimaryKey(mapFields, basePaths);
        // 映射到目标主键的源字段数组
        const primaryKeys = primaryInfo && primaryInfo.map((item) => item.primaryKey) || [];
        // 目标主键字段数组
        const primaryFields = primaryInfo && primaryInfo.map((item) => item.primaryField) || [];
        // 对映射中的key进行排序，使映射到目标主键的key排到前面
        helpFields = this.sortMapFieldKeys(helpFields, primaryKeys);
        if (!helpData || asClear) {
            helpFields.reverse();
        }
        this.mapping(helpFields, mapFields, helpData, primaryFields, basePaths, asClear, spliter);
        // 重新打开变更检测
        appContext.changeDetectionController.reattach();
    }
    mapping(sortedKeyFields, mapFields, helpData, targetPrimaryFields, basePaths, asClear = false, spliter = ',') {
        sortedKeyFields.forEach((field) => {
            const val = this.getHelpValue(field, helpData, spliter);
            let mappings = mapFields[field].split(',');
            const headMappings = mappings.filter((p) => targetPrimaryFields.includes(p));
            const leftMappings = mappings.filter((p) => !targetPrimaryFields.includes(p));
            if (!helpData || asClear) {
                mappings = [].concat(leftMappings).concat(headMappings);
            }
            else {
                mappings = [].concat(headMappings).concat(leftMappings);
            }
            this.updateTarget(mappings, basePaths, helpData, val);
        });
    }
    updateTarget(mappings, basePaths, helpData, value) {
        mappings.forEach((targetFieldPath) => {
            this.updateTargetValue(basePaths, targetFieldPath, value, helpData);
        });
    }
    updateTargetValue(basePaths, targetFieldPath, value, helpData) {
        if (this.target) {
            const paths = targetFieldPath.split('.');
            this.setValue(this.target, paths, value);
        }
        else {
            const paths = basePaths.concat(targetFieldPath.split('.'));
            if (!helpData) {
                this.vm.bindingData.clearValue(paths, true, true, { frameContext: this.vm.frameContext });
            }
            else {
                this.vm.bindingData.setValue(paths, value, true, true, null, { frameContext: this.vm.frameContext });
            }
        }
    }
    /**
     * 获取帮助字段对应的值
     * @param field 帮助字段
     * @param helpData 帮助数据
     * @param [spliter=','] 多选帮助分隔符
     * @returns
     */
    getHelpValue(field, helpData, spliter = ',') {
        let value = '';
        if (helpData) {
            if (helpData instanceof Array) {
                value = helpData.map((item) => {
                    return this.getValue(field, item);
                }).join(spliter);
            }
            else {
                value = this.getValue(field, helpData);
            }
        }
        return value;
    }
    getValue(f, data) {
        let val = '';
        if (f.indexOf('.') === -1) {
            val = data[f];
        }
        else {
            val = f.split('.').reduce((a, b) => {
                return a[b];
            }, data);
        }
        return val;
    }
    setValue(target, paths, value) {
        if (target) {
            if (paths.length <= 1) {
                target[paths[0]] = value;
            }
            else {
                paths.slice(0, -1).reduce((prev, path) => {
                    if (!(prev.hasOwnProperty(path) || prev['__proto__'].hasOwnProperty(path))) {
                        prev[path] = {};
                    }
                    return prev[path];
                }, target)[paths[paths.length - 1]] = value;
            }
        }
    }
    getBindingPathArray() {
        const path = this.vm.bindingPath;
        if (path) {
            return path.split('/').filter((n) => n !== '');
        }
        return [];
    }
    isNumberValue(field, data) {
        const currentVal = this.getValue(field, data);
        return isNumber(currentVal);
    }
    /**
     *
     * @param mapFields  格式形如：{id: "assoField.assoField", code: "assoField.assoField_Code", name: "assoField.assoField_Name"} 或者 {id:'vid',code:'code',name:'name'}
     */
    getMapFieldsPrimaryKey(mapFields, bindingPaths) {
        if (!mapFields || Object.keys(mapFields).length < 1) {
            return null;
        }
        const results = [];
        // let primaryField = null;
        try {
            const entityTypeInfo = this.vm.frameContext.repository.entityTypeInfo;
            Object.keys(mapFields).forEach((key) => {
                const mapField = mapFields[key];
                if (mapField && typeof mapField === 'string') {
                    const mappings = mapField.split(',').filter((p) => p);
                    mappings.forEach((item) => {
                        let paths = item.split('.');
                        if (bindingPaths && bindingPaths.length > 0) {
                            paths = bindingPaths.concat(paths);
                        }
                        const propInfo = entityTypeInfo.getPropInfoByPath(paths);
                        if (propInfo && propInfo.metadataInfo && propInfo.metadataInfo.primary === true) {
                            results.push({
                                primaryKey: key,
                                primaryField: item
                            });
                        }
                    });
                }
            });
        }
        catch (e) {
            console.error(e);
        }
        return results;
    }
    sortMapFieldKeys(keys, primaryKeys) {
        if (!primaryKeys || primaryKeys.length < 1 || !keys || keys.length < 1) {
            return keys;
        }
        primaryKeys = [...new Set(primaryKeys)];
        // 过滤出非主键映射字段
        keys = keys.filter((p) => !primaryKeys.includes(p));
        return [].concat(primaryKeys).concat(keys);
    }
}

/*
 * @Author: 疯狂秀才(lucas huang)
 * @Date: 2018-11-07 16:31:57
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-09-27 14:57:22
 * @Company: Inspur
 * @Version: v0.0.1
 */
class LookupDataMappingDirective extends DataMapping {
    constructor(vm, lookup) {
        super();
        this.vm = vm;
        this.lookup = lookup;
        this.target = null;
    }
    ngOnInit() {
        this.lookup.selectedData.subscribe((data) => {
            const _mapfields = this.mapfields || this.lookup.mapFields;
            const spliter = this.lookup.multipleChoiceSeparator || this.defaultSpliter;
            this.mappingData(data, _mapfields, false, spliter);
        });
        this.lookup.clearMappings.subscribe((result) => {
            // const value = result && result.value || null;
            const mapfields = Object.assign({}, (this.mapfields || this.lookup.mapFields || {}));
            const lookupTextField = this.lookup.textField;
            const data = {};
            const controlName = this.lookup.ngControl && this.lookup.ngControl.name;
            if (controlName && this.vm) {
                const textFieldMapping = mapfields[lookupTextField];
                const ngFormControl = this.vm && this.vm.form && this.vm.form.ngFormControls && this.vm.form.ngFormControls[controlName];
                const binding = ngFormControl && ngFormControl.binding;
                if (textFieldMapping && binding) {
                    mapfields[lookupTextField] = textFieldMapping.split(',').filter((item) => item !== binding).join(',');
                }
            }
            // this.setValue(data, lookupTextField.split('.'), value);
            Object.keys(mapfields).forEach((field) => {
                this.setValue(data, field.split('.'), '');
            });
            this.mappingData(data, mapfields, true);
        });
        this.lookup.clear.subscribe(() => {
            const _mapfields = this.mapfields || this.lookup.mapFields;
            this.mappingData(null, _mapfields);
        });
    }
}
LookupDataMappingDirective.decorators = [
    { type: Directive, args: [{ selector: '[data-mapping]' },] }
];
/** @nocollapse */
LookupDataMappingDirective.ctorParameters = () => [
    { type: ViewModel, decorators: [{ type: Optional }] },
    { type: LookupGridComponent, decorators: [{ type: Optional }, { type: Self }] }
];
LookupDataMappingDirective.propDecorators = {
    mapfields: [{ type: Input, args: ['data-mapping',] }],
    target: [{ type: Input, args: ['target',] }]
};

// tslint:disable-next-line: directive-selector
class LookupEnableExtendLoadMethodDirective {
    constructor(frameContext, lookup) {
        this.frameContext = frameContext;
        this.lookup = lookup;
    }
    ngOnInit() {
        if (!this.frameContext || !this.lookup || this.enableExtendLoadMethod !== true) {
            return;
        }
        const befApiUrl = this.frameContext.repository.apiUri;
        const helpMetadataId = this.lookup.uri;
        const enableKey = `${helpMetadataId}@${befApiUrl}`;
        this.frameContext.setParam(enableKey, true);
    }
}
LookupEnableExtendLoadMethodDirective.decorators = [
    { type: Directive, args: [{
                selector: '[enableExtendLoadMethod]'
            },] }
];
/** @nocollapse */
LookupEnableExtendLoadMethodDirective.ctorParameters = () => [
    { type: FrameContext, decorators: [{ type: Optional }] },
    { type: LookupGridComponent, decorators: [{ type: Optional }, { type: Self }] }
];
LookupEnableExtendLoadMethodDirective.propDecorators = {
    enableExtendLoadMethod: [{ type: Input }]
};

class UIStateBindingDirective {
    constructor(hostComboComponent, hostHelpComponent, differs, hostComboListComponent, hostComboLookupComponent) {
        this.hostComboComponent = hostComboComponent;
        this.hostHelpComponent = hostHelpComponent;
        this.differs = differs;
        this.hostComboListComponent = hostComboListComponent;
        this.hostComboLookupComponent = hostComboLookupComponent;
        this.defaultSpliter = ',';
        this.differ = null;
        this.UIStateBindingChange = new EventEmitter();
    }
    set bindingObject(value) {
        this._bindingObject = value;
        if (!this.differ && value && this.differs && typeof (value) === 'object') {
            this.differ = this.differs.find(value).create();
        }
    }
    get bindingObject() {
        return this._bindingObject;
    }
    onValueChange(val) {
        // host is combobox
        if (this.hostComboComponent && this.bindingObject) {
            if (val) {
                this.bindingObject.key = val.value;
                this.bindingObject.value = val.name;
            }
            else {
                this.bindingObject.key = null;
                this.bindingObject.value = null;
            }
        }
    }
    ngOnInit() {
        if (this.hostComboComponent) {
            this.hostComboComponent.valuePrimitive = false;
        }
        else if (this.hostHelpComponent) {
            this.bindObjectToHostLookup();
        }
        else if (this.hostComboListComponent) {
            this.bindObjectToHostComboList();
        }
        else if (this.hostComboLookupComponent) {
            this.bindObjectToHostComboLookup();
        }
    }
    ngDoCheck() {
        if (this.differ && typeof (this.bindingObject) === 'object') {
            const changes = this.differ && this.differ.diff(this.bindingObject);
            if (changes) {
                this.bindingChanges();
            }
        }
        else { // 兼容未重新编译工程，differ不存在从情况
            this.bindingChanges();
        }
    }
    bindingChanges() {
        const text = this.bindingObject ? this.bindingObject.value : null;
        const key = this.bindingObject ? this.bindingObject.key : null;
        if (this.hostComboComponent) {
            this.hostComboComponent.text = text;
            const vField = this.hostComboComponent.valueField;
            const item = this.hostComboComponent.data.find((n) => n[vField] === key);
            this.hostComboComponent.writeValue(item);
        }
        else if (this.hostHelpComponent) {
            this.hostHelpComponent.writeValue(text);
            this.hostHelpComponent.displayValue = key;
        }
        else if (this.hostComboListComponent) {
            this.hostComboListComponent.writeValue(key);
        }
        else if (this.hostComboLookupComponent) {
            this.hostComboLookupComponent.selectedValues = key;
            this.hostComboLookupComponent.writeValue(text);
        }
    }
    ngOnChanges(changes) {
        if (changes.bindingObject && !this.differ) {
            this.bindingChanges();
        }
    }
    // 弹出帮助
    bindObjectToHostLookup() {
        if (!this.hostHelpComponent) {
            return;
        }
        this.hostHelpComponent.selectedData.subscribe((data) => this.updateHelpBindingObject(data));
        this.hostHelpComponent.clear.subscribe(() => {
            // this.bindingObject = {key: null, value: null};
            this.updateHelpBindingObject(null);
        });
        if (this.hostHelpComponent.tagRemoved) {
            this.hostHelpComponent.tagRemoved.subscribe((event) => {
                const { removedIndex: index = -1, instance: componentRef = null } = event;
                if (index === -1) {
                    return;
                }
                const isSigleSelect = componentRef.singleSelect;
                if (isSigleSelect || !componentRef.displayValue) {
                    this.updateHelpBindingObject(null);
                }
                else {
                    this.UIStateBindingChange.emit({ key: componentRef.displayValue, value: componentRef.displayText });
                }
            });
        }
        if (this.hostHelpComponent.nosearch) {
            this.hostHelpComponent.valueChanged.subscribe((txt) => {
                const idField = this.hostHelpComponent.idField;
                const textField = this.hostHelpComponent.textField;
                this.updateHelpBindingObject({
                    [idField]: txt,
                    [textField]: txt
                });
            });
        }
    }
    // 下拉列表
    bindObjectToHostComboList() {
        if (!this.hostComboListComponent) {
            return;
        }
        this.hostComboListComponent.valueChange.subscribe((data) => this.updateHelpBindingObject(data.selections));
        this.hostComboListComponent.clear.subscribe(() => {
            this.updateHelpBindingObject(null);
        });
    }
    // 下拉帮助
    bindObjectToHostComboLookup() {
        if (!this.hostComboLookupComponent) {
            return;
        }
        if (this.hostComboLookupComponent.multiSelect) {
            this.hostComboLookupComponent.valueChange.subscribe((data) => this.updateHelpBindingObject(data.selections));
        }
        else {
            // this.hostComboLookupComponent.selectChange.subscribe((data: any) => this.updateHelpBindingObject(data));
            this.hostComboLookupComponent.selectChange.subscribe((e) => {
                let data = e;
                if (e.data) {
                    data = e.data;
                }
                this.updateHelpBindingObject(data);
            });
        }
        this.hostComboLookupComponent.clear.subscribe(() => {
            this.updateHelpBindingObject(null);
        });
    }
    // 更新UISTATE
    updateHelpBindingObject(data) {
        let idField;
        let textField;
        let spliter = this.defaultSpliter;
        if (this.hostHelpComponent) {
            idField = this.hostHelpComponent.idField;
            textField = this.hostHelpComponent.textField;
            spliter = this.hostHelpComponent.multipleChoiceSeparator || this.defaultSpliter;
        }
        if (this.hostComboListComponent) {
            idField = this.hostComboListComponent.idField;
            textField = this.hostComboListComponent.textField;
        }
        if (this.hostComboLookupComponent) {
            idField = this.hostComboLookupComponent.idField;
            textField = this.hostComboLookupComponent.textField;
            spliter = this.hostComboLookupComponent.separator || this.defaultSpliter;
        }
        this.emitUiStateBinding(data, idField, textField, spliter);
    }
    emitUiStateBinding(data, idField, textField, spliter = ',') {
        const newObject = { key: null, value: null };
        if (data) {
            // const idField = this.hostHelpComponent.idField;
            // const textField = this.hostHelpComponent.textField;
            if (Array.isArray(data)) {
                newObject.key = data.map((d) => d[idField]).join(spliter);
                newObject.value = data.map((d) => {
                    if (textField.indexOf('.') > -1) {
                        return textField.split('.').reduce((r, c) => {
                            return r[c];
                        }, d);
                    }
                    else {
                        return d[textField];
                    }
                }).join(spliter);
            }
            else {
                if (idField) {
                    newObject.key = data[idField];
                }
                if (textField) {
                    if (textField.indexOf('.') > -1) {
                        newObject.value = textField.split('.').reduce((r, c) => {
                            return r[c];
                        }, data);
                    }
                    else {
                        newObject.value = data[textField];
                    }
                }
            }
        }
        this.UIStateBindingChange.emit(newObject);
    }
}
UIStateBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[UIStateBinding]'
            },] }
];
/** @nocollapse */
UIStateBindingDirective.ctorParameters = () => [
    { type: ComboBoxComponent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: LookupGridComponent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: KeyValueDiffers, decorators: [{ type: Optional }] },
    { type: ComboListComponent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] },
    { type: ComboLookupComponent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] }
];
UIStateBindingDirective.propDecorators = {
    bindingObject: [{ type: Input, args: ['UIStateBinding',] }],
    UIStateBindingChange: [{ type: Output }],
    onValueChange: [{ type: HostListener, args: ['valueChange', ['$event'],] }]
};

class FarrisDisabledDirective {
    constructor(grid, el, renderer) {
        this.grid = grid;
        this.el = el;
        this.renderer = renderer;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (!this.maskElement) {
            this.createMaskElement();
        }
        if (changes['kendoGridDisabled'] && this.maskElement) {
            if (this.kendoGridDisabled) {
                this.renderer.removeStyle(this.maskElement, 'display');
            }
            else {
                this.renderer.setStyle(this.maskElement, 'display', 'none');
            }
        }
    }
    createMaskElement() {
        this.maskElement = this.renderer.createElement("div");
        this.renderer.setStyle(this.maskElement, 'width', '100%');
        this.renderer.setStyle(this.maskElement, 'height', '100%');
        this.renderer.setStyle(this.maskElement, 'position', 'absolute');
        this.renderer.setStyle(this.maskElement, 'background-color', 'rgba(255,255,255,0.5)');
        this.renderer.setStyle(this.maskElement, 'z-index', '3');
        this.renderer.setStyle(this.maskElement, 'display', 'none');
        this.renderer.appendChild(this.el.nativeElement, this.maskElement);
    }
}
FarrisDisabledDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisDisabled]'
            },] }
];
/** @nocollapse */
FarrisDisabledDirective.ctorParameters = () => [
    { type: GridComponent },
    { type: ElementRef },
    { type: Renderer2 }
];
FarrisDisabledDirective.propDecorators = {
    kendoGridDisabled: [{ type: Input, args: ['farrisDisabled',] }]
};

class FarrisSortDirective {
}
FarrisSortDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisSort]'
            },] }
];
class FarrisTextareaEditDirective {
}
FarrisTextareaEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-textarea-edit]'
            },] }
];
class FarrisDynamicColumnFormatDirective {
}
FarrisDynamicColumnFormatDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisDynamicColumnFormat]'
            },] }
];
class FarrisEditEnterDirective {
}
FarrisEditEnterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-enter-edit]'
            },] }
];
FarrisEditEnterDirective.propDecorators = {
    farrisForm: [{ type: Input, args: ['form-group',] }]
};
class FarrisTreeTableFormatDirective {
}
FarrisTreeTableFormatDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisTreeTableFormat]'
            },] }
];

// tslint:disable: max-line-length
/*
 * 使用绑定数据指令
 */
class FarrisDatagridUseBindingDataDirective {
    // private renderGridDebounce;
    constructor(bindingData, viewModel, grid) {
        this.bindingData = bindingData;
        this.viewModel = viewModel;
        this.grid = grid;
        // 排序字段
        this.sortFields = null;
        // 排序方向
        this.sortDirections = null;
        /**
         * 是否已排序
         */
        this.hasSorted = false;
        /**
         * 过滤条件
         */
        this.filters = null;
        /**
         * 渲染grid
         */
        this.renderGridSubject = new Subject();
        this.enableFilterSorting = false;
        /**
         * 选中行切换事件
         */
        this.selectedRowChange = new EventEmitter();
        this.setChecks([]);
        this.enableFilterSorting = this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.injector.get(ENABLE_EDIT_STATE_FILTER_SORTING, false) || false;
        this.registerEvent();
    }
    get props() {
        return this._PROPS;
    }
    set props(value) {
        this._PROPS = value;
    }
    // #region Ng Event
    ngOnInit() {
        const { pageSize = 0 } = this.getPagingInfo() || {};
        if (pageSize !== 0) {
            // 启用分页
            if ((!this.grid.pageList || this.grid.pageList.length < 1) && typeof this.grid['setPageList'] === 'function') {
                this.grid['setPageList']([pageSize, pageSize * 2, pageSize * 3, pageSize * 4]);
            }
        }
        this.setComponentRef();
        this.bindData();
        window.setTimeout(() => {
            this.updateSelectedRow();
        }, 0);
        this.registerBindingDataChangeEvent();
        this.renderGridSubject.pipe(debounceTime(500)).subscribe((change) => {
            if (!this.viewModel || !this.viewModel.frameContext || this.viewModel.frameContext.isDisposed) {
                return;
            }
            this.bindData(change);
            /*if (!this.renderGridDebounce) {
              this.renderGridDebounce = this.debounce((change) => {
                this.bindData(change);
              }, 500);
            }
            this.renderGridDebounce(change);*/
        });
        if (this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.frameComponent) {
            this.viewModel.frameContext.frameComponent.componentType = ComponentType.farrisDataGridComponent;
        }
    }
    ngOnChanges(changes) {
        this.bindData();
    }
    // #endregion
    /**
     * 主键
     */
    get primaryKey() {
        return this.bindingList.primaryKey;
    }
    /**
     * 获取绑定数据
     */
    get bindingList() {
        // 根实体
        if (this.viewModel.bindingPath === '/' || !this.viewModel.bindingPath) {
            return this.bindingData.list;
        }
        // 子实体
        let bindingPath = this.viewModel.bindingPath.substr(1);
        bindingPath = bindingPath[0].toLowerCase() + bindingPath.substring(1, bindingPath.length);
        const paths = bindingPath.split('/');
        const filteredPaths = paths.filter((part) => {
            return part !== '';
        });
        return this.bindingData.getValue(filteredPaths);
    }
    /**
     * 设置组件引用
     */
    setComponentRef() {
        const appContext = this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.getFormAppContext();
        const frameId = this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.frameId;
        const id = this.grid && this.grid.id;
        // 如果frameId不存在或farris grid没有id属性，说明不符合使用场景
        if (!frameId || !id) {
            return;
        }
        const map = appContext && appContext.componentRefs && appContext.componentRefs.get(frameId) || new Map();
        appContext && appContext.componentRefs && appContext.componentRefs.set(frameId, map.set(id, this.grid));
    }
    /**
     * 获取分页信息
     */
    getPagingInfo() {
        const bindingPath = this.viewModel.bindingPath;
        const bindingData = this.viewModel.bindingData;
        const pagingInfo = bindingData && bindingData.pagingInfo || {};
        if (bindingPath === '/') {
            return pagingInfo;
        }
        else {
            const bindingPaths = bindingPath.substr(1).split('/').filter((item) => !!item && item.length > 0);
            // 从表及从从表分页和数据是关联的，因为不同的从表行有不同的从从表数据，分页信息的结构为nodeCode_parentId:{分页信息}且分页信息是平级的
            // {pagination:{a_pid:{pageSize:2,pageIndex:1},b_pid:{pageSize:2,pageIndex:1}}}
            // 取出当前路径下实体的nodeCode
            let nodeCode = bindingPaths[bindingPaths.length - 1];
            nodeCode = nodeCode.substr(0, nodeCode.length - 1);
            // 获取当前实体上级的主键
            // const result = pagingInfo[nodeCode] || {};
            // if (result.hasOwnProperty('totalCount')) {
            //   result.total = result.totalCount;
            // }
            // return result;
            const paths = bindingPaths.slice(0, bindingPaths.length - 1);
            const bindingList = bindingData.getValue(paths);
            const { pageSize = 0 } = pagingInfo[`${nodeCode}`] || {};
            // 上级表有数据
            if (bindingList && bindingList.currentId) {
                const key = `${nodeCode}_${bindingList.currentId}`;
                // const key = nodeCode;
                const result = pagingInfo[key] || {};
                if (result.hasOwnProperty('totalCount')) {
                    result.total = result.totalCount;
                }
                // 上级表虽然有数据，但上级表当前行的下级表可能没有数据，这就导致获取不到分页信息，所以需要在返回前对结果进行处理，如果没有分页信息的话起码应该返回分页大小及当前页码
                if (Object.keys(result).length < 1) {
                    result.pageIndex = 1;
                    result.pageSize = pageSize;
                }
                return result;
            }
            else {
                // 上级表没有数据，此时需要获取当前表的分页信息，如分页大小。当前页默认为1即可。
                return { pageIndex: 1, pageSize };
            }
        }
    }
    // #region Input
    /**
     * 组件是否需要更新
     * @param props 当前属性
     * @param nextProps 新属性
     * @param change 变更
     */
    shouldComponentUpdate(change, data) {
        const props = this.buildProps(data);
        if (this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.appContext && this.viewModel.frameContext.appContext.runMode === RunMode.highSpeed && change) {
            if (change.type === ChangeType.Load || change.type === ChangeType.Remove || change.type === ChangeType.PaginationInfoChange) {
                return { result: true, props };
            }
        }
        const gridProps = this.buildGridProps();
        if (JSON.stringify(props) === JSON.stringify(gridProps)) {
            return { result: false };
        }
        return { result: true, props };
    }
    registerEvent() {
        // 排序事件
        this.grid && this.grid.columnSorted && this.grid.columnSorted.subscribe((event) => {
            const isRemoteSort = this.grid.remoteSort;
            // 本地排序
            if (!isRemoteSort) {
                this.sortFields = this.grid.sortName;
                this.sortDirections = this.grid.sortOrder;
                this.sortBindingList();
                // this.props = this.buildProps();
            }
            else {
                // 服务器端排序
                const groupField = this.grid && this.grid.groupField || null;
                let sortFields = this.grid.sortName && this.grid.sortName.split(',') || [];
                const sortDirection = this.grid.sortOrder && this.grid.sortOrder.split(',') || [];
                if (groupField) {
                    if (!sortFields.includes(groupField)) {
                        sortFields.splice(0, 0, groupField);
                        sortDirection.splice(0, 0, 'asc');
                    }
                }
                // 获取当前entity上所有object属性
                const entityType = this.viewModel && this.viewModel.frameContext.repository.entityType || null;
                if (sortFields.length > 0) {
                    if (entityType) {
                        const dataTypeInfo = new DataTypeInfo(entityType);
                        sortFields = sortFields.map(field => {
                            //if (field && field.indexOf('.') !== -1) {
                            const paths = field.split('.');
                            const propInfo = dataTypeInfo.getPropInfoByPath(paths);
                            const originalField = propInfo && propInfo.metadataInfo['path'] || null;
                            return originalField;
                            //}
                            //return field;
                        });
                    }
                }
                // 遍历属性，根据datafield转换为originalDataField
                const fields = sortFields.join(',');
                const directions = sortDirection.join(',') || 'asc';
                const frameContext = this.viewModel && this.viewModel.frameContext || null;
                if (frameContext) {
                    frameContext.repository.sortConditionManager.setConditions(this.viewModel.bindingPath, fields, directions);
                }
            }
        });
        // 过滤事件
        this.grid && this.grid.filterChanged && this.grid.filterChanged.subscribe((event) => {
            this.filters = event;
            if (!this.grid.remoteFilter) {
                if (this.bindingList.length > 0 && !this.bindingList.currentId) {
                    const id = this.bindingList.getIdByIndex(0);
                    this.bindingList.setCurrentId(id);
                }
                this.bindingList.filter(this.filters);
                this.bindData();
            }
        });
        this.viewModel.frameContext.appContext.messagePipe.subscribe((message) => {
            if (message && message === 'CLEAR_GRID_CONDITION' && this.filters && Object.keys(this.filters).length > 0) {
                this.filters = {};
                this.bindData();
            }
        });
    }
    /**
     * 对bindingList排序
     * @param change change
     */
    sortBindingList(change) {
        // groupField可能有多个，以逗号分隔的字符串
        const groupField = this.grid && this.grid.groupField || null;
        if (groupField) {
            const arrSortFields = this.sortFields && this.sortFields.split(',') || [];
            const groupFields = groupField.split(',').reverse();
            groupFields.forEach((field) => {
                if (!arrSortFields.includes(field)) {
                    arrSortFields.splice(0, 0, field);
                    const arrSortDirection = this.sortDirections && this.sortDirections.split(',') || [];
                    arrSortDirection.splice(0, 0, 'asc');
                    this.sortFields = arrSortFields.join(',');
                    this.sortDirections = arrSortDirection.join(',') || 'asc';
                }
            });
        }
        this.bindingList.sortBy(this.sortFields, this.sortDirections);
        this.bindData(change);
    }
    // #endregion
    // #region 数据绑定部分
    /**
     * 更新数据
     * @param change? 变更
     */
    bindData(change) {
        const isRemoteFilter = this.grid && this.grid.remoteFilter || false;
        // 先执行排序
        const shouldSort = this.shouldSort(change);
        if (shouldSort) {
            this.hasSorted = true;
            this.sortBindingList(change);
            return;
        }
        this.hasSorted = false;
        // 新增数据时清空表格筛选条件
        if ((this.grid.editable === true || change && change.type === ChangeType.Append) && this.filters && Object.keys(this.filters).length > 0 && !isRemoteFilter) {
            if (!this.viewModel.frameContext.appContext.enableGridHeaderWhenEditing && !this.enableFilterSorting) {
                this.filters = {};
                this.grid.clearCondition();
            }
        }
        const shouldFiltering = this.shouldFiltering(change);
        if (shouldFiltering) {
            this.bindingList.filter(this.filters);
        }
        // 再toJSON
        const data = this.bindingList.toJSON();
        // if (this.filters && Object.keys(this.filters).length > 0 && !isRemoteFilter) {
        //   // data = this.grid.clientFilterService.executeFilter(data, this.filters);
        // }
        if (this.filters && Object.keys(this.filters).length > 0 && !isRemoteFilter && (!change || change && change.type !== ChangeType.SelectionChanged && change.type !== ChangeType.GlobalSelectionChanged)) {
            if (data && data.length > 0) {
                // 判断当前行是否在过滤后的数据中
                const row = data.find((item) => item[this.bindingList.primaryKey] === this.bindingList.currentId);
                if (!row) {
                    const firstRowId = data[0][this.bindingList.primaryKey];
                    this.bindingList.setCurrentId(firstRowId, true, true);
                }
            }
            else {
                // 本地过滤完之后没有数据了
                // this.bindingList.currentId = null;
                if (this.bindingList.currentId) {
                    this.bindingList.setCurrentId(null, true, true, true);
                }
                // 单选时清空ids
                if (!this.grid.multiSelect) {
                    this.setChecks([]);
                }
            }
        }
        const result = this.shouldComponentUpdate(change, data);
        if (!result.result) {
            return;
        }
        // const nextProps = this.buildProps(result);
        this.renderGrid(result.props);
        this.props = JSON.parse(JSON.stringify(result.props));
    }
    /**
     * 是否应该过滤
     * @param change - change
     * @returns {boolean}
     */
    shouldFiltering(change) {
        const isRemoteFilter = this.grid && this.grid.remoteFilter || false;
        // 启用远端过滤时不需要本地过滤
        if (isRemoteFilter === true) {
            return false;
        }
        // 没有过滤条件时不需要执行过滤
        if (!this.filters || Object.keys(this.filters).length < 1) {
            return false;
        }
        if (change) {
            return change.type === ChangeType.Load;
        }
        return !this.grid.editable;
    }
    shouldSort(change) {
        // this.sortFields && !this.grid.editable && change && (change.type === 'Load' || change.type === 'SelectionChanged')
        if (!this.sortFields || Object.keys(this.sortFields).length < 1) {
            return false;
        }
        if (this.hasSorted) {
            return false;
        }
        if (change) {
            return change.type === 'Load' || change.type === 'SelectionChanged';
        }
        return this.grid.editable;
    }
    /**
     * 渲染grid
     * @param props 属性
     */
    renderGrid(props) {
        const { pageIndex, pageSize, total, pagination, data } = props;
        const virtualizedLoad = this.grid.virtualizedAsyncLoad || false;
        this.grid.total = total;
        this.grid.pageSize = pageSize;
        this.grid.pageIndex = pageIndex;
        this.grid.pagination = pagination;
        this.grid.controlPaginationState = false;
        // this.endCellEdit();
        if (pageSize === 0) {
            this.grid.pagination = false;
            this.grid.pageIndex = 1;
            // 修复不分页时grid启用分组仍会重新邦数的问题
            // this.grid.pageSize = total;
        }
        if (virtualizedLoad) {
            this.grid.loadVirtualData({
                items: data,
                pageIndex,
                pageSize,
                total
            });
        }
        else {
            this.grid.loadData(data);
        }
    }
    /**
     * 构造表格数据属性
     */
    buildProps(datas) {
        let data;
        if (typeof (datas) !== 'undefined') {
            data = datas;
        }
        else {
            data = this.bindingList.toJSON();
        }
        // let skip = 0;
        let { pageIndex = 1, pageSize = 0 } = this.getPagingInfo() || {};
        let { total = 0 } = this.getPagingInfo() || {};
        // if (pageIndex > 0) {
        //   skip = (pageIndex - 1) * pageSize;
        // }
        if (pageSize === 0 && total === 0) {
            total = data.length;
        }
        return { data, pageIndex, pageSize, total, pagination: pageSize !== 0 };
    }
    /**
     * 计算grid状态
     */
    buildGridProps() {
        const data = this.grid.data || [];
        const { pageIndex = 1, pageSize = 0 } = { pageIndex: this.grid.pageIndex, pageSize: this.grid.pageSize };
        let total = this.grid.total || 0;
        if (pageSize === 0 && total === 0) {
            total = data.length;
        }
        return { data, pageIndex, pageSize, total, pagination: this.grid.pagination };
    }
    /**
     * 数据源发生变更
     * @param change 变更
     */
    onBindingDataChange(change) {
        this.updateDataSource(change);
        this.updateSelectedRow(change);
        // this.updateGrid(change);
        // 不清除勾选行，需要保留勾选状态
        // this.clearCheckedRows(change);
        this.endCellEdit(change);
        // 更新勾选行数据
        this.updateCheckedRows(change);
        this.updateData(change);
    }
    /**
     * 更新数据
     */
    updateDataSource(change) {
        if (change && change.type === ChangeType.ValueChanged) {
            // 计算变更路径中表名及字段名
            const paths = change.path;
            try {
                const entityPath = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.viewModel.frameContext.repository.entityTypeInfo);
                if (this.viewModel.bindingPath === '/' + entityPath.join('/')) {
                    const propertyNames = paths.slice(entityPath.length);
                    if (change.id && this.grid && change.path && this.viewModel.frameContext.appContext.runMode !== RunMode.highSpeed && propertyNames && propertyNames.length > 0) {
                        this.grid.updateRow(change.id, { [propertyNames.join('.')]: change.value });
                    }
                }
            }
            catch (error) {
                console.warn(error);
            }
            this.renderGridSubject.next(change);
        }
        else if (change && (change.type === ChangeType.SelectionChanged || change.type === ChangeType.GlobalSelectionChanged)) {
            if (this.bindingList.currentId === (this.grid.selectedRow && this.grid.selectedRow.id) && this.grid.total > 0) ;
            else {
                this.bindData(change);
            }
        }
        else {
            this.bindData(change);
        }
    }
    // private endCellEdit() {
    //   const isEditing = this.grid.isEditing();
    //   if (isEditing) {
    //     this.grid.endCellEdit();
    //   }
    // }
    endCellEdit(change) {
        const isEditing = this.grid.isEditing();
        if (change.type === ChangeType.Load && isEditing) {
            this.grid.endCellEdit();
        }
    }
    /**
     * 设置grid当前选择行
     * @param change 变更
     */
    updateSelectedRow(change) {
        if (!this.bindingList || !this.bindingList.currentId) {
            return;
        }
        // 页码切换时不执行当前行切换
        if (change && change.type === ChangeType.PaginationInfoChange) {
            return;
        }
        if (this.viewModel && this.viewModel.frameContext.bindingData.rowSelectedEventSuspend === true) {
            return;
        }
        const { id: gridSelectedRowId = null } = this.grid.selectedRow || {};
        const currentId = this.bindingList.currentId;
        // grid当前行与bingingList当前行一致，无须切换
        if (gridSelectedRowId === currentId) {
            const isMatch = change && (change.path.toString() === this.viewModel.bindingPath.split('/').filter(p => p).toString());
            if (change && change.type === ChangeType.Load && isMatch) {
                this.grid.clearSelections();
                this.grid.selectRow(currentId, true, true);
            }
            return;
        }
        this.selectGridRow(this.bindingList.currentId);
    }
    /**
     * 注册bindingdata变化事件
     */
    registerBindingDataChangeEvent() {
        this.bindingDataChangeEvent = this.bindingData.changes.subscribe((change) => {
            this.onBindingDataChange(change);
        });
        this.viewModel.frameContext.appContext.messagePipe.subscribe(message => {
            if (message === 'bindData') {
                this.bindData();
            }
        });
    }
    /**
     * 取消bindingdata变化订阅
     */
    unRegisterBindingDataChangeEvent() {
        if (this.bindingDataChangeEvent && typeof (this.bindingDataChangeEvent.unsubscribe) === 'function') {
            this.bindingDataChangeEvent.unsubscribe();
        }
    }
    /**
     * 触发页码切换事件
     * @description 本方法适用场景仅为父级grid数据重新load，需要触发该grid重新取数使用。其他场景请勿使用
     * @TODO: 待重构，控制下级数据加载应该依赖表格的行切换事件，临时这样处理，后续提供LoadChildren事件
     */
    updateData(change) {
        if (!(change && (change.type === ChangeType.SelectionChanged || change.type === ChangeType.Load))) {
            return;
        }
        const bindingPath = this.viewModel.bindingPath;
        const eventBindingPath = '/' + change.path.join('/');
        const isRetrieve = this.viewModel.frameContext.appContext.params.get('retrieveing') || false;
        if (change.path.length < 1 || bindingPath === '/' || bindingPath === eventBindingPath || !bindingPath.startsWith(eventBindingPath)) {
            return;
        }
        // retrieve时会自动带回从表第一页及从表第一行的从从表数据，所以不需要再去单独请求
        if (isRetrieve) {
            return;
        }
        const fullPaths = EntityPathConverter.toEntityPathArray(this.viewModel.bindingPath, this.bindingData);
        const paths = fullPaths.slice(0, fullPaths.length - 1);
        const parent = this.bindingList.parent;
        const parentId = parent && parent[parent.primaryKey];
        // 上级表没有数据
        if (!parentId) {
            return;
        }
        // 获取nodecode
        const bindingPaths = this.viewModel.bindingPath.split('/').filter(item => item);
        let nodeCode = bindingPaths[bindingPaths.length - 1];
        nodeCode = nodeCode.substr(0, nodeCode.length - 1);
        // const configPath = `/${nodeCode}_${parentId}`;
        const configPath = `/${nodeCode}`;
        let { pageIndex = 1 } = this.viewModel.frameContext.repository.entityCollection.getPaginationConfigByPath(configPath) || {};
        const { pageSize = 0 } = this.viewModel.frameContext.repository.entityCollection.getPaginationConfigByPath(configPath) || {};
        const parentNodeCode = change.path[change.path.length - 1];
        const parentConfigPath = '/' + parentNodeCode.substring(0, parentNodeCode.length - 1);
        const { pageSize: parentPageSize = 0 } = this.viewModel.frameContext.repository.entityCollection.getPaginationConfigByPath(parentConfigPath) || {};
        const isQueryChild = this.viewModel.frameContext.appContext.params.get('queryChild') || false;
        if (isQueryChild) {
            // this.viewModel.frameContext.appContext.params.delete('queryChild');
            pageIndex = 1;
        }
        // 当上级表切换行时
        if (parentPageSize + pageSize !== 0) {
            this.viewModel.frameContext.appContext.params.set('forceQueryChild', true);
            this.viewModel.frameContext.repository.queryChild(paths, pageIndex, pageSize).pipe(finalize(() => this.viewModel.frameContext.appContext.params.delete('forceQueryChild'))).subscribe();
        }
    }
    ngOnDestroy() {
        this.unRegisterBindingDataChangeEvent();
    }
    // #endregion
    // #region 事件发射器
    /**
     * 发射选中行切换事件
     * @description 统一单选模式和多选模式下的行切换事件
     */
    fireSelectedRowChange(selectedRowContext) {
        this.selectedRowChange.emit(selectedRowContext);
    }
    /**
     * 清空选定行
     * @param change 变更
     */
    clearCheckedRows(change) {
        if (change.type === ChangeType.Load && this.grid.multiSelect) {
            const isMatch = this.checkIfChangeMatchBindingPath(change);
            if (isMatch) {
                this.setChecks([]);
                if (typeof (this.grid.clearCheckeds) === 'function') {
                    this.grid.clearCheckeds();
                }
            }
        }
    }
    // #endregion
    // #region 通信
    /**
     * 设置BindingList的当前行
     * @param id 当前行内码
     */
    setSelectionIdToBindingData(id) {
        // 如果当前行不存在，则强制设置
        if (!id) {
            this.bindingList.currentId = id;
            if (!this.grid.multiSelect) {
                this.setChecks([]);
            }
            return;
        }
        if (this.bindingList.currentId !== id) {
            this.bindingList.setCurrentId(id, true);
        }
        // 单选模式下将当前行设置到ids
        if (!this.grid.multiSelect) {
            this.setChecks([id]);
        }
    }
    updateCheckedRows(changes) {
        if (changes.type === ChangeType.Load) {
            this.setCheckedRows();
        }
        else if (changes.type === ChangeType.ValueChanged) {
            const ids = this.getChecks();
            if (changes.id && ids.includes(changes.id)) {
                this.setCheckedRows();
            }
        }
    }
    /**
     * 设置选择行
     */
    setChecks(ids) {
        this.viewModel.uiState.setPropertyValue('ids', ids);
        this.setCheckedRows(ids);
    }
    /**
     * 获取勾选行id数组
     * @returns
     */
    getChecks() {
        return this.viewModel.uiState['ids'] || [];
    }
    /**
     * 更新勾选行数据
     */
    setCheckedRows(ids) {
        // 高速模式时不再设置rows
        // if (this.viewModel.frameContext.appContext.runMode === RunMode.highSpeed) {
        //   return;
        // }
        if (typeof ids === 'undefined') {
            ids = this.viewModel.uiState['ids'] || [];
        }
        if (!Array.isArray(ids) || ids.length < 1) {
            // 此时ids没有值，rows中也不应该有
            this.viewModel.uiState.setPropertyValue('rows', null);
            return;
        }
        let list = [];
        // TODO：rows中数据在高速模式和普通模式下多语字段的值表现不一致，高速模式下多语字段值为对象，普通模式为当前语言。暂不处理高速模式场景
        if (this.viewModel.frameContext.appContext.runMode === RunMode.highSpeed) {
            list = this.grid.data || [];
        }
        else {
            list = this.bindingList.toJSON({ ignoreMultiLangInput: true });
        }
        const rows = this.viewModel.uiState['rows'] || new Map();
        const result = new Map();
        ids.forEach((id) => {
            const item = list.find(item => item[this.primaryKey] === id);
            const otherPageItem = rows.get(id);
            if (item) {
                result.set(id, item);
            }
            else if (otherPageItem) {
                result.set(id, otherPageItem);
            }
        });
        this.viewModel.uiState.setPropertyValue('rows', result);
    }
    /**
     * 选中grid行
     * @param id id
     */
    selectGridRow(id) {
        this.grid.selectRow(id);
        this.grid.scrollToCurrentRow();
    }
    // #endregion
    // #region 事件处理器
    /**
     * 页码切换事件
     * @param event event
     */
    pageChangedHandler(event) {
        let { pageIndex, pageSize } = event;
        if (pageIndex < 1) {
            pageIndex = 1;
        }
        const skip = (pageIndex - 1) * pageSize;
        this.bindingData.setPagingInfo(skip, pageSize, this.bindingData.bindingPath);
    }
    /**
     * 行切换事件
     * @param event event
     */
    selectedRowChanged(event) {
        const { index, data } = event;
        const id = data[this.primaryKey];
        this.setSelectionIdToBindingData(id);
        this.fireSelectedRowChange(event);
    }
    /**
     * 取消行选择事件
     * @param event event
     */
    unSelected(event) {
        if (!event) {
            return;
        }
        const { data = {} } = event;
        const id = data[this.primaryKey];
        const currentId = this.bindingList.currentId;
        if (id === currentId) {
            this.setSelectionIdToBindingData(null);
        }
        // this.fireSelectedRowChange(event);
    }
    /**
     * 勾选行发生变化
     * @param event event
     */
    checkedChanged(event) {
        event = event || [];
        const ids = event.map(item => item.id);
        this.setChecks(ids);
    }
    /**
     * 分页大小变更事件
     * @param event event
     */
    pageSizeChanged(event) {
        const { pageIndex, pageSize } = event;
        const skip = 0; //(pageIndex - 1) * pageSize;
        // this.bindingList.setPaginationInfo(skip, pageSize);
        this.bindingData.setPagingInfo(skip, pageSize, this.bindingData.bindingPath);
    }
    /**
     * grid滚动加载数据
     * @param event event
     */
    scrollY(event) {
        const { pager: pageIndex, pageSize } = event;
        const skip = (pageIndex - 1) * pageSize;
        this.bindingData.setPagingInfo(skip, pageSize, this.bindingData.bindingPath);
    }
    filterChanged(event) {
        this.filters = event;
    }
    // #endregion
    checkIfChangeMatchBindingPath(change) {
        let isMatch = false;
        if (!change || !change.path) {
            return isMatch;
        }
        const changePathArray = change.path;
        if (!changePathArray) {
            return isMatch;
        }
        if (!(this.bindingData) && !(this.bindingData.bindingPath)) {
            return isMatch;
        }
        const bingdingPathArray = this.bindingData.bindingPath.split('/');
        if (bingdingPathArray.length <= 0) {
            return isMatch;
        }
        if (changePathArray.length === 0) { // 主表
            if (this.bindingData.bindingPath === '/') {
                isMatch = true;
            }
        }
        else if (change.path.length === 1) { // 主从表
            if (bingdingPathArray.length === 2 && bingdingPathArray[1] === change.path[0]) {
                isMatch = true;
            }
        }
        else if (change.path.length === 2) { // 主从从表
            if (bingdingPathArray.length === 3 && bingdingPathArray[1] === change.path[0] && bingdingPathArray[2] === change.path[1]) {
                isMatch = true;
            }
        }
        return isMatch;
    }
    debounce(callback, wait) {
        let timeoutId = null;
        return (...args) => {
            window.clearTimeout(timeoutId);
            timeoutId = window.setTimeout(() => {
                callback.apply(null, args);
            }, wait);
        };
    }
}
FarrisDatagridUseBindingDataDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-use-binding-data]'
            },] }
];
/** @nocollapse */
FarrisDatagridUseBindingDataDirective.ctorParameters = () => [
    { type: BindingData },
    { type: ViewModel },
    { type: DatagridComponent }
];
FarrisDatagridUseBindingDataDirective.propDecorators = {
    selectedRowChange: [{ type: Output }],
    pageChangedHandler: [{ type: HostListener, args: ['pageChanged', ['$event'],] }],
    selectedRowChanged: [{ type: HostListener, args: ['selectChanged', ['$event'],] }],
    unSelected: [{ type: HostListener, args: ['unSelect', ['$event'],] }],
    checkedChanged: [{ type: HostListener, args: ['checkedChange', ['$event'],] }],
    pageSizeChanged: [{ type: HostListener, args: ['pageSizeChanged', ['$event'],] }],
    scrollY: [{ type: HostListener, args: ['scrollYLoad', ['$event'],] }],
    filterChanged: [{ type: HostListener, args: ['filterChanged', ['$event'],] }]
};

class MultiSelectDataMappingDirective {
    constructor(vm, multiSelectComponent) {
        this.vm = vm;
        this.multiSelectComponent = multiSelectComponent;
        this.selectedIdChanged = new EventEmitter();
        this.vm.uiState.changes.subscribe(data => {
            this.selectedId = data.value;
        });
    }
    ngOnInit() {
        this.multiSelectComponent.dataSource = [];
        if (Array.isArray(this.dataSource)) {
            this.multiSelectComponent.dataSource = this.dataSource;
            this.originalDataSource = this.dataSource;
        }
        else if (this.dataSource && this.dataSource.changes) {
            this.dataSource.changes.subscribe((data) => {
                if (data.type === 'Load') {
                    this.originalDataSource = data.value;
                    if (this.multiSelectComponent.isTree()) {
                        if (this.fjmField) {
                            // 分级码加载树结构
                            this.multiSelectComponent.dataSource = this.plainToTree(data.value, this.fjmField, 1);
                        }
                        else if (this.fjdField) {
                            // 父节点加载树结构
                            this.multiSelectComponent.dataSource = this.buildTreeNodesByFjd(data.value, this.fjdField);
                        }
                        this.multiSelectComponent.selections = this.getTreeSelectionsById(this.selectedId, this.originalDataSource);
                    }
                    else {
                        this.multiSelectComponent.dataSource = data.value;
                        this.multiSelectComponent.selections = this.getListSelectionsById(this.selectedId, this.multiSelectComponent.dataSource);
                    }
                }
            });
        }
        this.selectIdBindingToUIStateField();
    }
    selectIdBindingToUIStateField() {
        if (this.multiSelectComponent && this.multiSelectComponent.selectedIdChange) {
            this.multiSelectComponent.selectedIdChange.subscribe(data => {
                this.selectedIdChanged.emit(data);
            });
        }
    }
    /**
     *
     * @param data 需要格式化的数据
     */
    formatDataSource(data, field) {
        if (!data || !data.length) {
            return [];
        }
        return data.map(item => {
            const n = item['toJSON'] ? item.toJSON() : item;
            return {
                data: Object.assign(Object.assign({}, n), {
                    [`${this.idField}`]: item[this.idField],
                    [`${this.textField}`]: item[this.textField],
                    [`${this.valueField}`]: item[this.valueField],
                    [`${field}`]: item[field]
                }),
                children: []
            };
        });
    }
    /**
     * 把平行结构的数据转换成树形结构
     * @param plainSource
     * @param field
     * @param layer
     */
    plainToTree(plainSource, field, layer) {
        const treeSource = this.formatDataSource(plainSource, field);
        if (!treeSource.length) {
            return [];
        }
        if (!treeSource[0]['data'][field]) {
            return [];
        }
        const parents = treeSource.filter(item => {
            return item['data'][field]['layer'] === layer;
        });
        this.recursive(parents, treeSource, field, 1);
        return parents;
    }
    /**
     * 递归遍历树形结构
     * @param parents
     * @param treeSource
     * @param field
     * @param layer
     */
    recursive(parents, treeSource, field, layer) {
        parents.forEach(parent => {
            const parentPath = parent['data'][field]['path'];
            const parentLayer = parent['data'][field]['layer'];
            if (parent['data'][field]['isDetail'] === false) {
                treeSource.forEach(item => {
                    if (item && item['data'] && item['data'][field] && item['data'][field]['path']) {
                        const itemPath = item['data'][field]['path'];
                        const itemLayer = item['data'][field]['layer'];
                        let targetPath;
                        if (itemPath && itemPath.length > parentPath.length) {
                            targetPath = itemPath.substr(0, Number(layer) * 4);
                        }
                        if (parentPath === targetPath && parentLayer === itemLayer - 1) {
                            parent['children'].push(item);
                        }
                        if (item['data'][field]['isDetail'] === false && parentPath === targetPath) {
                            this.recursive([item], treeSource, field, Number(layer) + 1);
                        }
                    }
                });
            }
        });
    }
    /**
       *
       * @param ids 选中数据的id
       * @param dataSource 原始数据
       */
    getListSelectionsById(ids, dataSource) {
        let result = [];
        const _this = this;
        if ((typeof ids === 'string' && !!ids) || typeof ids === 'number') {
            const reusltObj = dataSource.find(item => {
                return item && item[_this.idField] === ids;
            });
            if (reusltObj) {
                result.push(reusltObj);
            }
        }
        else if (Array.isArray(ids)) {
            if (dataSource) {
                ids.forEach(id => {
                    const item = dataSource.find(item => item && item[_this.idField] === id);
                    if (item) {
                        result.push(item);
                    }
                });
                // dataSource.forEach(item => {
                //   ids.forEach(id => {
                //     if (item[_this.idField] === id) {
                //       result.push(item);
                //     }
                //   })
                // })
            }
            else {
                result = [];
            }
        }
        else {
            result = [];
        }
        return result;
    }
    /**
     *
     * @param ids 选中数据的id
     * @param dataSource 原始数据
     */
    getTreeSelectionsById(ids, dataSource) {
        let result = [];
        const _this = this;
        if ((typeof ids === 'string' && !!ids) || typeof ids === 'number') {
            const reusltObj = dataSource.find(item => {
                return item && item[_this.idField] === ids;
            });
            if (reusltObj) {
                result.push(reusltObj);
            }
        }
        else if (Array.isArray(ids)) {
            if (dataSource) {
                ids.forEach(id => {
                    const item = dataSource.find(item => item && item[_this.idField] === id);
                    if (item) {
                        result.push(item);
                    }
                });
                // dataSource.forEach(item => {
                //   ids.forEach(id => {
                //     if (item.data[_this.idField] === id) {
                //       result.push(item.data);
                //     }
                //   })
                // })
            }
            else {
                result = [];
            }
        }
        else {
            result = [];
        }
        return result;
    }
    /**
     * 根据父节点初始化树结构
     * @param bindingObjects
     */
    buildTreeNodesByFjd(bindingObjects, field) {
        const treeData = this.formatDataSource(bindingObjects, field);
        treeData.forEach((item) => {
            const parent = treeData.find((ele) => item.data[field].parentElement === ele.data[this.idField]);
            if (parent) {
                parent.children.push(item);
            }
        });
        return treeData.filter((ele) => !ele.data[field].parentElement);
    }
}
MultiSelectDataMappingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[multiSelectDataMapping]'
            },] }
];
/** @nocollapse */
MultiSelectDataMappingDirective.ctorParameters = () => [
    { type: ViewModel, decorators: [{ type: Optional }] },
    { type: MultiSelectComponent, decorators: [{ type: Host }, { type: Self }, { type: Optional }] }
];
MultiSelectDataMappingDirective.propDecorators = {
    dataSource: [{ type: Input }],
    idField: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    fjmField: [{ type: Input }],
    fjdField: [{ type: Input }],
    uiStateField: [{ type: Input }],
    selectedId: [{ type: Input }],
    selectedIdChanged: [{ type: Output }]
};

class FarrisListViewBindingDirective {
    constructor(bindingData, viewModel, listview) {
        this.bindingData = bindingData;
        this.viewModel = viewModel;
        this.listview = listview;
        this.supportPaged = true;
        /**
         * 选中行切换事件
         */
        this.selectedRowChange = new EventEmitter();
    }
    /**
     * 主键
     */
    get primaryKey() {
        return this.bindingList.primaryKey;
    }
    ngOnInit() {
        // 绑定数据
        this.bindData();
        this.registerBindingDataChangeEvent();
    }
    ngOnChanges() {
        this.bindData();
    }
    ngOnDestroy() {
        this.unRegisterBindingDataChangeEvent();
    }
    /**
     * 获取分页信息
     */
    getPagingInfo() {
        const bindingPath = this.viewModel.bindingPath;
        const bindingData = this.viewModel.bindingData;
        let pagingInfo = bindingData.pagingInfo;
        if (bindingPath === '/') {
            return pagingInfo;
        }
        else {
            const bindingPaths = bindingPath.substr(1).split('/').filter(item => !!item && item.length > 0).map(item => {
                return item.substring(0, item.length - 1);
            });
            bindingPaths.forEach(path => {
                pagingInfo = pagingInfo && pagingInfo[path];
            });
            return pagingInfo;
        }
    }
    /**
     * 设置listview属性
     */
    setListViewPageProps() {
        const data = this.bindingList.toJSON();
        const { pageIndex = 1, pageSize = 0 } = this.getPagingInfo() || {};
        let { total = 0 } = this.getPagingInfo() || {};
        if (pageSize === 0 && total === 0) {
            total = data.length;
        }
        this.listview.supportPaging = this.supportPaged;
        this.listview.pageIndex = pageIndex;
        this.listview.pageSize = pageSize;
        this.listview.total = total;
        let currentPage = pageIndex;
        const itemsPerPage = pageSize;
        let totalItems = total;
        if (pageSize === 0) {
            // this.listview.supportPaging = false;
            this.listview.pageIndex = pageIndex;
            this.listview.total = total;
            currentPage = 1;
            totalItems = total;
        }
        if (this.listview.paginationOptions) {
            this.listview.paginationOptions.itemsPerPage = itemsPerPage;
            this.listview.paginationOptions.currentPage = currentPage;
            this.listview.paginationOptions.pageList = this.listview.pageList;
            this.listview.paginationOptions.totalItems = totalItems;
        }
        const listViewChangeDetectRef = this.listview['cdr'];
        if (listViewChangeDetectRef) {
            listViewChangeDetectRef.detectChanges();
        }
        const paginationDirective = this.listview.pager && this.listview.pager['paginationDirective'];
        if (paginationDirective && paginationDirective['service']) {
            try {
                paginationDirective['service'].instances[this.listview.pager.id] = Object.assign({}, this.listview.paginationOptions);
                paginationDirective['service'].setTotalItems(this.listview.pager.id, totalItems);
                paginationDirective.changeDetectorRef.detectChanges();
            }
            catch (_a) { }
        }
    }
    /*
     * 获取绑定数据
     */
    get bindingList() {
        // 根实体
        if (this.viewModel.bindingPath === '/' || !this.viewModel.bindingPath) {
            return this.bindingData.list;
        }
        // 子实体
        let bindingPath = this.viewModel.bindingPath.substr(1);
        bindingPath = bindingPath[0].toLowerCase() + bindingPath.substring(1, bindingPath.length);
        const paths = bindingPath.split('/');
        const filteredPaths = paths.filter((part) => {
            return part !== '';
        });
        return this.bindingData.getValue(filteredPaths);
    }
    /* 绑定数据 */
    bindData() {
        this.setListViewPageProps();
        const data = this.bindingList.toArray();
        this.listview.setData(data);
    }
    /*
         * 发射选中行切换事件
         * @description 统一单选模式和多选模式下的行切换事件
         */
    fireSelectedRowChange(selectedRowContext) {
        this.selectedRowChange.emit(selectedRowContext);
    }
    /**
     * 设置BindingList的当前行
     * @param id 当前行内码
     */
    setSelectionIdToBindingData(id) {
        this.bindingList.setCurrentId(id, true);
    }
    /**
     * 数据源发生变更
     * @param change 变更
     */
    onBindingDataChange(change) {
        this.bindData();
        this.updateSelectedRow(change);
    }
    /**
     * 设置当前行
     * @param change 变更
     */
    updateSelectedRow(change) {
        if (!this.bindingList || !this.bindingList.currentId) {
            return;
        }
        if (this.viewModel && this.viewModel.frameContext.bindingData.rowSelectedEventSuspend === true) {
            return;
        }
        const { id = null } = this.listview.clickItem || {};
        const currentId = this.bindingList.currentId;
        // grid当前行与bingingList当前行一致，无须切换
        if (id === currentId) {
            return;
        }
        this.selectRow(this.bindingList.currentId);
    }
    selectRow(id) {
        if (this.listview && typeof this.listview.selectRow === 'function') {
            this.listview.selectRow(id);
        }
    }
    /**
     * 注册bindingdata变化事件
     */
    registerBindingDataChangeEvent() {
        this.bindingDataChangeEvent = this.bindingData.changes.subscribe((change) => {
            this.onBindingDataChange(change);
        });
    }
    /**
     * 取消bindingdata变化订阅
     */
    unRegisterBindingDataChangeEvent() {
        this.bindingDataChangeEvent.unsubscribe();
    }
    setChecks(ids) {
        this.viewModel.uiState.setPropertyValue('ids', ids);
    }
    /* 切换行事件 */
    changeRow(event) {
        const { index, data, checkChangeEvent } = event;
        if (checkChangeEvent === false || !event.hasOwnProperty('checkChangeEvent')) {
            if (data && Array.isArray(data) && data.length > 0) {
                const id = data[0] && data[0][this.primaryKey] || null;
                if (id) {
                    this.setSelectionIdToBindingData(id);
                }
            }
            this.listview.activeIndex = index;
            this.fireSelectedRowChange(event);
        }
    }
    /**
     * 切换页码触发事件
     * @param event 切换页码参数
     */
    pageChangedHandler(event) {
        let pageIndex = event.pageInfo.pageIndex;
        const pageSize = event.pageInfo.pageSize;
        if (pageIndex < 1) {
            pageIndex = 1;
        }
        const skip = (pageIndex - 1) * pageSize;
        this.bindingData.setPagingInfo(skip, pageSize, this.bindingData.bindingPath);
    }
    /**
     * 设置每页数据条数触发事件
     * @param event 切换页码参数
     */
    pageSizeChangedHandler(event) {
        const { pageIndex, pageSize } = event.pageInfo;
        const skip = (pageIndex - 1) * (+pageSize);
        this.bindingData.setPagingInfo(skip, pageSize, this.bindingData.bindingPath);
    }
    checkValuesChange(event) {
        const ids = event;
        this.setChecks(ids);
    }
}
FarrisListViewBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisListviewBinding]'
            },] }
];
/** @nocollapse */
FarrisListViewBindingDirective.ctorParameters = () => [
    { type: BindingData },
    { type: ViewModel },
    { type: ListViewComponent }
];
FarrisListViewBindingDirective.propDecorators = {
    supportPaged: [{ type: Input }],
    selectedRowChange: [{ type: Output }],
    changeRow: [{ type: HostListener, args: ['listClick', ['$event'],] }],
    pageChangedHandler: [{ type: HostListener, args: ['pageChanged', ['$event'],] }],
    pageSizeChangedHandler: [{ type: HostListener, args: ['pageSizeChanged', ['$event'],] }],
    checkValuesChange: [{ type: HostListener, args: ['checkValuesChange', ['$event'],] }]
};

class EditableDirective {
    constructor(bindingData, viewModel, grid, dateService, injector, rts, dialogSer, ngZone) {
        this.bindingData = bindingData;
        this.viewModel = viewModel;
        this.grid = grid;
        this.dateService = dateService;
        this.injector = injector;
        this.rts = rts;
        this.dialogSer = dialogSer;
        this.ngZone = ngZone;
        /**
         * 编辑时取消分组
         */
        this.disableGroupOnEditing = true;
        /**
         * 多选帮助默认分隔符
         */
        this.defaultSpliter = ',';
        /**
         * 临时记录grid分组字段
         */
        this.groupFields = [];
    }
    get bindingList() {
        // 根实体
        if (this.viewModel.bindingPath === '/' || !this.viewModel.bindingPath) {
            return this.bindingData.list;
        }
        // 子实体
        let bindingPath = this.viewModel.bindingPath.substr(1);
        bindingPath = bindingPath[0].toLowerCase() + bindingPath.substring(1, bindingPath.length);
        const paths = bindingPath.split('/');
        const filteredPaths = paths.filter((part) => {
            return part !== '';
        });
        return this.bindingData.getValue(filteredPaths);
    }
    ngOnInit() {
        this.apply();
    }
    ngOnChanges(changes) {
        this.apply();
    }
    ngOnDestroy() {
        this.detach();
    }
    /**
     * 应用属性
     */
    apply() {
        if (!this.grid) {
            return;
        }
        this.handleGroupStatus();
        // 是否启用了编辑态过滤排序
        if (this.gridEditable) {
            const enableFilterSorting = this.injector && this.injector.get(ENABLE_EDIT_STATE_FILTER_SORTING, false) || false;
            if (!this.grid.remoteFilter && !enableFilterSorting) {
                this.grid.clearCondition();
                // 发送清空过滤条件事件
                this.viewModel.frameContext.appContext.messagePipe.next('CLEAR_GRID_CONDITION');
            }
            this.grid.editable = true;
            if (!this.viewModel.frameContext.appContext.enableGridHeaderWhenEditing && !enableFilterSorting) {
                this.grid.disableHeader(true);
            }
            this.handleBeginEditEvent();
            this.handleAfterEditEvent();
            this.handleEndEditEvent();
        }
        else {
            this.grid.editable = false;
            this.grid.disableHeader(false);
            // TODO:应由表格兼容，但目前补丁不能继续依赖表格组件，临时使用该方案处理
            // 2023-12-25 表格内部已解决列设置后表头无法拖动问题，且兼容代码存在覆盖开发者设置的自定义列名称的问题
            // this.grid.columns = this.grid.columns.map((cols) => {
            //   return cols.map((col) => Object.assign({}, col));
            // });
            // this.grid.columnsChanged(false);
            if (this.grid && typeof this.grid.sort === 'function' && this.grid.sortName) {
                this.grid.sort();
            }
            this.detach();
        }
    }
    /**
     * 编辑时取消分组
     */
    handleGroupStatus() {
        if (this.disableGroupOnEditing === false) {
            return;
        }
        const groupField = this.grid && this.grid.groupField || null;
        if (groupField) {
            if (this.gridEditable) {
                this.groupFields = [groupField];
                this.grid.setGroupFields('');
            }
        }
        else {
            if (this.groupFields && this.groupFields.length > 0) {
                const groupField = this.groupFields.pop();
                if (this.groupFields.length > 0) {
                    this.groupFields = [];
                }
                this.grid.setGroupFields(groupField);
            }
        }
    }
    /**
     * 处理开始编辑事件
     */
    handleBeginEditEvent() {
        this.beginEditSubscription = this.grid.beginEdit.subscribe((e) => {
            if (!e) {
                return;
            }
            const column = e.column;
            if (column && column.editor) {
                const editorInstance = e.editor.componentRef.instance;
                if (!editorInstance || !editorInstance.instance) {
                    return;
                }
                let mapFields = editorInstance.instance.mapFields;
                if (column.editor.type === 'lookup' || column.editor.type === 'PersonnelSelector' || column.editor.type === 'OrganizationSelector' || column.editor.type === 'external-integration' || 'EmployeeSelector' === column.editor.type || 'EmployeeOrgSelector' === column.editor.type) {
                    const lookupGrid = editorInstance.instance;
                    const subject = editorInstance.instance.selectedData;
                    if (subject) {
                        subject.subscribe((data) => {
                            mapFields = editorInstance.instance.mapFields;
                            const spliter = lookupGrid.multipleChoiceSeparator || this.defaultSpliter;
                            this.lookupMapping(data, mapFields, false, spliter);
                        });
                    }
                    const clearMappings = editorInstance.instance.clearMappings;
                    if (clearMappings) {
                        clearMappings.subscribe((result) => {
                            const mapFields = Object.assign({}, editorInstance.instance.mapFields);
                            const value = result && result.value || null;
                            const binding = editorInstance.column && editorInstance.column.field;
                            const lookupTextField = editorInstance.instance.textField;
                            const data = {};
                            if (binding) {
                                const textFieldMapping = mapFields[lookupTextField];
                                if (textFieldMapping) {
                                    const otherField = textFieldMapping.split(',').filter((item) => item !== binding).join(',');
                                    if (otherField) {
                                        mapFields[lookupTextField] = otherField;
                                    }
                                    else {
                                        delete mapFields[lookupTextField];
                                    }
                                }
                                const parentPaths = this.getBindingPathArray();
                                this.bindingData.setValue(parentPaths.concat(binding.split('.')), value, true, true);
                            }
                            // this.setValue(data, lookupTextField.split('.'), value);
                            if (mapFields && Object.keys(mapFields).length > 0) {
                                Object.keys(mapFields).forEach((field) => {
                                    this.setValue(data, field.split('.'), '');
                                });
                                this.lookupMapping(data, mapFields, true);
                            }
                        });
                    }
                }
                if (column.editor.type === 'combo-lookup') {
                    editorInstance.instance.valueChange.subscribe((e) => {
                        const asClear = e && e.selections && e.selections.length === 0;
                        const comboLookup = editorInstance.instance;
                        mapFields = editorInstance.instance.mapFields;
                        const spliter = comboLookup.separator || this.defaultSpliter;
                        this.lookupMapping(e.selections || [], mapFields, asClear, spliter);
                    });
                }
                if (['combo-lookup', 'combolist', 'lookup', 'PersonnelSelector', 'OrganizationSelector', 'external-integration', 'EmployeeSelector', 'EmployeeOrgSelector'].includes(column.editor.type)) {
                    if (editorInstance.instance.clear && editorInstance.instance.clear.subscribe) {
                        editorInstance.instance.clear.subscribe(() => {
                            this.lookupMapping(null, mapFields);
                        });
                    }
                }
                if (column.editor.type === 'combolist') {
                    if (mapFields) {
                        editorInstance.instance.valueChange.subscribe((e) => {
                            const pathArr = this.getBindingPathArray();
                            this.viewModel.bindingData.setValue(pathArr.concat(mapFields.split('.')), editorInstance.instance.selectedValues, true, true);
                        });
                    }
                }
            }
        });
    }
    /**
     * 处理编辑事件
     */
    handleAfterEditEvent() {
        this.grid.afterEdit = (rowIndex, rowData, column, editor) => {
            if (this.dialogSer.hasDialogOpened()) {
                return of(false);
            }
            if (this.rts) {
                // 帮助组件文本变化后去查询
                if (this.rts.getFormState('lookup.pending')) {
                    return of(false);
                }
            }
            // 更新数据源
            if (!editor || !editor.formControl) {
                return of(false);
            }
            return of(true);
        };
    }
    /**
     * 处理结束编辑事件
     */
    handleEndEditEvent() {
        this.endEditSubscription = this.grid && this.grid.endEdit && this.grid.endEdit.subscribe((event) => {
            const { value = undefined, column = undefined, rowData = {} } = event || {};
            const primaryValue = rowData && rowData[this.grid.idField] || null;
            this.updateBindingData(value, column, primaryValue);
        });
    }
    /*
     * 给列表赋值 或给formcontrol赋值
     */
    updateBindingData(value, column, primaryValue) {
        if (!column) {
            return;
        }
        const currentColumnType = column.dataType;
        // 同时判断gridOption的列对象
        const fieldPaths = column.field.split('.');
        // 是否为大数
        const isBigNumber = column && column.editor && column.editor.options && column.editor.options.bigNumber;
        // 存在行编辑器
        if (currentColumnType === 'date') {
            let result;
            if (value) {
                result = this.dateService.formatTo(value, 'yyyy-MM-dd');
            }
            else {
                result = value;
            }
            this.updateBindingList(primaryValue, fieldPaths.join('.'), result);
        }
        else if (currentColumnType === 'datetime') {
            // if (!value) {
            //   value = '0001-01-01T00:00:00';
            // }
            this.updateBindingList(primaryValue, fieldPaths.join('.'), value);
        }
        else if (currentColumnType === 'number' && !isBigNumber) {
            if (value === null || value === undefined) {
                this.updateBindingList(primaryValue, fieldPaths.join('.'), null);
            }
            else {
                this.updateBindingList(primaryValue, fieldPaths.join('.'), Number(value));
            }
        }
        else {
            this.updateBindingList(primaryValue, fieldPaths.join('.'), value);
        }
    }
    updateBindingList(primaryValue, propertyName, value) {
        const viewModel = this.viewModel || null;
        if (!viewModel || !propertyName) {
            return;
        }
        // 更新主表部分行的字段
        const propertyNames = propertyName.split('.').filter((item) => item);
        const bindingPath = this.getBindingPathArray();
        // 取出来的一定是bindingList
        const list = this.bindingData.getValue(bindingPath);
        // 修改的是当前行
        if (list && primaryValue === list.currentItem.primaryKeyValue) {
            const paths = bindingPath.concat(propertyNames);
            this.bindingData.setValue(paths, value, true, true);
            return;
        }
        const bindingObject = this.bindingList.findById(primaryValue);
        if (!bindingObject) {
            return;
        }
        if (propertyNames.length < 2) {
            bindingObject.setValue(propertyName, value, true, true);
        }
        else {
            let targetBindingObject = null;
            const fpaths = propertyNames.slice(0, propertyNames.length - 1);
            const targetPropertyName = propertyNames[propertyNames.length - 1];
            fpaths.forEach((prop) => {
                targetBindingObject = targetBindingObject && targetBindingObject[prop] || bindingObject[prop];
            });
            // todo:需要添加值变化事件
            targetBindingObject.setValue(targetPropertyName, value, true, true);
        }
    }
    detach() {
        if (this.beginEditSubscription && typeof this.beginEditSubscription.unsubscribe === 'function') {
            this.beginEditSubscription.unsubscribe();
        }
        if (this.endEditSubscription && typeof this.endEditSubscription.unsubscribe === 'function') {
            this.endEditSubscription.unsubscribe();
        }
    }
    //#region 帮助字段映射
    lookupMapping(helpData, mapFields, asClear = false, spliter = ',') {
        if (!mapFields) {
            return;
        }
        // 关闭变更检测
        const appContext = this.viewModel.frameContext.appContext;
        appContext.changeDetectionController.detach();
        const pathArr = this.getBindingPathArray();
        let helpFields = Object.keys(mapFields);
        const primaryInfo = this.getMapFieldsPrimaryKey(mapFields, pathArr);
        let primaryKeys = primaryInfo && primaryInfo.map((item) => item.primaryKey) || [];
        const primaryFields = primaryInfo && primaryInfo.map((item) => item.primaryField) || [];
        // 去重
        if (primaryKeys && primaryKeys.length > 0) {
            primaryKeys = [...new Set(primaryKeys)];
            helpFields = this.sortMapFieldKeys(helpFields, primaryKeys);
        }
        if (!helpData || asClear) {
            helpFields.reverse();
        }
        helpFields.forEach((f) => {
            let val = '';
            if (helpData) {
                if (helpData instanceof Array) {
                    val = helpData.map((h) => {
                        return this.getValue(f, h);
                    }).join(spliter);
                }
                else {
                    val = this.getValue(f, helpData);
                }
            }
            let mappings = mapFields[f].split(',');
            const headMappings = mappings.filter((p) => primaryFields.includes(p));
            const leftMappings = mappings.filter((p) => !primaryFields.includes(p));
            if (!helpData) {
                mappings = [].concat(leftMappings).concat(headMappings);
            }
            else {
                mappings = [].concat(headMappings).concat(leftMappings);
            }
            mappings.forEach((ff) => {
                if (!helpData) {
                    this.viewModel.bindingData.clearValue(pathArr.concat(ff.split('.')), true, true);
                }
                else {
                    this.viewModel.bindingData.setValue(pathArr.concat(ff.split('.')), val, true, true);
                }
            });
        });
        // 重新打开变更检测
        appContext.changeDetectionController.reattach();
    }
    getValue(f, data) {
        let val = '';
        if (f.indexOf('.') === -1) {
            val = data[f];
        }
        else {
            val = f.split('.').reduce((a, b) => {
                return a[b];
            }, data);
        }
        return val;
    }
    getBindingPathArray() {
        const path = this.viewModel.bindingPath;
        if (path) {
            return path.split('/').filter((n) => n !== '');
        }
        return [];
    }
    isNumberValue(field, data) {
        const currentVal = this.getValue(field, data);
        return isNumber(currentVal);
    }
    //#endregion
    /**
     *
     * @param mapFields  格式形如：{id: "assoField.assoField", code: "assoField.assoField_Code", name: "assoField.assoField_Name"} 或者 {id:'vid',code:'code',name:'name'}
     */
    getMapFieldsPrimaryKey(mapFields, bindingPaths) {
        if (!mapFields || Object.keys(mapFields).length < 1) {
            return null;
        }
        const results = [];
        // let primaryField = null;
        try {
            const entityTypeInfo = this.viewModel.frameContext.repository.entityTypeInfo;
            Object.keys(mapFields).forEach((key) => {
                const mapField = mapFields[key];
                if (mapField && typeof mapField === 'string') {
                    const mappings = mapField.split(',').filter((p) => p);
                    mappings.forEach((item) => {
                        let paths = item.split('.');
                        if (bindingPaths && bindingPaths.length > 0) {
                            paths = bindingPaths.concat(paths);
                        }
                        const propInfo = entityTypeInfo.getPropInfoByPath(paths);
                        if (propInfo && propInfo.metadataInfo && propInfo.metadataInfo.primary === true) {
                            results.push({
                                primaryKey: key,
                                primaryField: item
                            });
                        }
                    });
                }
            });
        }
        catch (e) {
            console.error(e);
        }
        return results;
    }
    setValue(target, paths, value) {
        if (target) {
            if (paths.length <= 1) {
                target[paths[0]] = value;
            }
            else {
                paths.slice(0, -1).reduce((prev, path) => {
                    if (!(prev.hasOwnProperty(path) || prev['__proto__'].hasOwnProperty(path))) {
                        prev[path] = {};
                    }
                    return prev[path];
                }, target)[paths[paths.length - 1]] = value;
            }
        }
    }
    sortMapFieldKeys(keys, primaryKeys) {
        if (!primaryKeys || primaryKeys.length < 1 || !keys || keys.length < 1) {
            return keys;
        }
        // 过滤出非主键映射字段
        keys = keys.filter((p) => !primaryKeys.includes(p));
        return [].concat(primaryKeys).concat(keys);
    }
}
EditableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-datagrid-editable]'
            },] }
];
/** @nocollapse */
EditableDirective.ctorParameters = () => [
    { type: BindingData },
    { type: ViewModel },
    { type: DatagridComponent },
    { type: DateTimeHelperService },
    { type: Injector },
    { type: RuntimeStateService },
    { type: DialogService },
    { type: NgZone }
];
EditableDirective.propDecorators = {
    gridEditable: [{ type: Input, args: ['farris-datagrid-editable',] }],
    disableGroupOnEditing: [{ type: Input, args: ['disableGroupOnEditing',] }]
};

class AbstractEndEdit {
    constructor(appContext) {
        this.appContext = appContext;
        this.messagePipe = this.appContext && this.appContext.messagePipe;
        if (this.messagePipe) {
            this.messagePipe.subscribe((message) => {
                if (message && message.type === 'endEdit') {
                    this.endEdit(message);
                }
            });
        }
    }
    ngOnDestroy() {
        // if (this.messagePipe) {
        //   this.messagePipe.unsubscribe();
        // }
    }
}

class InputEndEditDirective extends AbstractEndEdit {
    constructor(appContext, elementRef) {
        super(appContext);
        this.appContext = appContext;
        this.elementRef = elementRef;
    }
    ngOnInit() {
        if (this.elementRef) {
            this.nativeElement = this.elementRef.nativeElement;
        }
    }
    /**
     * 结束编辑
     * @param message 消息
     */
    endEdit(message) {
        if (this.nativeElement) {
            const parent = this.nativeElement.parentNode || this.nativeElement.parentElement;
            const inputs = parent && Array.from(parent.getElementsByTagName('input')) || [];
            if (inputs && inputs.length > 0) {
                inputs.forEach(input => {
                    if (input && typeof (input.blur) === 'function') {
                        input.blur();
                    }
                });
            }
        }
    }
}
InputEndEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[input-end-edit]'
            },] }
];
/** @nocollapse */
InputEndEditDirective.ctorParameters = () => [
    { type: AppContext },
    { type: ElementRef }
];

class FarrisDataGridEndEditDirective extends AbstractEndEdit {
    constructor(appContext, datagrid) {
        super(appContext);
        this.appContext = appContext;
        this.datagrid = datagrid;
    }
    /**
     * 结束编辑
     * @param message message
     */
    endEdit(message) {
        if (this.datagrid && typeof this.datagrid.endCellEdit === 'function') {
            this.datagrid.endCellEdit();
        }
    }
}
FarrisDataGridEndEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-grid-end-edit]'
            },] }
];
/** @nocollapse */
FarrisDataGridEndEditDirective.ctorParameters = () => [
    { type: AppContext },
    { type: DatagridComponent }
];

class HtmlEditorEndEditDirective extends AbstractEndEdit {
    constructor(appContext, editor) {
        super(appContext);
        this.appContext = appContext;
        this.editor = editor;
    }
    endEdit(message) {
        if (this.editor && typeof this.editor.endEdit === 'function') {
            this.editor.endEdit();
        }
    }
}
HtmlEditorEndEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[html-editor-end-edit]'
            },] }
];
/** @nocollapse */
HtmlEditorEndEditDirective.ctorParameters = () => [
    { type: AppContext },
    { type: HtmlEditorComponent }
];

class KendoGridEndEditDirective extends AbstractEndEdit {
    constructor(appContext, grid) {
        super(appContext);
        this.appContext = appContext;
        this.grid = grid;
    }
    endEdit(message) {
        if (this.grid && typeof this.grid.closeCell === 'function') {
            this.grid.closeCell();
        }
    }
}
KendoGridEndEditDirective.decorators = [
    { type: Directive, args: [{
                selector: '[kendo-grid-end-edit]'
            },] }
];
/** @nocollapse */
KendoGridEndEditDirective.ctorParameters = () => [
    { type: AppContext },
    { type: GridComponent }
];

class FarrisDataGridRemoteSummaryDirective {
    constructor(viewModel, grid) {
        this.viewModel = viewModel;
        this.grid = grid;
        const appContext = this.viewModel.frameContext.getFormAppContext();
        if (appContext && appContext.hasOwnProperty('messagePipe')) {
            appContext.messagePipe.subscribe((message) => {
                const messageType = message && message.type || null;
                // 查询事件
                if (messageType === 'query') {
                    if (this.remoteSummaryCommand && this.grid.footerDataFrom === 'server') {
                        const paths = this.remoteSummaryCommand.split('.');
                        let func = null;
                        paths.forEach(path => {
                            func = func && func[path] || this[path];
                        });
                        if (typeof func === 'function') {
                            func().subscribe(result => {
                                this.grid.footerData = result;
                            });
                        }
                    }
                }
            });
        }
    }
    /**
     * 执行命令
     * @param commandName 命令名称
     * @param frameId frameId
     */
    execute(commandName, frameId) {
        if (!commandName || commandName === '' || commandName === 'undefined') {
            return;
        }
        let viewModel = this.viewModel;
        if (frameId) {
            const targetContext = viewModel.frameContext.appContext.frameContextManager.getFrameContextById(frameId);
            viewModel = targetContext.viewModel;
        }
        return viewModel[commandName]();
    }
}
FarrisDataGridRemoteSummaryDirective.decorators = [
    { type: Directive, args: [{
                selector: "[farris-remote-summary-command]"
            },] }
];
/** @nocollapse */
FarrisDataGridRemoteSummaryDirective.ctorParameters = () => [
    { type: ViewModel },
    { type: DatagridComponent }
];
FarrisDataGridRemoteSummaryDirective.propDecorators = {
    remoteSummaryCommand: [{ type: Input, args: ['farris-remote-summary-command',] }]
};

class FarrisSetFocusDirective {
    constructor(rd, injector, el) {
        this.rd = rd;
        this.injector = injector;
        this.el = el;
        this._state = new BehaviorSubject({});
    }
    set focusState(value) {
        this._state.next(value);
    }
    ngOnInit() {
        this.selfEl = this.el.nativeElement;
        this._state.subscribe(data => {
            if (data === false && this.selfEl) {
                if (this.selfEl.nodeName.toLowerCase() === 'farris-html-editor') {
                    this.setHtmlEditorFocus();
                }
                else {
                    this.setFocus();
                }
            }
        });
    }
    /**
     * 设置一般输入框的默认焦点
     */
    setFocus() {
        const input = this.selfEl.querySelectorAll('input');
        if (input.length) {
            input[0].focus();
        }
        else {
            this.selfEl.focus();
        }
    }
    /**
     * 设置html编辑器的默认焦点  总是在文本最后
     */
    setHtmlEditorFocus() {
        // 富文本编辑器不是input
        const ediotrArea = this.selfEl.querySelector('div[contenteditable="true"]');
        //创建range  存在浏览器兼容性问题
        const range = window.getSelection();
        //range 选择obj下所有子内容
        range.selectAllChildren(ediotrArea);
        //光标移至最后
        range.collapseToEnd();
    }
}
FarrisSetFocusDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-set-focus]'
            },] }
];
/** @nocollapse */
FarrisSetFocusDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: Injector },
    { type: ElementRef }
];
FarrisSetFocusDirective.propDecorators = {
    focusState: [{ type: Input }]
};

/**
 * 树表格绑定指令
 */
class FarrisFilePreviewBindingDirective {
    /**
     * 构造函数
     * @param previewComponent - 附件组件
     * @param frameContext - 控制器上下文
     * @param uploadAndPreviewComponent - 附件上传预览组件
     * @param injector - injector
     * @TODO: 该指令被用于不同的组件中，因此uploadAndPreviewComponent可能为null
     */
    constructor(previewComponent, frameContext, uploadAndPreviewComponent, injector) {
        this.previewComponent = previewComponent;
        this.frameContext = frameContext;
        this.uploadAndPreviewComponent = uploadAndPreviewComponent;
        this.injector = injector;
        /**
         * 未启用排序时默认按上传时间字段排序
         */
        this.DEFAULT_SORT_FIELD = 'createTime';
        /**
         * 启用排序时使用fileSortOrder做排序字段，与零代码的拖拽排序统一
         */
        this.SORT_FIELD_ON_SORTING = 'fileSortOrder';
    }
    /**
     * 绑定数据
     */
    get bindingData() {
        return this.frameContext.bindingData;
    }
    /**
     * 绑定数据列表
     */
    get bindingList() {
        return this.bindingData.getList();
    }
    /**
     * 排序字段
     * @description
     * 组件排序字段只有一个，不支持多个。
     * 如果启用了拖拽排序，则为fileSortOrder，否则使用默认的createTime
     */
    get orderField() {
        return this.uploadAndPreviewComponent && this.uploadAndPreviewComponent.enableOrder && this.uploadAndPreviewComponent.orderField || this.fileSortOrderKey && this.SORT_FIELD_ON_SORTING || this.DEFAULT_SORT_FIELD;
    }
    /**
     * 默认降序
     */
    get orderType() {
        return this.farrisOrderType ? this.farrisOrderType : this.orderField === this.DEFAULT_SORT_FIELD ? 'desc' : 'asc';
    }
    /**
     * 指令初始化
     */
    ngOnInit() {
        this.bindData();
        if (this.uploadAndPreviewComponent) {
            if (this.uploadAndPreviewComponent.enableOrder) {
                this.uploadAndPreviewComponent.orderField = this.SORT_FIELD_ON_SORTING;
            }
            // 禁用组件内置排序，控制器负责排序并将排序后的数据绑定到附件上传预览组件
            this.uploadAndPreviewComponent.enableSorting = false;
            this.uploadAndPreviewComponent.fSelectedEvent.subscribe((event) => {
                const primaryKey = this.bindingList.primaryKey;
                const id = event && event.originalData && event.originalData[primaryKey];
                if (id && id !== this.bindingList.currentId) {
                    this.bindingList.setCurrentId(id, true);
                }
            });
        }
        this.bindingData.changes.subscribe((change) => {
            // 因排序需要，值变化时也应进行数据绑定
            if (change.type === ChangeType.Load || change.type === ChangeType.Append || change.type === ChangeType.Remove || change.type === ChangeType.ValueChanged || change.type === ChangeType.SelectionChanged) {
                this.bindData(change);
                this.updateCurrentRow(change);
                this.updateChecks(change);
            }
        });
        this.setChecks([]);
    }
    /**
     * 指令输入变更
     * @param changes -变更
     */
    ngOnChanges(changes) {
    }
    shouldComponentUpdate(data) {
        return !(JSON.stringify(this.__DATA__) === JSON.stringify(data));
        // return !(this.__DATA__ && isEqual(this.__DATA__, data));
    }
    /**
     * 绑定数据
     * @param change -变更
     */
    bindData(change) {
        const bindingPath = this.frameContext.viewModel.bindingPath.split('/').filter(p => p).join('/');
        const eventPath = change && change.path && change.path.filter(p => p).join('/');
        // 行切换、删除、加载、新增数据、页码切换 场景
        if (change && [ChangeType.SelectionChanged, ChangeType.Remove, ChangeType.Load, ChangeType.Append].includes(change.type)) {
            // 非上级实体不重新绑定数据
            if (!bindingPath.startsWith(eventPath)) {
                return;
            }
            // 当前附件组件切换当前行不需要重新渲染
            if (change.type === ChangeType.SelectionChanged && bindingPath === eventPath) {
                return;
            }
        }
        // 非当前实体发生了值变化
        if (change && change.type === ChangeType.ValueChanged && !eventPath.startsWith(bindingPath)) {
            return;
        }
        const fileInfos = this.getFileInfos();
        if (!this.shouldComponentUpdate(fileInfos)) {
            return;
        }
        if (this.componentRef) {
            this.__DATA__ = fileInfos;
            this.componentRef.fileInfos = fileInfos;
            if (this.uploadAndPreviewComponent && fileInfos && fileInfos.length > 0) {
                const extendInfos = fileInfos.map((item) => item.originalData);
                this.uploadAndPreviewComponent.extendInfos = extendInfos;
            }
            this.changeCurrentRow(fileInfos, change);
        }
    }
    updateChecks(change) {
        if (!this.uploadAndPreviewComponent) {
            return;
        }
        const bindingPath = this.frameContext.viewModel.bindingPath.split('/').filter(p => p).join('/');
        const eventPath = change && change.path && change.path.filter(p => p).join('/');
        // 删除自身表时更新勾选记录
        if (change && change.type === ChangeType.Remove && eventPath === bindingPath) {
            const values = change.value || [];
            const ids = this.frameContext.uiState['ids'] || [];
            if (values.length > 0 && ids.length > 0) {
                values.forEach((id) => {
                    const index = ids.indexOf(id);
                    if (index !== -1) {
                        ids.splice(index, 1);
                    }
                });
            }
        }
        else if ((change.type === ChangeType.Remove || change.type === ChangeType.SelectionChanged) && bindingPath.startsWith(eventPath) && bindingPath !== eventPath) {
            //上级（上上级）表删除、上级（上上级）表切换当前行时更新勾选记录
            this.setChecks([]);
            // 清空组件勾选
            this.clearComponentChecks();
        }
        else if (change && change.type === ChangeType.Load && (bindingPath === eventPath || bindingPath.startsWith(eventPath) && bindingPath !== eventPath)) {
            // 当前附件组件数据重新加载 or 上级或上上级重新加载
            this.setChecks([]);
            // 清空组件勾选
            this.clearComponentChecks();
        }
    }
    /**
     * 主动更新当前行
     * @param data - 数据
     * @param change - 变更
     */
    changeCurrentRow(data, change) {
        if (!this.uploadAndPreviewComponent) {
            return;
        }
        const changePath = change && change.path.join('/');
        const paths = this.frameContext.viewModel.bindingPath.split('/').filter(p => p);
        const path = paths.join('/');
        const isParentSelectChange = path.startsWith(changePath) && change.type === ChangeType.SelectionChanged && path !== changePath;
        const isSelfRowDelete = change && change.type === ChangeType.Remove && path === changePath;
        if (data && data.length > 0 && change && (change.type === ChangeType.Load || isParentSelectChange || isSelfRowDelete)) {
            const primaryKey = this.bindingList.primaryKey;
            const id = data[0]['originalData'] && data[0]['originalData'][primaryKey];
            if (this.bindingList.currentId !== id) {
                setTimeout(() => {
                    this.bindingList.setCurrentId(id, true, true);
                }, 100);
            }
        }
    }
    /**
     * 为控件设置当前行
     * @param change - 控制器变更
     * @returns
     */
    updateCurrentRow(change) {
        if (!this.bindingList || !this.bindingList.currentId || !this.uploadAndPreviewComponent) {
            return;
        }
        if (change && change.type !== ChangeType.SelectionChanged && change.type !== ChangeType.Load && change.type !== ChangeType.Remove) {
            return;
        }
        const currentId = this.uploadAndPreviewComponent.previewCurrent;
        // 组件id和数据id进行转换
        const id = this.getValueByPath(this.bindingList.currentItem, this.fileIdKey);
        if (id === currentId) {
            return;
        }
        this.selectComponentRow(id);
    }
    /**
     * 获取附件信息列表
     */
    getFileInfos() {
        const listData = this.bindingList.toJSON();
        const fileInfos = [];
        listData.forEach((itemData) => {
            const fileInfo = this.convertToFileInfo(itemData);
            fileInfos.push(fileInfo);
        });
        // 排序
        if (this.orderField) {
            this.sort(fileInfos, this.orderField, this.orderType);
        }
        return fileInfos;
    }
    /**
     * 行数据转换为文件信息
     * @param itemData - 行数据
     * @returns
     */
    convertToFileInfo(itemData) {
        // const idKey = this.bindingList.primaryKey;
        // const id = this.getValueByPath(itemData, idKey);
        const fileId = this.getValueByPath(itemData, this.fileIdKey);
        const fileName = this.getValueByPath(itemData, this.fileNameKey);
        const fileSize = this.getValueByPath(itemData, this.fileSizeKey);
        const fileCreateTime = this.getValueByPath(itemData, this.fileCreateTimeKey);
        const fileInfo = {
            id: fileId,
            name: fileName,
            size: fileSize,
            createTime: fileCreateTime,
            originalData: itemData,
            extend: {
                metadataId: fileId
            }
        };
        if (this.extendFileInfo && Array.isArray(this.extendFileInfo) && this.extendFileInfo.length > 0) {
            this.extendFileInfo.forEach((item) => {
                fileInfo[item.key] = this.getValueByPath(itemData, item.path);
            });
        }
        if (this.fileSortOrderKey) {
            const fileSortOrder = this.getValueByPath(itemData, this.fileSortOrderKey);
            fileInfo[this.SORT_FIELD_ON_SORTING] = fileSortOrder;
        }
        return fileInfo;
    }
    /**
     * 设置控件的当前行
     * @param id 主键
     */
    selectComponentRow(id) {
        if (this.uploadAndPreviewComponent) {
            this.uploadAndPreviewComponent.previewCurrent = id;
        }
    }
    /**
     * 根据字段路径获取值
     * @param data - 数据源
     * @param path - 字段路径
     */
    getValueByPath(data, path) {
        const keys = path.split('.');
        let currentValue = data;
        keys.forEach((key) => {
            currentValue = currentValue && currentValue[key];
        });
        return currentValue;
    }
    getUdtPaths() {
        const paths = this.fileIdKey.split('.');
        paths.pop();
        return paths;
    }
    get fileSizeKey() {
        const basePaths = this.getUdtPaths();
        return basePaths.concat(['fileSize']).join('.');
    }
    get fileCreateTimeKey() {
        const basePaths = this.getUdtPaths();
        return basePaths.concat(['fileCreateTime']).join('.');
    }
    get componentRef() {
        return this.previewComponent || this.uploadAndPreviewComponent || null;
    }
    setChecks(ids) {
        this.frameContext.uiState.setPropertyValue('ids', ids);
    }
    /**
     * 清空组件勾选
     */
    clearComponentChecks() {
        if (this.uploadAndPreviewComponent) {
            this.uploadAndPreviewComponent.previewUpdateRefresh();
        }
    }
    sort(data, fields, directions) {
        if (!fields || fields.length < 1 || !directions || directions.length < 1) {
            throw new Error('sortBy:argument error');
        }
        // 默认升序
        const arrFields = typeof fields === 'string' ? fields.split(',') : fields || [];
        const arrDirections = typeof directions === 'string' ? directions.split(',') : directions || [];
        // 排序字段和排序方式应一致
        if (arrFields.length !== arrDirections.length || arrFields.length < 1) {
            throw new Error('sortBy:fields and directions not match');
        }
        // nage,age,total
        const comparator = (props, orders) => (item1, item2) => {
            return props.reduce((result, prop) => {
                if (result === 0) {
                    const order = ['asc'].includes(orders[props.indexOf(prop)]) ? 1 : -1;
                    const item1Value = this.getValue(item1, prop);
                    const item2Value = this.getValue(item2, prop);
                    if (item1Value === null || item1Value === undefined) {
                        return 1;
                    }
                    if (item2Value === null || item2Value === undefined) {
                        return -1;
                    }
                    if (typeof item1Value !== typeof item2Value) {
                        const localeCompareResult = String(item1Value).localeCompare(String(item2Value));
                        result = localeCompareResult * order;
                    }
                    else if (typeof item1Value === 'string' && typeof item2Value === 'string') {
                        const localeCompareResult = item1Value.localeCompare(item2Value);
                        result = localeCompareResult * order;
                    }
                    else {
                        if (item1Value > item2Value) {
                            result = order * 1;
                        }
                        if (item1Value < item2Value) {
                            result = order * -1;
                        }
                    }
                }
                return result;
            }, 0);
        };
        data.sort(comparator(arrFields, arrDirections));
    }
    getValue(target, propName) {
        if (target instanceof BindingList) {
            target = target.currentItem;
        }
        else if (target instanceof BindingData) {
            target = target.list.currentItem;
        }
        let result = null;
        if (propName.indexOf('.') === -1) {
            result = target[propName];
        }
        else {
            const props = propName.split('.');
            for (const prop of props) {
                target = result = this.getValue(target, prop);
            }
        }
        return result;
    }
    /**
     * 勾选变化事件
     * @param event
     */
    checkedChanged(event) {
        const primaryKey = this.bindingList.primaryKey;
        const ids = event && event.map((item) => item && item.originalData && item.originalData[primaryKey] || '').filter(p => p) || [];
        this.setChecks(ids);
    }
    /**
     * 行切换事件
     * @param event
     */
    selectChanged(event) {
    }
}
FarrisFilePreviewBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisFilePreviewBinding]'
            },] }
];
/** @nocollapse */
FarrisFilePreviewBindingDirective.ctorParameters = () => [
    { type: FFilePreviewComponent, decorators: [{ type: Optional }] },
    { type: FrameContext },
    { type: UploadAndPreviewComponent, decorators: [{ type: Optional }] },
    { type: Injector, decorators: [{ type: Optional }] }
];
FarrisFilePreviewBindingDirective.propDecorators = {
    extendFileInfo: [{ type: Input, args: ['extendFileInfo',] }],
    farrisOrderType: [{ type: Input, args: ['farrisOrderType',] }],
    fileIdKey: [{ type: Input, args: ['farrisFileIdKey',] }],
    fileSortOrderKey: [{ type: Input, args: ['farrisFileSortOrderKey',] }],
    fileNameKey: [{ type: Input, args: ['farrisFileNameKey',] }],
    checkedChanged: [{ type: HostListener, args: ['fPreviewMultiSelectedEvent', ['$event'],] }],
    selectChanged: [{ type: HostListener, args: ['fSelectedEvent', ['$event'],] }]
};

const KEY_UISTATE_REPLY_MESSAGE = 'DISCUSSION_REPLY_MESSAGE_INFO';
const KEY_MESSAGE_ON_COMMENT_ADD = 'onCommentAdd';
class FarrisDiscussionEditorBindingDirective {
    constructor(injector, discussionEditorComponent, viewModel) {
        this.injector = injector;
        this.discussionEditorComponent = discussionEditorComponent;
        this.viewModel = viewModel;
    }
    ngOnInit() {
        this.discussionEditorComponent.replyUser = this.viewModel.frameContext.root.viewModel.uiState[KEY_UISTATE_REPLY_MESSAGE] || {};
        this.viewModel.frameContext.root.viewModel.uiState.changes.subscribe((change) => {
            if (change.field === KEY_UISTATE_REPLY_MESSAGE) {
                this.discussionEditorComponent.replyUser = this.viewModel.frameContext.root.viewModel.uiState[KEY_UISTATE_REPLY_MESSAGE] || {};
            }
        });
        if (this.queryFrequentAtUsersCommand) {
            this.queryFrequentAtUsers();
        }
        else {
            this.queryAtUsers();
        }
        this.queryAllOrgs();
    }
    /**
     * 查询所有部门数据
     */
    queryAllOrgs() {
        this.execute(this.queryAllOrgsCommand).subscribe(result => {
            if (!result) {
                return;
            }
            this.discussionEditorComponent.sectionData = result;
        });
    }
    /**
     * 获取@用户
     */
    queryAtUsers() {
        this.execute(this.userQueryCommand).subscribe(result => {
            if (!result) {
                return;
            }
            const { users = [] } = result;
            this.discussionEditorComponent.personnels = users;
        });
    }
    /**
     * 获取常用@用户
     */
    queryFrequentAtUsers() {
        this.execute(this.queryFrequentAtUsersCommand).subscribe(result => {
            if (!result) {
                return;
            }
            this.discussionEditorComponent.personnels = result && result.users || [];
        });
    }
    /**
     * 提交或取消评论
     * @param event event
     */
    pageChangedHandler(event) {
        const { msgInfo = 0, text = '', visibility = 'ALL', parentId = null } = event || {};
        if (msgInfo === 1) {
            this.execute(this.addCommentCommand, { text, parentId, visibility }).pipe(tap(() => {
                this.viewModel.frameContext.appContext.messagePipe.next(KEY_MESSAGE_ON_COMMENT_ADD);
            }), catchError(e => EMPTY)).subscribe();
        }
        else {
            // 取消的时候同时会将回复用户清空
            this.viewModel.frameContext.root.viewModel.uiState[KEY_UISTATE_REPLY_MESSAGE] = {};
            this.discussionEditorComponent.replyUser = {};
        }
    }
    /**
     * 执行命令
     * @param commandName 命令名称
     */
    execute(commandName, params) {
        if (!commandName || commandName === '' || commandName === 'undefined') {
            return of(null);
        }
        if (typeof params === 'undefined') {
            params = {};
        }
        const paths = commandName.split('.');
        let func = null;
        paths.forEach(path => {
            func = func && func[path] || this[path];
        });
        if (typeof func === 'function') {
            return func(params);
        }
        return of(null);
    }
}
FarrisDiscussionEditorBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-discussion-editor-binding]'
            },] }
];
/** @nocollapse */
FarrisDiscussionEditorBindingDirective.ctorParameters = () => [
    { type: Injector },
    { type: DiscussionEditorComponent },
    { type: ViewModel }
];
FarrisDiscussionEditorBindingDirective.propDecorators = {
    userQueryCommand: [{ type: Input, args: ["userQueryCommand",] }],
    addCommentCommand: [{ type: Input, args: ["addCommentCommand",] }],
    queryAllOrgsCommand: [{ type: Input, args: ["queryAllOrgsCommand",] }],
    queryFrequentAtUsersCommand: [{ type: Input, args: ["queryFrequentAtUsersCommand",] }],
    pageChangedHandler: [{ type: HostListener, args: ['valueChange', ['$event'],] }]
};

const KEY_UISTATE_REPLY_MESSAGE$1 = 'DISCUSSION_REPLY_MESSAGE_INFO';
const KEY_MESSAGE_ON_COMMENT_ADD$1 = 'onCommentAdd';
class FarrisDiscussionListBindingDirective {
    constructor(injector, discussionListComponent, viewModel, discussionListDirective) {
        this.injector = injector;
        this.discussionListComponent = discussionListComponent;
        this.viewModel = viewModel;
        this.discussionListDirective = discussionListDirective;
    }
    ngOnInit() {
        this.viewModel.frameContext.appContext.messagePipe.subscribe((message) => {
            if (message === KEY_MESSAGE_ON_COMMENT_ADD$1) {
                this.queryComments();
            }
        });
        this.viewModel.bindingData.changes.subscribe((change) => {
            if (change.type === ChangeType.Load || change.type === ChangeType.SelectionChanged) {
                this.queryComments();
            }
        });
    }
    /**
     * 查询评论
     */
    queryComments(pageIndex, pageSize) {
        if (typeof pageIndex === 'undefined') {
            pageIndex = (this.discussionListComponent.pageIndex - 1) || 0;
        }
        if (typeof pageSize === 'undefined') {
            if (this.discussionListComponent.supportPaging) {
                pageSize = this.discussionListComponent.pageSize;
            }
            else {
                // 不分页，pageSize和后端约定传最大数
                pageSize = 10000;
            }
        }
        this.execute(this.commentsQueryCommand, { pageIndex, pageSize }).pipe(catchError(e => EMPTY)).subscribe(result => {
            if (!result) {
                return;
            }
            const { comments = [], pageIndex = 0, pageSize = 10, totalCount = 0 } = result;
            this.discussionListComponent.pageIndex = parseInt(pageIndex) + 1;
            if (this.discussionListComponent.supportPaging) {
                this.discussionListComponent.pageSize = pageSize;
            }
            this.discussionListComponent.total = totalCount;
            this.discussionListDirective.discussionListData = result;
        });
    }
    /**
     * 回复消息
     * @param event event
     */
    replyMessagedHandler(event) {
        this.viewModel.frameContext.root.viewModel.uiState.setPropertyValue(KEY_UISTATE_REPLY_MESSAGE$1, event);
    }
    /**
     * 切换页码
     * @param event event
     */
    pageChangedHandler(event) {
        const { pageIndex = 1, pageSize = 10 } = event.pageInfo || {};
        this.queryComments(pageIndex - 1, pageSize);
    }
    /**
     * 执行命令
     * @param commandName 命令名称
     */
    execute(commandName, params) {
        if (!commandName || commandName === '' || commandName === 'undefined') {
            return of(null);
        }
        const paths = commandName.split('.');
        let func = null;
        paths.forEach(path => {
            func = func && func[path] || this[path];
        });
        if (typeof func === 'function') {
            return func(params);
        }
        return of(null);
    }
}
FarrisDiscussionListBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-discussion-list-binding]'
            },] }
];
/** @nocollapse */
FarrisDiscussionListBindingDirective.ctorParameters = () => [
    { type: Injector },
    { type: DiscussionListComponent },
    { type: ViewModel },
    { type: DiscussionListDirective }
];
FarrisDiscussionListBindingDirective.propDecorators = {
    commentsQueryCommand: [{ type: Input, args: ["commentsQueryCommand",] }],
    replyMessagedHandler: [{ type: HostListener, args: ['replyMessage', ['$event'],] }],
    pageChangedHandler: [{ type: HostListener, args: ['pageChanged', ['$event'],] }]
};

/*******************************************************************************************************************
 *                                     FarrisPrimengTreeTableBindingDirective指令说明                               *
 * *****************************************************************************************************************
 *
 * 1. 依赖primeng版本: primeng:^9.0.0,primeicons:^4.0.0
 *
 * 2. 由于可编辑树表无法触发编辑单元格的关闭事件onEditComplete，因此对priemeng的node_modules\primeng\fesm5\primeng-treetable.js脚本作出修改：
 *    源码修改如下，+表示新增加的脚本语句:
 *
 *  TreeTable.prototype.updateEditingCell = function (cell, data, field) { //+ 参数增加data和field
 *      this.editingCell = cell;
 *      this.editingCellData = data; //+
 *      this.editingCellField = field; //+
 *      this.bindDocumentEditListener();
 *  };
 *
 *  TreeTable.prototype.bindDocumentEditListener = function () {
 *       var _this = this;
 *       if (!this.documentEditListener) {
 *           this.documentEditListener = function (event) {
 *               if (_this.editingCell && !_this.editingCellClick && _this.isEditingCellValid()) {
 *                   domhandler_1.DomHandler.removeClass(_this.editingCell, 'ui-editing-cell');
 *                   _this.editingCell = null;
 *                   _this.onEditComplete.emit({ field: _this.editingCellField, data: _this.editingCellData });//+
 *                   _this.unbindDocumentEditListener();
 *               }
 *               _this.editingCellClick = false;
 *           };
 *           document.addEventListener('click', this.documentEditListener);
 *       }
 *   };
 *
 *  TreeTable.prototype.bindDocumentEditListener = function () {
 *       var _this = this;
 *       if (!this.documentEditListener) {
 *           this.documentEditListener = function (event) {
 *               if (_this.editingCell && !_this.editingCellClick && _this.isEditingCellValid()) {
 *                   domhandler_1.DomHandler.removeClass(_this.editingCell, 'ui-editing-cell');
 *                   _this.editingCell = null;
 *                   _this.onEditComplete.emit({ field: _this.editingCellField, data: _this.editingCellData });//+
 *                   _this.unbindDocumentEditListener();
 *               }
 *               _this.editingCellClick = false;
 *           };
 *           document.addEventListener('click', this.documentEditListener);
 *       }
 *   };
 *
 *  TTEditableColumn.prototype.openCell = function () {
 *       var _this = this;
 *        this.tt.updateEditingCell(this.el.nativeElement,this.data, this.field);//+
 *        domhandler_1.DomHandler.addClass(this.el.nativeElement, 'ui-editing-cell');
 *        this.tt.onEditInit.emit({ field: this.field, data: this.data });
 *        this.zone.runOutsideAngular(function () {
 *            setTimeout(function () {
 *                var focusable = domhandler_1.DomHandler.findSingle(_this.el.nativeElement, 'input, textarea');
 *                if (focusable) {
 *                     focusable.focus();
 *                 }
 *             }, 50);
 *        });
 *   };
 *
 *  TTEditableColumn.prototype.onClick = function (event) {
 *        if (this.isEnabled()) {
 *            this.tt.editingCellClick = true;
 *            if (this.tt.editingCell) {
 *                if (this.tt.editingCell !== this.el.nativeElement) {
 *                    if (!this.tt.isEditingCellValid()) {
 *                        return;
 *                    }
 *                    this.tt.onEditComplete.emit({ field: this.tt.oldField, data: this.tt.oldDdata });//+
 *                    DomHandler.removeClass(this.tt.editingCell, 'ui-editing-cell');
 *                    this.openCell();
 *                }
 *            }
 *            else {
 *                this.openCell();
 *            }
 *        }
 *  };
 *
 *  TTEditableColumn.prototype.openCell = function () {
 *         var _this = this;
 *         this.tt.updateEditingCell(this.el.nativeElement,this.data, this.field);
 *         DomHandler.addClass(this.el.nativeElement, 'ui-editing-cell');
 *         this.tt.onEditInit.emit({ field: this.field, data: this.data });
 *         this.tt.oldField= this.field; //+
 *         this.tt.oldDdata=this.data;  //+
 *         this.zone.runOutsideAngular(function () {
 *             setTimeout(function () {
 *                 var focusable = DomHandler.findSingle(_this.el.nativeElement, 'input, textarea');
 *                if (focusable) {
 *                     focusable.focus();
 *                 }
 *           }, 50);
 *       });
 *   };
 *
 * 3. HTML模板
 * (1) 不启用多表头
 *      <p-treeTable [columns]="treeGridColumns" farrisPrimengTreeTableBinding farrisHierarchyInfoKey="layerField" [resizableColumns]="true" farrisPrimengTreeTableIdField="id">
 *             <ng-template pTemplate="header" let-columns>
 *                 <tr>
 *                     <th *ngFor="let col of columns" ttResizableColumn>
 *                         {{col.header}}
 *                     </th>
 *                 </tr>
 *             </ng-template>
 *             <ng-template pTemplate="body" let-rowNode let-rowData="rowData" let-columns="columns">
 *                 <tr>
 *                     <td *ngFor="let col of columns; let i = index" ttEditableColumn [ttEditableColumn]="rowData"
 *                         [ttEditableColumnField]="col.field">
 *                         <p-treeTableToggler [rowNode]="rowNode" *ngIf="i === 0"></p-treeTableToggler>
 *                         <p-treeTableCellEditor>
 *                             <ng-template pTemplate="input">
 *                                  <!-- 控件动态生成区域，此处可放置控件动态生成组件，生成规则如下：
 *                                            1. 字符串类型：文本控件
 *                                            2. 数字类型：数字控件
 *                                            3. 布尔类型：复选框控件
 *                                            4. 日期时间类型：日期时间控件
 *                                            5. 枚举类型：下拉框控件
 *                                            6. 帮助类型：帮助控件-->
 *                             </ng-template>
 *                             <ng-template pTemplate="output">{{ col | formatCellData : rowData }}</ng-template>
 *                         </p-treeTableCellEditor>
 *                     </td>
 *                 </tr>
 *             </ng-template>
 *     </p-treeTable>
 *
 * (2) 启用多表头
 *
 *  <p-treeTable [columns]="treeGridColumns" farrisPrimengTreeTableBinding farrisHierarchyInfoKey="layerField" [resizableColumns]="true" farrisPrimengTreeTableIdField="id">
 *             <ng-template pTemplate="header" let-columns>
 *                  <tr *ngFor="let columnHeader of treeGridColumnHeaders">
 *                      <th *ngFor="let col of columnHeader" ttResizableColumn [attr.rowspan]="col.rowspan" [attr.colspan]="col.colspan">
 *                          {{col.header}}
 *                      </th>
 *                  </tr>
 *             </ng-template>
 *             <ng-template pTemplate="body" let-rowNode let-rowData="rowData" let-columns="columns">
 *                 <tr>
 *                     <td *ngFor="let col of columns; let i = index" ttEditableColumn [ttEditableColumn]="rowData"
 *                         [ttEditableColumnField]="col.field">
 *                         <p-treeTableToggler [rowNode]="rowNode" *ngIf="i === 0"></p-treeTableToggler>
 *                         <p-treeTableCellEditor>
 *                             <ng-template pTemplate="input">
 *                                  <!-- 控件动态生成区域，此处可放置控件动态生成组件，生成规则如下：
 *                                            1. 字符串类型：文本控件
 *                                            2. 数字类型：数字控件
 *                                            3. 布尔类型：复选框控件
 *                                            4. 日期时间类型：日期时间控件
 *                                            5. 枚举类型：下拉框控件
 *                                            6. 帮助类型：帮助控件-->
 *                             </ng-template>
 *                             <ng-template pTemplate="output">{{ col | formatCellData : rowData }}</ng-template>
 *                         </p-treeTableCellEditor>
 *                     </td>
 *                 </tr>
 *             </ng-template>
 *  </p-treeTable>
 *
 * 多表头数据格式：
 *  this.treeGridColumnHeaders=[
 *     [{ header: 'Brand',rowspan:3, colspan:1},{ header: 'Sale Rate',rowspan:1, colspan:4}],
 *     [{ header: 'Sales',rowspan:1, colspan:2},{ header: 'Profits',rowspan:1, colspan:2}],
 *     [{ header: 'Last Year',rowspan:1, colspan:1},{ header: 'This Year',rowspan:1, colspan:1},{ header: 'Last Year',rowspan:1, colspan:1},{ header: 'This Year',rowspan:1, colspan:1}],
 *  ]

 **********************************************************************************************************************/
class FarrisPrimengTreeTableBindingDirective {
    constructor(treeTable, frameContext, dateService) {
        this.treeTable = treeTable;
        this.frameContext = frameContext;
        this.dateService = dateService;
        this.selectedRowId = null;
        this.treeTableSelectedEvent = null;
        /**
         * 节点选择变更事件
         */
        this.nodeSelectChange = new EventEmitter();
        this.oldTreeNodeMap = {};
    }
    /**
     * 绑定数据
     */
    get bindingData() {
        return this.frameContext.bindingData;
    }
    /**
     * 绑定数据列表
     */
    get bindingList() {
        return this.bindingData.getList();
    }
    getHierarchyInfoField() {
        let infos = this.hierarchyInfoKey.split('/');
        return infos[infos.length - 1];
    }
    ngOnChanges(changes) {
    }
    ngOnInit() {
        //解析获取分级码字段编号
        this.hierarchyInfoField = this.getHierarchyInfoField();
        // 将分级码信息保存到root-component
        const virtualRootFrameContext = this.frameContext.getVirtualRootFrameContext();
        virtualRootFrameContext.setParam('hierarchyInfoKey', this.hierarchyInfoKey);
        this.bindingData.changes.subscribe((change) => {
            this.bindData(change);
            this.updateSelectedRow(change);
        });
        this.frameContext.viewModel.uiState.setPropertyValue('ids', []);
        if (this.frameContext && this.frameContext.frameComponent) {
            this.frameContext.frameComponent.componentType = ComponentType.primengTreeComponent;
        }
    }
    /**
     * 获取树列表绑定数据对应的实体数组
     * @returns 实体数组
     */
    getEntityArr() {
        const entityCollection = this.frameContext.repository.entityCollection;
        const bindingPath = this.frameContext.bindingData.bindingPath;
        if (!bindingPath || bindingPath === '/') {
            return entityCollection.toArray();
        }
        let bindingList = this.frameContext.bindingData.list;
        let bindingPathArr = bindingPath.split('/').filter(str => str);
        let pathArray = [];
        bindingPathArr.forEach((path) => {
            pathArray.push(`${bindingList.primaryKey}:${bindingList.currentId}`);
            pathArray.push(path);
            bindingList = bindingList.currentItem[path];
        });
        return entityCollection.getEntitiesByPath(pathArray).toArray();
    }
    /**
     * 将真实顺序标记到对应的实体上
     * @param entityArr 实体数组
     * @param treeNodes 树节点
     */
    setActualIndex(entityArr, treeNodes) {
        if (entityArr.length < 1)
            return;
        // 初始化序号器并依次遍历每一棵树
        let counter = { index: 0 };
        const primaryKey = entityArr[0].primaryKey;
        treeNodes.forEach((rootNode) => {
            this.traverseTree(rootNode, counter, entityArr, primaryKey);
        });
    }
    /**
     * 前序递归遍历树节点并在对应实体上标记序号
     * @param treeNode 树节点
     * @param counter 序号器
     * @param entityArr 实体数组
     * @description
     * 在进行前端校验时，按照Entity在数组中的下标生成（错误提示的）行号的方式不适用于树列表，
     * 因为树列表可以在已经添加的节点上加入子节点，而Entity总是在最后追加新对象，导致二者的顺序不一定相同，
     * 所以在绑定数据的时候将树节点在列表中的真实顺序通过一个附加的属性（__ACTUAL_INDEX__）赋给Entity示例，
     * 当Entity调用validate方法时，检查是否存在该属性，如果存在则应用该属性的值作为行号。
     */
    traverseTree(treeNode, counter, entityArr, primaryKey) {
        const INDEX_LABEL = "__ACTUAL_INDEX__";
        // 处理当前节点
        const entity = entityArr.find(e => e[primaryKey] === treeNode.data[primaryKey]);
        if (entity) {
            Object.defineProperty(entity, INDEX_LABEL, {
                value: counter.index
            });
            counter.index++;
        }
        // 递归遍历分支
        treeNode.children.forEach((rootNode) => {
            this.traverseTree(rootNode, counter, entityArr, primaryKey);
        });
    }
    /**
     * 处理数据变更
     * @param change 变更
     * @returns 是否跳过绑定数据的整体刷新
     * @description
     * 目的是尽量少的重新构造整个树列表，比如在发生值变化事件时尽量只更改变化的值就结束，
     * 如果任何变化都重新构造树，会导致Tab键切换功能难以实现等问题。
     */
    handleChange(change) {
        // 没有变更时，继续绑定数据刷新
        if (!change)
            return false;
        // 分类处理具体的变更
        switch (change.type) {
            case ChangeType.SelectionChanged:
                return this.handleSelectionChanged(change);
            case ChangeType.GlobalSelectionChanged:
                return this.handleSelectionChanged(change);
            case ChangeType.ValueChanged:
                return this.handleValueChanged(change);
            default:
                return false;
        }
    }
    /**
     * 处理行切换变更
     * @param change 变更
     * @returns 是否跳过绑定数据的整体刷新
     */
    handleSelectionChanged(change) {
        // 当前绑定路径下发生行切换事件，不进行数据刷新（为了支持Tab键切换单元格）
        if (change.type === ChangeType.SelectionChanged || change.type === ChangeType.GlobalSelectionChanged) {
            let path = change.path;
            let frmPath = this.bindingData.bindingPath.split("/").filter(str => str);
            if (path.length === frmPath.length) {
                let same = true;
                for (let i = 0; i < path.length; i++) {
                    if (path[i] !== frmPath[i])
                        same = false;
                }
                if (same)
                    return true;
            }
        }
        return false;
    }
    /**
     * 处理行切换变更
     * @param change 变更
     * @returns 是否跳过绑定数据的整体刷新
     */
    handleValueChanged(change) {
        if (change.type !== ChangeType.ValueChanged) {
            return false;
        }
        // 接收到值变化事件，尝试仅进行局部数据的更新（为了支持Tab键切换单元格）
        let path = change.path;
        let bindingPathArr = this.bindingData.bindingPath.split("/").filter(str => str);
        // 判断绑定路径是否相同，如果不相同则整体刷新
        for (let item of bindingPathArr) {
            if (path.length > 0) {
                if (item === path[0]) {
                    path.shift();
                }
                else {
                    return false;
                }
            }
        }
        // 通过id找到待更新的树节点
        let id = change.id;
        if (id) {
            const primaryKey = this.bindingList.primaryKey;
            let nodes = this.treeTable.value;
            let targetNode = null;
            for (let node of nodes) {
                let result = this.findTreeNodeById(node, primaryKey, id);
                if (result) {
                    targetNode = result;
                    break;
                }
            }
            if (targetNode && path.length === 1) {
                const propertyName = path.shift();
                if (targetNode.data.hasOwnProperty(propertyName) && change.hasOwnProperty("value")) {
                    targetNode.data[propertyName] = change.value;
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * 通过主键值查找树节点
     * @param treeNode 树根节点
     * @param primaryKey 主键名
     * @param keyValue 主键值
     * @returns 树节点
     * @todo 递归遍历实现比较低效，考虑通过oldTreeNodeMap查找树节点
     */
    findTreeNodeById(treeNode, primaryKey, keyValue) {
        if (!treeNode)
            return null;
        if (treeNode.data.hasOwnProperty(primaryKey) && treeNode.data[primaryKey] === keyValue)
            return treeNode;
        if (treeNode.children) {
            for (let node of treeNode.children) {
                let result = this.findTreeNodeById(node, primaryKey, keyValue);
                if (result)
                    return result;
            }
        }
        return null;
    }
    /**
    * 绑定数据
    */
    bindData(change) {
        let skipRefresh = this.handleChange(change);
        if (skipRefresh) {
            return;
        }
        // this.sourceData = this.bindingList.toJSON({ ignoreMultiLangInput: true });
        const oldTreeNodes = this.treeTable.value;
        const treeNodesData = this.bindingList.toJSON({ ignoreMultiLangInput: true });
        let treeNodes = [];
        if (treeNodesData && treeNodesData.length > 0) {
            let hierarchyInfo = treeNodesData[0][this.hierarchyInfoField];
            const builder = TreeNodeBuilderFactory.getBuilder(hierarchyInfo);
            // 服务器返回的分级节点信息匹配不到现有工厂里面的任何一种情况。确认新加的builder已经在工厂中注册
            if (builder == null) {
                throw new Error('TreeTable builder is null!');
            }
            let expandLevel = -1;
            const treeExpandLevel = this.treeTable['expandLevel'];
            if (typeof treeExpandLevel !== 'undefined') {
                expandLevel = treeExpandLevel;
            }
            const context = {
                expandLevel,
                component: this.treeTable,
            };
            const treeNodesBuilder = new builder(treeNodesData, oldTreeNodes, this.bindingList.primaryKey, this.hierarchyInfoField, context);
            treeNodes = treeNodesBuilder.build();
            // 获取绑定数据对应的实体列表
            let entityArr = this.getEntityArr();
            // 根据treeNodes的顺序在对应的实体上添加序号字段__ACTUAL_INDEX__
            this.setActualIndex(entityArr, treeNodes);
        }
        if (!this.treeTable.lazy) {
            this.treeTable.totalRecords = (this.treeTable._value ? this.treeTable._value.length : 0);
            if (this.treeTable.sortMode == 'single' && this.treeTable.sortField)
                this.treeTable.sortSingle();
            else if (this.treeTable.sortMode == 'multiple' && this.treeTable.multiSortMeta)
                this.treeTable.sortMultiple();
            else if (this.treeTable.hasFilter()) //sort already filters
                this.treeTable._filter();
        }
        this.treeTable.tableService.onUIUpdate(treeNodes);
        this.treeTable.value = treeNodes;
        this.treeTable.updateSerializedValue();
        // this.treeNodeMap = {};
        // this.sourceDataClone = this.sourceData;
        // this.treeTable.value = [...this.treeNodesBuilder()];
        // this.treeTableValueHandler();
    }
    updateSelectedRow(change) {
        const currentId = this.bindingList.currentId;
        if (this.treeTableSelectedEvent) {
            this.treeTableSelectedEvent = false;
            this.selectedRowId = currentId;
            return;
        }
        const serializedValue = this.treeTable.serializedValue;
        const treeNode = serializedValue && serializedValue.find(item => item && item.node && item.node.data && item.node.data.id === currentId) || null;
        if (treeNode) {
            if (this.treeTable.isSelected(treeNode.node) || currentId === this.selectedRowId) {
                return;
            }
            this.selectedRowId = currentId;
            this.treeTable.handleRowClick({ rowNode: treeNode, originalEvent: { target: { nodeName: '' } } });
        }
    }
    onEditInitHandler(event) {
        this.nodeSelectChange.emit(event['data']);
        const id = event.data[this.idField];
        this.setCurrentIdToBindingList(id);
    }
    onEditCompleteHandler(event) {
        let fieldName = event.field;
        const column = this.columns.find(item => item.field === fieldName);
        if (fieldName && column && column.editor && column.editor.options && column.editor.options.type === 'EditorTypes.LOOKUP') {
            return;
        }
        if (event && event.hasOwnProperty('data')) {
            const primaryKeyValue = event.data[this.frameContext.repository.primaryKey];
            let value = this.getValue(fieldName, event.data);
            const bindingPath = this.frameContext.viewModel.bindingPath || '/';
            const bindingPaths = bindingPath.split('/').filter(p => p);
            const bindingList = this.bindingData.getValue(bindingPaths);
            const bindingObject = bindingList.findById(primaryKeyValue);
            const oldValue = this.getValue(fieldName, bindingObject);
            const column = this.treeTable.columns.find(item => item.field === fieldName);
            const dataType = column && column.dataType || null;
            if (dataType === 'date' || dataType === 'datetime') {
                if (this.dateService) {
                    const format = column && column.formatter && column.formatter.options && column.formatter.options.format || 'yyyy-MM-dd';
                    value = this.dateService.formatTo(value, format);
                    if (!value) {
                        value = null;
                    }
                }
            }
            else if (dataType === 'number') {
                value = Number(value);
            }
            if (value !== oldValue) {
                this.updateBindingList(primaryKeyValue, fieldName, value);
            }
        }
    }
    onNodeExpandHandler(event) {
        // this.setNodeExpandedValue(event);
        const selectedId = event && event.node && event.node.id || null;
        if (!selectedId) {
            return;
        }
        const virtualRootFrameContext = this.frameContext.getVirtualRootFrameContext();
        const expandNodes = virtualRootFrameContext.getParam('TREE_LATEST_EXPANDED_ID') || [];
        expandNodes.push(selectedId);
        virtualRootFrameContext.setParam('TREE_LATEST_EXPANDED_ID', expandNodes);
    }
    onNodeCollapseHandler(event) {
        // this.setNodeExpandedValue(event);
    }
    onNodeSelectHandler(event) {
        const id = event && event.node && event.node.data && event.node.data[this.frameContext.repository.primaryKey] || null;
        if (id === this.bindingList.currentId) {
            return;
        }
        this.treeTableSelectedEvent = true;
        this.setCurrentIdToBindingList(id);
    }
    onNodeUnselectHandler(event) {
        this.setCurrentIdToBindingList(null);
    }
    setNodeExpandedValue(event) {
        if (!event || !this.oldTreeNodeMap || Object.keys(this.oldTreeNodeMap).length <= 0) {
            return;
        }
        try {
            let currentId = event.node.data.id;
            this.oldTreeNodeMap[currentId].expanded = event.expanded;
        }
        catch (e) {
            console.warn(`setNodeExpandedValue error:${e.message}`);
        }
    }
    setCurrentIdToBindingList(selectedId) {
        const oldCurrentId = this.bindingList.currentId;
        if (oldCurrentId === selectedId) {
            return;
        }
        this.bindingList.setCurrentId(selectedId, true);
    }
    getPaths() {
        let paths = [];
        if (!this.frameContext.viewModel || !this.frameContext.viewModel.bindingPath || this.frameContext.viewModel.bindingPath === '/') {
            return paths;
        }
        else {
            let bindingPath = this.frameContext.viewModel.bindingPath;
            paths = bindingPath.substring(1, bindingPath.length).split('/');
            return paths;
        }
    }
    updateBindingList(primaryValue, propertyName, value) {
        if (!propertyName) {
            return;
        }
        // 更新主表部分行的字段
        const propertyNames = propertyName.split('.').filter(item => item);
        const bindingPath = this.getBindingPathArray();
        // 取出来的一定是bindingList
        const list = this.bindingData.getValue(bindingPath);
        // 修改的是当前行
        const paths = bindingPath.concat(propertyNames);
        if (list && primaryValue === list.currentItem.primaryKeyValue) {
            this.bindingData.setValue(paths, value, true, true);
            return;
        }
        const bindingObject = this.bindingList.findById(primaryValue);
        if (!bindingObject) {
            return;
        }
        if (propertyNames.length < 2) {
            bindingObject.setValue(propertyName, value, true, true, undefined, this.bindingData.getValudChangeInvokerFactory()(paths));
        }
        else {
            let targetBindingObject = null;
            const fpaths = propertyNames.slice(0, propertyNames.length - 1);
            const targetPropertyName = propertyNames[propertyNames.length - 1];
            fpaths.forEach(prop => {
                targetBindingObject = targetBindingObject && targetBindingObject[prop] || bindingObject[prop];
            });
            // todo:需要添加值变化事件
            targetBindingObject.setValue(targetPropertyName, value, true, true, undefined, this.bindingData.getValudChangeInvokerFactory()(paths));
        }
    }
    getBindingPathArray() {
        const path = this.frameContext.viewModel.bindingPath;
        if (path) {
            return path.split('/').filter(n => n !== '');
        }
        return [];
    }
    getValue(path, data) {
        let value = '';
        if (path.indexOf('.') === -1) {
            value = data[path];
        }
        else {
            value = path.split('.').reduce((result, prop) => {
                return result[prop];
            }, data);
        }
        return value;
    }
    setChecks(ids) {
        this.frameContext.viewModel.uiState.setPropertyValue('ids', ids);
    }
}
FarrisPrimengTreeTableBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisPrimengTreeTableBinding]'
            },] }
];
/** @nocollapse */
FarrisPrimengTreeTableBindingDirective.ctorParameters = () => [
    { type: TreeTable },
    { type: FrameContext },
    { type: DateTimeHelperService }
];
FarrisPrimengTreeTableBindingDirective.propDecorators = {
    hierarchyInfoKey: [{ type: Input, args: ['farrisHierarchyInfoKey',] }],
    columns: [{ type: Input, args: ['columns',] }],
    idField: [{ type: Input, args: ['farrisPrimengTreeTableIdField',] }],
    nodeSelectChange: [{ type: Output }],
    onEditInitHandler: [{ type: HostListener, args: ['onEditInit', ['$event'],] }],
    onEditCompleteHandler: [{ type: HostListener, args: ['onEditComplete', ['$event'],] }],
    onNodeExpandHandler: [{ type: HostListener, args: ['onNodeExpand', ['$event'],] }],
    onNodeCollapseHandler: [{ type: HostListener, args: ['onNodeCollapse', ['$event'],] }],
    onNodeSelectHandler: [{ type: HostListener, args: ['onNodeSelect', ['$event'],] }],
    onNodeUnselectHandler: [{ type: HostListener, args: ['onNodeUnselect', ['$event'],] }]
};

class FarrisDynamicRequiredDirective {
    constructor(frameContext, injector) {
        this.frameContext = frameContext;
        this.injector = injector;
        /**
         * 启用校验的时机
         */
        this.requiredOn = false;
    }
    ngOnDestroy() {
        this.updateValidateRule(false);
    }
    ngOnChanges(changes) {
        // 启用必填校验
        this.updateValidateRule(this.requiredOn);
    }
    /**
     *
     * @param isRequired
     */
    updateValidateRule(isRequired) {
        if (!this.field) {
            return;
        }
        this.frameContext.form.updateFieldValidateRule(this.field, isRequired);
        // if (isRequired) {
        //   const rules = this.frameContext.params.get(EXCLUDE_VALIDATE_FIELDS) || {};
        //   const fieldExcludeRules: string[] = rules[this.field] || [];
        //   if (fieldExcludeRules.includes(RULETYPE)) {
        //     const index = fieldExcludeRules.indexOf(RULETYPE);
        //     fieldExcludeRules.splice(index, 1);
        //   }
        //   this.frameContext.params.set(EXCLUDE_VALIDATE_FIELDS, rules);
        //   this.frameContext.form.updateFieldValidateRule(this.field, fieldExcludeRules);
        // } else {
        //   // 禁用校验
        //   // {int1:[required,maxValue]}
        //   const rules = this.frameContext.params.get(EXCLUDE_VALIDATE_FIELDS) || {};
        //   const fieldExcludeRules = rules[this.field] || [];
        //   if (fieldExcludeRules && !fieldExcludeRules.includes(RULETYPE)) {
        //     fieldExcludeRules.push(RULETYPE);
        //   }
        //   rules[this.field] = fieldExcludeRules;
        //   this.frameContext.params.set(EXCLUDE_VALIDATE_FIELDS, rules);
        //   this.frameContext.form.updateFieldValidateRule(this.field, fieldExcludeRules);
        // }
    }
}
FarrisDynamicRequiredDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-dynamic-required]'
            },] }
];
/** @nocollapse */
FarrisDynamicRequiredDirective.ctorParameters = () => [
    { type: FrameContext },
    { type: Injector }
];
FarrisDynamicRequiredDirective.propDecorators = {
    field: [{ type: Input, args: ['farris-dynamic-required',] }],
    requiredOn: [{ type: Input, args: ['requiredOn',] }]
};

class FarrisEditorDirective {
    constructor(viewModel, editor) {
        this.viewModel = viewModel;
        this.editor = editor;
    }
    ngOnInit() {
        this.setComponentRef();
    }
    setComponentRef() {
        const appContext = this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.getFormAppContext();
        const frameId = this.viewModel && this.viewModel.frameContext && this.viewModel.frameContext.frameId;
        const editor = this.editor;
        const elementRef = editor && editor.injector && editor.injector.get(ElementRef, null);
        const id = elementRef && elementRef.nativeElement && elementRef.nativeElement.id || null;
        // 如果frameId不存在或treetable没有id属性，说明不符合使用场景
        if (!frameId || !id) {
            return;
        }
        const map = appContext && appContext.componentRefs && appContext.componentRefs.get(frameId) || new Map();
        appContext && appContext.componentRefs && appContext.componentRefs.set(frameId, map.set(id, this.editor));
    }
}
FarrisEditorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-editor],[farris-editor-bind]'
            },] }
];
/** @nocollapse */
FarrisEditorDirective.ctorParameters = () => [
    { type: ViewModel },
    { type: EditorComponent }
];

class FarrisQuerySolutionEventBindDirective {
    constructor(injector, component, frameContext) {
        this.injector = injector;
        this.component = component;
        this.frameContext = frameContext;
    }
    /**
     * 执行筛选
     * @param event event
     */
    onQuery(event) {
        if (this.frameContext) {
            this.frameContext.repository.entityCollection.pageIndex = 1;
        }
    }
}
FarrisQuerySolutionEventBindDirective.decorators = [
    { type: Directive, args: [{
                selector: "[farris-querysolution-event-bind]"
            },] }
];
/** @nocollapse */
FarrisQuerySolutionEventBindDirective.ctorParameters = () => [
    { type: Injector },
    { type: QuerySolutionComponent },
    { type: FrameContext }
];
FarrisQuerySolutionEventBindDirective.propDecorators = {
    onQuery: [{ type: HostListener, args: ["queryEmitter",] }]
};

class FarrisDateLocalizationDirective {
    constructor(injector, userSettings, componentRef) {
        this.injector = injector;
        this.userSettings = userSettings;
        this.componentRef = componentRef;
    }
    ngOnInit() {
        this.localize();
    }
    localize() {
        if (this.userSettings && this.componentRef) {
            const { dateFormat = null, timeFormat = null } = this.userSettings;
            if (dateFormat === null && timeFormat === null) {
                return;
            }
            if (timeFormat && timeFormat && this.componentRef.showTime === true) {
                this.componentRef.dateFormat = `${dateFormat} ${timeFormat}`;
                this.componentRef.dateOpts.dateFormat = `${dateFormat} ${timeFormat}`;
                this.componentRef.updateValue(this.componentRef.value);
            }
            else if (dateFormat) {
                this.componentRef.dateFormat = `${dateFormat}`;
                this.componentRef.dateOpts.dateFormat = `${dateFormat}`;
                this.componentRef.updateValue(this.componentRef.value);
            }
        }
    }
}
FarrisDateLocalizationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-date-localization]'
            },] }
];
/** @nocollapse */
FarrisDateLocalizationDirective.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [UserSettingsToken,] }] },
    { type: FarrisDatepickerComponent }
];

class FarrisNumberLocalizationDirective {
    constructor(injector, userSettings, componentRef) {
        this.injector = injector;
        this.userSettings = userSettings;
        this.componentRef = componentRef;
    }
    ngOnInit() {
        this.localize();
    }
    localize() {
        return;
        // 涉及金额等问题，数字格式化不予处理
        if (this.userSettings && this.userSettings.numberFormat && this.componentRef) {
            const { negativeSign = null, numberDecimalDigits = null, numberDecimalSeparator = null, numberGroupSeparator = null } = this.userSettings.numberFormat || {};
            // 小数位数
            if (numberDecimalDigits !== null) {
                this.componentRef.precision = numberDecimalDigits;
                this.componentRef.formatOptions['precision'] = numberDecimalDigits;
            }
            // 小数点符号
            if (numberDecimalSeparator !== null) {
                this.componentRef.decimalSeparator = numberDecimalSeparator;
                this.componentRef.formatOptions['decimalSeparator'] = numberDecimalSeparator;
            }
            // 千分位符号
            if (numberGroupSeparator !== null) {
                this.componentRef.groupSeparator = numberGroupSeparator;
                this.componentRef.formatOptions['groupSeparator'] = numberGroupSeparator;
            }
            this.componentRef.updateValue(this.componentRef.value);
        }
    }
}
FarrisNumberLocalizationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-number-localization]'
            },] }
];
/** @nocollapse */
FarrisNumberLocalizationDirective.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [UserSettingsToken,] }] },
    { type: NumberSpinnerComponent }
];

class FarrisTimeLocalizationDirective {
    constructor(injector, userSettings, componentRef) {
        this.injector = injector;
        this.userSettings = userSettings;
        this.componentRef = componentRef;
    }
    ngOnInit() {
        this.localize();
    }
    localize() {
        if (this.userSettings && this.componentRef) {
            const { timeFormat = null } = this.userSettings;
            if (timeFormat) {
                this.componentRef.format = timeFormat;
            }
        }
    }
}
FarrisTimeLocalizationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-time-localization]'
            },] }
];
/** @nocollapse */
FarrisTimeLocalizationDirective.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [UserSettingsToken,] }] },
    { type: TimePickerComponent }
];

class FarrisTextLocalizationDirective {
    constructor(injector, userSettings, componentRef) {
        this.injector = injector;
        this.userSettings = userSettings;
        this.componentRef = componentRef;
        this.transform();
    }
    ngOnInit() {
    }
    transform() {
        if (this.componentRef) {
            this.componentRef.beforeWriteValue = (value, options) => {
                let { localizationType = null, showTime = false } = options;
                if (!value) {
                    return '';
                }
                if (localizationType && value) {
                    localizationType = localizationType.toLowerCase();
                    value = this.transformValue(value, localizationType);
                    return value;
                }
                else {
                    return undefined;
                }
            };
        }
    }
    transformValue(value, dataType) {
        if (dataType === 'date') {
            return this.transformDate(value);
        }
        else if (dataType === 'datetime') {
            return this.transformDateTime(value);
        }
        // 涉及金额计算及显示问题，不予处理
        //  else if (dataType === 'number') {
        //   return this.transformNumber(value);
        // } 
        else {
            return value;
        }
    }
    /**
     * 转换日期
     * @param value value
     */
    transformDate(value) {
        let dateFormat = this.userSettings && this.userSettings.dateFormat || 'YYYY-MM-DD';
        if (!dateFormat || !value) {
            return value;
        }
        const date = moment(value);
        const isValid = date.isValid();
        if (!isValid) {
            return value;
        }
        dateFormat = this.parseDateFormat(dateFormat);
        return date.format(dateFormat);
    }
    /**
     * 转换日期时间
     * @param value value
     * todo: 目前无法定义日期时间格式
     */
    transformDateTime(value) {
        let dateFormat = this.userSettings && this.userSettings.dateFormat || 'YYYY-MM-DD';
        let timeFormat = this.userSettings && this.userSettings.timeFormat || 'HH:mm:ss';
        if (!dateFormat || !timeFormat) {
            return value;
        }
        const dateTime = moment(value);
        const isValid = dateTime.isValid();
        if (!isValid) {
            return value;
        }
        if (dateFormat) {
            dateFormat = this.parseDateFormat(dateFormat);
        }
        if (timeFormat) {
            timeFormat = this.parseTimeFormat(timeFormat);
        }
        const dateTimeFormat = dateFormat + ' ' + timeFormat;
        return dateTime.format(dateTimeFormat);
    }
    /**
     * 转换数字
     * @param value value
     */
    transformNumber(value) {
        if (value === null || value === undefined || value === '') {
            return '';
        }
        const bigNumber = new BigNumber(value);
        // 如果不是数字，不做任何处理
        if (!BigNumber.isBigNumber(bigNumber)) {
            return value;
        }
        const isNegative = bigNumber.isNegative();
        const format = this.buildNumberFormat();
        const { negativeSign = null, numberDecimalDigits = null } = this.numberFormat || {};
        if (isNegative) {
            if (negativeSign !== null) {
                format.prefix = negativeSign;
                return bigNumber.absoluteValue().toFormat(numberDecimalDigits, null, format);
            }
        }
        return bigNumber.toFormat(numberDecimalDigits, null, format);
    }
    /**
     * 转换日期格式规则为moment的format规则
     * @param format format
     */
    parseDateFormat(format) {
        return format.replace(/y/g, 'Y').replace(/d/g, 'D');
    }
    /**
     * 转换时间格式规则为moment的format规则
     * @param format format
     */
    parseTimeFormat(format) {
        return format.replace(/M/g, 'm');
    }
    /**
     * 构造bignumber数字格式化选项
     */
    buildNumberFormat() {
        if (this.numberFormat) {
            const { numberDecimalSeparator = null, numberGroupSeparator = null } = this.numberFormat;
            const format = {
                groupSize: 3,
            };
            if (numberDecimalSeparator !== null) {
                format.decimalSeparator = numberDecimalSeparator;
            }
            if (numberGroupSeparator !== null) {
                format.groupSeparator = numberGroupSeparator;
            }
            return format;
        }
    }
    get numberFormat() {
        return this.userSettings && this.userSettings.numberFormat || null;
    }
}
FarrisTextLocalizationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-text-localization]'
            },] }
];
/** @nocollapse */
FarrisTextLocalizationDirective.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [UserSettingsToken,] }] },
    { type: TextComponent }
];
FarrisTextLocalizationDirective.propDecorators = {
    localization: [{ type: Input, args: ['localization',] }]
};

class FarrisCheckboxModificationDirective {
    constructor(injector, elementRef) {
        this.injector = injector;
        this.elementRef = elementRef;
    }
    ngOnInit() {
        if (typeof this.index !== 'number' || !this.elementRef) {
            return;
        }
        const nativeElement = this.elementRef.nativeElement;
        if (nativeElement) {
            const id = nativeElement.getAttribute('id');
            if (id) {
                const token = `${id}_${this.index}`;
                this.elementRef.nativeElement.setAttribute('id', token);
                this.elementRef.nativeElement.setAttribute('name', token);
                this.elementRef.nativeElement.setAttribute('original_id', id);
            }
        }
    }
}
FarrisCheckboxModificationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-checkbox-modification]'
            },] }
];
/** @nocollapse */
FarrisCheckboxModificationDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef }
];
FarrisCheckboxModificationDirective.propDecorators = {
    index: [{ type: Input }]
};

class FarrisLabelModificationDirective {
    constructor(injector, elementRef) {
        this.injector = injector;
        this.elementRef = elementRef;
    }
    ngOnInit() {
        if (typeof this.index !== 'number' || !this.elementRef) {
            return;
        }
        const nativeElement = this.elementRef.nativeElement;
        if (nativeElement) {
            const labelFor = nativeElement.getAttribute('for');
            if (labelFor) {
                this.elementRef.nativeElement.setAttribute('for', `${labelFor}_${this.index}`);
            }
        }
    }
}
FarrisLabelModificationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-label-modification]'
            },] }
];
/** @nocollapse */
FarrisLabelModificationDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef }
];
FarrisLabelModificationDirective.propDecorators = {
    index: [{ type: Input }]
};

class FarrisLookupBindingDirective {
    constructor(lookup, comboLookup) {
        this.lookup = lookup;
        this.comboLookup = comboLookup;
    }
    set lookupValue(value) {
        if (this.lookupType === 'lookup' && this.lookup) {
            this.lookup.writeValue(value);
        }
        else if (this.lookupType === 'comboLookup' && this.comboLookup) {
            this.comboLookup.writeValue(value);
        }
    }
}
FarrisLookupBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-lookup-binding]'
            },] }
];
/** @nocollapse */
FarrisLookupBindingDirective.ctorParameters = () => [
    { type: LookupGridComponent, decorators: [{ type: Optional }] },
    { type: ComboLookupComponent, decorators: [{ type: Optional }] }
];
FarrisLookupBindingDirective.propDecorators = {
    lookupType: [{ type: Input }],
    lookupValue: [{ type: Input, args: ['farris-lookup-binding',] }]
};

class ComponentRef {
    constructor(frameContext, elementRef) {
        this.frameContext = frameContext;
        this.elementRef = elementRef;
    }
    addComponent(componentRef) {
        const id = this.elementRef && this.elementRef.nativeElement && this.elementRef.nativeElement.id;
        if (this.frameContext && id && componentRef) {
            this.frameContext.componentRefManager.add(id, componentRef);
        }
    }
    tryAddComponent(componentRef, componentId = null) {
        const id = componentId || this.elementRef && this.elementRef.nativeElement && this.elementRef.nativeElement.id;
        if (this.frameContext && id && componentRef && !this.frameContext.componentRefManager.has(id)) {
            this.frameContext.componentRefManager.add(id, componentRef);
        }
    }
}

class ListNavComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    //#region angular lifecycle
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
ListNavComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[listNavRef]'
            },] }
];
/** @nocollapse */
ListNavComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: ListNavComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class ListViewComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
ListViewComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[listViewRef]'
            },] }
];
/** @nocollapse */
ListViewComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: ListViewComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class ListFilterComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
ListFilterComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[listFilterRef]'
            },] }
];
/** @nocollapse */
ListFilterComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: ListFilterComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class FilterComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
FilterComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[filterRef]'
            },] }
];
/** @nocollapse */
FilterComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: FilterComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class ViewChangeComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
ViewChangeComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[viewChangeRef]'
            },] }
];
/** @nocollapse */
ViewChangeComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: ViewChangeComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class HtmlEditorComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
HtmlEditorComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[htmlEditorRef]'
            },] }
];
/** @nocollapse */
HtmlEditorComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: HtmlEditorComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class SectionComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
SectionComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sectionRef]'
            },] }
];
/** @nocollapse */
SectionComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: FarrisSectionComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class InputGroupComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
InputGroupComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[inputGroupRef]'
            },] }
];
/** @nocollapse */
InputGroupComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: InputGroupComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class DatepickerComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
DatepickerComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[datepickerRef]'
            },] }
];
/** @nocollapse */
DatepickerComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: FarrisDatepickerComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class TimePickerComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
TimePickerComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[timePickerRef]'
            },] }
];
/** @nocollapse */
TimePickerComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: TimePickerComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class NumberSpinnerComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
NumberSpinnerComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[numberSpinnerRef]'
            },] }
];
/** @nocollapse */
NumberSpinnerComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: NumberSpinnerComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class ComboListComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
ComboListComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[comboListRef]'
            },] }
];
/** @nocollapse */
ComboListComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: ComboListComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class ComboLookupComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
ComboLookupComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[comboLookupRef]'
            },] }
];
/** @nocollapse */
ComboLookupComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: ComboLookupComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class LookupGridComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
LookupGridComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[lookupGridRef]'
            },] }
];
/** @nocollapse */
LookupGridComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: LookupGridComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class DatagridComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component, this.component.id);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
DatagridComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[datagridRef]'
            },] }
];
/** @nocollapse */
DatagridComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: DatagridComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class TreetableComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
TreetableComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[treetableRef]'
            },] }
];
/** @nocollapse */
TreetableComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: TreeTableComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class WizardComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
WizardComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[wizardRef]'
            },] }
];
/** @nocollapse */
WizardComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: WizardComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class DiscussionEditorComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
DiscussionEditorComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[discussionEditorRef]'
            },] }
];
/** @nocollapse */
DiscussionEditorComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: DiscussionEditorComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class DiscussionListComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
DiscussionListComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[discussionListRef]'
            },] }
];
/** @nocollapse */
DiscussionListComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: DiscussionListComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class NavComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
NavComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[navRef]'
            },] }
];
/** @nocollapse */
NavComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: NavComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class MultiSelectComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
MultiSelectComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[multiSelectRef]'
            },] }
];
/** @nocollapse */
MultiSelectComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: MultiSelectComponent },
    { type: ElementRef },
    { type: FrameContext }
];

class ScrollspyComponentRefDirective extends ComponentRef {
    constructor(injector, component, elementRef, frameContext) {
        super(frameContext, elementRef);
        this.injector = injector;
        this.component = component;
        this.elementRef = elementRef;
        this.frameContext = frameContext;
    }
    ngAfterViewInit() {
        this.tryAddComponent(this.component);
    }
    ngOnInit() {
        this.addComponent(this.component);
    }
    ngOnDestroy() {
    }
}
ScrollspyComponentRefDirective.decorators = [
    { type: Directive, args: [{
                selector: '[scrollspyRef]'
            },] }
];
/** @nocollapse */
ScrollspyComponentRefDirective.ctorParameters = () => [
    { type: Injector },
    { type: ScrollspyComponent },
    { type: ElementRef },
    { type: FrameContext }
];

/**
 * 使用方法：
 * [comob-lookup-data-mapping]="{ id: 'user.userId', name: 'user.userName' }"
 * key 为帮助上的字段， value 为 表单中的字段名
 * 帮助上的同一个字段可以映射到表单中的多个字段中，{ ... id: 'user.userid, user.addusid'}
 * 多字段以逗号隔开
 *
 */
class ComboLookupDataMappingDirective extends DataMapping {
    constructor(vm, lookup) {
        super();
        this.vm = vm;
        this.lookup = lookup;
        this.target = null;
        if (this.lookup) {
            this.lookup.useFormDataMapping = true;
        }
    }
    ngOnInit() {
        // 值变化，亦通过该事件触发任意输入清空事件
        this.lookup.valueChange.subscribe((result) => {
            if (!result['nosearch']) {
                // 值变化
                const data = result.selections && result.selections.length > 0 ? result.selections : null;
                this.onValueChange(data);
            }
            else {
                // 任意输入清空映射字段
                this.onClearMapping();
            }
        });
        // 清空事件
        this.lookup.clear.subscribe(() => {
            const _mapfields = this.mapfields || this.lookup.mapFields;
            this.mappingData(null, _mapfields);
        });
    }
    onClearMapping() {
        const mapfields = Object.assign({}, (this.mapfields || this.lookup.mapFields || {}));
        const lookupTextField = this.lookup.textField;
        const data = {};
        const controlName = this.lookup.ngControl && this.lookup.ngControl.name;
        if (controlName && this.vm) {
            const textFieldMapping = mapfields[lookupTextField];
            const ngFormControl = this.vm && this.vm.form && this.vm.form.ngFormControls && this.vm.form.ngFormControls[controlName];
            const binding = ngFormControl && ngFormControl.binding;
            if (textFieldMapping && binding) {
                const targetField = textFieldMapping.split(',').filter((item) => item !== binding).join(',');
                if (targetField) {
                    mapfields[lookupTextField] = targetField;
                }
                else {
                    delete mapfields[lookupTextField];
                }
            }
        }
        if (mapfields && Object.keys(mapfields).length > 0) {
            Object.keys(mapfields).forEach((field) => {
                this.setValue(data, field.split('.'), '');
            });
            this.mappingData(data, mapfields, true);
        }
    }
    onValueChange(data) {
        const _mapfields = this.mapfields || this.lookup.mapFields;
        const spliter = this.lookup.separator || this.defaultSpliter;
        this.mappingData(data, _mapfields, false, spliter);
    }
}
ComboLookupDataMappingDirective.decorators = [
    { type: Directive, args: [{ selector: '[combo-lookup-data-mapping]' },] }
];
/** @nocollapse */
ComboLookupDataMappingDirective.ctorParameters = () => [
    { type: ViewModel, decorators: [{ type: Optional }] },
    { type: ComboLookupComponent, decorators: [{ type: Optional }, { type: Self }] }
];
ComboLookupDataMappingDirective.propDecorators = {
    mapfields: [{ type: Input, args: ['combo-lookup-data-mapping',] }],
    target: [{ type: Input, args: ['target',] }]
};

var ViewType;
(function (ViewType) {
    ViewType["day"] = "day";
    ViewType["week"] = "week";
})(ViewType || (ViewType = {}));

class AppointmentCalendarBindingDirective {
    constructor(injector, frameContext, calendarComponent) {
        this.injector = injector;
        this.frameContext = frameContext;
        this.calendarComponent = calendarComponent;
        /**
         * 房间列表api url
         */
        this.url = null;
        /**
         * http method, default PUT
         */
        this.method = 'PUT';
        this.startDateVariable = 'startDate';
        this.endDateVariable = 'endDate';
        this.viewTypeVariable = 'viewType';
    }
    get bindingData() {
        return this.frameContext.bindingData;
    }
    get viewModel() {
        return this.frameContext.viewModel;
    }
    restService() {
        return this.frameContext.repository.restService;
    }
    /**
     * 获取绑定数据
     */
    get bindingList() {
        // 根实体
        if (this.viewModel.bindingPath === '/' || !this.viewModel.bindingPath) {
            return this.bindingData.list;
        }
        // 子实体
        let bindingPath = this.viewModel.bindingPath.substr(1);
        bindingPath = bindingPath[0].toLowerCase() + bindingPath.substring(1, bindingPath.length);
        const paths = bindingPath.split('/');
        const filteredPaths = paths.filter((part) => {
            return part !== '';
        });
        return this.bindingData.getValue(filteredPaths);
    }
    ngOnInit() {
        this.loadPlacements();
        this.registerBindingDataChangeEvent();
    }
    ngOnChanges(changes) {
    }
    ngOnDestroy() {
        this.unRegisterBindingDataChangeEvent();
    }
    bindData(change) {
        // 再toJSON
        let data = this.bindingList.toJSON();
        if (this.__DATA__ && isEqual(this.__DATA__, data)) {
            return;
        }
        this.__DATA__ = data;
        this.calendarComponent.loadReserveData(data);
    }
    onBindingDataChange(change) {
        this.bindData(change);
        this.updateSelectedRow(change);
    }
    registerBindingDataChangeEvent() {
        this.bindingDataChangeEvent = this.bindingData.changes.subscribe((change) => {
            this.onBindingDataChange(change);
        });
    }
    /**
     * 取消bindingdata变化订阅
     */
    unRegisterBindingDataChangeEvent() {
        if (this.bindingDataChangeEvent && typeof (this.bindingDataChangeEvent.unsubscribe) === 'function') {
            this.bindingDataChangeEvent.unsubscribe();
        }
    }
    loadPlacements() {
        if (!this.url) {
            console.log('无法加载房间信息，请配置房间列表api地址');
            return;
        }
        const requestInfo = this.restService().buildRequestInfo();
        const options = {
            body: {
                requestInfo
            }
        };
        const url = BasePathService.convertPath(this.url);
        this.restService().request(url, this.method, null, options).subscribe((returnValue) => {
            this.bindPlacements(returnValue);
        });
    }
    bindPlacements(placments) {
        this.calendarComponent.loadPlaceData(placments);
    }
    updateState(startDate, endDate, viewType) {
        this.viewModel.uiState.setPropertyValue(this.startDateVariable, startDate);
        this.viewModel.uiState.setPropertyValue(this.endDateVariable, endDate);
        this.viewModel.uiState.setPropertyValue(this.viewTypeVariable, viewType);
    }
    updateSelectedRow(change) {
        if (!this.bindingList || !this.bindingList.currentId) {
            return;
        }
        // 页码切换时不执行当前行切换
        if (change && change.type === ChangeType.PaginationInfoChange) {
            return;
        }
        if (this.viewModel && this.viewModel.frameContext.bindingData.rowSelectedEventSuspend === true) {
            return;
        }
        const id = this.calendarComponent.selectedId;
        const currentId = this.bindingList.currentId;
        // grid当前行与bingingList当前行一致，无须切换
        if (id === currentId) {
            return;
        }
        this.selectCalendarRow(this.bindingList.currentId);
    }
    selectCalendarRow(id) {
        this.calendarComponent.selectItem(id);
    }
    filterChanged(event) {
        const { dateValue = null, place = null, viewType = null } = event || {};
        let startDate = null;
        let endDate = null;
        if (!dateValue) {
            return;
        }
        if (viewType === ViewType.day) {
            startDate = `${dateValue} 00:00:00`;
            endDate = `${dateValue} 23:59:59`;
        }
        else if (viewType === ViewType.week && dateValue.indexOf('~') !== -1) {
            const sections = dateValue.split('~');
            startDate = `${sections[0]} 00:00:00`;
            endDate = `${sections[1]} 23:59:59`;
        }
        this.updateState(startDate, endDate, viewType);
    }
    setSelectionIdToBindingData(id) {
        // 如果当前行不存在，则强制设置
        if (this.bindingList.currentId !== id) {
            this.bindingList.setCurrentId(id, true);
        }
    }
    selectChange(event) {
        const { item: { id = null } } = event;
        this.setSelectionIdToBindingData(id);
    }
}
AppointmentCalendarBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-appointment-calendar-binding]'
            },] }
];
/** @nocollapse */
AppointmentCalendarBindingDirective.ctorParameters = () => [
    { type: Injector },
    { type: FrameContext },
    { type: AppointmentCalendarComponent }
];
AppointmentCalendarBindingDirective.propDecorators = {
    url: [{ type: Input }],
    method: [{ type: Input }],
    startDateVariable: [{ type: Input }],
    endDateVariable: [{ type: Input }],
    viewTypeVariable: [{ type: Input }],
    filterChanged: [{ type: HostListener, args: ['filterChange', ['$event'],] }],
    selectChange: [{ type: HostListener, args: ['selectChange', ['$event'],] }]
};

class CustomDatagridSizeDirective {
    constructor(dg, injector, cd, el, frameContext) {
        this.dg = dg;
        this.injector = injector;
        this.cd = cd;
        this.el = el;
        this.frameContext = frameContext;
        this.useCustomSize = false;
        this.sizeApiUri = '';
    }
    restService() {
        return this.frameContext.repository.restService;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (changes.sizeApiUri && !changes.sizeApiUri.isFirstChange()) {
            this.applyNewSize();
        }
    }
    ngAfterViewInit() {
        this.applyNewSize();
    }
    applyNewSize() {
        if (this.useCustomSize && this.sizeApiUri) {
            this.getSizeConfig().subscribe((cfg) => {
                if (this.dg && typeof this.dg.applyNewSize === 'function') {
                    this.dg.applyNewSize(cfg);
                }
            });
        }
    }
    getSizeConfig() {
        return this.restService().request(this.sizeApiUri, 'get');
    }
}
CustomDatagridSizeDirective.decorators = [
    { type: Directive, args: [{ selector: '[custom-size]' },] }
];
/** @nocollapse */
CustomDatagridSizeDirective.ctorParameters = () => [
    { type: DatagridComponent },
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: FrameContext }
];
CustomDatagridSizeDirective.propDecorators = {
    useCustomSize: [{ type: Input, args: ['custom-size',] }],
    sizeApiUri: [{ type: Input }]
};

class FarrisFilterBindingDirective {
    constructor(injector, frameContext, filterComponent) {
        this.injector = injector;
        this.frameContext = frameContext;
        this.filterComponent = filterComponent;
        /**
         * 变量编号，默认为filterConditionList
         */
        this.variableCode = 'filterConditionList';
        this.$destroy = new Subject();
    }
    ngOnDestroy() {
        if (this.$destroy) {
            this.$destroy.next();
            this.$destroy.complete();
        }
    }
    ngOnInit() {
        if (this.filterComponent) {
            this.filterComponent.conditionsChange.pipe(takeUntil(this.$destroy)).subscribe((event) => {
                const { data = '[]' } = event || {};
                this.setConditions(data);
            });
        }
    }
    setConditions(conditions) {
        this.frameContext.uiState.setPropertyValue(this.variableCode, conditions);
    }
}
FarrisFilterBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-filter-binding]'
            },] }
];
/** @nocollapse */
FarrisFilterBindingDirective.ctorParameters = () => [
    { type: Injector },
    { type: FrameContext },
    { type: FilterComponent, decorators: [{ type: Optional }] }
];
FarrisFilterBindingDirective.propDecorators = {
    variableCode: [{ type: Input, args: ['variableCode',] }]
};

class FarrisListFilterBindingDirective {
    constructor(injector, frameContext, listFilterComponent) {
        this.injector = injector;
        this.frameContext = frameContext;
        this.listFilterComponent = listFilterComponent;
        /**
         * 变量编号，默认为filterConditionList
         */
        this.variableCode = 'filterConditionList';
        this.$destroy = new Subject();
    }
    ngOnDestroy() {
        if (this.$destroy) {
            this.$destroy.next();
            this.$destroy.complete();
        }
    }
    ngOnInit() {
        if (this.listFilterComponent) {
            this.listFilterComponent.conditionsChange.pipe(takeUntil(this.$destroy)).subscribe((event) => {
                const { data = '[]' } = event || {};
                this.setConditions(data);
            });
        }
    }
    setConditions(conditions) {
        this.frameContext.uiState.setPropertyValue(this.variableCode, conditions);
    }
}
FarrisListFilterBindingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farris-list-filter-binding]'
            },] }
];
/** @nocollapse */
FarrisListFilterBindingDirective.ctorParameters = () => [
    { type: Injector },
    { type: FrameContext },
    { type: ListFilterComponent, decorators: [{ type: Optional }] }
];
FarrisListFilterBindingDirective.propDecorators = {
    variableCode: [{ type: Input, args: ['variableCode',] }]
};

class ImageIdToUrlPipe {
    constructor(injector) {
        this.injector = injector;
        this.defaultPic = BasePathService.convertPath('/platform/common/web/assets/imgs/no-pic.png');
        this.downloadService = this.injector && this.injector.get(DownloadService, null) || null;
    }
    transform(value, rootId = 'default-root') {
        if (!value) {
            return this.defaultPic;
        }
        //const rootId = 'default-root';
        if (this.downloadService) {
            return this.downloadService.getDownloadUrl(value, rootId);
        }
        else {
            console.warn('因安全问题，附件下载提供安全校验机制，附件下载功能需重新编译。');
            return BasePathService.convertPath(`/api/runtime/dfs/v1.0/formdoc/download/${value}`);
        }
    }
}
ImageIdToUrlPipe.decorators = [
    { type: Pipe, args: [{ name: 'imageIdToUrl' },] }
];
/** @nocollapse */
ImageIdToUrlPipe.ctorParameters = () => [
    { type: Injector, decorators: [{ type: Optional }] }
];

class FormatPrimeNgTreeTableCellData {
    constructor(cfs, injector) {
        this.cfs = cfs;
        this.injector = injector;
        if (this.injector) {
            this.localeService = this.injector.get(LocaleService);
        }
    }
    transform(col, rowData) {
        let value = '';
        if (rowData && col && col.field) {
            value = this.getValue(col.field, rowData);
            let formatterFn = col.formatter;
            if (!formatterFn) {
                if (col.isMultilingualField) {
                    return this.getMultiLanguageValue(value);
                }
                else {
                    return value;
                }
            }
            else {
                return this.cfs.format(value, rowData, formatterFn);
            }
        }
        return '';
    }
    // 获取多语数据
    getMultiLanguageValue(valObj) {
        if (valObj && typeof valObj === 'object' && Object.keys(valObj).length > 0) {
            const localeId = this.localeService && this.localeService.localeId || 'zh-CHS';
            const value = valObj[localeId];
            return value === undefined ? '' : value;
        }
        else {
            return '';
        }
    }
    getValue(path, target) {
        if (!target) {
            return '';
        }
        var resultVal = '';
        if (path.indexOf('.') === -1) {
            resultVal = target[path];
        }
        else {
            resultVal = path.split('.').reduce(((obj, key) => {
                return obj && obj[key] || null;
            }), target);
        }
        return resultVal;
    }
    ;
    /**
     * 是否为帮助列
     * @param col col
     */
    isHelpColumn(col) {
        return col && col.editor && col.editor.options && col.editor.options.type === 'EditorTypes.LOOKUP' || false;
    }
    getHelpColumnValue(col, data) {
        const textField = this.getHelpControlTextField(col);
        const mapFields = this.getHelpControlMapFields(col);
        if (textField && mapFields && Object.keys(mapFields).length > 0) {
            const path = mapFields[textField];
            return this.getValue(path, data);
        }
        return '';
    }
    getHelpControlTextField(col) {
        return col && col.editor && col.editor.options && col.editor.options.textField || '';
    }
    getHelpControlMapFields(col) {
        return col && col.editor && col.editor.options && col.editor.options.mapFields || {};
    }
}
FormatPrimeNgTreeTableCellData.decorators = [
    { type: Pipe, args: [{ name: 'formatPrimeNgTreeTableCellData', pure: false },] }
];
/** @nocollapse */
FormatPrimeNgTreeTableCellData.ctorParameters = () => [
    { type: ColumnFormatService },
    { type: Injector, decorators: [{ type: Optional }] }
];

class Localization {
    constructor(injector, userSettings) {
        this.injector = injector;
        this.userSettings = userSettings;
    }
    transform(value, dataType) {
        if (dataType) {
            dataType = dataType.toLowerCase();
            if (dataType === 'date') {
                return this.transformDate(value);
            }
            else if (dataType === 'datetime') {
                return this.transformDateTime(value);
            }
            else if (dataType === 'number') {
                return this.transformNumber(value);
            }
            else {
                return value;
            }
        }
    }
    /**
     * 转换日期
     * @param value value
     */
    transformDate(value) {
        let dateFormat = this.userSettings && this.userSettings.dateFormat || null;
        if (!dateFormat || !value) {
            return value;
        }
        const date = moment(value);
        const isValid = date.isValid();
        if (!isValid) {
            return value;
        }
        dateFormat = this.parseDateFormat(dateFormat);
        return date.format(dateFormat);
    }
    /**
     * 转换日期时间
     * @param value value
     * todo: 目前无法定义日期时间格式
     */
    transformDateTime(value) {
        let dateFormat = this.userSettings && this.userSettings.dateFormat || '';
        let timeFormat = this.userSettings && this.userSettings.timeFormat || '';
        const dateTime = moment(value);
        const isValid = dateTime.isValid();
        if (!isValid) {
            return value;
        }
        if (dateFormat) {
            dateFormat = this.parseDateFormat(dateFormat);
        }
        if (timeFormat) {
            timeFormat = this.parseTimeFormat(timeFormat);
        }
        const dateTimeFormat = dateFormat + ' ' + timeFormat;
        return dateTime.format(dateTimeFormat);
    }
    /**
     * 转换数字
     * @param value value
     */
    transformNumber(value) {
        if (value === null || value === undefined || value === '') {
            return '';
        }
        const bigNumber = new BigNumber(value);
        // 如果不是数字，不做任何处理
        if (!BigNumber.isBigNumber(bigNumber)) {
            return value;
        }
        const isNegative = bigNumber.isNegative();
        const format = this.buildNumberFormat();
        const { negativeSign = null, numberDecimalDigits = null } = this.numberFormat;
        if (isNegative) {
            if (negativeSign !== null) {
                format.prefix = negativeSign;
                return bigNumber.absoluteValue().toFormat(numberDecimalDigits, null, format);
            }
        }
        return bigNumber.toFormat(numberDecimalDigits, null, format);
    }
    /**
     * 转换日期格式规则为moment的format规则
     * @param format format
     */
    parseDateFormat(format) {
        return format.replace(/y/g, 'Y').replace(/d/g, 'D');
    }
    /**
     * 转换时间格式规则为moment的format规则
     * @param format format
     */
    parseTimeFormat(format) {
        return format.replace(/M/g, 'm');
    }
    /**
     * 构造bignumber数字格式化选项
     */
    buildNumberFormat() {
        if (this.numberFormat) {
            const { numberDecimalSeparator = null, numberGroupSeparator = null } = this.numberFormat;
            const format = {
                groupSize: 3,
            };
            if (numberDecimalSeparator !== null) {
                format.decimalSeparator = numberDecimalSeparator;
            }
            if (numberGroupSeparator !== null) {
                format.groupSeparator = numberGroupSeparator;
            }
            return format;
        }
    }
    get numberFormat() {
        return this.userSettings && this.userSettings.numberFormat || null;
    }
}
Localization.decorators = [
    { type: Pipe, args: [{ name: 'localization' },] }
];
/** @nocollapse */
Localization.ctorParameters = () => [
    { type: Injector, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Inject, args: [UserSettingsToken,] }] }
];

class KendoBindingModule {
}
KendoBindingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FarrisCommonModule.forRoot()
                ],
                declarations: [
                    KendoGridBindingDirective,
                    FarrisTreeTableBindingDirective,
                    LookupDataMappingDirective,
                    LookupEnableExtendLoadMethodDirective,
                    UIStateBindingDirective,
                    FarrisDisabledDirective,
                    FarrisSortDirective,
                    FarrisDynamicColumnFormatDirective,
                    FarrisEditEnterDirective,
                    FarrisTextareaEditDirective,
                    FarrisTreeTableFormatDirective,
                    StringToDatePipe,
                    GridColumnAggregateDirective,
                    GridSummaryDirective,
                    DateFormatPlaceholderPipe,
                    ImageIdToUrlPipe,
                    FormatPrimeNgTreeTableCellData,
                    FarrisDatagridUseBindingDataDirective,
                    MultiSelectDataMappingDirective,
                    FarrisListViewBindingDirective,
                    EditableDirective,
                    KendoGridFilterDirective,
                    FormatTotalPipe,
                    InputEndEditDirective,
                    FarrisDataGridEndEditDirective,
                    HtmlEditorEndEditDirective,
                    KendoGridEndEditDirective,
                    FarrisDataGridRemoteSummaryDirective,
                    FarrisFilePreviewBindingDirective,
                    FarrisSetFocusDirective,
                    FarrisDiscussionEditorBindingDirective,
                    FarrisDiscussionListBindingDirective,
                    FarrisPrimengTreeTableBindingDirective,
                    FarrisDynamicRequiredDirective,
                    FarrisEditorDirective,
                    FarrisQuerySolutionEventBindDirective,
                    FarrisDateLocalizationDirective,
                    FarrisNumberLocalizationDirective,
                    FarrisTimeLocalizationDirective,
                    FarrisTextLocalizationDirective,
                    Localization,
                    FarrisCheckboxModificationDirective,
                    FarrisLabelModificationDirective,
                    FarrisLookupBindingDirective,
                    ListNavComponentRefDirective,
                    ListViewComponentRefDirective,
                    ListFilterComponentRefDirective,
                    ViewChangeComponentRefDirective,
                    FilterComponentRefDirective,
                    SectionComponentRefDirective,
                    HtmlEditorComponentRefDirective,
                    InputGroupComponentRefDirective,
                    DatepickerComponentRefDirective,
                    TimePickerComponentRefDirective,
                    NumberSpinnerComponentRefDirective,
                    ComboListComponentRefDirective,
                    ComboLookupComponentRefDirective,
                    LookupGridComponentRefDirective,
                    DatagridComponentRefDirective,
                    TreetableComponentRefDirective,
                    WizardComponentRefDirective,
                    DiscussionEditorComponentRefDirective,
                    DiscussionListComponentRefDirective,
                    NavComponentRefDirective,
                    MultiSelectComponentRefDirective,
                    ScrollspyComponentRefDirective,
                    ComboLookupDataMappingDirective,
                    AppointmentCalendarBindingDirective,
                    CustomDatagridSizeDirective,
                    FarrisFilterBindingDirective,
                    FarrisListFilterBindingDirective
                ],
                providers: [
                    DialogService, GridComponent, FarrisKendoGridFormatService, FarrisTreetableFormatService
                ],
                exports: [
                    KendoGridBindingDirective,
                    FarrisTreeTableBindingDirective,
                    LookupDataMappingDirective,
                    LookupEnableExtendLoadMethodDirective,
                    UIStateBindingDirective,
                    FarrisDisabledDirective,
                    FarrisSortDirective,
                    FarrisDynamicColumnFormatDirective,
                    FarrisEditEnterDirective,
                    FarrisTextareaEditDirective,
                    FarrisTreeTableFormatDirective,
                    StringToDatePipe,
                    GridColumnAggregateDirective,
                    DateFormatPlaceholderPipe,
                    ImageIdToUrlPipe,
                    FormatPrimeNgTreeTableCellData,
                    FarrisDatagridUseBindingDataDirective,
                    MultiSelectDataMappingDirective,
                    FarrisListViewBindingDirective,
                    EditableDirective,
                    KendoGridFilterDirective,
                    FormatTotalPipe,
                    InputEndEditDirective,
                    FarrisDataGridEndEditDirective,
                    HtmlEditorEndEditDirective,
                    KendoGridEndEditDirective,
                    FarrisDataGridRemoteSummaryDirective,
                    FarrisFilePreviewBindingDirective,
                    FarrisSetFocusDirective,
                    FarrisDiscussionEditorBindingDirective,
                    FarrisDiscussionListBindingDirective,
                    FarrisPrimengTreeTableBindingDirective,
                    FarrisDynamicRequiredDirective,
                    FarrisEditorDirective,
                    FarrisQuerySolutionEventBindDirective,
                    FarrisDateLocalizationDirective,
                    FarrisNumberLocalizationDirective,
                    FarrisTimeLocalizationDirective,
                    FarrisTextLocalizationDirective,
                    Localization,
                    FarrisCheckboxModificationDirective,
                    FarrisLabelModificationDirective,
                    FarrisLookupBindingDirective,
                    ListNavComponentRefDirective,
                    ListViewComponentRefDirective,
                    ListFilterComponentRefDirective,
                    ViewChangeComponentRefDirective,
                    FilterComponentRefDirective,
                    SectionComponentRefDirective,
                    HtmlEditorComponentRefDirective,
                    InputGroupComponentRefDirective,
                    DatepickerComponentRefDirective,
                    TimePickerComponentRefDirective,
                    NumberSpinnerComponentRefDirective,
                    ComboListComponentRefDirective,
                    ComboLookupComponentRefDirective,
                    LookupGridComponentRefDirective,
                    DatagridComponentRefDirective,
                    TreetableComponentRefDirective,
                    WizardComponentRefDirective,
                    DiscussionEditorComponentRefDirective,
                    DiscussionListComponentRefDirective,
                    NavComponentRefDirective,
                    MultiSelectComponentRefDirective,
                    ScrollspyComponentRefDirective,
                    ComboLookupDataMappingDirective,
                    AppointmentCalendarBindingDirective,
                    CustomDatagridSizeDirective,
                    FarrisFilterBindingDirective,
                    FarrisListFilterBindingDirective
                ]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { ComponentRef as ɵc, DataMapping as ɵa, AbstractEndEdit as ɵb, ArrayConverter, DateConverter, MultiLangConverter, FilterConditionsConverter, KendoGridBindingDirective, FarrisTreeTableBindingDirective, LookupDataMappingDirective, LookupEnableExtendLoadMethodDirective, UIStateBindingDirective, FarrisDisabledDirective, FarrisSortDirective, FarrisTextareaEditDirective, FarrisDynamicColumnFormatDirective, FarrisEditEnterDirective, FarrisTreeTableFormatDirective, GridColumnAggregateDirective, GridSummaryDirective, FarrisDatagridUseBindingDataDirective, MultiSelectDataMappingDirective, FarrisListViewBindingDirective, EditableDirective, InputEndEditDirective, FarrisDataGridEndEditDirective, HtmlEditorEndEditDirective, KendoGridEndEditDirective, FarrisDataGridRemoteSummaryDirective, FarrisSetFocusDirective, FarrisFilePreviewBindingDirective, FarrisDiscussionEditorBindingDirective, FarrisDiscussionListBindingDirective, FarrisPrimengTreeTableBindingDirective, FarrisDynamicRequiredDirective, FarrisEditorDirective, FarrisQuerySolutionEventBindDirective, FarrisDateLocalizationDirective, FarrisNumberLocalizationDirective, FarrisTimeLocalizationDirective, FarrisTextLocalizationDirective, FarrisCheckboxModificationDirective, FarrisLabelModificationDirective, FarrisLookupBindingDirective, ListNavComponentRefDirective, ListViewComponentRefDirective, ListFilterComponentRefDirective, FilterComponentRefDirective, ViewChangeComponentRefDirective, HtmlEditorComponentRefDirective, SectionComponentRefDirective, InputGroupComponentRefDirective, DatepickerComponentRefDirective, TimePickerComponentRefDirective, NumberSpinnerComponentRefDirective, ComboListComponentRefDirective, ComboLookupComponentRefDirective, LookupGridComponentRefDirective, DatagridComponentRefDirective, TreetableComponentRefDirective, WizardComponentRefDirective, DiscussionEditorComponentRefDirective, DiscussionListComponentRefDirective, NavComponentRefDirective, MultiSelectComponentRefDirective, ScrollspyComponentRefDirective, ComboLookupDataMappingDirective, AppointmentCalendarBindingDirective, CustomDatagridSizeDirective, FarrisFilterBindingDirective, FarrisListFilterBindingDirective, ImageIdToUrlPipe, FormatPrimeNgTreeTableCellData, Localization, FarrisKendoGridFormatService, FarrisTreetableFormatService, StringToDatePipe, KendoGridFilterDirective, DateFormatPlaceholderPipe, FormatTotalPipe, KendoBindingModule };

//# sourceMappingURL=farris-kendo-binding.js.map