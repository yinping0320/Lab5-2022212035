import { TreeNode } from '@farris/ui-treetable';
/**
 * 树节点构造器
 * @summary
 * 将BindingData中的数据集合转换成TreeTable节点集合
 */
declare class ParentTreeNodeBuilder {
    private frameContext;
    /**
     * 构造函数
     */
    constructor(allNodesData: any[], oldTreeNodes: TreeNode[], primaryKey: string, hierarchyInfoKey: string, context?: any);
    /**
     * 展开至层级
     * @description -1为不展开
     */
    private readonly expandLevel;
    private readonly component;
    private readonly addTreeLoadCompleteListener;
    /**
     * 需要展开的节点
     */
    private nodesShouldExpand;
    /**
     * 等待展开的节点
     * @description 节点结构
     * ```
     * {id:'xxx',expanded:false}
     * ```
     */
    private nodesWaitExpand;
    /**
     * 主键字段名
     */
    private primaryKey;
    /**
     * 分级码字段名
     */
    private hierarchyInfoKey;
    /**
     * 节点的数据集合
     */
    private allNodesData;
    /**
     * 节点集合
     */
    private allNodes;
    /**
     * 上一次绑定的树节点集合Map
     */
    private allNodesMap;
    /**
     * 上一次绑定的树节点集合Map
     */
    private allOldNodesMap;
    /**
     * 上下文
     */
    private context;
    updateTreeNode(allNodesData: any, data: any): void;
    build(): TreeNode[];
    /**
     * 构造树节点
     */
    build1(): TreeNode[];
    /**
     * 构造树节点集合
     */
    private buildNodes;
    /**
     * 创建树节点
     */
    private buildNode;
    /**
     * 构造分页信息
     * @param nodeData nodeData
     * @returns
     */
    private buildPaginationInfo;
    /**
     * 计算节点是否要展开
     * @param nodeData nodeData
     */
    private shouldExpand;
    /**
     * 展开树节点
     * @description 完全加载树使用展开属性在buildNode时已经展开，此函数的主要用于展开分级加载树
     * @param nodeData nodeData
     */
    private expandNode;
    /**
     * 树加载完成事件
     */
    private onTreeLoadComplete;
    /**
     * 获取主键
     * @param nodeData nodeData
     */
    private getPrimary;
    /**
     * 获取子级节点的数据集合
     */
    private getChildNodesData;
    private getHierarchyInfo;
    private getValue;
    /**
     * 获取分级信息中的层级
     * @param nodeData nodeData
     */
    private getNodeLayer;
    /**
     * 获取分级信息中的父节点
     * @param nodeData nodeData
     */
    private getNodeParentElement;
    /**
     * 获取展开状态
     */
    private isExpanded;
    /**
     * 是否是叶子节点
     * @todo：应该用数据本身的isDetail来保证，但目前不准确，强制前端计算
     */
    private isLeaf;
    /**
     * 判断节点是否是新增
     * @todo：不应该这样判断，待优化。
     * @summary
     * 1、非空树（空树视为初次加载数据）；
     * 2、找不到oldNode。
     */
    private isNewNode;
    /**
     * 展开父节点
     */
    private expandParentNode;
    /**
     * 查找父节点
     */
    private getParentNode;
    /**
     * 获取老的树节点
     */
    private getOldNode;
    /**
     * 打平TreeNodes，并放入一个Map中
     */
    private buildNodesDataMap;
}
export { ParentTreeNodeBuilder };
