import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { PaginationModule } from '@farris/ui-pagination';
import { FarrisFormsModule } from '@farris/ui-forms';
import { DomSanitizer, EventManager } from '@angular/platform-browser';
import { ResizeService } from '@farris/ui-common/events';
import { ColumnFormatService, DataColumnModule } from '@farris/ui-common/column';
import { InputGroupModule } from '@farris/ui-input-group';
import { LocaleService, LocaleModule } from '@farris/ui-locale';
import { PerfectScrollbarComponent, PerfectScrollbarModule } from '@farris/ui-perfect-scrollbar';
import ResizeObserver from 'resize-observer-polyfill';
import { cloneDeep, extend, remove } from 'lodash-es';
import { FarrisContextMenuDirective, FarrisContextMenuModule } from '@farris/ui-context-menu';
import { switchMap, takeUntil, map, debounceTime, filter } from 'rxjs/operators';
import { Observable, Subject, of, BehaviorSubject, timer, fromEvent } from 'rxjs';
import { FarrisTemplateDirective, CommonUtils, IdService, FarrisComponentInstanceService, DebugService, FarrisCommonModule } from '@farris/ui-common';
import { Pipe, ElementRef, Injectable, NgModule, Component, defineInjectable, inject, EventEmitter, NgZone, Injector, Input, Output, ViewChild, ChangeDetectorRef, Directive, ViewEncapsulation, ChangeDetectionStrategy, Renderer2, ContentChildren, HostListener, HostBinding, Optional, Self } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HighlightPipe {
    /**
     * @param {?} sanitizer
     * @param {?} el
     */
    constructor(sanitizer, el) {
        this.sanitizer = sanitizer;
        this.el = el;
    }
    /**
     * @param {?} text
     * @param {?} keyword
     * @param {?=} field
     * @param {?=} findField
     * @return {?}
     */
    transform(text, keyword, field = '', findField = '') {
        /** @type {?} */
        let needSearch = true;
        if (field && findField) {
            if (findField.indexOf(',') === -1) {
                needSearch = field === findField;
            }
            else {
                needSearch = findField.split(',').some((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n === field));
            }
        }
        if (!needSearch) {
            return text;
        }
        if (keyword && text) {
            /** @type {?} */
            let pattern = keyword.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            pattern = pattern.split(' ').filter((/**
             * @param {?} t
             * @return {?}
             */
            (t) => {
                return t.length > 0;
            })).join('|');
            /** @type {?} */
            const regex = new RegExp(pattern, 'gi');
            return this.sanitizer.bypassSecurityTrustHtml(
            // text.replace(regex, (match) => `<span class="search-highlight">${match}</span>`)
            this.replaceContent(text, regex, (/**
             * @param {?} match
             * @return {?}
             */
            (match) => `<span class="search-highlight">${match}</span>`)));
        }
        else {
            return text;
        }
    }
    /**
     * @param {?} html
     * @param {?} context
     * @return {?}
     */
    parseHTML(html, context) {
        /** @type {?} */
        const t = (context || document).createElement('template');
        t.innerHTML = html;
        return t.content.cloneNode(true);
    }
    /**
     * @private
     * @param {?} strMatch1
     * @param {?} regex
     * @param {?} match
     * @return {?}
     */
    replaceContent(strMatch1, regex, match) {
        /** @type {?} */
        const matchReg1 = />.*?\</gi;
        // 先查出><之间的内容
        /** @type {?} */
        const strs = strMatch1.match(matchReg1);
        if (strs && strs.length) {
            for (const aa of strs) {
                /** @type {?} */
                const rep_old = strs[aa];
                // 拿到原始符合字符串
                /** @type {?} */
                const rep_new = strs[aa].replace(regex, match);
                // 替换成目的字符串
                /** @type {?} */
                const re2 = new RegExp(rep_old, 'g');
                strMatch1 = strMatch1.replace(re2, rep_new); // 将符合的原始字符串替换成新字符串
            }
            return strMatch1;
        }
        else {
            return strMatch1.replace(regex, match);
        }
    }
}
HighlightPipe.decorators = [
    { type: Pipe, args: [{ name: 'highlight' },] }
];
/** @nocollapse */
HighlightPipe.ctorParameters = () => [
    { type: DomSanitizer },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TTHotkeys {
    /**
     * @param {?} eventManager
     */
    constructor(eventManager) {
        this.eventManager = eventManager;
        this.hotkeys = new Map();
        this.defaults = {
            element: document
        };
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addShortcut(options) {
        /** @type {?} */
        const merged = Object.assign({}, this.defaults, options);
        if (merged.keys.indexOf('ctrl') > -1) {
            merged.keys = merged.keys.replace('ctrl', 'control');
        }
        /** @type {?} */
        const event = `keydown.${merged.keys}`;
        if (merged.description) {
            this.hotkeys.set(merged.keys, merged.description);
        }
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            /** @type {?} */
            const handler = (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.preventDefault();
                observer.next(e);
            });
            /** @type {?} */
            const dispose = this.eventManager.addEventListener(merged.element, event, handler);
            return (/**
             * @return {?}
             */
            () => {
                dispose();
                this.hotkeys.delete(merged.keys);
            });
        }));
    }
}
TTHotkeys.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TTHotkeys.ctorParameters = () => [
    { type: EventManager }
];
/** @nocollapse */ TTHotkeys.ngInjectableDef = defineInjectable({ factory: function TTHotkeys_Factory() { return new TTHotkeys(inject(EventManager)); }, token: TTHotkeys, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VirtualizedLoaderService {
    /**
     * @param {?} tt
     */
    constructor(tt) {
        this.tt = tt;
    }
    /**
     * @return {?}
     */
    getTableHeight() {
        return this.tt.height;
    }
    /**
     * @return {?}
     */
    getTableHeaderHeight() {
        return this.tt.headerBox.nativeElement.getBoundingClientRect().height;
    }
    /**
     * @return {?}
     */
    getTableBodyHeight() {
        return this.tt.height - this.getTableHeaderHeight();
    }
    /**
     * @return {?}
     */
    getTableWidth() {
        return this.tt.width;
    }
    /**
     * @return {?}
     */
    getRowHeight() {
        return this.tt.rowHeight;
    }
    /**
     * @param {?} scrollTop
     * @return {?}
     */
    getRowNodes(scrollTop) {
        /** @type {?} */
        let top = 0;
        /** @type {?} */
        const rows = [];
        /** @type {?} */
        let topHideHeight = 0;
        /** @type {?} */
        let bottomHideHeight = 0;
        /** @type {?} */
        const rowNodes = this.tt.getCurrentAllRowNodes();
        // const {rowNodes } = this.tt.state;
        /** @type {?} */
        const rowHeight = this.getRowHeight();
        /** @type {?} */
        const minTop = scrollTop;
        /** @type {?} */
        const maxTop = minTop + this.getTableHeight() + rowHeight;
        for (let i = 0; i < rowNodes.length; i++) {
            /** @type {?} */
            const n = rowNodes[i];
            if (!n.visible) {
                continue;
            }
            top += rowHeight;
            if (top + rowHeight < minTop) {
                topHideHeight += rowHeight;
                continue;
            }
            else {
                if (top > maxTop) {
                    bottomHideHeight += rowHeight;
                    continue;
                }
            }
            rows.push(n);
        }
        return {
            data: rows,
            topHideHeight,
            bottomHideHeight
        };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreetableService {
    constructor() {
        this.selectionSource = new Subject();
        this.dblClickSource = new Subject();
        this.changeCheckboxStatus = new Subject();
        this.removeNode = new Subject();
        this.insertNode = new Subject();
        this.updateNode = new Subject();
        this.selectionSource$ = this.selectionSource.asObservable();
        this.dblClickSource$ = this.dblClickSource.asObservable();
        this.changeCheckboxStatus$ = this.changeCheckboxStatus.asObservable();
        this.insertNode$ = this.insertNode.asObservable();
        this.removeNode$ = this.removeNode.asObservable();
        this.updateNode$ = this.updateNode.asObservable();
    }
    /**
     * @param {?=} selected
     * @return {?}
     */
    onSelectionChange(selected) {
        this.selectionSource.next(selected);
    }
    /**
     * @param {?} rowNode
     * @return {?}
     */
    onDblClick(rowNode) {
        this.dblClickSource.next(rowNode);
    }
    /**
     * @param {?} rowNode
     * @return {?}
     */
    onChangeCheckboxStatus(rowNode) {
        this.changeCheckboxStatus.next(rowNode);
    }
    /**
     * @param {?} treeNode
     * @param {?=} parent
     * @return {?}
     */
    onInsert(treeNode, parent) {
        this.insertNode.next(treeNode);
    }
    /**
     * @param {?} rowNode
     * @return {?}
     */
    onRemove(rowNode) {
        this.removeNode.next(rowNode);
    }
    /**
     * @param {?} rowNode
     * @return {?}
     */
    onUpdate(rowNode) {
        this.updateNode.next(rowNode);
    }
    /**
     * @param {?} col
     * @param {?} tt
     * @return {?}
     */
    columnIsVisible(col, tt) {
        if (col.visible === undefined) {
            return true;
        }
        if (typeof col.visible === 'function') {
            return col.visible(tt);
        }
        return col.visible;
    }
    /**
     * @param {?} columns
     * @param {?} tt
     * @return {?}
     */
    checkColumnsForGroupHeader(columns, tt) {
        /** @type {?} */
        let _columns = [];
        if (columns && columns.length) {
            _columns = this.getDataColumns(columns);
        }
        return {
            columns: _columns
        };
    }
    /**
     * @private
     * @param {?} cols
     * @param {?} length
     * @return {?}
     */
    getDataFields(cols, length) {
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let j = 0;
        cols.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            /** @type {?} */
            const colspan = n.colspan || 1;
            if (i + colspan <= length) {
                i += colspan;
                j++;
            }
        }));
        return cols.splice(0, j);
    }
    /**
     * @private
     * @param {?} cols
     * @return {?}
     */
    getDataColumns(cols) {
        if (!cols || !cols.length) {
            return [];
        }
        /** @type {?} */
        let fields = [];
        for (let i = 0; i < cols.length; i++) {
            /** @type {?} */
            let _cols = cols[i];
            if (cols[i] && !cols[i].length) {
                _cols = [...fields];
                fields = [];
            }
            _cols.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if (!n.field && n.colspan && n.colspan > 1) {
                    if (n['halign']) {
                        n.hAlign = n['halign'];
                    }
                    this.getDataFields(cols[i + 1], n.colspan).forEach((/**
                     * @param {?} d
                     * @return {?}
                     */
                    d => {
                        if (!fields.includes((/**
                         * @param {?} f
                         * @return {?}
                         */
                        f => f.field === d.field))) {
                            fields.push(d);
                        }
                    }));
                }
                else {
                    if (!fields.includes((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => f.field === n.field))) {
                        fields.push(n);
                    }
                }
            }));
        }
        return fields.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => !n.colspan || n.colspan === 1));
    }
}
TreetableService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchHandle {
    /**
     * @param {?} ttInstance
     */
    constructor(ttInstance) {
        this.ttInstance = ttInstance;
        this.allNodes = [];
    }
    // 刷新查询结果
    /**
     * @param {?=} from
     * @return {?}
     */
    research(from = 'client') {
        const { field, value } = this.ttInstance.searchData;
        this.allNodes = [];
        this.search(field, value, from);
    }
    /**
     * @param {?} field
     * @param {?} value
     * @param {?=} from
     * @return {?}
     */
    search(field, value, from = 'client') {
        if (!this.allNodes.length) {
            this.allNodes = cloneDeep(this.ttInstance.state.rowNodes);
        }
        switch (from) {
            case 'server':
                this.searchOnServer(field, value);
                break;
            default:
                if (value !== '' && value !== undefined && value !== null) {
                    /** @type {?} */
                    const values = this.searchOnClient(field, value, this.allNodes);
                    this.ttInstance.state.searchRowNodes = null;
                    this._updateSerializedValues(values);
                }
                else {
                    this.ttInstance.state.searched = false;
                    this.ttInstance.updateSerializedValue();
                }
                this._refreshTree();
                break;
        }
    }
    /**
     * @private
     * @return {?}
     */
    _refreshTree() {
        if (this.ttInstance.checkeds && this.ttInstance.checkeds.length) {
            this.ttInstance.checkedNodes(this.ttInstance.checkeds.map((/**
             * @param {?} n
             * @return {?}
             */
            n => n.data[this.ttInstance.idField])));
            this.ttInstance['updateNodeStatus']();
            this.ttInstance.detectChanges();
        }
        else {
            if (this.ttInstance.serializedValue && this.ttInstance.serializedValue.length) {
                this.ttInstance.resize();
            }
            this.ttInstance.detectChanges();
            if (this.ttInstance.psRef) {
                this.ttInstance.psRef.directiveRef.update();
            }
        }
    }
    /**
     * @private
     * @param {?} visibleItems
     * @return {?}
     */
    _updateSerializedValues(visibleItems) {
        /** @type {?} */
        const pids = ((/** @type {?} */ (visibleItems.map((/**
         * @param {?} n
         * @return {?}
         */
        n => [...n.parents, n.id]))))).flat();
        /** @type {?} */
        const pidArr = Array.from(new Set(pids));
        /** @type {?} */
        const rowNodes = this.allNodes.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => pidArr.some((/**
         * @param {?} item
         * @return {?}
         */
        item => item == n.id)))).map((/**
         * @param {?} r
         * @return {?}
         */
        r => {
            r.expanded = true;
            this.ttInstance.updateNodeProperty(r.id, { expanded: true });
            return r;
        }));
        this.ttInstance.state.searched = true;
        this.ttInstance.serializedValue = this.resetTreeData(null, rowNodes);
        this.ttInstance.state.searchRowNodes = this.ttInstance.serializedValue;
    }
    /**
     * @param {?} item
     * @param {?} allNodes
     * @return {?}
     */
    findParent(item, allNodes) {
        /** @type {?} */
        let res = [];
        if (item && allNodes && allNodes.length) {
            /** @type {?} */
            const p = allNodes.find((/**
             * @param {?} t1
             * @return {?}
             */
            t1 => t1.id === item.data[this.ttInstance.idField]));
            res.push(p);
            if (p.parent) {
                res = res.concat(this.findParent(p.parent, allNodes));
            }
        }
        return res;
    }
    /**
     * @private
     * @param {?} item
     * @param {?} value
     * @param {?=} fields
     * @return {?}
     */
    searchExpression(item, value, fields = []) {
        /** @type {?} */
        const _fields = fields.length ? fields : this.ttInstance.columns.map((/**
         * @param {?} c
         * @return {?}
         */
        c => c.field));
        /** @type {?} */
        const results = _fields.map((/**
         * @param {?} f
         * @return {?}
         */
        f => {
            /** @type {?} */
            const targetValue = this.getValue(f, item.node.data);
            if (targetValue !== null && targetValue !== undefined) {
                if (typeof targetValue === 'number') {
                    return targetValue === parseFloat(value);
                }
                else {
                    return targetValue.toLowerCase().indexOf(value.toLowerCase()) > -1;
                }
            }
            else {
                this.ttInstance.writeConsole(`不存在列 ${f}`);
            }
        }));
        return results.reduce((/**
         * @param {?} flag
         * @param {?} curr
         * @return {?}
         */
        (flag, curr) => {
            return flag || curr;
        }), false);
    }
    /**
     * @private
     * @param {?} field
     * @param {?} data
     * @return {?}
     */
    getValue(field, data) {
        if (field) {
            if (field.indexOf('.') > -1) {
                try {
                    return field.split('.').reduce((/**
                     * @param {?} r
                     * @param {?} f
                     * @return {?}
                     */
                    (r, f) => {
                        if (r) {
                            return r[f];
                        }
                        else {
                            return null;
                        }
                    }), data);
                }
                catch (_a) {
                    this.ttInstance.writeConsole(`字段 ${field} 不存在。`);
                }
            }
            else {
                return data[field];
            }
        }
    }
    /**
     * @param {?} field
     * @param {?} value
     * @param {?} nodes
     * @return {?}
     */
    getFindTextTotal(field, value, nodes) {
        /** @type {?} */
        let t = 0;
        /** @type {?} */
        const getCount = (/**
         * @param {?} fields
         * @return {?}
         */
        (fields) => {
            /** @type {?} */
            let c = 0;
            nodes.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                fields.forEach((/**
                 * @param {?} f
                 * @return {?}
                 */
                f => {
                    /** @type {?} */
                    const targetValue = '' + this.getValue(f, n.node.data);
                    if (targetValue !== undefined) {
                        if (targetValue.indexOf(value) > -1) {
                            c++;
                        }
                    }
                }));
            }));
            return c;
        });
        /** @type {?} */
        let _fields = [field];
        if (field === '*') {
            _fields = this.ttInstance.columns.map((/**
             * @param {?} c
             * @return {?}
             */
            c => c.field));
        }
        else if (field.indexOf(',') > -1) {
            _fields = field.split(',').map((/**
             * @param {?} f
             * @return {?}
             */
            f => f.trim()));
        }
        t = getCount(_fields);
        return t;
    }
    /**
     * @param {?} field
     * @param {?} value
     * @param {?} nodes
     * @return {?}
     */
    searchOnClient(field, value, nodes) {
        /** @type {?} */
        let resultNodes = [];
        if (value === undefined || value === null) {
            return [];
        }
        if (field === '*') {
            resultNodes = nodes.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => this.searchExpression(n, value)));
        }
        else if (field.indexOf(',') > -1) {
            resultNodes = nodes.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => this.searchExpression(n, value, field.split(',').map((/**
             * @param {?} f
             * @return {?}
             */
            f => f.trim())))));
        }
        else {
            value = value.toLowerCase();
            if (field.indexOf('.') === -1) {
                resultNodes = nodes.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => ('' + n.node.data[field]).toLowerCase().indexOf(value) > -1));
            }
            else {
                resultNodes = nodes.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => ('' + this.getValue(field, n.node.data)).toLowerCase().indexOf(value) > -1));
            }
        }
        return resultNodes;
    }
    /**
     * @param {?} conditons
     * @return {?}
     */
    searchWithConditions(conditons) {
        if (!this.allNodes.length) {
            this.allNodes = cloneDeep(this.ttInstance.state.rowNodes);
        }
        /** @type {?} */
        const fields = Object.keys(conditons);
        if (!fields.length) {
            this.ttInstance.state.searched = false;
            this.ttInstance.updateSerializedValue();
        }
        else {
            /** @type {?} */
            const nodes = this.allNodes.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                /** @type {?} */
                const results = fields.map((/**
                 * @param {?} field
                 * @return {?}
                 */
                field => {
                    /** @type {?} */
                    const value = conditons[field];
                    return this.searchExpression(n, value, [field]);
                }));
                // return results.reduce((flag, curr) => {
                //     return flag && curr;
                // }, false);
                return results.every((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n));
            }));
            this.ttInstance.state.searchRowNodes = null;
            this._updateSerializedValues(nodes);
        }
        this._refreshTree();
    }
    /**
     * @param {?} rowNodes
     * @param {?} allNodes
     * @return {?}
     */
    findParents(rowNodes, allNodes) {
        /** @type {?} */
        let res = [];
        rowNodes.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            res = res.concat(this.findParent(item.node, allNodes));
        }));
        return Array.from(new Set(res));
    }
    /**
     * @private
     * @param {?} parentNode
     * @param {?} visibleItems
     * @return {?}
     */
    resetTreeData(parentNode, visibleItems) {
        /** @type {?} */
        let res = [];
        /** @type {?} */
        let arr = [];
        if (parentNode === null) {
            arr = visibleItems.filter((/**
             * @param {?} t2
             * @return {?}
             */
            t2 => t2.parent === parentNode));
        }
        else {
            parentNode.node.expanded = true;
            arr = visibleItems.filter((/**
             * @param {?} t2
             * @return {?}
             */
            t2 => t2.parent && t2.parent.data[this.ttInstance.idField] === parentNode.id));
            if (!arr.length) {
                parentNode.node.children = [];
            }
            else {
                parentNode.node.children = arr.map((/**
                 * @param {?} tn
                 * @return {?}
                 */
                tn => tn.node));
            }
        }
        arr.forEach((/**
         * @param {?} a
         * @return {?}
         */
        a => {
            a.visible = true;
            res.push(a);
            res = res.concat(this.resetTreeData(a, visibleItems));
        }));
        return cloneDeep(res);
    }
    /**
     * @private
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    searchOnServer(field, value) {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NODES_PAGER_COLUMN_FIELD = '__nodespagerbar__';
class TreeTableColumnDirective {
}
TreeTableColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: 'tt-column, [tt-column]'
            },] }
];
TreeTableColumnDirective.propDecorators = {
    field: [{ type: Input }],
    title: [{ type: Input }],
    width: [{ type: Input }],
    hAlign: [{ type: Input }],
    align: [{ type: Input }],
    formatter: [{ type: Input }]
};
class TreeTableComponent {
    /**
     * @param {?} ttService
     * @param {?} el
     * @param {?} resizeSer
     * @param {?} renderer
     * @param {?} utils
     * @param {?} colFormatSer
     * @param {?} shortcuts
     * @param {?} cdRef
     * @param {?} ngZone
     * @param {?} injector
     */
    constructor(ttService, el, resizeSer, renderer, utils, colFormatSer, shortcuts, cdRef, ngZone, injector) {
        this.ttService = ttService;
        this.el = el;
        this.resizeSer = resizeSer;
        this.renderer = renderer;
        this.utils = utils;
        this.colFormatSer = colFormatSer;
        this.shortcuts = shortcuts;
        this.cdRef = cdRef;
        this.ngZone = ngZone;
        this.injector = injector;
        this.id = '';
        /**
         * 宽度
         */
        this.width = 500;
        /**
         * 高度
         */
        this.height = 400;
        this.showFilterBar = false;
        /**
         * 显示过滤行
         */
        this.enableFilterRow = false;
        /**
         * 显示查询字段
         */
        this.showSearchField = true;
        this.headerHeight = 35;
        /**
         * 表头折行
         */
        this.headerWrap = false;
        /**
         * 行高
         */
        this.rowHeight = 29;
        /**
         * 列信息
         */
        this.columns = [];
        this._groupColumns = [];
        /**
         * 启用多表头
         */
        this.useGroupHeader = false;
        this.fitColumns = true;
        this.autoFitColumns = false;
        this.allColumnsTitle = '所有列';
        this.searchAnyField = true;
        /**
         * 显示连接线，默认为 false
         */
        this.showLines = false;
        this.showLinesOnHover = false;
        /**
         * 是否启用多选。 默认为单选
         */
        this.multiSelect = false;
        this.singleSelect = true;
        /**
         * 启用多选后，是否显示checkbox
         */
        this.showCheckbox = false;
        /**
         * 显示边框线
         */
        this.showBorder = true;
        this.showCheckAll = true;
        this.showHeader = true;
        /**
         * 启用斑马线
         */
        this.striped = false;
        /**
         * 启用鼠标划过效果
         */
        this.hovered = true;
        /**
         * 禁用。 禁用时不允许选中行
         */
        this.disabled = false;
        /**
         * 数据加载方式; 默认值 为 all
         * - all: 全部加载
         * - async: 分层加载
         */
        this.loadDataType = 'all';
        /**
         * 固定表头
         */
        this.fixedHeader = false;
        /**
         * 当多选时，选中当前行并钩选
         */
        this.checkOnSelect = false;
        /**
         * 当多选时，钩选并选中当前行
         */
        this.selectOnCheck = false;
        /**
         * 启用多选时，此属性为true 时，仅当前行选中
         */
        this.onlySelectSelf = false;
        /**
         * 启用列宽调整
         */
        this.resizableColumns = true;
        /**
         * 设置为true时自适应父容的尺寸
         */
        this.fit = false;
        /**
         * 启用级联选中功能
         */
        this.cascadeCheck = true;
        /**
         * 向下级联选中
         */
        this.cascadeDown = true;
        /**
         * 向上级联选中
         */
        this.cascadeUp = true;
        /**
         * 空数据时，显示的提示文本
         */
        this.emptyMessage = '暂无数据';
        /**
         * 缩进间距，默认为 16px
         */
        this.indentSpacing = 16;
        /**
         * 单击行选中后，在次点击不会被取消选中状态;
         */
        this.keepSelect = true;
        /**
         * 虚拟加载
         */
        this.virtualized = false;
        /**
         * 仅允许选择叶子节点
         * - default: 应用服务器端传回的设置，如果服务器端没有设置，则与 no 保持一至；
         * - yes: 如果客户端设置为 `yes`, 服务器端的设置失效；
         * - no: 允许选择所有节点；服务器端设置失效
         */
        this.onlySelectLeaf = 'default';
        /**
         * 显示图标
         */
        this.showIcon = false;
        /**
         * 叶子节点图标
         */
        this.leafIcon = 'file';
        /**
         * 节点展开图标
         */
        this.expandIcon = 'folder-open';
        /**
         * 节点折叠图标
         */
        this.collapseIcon = 'folder';
        this.foldIcon = 'treetable-toggler';
        this.unfoldIcon = 'extanded treetable-toggler';
        /**
         * 启用节点图标从数据中获取。 默认为 false
         */
        this.useIconFromData = false;
        /**
         * 当数据源中icon未设置时使用内置ICON. 默认为 true
         */
        this.whenDataIconEmptyUseDefault = true;
        /**
         * 从数据源字段中获取图标
         */
        this.iconField = '';
        /**
         * 启用远端排序
         */
        this.remoteSort = true;
        /**
         * 启用前端文本查找
         */
        this.enableFindText = false;
        // 树列表默认展开层级。 -1： 不展开； 0： 全部展开； >0:  展开到指定级数；
        this.expandLevel = -1;
        this.selectValue = '';
        this.selectValueChange = new EventEmitter();
        /**
         * 启用双击展开节点
         */
        this.dblClickExpand = true;
        this.useDblClick = true;
        /**
         * 选中节点ID数组
         */
        this.selectValues = [];
        this.selectValuesChange = new EventEmitter();
        /**
         * 是否禁止折行，默认不折行
         */
        this.nowrap = true;
        this.checkValues = [];
        this.checkValuesChange = new EventEmitter();
        /**
         * 分页信息
         */
        this.pagination = false;
        /**
         * 分页加载子节点数据
         */
        this.paginationForChildren = false;
        /**
         * 分页条显示模式， default, simple
         */
        this.pagerViewMode = 'default';
        /**
         * 启用服务器端分页
         */
        this.pagerOnServer = true;
        /**
         * 每页记录数
         */
        this.pageList = [10, 20, 30, 50, 100];
        /**
         * 当前页码
         */
        this.pageIndex = 1;
        /**
         * 每页记录数
         */
        this.pageSize = 20;
        /**
         * 分页区高度
         */
        this.pagerHeight = 56;
        /**
         * 显示每页记录数
         */
        this.showPageList = false;
        /**
         * 显示分页信息
         */
        this.showPageInfo = true;
        /**
         * 显示页码
         */
        this.showPageNumber = true;
        /**
         * 显示页码最大数量
         */
        this.pagerLabelSize = 7;
        /**
         * 显示页码输入框
         */
        this.showGotoInput = false;
        /**
         * 子节点分页是否显示总记录数，默认 false
         */
        this.showTotalForChildren = false;
        /**
         * 总记录数
         */
        this.total = 0;
        this.enableContextMenu = false;
        this.contextMenuItems = [];
        this.pageSizeChanged = new EventEmitter();
        this.pageChanged = new EventEmitter();
        /**
         * 排序后
         */
        this.columnSorted = new EventEmitter();
        /**
         * 选中事件
         */
        this.nodeSelected = new EventEmitter();
        /**
         * 取消选中事件
         */
        this.nodeUnSelect = new EventEmitter();
        /**
         * 钩选
         */
        this.nodeChecked = new EventEmitter();
        /**
         * 取消钩选
         */
        this.nodeUnChecked = new EventEmitter();
        /**
         * 全选事件
         */
        this.checkAll = new EventEmitter();
        /**
         * 取消全选
         */
        this.unCheckAll = new EventEmitter();
        /**
         * 查询
         */
        this.search = new EventEmitter();
        this.dblClick = new EventEmitter();
        this.loadedData = new EventEmitter();
        this.expand = new EventEmitter();
        this.collapse = new EventEmitter();
        this.expandAllNodes = new EventEmitter();
        this.collapseAllNodes = new EventEmitter();
        this.appendNew = new EventEmitter();
        this.removed = new EventEmitter();
        this.updated = new EventEmitter();
        this.clearSearchValue = new EventEmitter();
        this.cellClick = new EventEmitter();
        this.childsPageChanged = new EventEmitter();
        this.searchValueChange = new EventEmitter();
        this.loadedTimer = 100;
        this._data = [];
        // loaddata 时 先设置为空数组，
        this.isLoadNewDataSetEmpty = false;
        /**
         * 根据内容自动宽度，默认 false;
         * 此属性开启后，自动列宽失效
         */
        this.autoWidth = false;
        /**
         * 选中项集合
         */
        this._selections = [];
        /**
         * 选中项索引
         */
        this.selectRowIndex = -1;
        /**
         * 选中当前行
         */
        this._selectedRow = null;
        /**
         * 钩选的记录集合
         */
        this._checkeds = [];
        this.searchData = { field: '*', value: '' };
        this.searchButtonText = '<i class="f-icon f-icon-search"></i>';
        /**
         * 显示查询工具条
         */
        this.showFindInput = false;
        this.isDataChanged = false;
        this.topHideHeight = 0;
        this.bottomHideHeight = 0;
        this.state = {
            searchRowNodes: null,
            searched: false,
            rowNodes: [],
            scrollY: 0,
            scrollX: 0
        };
        /**
         * 待查询的文本
         */
        this.findValue = '';
        /**
         * 结果总数
         */
        this.findCount = 0;
        /**
         * 当前索引
         */
        this.findCurrent = 0;
        /**
         * 存储文本查询结果
         */
        this.findResult = [];
        this.ro = null;
        this.findKeysHandler = null;
        this._hotKeys = null;
        this.styleSheetId = 'treetable-style-';
        // 调整模板，此属性仅为帮助中的树组件
        this.fast = false;
        this.paginationOptions = {
            id: 'Farris-TreeTable-Pagination_',
            itemsPerPage: this.pageSize,
            currentPage: this.pageIndex,
            pageList: this.pageList,
            totalItems: this.total,
            remote: this.pagerOnServer
        };
        this.selectNodeChangedSubject = new BehaviorSubject(null);
        this._UUID = '';
        // 是否有固定列
        this.fixedColumns = false;
        this.destroy$ = new Subject();
        this.farrisInstances = null;
        this.difference = (/**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        (first, second) => first.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => !second.some((/**
         * @param {?} secondItem
         * @return {?}
         */
        secondItem => secondItem == item)))));
        this.debugSer = null;
        this.filterRowConditions = null;
        this.onBeforeShowContextMenu = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            // row_1_fixedleft  row_1  row_1_fixedright
            const { contextMenuDom, event } = e;
            /** @type {?} */
            let rowID = event.target.id;
            if (contextMenuDom) {
                rowID = this.trId2DataId(contextMenuDom);
                /** @type {?} */
                const rowNode = this.findRowNode(rowID);
                /** @type {?} */
                let go$ = of({ show: true });
                if (this.beforeShowContextMenu) {
                    go$ = this.beforeShowContextMenu({ data: rowNode, tree: this });
                }
                return go$.pipe(switchMap((/**
                 * @param {?} r
                 * @return {?}
                 */
                (r) => {
                    if (r.show) {
                        if (r.menus) {
                            this.contextMenuItems = r.menus;
                            this.detectChanges();
                        }
                        /** @type {?} */
                        const viewportW = contextMenuDom.closest('.farris-treetable').offsetWidth;
                        /** @type {?} */
                        const targetW = contextMenuDom.offsetWidth;
                        /** @type {?} */
                        const focusTargetWidth = viewportW > targetW ? targetW : viewportW;
                        return of({ show: true, data: { data: rowNode, tree: this }, focusTargetWidth });
                    }
                    else {
                        return of({ show: false });
                    }
                })));
            }
            return of({ show: false });
        });
        this.searchHandle = new SearchHandle(this);
        this.scrollLoader = new VirtualizedLoaderService(this);
        if (this.injector) {
            this._hotKeys = this.injector.get(TTHotkeys, null);
            this.localeService = this.injector.get(LocaleService, null);
            this.idService = this.injector.get(IdService, null);
            this.farrisInstances = this.injector.get(FarrisComponentInstanceService, null);
        }
        if (this.idService) {
            this._UUID = this.idService.uuid();
            this.styleSheetId += this.idService.uuid();
        }
        else {
            this._UUID = ('' + Math.random()).slice(2);
            this.styleSheetId += ('' + Math.random()).slice(2);
        }
        this.ttService = new TreetableService();
        this.debugSer = this.injector.get(DebugService, null);
        if (this.debugSer) {
            this.debugSer.useDebugMode();
        }
    }
    /**
     * @param {?} cols
     * @return {?}
     */
    set groupColumns(cols) {
        this._groupColumns = cols || [];
        /** @type {?} */
        const _columns = this.ttService.checkColumnsForGroupHeader(cols.map((/**
         * @param {?} cs
         * @return {?}
         */
        cs => [...cs])), this).columns;
        this.columns = _columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.field));
    }
    /**
     * @return {?}
     */
    get groupColumns() {
        return this._groupColumns;
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set data(val) {
        this._data = val;
        this.updateSerializedValue();
        if (!this.isLoadNewDataSetEmpty) {
            this.initNodeStatus();
        }
        // autowidth 时，表头宽度依据内容宽度作同步处理
        this.setNewColumnsWidth();
        this.loadDataSuccess();
    }
    /**
     * @param {?} content
     * @return {?}
     */
    set allCheckbox(content) {
        this.headerCheckboxCmp = content;
    }
    /**
     * @return {?}
     */
    get selections() {
        return this._selections;
    }
    /**
     * @param {?} vals
     * @return {?}
     */
    set selections(vals) {
        if (vals && vals.length) {
            // 过滤掉数据源中不存在节点
            this._selections = vals.filter((/**
             * @param {?} tn
             * @return {?}
             */
            tn => tn && this.findRowNode(tn.id)));
            /** @type {?} */
            const ids = this._selections.map((/**
             * @param {?} tn
             * @return {?}
             */
            tn => tn.id));
            if (ids.length !== this.selectValues.length ||
                (ids.length === this.selectValues.length && this.difference(ids, this.selectValues).length)) {
                this.selectValues = ids;
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.selectValuesChange.emit(ids);
                }));
            }
        }
        else {
            this._selections = [];
            this.selectValues = [];
            this.selectValuesChange.emit([]);
        }
    }
    /**
     * @return {?}
     */
    get selectedRow() {
        return this._selectedRow;
    }
    /**
     * @param {?} treeNode
     * @return {?}
     */
    set selectedRow(treeNode) {
        this._selectedRow = treeNode;
        if (treeNode) {
            if (this.selectValue !== treeNode.id) {
                this.selectValue = treeNode.id;
                this.selectValueChange.emit(treeNode.id);
            }
        }
        else {
            this.selectValue = null;
            this.selectValueChange.emit(null);
        }
    }
    /**
     * @return {?}
     */
    get checkeds() {
        return this._checkeds;
    }
    /**
     * @param {?} treeNodes
     * @return {?}
     */
    set checkeds(treeNodes) {
        if (treeNodes && treeNodes.length) {
            this._checkeds = treeNodes.filter((/**
             * @param {?} tn
             * @return {?}
             */
            tn => this.findRowNode(tn.id)));
            /** @type {?} */
            const ids = this._checkeds.map((/**
             * @param {?} tn
             * @return {?}
             */
            tn => tn.id));
            this.checkValues = this.checkValues || [];
            if (ids.length !== this.checkValues.length || (ids.length === this.checkValues.length && this.difference(ids, this.checkValues).length)) {
                this.checkValues = ids;
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.checkValuesChange.emit(ids);
                }));
            }
        }
        else {
            this._checkeds = [];
            this.checkValues = [];
            this.checkValuesChange.emit([]);
        }
    }
    /**
     * @param {?} msg
     * @param {?=} type
     * @return {?}
     */
    writeConsole(msg, type = 'warn') {
        if (this.debugSer) {
            this.debugSer[type](msg);
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkOptons() {
        // 启用数据折行后，虚拟渲染功能失效
        if (!this.nowrap) {
            this.virtualized = false;
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.reSetSize();
            this.setScorllBodyHeight();
        }));
        if (this.multiSelect) {
            this.singleSelect = false;
        }
        if (this.singleSelect && this.showCheckbox) {
            this.checkOnSelect = true;
            this.selectOnCheck = true;
        }
        if (!this.beforeSortColumn) {
            this.beforeSortColumn = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (this.fit) {
            this.renderer.addClass(this.el.nativeElement, 'f-utils-fill-flex-column');
            /** @type {?} */
            const parentEl = this.el.nativeElement.parentElement || this.el.nativeElement.parentNode;
            if (parentEl) {
                // this.renderer.addClass(parentEl, 'f-utils-fill');
                this.renderer.setStyle(parentEl, 'overflow', 'hidden');
            }
        }
        if (!this.beforeClickNode) {
            this.beforeClickNode = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.beforeCheckAll) {
            this.beforeCheckAll = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.beforeUnCheckAll) {
            this.beforeUnCheckAll = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (this.autoWidth) {
            this.fitColumns = false;
            this.resizableColumns = false;
        }
        if (!this.disabledRow) {
            this.disabledRow = (/**
             * @return {?}
             */
            () => false);
        }
        if (!this.searchAnyField && this.searchFields && this.searchFields.length) {
            this.searchData.field = this.searchFields[0].label;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.id = 'Treetable-' + this._UUID;
        // 创建 stylesheet
        this.styleElement = this.utils.createStyleSheet(this.styleSheetId);
        this.checkColumnOption();
        this.checkOptons();
        if (this.ngZone) {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                if (this.el.nativeElement.parentElement) {
                    this.ro = new ResizeObserver((/**
                     * @param {?} entries
                     * @param {?} observer
                     * @return {?}
                     */
                    (entries, observer) => {
                        if (entries && entries[0]) {
                            const { width, height } = entries[0].contentRect;
                            /** @type {?} */
                            const target = entries[0].target;
                            if (this.fit && target['offsetParent']) {
                                this.resize({ width, height: this.showBorder ? height - 2 : height });
                            }
                        }
                        // 表单切换后，如果有选中行，则更新滚动条位置
                        this.scrollToCurrentNode();
                    }));
                    this.ro.observe(this.el.nativeElement.parentElement);
                }
            }));
        }
        this.paginationOptions = this.initPaginationOptions();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.ro) {
            if (this.el.nativeElement.parentElement) {
                this.ro.unobserve(this.el.nativeElement.parentElement);
            }
            this.ro.disconnect();
            this.ro = null;
        }
        if (this.findKeysHandler) {
            this.findKeysHandler.unsubscribe();
        }
        this.utils.removeStyleSheet(this.styleSheetId);
        this.styleElement = null;
        if (this.farrisInstances) {
            this.farrisInstances.destroy(this.el.nativeElement);
        }
        this.ttService = null;
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.data && !changes.data.isFirstChange()) {
            this.isDataChanged = changes.data.currentValue !== changes.data.previousValue;
        }
        if (changes.multiSelect && !changes.multiSelect.isFirstChange()) {
            this.singleSelect = !changes.multiSelect.currentValue;
            if (this.singleSelect && this.showCheckbox) {
                this.selectOnCheck = true;
                this.checkOnSelect = true;
            }
        }
        if (changes.disabled && !changes.disabled.isFirstChange()) {
            this.hovered = !changes.disabled.currentValue;
        }
        if (changes.enableFindText && !changes.enableFindText.isFirstChange()) {
            this.setFindText(changes.enableFindText.currentValue);
        }
        if (changes.selectValue && !changes.selectValue.isFirstChange()) {
            this.selectNode(changes.selectValue.currentValue);
        }
        if (changes.selectValues && !changes.selectValues.isFirstChange()) {
            this.selectNodes(changes.selectValues.currentValue);
        }
        if (changes.checkValues && !changes.checkValues.isFirstChange()) {
            this.checkedNodes(changes.checkValues.currentValue);
        }
        if (changes.pageIndex !== undefined && !changes.pageIndex.isFirstChange()) {
            this.paginationOptions = Object.assign(this.paginationOptions, {
                currentPage: this.pageIndex
            });
        }
        if (changes.pageSize !== undefined && !changes.pageSize.isFirstChange()) {
            this.paginationOptions = Object.assign(this.paginationOptions, {
                itemsPerPage: this.pageSize
            });
        }
        if (changes.pageList !== undefined && !changes.pageList.isFirstChange()) {
            this.paginationOptions = Object.assign(this.paginationOptions, {
                pageList: this.pageList
            });
        }
        if (changes.total !== undefined && !changes.total.isFirstChange()) {
            this.paginationOptions = Object.assign(this.paginationOptions, {
                totalItems: this.total
            });
        }
        if (changes.fitColumns && !changes.fitColumns.isFirstChange()) {
            this.setTableWidth(this.allColumnsWidth());
        }
        if (changes.columns && !changes.columns.isFirstChange()) {
            this.checkColumnOption();
        }
        if (changes.showBorder && !changes.showBorder.isFirstChange()) ;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        // if (this.isDataChanged) {
        //     this.loadedData.emit();
        //     this.isDataChanged = false;
        // } else {
        //     this.ngZone.runOutsideAngular(() => {
        //         if (this.psRef) {
        //             this.psRef.directiveRef.update();
        //         }
        //     });
        // }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templates.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            switch (item.getType()) {
                case 'header':
                    this.headerTemplate = item.template;
                    break;
                case 'body':
                    this.bodyTemplate = item.template;
                    break;
            }
        }));
        if (this.columnsRef.length) {
            this.columns = this.ttc2columns(this.columnsRef);
            this.columnsRef.changes.subscribe((/**
             * @param {?} d
             * @return {?}
             */
            (d) => {
                this.columns = this.ttc2columns(d);
            }));
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.containerElement = this.el.nativeElement.querySelector('.farris-treetable');
        this.registerShortcuts();
        // autowidth 时，表头宽度依据内容宽度作同步处理
        this.setNewColumnsWidth();
        this.setRightFixedColumnShadow();
        if (this.el && this.farrisInstances) {
            this.farrisInstances.add(this.el.nativeElement, this);
        }
        if (this.bodyTemplate) {
            this.utils.appendCssRules([`#${this.id} .farris-treetable .farris-treetable-tbody td {padding: .25rem 0.75rem;}`], this.styleElement.sheet);
        }
        // 兼容旧版设计器        
        if (this.fit && this.el.nativeElement.parentElement.nodeName !== 'DIV') {
            if (this.el.nativeElement.parentElement.nodeName === 'APP-DG-TREE-GRID') {
                /** @type {?} */
                const div = this.el.nativeElement.parentElement.closest('div');
                if (div) {
                    div.style.overflow = 'hidden';
                }
            }
        }
        this.loadDataSuccess();
    }
    /**
     * @private
     * @return {?}
     */
    loadDataSuccess() {
        timer(this.loadedTimer).pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this.psRef && this.psRef.directiveRef) {
                this.psRef.directiveRef.update();
            }
            this.loadedData.emit();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    setNewColumnsWidth() {
        if (!this.autoWidth) {
            return;
        }
        /** @type {?} */
        let headerCells = [];
        /** @type {?} */
        let firstRowCells = [];
        // let colgroups = [];
        if (this.showHeader && this.headerTable) {
            headerCells = Array.from(this.headerTable.nativeElement.querySelectorAll('th'));
        }
        if (this.serializedValue && this.serializedValue.length && this.bodyTable) {
            firstRowCells = Array.from(this.bodyTable.nativeElement.querySelector('tr').querySelectorAll('td'));
            // colgroups = this.bodyTable.nativeElement.querySelector('colgroup').querySelectorAll('col');
        }
        firstRowCells.forEach((/**
         * @param {?} td
         * @param {?} index
         * @return {?}
         */
        (td, index) => {
            /** @type {?} */
            const fieldName = td.getAttribute('field');
            /** @type {?} */
            let colWidth = td.getBoundingClientRect().width.toFixed(2);
            /** @type {?} */
            const col = this.columns.find((/**
             * @param {?} c
             * @return {?}
             */
            c => c.field === fieldName));
            if (col && col.width !== undefined) {
                colWidth = colWidth > col.width ? colWidth : col.width;
            }
            td.style.minWidth = colWidth + 'px';
            headerCells[index].style.width = colWidth + 'px';
        }));
        /** @type {?} */
        const colWidthTotal = this.allColumnsWidth();
        this.setTableWidth(colWidthTotal);
    }
    /**
     * @param {?} col
     * @return {?}
     */
    columnIsVisible(col) {
        return this.ttService.columnIsVisible(col, this);
    }
    /**
     * @private
     * @param {?} n
     * @return {?}
     */
    columnCssName(n) {
        return `#${this.id} .treetable-cell[field="${n.field}"], #${this.id} .treetable-header-cell[field="${n.field}"]:not(.group-header-cell)`;
    }
    /**
     * @private
     * @return {?}
     */
    checkGroupColumns() {
        /** @type {?} */
        var i = this.groupColumns.length - 1;
        while (i >= 0) {
            /** @type {?} */
            var ids = this.groupColumns[i].map((/**
             * @param {?} n
             * @return {?}
             */
            n => n.parentId));
            ids = Array.from(new Set(ids));
            ids.map((/**
             * @param {?} id
             * @return {?}
             */
            id => {
                /** @type {?} */
                const childCols = this.groupColumns[i].filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.parentId == id)).map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    /** @type {?} */
                    const dataField = this.columns.find((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => c.id === n.id));
                    return dataField || n;
                }));
                return {
                    id,
                    width: childCols.reduce((/**
                     * @param {?} r
                     * @param {?} c
                     * @return {?}
                     */
                    (r, c) => { return r += c.width; }), 0),
                    left: childCols[0].left,
                    right: childCols[childCols.length - 1].right || 0
                };
            })).forEach((/**
             * @param {?} p
             * @return {?}
             */
            p => {
                if (i - 1 >= 0) {
                    /** @type {?} */
                    let pCol = this.groupColumns[i - 1].find((/**
                     * @param {?} pc
                     * @return {?}
                     */
                    pc => pc.id == p.id));
                    /** @type {?} */
                    const dataField = this.columns.find((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => c.id === p.id));
                    pCol = dataField || pCol;
                    pCol.width = p.width;
                    if (pCol.fixed === 'left') {
                        pCol.left = p.left;
                    }
                    if (pCol.fixed === 'right') {
                        pCol.right = p.right;
                    }
                }
            }));
            i--;
        }
    }
    // 按固定列的顺序排序
    /**
     * @private
     * @param {?=} updateColumns
     * @return {?}
     */
    sortColumnsByFixed(updateColumns = true) {
        /** @type {?} */
        const fixedLeft = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'left'));
        /** @type {?} */
        const fixedCenter = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => !n.fixed || n.fixed === 'center'));
        /** @type {?} */
        const fixedRight = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'right'));
        if (fixedLeft && fixedLeft.length) {
            fixedLeft.forEach((/**
             * @param {?} n
             * @param {?} index
             * @return {?}
             */
            (n, index) => {
                if (index) {
                    n.left = fixedLeft.reduce((/**
                     * @param {?} r
                     * @param {?} c
                     * @param {?} i
                     * @return {?}
                     */
                    (r, c, i) => {
                        if (i < index) {
                            return r += c.width;
                        }
                        return r;
                    }), 0);
                }
                else {
                    n.left = 0;
                }
            }));
        }
        if (fixedRight && fixedRight.length) {
            /** @type {?} */
            let rightWidthTotal = fixedRight.reduce((/**
             * @param {?} r
             * @param {?} c
             * @return {?}
             */
            (r, c) => {
                return r + c.width;
            }), 0);
            fixedRight.forEach((/**
             * @param {?} n
             * @param {?} index
             * @return {?}
             */
            (n, index) => {
                rightWidthTotal -= n.width;
                n.right = rightWidthTotal;
            }));
        }
        if (updateColumns) {
            this.columns = fixedLeft.concat(fixedCenter).concat(fixedRight);
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkColumnOption() {
        /** @type {?} */
        const cssRules = [];
        // 启用分页加载子节点
        if (this.paginationForChildren) {
            /** @type {?} */
            const pagerBarCol = {
                field: NODES_PAGER_COLUMN_FIELD,
                width: 160,
                title: '',
                align: 'center',
                template: this.nodesPagerBar,
                rowspan: 1,
            };
            if (this.useGroupHeader) {
                if (this.groupColumns[0][this.groupColumns[0].length - 1].fixed === 'right') {
                    pagerBarCol.fixed = 'right';
                }
                pagerBarCol.rowspan = this.groupColumns.length;
                this.groupColumns[0].push(pagerBarCol);
            }
            this.columns.push(pagerBarCol);
        }
        if (!this.fitColumns) {
            this.sortColumnsByFixed();
        }
        this.columns.forEach((/**
         * @param {?} n
         * @param {?} i
         * @return {?}
         */
        (n, i) => {
            if (n.visible === undefined) {
                n.visible = true;
            }
            if (n['halign']) {
                n.hAlign = n['halign'];
            }
            if (n.width === undefined) {
                n.width = 100;
            }
            if (!n.id) {
                n.id = 'treetable-header-' + (n.field || i);
            }
        }));
        /** @type {?} */
        const colWidthTotal = this.allColumnsWidth();
        /** @type {?} */
        let fixedCols = 0;
        /** @type {?} */
        const fixedRightColumns = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'right'));
        if (fixedRightColumns && fixedRightColumns.length) {
            fixedRightColumns[0]['rightShadowCol'] = true;
            fixedRightColumns[fixedRightColumns.length - 1]['lastColumn'] = true;
        }
        else {
            if (this.columns && this.columns.length) {
                this.columns[this.columns.length - 1]['lastColumn'] = true;
            }
        }
        /** @type {?} */
        const fixedLeftColumns = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'left'));
        if (fixedLeftColumns && fixedLeftColumns.length) {
            fixedLeftColumns[fixedLeftColumns.length - 1]['leftShadowCol'] = true;
        }
        fixedCols = this.setCellWidthCss(colWidthTotal, fixedCols, cssRules);
        this.setTableWidth(colWidthTotal);
        this.fixedColumns = !!fixedCols;
    }
    /**
     * @private
     * @param {?} colWidthTotal
     * @param {?} fixedCols
     * @param {?} cssRules
     * @return {?}
     */
    setCellWidthCss(colWidthTotal, fixedCols, cssRules) {
        this.columns.forEach((/**
         * @param {?} n
         * @param {?} index
         * @return {?}
         */
        (n, index) => {
            /** @type {?} */
            const isVisible = this.columnIsVisible(n);
            /** @type {?} */
            const ruleName = this.columnCssName(n);
            /** @type {?} */
            const cssRule = this.utils.getCssRule(ruleName, this.styleElement.sheet);
            if (!cssRule) {
                /** @type {?} */
                let stylecss = ruleName + ' { ';
                stylecss += isVisible ? '' : 'display: none;';
                if (this.fitColumns) {
                    stylecss += `width: ${(n.width / colWidthTotal * 100).toFixed(2)}%;`;
                }
                else {
                    stylecss += `width: ${n.width}px;`;
                    if (n.fixed) {
                        if (n.fixed === 'left') {
                            stylecss += `left: ${n.left}px`;
                            fixedCols++;
                        }
                        if (n.fixed === 'right') {
                            stylecss += `right: ${n.right}px`;
                            fixedCols++;
                        }
                    }
                }
                stylecss += '}';
                cssRules.push(stylecss);
            }
            else {
                cssRule.style.display = isVisible ? '' : 'none';
                if (this.fitColumns) {
                    cssRule.style.width = `${(n.width / colWidthTotal * 100).toFixed(2)}%`;
                }
                else {
                    cssRule.style.width = `${n.width}px`;
                    if (n.fixed) {
                        if (n.fixed === 'left') {
                            cssRule.style.left = `${n.left}px`;
                        }
                        if (n.fixed === 'right') {
                            cssRule.style.right = `${n.right}px`;
                        }
                    }
                }
            }
        }));
        if (this.useGroupHeader) {
            this.autoWidth = false; // 多表头启用后，自动列宽失效 TFS 496088
            this.checkGroupColumns();
            /** @type {?} */
            var i = this.groupColumns.length - 2;
            while (i >= 0) {
                /** @type {?} */
                const groupHeaderColCsses = this.groupColumns[i].filter((/**
                 * @param {?} col
                 * @return {?}
                 */
                col => !col.field)).map((/**
                 * @param {?} col
                 * @return {?}
                 */
                col => {
                    /** @type {?} */
                    let groupColCssName = `#${col.id}{ width: ${col.width}px`;
                    if (col.fixed) {
                        if (col.fixed === 'left') {
                            groupColCssName += ';left:' + col.left + 'px';
                        }
                        if (col.fixed === 'right') {
                            groupColCssName += ';right:' + col.right + 'px';
                        }
                    }
                    return groupColCssName += '}';
                }));
                this.utils.appendCssRules2(groupHeaderColCsses, this.styleElement.sheet);
                i--;
            }
        }
        if (cssRules.length) {
            this.utils.appendCssRules(cssRules, this.styleElement.sheet);
        }
        return fixedCols;
    }
    /**
     * @private
     * @param {?} colWidthTotal
     * @return {?}
     */
    setTableWidth(colWidthTotal) {
        if (this.headerTable && this.bodyTable) {
            if (!this.fitColumns && !this.autoFitColumns) {
                this.headerTable.nativeElement.style.width = `${colWidthTotal}px`;
                this.bodyTable.nativeElement.style.width = `${colWidthTotal}px`;
            }
            else {
                this.headerTable.nativeElement.style.width = '100%';
                this.bodyTable.nativeElement.style.width = '100%';
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    allColumnsWidth() {
        return this.columns.reduce((/**
         * @param {?} r
         * @param {?} c
         * @return {?}
         */
        (r, c) => {
            if (this.columnIsVisible(c)) {
                return r + c.width;
            }
            else {
                return r;
            }
        }), 0);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPageChange($event) {
        this.pageChanged.emit($event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPageSizeChange($event) {
        this.pageSizeChanged.emit($event);
    }
    /**
     * @param {?} pageInfo
     * @return {?}
     */
    updatePageInfo(pageInfo) {
        if (pageInfo && Object.keys(pageInfo).length) {
            /** @type {?} */
            const obj = {};
            if (pageInfo.total !== undefined) {
                obj.totalItems = pageInfo.total;
            }
            if (pageInfo.pageIndex !== undefined) {
                obj.currentPage = pageInfo.pageIndex;
            }
            if (pageInfo.pageSize !== undefined) {
                obj.itemsPerPage = pageInfo.pageSize;
            }
            if (pageInfo.pageList !== undefined) {
                obj.pageList = pageInfo.pageList;
            }
            this.paginationOptions = Object.assign(this.paginationOptions, obj);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initPaginationOptions() {
        return {
            id: 'Farris-TreeTable-Pagination_' + this._UUID,
            itemsPerPage: this.pageSize,
            currentPage: this.pageIndex,
            pageList: this.pageList,
            totalItems: this.total,
            remote: this.pagerOnServer
        };
    }
    /**
     * @param {?} col
     * @param {?} rowdata
     * @param {?=} fast
     * @return {?}
     */
    getNodeText(col, rowdata, fast = false) {
        if (col.isMultilingualField) {
            /** @type {?} */
            const val = this.utils.getValue(col.field, rowdata);
            if (this.localeService) {
                /** @type {?} */
                const localeId = this.localeService.localeId || 'zh-CHS';
                if (val && typeof val === 'object' && Object.keys(val).length > 0) {
                    return val[localeId];
                }
                else {
                    return val;
                }
            }
        }
        else {
            return this.utils.getValue(col.field, rowdata, !fast);
        }
    }
    /**
     * @private
     * @return {?}
     */
    initNodeStatus() {
        if (!this.singleSelect) {
            if (this.checkValues && this.checkValues.length) {
                this.checkedNodes(this.checkValues, false, false);
            }
            if (this.selectValues && this.selectValues.length && !this.onlySelectSelf) {
                this.selectNodes(this.selectValues, false, false);
            }
        }
        else {
            if (this.selectValue) {
                this.selectNode(this.selectValue, false);
            }
        }
    }
    /**
     * 注册快捷键
     * @private
     * @return {?}
     */
    registerShortcuts() {
        if (this.showFilterBar && this._hotKeys) {
            this._hotKeys.addShortcut({ keys: 'enter', element: this.inputGroup.textbox.nativeElement }).subscribe((/**
             * @return {?}
             */
            () => {
                this.onSearch();
            }));
        }
        this.setFindText(this.enableFindText);
    }
    /**
     * @private
     * @param {?=} enable
     * @return {?}
     */
    setFindText(enable = true) {
        this.enableFindText = enable;
        if (this.enableFindText && this._hotKeys) {
            // 查询工具条
            this.findKeysHandler = this._hotKeys.addShortcut({ keys: 'control.shift.f' }).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (this.enableFindText) {
                    this.showFindInput = true;
                    this.detectChanges();
                }
            }));
        }
        else {
            if (this.showFindInput) {
                this.showFindInput = false;
                this.cdRef.detectChanges();
            }
            if (this.findKeysHandler) {
                this.findKeysHandler.unsubscribe();
                this.findKeysHandler = null;
            }
        }
    }
    /**
     * @private
     * @param {?} rowNode
     * @param {?=} field
     * @param {?=} clsType
     * @return {?}
     */
    getCustomCls(rowNode, field = '', clsType = 'row') {
        /** @type {?} */
        const cls = {};
        /** @type {?} */
        let fn = this.rowStyler;
        if (clsType === 'cell') {
            fn = this.cellStyler;
        }
        if (fn) {
            /** @type {?} */
            const rowCls = fn(rowNode.node, field);
            if (rowCls) {
                /** @type {?} */
                let arrcls = [];
                if (typeof rowCls === 'string') {
                    arrcls = [rowCls];
                }
                else {
                    if (Array.isArray(rowCls)) {
                        arrcls = rowCls;
                    }
                }
                if (arrcls.length) {
                    /** @type {?} */
                    const rowClsObj = {};
                    arrcls.forEach((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => {
                        rowClsObj['' + c] = true;
                    }));
                    /** @type {?} */
                    const _cls = Object.assign({}, rowClsObj, cls);
                    return _cls;
                }
                else {
                    return rowCls;
                }
            }
            else {
                return cls;
            }
        }
        else {
            return cls;
        }
    }
    /**
     * @param {?} rowNode
     * @param {?=} field
     * @return {?}
     */
    getRowCls(rowNode, field) {
        return this.getCustomCls(rowNode, 'row');
    }
    /**
     * @param {?} rowNode
     * @param {?} field
     * @return {?}
     */
    getCellCls(rowNode, field) {
        return this.getCustomCls(rowNode, field, 'cell');
    }
    /**
     * @param {?} currentCol
     * @return {?}
     */
    getRealColWidth(currentCol) {
        if (this.columns && this.columns.length && this.fitColumns) {
            /** @type {?} */
            const colWidthTotal = this.columns.reduce((/**
             * @param {?} r
             * @param {?} c
             * @return {?}
             */
            (r, c) => {
                return r + (this.columnIsVisible(c) && (r.field !== NODES_PAGER_COLUMN_FIELD || r.fixedWidth) ? c.width : 0);
            }), 0);
            if (this.columnIsVisible(currentCol)) {
                if (currentCol.field !== NODES_PAGER_COLUMN_FIELD && !currentCol.fixedWidth) {
                    return (currentCol.width / colWidthTotal * 100).toFixed(2) + '%';
                }
                else {
                    return (currentCol.width || 120) + 'px';
                }
            }
            else {
                return 0;
            }
        }
        return currentCol.width + 'px';
    }
    /**
     * @return {?}
     */
    onResized() {
        this.resizeSer.windowResized();
    }
    /**
     * @private
     * @return {?}
     */
    setRightFixedColumnShadow() {
        if (this.psRef && this.psRef.directiveRef) {
            /** @type {?} */
            const ps = ((/** @type {?} */ (this.psRef.directiveRef))).instance;
            if (!ps) {
                return;
            }
            const { containerWidth, scrollbarXLeft, contentWidth } = ps;
            if (containerWidth + scrollbarXLeft < contentWidth) {
                /** @type {?} */
                const fixedRightColumns = this.columns.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.fixed === 'right'));
                /** @type {?} */
                const ruleName = `#${this.id}.f-treetable--fixed-columns`;
                if (fixedRightColumns && fixedRightColumns.length) {
                    /** @type {?} */
                    const fixedRightCssRuleKey = `${ruleName} [r-tt-shadow-col]::before`;
                    /** @type {?} */
                    const rightCSSRule = `${fixedRightCssRuleKey}{
                        box-shadow:#d9d9d9 -12px 0px 8px -12px inset;
                    }`;
                    this.utils.appendCssRules([rightCSSRule], this.styleElement.sheet);
                }
            }
        }
    }
    /**
     * @private
     * @param {?} x
     * @param {?} e
     * @return {?}
     */
    setFixedColumnShadow(x, e) {
        /** @type {?} */
        const fixedLeftColumns = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'left'));
        /** @type {?} */
        const fixedRightColumns = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'right'));
        /** @type {?} */
        const ruleName = `#${this.id}.f-treetable--fixed-columns`;
        /** @type {?} */
        let fixedLeftCssRuleKey = '';
        /** @type {?} */
        let fixedRightCssRuleKey = '';
        /** @type {?} */
        let leftCSSRule = '';
        /** @type {?} */
        let rightCSSRule = '';
        if (fixedLeftColumns && fixedLeftColumns.length) {
            /** @type {?} */
            const lastFixedLeftColumn = fixedLeftColumns[fixedLeftColumns.length - 1];
            fixedLeftCssRuleKey = `${ruleName} [field="${lastFixedLeftColumn.field}"]::after`;
            leftCSSRule = `${fixedLeftCssRuleKey}{
                box-shadow:#d9d9d9 12px 0px 8px -12px inset;
            }`;
        }
        if (fixedRightColumns && fixedRightColumns.length) {
            fixedRightCssRuleKey = `${ruleName} [r-tt-shadow-col]::before`;
            rightCSSRule = `${fixedRightCssRuleKey}{
                box-shadow:#d9d9d9 -12px 0px 8px -12px inset;
            }`;
        }
        if (x === 0) {
            // 移除左侧固定列阴影样式
            if (fixedLeftCssRuleKey) {
                this.utils.removeCssRule(fixedLeftCssRuleKey, this.styleElement.sheet);
            }
        }
        else if ((x + e.srcElement.offsetWidth).toFixed() == e.srcElement.scrollWidth) {
            // 移除右则固定列阴影样式
            if (fixedRightCssRuleKey) {
                this.utils.removeCssRule(fixedRightCssRuleKey, this.styleElement.sheet);
            }
        }
        else {
            // 添加左右固定列样式
            /** @type {?} */
            const arr = [];
            if (leftCSSRule) {
                arr.push(leftCSSRule);
            }
            if (rightCSSRule) {
                arr.push(rightCSSRule);
            }
            this.utils.appendCssRules(arr, this.styleElement.sheet);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onScrollX(e) {
        if (this.showHeader && this.headerBox) {
            /** @type {?} */
            const x = e.srcElement.scrollLeft;
            this.state.scrollX = x;
            // this.renderer.setStyle(this.headerBox.nativeElement.querySelector('table'), 'transform', `translate3d(-${x}px, 0px, 0px)`);
            this.headerBox.nativeElement.scrollLeft = x;
            this.setFixedColumnShadow(x, e);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onScrollY(e) {
        if (this.virtualized) {
            /** @type {?} */
            const scrollTop = e.target.scrollTop;
            this.renderData(scrollTop);
        }
    }
    /**
     * @private
     * @param {?} scrolltop
     * @return {?}
     */
    renderData(scrolltop) {
        const { data, topHideHeight, bottomHideHeight } = this.scrollLoader.getRowNodes(scrolltop);
        this.state.scrollY = scrolltop;
        this.serializedValue = data;
        this.topHideHeight = topHideHeight;
        this.bottomHideHeight = bottomHideHeight;
        this.detectChanges();
        this.setNewColumnsWidth();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onSearchValueChange($event) {
        if (!$event) {
            this.onClearSearchValue();
        }
        this.searchValueChange.emit(this.searchData);
    }
    /**
     * @return {?}
     */
    onClearSearchValue() {
        this.searchData.value = '';
        this.state.searched = false;
        this.clearSearchValue.emit();
    }
    /**
     * @param {?} event
     * @param {?} col
     * @param {?} node
     * @return {?}
     */
    onCellClick(event, col, node) {
        this.cellClick.emit({ event, col, node });
    }
    /**
     * @param {?} index
     * @param {?} rowNode
     * @return {?}
     */
    trackByFn(index, rowNode) {
        return rowNode.id;
    }
    /**
     * 格式化数据
     * @param {?} col
     * @param {?} data
     * @param {?} formatter
     * @return {?}
     */
    formatData(col, data, formatter) {
        // const val = this.utils.getValue(field, data, true );
        /** @type {?} */
        const val = this.getNodeText(col, data);
        if (formatter && formatter.type === 'timeago') {
            if (!formatter.options) {
                formatter.options = { locale: this.localeService.localeId };
            }
            else {
                if (!formatter.options.locale) {
                    formatter.options.locale = this.localeService.localeId;
                }
            }
        }
        return this.colFormatSer.format(val, data, formatter, { locale: this.localeService.localeId });
    }
    /**
     * @return {?}
     */
    columnsChanged() {
        this.checkColumnOption();
        this.detectChanges();
    }
    /**
     * @private
     * @param {?} list
     * @return {?}
     */
    ttc2columns(list) {
        return list.map((/**
         * @param {?} n
         * @return {?}
         */
        (n) => {
            return {
                field: n.field,
                title: n.title,
                align: n.align,
                hAlign: n.hAlign,
                width: n.width,
                formatter: n.formatter
            };
        }));
    }
    /**
     * @private
     * @return {?}
     */
    reSetSize() {
        if (this.fit) {
            /** @type {?} */
            const parentEl = this.el.nativeElement.parentNode;
            this.setWidth(parentEl.offsetWidth);
            this.height = parentEl.offsetHeight;
            // 如果在使用时，为组件设置的高度，则以此值为准，仅支持 固定值 ，不支持 百分比
            if (this.el.nativeElement.style.height) {
                /** @type {?} */
                let h = this.el.nativeElement.style.height;
                if (h.indexOf('px') > -1) {
                    h = parseInt(h.replace('px', ''), 10);
                    if (h > 0) {
                        this.height = h;
                    }
                }
            }
        }
    }
    /**
     * @private
     * @param {?=} nodePosY
     * @return {?}
     */
    renderVirtualRowNodes(nodePosY = null) {
        if (this.virtualized) {
            /** @type {?} */
            const scrollY = nodePosY !== null && nodePosY !== undefined ? nodePosY : this.state.scrollY;
            /** @type {?} */
            const _rownodes = this.scrollLoader.getRowNodes(scrollY);
            this.serializedValue = _rownodes.data;
            this.topHideHeight = _rownodes.topHideHeight;
            this.bottomHideHeight = _rownodes.bottomHideHeight;
            this.detectChanges();
            if (nodePosY !== null && nodePosY !== undefined) {
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this.psRef.directiveRef.elementRef.nativeElement.scrollTop = nodePosY;
                    }), 20);
                }));
            }
        }
    }
    /**
     * @param {?=} nodePosY
     * @return {?}
     */
    updateSerializedValue(nodePosY = null) {
        this.serializedValue = [];
        this.searchHandle.allNodes = [];
        this.state.rowNodes = [];
        this.serializeNodes(null, this.data, 0, true);
        if (this.virtualized && this.fixedHeader) {
            this.renderVirtualRowNodes(nodePosY);
        }
        else {
            this.serializedValue = this.state.rowNodes;
            this.detectChanges();
            // if (emitChanges) {
            // }
        }
    }
    /**
     * 将树节点数据序列化为RowNode
     * @param {?} parent 父级节点
     * @param {?} nodes 树节点集合
     * @param {?} level 级别
     * @param {?} visible 是否可见
     * @param {?=} parentIds
     * @return {?}
     */
    serializeNodes(parent, nodes, level, visible, parentIds) {
        if (nodes && nodes.length) {
            if (!nodes[0].data) {
                return;
            }
            nodes.forEach((/**
             * @param {?} node
             * @param {?} index
             * @return {?}
             */
            (node, index) => {
                node.parent = parent;
                if (!node.hasOwnProperty('selectable')) {
                    node.selectable = true;
                }
                if (!node.hasOwnProperty('showIcon')) {
                    node.showIcon = true;
                }
                if (this.onlySelectLeaf === 'yes' && node.selectable) {
                    node.selectable = !!node.leaf;
                }
                /** @type {?} */
                const keyid = node.data[this.idField];
                node.id = keyid;
                /** @type {?} */
                const isSelected = this.findIndexInSelection(node) > -1;
                /** @type {?} */
                const isChecked = this.findIndexInCheckeds(node) > -1;
                /** @type {?} */
                const isLast = index === nodes.length - 1;
                /** @type {?} */
                const isFirst = index === 0;
                /** @type {?} */
                let parents = [];
                /** @type {?} */
                let parentRn = null;
                if (parent) {
                    /** @type {?} */
                    const parentID = parent.data[this.idField];
                    /** @type {?} */
                    const _parents = parentIds || [];
                    parents = parents.concat(_parents.map((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n)));
                    parents.push(parentID);
                    parentRn = this.state.rowNodes.find((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n.id === parent.id));
                }
                /** @type {?} */
                const rowNode = {
                    id: keyid,
                    node,
                    parent,
                    level,
                    visible: visible && (parent ? parent.expanded : true),
                    isSelected,
                    isChecked,
                    parents,
                    parentRowNode: parentRn,
                    index: this.state.rowNodes.length,
                    last: isLast,
                    first: isFirst
                };
                // this.serializedValue.push(rowNode);
                this.state.rowNodes.push(rowNode);
                this.serializeNodes(node, node.children, level + 1, rowNode.visible, parents);
            }));
        }
    }
    /**
     * 判断指定的节点是否被选中
     * @param {?} node 树节点
     * @return {?}
     */
    isSelected(node) {
        if (this.singleSelect) {
            if (node && this.selectedRow) {
                return node.data[this.idField] === this.selectedRow.data[this.idField];
            }
            return false;
        }
        else {
            if (this.selections && this.selections.length) {
                return this.selections.findIndex((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.data[this.idField] === node.data[this.idField])) > -1;
            }
            return false;
        }
    }
    /**
     * 判断当前节点的钩选状态
     * @param {?} node
     * @return {?}
     */
    isChecked(node) {
        if (node && this.checkeds) {
            if (this.checkeds instanceof Array) {
                return this.checkeds.findIndex((/**
                 * @param {?} v
                 * @return {?}
                 */
                (v) => {
                    return v.data[this.idField] === node.data[this.idField];
                })) > -1;
            }
            return false;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    unSelectedCurrentRowEmit() {
        /** @type {?} */
        const currSelected = this.selectedRow;
        if (currSelected) {
            this.nodeUnSelect.emit({ node: currSelected, type: 'row', instance: this });
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    _singleSelectNode(e) {
        this.clearSelections();
        this.selectedRow = e.rowNode.node;
        this.selectRowIndex = e.rowIndex;
        this.selections = [e.rowNode.node];
        e.rowNode.isSelected = true;
        if (this.showCheckbox) {
            e.rowNode.isChecked = true;
            this.clearCheckeds();
            this.setCheckeds(e.rowNode);
        }
        /** @type {?} */
        const sp = {
            originalEvent: e.originalEvent,
            node: e.rowNode.node, type: 'row',
            index: e.rowIndex,
            parents: e.rowNode.parents,
            instance: this
        };
        this.nodeSelected.emit(sp);
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    _singleUnSelectNode(e) {
        this.selectedRow = null;
        this.selectRowIndex = -1;
        e.rowNode.isSelected = false;
        e.rowNode.isChecked = false;
        this.selections = [];
        this.nodeUnSelect.emit({
            originalEvent: e.originalEvent,
            node: e.rowNode.node, type: 'row', parents: e.rowNode.parents,
            instance: this
        });
    }
    /**
     * @private
     * @param {?} event
     * @param {?=} selected
     * @return {?}
     */
    __singleSelectNode(event, selected = false) {
        if (!selected) {
            this.unSelectedCurrentRowEmit();
            this._singleSelectNode(event);
        }
        else {
            if (!this.keepSelect) {
                this._singleUnSelectNode(event);
            }
        }
    }
    /**
     * @private
     * @param {?} event
     * @param {?} selected
     * @return {?}
     */
    __multiSelectNode(event, selected) {
        /** @type {?} */
        const rowNode = event.rowNode;
        if (selected) {
            this.unSelectedCurrentRowEmit();
            this.singleSelectWhenMultiSelect(rowNode, true);
            this.nodeSelected.emit({
                originalEvent: event.originalEvent, node: rowNode.node,
                type: 'row', index: event.rowIndex, parents: rowNode.parents,
                instance: this
            });
        }
        else {
            if (!this.keepSelect) {
                this.singleSelectWhenMultiSelect(rowNode, false);
                this.nodeUnSelect.emit({
                    originalEvent: event.originalEvent, node: rowNode.node,
                    type: 'row', index: event.rowIndex, parents: rowNode.parents,
                    instance: this
                });
            }
        }
    }
    /**
     * 行单击事件
     * @param {?} event
     * @return {?}
     */
    handleRowClick(event) {
        /** @type {?} */
        const rowNode = event.rowNode;
        rowNode.node['elementRef'] = event.originalEvent.target;
        /** @type {?} */
        const selected = this.isSelected(rowNode.node);
        if (this.singleSelect) {
            this.__singleSelectNode(event, selected);
        }
        else {
            rowNode.indeterminate = false;
            if (this.onlySelectSelf) {
                this.__multiSelectNode(event, !selected);
            }
            else {
                rowNode.isSelected = !selected;
                this.state.rowNodes.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id === rowNode.id)).isSelected = !selected;
                this.setSelections(rowNode);
                /** @type {?} */
                const rowSelectChangeParams = {
                    originalEvent: event.originalEvent, node: rowNode.node,
                    type: 'row', index: event.rowIndex, parents: rowNode.parents,
                    instance: this
                };
                if (rowNode.isSelected) {
                    this.nodeSelected.emit(rowSelectChangeParams);
                }
                else {
                    this.nodeUnSelect.emit(rowSelectChangeParams);
                }
                if (this.checkOnSelect) {
                    rowNode.isChecked = !selected;
                    this.state.rowNodes.find((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n.id === rowNode.id)).isChecked = !selected;
                    this.setCheckeds(rowNode);
                    /** @type {?} */
                    const nodes = this.cascadeNodes(rowNode, rowNode.isChecked);
                    this.ttService.onChangeCheckboxStatus(rowNode);
                    if (rowNode.isChecked) {
                        this.nodeChecked.emit({ originalEvent: event, node: rowNode.node, nodes, instance: this });
                    }
                    else {
                        this.nodeUnChecked.emit({ originalEvent: event, node: rowNode.node, nodes, instance: this });
                    }
                }
            }
            if (this.checkOnSelect) {
                /** @type {?} */
                const ids = this.checkeds.map((/**
                 * @param {?} tn
                 * @return {?}
                 */
                tn => tn.id));
                this.checkValues = ids;
                this.checkValuesChange.emit(ids);
            }
        }
        this.detectChanges();
    }
    /**
     * 带有checkbox 的单选
     * @private
     * @param {?} rowNode 当前节点
     * @param {?} flag
     * @return {?}
     */
    singleSelectWhenMultiSelect(rowNode, flag) {
        if (this.checkOnSelect) {
            rowNode.isChecked = flag;
            this.cascadeNodes(rowNode, rowNode.isChecked);
            this.setCheckeds(rowNode);
            this.ttService.onChangeCheckboxStatus(rowNode);
            if (rowNode.isChecked) {
                this.nodeChecked.emit({ originalEvent: event, node: rowNode.node, instance: this });
            }
            else {
                this.nodeUnChecked.emit({ originalEvent: event, node: rowNode.node, instance: this });
            }
        }
        this.clearSelections();
        if (this.onlySelectSelf) {
            this.selectedRow = rowNode.node;
        }
        rowNode.isSelected = flag;
        this.setSelections(rowNode);
    }
    /**
     * @private
     * @param {?} rowNode
     * @param {?} flag
     * @param {?} event
     * @return {?}
     */
    selectWhenChecked(rowNode, flag, event) {
        if (rowNode.node.selectable) {
            rowNode.isChecked = flag;
        }
        this.setCheckeds(rowNode, false);
        if (this.selectOnCheck) {
            if (this.onlySelectSelf) {
                if (flag || (this.selectedRow && this.selectedRow.id === rowNode.id)) {
                    this.clearSelections();
                }
            }
            if (this.singleSelect && this.showCheckbox) {
                this.clearCheckeds();
            }
            if (rowNode.node.selectable) {
                rowNode.isSelected = flag;
            }
            this.setSelections(rowNode);
            this.state.rowNodes.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n.id === rowNode.id)).isSelected = flag;
            if (rowNode.isSelected) {
                this.nodeSelected.emit({ originalEvent: event, node: rowNode.node, instance: this, type: 'checkbox' });
            }
            else {
                this.nodeUnSelect.emit({ originalEvent: event, node: rowNode.node, instance: this, type: 'checkbox' });
            }
        }
    }
    /**
     * @private
     * @param {?} rowNode
     * @param {?} items
     * @return {?}
     */
    isInArray(rowNode, items) {
        if (items && items.length === 0) {
            return false;
        }
        return items.findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i.data[this.idField] === rowNode.id)) > -1;
    }
    /**
     * @private
     * @param {?} rowNode
     * @return {?}
     */
    setSelections(rowNode) {
        if (rowNode.isSelected) {
            if (!this.selections) {
                this.selections = [];
            }
            if (!this.isInArray(rowNode, this.selections)) {
                // this.selections = [...this.selections, rowNode.node];
                this.selections.push(rowNode.node);
            }
        }
        else {
            if (this.selections) {
                /** @type {?} */
                const i = this.selections.findIndex((/**
                 * @param {?} tn
                 * @return {?}
                 */
                (tn) => tn.data[this.idField] === rowNode.node.data[this.idField]));
                if (i !== -1) {
                    this.selections.splice(i, 1);
                }
                // this.selections = this.selections.filter((tn: TreeNode) => tn.data[this.idField] !== rowNode.node.data[this.idField]);
            }
        }
    }
    /**
     * @private
     * @param {?} rowNode
     * @param {?=} updated
     * @return {?}
     */
    setCheckeds(rowNode, updated = true) {
        if (rowNode.isChecked) {
            if (!this.checkeds) {
                this.checkeds = [];
            }
            if (!this.isInArray(rowNode, this.checkeds)) {
                this.checkeds.push(rowNode.node);
            }
        }
        else {
            if (this.checkeds) {
                /** @type {?} */
                const i = this.checkeds.findIndex((/**
                 * @param {?} tn
                 * @return {?}
                 */
                (tn) => tn.data[this.idField] === rowNode.node.data[this.idField]));
                if (i !== -1) {
                    this.checkeds.splice(i, 1);
                }
            }
        }
        if (updated) {
            this.checkeds = [...this.checkeds];
        }
    }
    /**
     * @private
     * @param {?} data
     * @return {?}
     */
    getDiffrentData(data) {
        if (data.length) {
            /** @type {?} */
            const _nodes = [];
            data.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if (_nodes.findIndex((/**
                 * @param {?} t
                 * @return {?}
                 */
                t => t.data[this.idField] === n.data[this.idField])) === -1) {
                    _nodes.push(n);
                }
            }));
            return _nodes;
        }
        return data;
    }
    /**
     * @private
     * @param {?} rowNode
     * @param {?} checked
     * @param {?=} sync
     * @return {?}
     */
    cascadeCheckedNode(rowNode, checked, sync = false) {
        /** @type {?} */
        const nodes = [];
        if (rowNode.node.selectable) {
            rowNode.isChecked = checked;
        }
        this.setCheckeds(rowNode, false);
        if (this.selectOnCheck) {
            if (sync) {
                /** @type {?} */
                const status = this.isIndeterminate(rowNode) !== 2;
                checked = status ? checked : false;
            }
            if (rowNode.node.selectable) {
                rowNode.isSelected = checked;
                this.setSelections(rowNode);
            }
        }
        if (!this.isInArray(rowNode, nodes)) {
            nodes.push(rowNode.node);
        }
        return nodes;
    }
    /**
     * 向下级联选中
     * @param {?} rowNode
     * @param {?} checked 选中状态
     * 返回受影响的行
     * @return {?}
     */
    propagateSelectionDown(rowNode, checked) {
        /** @type {?} */
        let nodes = this.cascadeCheckedNode(rowNode, checked);
        if (this.cascadeCheck && this.cascadeDown && rowNode.node.children && rowNode.node.children.length) {
            rowNode.node.children.forEach((/**
             * @param {?} v
             * @param {?} i
             * @return {?}
             */
            (v, i) => {
                /** @type {?} */
                const rn = this.state.rowNodes.find((/**
                 * @param {?} row
                 * @return {?}
                 */
                (row) => row.id === v.data[this.idField]));
                if (rn) {
                    rn.indeterminate = false;
                    if (rn.node.selectable) {
                        rn.isChecked = checked;
                    }
                    nodes = nodes.concat(this.propagateSelectionDown(rn, checked));
                    this.ttService.onChangeCheckboxStatus(rn);
                }
            }));
        }
        return nodes;
    }
    /**
     * 向上级联选中
     * @param {?} rowNode
     * @param {?} checked
     * @return {?}
     */
    propagateSelectionUp(rowNode, checked) {
        /** @type {?} */
        const nodes = this.cascadeCheckedNode(rowNode, checked);
        if (this.cascadeCheck && this.cascadeUp && rowNode.node.parent) {
            if (rowNode.parents && rowNode.parents.length) {
                /** @type {?} */
                const rns = [];
                rowNode.parents.forEach((/**
                 * @param {?} n
                 * @param {?} i
                 * @return {?}
                 */
                (n, i) => {
                    /** @type {?} */
                    const rn = this.findRowNode(n);
                    if (rn && rn.node.selectable) {
                        // rn.isChecked = checked;
                        /** @type {?} */
                        const checkedNodes = this.cascadeCheckedNode(rn, checked, true);
                        if (checkedNodes.length) {
                            nodes.push(checkedNodes[0]);
                        }
                        rns.push(rn);
                    }
                }));
                rns.reverse().forEach((/**
                 * @param {?} rn
                 * @return {?}
                 */
                rn => {
                    this.updateCheckboxStatus(rn);
                }));
            }
        }
        return nodes;
    }
    // 节点状态（选中，勾选）同步更新
    /**
     * @private
     * @return {?}
     */
    updateNodeStatus() {
        if (this.state.searched) {
            /** @type {?} */
            const rowNodes = this.state.searchRowNodes;
            if (!rowNodes) {
                return;
            }
            rowNodes.forEach((/**
             * @param {?} rn
             * @return {?}
             */
            rn => {
                /** @type {?} */
                const checkedItem = this.state.rowNodes.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id === rn.id));
                /** @type {?} */
                const chked = checkedItem ? checkedItem.isChecked : false;
                rn.indeterminate = false;
                rn.isChecked = chked;
                if (this.selectOnCheck) {
                    if (checkedItem.isSelected != rn.isChecked) {
                        checkedItem.isSelected = checkedItem.isChecked;
                    }
                    rn.isSelected = checkedItem.isSelected;
                }
            }));
        }
        else {
            if (this.selectOnCheck) {
                this.state.rowNodes.forEach((/**
                 * @param {?} rn
                 * @return {?}
                 */
                rn => {
                    if (this.onlySelectSelf) {
                        if (!this.selections || !this.selections.length) {
                            rn.isSelected = false;
                        }
                        else {
                            if (this.selections[0].id === rn.id) {
                                rn.isSelected = true;
                            }
                            else {
                                rn.isSelected = false;
                            }
                        }
                    }
                    else {
                        if (rn.isSelected != rn.isChecked) {
                            rn.isSelected = rn.isChecked;
                        }
                    }
                }));
            }
        }
    }
    /**
     * 级联选择节点
     * @private
     * @param {?} rowNode 当前节点
     * @param {?} checked 是否钩选
     * @return {?}
     */
    cascadeNodes(rowNode, checked) {
        /** @type {?} */
        let checkedNodes = this.propagateSelectionDown(rowNode, checked);
        checkedNodes = checkedNodes.concat(this.propagateSelectionUp(rowNode, checked));
        checkedNodes = this.getDiffrentData(checkedNodes);
        this.updateNodeStatus();
        this.updateAllCheckboxStatus();
        return checkedNodes.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            return n.selectable;
        }));
    }
    /**
     * 行Checkbox 选中变化事件
     * @param {?} event 鼠标点击事件对象
     * @param {?} rowNode 当前树节点
     * @param {?} checked
     * @return {?}
     */
    toggleNodeWithCheckbox(event, rowNode, checked) {
        this.state.rowNodes.find((/**
         * @param {?} n
         * @return {?}
         */
        n => n.id === rowNode.id)).isChecked = checked;
        rowNode.indeterminate = false;
        /** @type {?} */
        const data = this.cascadeNodes(rowNode, checked);
        this.ttService.onChangeCheckboxStatus(rowNode);
        if (checked) {
            this.nodeChecked.emit({ originalEvent: event, node: rowNode.node, nodes: data, instance: this });
        }
        else {
            this.nodeUnChecked.emit({ originalEvent: event, node: rowNode.node, nodes: data, instance: this });
        }
        this.selectWhenChecked(rowNode, checked, event);
        if (this.onlySelectSelf && checked) {
            this.selectedRow = rowNode.node;
        }
        this.checkeds = [...this.checkeds];
        this.detectChanges();
        event.stopPropagation();
    }
    /**
     * 全选
     * @param {?} event 鼠标事件对象
     * @param {?} checked 是否选中
     * @return {?}
     */
    toggleNodesWithCheckbox(event, checked) {
        if (checked) {
            if (this.data && this.data.length) {
                this.checkAllNodes({ originalEvent: event, checked, instance: this });
            }
        }
        else {
            this.selections = null;
            this.unCheckAllNodes({ originalEvent: event, checked, instance: this });
        }
        this.detectChanges();
    }
    /**
     * 更新全选checkbox 的状态
     * @private
     * @return {?}
     */
    updateAllCheckboxStatus() {
        if (this['checkall_CLICKED']) {
            return;
        }
        /** @type {?} */
        const status = this.isIndeterminate();
        if (this.showCheckAll && !this.singleSelect && this.showCheckbox) {
            if (status !== undefined) {
                if (this.headerCheckboxCmp) {
                    this.headerCheckboxCmp.chkAll.nativeElement.indeterminate = status === 2;
                    this.headerCheckboxCmp.checked = status === 1;
                }
            }
        }
    }
    /**
     * 更新父节点checkbox 选中状态
     * @private
     * @param {?} rowNode
     * @return {?}
     */
    updateParentCheckboxStatus(rowNode) {
        /** @type {?} */
        const pNodes = [];
        rowNode.parents.forEach((/**
         * @param {?} rnid
         * @return {?}
         */
        rnid => {
            /** @type {?} */
            const rn = this.findRowNode(rnid);
            if (rn) {
                pNodes.push(rn);
            }
        }));
        pNodes.reverse().forEach((/**
         * @param {?} rn
         * @return {?}
         */
        rn => {
            this.updateCheckboxStatus(rn);
        }));
    }
    /**
     * 更新N个父节点复选框中的选中状态
     * @private
     * @param {?} parentIds
     * @return {?}
     */
    updateParentsCheckStatus(parentIds) {
        /** @type {?} */
        let pids = [];
        parentIds.forEach((/**
         * @param {?} ids
         * @return {?}
         */
        (ids) => {
            pids = [...pids, ...ids];
        }));
        pids = Array.from(new Set(pids));
        /** @type {?} */
        const pRowNodes = this.findRowNodes(pids);
        pRowNodes.sort((/**
         * @param {?} r
         * @param {?} n
         * @return {?}
         */
        (r, n) => {
            return n.level - r.level;
        })).forEach((/**
         * @param {?} rn
         * @return {?}
         */
        rn => {
            this.updateCheckboxStatus(rn);
        }));
    }
    /**
     * 更新节点中checkbox的状态
     * @private
     * @param {?} rowNode
     * @return {?}
     */
    updateCheckboxStatus(rowNode) {
        /** @type {?} */
        const status = this.isIndeterminate(rowNode);
        if (status !== undefined && rowNode.node.selectable) {
            rowNode.indeterminate = status === 2;
            this.ttService.onChangeCheckboxStatus(rowNode);
        }
    }
    /**
     * 判断指定节点checkbox 的状态
     * 0：全不选， 1： 全部选中， 2：有选中的也有没选中的
     * @private
     * @param {?=} rowNode
     * @return {?}
     */
    isIndeterminate(rowNode) {
        /** @type {?} */
        const status = this.getCheckboxStatus(rowNode);
        if (status !== undefined) {
            /** @type {?} */
            let checked = false;
            if (status === 2) {
                checked = false;
            }
            else {
                checked = !!status;
            }
            if (rowNode && rowNode.node.selectable) {
                rowNode.isChecked = checked;
                this.setCheckeds(rowNode, false);
            }
        }
        return status;
    }
    /**
     * 返回父级节点checkbox 的状态。0：不选中， 1： 选中， 2：不确定
     * @private
     * @param {?=} rowNode 父级节点；为空时返回全选checkbox 的状态
     * @return {?}
     */
    getCheckboxStatus(rowNode) {
        /** @type {?} */
        let uncheckedLength = 0;
        /** @type {?} */
        let checkedLength = 0;
        /** @type {?} */
        let len = 0;
        /** @type {?} */
        let childNodes = [];
        if (rowNode) {
            childNodes = rowNode.node.children || [];
            if (!childNodes.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.selectable)).length) {
                return rowNode.isChecked;
            }
        }
        else {
            childNodes = this.state.rowNodes;
        }
        len = childNodes.length;
        childNodes.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            /** @type {?} */
            let rn = n;
            if (rowNode) {
                rn = this.findRowNode(n.data[this.idField]);
            }
            if (rn && !rn.indeterminate) {
                if (rn.isChecked) {
                    checkedLength++;
                }
                else {
                    uncheckedLength++;
                }
            }
        }));
        if (len === 0) {
            return undefined;
        }
        /** @type {?} */
        let flag = 0;
        if (uncheckedLength === len) {
            flag = 0;
        }
        else {
            if (checkedLength === len) {
                flag = 1;
            }
            else {
                flag = 2;
            }
        }
        return flag;
    }
    /**
     * @private
     * @param {?} node
     * @param {?} treeNodes
     * @return {?}
     */
    findIndexIn(node, treeNodes) {
        /** @type {?} */
        let index = -1;
        if (treeNodes && treeNodes.length) {
            index = treeNodes.findIndex((/**
             * @param {?} v
             * @param {?} i
             * @return {?}
             */
            (v, i) => {
                return this.equals(v, node);
            }));
        }
        return index;
    }
    /**
     * 在选中的集合中查找指定节点的索引
     * @param {?} node 树节点
     * @return {?}
     */
    findIndexInCheckeds(node) {
        return this.findIndexIn(node, this.checkeds);
    }
    /**
     * 在选中的集合中查找指定节点的索引
     * @param {?} node 树节点
     * @return {?}
     */
    findIndexInSelection(node) {
        return this.findIndexIn(node, this.selections);
    }
    /**
     * 对比两个节点是否同一个节点
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    equals(target, source) {
        return target.data[this.idField] === source.data[this.idField];
    }
    /**
     * 展开所有节点
     * @param {?=} treeNode
     * @param {?=} deep 设置为true 时，当前节点下的所有子节点全部展开, 默认 false
     * @param {?=} childrenEmptyEmitExpand  当没有子节点是否触发展开事件，默认为 true
     * @return {?}
     */
    toggleExpand(treeNode, deep = false, childrenEmptyEmitExpand = true) {
        if (treeNode) {
            treeNode.expanded = !treeNode.expanded;
            this.updateNodeProperty(treeNode.id, { expanded: treeNode.expanded });
            this.toggleVisible(treeNode);
            if (this.virtualized) {
                if (treeNode.children && treeNode.children.length) {
                    this.renderVirtualRowNodes();
                }
            }
            if (treeNode.expanded) {
                if (childrenEmptyEmitExpand || (treeNode.children && treeNode.children.length)) {
                    this.expand.emit(treeNode);
                }
                else {
                    treeNode.expanded = !treeNode.expanded;
                    return;
                }
            }
            else {
                this.collapse.emit(treeNode);
            }
            if (deep) {
                if (treeNode.children && treeNode.children.length) {
                    treeNode.children.forEach((/**
                     * @param {?} row
                     * @param {?} i
                     * @return {?}
                     */
                    (row, i) => {
                        this.toggleExpand(row, deep, childrenEmptyEmitExpand);
                    }));
                }
            }
        }
        else {
            if (this.data && this.data.length) {
                this.data.forEach((/**
                 * @param {?} row
                 * @return {?}
                 */
                (row) => {
                    this.toggleExpand(row);
                }));
            }
        }
        this.setNewColumnsWidth();
    }
    /**
     * @private
     * @param {?} treeNode
     * @return {?}
     */
    toggleVisible(treeNode) {
        /** @type {?} */
        const rowNode = this.findRowNode(treeNode.id);
        if (rowNode) {
            /** @type {?} */
            const rid = rowNode.id;
            /** @type {?} */
            const setRowVisible = (/**
             * @param {?} rn
             * @param {?} visible
             * @return {?}
             */
            (rn, visible) => {
                /** @type {?} */
                const pid = rn.parent.data[this.idField];
                /** @type {?} */
                const rnParent = this.findRowNode(pid);
                if (rnParent) {
                    rn.visible = rnParent.visible && rnParent.node.expanded;
                }
                else {
                    rn.visible = visible;
                }
                /** @type {?} */
                const _r = this.serializedValue.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id === rn.id));
                if (_r) {
                    _r.visible = rn.visible;
                }
            });
            this.state.rowNodes.filter((/**
             * @param {?} rn
             * @return {?}
             */
            rn => rn.parents.indexOf(rid) > -1)).forEach((/**
             * @param {?} rn
             * @return {?}
             */
            rn => {
                setRowVisible(rn, treeNode.expanded);
            }));
            // #392512 
            /** @type {?} */
            const rowNodes = this.getCurrentAllRowNodes();
            if (rowNodes) {
                rowNodes.filter((/**
                 * @param {?} rn
                 * @return {?}
                 */
                rn => rn.parents.indexOf(rid) > -1)).forEach((/**
                 * @param {?} rn
                 * @return {?}
                 */
                rn => {
                    setRowVisible(rn, treeNode.expanded);
                }));
            }
        }
    }
    /**
     * 展开指定节点
     * emit: 触发展开事件
     * render: 数据重新加载
     * @param {?} id
     * @param {?=} emit
     * @param {?=} render
     * @return {?}
     */
    expandNode(id, emit = true, render = true) {
        if (id) {
            /** @type {?} */
            const rowNode = this.findRowNode(id);
            if (rowNode) {
                rowNode.node.expanded = true;
                this.toggleVisible(rowNode.node);
                if (render) {
                    if (this.virtualized) {
                        if (rowNode.node.children && rowNode.node.children.length) {
                            this.renderVirtualRowNodes();
                        }
                    }
                    else {
                        this.detectChanges();
                    }
                }
                if (emit) {
                    this.expand.emit(rowNode.node);
                }
                this.setNewColumnsWidth();
            }
            else {
                this.writeConsole('Con\'t find tree node widh id:' + id, 'error');
            }
        }
    }
    /**
     * 展开所有节点
     * @return {?}
     */
    expandAll() {
        this.state.rowNodes = this.state.rowNodes.map((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            row.node.expanded = true;
            row.visible = true;
            return row;
        }));
        if (this.virtualized) {
            this.renderVirtualRowNodes();
        }
        else {
            this.serializedValue = this.state.rowNodes;
        }
        this.setNewColumnsWidth();
        this.expandAllNodes.emit();
        this.detectChanges();
    }
    /**
     * @param {?} id
     * @return {?}
     */
    expandNodes(id) {
        // const rowNode = this.findRowNode(id);
        // const rootNode = this.getRoot(id);
        // if (rowNode) {
        //     const treeNode = rowNode.node;
        //     treeNode.expanded = true;
        //     rowNode.visible = true;
        //     const parents = rowNode.parents;
        //     this.state.rowNodes.filter(n => n.parents.indexOf(rootNode.id) > -1).forEach(r => {
        //         if (parents.indexOf(r.id) > -1) {
        //             r.visible = true;
        //             r.node.expanded = true;
        //         }
        //     });
        //     this.detectChanges();
        // }
    }
    /**
     * 展开指定节点下的所有节点
     * @param {?} rowNode
     * @return {?}
     */
    expandAllNodesBy(rowNode) {
        if (rowNode) {
            /** @type {?} */
            const treeNode = rowNode.node;
            treeNode.expanded = true;
            rowNode.visible = true;
            this.state.rowNodes.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.parents.indexOf(rowNode.id) > -1)).forEach((/**
             * @param {?} r
             * @return {?}
             */
            r => {
                r.visible = true;
                r.node.expanded = true;
            }));
            this.detectChanges();
            this.setNewColumnsWidth();
        }
    }
    /**
     * 折叠指定节点
     * @param {?} id
     * @return {?}
     */
    collapseNode(id) {
        if (id) {
            /** @type {?} */
            const rowNode = this.findRowNode(id);
            if (rowNode) {
                rowNode.node.expanded = false;
                this.toggleVisible(rowNode.node);
                this.detectChanges();
                this.setNewColumnsWidth();
                this.collapse.emit(rowNode.node);
            }
            else {
                this.writeConsole('Con\'t find tree node widh id:' + id, 'error');
            }
        }
    }
    /**
     * 折叠所有节点
     * @return {?}
     */
    collapseAll() {
        this.state.rowNodes = this.state.rowNodes.map((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            row.node.expanded = false;
            row.visible = !row.parent;
            return row;
        }));
        if (this.virtualized) {
            this.renderVirtualRowNodes(0);
        }
        else {
            this.serializedValue = this.state.rowNodes;
        }
        this.collapseAllNodes.emit();
        this.detectChanges();
        this.setNewColumnsWidth();
    }
    /**
     * @return {?}
     */
    getContainerOffset() {
        /** @type {?} */
        const rect = this.containerElement.getBoundingClientRect();
        return {
            left: rect.left + document.body.scrollLeft,
            top: rect.top + document.body.scrollTop
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onColumnResizeBegin(event) {
        /** @type {?} */
        const containerLeft = Math.round(this.getContainerOffset().left);
        this.lastResizerHelperX = (event.pageX - containerLeft + this.containerElement.scrollLeft);
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onColumnResize(event) {
        if (this.resizableColumns) {
            /** @type {?} */
            const containerLeft = this.getContainerOffset().left;
            this.renderer.addClass(this.containerElement, 'ui-unselectable-text');
            this.resizerHelperVC.nativeElement.style.height = this.containerElement.offsetHeight + 'px';
            this.resizerHelperVC.nativeElement.style.top = 0 + 'px';
            this.resizerHelperVC.nativeElement.style.left = (event.pageX - containerLeft) + 'px';
            this.resizerHelperVC.nativeElement.style.display = 'block';
        }
    }
    /**
     * @param {?} event
     * @param {?} column
     * @return {?}
     */
    onColumnResizeEnd(event, column) {
        if (!this.resizerHelperVC.nativeElement.offsetLeft) {
            return;
        }
        // 偏移量
        /** @type {?} */
        const delta = this.resizerHelperVC.nativeElement.offsetLeft - this.lastResizerHelperX;
        // 列宽
        /** @type {?} */
        const columnWidth = column.offsetWidth;
        // 新宽度
        /** @type {?} */
        const newColumnWidth = columnWidth + delta;
        // 最小宽度
        /** @type {?} */
        const minWidth = column.style.minWidth || 15;
        /** @type {?} */
        let resizeColumnIndex = -1;
        if (column.id) {
            resizeColumnIndex = this.columns.findIndex((/**
             * @param {?} n
             * @return {?}
             */
            n => n.id === column.id));
        }
        else {
            /** @type {?} */
            const colField = column.getAttribute('field');
            if (colField) {
                resizeColumnIndex = this.columns.findIndex((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.field === colField));
            }
        }
        if (!this.fitColumns) {
            this.resizeColGroup(this.headerTable.nativeElement, resizeColumnIndex, newColumnWidth, 0);
            this.resizeColGroup(this.bodyTable.nativeElement, resizeColumnIndex, newColumnWidth, 0);
            if (this.columns[resizeColumnIndex]) {
                this.columns[resizeColumnIndex].width = newColumnWidth;
            }
            this.sortColumnsByFixed(false);
            this.setCellWidthCss(this.allColumnsWidth(), 0, []);
            // this.setTableWidth(this.allColumnsWidth());
            // // update css.
            // const _colInfo = this.columns[resizeColumnIndex];
            // if (_colInfo) {
            //     const ruleName = this.columnCssName(_colInfo);
            //     const stylecss = ruleName + '{width:' + newColumnWidth + 'px}';
            //     this.utils.appendCssRules([stylecss], this.styleElement.sheet);
            // }
            // const nextColumn = this.columns[resizeColumnIndex + 1];
            // if (nextColumn && nextColumn.fixed) {
            //     const ruleName = this.columnCssName(nextColumn);
            //     const stylecss = ruleName + '{' + nextColumn.fixed + ':' + nextColumn[nextColumn.fixed] + 'px}';
            //     this.utils.appendCssRules([stylecss], this.styleElement.sheet);
            // }
        }
        else {
            if (newColumnWidth > minWidth) {
                /** @type {?} */
                let nextColumn = column.nextElementSibling;
                while (!nextColumn.offsetParent) {
                    nextColumn = nextColumn.nextElementSibling;
                }
                if (nextColumn) {
                    /** @type {?} */
                    const nextColumnWidth = nextColumn.offsetWidth - delta;
                    /** @type {?} */
                    const nextColumnMinWidth = nextColumn.style.minWidth || 15;
                    if (newColumnWidth > 15 && nextColumnWidth > nextColumnMinWidth) {
                        this.resizeColGroup(this.headerTable.nativeElement, resizeColumnIndex, newColumnWidth, nextColumnWidth);
                        this.resizeColGroup(this.bodyTable.nativeElement, resizeColumnIndex, newColumnWidth, nextColumnWidth);
                    }
                }
            }
        }
        this.resizerHelperVC.nativeElement.style.display = 'none';
        this.renderer.removeClass(this.containerElement, 'ui-unselectable-text');
        this.psRef.directiveRef.update();
    }
    /**
     * @param {?} table
     * @param {?} resizeColumnIndex
     * @param {?} newColumnWidth
     * @param {?=} nextColumnWidth
     * @return {?}
     */
    resizeColGroup(table, resizeColumnIndex, newColumnWidth, nextColumnWidth) {
        if (table) {
            /** @type {?} */
            const colGroup = table.children[0].nodeName === 'COLGROUP' ? table.children[0] : null;
            if (colGroup) {
                /** @type {?} */
                const col = colGroup.children[resizeColumnIndex];
                /** @type {?} */
                const nextCol = col.nextElementSibling;
                col.style.width = newColumnWidth + 'px';
                if (nextCol) {
                    if (nextColumnWidth && this.fitColumns) {
                        nextCol.style.width = nextColumnWidth + 'px';
                    }
                }
            }
            else {
                throw new Error('Scrollable tables require a colgroup to support resizable columns');
            }
        }
    }
    /**
     * @return {?}
     */
    onSearch() {
        this.state.searchRowNodes = null;
        this.state.searched = !!this.searchData.value;
        if (this.searchData.value) {
            this.searchData.value = this.searchData.value.trim();
        }
        this.search.emit(this.searchData);
    }
    /**
     * @param {?} node
     * @param {?=} parent
     * @return {?}
     */
    insert(node, parent) {
        if (parent) {
            if (!parent.children) {
                parent.children = [];
            }
            parent.children.push(node);
            this.expandNode(parent.data[this.idField]);
            this.appendNew.emit({ parent });
        }
        else {
            this.data.push(node);
        }
        this.updateSerializedValue();
    }
    /**
     * @param {?} data
     * @param {?=} parent
     * @return {?}
     */
    append(data, parent) {
        if (data && data[this.idField]) {
            this.insert({ data, id: data[this.idField] }, parent);
        }
        else {
            this.writeConsole('Please set id value.', 'warn');
        }
    }
    /**
     * @private
     * @param {?} parent
     * @return {?}
     */
    emitAppendNew(parent) {
        if (this.virtualized) {
            /** @type {?} */
            const nodePosY = this.psRef.directiveRef.elementRef.nativeElement.scrollTop;
            this.updateSerializedValue(nodePosY);
        }
        else {
            this.updateSerializedValue();
        }
    }
    /**
     * @param {?} nodes
     * @param {?} parent
     * @param {?=} emit
     * @return {?}
     */
    appendChildren(nodes, parent, emit = true) {
        if (nodes && nodes.length) {
            if (parent) {
                parent.children.push(...nodes);
                this.emitAppendNew(parent);
                if (emit) {
                    this.appendNew.emit({ parent });
                }
            }
            else {
                throw new Error('未找到父级节点');
            }
        }
        else {
            this.updateSerializedValue();
            this.writeConsole('添加子节点的数据为空', 'warn');
        }
    }
    /**
     * @param {?} nodes
     * @param {?} parent
     * @param {?=} emit
     * @return {?}
     */
    loadChildren(nodes, parent, emit = true) {
        if (parent) {
            parent.children = nodes || [];
            this.emitAppendNew(parent);
            if (emit) {
                this.appendNew.emit({ parent });
            }
        }
    }
    /**
     * @param {?} nodeId
     * @return {?}
     */
    remove(nodeId) {
        if (nodeId) {
            /** @type {?} */
            const rowNode = this.findRowNode(nodeId);
            if (rowNode) {
                // remove(this.state.rowNodes, (n) => {
                //     return n.id === nodeId;
                // });
                if (this.selectValue === nodeId) {
                    this.selectedRow = null;
                    this.selectValue = null;
                }
                if (rowNode.parent) {
                    remove(rowNode.parent.children, (/**
                     * @param {?} n
                     * @return {?}
                     */
                    (n) => {
                        return n.data[this.idField] === nodeId;
                    }));
                }
                else {
                    remove(this.state.rowNodes, (/**
                     * @param {?} n
                     * @return {?}
                     */
                    (n) => {
                        return n.id === nodeId;
                    }));
                    this.data = this.data.filter((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n.data[this.idField] !== nodeId));
                }
                this.updateSerializedValue();
                this.detectChanges();
                this.ttService.onRemove(rowNode);
                this.removed.emit(rowNode);
            }
        }
    }
    /**
     * @param {?} nodeId
     * @param {?} data
     * @return {?}
     */
    update(nodeId, data) {
        if (nodeId && data) {
            /** @type {?} */
            const rowNode = this.findRowNode(nodeId);
            if (rowNode) {
                rowNode.node.data = extend(rowNode.node.data, data);
                this.detectChanges();
                this.ttService.onUpdate(rowNode);
                this.updated.emit(rowNode);
            }
        }
    }
    /**
     * @param {?} nodeid
     * @param {?} property
     * @return {?}
     */
    updateNodeProperty(nodeid, property) {
        /** @type {?} */
        const rowNode = this.findRowNode(nodeid);
        if (rowNode && property) {
            Object.keys(property).forEach((/**
             * @param {?} k
             * @return {?}
             */
            k => {
                rowNode.node[k] = property[k];
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    setScorllBodyHeight() {
        this.scorllBodyHeight = this.height;
        if (this.showFilterBar) {
            this.scorllBodyHeight = this.scorllBodyHeight - 46;
        }
        if (this.enableFilterRow) {
            this.scorllBodyHeight = this.scorllBodyHeight - 36;
        }
        if (this.fixedHeader && this.showHeader) {
            if (this.headerBox && (this.headerWrap || this.useGroupHeader)) {
                /** @type {?} */
                const hh = this.headerBox.nativeElement.clientHeight;
                this.scorllBodyHeight = this.scorllBodyHeight - hh;
            }
            else {
                // 宽松版时，表头高度增高，需要按实际取得表头高度
                /** @type {?} */
                let _headerHeight = this.headerHeight;
                /** @type {?} */
                const themesKey = localStorage.getItem('gsp_rtf_themSKey');
                if (themesKey === 'loose' && this.headerBox) {
                    _headerHeight = this.headerBox.nativeElement.getBoundingClientRect().height;
                }
                this.scorllBodyHeight = this.scorllBodyHeight - _headerHeight;
            }
        }
        if (this.pagination) {
            this.scorllBodyHeight = this.scorllBodyHeight - this.pagerHeight;
        }
        this.detectChanges();
    }
    /**
     * @private
     * @param {?} w
     * @return {?}
     */
    setWidth(w) {
        this.width = w;
    }
    /**
     * @param {?=} size
     * @return {?}
     */
    resize(size) {
        if (size) {
            /** @type {?} */
            const w = parseInt('' + size.width, 10);
            /** @type {?} */
            const h = parseInt('' + size.height, 10);
            if (this.width === w && this.height === h) {
                if (this.state.scrollY) {
                    this.psRef.directiveRef.scrollToY(this.state.scrollY);
                }
                if (this.state.scrollX) {
                    this.psRef.directiveRef.scrollToX(this.state.scrollX);
                }
                return;
            }
            this.setWidth(w);
            this.height = h;
        }
        this.setScorllBodyHeight();
        if (this.data && this.data.length) {
            this.renderVirtualRowNodes();
        }
        // setTimeout(() => {
        //     if (this.psRef) {
        //         this.psRef.directiveRef.update();
        //     }
        // }, 100);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    loadData(data) {
        if (this.showLines) {
            this.isLoadNewDataSetEmpty = true;
            this.data = [];
            this.isLoadNewDataSetEmpty = false;
        }
        this.data = data;
    }
    /**
     * @return {?}
     */
    empty() {
        this.data = [];
    }
    /**
     * @return {?}
     */
    getCurrentAllRowNodes() {
        if (this.state.searched && this.state.searchRowNodes && this.state.searchRowNodes.length) {
            return this.state.searchRowNodes || this.state.rowNodes;
        }
        else {
            return this.state.rowNodes;
        }
    }
    /**
     * @param {?=} detectChanges
     * @return {?}
     */
    clearAll(detectChanges = true) {
        this.state.rowNodes.filter((/**
         * @param {?} rn
         * @return {?}
         */
        rn => rn.indeterminate)).forEach((/**
         * @param {?} rn
         * @return {?}
         */
        rn => {
            rn.indeterminate = false;
            this.ttService.onChangeCheckboxStatus(rn);
        }));
        this.state.rowNodes = this.state.rowNodes.map((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            row.isChecked = false;
            row.isSelected = false;
            row.indeterminate = false;
            return row;
        }));
        // if (this.searchData && this.searchData.value) {
        if (this.state.searched && this.state.searchRowNodes && this.state.searchRowNodes.length) {
            this.serializedValue = this.state.searchRowNodes.map((/**
             * @param {?} row
             * @return {?}
             */
            (row) => {
                row.isChecked = false;
                row.isSelected = false;
                row.indeterminate = false;
                return row;
            }));
        }
        this.checkeds = [];
        this.selections = [];
        this.selectedRow = undefined;
        if (this.showCheckAll && this.headerCheckboxCmp) {
            this.headerCheckboxCmp.chkAll.nativeElement.indeterminate = false;
            this.headerCheckboxCmp.checked = false;
        }
        if (detectChanges) {
            this.detectChanges();
        }
        return this;
    }
    /**
     * @return {?}
     */
    detectChanges() {
        this.cdRef.markForCheck();
        // tslint:disable-next-line:no-string-literal
        if (!this.cdRef['destroyed']) {
            this.cdRef.detectChanges();
        }
        return this;
    }
    /**
     * @return {?}
     */
    clearCheckeds() {
        if (this.checkeds && this.checkeds.length) {
            this.findRowNodes(this.checkeds.map((/**
             * @param {?} tn
             * @return {?}
             */
            tn => tn.data[this.idField]))).forEach((/**
             * @param {?} rn
             * @return {?}
             */
            rn => {
                rn.isChecked = false;
            }));
        }
        this.checkeds = [];
        if (this.showCheckAll && this.headerCheckboxCmp) {
            this.headerCheckboxCmp.chkAll.nativeElement.indeterminate = false;
            this.headerCheckboxCmp.checked = false;
        }
        return this;
    }
    /**
     * @return {?}
     */
    clearSelections() {
        if (this.serializedValue && this.serializedValue.length) {
            this.serializedValue.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                n.isSelected = false;
            }));
        }
        this.state.rowNodes.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            n.isSelected = false;
        }));
        if (this.selections && this.selections.length) {
            /** @type {?} */
            const nodeIds = this.selections.map((/**
             * @param {?} tn
             * @return {?}
             */
            tn => tn.data[this.idField]));
            this.findRowNodes(nodeIds).forEach((/**
             * @param {?} rn
             * @return {?}
             */
            rn => {
                rn.isSelected = false;
                if (this.singleSelect) {
                    rn.isChecked = false;
                }
            }));
        }
        this.selections = undefined;
        this.selectedRow = undefined;
        return this;
    }
    /**
     * 选中第1个可以选中的节点
     * @return {?}
     */
    selectFirstNode() {
        if (this.state.rowNodes && this.state.rowNodes.length) {
            /** @type {?} */
            const firstCanSelectNode = this.state.rowNodes.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n.node.selectable));
            if (firstCanSelectNode) {
                this.selectNode(firstCanSelectNode.id);
            }
        }
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    scrollToCurrentRow(id) {
        /** @type {?} */
        const trId = 'rownode-' + id;
        // const trEle =    document.getElementById(trId);
        /** @type {?} */
        const trEle = this.el.nativeElement.querySelector('#' + trId) || document.getElementById(trId);
        if (trEle && trEle.closest('.farris-treetable') && trEle.closest('.farris-treetable').id === this.id) {
            if (!this.isElementInViewport(trEle)) {
                if (trEle.scrollIntoViewIfNeeded) {
                    trEle.scrollIntoViewIfNeeded();
                    return true;
                }
                /** @type {?} */
                const browserInfo = this.utils.getBrowserType();
                if (browserInfo.ff && this.utils.getFFVer() < 58) {
                    trEle.scrollIntoView();
                }
                else {
                    trEle.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                }
            }
            else {
                trEle.scrollIntoView({ block: 'nearest' });
            }
            return true;
        }
        return false;
    }
    /**
     * @private
     * @param {?} el
     * @return {?}
     */
    isElementInViewport(el) {
        /** @type {?} */
        const containerEl = this.el.nativeElement.querySelector('.farris-treetable-body');
        if (!containerEl) {
            return false;
        }
        /** @type {?} */
        const container = containerEl.getBoundingClientRect();
        /** @type {?} */
        const viewPortHeight = container.height;
        /** @type {?} */
        const offsetTop = el.offsetTop + this.topHideHeight;
        /** @type {?} */
        const scrollTop = this.psRef.directiveRef.elementRef.nativeElement.scrollTop;
        /** @type {?} */
        const top = offsetTop - scrollTop;
        return top >= 0 && top <= viewPortHeight;
    }
    /**
     * @private
     * @param {?} nodeId
     * @return {?}
     */
    _scrollToNode(nodeId) {
        this.scrollToCurrentNode(nodeId);
    }
    /**
     * @param {?=} nodeid
     * @return {?}
     */
    scrollToCurrentNode(nodeid = '') {
        /** @type {?} */
        let id = nodeid;
        if (!nodeid && this.selectedRow) {
            id = this.selectedRow.id;
        }
        if (id == null || id == undefined || id == '') {
            return;
        }
        /** @type {?} */
        const result = this.scrollToCurrentRow(id);
        if (!result) {
            /** @type {?} */
            const rowNode = this.findRowNode(id);
            /** @type {?} */
            const showRowsOnePager = Math.ceil(this.scorllBodyHeight / this.rowHeight) + 1;
            if (rowNode.parents && rowNode.parents.length) {
                rowNode.parents.forEach((/**
                 * @param {?} pid
                 * @return {?}
                 */
                pid => {
                    this.expandNode(pid, false, false);
                }));
            }
            /** @type {?} */
            const rowIndex = this.state.rowNodes.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.visible)).findIndex((/**
             * @param {?} n
             * @return {?}
             */
            n => n.id === id));
            if (rowIndex < showRowsOnePager) {
                if (this.virtualized) {
                    this.renderData(0);
                }
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.scrollToCurrentRow(id);
                }));
                return;
            }
            /** @type {?} */
            const top = rowIndex * this.rowHeight;
            if (this.virtualized) {
                this.renderData(top - this.rowHeight);
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.scrollToCurrentRow(id);
                    if (this.psRef && this.psRef.directiveRef) {
                        this.psRef.directiveRef.elementRef.nativeElement.scrollTop += 1;
                    }
                }), 50);
            }
            else {
                this.scrollToY(top - this.rowHeight);
                this.scrollToCurrentRow(id);
            }
        }
    }
    /**
     * 选中指定ID 的节点,
     * detectChanges: 触发脏值检查，默认为 true
     * gotocurrent: 使用选中节点可见，默认为 true
     * @param {?} id
     * @param {?=} detectChanges
     * @param {?=} gotocurrent
     * @return {?}
     */
    selectNode(id, detectChanges = true, gotocurrent = true) {
        if (!id) {
            return this;
        }
        /** @type {?} */
        let node = this.findRowNode(id);
        /** @type {?} */
        const canSelect = node && node.node && node.node.selectable;
        /** @type {?} */
        const emit = canSelect && (!this.selectedRow || (this.selectedRow && id !== this.selectedRow.id));
        if (node && emit) {
            node.isSelected = true;
            if (this.singleSelect || this.onlySelectSelf) {
                this.clearSelections();
                node.isSelected = true;
                this.selections = [node.node];
                if (this.checkOnSelect && this.showCheckbox) {
                    node.isChecked = true;
                    if (this.multiSelect) {
                        this.setCheckeds(node);
                    }
                    else {
                        this.clearCheckeds();
                        this.checkeds = [node.node];
                    }
                    if (this.cascadeCheck && this.cascadeUp) {
                        this.updateParentCheckboxStatus(node);
                    }
                }
            }
            else {
                this.setSelections(node);
            }
            this.selectedRow = node.node;
            this.selectNodeChangedSubject.next(id);
            this.nodeSelected.emit({ node: node.node, instance: this });
            if (this.serializedValue.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n.id == this.selectedRow.id))) {
                this.serializedValue.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id == this.selectedRow.id)).isSelected = true;
            }
            if (gotocurrent && this.fixedHeader) {
                this.scrollToCurrentNode();
            }
            if (detectChanges) {
                this.detectChanges();
            }
        }
        else {
            if (!node) {
                this.selectedRow = null;
                this.writeConsole(`未找到ID为 ${id} 的数据！！`);
            }
        }
        return this;
    }
    /**
     * 取消选中
     * @param {?} id
     * @param {?=} detectChanges
     * @return {?}
     */
    unSelectNode(id, detectChanges = true) {
        /** @type {?} */
        const rowNode = this.findRowNode(id);
        if (rowNode) {
            rowNode.isSelected = false;
            if (this.singleSelect) {
                this.clearSelections();
                this.selectedRow = null;
                rowNode.isChecked = false;
                this.selections = [];
            }
            else {
                if (this.onlySelectSelf) {
                    this.selections = [];
                }
                else {
                    this.setSelections(rowNode);
                }
            }
            if (detectChanges) {
                this.detectChanges();
            }
            this.nodeUnSelect.emit({ node: rowNode.node, instance: this });
        }
        else {
            this.writeConsole(`未找到ID为${id}的数据！！`);
        }
    }
    /**
     * 选中多行数据
     * @param {?} ids
     * @param {?=} detectChanges
     * @param {?=} emitNodeSelected
     * @return {?}
     */
    selectNodes(ids, detectChanges = true, emitNodeSelected = false) {
        if (ids && ids.length) {
            /** @type {?} */
            const nodes = this.findRowNodes(ids).map((/**
             * @param {?} rn
             * @return {?}
             */
            rn => {
                rn.isSelected = true;
                this.setSelections(rn);
                return rn.node;
            }));
            this.selections = [...this.selections];
            if (detectChanges) {
                this.detectChanges();
            }
            this.selectNodeChangedSubject.next(ids.join(','));
            if (emitNodeSelected) {
                this.nodeSelected.emit({ node: nodes, instance: this });
            }
        }
        return this;
    }
    /**
     * 取消选中
     * @param {?=} ids
     * @param {?=} emit
     * @return {?}
     */
    unSelectNodes(ids, emit = true) {
        if (ids && ids.length) {
            /** @type {?} */
            const rownodes = this.findRowNodes(ids);
            if (rownodes && rownodes.length) {
                rownodes.forEach((/**
                 * @param {?} rn
                 * @return {?}
                 */
                rn => {
                    rn.isSelected = false;
                    this.setSelections(rn);
                }));
                this.selections = [...this.selections];
                this.detectChanges();
                if (emit) {
                    this.nodeUnSelect.emit({ node: rownodes.map((/**
                         * @param {?} r
                         * @return {?}
                         */
                        r => r.node)), instance: this });
                }
            }
        }
        else {
            this.clearSelections();
            this.detectChanges();
        }
    }
    /**
     * 钩选指定的节点
     * @param {?} id
     * @param {?=} updateParentCheckboxStatus
     * @param {?=} detectChanges 触发变更检测。默认为 true
     * @return {?}
     */
    checkedNode(id, updateParentCheckboxStatus = true, detectChanges = true) {
        if (this.isEnableMultiSelect()) {
            /** @type {?} */
            const node = this.findRowNode(id);
            if (node) {
                node.isChecked = true;
                if (!this.isChecked(node.node)) {
                    this.setCheckeds(node, false);
                    if (updateParentCheckboxStatus && this.cascadeCheck && this.cascadeUp) {
                        this.updateParentCheckboxStatus(node);
                    }
                }
                if (detectChanges) {
                    this.detectChanges();
                }
                this.nodeChecked.emit({ originalEvent: null, node: node.node, instance: this });
            }
            else {
                this.writeConsole(`未找到ID为${id}的数据！！`);
            }
        }
    }
    /**
     * @param {?} id
     * @param {?=} updateParentCheckboxStatus
     * @return {?}
     */
    unCheckedNode(id, updateParentCheckboxStatus = true) {
        if (this.isEnableMultiSelect()) {
            /** @type {?} */
            const rownode = this.findRowNode(id);
            if (rownode) {
                rownode.isChecked = false;
                this.setCheckeds(rownode);
                if (this.selectOnCheck) {
                    rownode.isSelected = false;
                    this.setSelections(rownode);
                }
                if (this.selectedRow && this.selectedRow.id === id) {
                    this.selectedRow = null;
                }
                if (this.singleSelect || !this.cascadeCheck) {
                    this.updateNodeStatus();
                    if (updateParentCheckboxStatus && this.cascadeCheck && this.cascadeUp) {
                        this.updateParentCheckboxStatus(rownode);
                    }
                    if (this.checkValues) {
                        this.checkValues = this.checkValues.filter((/**
                         * @param {?} n
                         * @return {?}
                         */
                        n => n !== id));
                        this.checkValuesChange.emit(this.checkValues);
                    }
                    this.detectChanges();
                    this.nodeUnChecked.emit({ node: rownode, instance: this });
                }
                else {
                    /** @type {?} */
                    const unNodes = this.cascadeNodes(rownode, false);
                    this.checkeds = [...this.checkeds];
                    this.checkValuesChange.emit(this.checkValues);
                    this.detectChanges();
                    this.nodeUnChecked.emit({ node: rownode, nodes: unNodes, instance: this });
                }
            }
            else {
                this.writeConsole(`未找到ID为${id}的数据！！`);
            }
        }
    }
    /**
     * @private
     * @param {?} ids
     * @param {?} checked
     * @return {?}
     */
    _checkedNodes(ids, checked) {
        /** @type {?} */
        const parentIDS = [];
        /** @type {?} */
        const nodes = this.findRowNodes(ids).map((/**
         * @param {?} rn
         * @return {?}
         */
        rn => {
            parentIDS.push(rn.parents);
            if (rn.node.selectable) {
                rn.isChecked = checked;
                this.setCheckeds(rn, false);
            }
            return rn.node;
        }));
        this.checkeds = [...this.checkeds];
        if (this.cascadeCheck && this.cascadeUp) {
            // 更新父节点复框的选中状态
            this.updateParentsCheckStatus(parentIDS);
        }
        return nodes;
    }
    /**
     * 批量选中节点
     * @param {?} ids
     * @param {?=} detectChanges
     * @param {?=} emit
     * @param {?=} closeCascade
     * @return {?}
     */
    checkedNodes(ids, detectChanges = true, emit = true, closeCascade) {
        if (this.isEnableMultiSelect()) {
            if (ids && ids.length) {
                /** @type {?} */
                const _cascade = this.cascadeCheck;
                if (closeCascade && _cascade) {
                    this.cascadeCheck = false;
                }
                /** @type {?} */
                const nodes = this._checkedNodes(ids, true);
                if (closeCascade && _cascade) {
                    // 恢复级联
                    this.cascadeCheck = true;
                }
                this.updateAllCheckboxStatus();
                if (detectChanges) {
                    this.detectChanges();
                }
                if (emit) {
                    this.nodeChecked.emit({ originalEvent: null, node: nodes, nodes, instance: this });
                }
            }
        }
    }
    /**
     * 取消选中的节点.
     * ids: 标识Id 数组
     * closeCascade: 执行取消钩选时是否关闭级联功能。默认为 false
     *     设为true时，钩选将禁用级联的功能，仅处理当前节点的选中状态。执行完毕后，恢复原先的级联选项。
     * emit: 是否触发取消勾选事件。默认为 true
     * @param {?} ids
     * @param {?=} closeCascade
     * @param {?=} emit
     * @return {?}
     */
    unCheckedNodes(ids, closeCascade, emit = true) {
        if (ids && ids.length) {
            /** @type {?} */
            const _cascade = this.cascadeCheck;
            if (closeCascade && _cascade) {
                this.cascadeCheck = false;
            }
            /** @type {?} */
            const nodes = this._checkedNodes(ids, false);
            if (closeCascade && _cascade) {
                this.cascadeCheck = true;
            }
            this.detectChanges();
            if (emit) {
                this.nodeUnChecked.emit({ originalEvent: null, node: nodes, nodes, instance: this });
            }
        }
        else {
            this.clearCheckeds();
            this.detectChanges();
        }
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    unCheckedAndSelected(ids) {
        this.unCheckedNodes(ids, true, false);
        this.unSelectNodes(ids, false);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    findRowNode(id) {
        if (id) {
            if (this.state.rowNodes) {
                return this.state.rowNodes.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id === id));
            }
        }
        return undefined;
    }
    /**
     * 将在 v0.2.x 废弃；请使用 findRowNode 方法
     * @param {?} id
     * @return {?}
     */
    findNode(id) {
        return this.findRowNode(id);
    }
    /**
     * 根据当前节点ID，获取顶级父节点
     * @param {?} id 当前节点ID
     * @return {?} 返回顶级节点
     */
    getRoot(id) {
        /** @type {?} */
        const rowNode = this.findRowNode(id);
        if (rowNode) {
            if (rowNode.parents && rowNode.parents.length) {
                return this.findRowNode(rowNode.parents[0]);
            }
            return rowNode;
        }
        return null;
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    findRowNodes(ids) {
        return this.state.rowNodes.filter((/**
         * @param {?} rn
         * @return {?}
         */
        rn => ids.indexOf(rn.id) > -1));
    }
    /**
     * @param {?=} args
     * @return {?}
     */
    checkAllNodes(args) {
        /** @type {?} */
        let rowNodes = this.getCurrentAllRowNodes();
        rowNodes = rowNodes.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => (n.node.selectable || n.node.selectable === undefined)));
        this.checkeds = rowNodes.map((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            n.indeterminate = false;
            this.ttService.onChangeCheckboxStatus(n);
            if (n.node.selectable || n.node.selectable === undefined) {
                n.isChecked = true;
            }
            return n.node;
        }));
        if (this.selectOnCheck && !this.onlySelectSelf) {
            this.selections = rowNodes.map((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if (n.node.selectable || n.node.selectable === undefined) {
                    n.isSelected = true;
                }
                return n.node;
            }));
        }
        if (this.state.searched) {
            rowNodes.forEach((/**
             * @param {?} rn
             * @return {?}
             */
            rn => {
                /** @type {?} */
                const row = this.state.rowNodes.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id === rn.id));
                if (row) {
                    row.isSelected = rn.isSelected;
                    row.isChecked = rn.isChecked;
                }
            }));
        }
        this.checkAll.emit(args);
        this.updateAllCheckboxStatus();
        this.detectChanges();
    }
    /**
     * @param {?=} args
     * @return {?}
     */
    unCheckAllNodes(args) {
        this.clearAll();
        this.unCheckAll.emit(args);
        this.detectChanges();
    }
    /**
     * @private
     * @return {?}
     */
    isEnableMultiSelect() {
        if (this.singleSelect) {
            if (!this.showCheckbox) {
                return false;
            }
            return true;
        }
        return true;
    }
    // 从数据中获取节点图标
    // iconField 为 object
    //      如果 展开图标为空，折叠图标不为空，或反之，则展开与折叠图标保持一至；
    //      如果 叶子图标为空，则使用组件默认的图标
    // iconField 为 字符串： 则叶子 展开 折叠 图标使用同一个。 如果为空， 则使用组件默认图标
    /**
     * @private
     * @param {?} tn
     * @return {?}
     */
    getNodeIconFromData(tn) {
        /** @type {?} */
        let leaf = null;
        /** @type {?} */
        let expand = null;
        /** @type {?} */
        let collapse = null;
        if (this.useIconFromData) {
            if (this.iconField) {
                /** @type {?} */
                let _iconField = '';
                if (typeof this.iconField === 'string') {
                    _iconField = this.iconField;
                    if (tn[_iconField]) {
                        leaf = tn[_iconField];
                    }
                    else {
                        leaf = this.utils.getValue(_iconField, tn.data);
                    }
                    expand = collapse = leaf;
                }
                else {
                    if (this.iconField.leaf) {
                        leaf = this.utils.getValue(this.iconField.leaf, tn.data);
                    }
                    if (this.iconField.expand) {
                        expand = this.utils.getValue(this.iconField.expand, tn.data);
                    }
                    if (this.iconField.collapse) {
                        collapse = this.utils.getValue(this.iconField.collapse, tn.data);
                    }
                    if (expand && !collapse) {
                        collapse = expand;
                    }
                    if (!expand && collapse) {
                        expand = collapse;
                    }
                }
            }
        }
        return {
            leaf, expand, collapse
        };
    }
    /**
     * @param {?} treeNode
     * @return {?}
     */
    getTreeIcon(treeNode) {
        /** @type {?} */
        const tn = treeNode;
        /** @type {?} */
        let leafIcon = this.leafIcon || 'file';
        /** @type {?} */
        let expandIcon = this.expandIcon || 'folder-open';
        /** @type {?} */
        let collapseIcon = this.collapseIcon || 'folder';
        /** @type {?} */
        const loading = 'f-loading-round';
        if (tn['showLoading']) {
            return { [loading]: true };
        }
        if (tn.icon) {
            leafIcon = tn.icon;
        }
        if (tn.expandedIcon) {
            expandIcon = tn.expandedIcon;
        }
        if (tn.collapsedIcon) {
            collapseIcon = tn.collapsedIcon;
        }
        if (this.useIconFromData) {
            const { leaf, expand, collapse } = this.getNodeIconFromData(treeNode);
            if (this.whenDataIconEmptyUseDefault) {
                if (leaf) {
                    leafIcon = leaf;
                }
                if (expand) {
                    expandIcon = expand;
                }
                if (collapse) {
                    collapseIcon = collapse;
                }
            }
            else {
                leafIcon = leaf || '';
                expandIcon = expand || '';
                collapseIcon = collapse || '';
            }
        }
        /** @type {?} */
        const collapsedExpression = (!tn.leaf || !!(tn.children && tn.children.length)) && !tn.expanded;
        /** @type {?} */
        const expandedExpression = !!tn.expanded;
        /** @type {?} */
        const leafExpression = tn.leaf === undefined ? (!tn.children || !tn.children.length) : tn.leaf;
        /** @type {?} */
        const icons = {};
        if (leafExpression && leafIcon) {
            icons[leafIcon] = leafExpression;
        }
        else {
            if (tn.expanded && expandIcon) {
                icons[expandIcon] = expandedExpression;
            }
            else {
                if (collapseIcon) {
                    icons[collapseIcon] = collapsedExpression;
                }
            }
        }
        if (this.iconCls) {
            icons[this.iconCls] = true;
        }
        return icons;
    }
    /**
     * @private
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    compare(a, b) {
        if (typeof a === 'string') {
            return a.localeCompare(b);
        }
        else {
            return a === b ? 0 : (a > b ? 1 : -1);
        }
    }
    /**
     * @private
     * @param {?} r1
     * @param {?} r2
     * @return {?}
     */
    _sort(r1, r2) {
        /** @type {?} */
        let r = 0;
        /** @type {?} */
        const sortFields = this.sortName.split(',');
        /** @type {?} */
        const orders = this.sortOrder.split(',');
        if (!this.sortName) {
            return r;
        }
        for (let i = 0; i < sortFields.length; i++) {
            /** @type {?} */
            const sn = sortFields[i];
            /** @type {?} */
            const so = orders[i];
            /** @type {?} */
            const col = this.columns.find((/**
             * @param {?} c
             * @return {?}
             */
            c => c.field === sn));
            /** @type {?} */
            const orderby = col.sorter || this.compare;
            /** @type {?} */
            let v1 = this.utils.getValue(sn, r1.data);
            if (v1 === null || v1 === undefined) {
                v1 = '';
            }
            /** @type {?} */
            let v2 = this.utils.getValue(sn, r2.data);
            if (v2 === null || v2 === undefined) {
                v2 = '';
            }
            r = orderby(v1, v2);
            if (r !== 0) {
                return r * (so === 'asc' ? 1 : -1);
            }
        }
        return r;
    }
    /**
     * @return {?}
     */
    clientSort() {
        if (!this.data || !this.data.length) {
            return;
        }
        /** @type {?} */
        const sortedData = this.data.sort(this._sort.bind(this));
        /** @type {?} */
        const sortChildNodes = (/**
         * @param {?} childNodes
         * @return {?}
         */
        (childNodes) => {
            childNodes = childNodes.sort(this._sort.bind(this));
            childNodes.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if (n.children && n.children.length) {
                    n.children = n.children.sort(this._sort.bind(this));
                    sortChildNodes(n.children);
                }
            }));
            return childNodes;
        });
        sortedData.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => {
            c.children = sortChildNodes(c.children);
        }));
        this.loadData(sortedData);
    }
    /**
     * @param {?} $event
     * @param {?} col
     * @return {?}
     */
    onSortColumnClick($event, col) {
        if (!col.sortable) {
            return;
        }
        /** @type {?} */
        const sortName = this.sortName;
        /** @type {?} */
        const sortOrder = this.sortOrder;
        /** @type {?} */
        let sortFields = [];
        /** @type {?} */
        let sortOrders = [];
        if (sortName) {
            sortFields = sortName.split(',');
            sortOrders = sortOrder.split(',');
        }
        /** @type {?} */
        const colOrder = col.order || 'asc';
        /** @type {?} */
        let newOrder = colOrder;
        /** @type {?} */
        const i = sortFields.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => n === col.field));
        if (i >= 0) {
            /** @type {?} */
            const _order = sortOrders[i] === 'asc' ? 'desc' : 'asc';
            newOrder = _order;
            // if (this.multiSort && newOrder === 'asc') {
            if (newOrder === 'asc') {
                newOrder = undefined;
                sortFields.splice(i, 1);
                sortOrders.splice(i, 1);
            }
            else {
                sortOrders[i] = _order;
            }
        }
        else {
            if (this.multiSort) {
                sortFields.push(col.field);
                sortOrders.push(colOrder);
            }
            else {
                sortFields = [col.field];
                sortOrders = [colOrder];
            }
        }
        col.order = newOrder;
        this.sortName = sortFields.join(',');
        this.sortOrder = sortOrders.join(',');
        if (!this.multiSort) {
            /** @type {?} */
            const updateFieldOrder = (/**
             * @param {?} cols
             * @return {?}
             */
            (cols) => {
                if (!cols || !cols.length) {
                    return;
                }
                cols.forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => {
                    c.order = undefined;
                    /** @type {?} */
                    const k = sortFields.findIndex((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => f === c.field));
                    if (k >= 0) {
                        c.order = sortOrders[k];
                    }
                }));
            });
            updateFieldOrder(this.columns);
            this.cdRef.detectChanges();
        }
        this.beforeSortColumn(this.sortName, this.sortOrder).subscribe((/**
         * @return {?}
         */
        () => {
            if (this.remoteSort) ;
            else {
                this.clientSort();
            }
            this.columnSorted.emit({ sortName: this.sortName, sortOrder: this.sortOrder });
        }));
    }
    /**
     * 查询工具条前端字符查询
     * @param {?} $event
     * @return {?}
     */
    findKeyWords($event) {
        /** @type {?} */
        const searchValue = $event.value;
        /** @type {?} */
        const field = $event.field;
        this.findField = field;
        if (searchValue && searchValue.length >= 2) {
            this.findValue = searchValue;
            if (!field) {
                this.writeConsole('Please set a field for the FindField property.', 'warn');
                return;
            }
            /** @type {?} */
            const result = this.searchHandle.searchOnClient(field, searchValue, this.state.rowNodes);
            if (result && result.length) {
                this.findResult = result.sort((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                (a, b) => a.index === b.index ? 0 : (a.index > b.index ? 1 : -1)));
                this.findCount = result.length;
                this.findCurrent = 1;
                this._scrollToNode(result[0].id);
                this.highLightKeywords();
            }
            else {
                this.findResult = [];
                this.findCurrent = 0;
                this.findCount = 0;
            }
        }
        else {
            this.resetFindText();
            this.cdRef.detectChanges();
        }
    }
    /**
     * @param {?} step
     * @return {?}
     */
    nextFindValue(step) {
        if (!this.findResult || !this.findResult.length) {
            return;
        }
        /** @type {?} */
        const allHighLights = Array.from(this.el.nativeElement.querySelectorAll('.search-highlight'));
        if (this.findCurrent === this.findResult.length) {
            this.findCurrent = 1;
        }
        else {
            if (step) {
                this.findCurrent = this.findCurrent + step;
                if (step === -1) {
                    if (this.findCurrent <= 0) {
                        this.findCurrent = 1;
                    }
                }
            }
            else {
                this.findCurrent++;
            }
        }
        /** @type {?} */
        const active = this.el.nativeElement.querySelector('.search-highlight.active');
        if (active) {
            this.renderer.removeClass(active, 'active');
        }
        /** @type {?} */
        const _index = this.findCurrent - 1;
        /** @type {?} */
        const nextRow = this.findResult[_index];
        if (nextRow) {
            this._scrollToNode(nextRow.id);
            if (this.virtualized) {
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => {
                    if (this['HIGH_LIGHT_TIMER']) {
                        clearTimeout(this['HIGH_LIGHT_TIMER']);
                    }
                    this['HIGH_LIGHT_TIMER'] = setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        /** @type {?} */
                        const trId = 'rownode-' + nextRow.id;
                        /** @type {?} */
                        const tr = this.el.nativeElement.querySelector('#' + trId);
                        if (tr) {
                            /** @type {?} */
                            const highLightDom = tr.querySelector('.search-highlight');
                            if (highLightDom) {
                                this.renderer.addClass(highLightDom, 'active');
                            }
                        }
                    }), 100);
                }));
            }
            else {
                if (allHighLights[_index]) {
                    this.renderer.addClass(allHighLights[_index], 'active');
                }
            }
        }
    }
    /**
     * 查询工具条前端字符查询
     * @return {?}
     */
    /*
        findKeyWords($event) {
            const searchValue = $event.value;
            const field = $event.field;
            this.findField = field;
            if (searchValue && searchValue.length >= 2) {
                this.findValue = searchValue;
    
                if (!field) {
                    this.writeConsole('Please set a field for the FindField property.', 'warn');
                    return;
                }
    
                const result = this.searchHandle.searchOnClient(field, searchValue, this.state.rowNodes);
    
                if (result && result.length) {
                    this.findResult = result.sort((a, b) => a.index === b.index ? 0 : (a.index > b.index ? 1 : -1));
                    const firstRowIndex = result[0].index;
    
                    this.findCount = result.length;
    
                    const parents = this.searchHandle.findParents(result, this.state.rowNodes);
    
                    this.findCurrent = 1;
                    [...parents, ...result].forEach((r: RowNode) => {
                        this.expandNode(r.id);
                    });
    
                    let y = 0;
                    this.state.rowNodes.forEach((row: RowNode, index: number) => {
                        if (row.visible && firstRowIndex > index) {
                            y += this.rowHeight;
                        }
                    });
                    if (this.psRef && this.psRef.directiveRef) {
                        this.psRef.directiveRef.scrollToY(y - 30);
                    }
    
                    this.highLightKeywords();
                } else {
                    this.findResult = [];
                    this.findCurrent = 0;
                    this.findCount = 0;
                }
            } else {
                this.resetFindText();
                this.cdRef.detectChanges();
            }
        }
    
        nextFindValue(step) {
            if (!this.findResult || !this.findResult.length) {
                return;
            }
            const allHighLights = Array.from(this.el.nativeElement.querySelectorAll('.search-highlight'));
    
            if (this.findCurrent === this.findResult.length) {
                this.findCurrent = 1;
            } else {
                if (step) {
                    this.findCurrent = this.findCurrent + step;
                    if (step === -1) {
                        if (this.findCurrent <= 0) {
                            this.findCurrent = 1;
                        }
                    }
                } else {
                    this.findCurrent++;
                }
            }
    
            const active = this.el.nativeElement.querySelector('.search-highlight.active');
    
            let _index = allHighLights.indexOf(active);
    
            if (active) {
                this.renderer.removeClass(active, 'active');
            }
    
            if (this.virtualized) {
    
                _index += !step ? 1 : step;
    
                if (allHighLights[_index]) {
                    this.renderer.addClass(allHighLights[_index], 'active');
    
                } else {
                    // 先滚动指定位置
                    const nextRow = this.findResult[this.findCurrent - 1];
                    let y = 0;
                    this.state.rowNodes.forEach((row: RowNode, index: number) => {
                        if (row.visible && nextRow.index > index) {
                            y += this.rowHeight;
                        }
                    });
    
                    if (this.psRef && this.psRef.directiveRef) {
                        this.psRef.directiveRef.scrollToY(y - 30, 200);
                    }
                    this.ngZone.runOutsideAngular(() => {
                        setTimeout(() => {
                            const keyWords = this.el.nativeElement.querySelectorAll('.search-highlight');
                            this.renderer.addClass(keyWords[0], 'active');
                        }, 100);
                    });
                }
            } else {
                const currentEl: any = allHighLights[this.findCurrent - 1];
                if (currentEl) {
                    this.renderer.addClass(currentEl, 'active');
                    if (this.psRef && this.psRef.directiveRef) {
                        const sTop = currentEl.closest('td').offsetTop - 30;
                        this.psRef.directiveRef.scrollToY(sTop, 200);
                    }
                }
            }
    
    
            this.cdRef.detectChanges();
        }
    */
    closeFindPanel() {
        this.showFindInput = false;
        this.resetFindText();
        this.cdRef.detectChanges();
    }
    /**
     * @private
     * @return {?}
     */
    highLightKeywords() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.cdRef.detectChanges();
                /** @type {?} */
                const allHighLights = this.el.nativeElement.querySelectorAll('.search-highlight');
                if (!allHighLights.length) {
                    return;
                }
                this.renderer.addClass(allHighLights[0], 'active');
            }), 100);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    resetFindText() {
        this.findValue = '';
        this.findCurrent = 0;
        this.findCount = 0;
        this.findResult = [];
    }
    /**
     * @param {?} y
     * @param {?=} animations
     * @return {?}
     */
    scrollToY(y, animations = 200) {
        this.state.scrollY = y || 0;
        this.psRef.directiveRef.scrollToY(y, animations);
    }
    /**
     * @private
     * @param {?} field
     * @param {?} isHide
     * @return {?}
     */
    showOrHideColumn(field, isHide) {
        if (Array.isArray(field)) {
            this.columns.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if (field.indexOf(n.field) > -1) {
                    n.visible = !isHide;
                }
            }));
        }
        else {
            this.columns.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if (field === n.field) {
                    n.visible = !isHide;
                }
            }));
        }
        this.columnsChanged();
    }
    /**
     * @param {?} field
     * @return {?}
     */
    showColumn(field) {
        this.showOrHideColumn(field, false);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    hideColumn(field) {
        this.showOrHideColumn(field, true);
    }
    /**
     * @param {?} parentNode
     * @return {?}
     */
    showChildsLoading(parentNode) {
        /** @type {?} */
        const colspan = this.columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.visible !== false)).length;
        /** @type {?} */
        const data = { [this.idField]: '正在加载中....', __colspan__: colspan };
        this.loadChildren([{ data, __childs_loading__: true }], parentNode, false);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onChildsPageChanged($event) {
        this.childsPageChanged.emit($event);
    }
    /**
     * @private
     * @param {?} tr
     * @return {?}
     */
    trId2DataId(tr) {
        return tr.id.replace('rownode-', '');
    }
    // 快捷键
    /**
     * @param {?} $event
     * @return {?}
     */
    onKeydownEvent($event) {
        if (!$event || !this.singleSelect || !this.data || !this.data.length) {
            return;
        }
        /** @type {?} */
        const keys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
        if (!keys.includes($event.key) || $event.target.nodeName === 'INPUT') {
            return;
        }
        $event.stopPropagation();
        $event.preventDefault();
        this.inputGroup.textbox.nativeElement.blur();
        /** @type {?} */
        let newIdx;
        /** @type {?} */
        const trs = Array.from(this.bodyTable.nativeElement.querySelectorAll('tr'));
        /** @type {?} */
        const trCount = trs.length;
        /** @type {?} */
        let selectedTrIndex = -1;
        if (this.selectedRow) {
            selectedTrIndex = trs.findIndex((/**
             * @param {?} n
             * @return {?}
             */
            (n) => this.trId2DataId(n) === this.selectedRow.id));
        }
        if ($event.code === 'ArrowDown') {
            newIdx = selectedTrIndex + 1;
        }
        else if ($event.code === 'ArrowUp') {
            if (selectedTrIndex !== -1) {
                newIdx = selectedTrIndex - 1;
            }
        }
        else {
            if (this.selectedRow && ($event.code === 'ArrowRight' || $event.code === 'ArrowLeft')) {
                this.toggleExpand(this.selectedRow);
            }
            return;
        }
        if (newIdx >= 0 && newIdx < trCount) {
            /** @type {?} */
            const _tr = (/** @type {?} */ (trs[newIdx]));
            if (_tr) {
                /** @type {?} */
                const id = this.trId2DataId(_tr);
                this.selectNode(id);
                _tr.scrollIntoView({ block: 'nearest' });
            }
        }
    }
    /**
     * 根据传入的父级ID，获取所有子级节点
     * @param {?} parentId
     * @return {?}
     */
    getChildNodes(parentId) {
        /** @type {?} */
        let nodes = [];
        if (parentId) {
            /** @type {?} */
            const rowNode = this.findRowNode(parentId);
            if (rowNode && rowNode.node.children && rowNode.node.children.length) {
                rowNode.node.children.forEach((/**
                 * @param {?} tn
                 * @return {?}
                 */
                (tn) => {
                    if (tn.selectable) {
                        nodes.push(tn);
                    }
                    nodes = nodes.concat(this.getChildNodes(tn.id));
                }));
            }
            return nodes;
        }
        return [];
    }
    /**
     * 根据传入的节点ID， 获取所有父级节点
     * @param {?} id
     * @return {?}
     */
    getParentNodes(id) {
        /** @type {?} */
        let nodes = [];
        if (id) {
            /** @type {?} */
            const rowNode = this.findRowNode(id);
            if (rowNode && rowNode.parents && rowNode.parents.length) {
                rowNode.parents.forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                (n) => {
                    /** @type {?} */
                    const rn = this.findRowNode(n);
                    if (rn && rn.node.selectable) {
                        nodes.push(rn);
                    }
                }));
            }
            return nodes;
        }
        return [];
    }
    /**
     * @param {?} $event
     * @param {?} col
     * @return {?}
     */
    onFilterRowInput($event, col) {
        this.filterRowConditions = this.filterRowConditions || {};
        this.filterRowConditions[col.field] = $event.target.value;
        Object.keys(this.filterRowConditions).forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (this.filterRowConditions[n] === '' || this.filterRowConditions[n] == null) {
                delete this.filterRowConditions[n];
            }
        }));
        if (this['FILTERCONDITIONS_CHANGED_TIMER']) {
            clearTimeout(this['FILTERCONDITIONS_CHANGED_TIMER']);
        }
        this['FILTERCONDITIONS_CHANGED_TIMER'] = setTimeout((/**
         * @return {?}
         */
        () => {
            this.searchHandle.searchWithConditions(this.filterRowConditions);
            this.setNewColumnsWidth();
        }), 200);
    }
}
TreeTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-treetable',
                template: "\r\n<div class=\"filter-row\" style=\"width: 100%;\" *ngIf=\"showFilterBar\">\r\n    <form style=\"display: flex; width: 100%;\">\r\n        <div class=\"search-fields\" style=\"padding-left:0; max-width: 180px;min-width: 140px;\" [style.display]=\"showSearchField ? '': 'none'\">\r\n            <select class=\"custom-select\" [(ngModel)]=\"searchData.field\" name=\"field\"  single-select [panelRef]=\"selectpanel\" [items]=\"searchFields\">\r\n                <!-- <option value=\"*\">{{allColumnsTitle}}</option>\r\n                <option *ngFor=\"let col of searchFields\" value=\"{{col.value}}\">{{ col.label }}</option> -->\r\n            </select>\r\n\r\n            <div #selectpanel class=\"single-select-panel f-area-hide\">\r\n                <ul class=\"dropdown-menu show\">\r\n                    <li class=\"dropdown-item\" [attr.value]=\"'*'\" [class.active]=\"searchData.field === '*'\" *ngIf=\"searchAnyField\">{{allColumnsTitle}}</li>\r\n                    <li class=\"dropdown-item\" *ngFor=\"let col of searchFields\" [attr.value]=\"col.value\" [class.active]=\"searchData.field === col.value\">{{ col.label }}</li>\r\n                </ul>\r\n            </div>\r\n\r\n\r\n        </div>\r\n        <div class=\"search-text flex-fill\" style=\"padding-right: 0px;\">\r\n            <input-group #inputGroup [groupText]=\"searchButtonText\" name=\"searchValue\" [(ngModel)]=\"searchData.value\"\r\n                (clear)=\"onClearSearchValue()\" (valueChange)=\"onSearchValueChange($event)\" (clickHandle)=\"onSearch()\"\r\n                (keydownHandle)=\"onKeydownEvent($event)\"></input-group>\r\n        </div>\r\n    </form>\r\n</div>\r\n\r\n<ng-content select=\"tt-column\"></ng-content>\r\n\r\n<ng-template #tdcell let-col let-serializedNode=\"rowNode\" let-left=\"left\">\r\n\r\n    <ng-container *ngIf=\"enableFindText\">\r\n        <span *ngIf=\"!col.formatter\" style=\"width: 100%;\"\r\n            [innerHTML]=\"getNodeText(col, serializedNode.node.data) | highlight: findValue: col.field :findField\"></span>\r\n        <span *ngIf=\"col.formatter\" style=\"width: 100%;\" \r\n            [innerHTML]=\"formatData(col, serializedNode.node.data, col.formatter) | safe: 'html' \"></span>\r\n    </ng-container>\r\n\r\n    <ng-container *ngIf=\"!enableFindText\">\r\n        <span *ngIf=\"!col.formatter && !fast\" style=\"width: 100%;\"\r\n            [innerHTML]=\"getNodeText(col, serializedNode.node.data)\"></span>\r\n        <span *ngIf=\"!col.formatter && fast\" style=\"width: 100%;\"\r\n            [textContent]=\"getNodeText(col, serializedNode.node.data, true)\"></span>\r\n        <span *ngIf=\"col.formatter\" style=\"width: 100%;\" \r\n            [innerHTML]=\"formatData(col, serializedNode.node.data, col.formatter) | safe: 'html' \"></span>\r\n    </ng-container>\r\n</ng-template>\r\n\r\n<ng-template #tbodyrows>\r\n    <ng-template ngFor let-serializedNode let-rowIndex=\"index\" [ngForTrackBy]=\"trackByFn\" [ngForOf]=\"pagination ? (serializedValue | paginate: paginationOptions) : serializedValue\">\r\n        <tr *ngIf=\"serializedNode.visible\" #row=\"row\" \r\n            [attr.id]=\" 'rownode-' + serializedNode.id\" class=\"f-treetable-row\"\r\n            [selectRow]=\"serializedNode\" [rowIndex]=\"rowIndex\" [dblclick]=\"useDblClick\" [dblclickNode]=\"serializedNode\"\r\n            [selectRowDisabled]=\"serializedNode.node | disablenode: disabledRow\"\r\n            [customRowStyle]=\"serializedNode\"\r\n            [class.f-treetable-disable-row]=\"serializedNode.node | disablenode: disabledRow\"\r\n            [class.farris-table-selectedrow]=\"serializedNode.isSelected\">\r\n\r\n            <td *ngIf=\"serializedNode.node.data['__colspan__']\"  [attr.colspan]=\" serializedNode.node.data['__colspan__'] || 0\">\r\n                <childs-loading></childs-loading>\r\n            </td>\r\n\r\n            <ng-container *ngIf=\"!serializedNode.node.data['__colspan__']\">\r\n                <td *ngFor=\"let col of columns; let i = index;\"\r\n                    [customCellStyle]=\"col\" [rowNode]=\"serializedNode\" [rowIndex]=\"rowIndex\"\r\n                    [style.textAlign]=\"col!.align || 'left'\" \r\n                    (click)=\"onCellClick($event, col, serializedNode.node)\"\r\n                    class=\"treetable-cell\" [attr.field]=\"col.field\"\r\n                    [attr.colspan]=\" serializedNode.node.data['__cellspan__'] || 0\"\r\n                    [attr.title]=\"col | tipmsg: serializedNode.node\"\r\n                    [class.f-treetable--fixed-left]=\"fixedColumns && fixedHeader && col.fixed && col.fixed === 'left'\"\r\n                    [class.f-treetable--fixed-right]=\"fixedColumns && fixedHeader && col.fixed && col.fixed === 'right'\"\r\n                    [attr.r-tt-shadow-col]=\"col.rightShadowCol\"\r\n                    [attr.l-tt-shadow-col]=\"col.leftShadowCol\"\r\n                >\r\n\r\n                    <div class=\"treetable-cell-content d-flex align-items-center\">\r\n                        <farris-treeTableToggler style=\"float: left\"\r\n                            [showLines]=\"showLines\"\r\n                            [indentSpacing]=\"indentSpacing\"\r\n                            [disabled]=\"serializedNode.node | disablenode: disabledRow: disabled\"\r\n                            [rowNode]=\"serializedNode\" *ngIf=\"i == 0\"></farris-treeTableToggler>\r\n                        \r\n                        <div class=\"flex-grow-1 text\"  *ngIf=\"!col.componentType\">\r\n                            <ng-container *ngIf=\"!col.template && col.field\">\r\n                                <ng-container *ngTemplateOutlet=\"tdcell; context: {$implicit: col, node: serializedNode.node, rowNode: serializedNode, rowData: serializedNode.node.data  }\" ></ng-container>\r\n                            </ng-container>\r\n            \r\n                            <ng-container *ngIf=\"col.template\"\r\n                                [ngTemplateOutlet]=\"col.template\"\r\n                                [ngTemplateOutletContext]=\"{$implicit: { column: col, node: serializedNode.node, rowNode: serializedNode, rowData:  serializedNode.node.data  }}\">\r\n                            </ng-container>\r\n                        </div>\r\n                        <div class=\"flex-grow-1 text\"  *ngIf=\"col.componentType\" [component-template]=\"col\" [ctx]=\" { column: col, node: serializedNode.node, rowNode: serializedNode, rowData:  serializedNode.node.data  }\">\r\n                        </div>\r\n                    </div>\r\n                </td>\r\n            </ng-container>\r\n        </tr>\r\n    </ng-template>\r\n</ng-template>\r\n\r\n<ng-template #tbody>\r\n    <tbody class=\"farris-treetable-tbody\"\r\n        [farris-context-menus]=\"contextMenuItems\" [disabled]=\"!enableContextMenu\" \r\n        [activeDomName]=\"'tr'\" [beforeShowContextMenu]=\"onBeforeShowContextMenu\"\r\n        [menuClass]=\"'f-treetable-context-menu'\">\r\n        <ng-container *ngTemplateOutlet=\"tbodyrows\"></ng-container>\r\n    </tbody>\r\n</ng-template>\r\n\r\n<!--\u5355\u884C\u8868\u5934\u6A21\u677F-->\r\n<ng-template #headerCells let-cols let-firstRow=\"firstRow\">\r\n    <ng-template ngFor let-col [ngForOf]=\"cols\" let-i=\"index\" let-first=\"first\" let-last=\"last\">\r\n        <th [resizable-column]=\"(!col.lastColumn || !last) && (!col.colspan || col.colspan == 1)\" [style.textAlign]=\"col!.hAlign || 'left'\" #th \r\n            class=\"treetable-header-cell\"\r\n            [class.f-treetable--fixed-left]=\"fixedColumns && col.fixed && col.fixed === 'left'\"\r\n            [class.f-treetable--fixed-right]=\"fixedColumns && col.fixed && col.fixed === 'right'\"\r\n            [attr.field]=\"col.field || ''\"\r\n            [attr.r-tt-shadow-col]=\"col.rightShadowCol\"\r\n            [attr.l-tt-shadow-col]=\"col.leftShadowCol\"\r\n            [attr.colspan]=\"col.colspan\" \r\n            [attr.rowspan]=\"col.rowspan\"\r\n            [class.group-header-cell]=\"col.colspan && col.colspan > 1\"\r\n            [attr.id]=\"col.id\"\r\n            >\r\n      \r\n            <div class=\"d-flex\" style=\"line-height: 1.25em;\" [style.padding-right.px]=\"col.sortable ? 10: 0\">\r\n                <ng-container *ngIf=\"!singleSelect && showCheckAll && first && showCheckbox && !last && firstRow\">\r\n                    <tt-header-checkbox #allCheckbox></tt-header-checkbox>\r\n                </ng-container>\r\n                <ng-container *ngIf=\"col.headTemplate&& !col.headerComponentType\"\r\n                    [ngTemplateOutlet]=\"col.headTemplate\"\r\n                    [ngTemplateOutletContext]=\"{$implicit: { column: col}}\">\r\n                </ng-container>\r\n                <ng-container *ngIf=\"!col.headTemplate && !col.headerComponentType\">\r\n                    <span style=\"overflow: hidden;width: 100%;\" *ngIf=\"!headerWrap\">{{ col.title }}</span>\r\n                    <span style=\"white-space: pre-wrap;width: 100%;\"  *ngIf=\"headerWrap\">{{ col.title }}</span>\r\n                </ng-container>\r\n\r\n                <div class=\"flex-grow-1 text\" *ngIf=\"col.headerComponentType\" [component-template]=\"col\" [templateType]=\"'head'\" [ctx]=\"{ column: col}\" [style.whiteSpace]=\"headerWrap ? 'pre-wrap': ''\"></div>\r\n\r\n\r\n                <ng-container *ngIf=\"col.sortable\">\r\n                    <span class=\"f-treetable-sort\"\r\n                        [class.f-treetable-sort-asc]=\"col.order === 'asc'\"\r\n                        [class.f-treetable-sort-desc]=\"col.order === 'desc'\"\r\n                        (click)=\"onSortColumnClick($event, col)\" *ngIf=\"col.order\"></span>\r\n                    <span class=\"f-treetable-sort\" (click)=\"onSortColumnClick($event, col)\" *ngIf=\"!col.order\"></span>\r\n                </ng-container>\r\n\r\n            </div>\r\n        </th>\r\n    </ng-template>\r\n</ng-template>\r\n\r\n<!--\u591A\u884C\u8868\u5934\u6A21\u677F-->\r\n<ng-template #groupHeader>\r\n    <tr *ngFor=\"let cols of groupColumns; first as isFirst\">\r\n        <ng-container *ngTemplateOutlet=\"headerCells; context: {$implicit: cols, firstRow: isFirst}\"></ng-container>\r\n    </tr>\r\n</ng-template>\r\n\r\n\r\n<ng-template #scorllview>\r\n    <div class=\"farris-treetable fixed\" [attr.id]=\"id\" [class.f-treetable--fixed-columns]=\"fixedColumns\"\r\n        [class.farris-treetable-nowrap]=\"!nowrap\" [class.table-bordered]=\"showBorder\"\r\n        [ngClass]=\"{'farris-treetable-disabled': disabled}\"\r\n        [class.farris-treetable-showlines]=\"showLinesOnHover && showLines\" [style.width]=\"fit ? '100%': (width + 'px')\">\r\n        <div #headerBox class=\"farris-treetable-header\" *ngIf=\"showHeader && columns\" style=\"overflow: hidden; background-color: #f7f8fb\">\r\n            <table #headerTable class=\"table\" >\r\n                <colgroup *ngIf=\"!autoWidth\">\r\n                    <ng-container *ngFor=\"let col of columns\">\r\n                        <col *ngIf=\"columnIsVisible(col)\" [style.width]=\"getRealColWidth(col)\" />\r\n                    </ng-container>\r\n                </colgroup>\r\n                <thead class=\"farris-treetable-thead\" [class.header-wrap]=\"headerWrap\">\r\n                    <ng-container *ngIf=\"!headerTemplate\">\r\n                        <tr *ngIf=\"!useGroupHeader; else groupHeader\">\r\n                            <ng-container *ngTemplateOutlet=\"headerCells; context: {$implicit: columns, firstRow: true}\"></ng-container>\r\n                        </tr>\r\n                        <tr *ngIf=\"enableFilterRow\">\r\n                            <th *ngFor=\"let col of columns\">\r\n                                <input autocomplete=\"off\" type=\"text\" class=\"form-control\" name=\"{{ col.field }}\" (input)=\"onFilterRowInput($event, col)\" />\r\n                            </th>\r\n                        </tr>\r\n                    </ng-container>\r\n\r\n                    <ng-container *ngIf=\"headerTemplate\">\r\n                        <ng-container *ngTemplateOutlet=\"headerTemplate; context: {$implicit: columns}\"></ng-container>\r\n                    </ng-container>\r\n                </thead>\r\n            </table>\r\n            <!-- \u5BA2\u6237\u7AEF\u67E5\u8BE2\u5B9A\u4F4D\u5DE5\u5177\u6761 -->\r\n            <find-input *ngIf=\"showFindInput\" [columns]=\"columns\" [current]=\"findCurrent\" [count]=\"findCount\"\r\n                (valueChanged)=\"findKeyWords($event)\" (close)=\"closeFindPanel()\" (enterHandler)=\"nextFindValue($event)\">\r\n            </find-input>\r\n\r\n        </div>\r\n\r\n        <div class=\"farris-treetable-body\">\r\n            <perfect-scrollbar #perfectScrollbar [config]=\"{minScrollbarLength: 15}\" (psScrollX)=\"onScrollX($event)\"\r\n                (psScrollY)=\"onScrollY($event)\" [style.height.px]=\"scorllBodyHeight\">\r\n                <div *ngIf=\"topHideHeight && virtualized\" [style.height.px]=\"topHideHeight\"> </div>\r\n                <table #bodyTable class=\"table\" [style.tableLayout]=\"autoWidth? 'auto': 'fixed'\"\r\n                    [ngClass]=\"{'table-striped': striped, 'table-hover': (hovered && serializedValue && serializedValue.length), 'f-table-norecords': (!serializedValue || !serializedValue.length),\r\n                    'h-100': (!serializedValue || !serializedValue.length) }\">\r\n                    <colgroup>\r\n                        <ng-container *ngFor=\"let col of columns\">\r\n                            <col *ngIf=\"columnIsVisible(col)\" [style.width]=\"getRealColWidth(col)\" />\r\n                        </ng-container>\r\n                    </colgroup>\r\n\r\n                    <ng-container *ngIf=\"!serializedValue || !serializedValue.length\">\r\n                        <tbody class=\"farris-treetable-tbody\">\r\n                            <tr class=\"f-table-norecords-row\">\r\n                                <td [attr.align]=\"'center'\" class=\"farris-treetable-emptydata\" [attr.colspan]=\"columns.length\">\r\n                                    <div class=\"f-table-norecords-content\" >\r\n                                        {{ 'treetable.emptyMessage' | locale }}\r\n                                    </div>\r\n                                </td>\r\n                            </tr>\r\n                        </tbody>\r\n                    </ng-container>\r\n\r\n                    <ng-container *ngIf=\"serializedValue && serializedValue.length\">\r\n                        <ng-container *ngIf=\"bodyTemplate\">\r\n                            <tbody class=\"farris-treetable-tbody\" treeTableBody [columns]=\"columns\" [template]=\"bodyTemplate\"></tbody>\r\n                        </ng-container>\r\n\r\n                        <ng-container #defaultBodyTemplate *ngIf=\"!bodyTemplate\">\r\n                            <ng-container *ngTemplateOutlet=\"tbody\"></ng-container>\r\n                        </ng-container>\r\n                    </ng-container>\r\n                </table>\r\n                <div *ngIf=\"bottomHideHeight && virtualized\" [style.height.px]=\"bottomHideHeight\"> </div>\r\n            </perfect-scrollbar>\r\n        </div>\r\n\r\n        <!-- \u5206\u9875\u6761 -->\r\n        <div *ngIf=\"pagination\" #tablePager class=\"farris-table-pager\" [ngStyle]=\" { 'opacity': (disabled ? 0.6 : 1), 'pointer-events': (disabled? 'none': '')  }\">\r\n            <pagination-controls #pager [id]=\"paginationOptions?.id\"\r\n                [maxSize]=\"pagerLabelSize\" [directionLinks]=\"true\"\r\n                [autoHide]=\"false\" [responsive]=\"true\"\r\n                [previousLabel]=\"' '\" [nextLabel]=\"' '\"\r\n                [showPageInfo]=\"showPageInfo\" [showPageNumber]=\"showPageNumber\" [showPageList]=\"showPageList\"\r\n                (pageChange)=\"onPageChange($event)\" [showGotoInput]=\"showGotoInput\"\r\n                (pageSizeChange)=\"onPageSizeChange($event)\"\r\n                >\r\n\r\n                \r\n            </pagination-controls>\r\n        </div>\r\n\r\n        <div #resizerHelper class=\"column-resizer-helper\" *ngIf=\"resizableColumns\"></div>\r\n    </div>\r\n</ng-template>\r\n\r\n<ng-template #nodespagerbar let-ctx>\r\n    <nodes-pager [context]=\"ctx\" [disabled]=\"disabled\" (pageChange)=\"onChildsPageChanged($event)\" [showTotal]=\"showTotalForChildren\"></nodes-pager>\r\n</ng-template>\r\n\r\n\r\n\r\n<div class=\"farris-treetable\" [class.table-bordered]=\"showBorder\" [attr.id]=\"id\"\r\n    [class.farris-treetable-showlines]=\"showLinesOnHover && showLines\" \r\n    [class.farris-treetable-nowrap]=\"!nowrap\"  *ngIf=\"!fixedHeader; else scorllview\">\r\n    <table class=\"table\" [style.tableLayout]=\"autoWidth? 'auto': 'fixed'\"\r\n        [ngClass]=\"{'table-striped': striped, 'table-hover': (hovered && serializedValue && serializedValue.length), 'f-table-norecords': (!serializedValue || !serializedValue.length),\r\n        'h-100': (!serializedValue || !serializedValue.length) }\">\r\n        <thead class=\"farris-treetable-thead\" *ngIf=\"showHeader\" [class.header-wrap]=\"headerWrap\">\r\n            <ng-container *ngIf=\"!headerTemplate && columns\">\r\n                <th *ngFor=\"let col of columns;let isFirst=first\" [style.textAlign]=\"col!.hAlign || 'left'\" class=\"treetable-header-cell\" [attr.field]=\"col.field\">\r\n                    <div class=\"d-flex\">\r\n                        <ng-container *ngIf=\"!singleSelect && showCheckAll && isFirst && showCheckbox\">\r\n                            <tt-header-checkbox #allCheckbox class=\"f-cmp-treetable-toggler\"></tt-header-checkbox>\r\n                        </ng-container>\r\n\r\n                        <ng-container *ngIf=\"!col.headTemplate && !col.headComponentType\">\r\n                            <div class=\"flex-grow-1 text\" [style.whiteSpace]=\"headerWrap ? 'pre-wrap': ''\">{{col.title}}</div>\r\n                        </ng-container>\r\n        \r\n                        <ng-container *ngIf=\"col.headTemplate && !col.headComponentType\"\r\n                            [ngTemplateOutlet]=\"col.headTemplate\"\r\n                            [ngTemplateOutletContext]=\"{$implicit: { column: col}}\">\r\n                        </ng-container>\r\n                        <div class=\"flex-grow-1 text\" *ngIf=\"col.headerComponentType\" [component-template]=\"col\" [templateType]=\"'head'\" [ctx]=\" { column: col}\" [style.whiteSpace]=\"headerWrap ? 'pre-wrap': ''\"></div>\r\n                    </div>\r\n                </th>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"headerTemplate\">\r\n                <ng-container *ngTemplateOutlet=\"headerTemplate; context: {$implicit: columns}\"></ng-container>\r\n            </ng-container>\r\n        </thead>\r\n        <ng-container *ngIf=\"serializedValue && serializedValue.length\">\r\n             <!-- \u5BA2\u6237\u7AEF\u67E5\u8BE2\u5B9A\u4F4D\u5DE5\u5177\u6761 -->\r\n             <find-input *ngIf=\"showFindInput\" [current]=\"findCurrent\" [count]=\"findCount\"\r\n             (valueChanged)=\"findKeyWords($event)\" (close)=\"closeFindPanel()\"  [columns]=\"columns\"\r\n             (enterHandler)=\"nextFindValue($event)\"></find-input>\r\n            <ng-container *ngIf=\"bodyTemplate\">\r\n                <tbody class=\"farris-treetable-tbody\" treeTableBody [columns]=\"columns\" [template]=\"bodyTemplate\">\r\n                </tbody>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"!bodyTemplate\">\r\n                <ng-container *ngTemplateOutlet=\"tbody\"></ng-container>\r\n            </ng-container>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!serializedValue || !serializedValue.length\">\r\n            <tbody class=\"farris-treetable-tbody\">\r\n                <tr class=\"f-table-norecords-row\" style=\"height: 200px\">\r\n                    <td [attr.align]=\"'center'\" class=\"farris-treetable-emptydata\" [attr.colspan]=\"columns.length\">\r\n                        <div class=\"f-table-norecords-content\" >\r\n                            {{ 'treetable.emptyMessage' | locale }}\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n            </tbody>\r\n        </ng-container>\r\n    </table>\r\n</div>\r\n\r\n",
                exportAs: 'treeTable',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
        .farris-treetable {
            position: relative;
        }
        .resizable-column {
            background-clip: padding-box;
            position: relative;
        }
        .column-resizer {
            display: block;
            position: absolute!important;
            top: 0;
            right: 0;
            margin: 0;
            width: .5em;
            height: 100%;
            padding: 0;
            cursor: col-resize;
            border: 1px solid transparent;
        }
        .column-resizer-helper {
            width: 1px;
            position: absolute;
            z-index: 10;
            display: none;
            border-right: 1px dashed #1890ff;
        }

        .farris-treetable-disabled .farris-treetable-body .table tr{
            opacity: 0.4;
            cursor: not-allowed;
        }
        .farris-treetable-disabled .table tr.farris-table-selectedrow{
            opacity: 1;
            cursor: default;
        }

        .custom-checkbox .custom-control-input:indeterminate~.custom-control-label::after {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 4'%3e%3cpath stroke='%23fff' d='M0 2h4'/%3e%3c/svg%3e");
            background-color: #1890ff;
        }
        .unselectable-text {
            -webkit-user-select: none;
            -moz-user-select: none;
            -o-user-select: none;
            -ms-user-select: none;
            user-select: none
        }
        .search-highlight {
            background-color: #FFFF1F;
        }
        .search-highlight.active{
            background-color: #FF901C;
        }

        .f-treetable--fixed-columns .ps__rail-x, .f-treetable--fixed-columns .ps__rail-y {
            z-index: 18;
        }
    `]
            }] }
];
/** @nocollapse */
TreeTableComponent.ctorParameters = () => [
    { type: TreetableService },
    { type: ElementRef },
    { type: ResizeService },
    { type: Renderer2 },
    { type: CommonUtils },
    { type: ColumnFormatService },
    { type: TTHotkeys },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Injector }
];
TreeTableComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    showFilterBar: [{ type: Input }],
    enableFilterRow: [{ type: Input }],
    showSearchField: [{ type: Input }],
    headerHeight: [{ type: Input }],
    headerWrap: [{ type: Input }],
    rowHeight: [{ type: Input }],
    columns: [{ type: Input }],
    groupColumns: [{ type: Input }],
    useGroupHeader: [{ type: Input }],
    fitColumns: [{ type: Input }],
    autoFitColumns: [{ type: Input }],
    searchFields: [{ type: Input }],
    allColumnsTitle: [{ type: Input }],
    searchAnyField: [{ type: Input }],
    showLines: [{ type: Input }],
    showLinesOnHover: [{ type: Input }],
    multiSelect: [{ type: Input }],
    singleSelect: [{ type: Input }],
    showCheckbox: [{ type: Input }],
    idField: [{ type: Input }],
    showBorder: [{ type: Input }],
    showCheckAll: [{ type: Input }],
    showHeader: [{ type: Input }],
    striped: [{ type: Input }],
    hovered: [{ type: Input }],
    disabled: [{ type: Input }],
    disabledRow: [{ type: Input }],
    loadDataType: [{ type: Input }],
    fixedHeader: [{ type: Input }],
    checkOnSelect: [{ type: Input }],
    selectOnCheck: [{ type: Input }],
    onlySelectSelf: [{ type: Input }],
    resizableColumns: [{ type: Input }],
    fit: [{ type: Input }],
    cascadeCheck: [{ type: Input }],
    cascadeDown: [{ type: Input }],
    cascadeUp: [{ type: Input }],
    emptyMessage: [{ type: Input }],
    indentSpacing: [{ type: Input }],
    keepSelect: [{ type: Input }],
    virtualized: [{ type: Input }],
    onlySelectLeaf: [{ type: Input }],
    showIcon: [{ type: Input }],
    leafIcon: [{ type: Input }],
    expandIcon: [{ type: Input }],
    collapseIcon: [{ type: Input }],
    foldIcon: [{ type: Input }],
    unfoldIcon: [{ type: Input }],
    useIconFromData: [{ type: Input }],
    whenDataIconEmptyUseDefault: [{ type: Input }],
    iconField: [{ type: Input }],
    iconCls: [{ type: Input }],
    remoteSort: [{ type: Input }],
    sortName: [{ type: Input }],
    sortOrder: [{ type: Input }],
    multiSort: [{ type: Input }],
    beforeSortColumn: [{ type: Input }],
    rowStyler: [{ type: Input }],
    cellStyler: [{ type: Input }],
    enableFindText: [{ type: Input }],
    findField: [{ type: Input }],
    expandLevel: [{ type: Input }],
    selectValue: [{ type: Input }],
    selectValueChange: [{ type: Output }],
    dblClickExpand: [{ type: Input }],
    useDblClick: [{ type: Input }],
    selectValues: [{ type: Input }],
    selectValuesChange: [{ type: Output }],
    nowrap: [{ type: Input }],
    checkValues: [{ type: Input }],
    checkValuesChange: [{ type: Output }],
    beforeNodeSelected: [{ type: Input }],
    beforeNodeUnSelected: [{ type: Input }],
    beforeNodeChecked: [{ type: Input }],
    beforeNodeUnChecked: [{ type: Input }],
    beforeCheckAll: [{ type: Input }],
    beforeUnCheckAll: [{ type: Input }],
    beforeClickNode: [{ type: Input }],
    pagination: [{ type: Input }],
    paginationForChildren: [{ type: Input }],
    pagerViewMode: [{ type: Input }],
    pagerOnServer: [{ type: Input }],
    pageList: [{ type: Input }],
    pageIndex: [{ type: Input }],
    pageSize: [{ type: Input }],
    pagerHeight: [{ type: Input }],
    showPageList: [{ type: Input }],
    showPageInfo: [{ type: Input }],
    showPageNumber: [{ type: Input }],
    pagerLabelSize: [{ type: Input }],
    showGotoInput: [{ type: Input }],
    showTotalForChildren: [{ type: Input }],
    total: [{ type: Input }],
    enableContextMenu: [{ type: Input }],
    contextMenuItems: [{ type: Input }],
    beforeShowContextMenu: [{ type: Input }],
    pageSizeChanged: [{ type: Output }],
    pageChanged: [{ type: Output }],
    columnSorted: [{ type: Output }],
    nodeSelected: [{ type: Output }],
    nodeUnSelect: [{ type: Output }],
    nodeChecked: [{ type: Output }],
    nodeUnChecked: [{ type: Output }],
    checkAll: [{ type: Output }],
    unCheckAll: [{ type: Output }],
    search: [{ type: Output }],
    dblClick: [{ type: Output }],
    loadedData: [{ type: Output }],
    expand: [{ type: Output }],
    collapse: [{ type: Output }],
    expandAllNodes: [{ type: Output }],
    collapseAllNodes: [{ type: Output }],
    appendNew: [{ type: Output }],
    removed: [{ type: Output }],
    updated: [{ type: Output }],
    clearSearchValue: [{ type: Output }],
    cellClick: [{ type: Output }],
    childsPageChanged: [{ type: Output }],
    searchValueChange: [{ type: Output }],
    loadedTimer: [{ type: Input }],
    data: [{ type: Input }],
    autoWidth: [{ type: Input }],
    templates: [{ type: ContentChildren, args: [FarrisTemplateDirective,] }],
    columnsRef: [{ type: ContentChildren, args: [TreeTableColumnDirective,] }],
    headerBox: [{ type: ViewChild, args: ['headerBox',] }],
    resizerHelperVC: [{ type: ViewChild, args: ['resizerHelper',] }],
    headerTable: [{ type: ViewChild, args: ['headerTable',] }],
    bodyTable: [{ type: ViewChild, args: ['bodyTable',] }],
    inputGroup: [{ type: ViewChild, args: ['inputGroup',] }],
    psRef: [{ type: ViewChild, args: [PerfectScrollbarComponent,] }],
    allCheckbox: [{ type: ViewChild, args: ['allCheckbox',] }],
    nodesPagerBar: [{ type: ViewChild, args: ['nodespagerbar',] }],
    ctxMenu: [{ type: ViewChild, args: [FarrisContextMenuDirective,] }],
    onResized: [{ type: HostListener, args: ['window:resize',] }]
};
class TTBodyComponent {
    /**
     * @param {?} tt
     */
    constructor(tt) {
        this.tt = tt;
    }
}
TTBodyComponent.decorators = [
    { type: Component, args: [{
                selector: '[treeTableBody]',
                template: `
        <ng-template ngFor let-serializedNode let-rowIndex="index" [ngForOf]="tt.serializedValue">
            <ng-container *ngIf="serializedNode.visible">
                <ng-container
                    *ngTemplateOutlet="template;
                        context: {$implicit: serializedNode, node: serializedNode.node,
                        rowData: serializedNode.node.data, rowIndex: rowIndex, columns: columns}">
                </ng-container>
            </ng-container>
        </ng-template>
    `
            }] }
];
/** @nocollapse */
TTBodyComponent.ctorParameters = () => [
    { type: TreeTableComponent }
];
TTBodyComponent.propDecorators = {
    columns: [{ type: Input }],
    template: [{ type: Input }]
};
// [style.marginLeft]="rowNode.level * 16 + 'px'"
/**
 * 树节点展开折叠
 */
class TreeTableTogglerComponent {
    /**
     * @param {?} tt
     * @param {?} ngzone
     * @param {?} render
     */
    constructor(tt, ngzone, render) {
        this.tt = tt;
        this.ngzone = ngzone;
        this.render = render;
        this.cls = true;
        this.showLines = false;
        this.indentSpacing = 16;
        this.treeNodeIcon = {};
        this.isShowTriangle = false;
        this.noChilds = false;
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    get offsetWidth() {
        return this.togglerEl.nativeElement.parentElement.offsetWidth;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.treeNodeIcon = this.tt.getTreeIcon(this.rowNode.node);
        this.isShowTriangle = this.showTriangle();
        this.noChilds = this.hasChildren();
        /** @type {?} */
        const expandSub = this.tt.expand.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (this.rowNode.id === node.data[this.tt.idField]) {
                this.updateIcon(this.rowNode.node);
                if (this.tt.psRef) {
                    this.tt.psRef.directiveRef.update();
                }
                this.tt.detectChanges();
            }
        }));
        /** @type {?} */
        const collapseSub = this.tt.collapse.subscribe((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (this.rowNode.id === node.data[this.tt.idField]) {
                this.updateIcon(this.rowNode.node);
                if (this.tt.psRef) {
                    this.tt.psRef.directiveRef.update();
                }
                this.tt.detectChanges();
            }
        }));
        /** @type {?} */
        const addNewSub = this.tt.appendNew.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.parent) {
                if (this.rowNode.id === e.parent.data[this.tt.idField]) {
                    if (this.rowNode.node.leaf || this.rowNode.node.leaf === undefined) {
                        this.rowNode.node.leaf = false;
                    }
                }
                this.updateIcon(this.rowNode.node);
            }
        }));
        this.subscriptions = [expandSub, collapseSub, addNewSub];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.showLines && !changes.showLines.isFirstChange()) {
            if (this.showLines) {
                this.render.setStyle(this.togglerEl.nativeElement, 'display', this.isShowTriangle ? '' : 'none');
            }
            else {
                this.render.removeStyle(this.togglerEl.nativeElement, 'display');
            }
            this.reSetLines();
        }
        if (changes.rowNode && !changes.rowNode.isFirstChange()) {
            this.updateIcon(this.rowNode.node);
            // if (changes.rowNode.currentValue.node.children) {
            //     if (!!changes.rowNode.currentValue.node.children.length !== !!changes.rowNode.previousValue.node.children.length) {
            //         this.reSetLines();
            //     }
            // }
            if (this.tt.showLines) {
                /** @type {?} */
                let currenChildrenLength = 0;
                /** @type {?} */
                let previousChildrenLength = 0;
                if (changes.rowNode.currentValue && changes.rowNode.currentValue.node.children) {
                    currenChildrenLength = changes.rowNode.currentValue.node.children.length;
                }
                if (changes.rowNode.previousValue && changes.rowNode.previousValue.node.children) {
                    previousChildrenLength = changes.rowNode.previousValue.node.children.length;
                }
                if (currenChildrenLength != previousChildrenLength || (!currenChildrenLength && !previousChildrenLength)) {
                    this.reSetLines();
                }
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.tt.bodyTemplate && this.showLines) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.reSetLines();
            }));
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        // this.isShowTriangle = this.showTriangle();
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        // if (this.tt && this.tt.data) {
        //     this.reSetLines();
        // }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unAllSubscriptions();
    }
    /**
     * @private
     * @return {?}
     */
    unAllSubscriptions() {
        this.subscriptions.forEach((/**
         * @param {?} s
         * @return {?}
         */
        s => {
            s.unsubscribe();
        }));
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    hasChildren() {
        /** @type {?} */
        const tn = this.rowNode.node;
        return tn.leaf === false || this.rowNode.level !== 0 || (tn.children && tn.children.length > 0);
    }
    /**
     * @return {?}
     */
    showTriangle() {
        /** @type {?} */
        const tn = this.rowNode.node;
        if (this.tt.loadDataType === 'all') {
            return tn.leaf === false || (tn.children && tn.children.length > 0);
        }
        else {
            return tn.leaf === false;
        }
    }
    /**
     * @return {?}
     */
    reSetLines() {
        if (this.togglerEl) {
            /** @type {?} */
            const parentEl = this.togglerEl.nativeElement.closest('.treetable-cell-content');
            if (parentEl) {
                /** @type {?} */
                const lineEls = parentEl.querySelectorAll('.treetable-lines');
                for (let k = 0; k < lineEls.length; k++) {
                    lineEls[k].remove();
                }
            }
        }
        this._renderLines();
    }
    /**
     * @private
     * @return {?}
     */
    _renderLines() {
        if (!this.tt.bodyTemplate) {
            if (this.showLines) {
                this.renderLines();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    noLineStyle() {
        // this.cls = false;
        if (this.togglerEl) {
            // this.render.setStyle(this.togglerEl.nativeElement, 'margin-left', `${this.rowNode.level * this.indentSpacing}px`);
            this.render.setStyle(this.togglerEl.nativeElement, 'visibility', this.isShowTriangle ? 'visible' : 'hidden');
            this.render.removeStyle(this.togglerEl.nativeElement, 'display');
        }
    }
    /**
     * @private
     * @return {?}
     */
    renderLines() {
        /** @type {?} */
        const len = this.rowNode.level;
        if (!this.togglerEl) {
            return;
        }
        /** @type {?} */
        const parentEl = this.togglerEl.nativeElement.closest('.treetable-cell-content');
        if (!parentEl) {
            return;
        }
        /** @type {?} */
        const referEl = this.togglerEl.nativeElement.parentElement;
        if (len === 0 && !this.showTriangle()) {
            this.createLeafNodeLines(referEl, parentEl, true);
        }
        for (let i = 0; i < len; i++) {
            parentEl.insertBefore(this.newLineElement(), referEl);
            /** @type {?} */
            const nearLine = this.newLineElement(false);
            parentEl.insertBefore(nearLine, referEl);
            /** @type {?} */
            const isLeaf = !this.showTriangle();
            if (isLeaf && i === len - 1) {
                this.createLeafNodeLines(referEl, parentEl);
            }
        }
    }
    /**
     * @private
     * @param {?=} border
     * @return {?}
     */
    newLineElement(border = true) {
        /** @type {?} */
        const newLineEl = this.render.createElement('div');
        this.render.addClass(newLineEl, 'treetable-lines');
        if (this.showLines) {
            if (border) {
                this.render.addClass(newLineEl, 'treetable-lines-border-color');
            }
        }
        return newLineEl;
    }
    /**
     * 构造 ∟ or ├
     * @private
     * @param {?} containerEl
     * @param {?} parentEl
     * @param {?=} isTopNode
     * @return {?}
     */
    createLeafNodeLines(containerEl, parentEl, isTopNode = false) {
        // ├
        // <div class="treetable-lines" style="border-color: rgb(204, 204, 204);"></div>
        // <div class="treetable-lines treetable-lines-leaf" style="border-color: transparent;">
        //     <div class="normal"></div>
        // </div>
        // ├
        // <div class="treetable-lines" style="border-color: rgb(204, 204, 204);"></div>
        // <div class="treetable-lines treetable-lines-leaf" style="border-color: transparent;">
        //     <div class="normal"></div>
        // </div>
        // ∟
        // <div class="treetable-lines" style="border-color: transparent"></div>
        // <div class="treetable-lines treetable-lines-leaf" style="border-color: transparent;">
        //     <div style="corner"></div>
        // </div>
        /** @type {?} */
        const l1 = this.newLineElement();
        /** @type {?} */
        const l2 = this.newLineElement(false);
        this.render.addClass(l2, 'treetable-lines-leaf');
        /** @type {?} */
        const dessert = this.render.createElement('div');
        if (this.showLines) {
            /** @type {?} */
            let cls = 'normal';
            if (this.rowNode.last) {
                cls = 'corner';
                this.render.removeClass(l1, 'treetable-lines-border-color');
            }
            l2.appendChild(dessert);
            this.render.addClass(dessert, cls);
            this.render.addClass(dessert, 'treetable-lines-border-color');
        }
        parentEl.insertBefore(l1, containerEl);
        parentEl.insertBefore(l2, containerEl);
        if (isTopNode) {
            this.render.setStyle(l2, 'marginRight', '3px');
        }
    }
    /**
     * @private
     * @return {?}
     */
    registerClickEvent() {
        if (this.togglerEl) {
            this.render.listen(this.togglerEl.nativeElement, 'click', this.onClick.bind(this));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.stopPropagation();
        event.preventDefault();
        if (this.rowNode.node['showLoading']) {
            return false;
        }
        if (!this.tt.disabled) {
            this.tt.toggleExpand(this.rowNode.node);
        }
        return false;
    }
    /**
     * @private
     * @param {?} treeNode
     * @return {?}
     */
    updateIcon(treeNode) {
        this.isShowTriangle = this.showTriangle();
        this.noChilds = this.hasChildren();
        this.treeNodeIcon = this.tt.getTreeIcon(treeNode);
    }
}
TreeTableTogglerComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-treeTableToggler',
                template: `
    <a #toggler style="cursor: pointer"
            class="treenode-fold" *ngIf="showLines"
            [ngClass]="rowNode.node.expanded ? tt.unfoldIcon : tt.foldIcon"
            [style.display]="isShowTriangle ? '' : 'none'"
            (click)="onClick($event)"></a>

    <a #toggler style="cursor: pointer"
            class="treenode-fold"  *ngIf="!showLines"
            [ngClass]="rowNode.node.expanded ? tt.unfoldIcon : tt.foldIcon"
            [style.marginLeft.px]="rowNode.level * indentSpacing"
            [style.visibility]="isShowTriangle ? 'visible' : 'hidden'"
            (click)="onClick($event)"></a>
    <span class="tree-icon-line" [style.display]="isShowTriangle && showLines? '' : 'none'"></span>
    <span [style.display]="(tt.showIcon && rowNode.node.showIcon) ? 'inline-block': 'none'" class="treenode-icon" [ngClass]="treeNodeIcon"></span>

    <tt-checkbox  [rowNode]="rowNode" *ngIf="tt.showCheckbox" [disabled]="disabled" [checked]="rowNode.isChecked" ></tt-checkbox>
    `,
                encapsulation: ViewEncapsulation.None,
                exportAs: 'ttToggler'
            }] }
];
/** @nocollapse */
TreeTableTogglerComponent.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: NgZone },
    { type: Renderer2 }
];
TreeTableTogglerComponent.propDecorators = {
    cls: [{ type: HostBinding, args: ['class.f-cmp-treetable-toggler',] }],
    rowNode: [{ type: Input }],
    disabled: [{ type: Input }],
    showLines: [{ type: Input }],
    indentSpacing: [{ type: Input }],
    togglerEl: [{ type: ViewChild, args: ['toggler',] }]
};
/**
 * 选中行组件
 */
class TreeTableSelectRowDirective {
    /**
     * @param {?} tt
     * @param {?} el
     * @param {?} render
     * @param {?} ngZone
     */
    constructor(tt, el, render, ngZone) {
        this.tt = tt;
        this.el = el;
        this.render = render;
        this.ngZone = ngZone;
        this.prevent = false;
        this.delay = 0;
        this.subscription = this.tt.selectNodeChangedSubject.subscribe((/**
         * @param {?} ids
         * @return {?}
         */
        (ids) => {
            if (ids && this.rowNode) {
                /** @type {?} */
                const idArr = ids.split(',');
                if (idArr.indexOf(this.rowNode.id) > -1) {
                    this.toggleClass();
                    this.rowNode.node['elementRef'] = this.el;
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // this.rowNode.node.selectable = !this.selectRowDisabled;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // if (changes.selectRowDisabled && !changes.selectRowDisabled.isFirstChange()) {
        //     this.rowNode.node.selectable = !changes.selectRowDisabled.currentValue;
        // }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.tt.bodyTemplate) {
            if (!this.tt.isSelected(this.rowNode.node)) {
                this.render.removeClass(this.el.nativeElement, 'farris-table-selectedrow');
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onclick(event) {
        if (this.isEnabled()) {
            // this.rowClick(event);
            if (this.delay !== 0) {
                if (!this.prevent) {
                    this.prevent = true;
                    this.timer = setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this.rowClick(event);
                        this.prevent = false;
                    }), this.delay);
                }
            }
            else {
                this.rowClick(event);
            }
        }
        // event.stopPropagation();
    }
    /**
     * @return {?}
     */
    isEnabled() {
        return !this.tt.disabled && this.selectRowDisabled !== true;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    rowClick(event) {
        event.stopPropagation();
        this.tt.beforeClickNode({ instance: this.tt, rowNode: this.rowNode, event, type: 'row' }).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (!e) {
                return;
            }
            this.tt.handleRowClick({
                originalEvent: event,
                rowNode: this.rowNode,
                rowIndex: this.rowIndex
            });
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.toggleClass();
            }));
        }));
    }
    /**
     * @return {?}
     */
    toggleClass() {
        if (!this.tt.bodyTemplate) {
            if (this.tt.isSelected(this.rowNode.node)) {
                if (this.tt.singleSelect) {
                    this.tt.el.nativeElement.querySelectorAll('.farris-treetable-tbody>tr.farris-table-selectedrow').forEach((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => {
                        this.render.removeClass(n, 'farris-table-selectedrow');
                    }));
                }
                this.render.addClass(this.el.nativeElement, 'farris-table-selectedrow');
            }
            else {
                if (!this.tt.keepSelect) {
                    this.render.removeClass(this.el.nativeElement, 'farris-table-selectedrow');
                }
            }
        }
    }
}
TreeTableSelectRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[selectRow]',
                exportAs: 'row'
            },] }
];
/** @nocollapse */
TreeTableSelectRowDirective.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
TreeTableSelectRowDirective.propDecorators = {
    rowNode: [{ type: Input, args: ['selectRow',] }],
    rowIndex: [{ type: Input }],
    selectRowDisabled: [{ type: Input }],
    delay: [{ type: Input }],
    onclick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/**
 * 表头全选组件
 */
class TreeTableHeaderCheckboxComponent {
    /**
     * @param {?} tt
     * @param {?} ttService
     */
    constructor(tt, ttService) {
        this.tt = tt;
        this.ttService = ttService;
        this.checkedChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} event
     * @return {?}
     */
    handleClick(event) {
        if (!this.disabled && !this.tt.disabled) {
            /** @type {?} */
            const beforeEvent = !this.checked ? this.tt.beforeCheckAll : this.tt.beforeUnCheckAll;
            this.tt['checkall_CLICKED'] = true;
            beforeEvent({ instance: this.tt, checked: !this.checked }).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            e => {
                // 全选功能
                this.chkAll.nativeElement.indeterminate = false;
                this.checked = !this.checked;
                this.tt.toggleNodesWithCheckbox(event, this.checked);
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.tt['checkall_CLICKED'] = false;
                }), 50);
            }));
        }
        event.stopPropagation();
        return false;
    }
}
TreeTableHeaderCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'tt-header-checkbox',
                template: `
    <div class="custom-control custom-checkbox  custom-control-inline tt-checkbox" style="top: -2px;">
        <input type="checkbox" #chkAll class="custom-control-input"  [checked]="checked">
        <label class="custom-control-label" (click)="handleClick($event)"></label>
    </div>
    `,
                styles: [`
        :host {
            vertical-align: middle;
        }
        `]
            }] }
];
/** @nocollapse */
TreeTableHeaderCheckboxComponent.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: TreetableService }
];
TreeTableHeaderCheckboxComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    checkedChange: [{ type: Output }],
    chkAll: [{ type: ViewChild, args: ['chkAll',] }]
};
/**
 * 表体checkbox 组件
 */
class TreeTableCheckboxComponent {
    /**
     * @param {?} tt
     * @param {?} ttService
     */
    constructor(tt, ttService) {
        this.tt = tt;
        this.ttService = ttService;
        this.cls1 = true;
        this.checkedChange = new EventEmitter();
        this.destroy$ = new Subject();
        this.ttService = this.tt.ttService;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.chk.nativeElement.indeterminate = this.rowNode.indeterminate || false;
        this.ttService.changeCheckboxStatus$.pipe(takeUntil(this.destroy$)).pipe(map((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (n.id === this.rowNode.id) {
                return n;
            }
            return null;
        }))).subscribe((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (n) {
                this.chk.nativeElement.indeterminate = n.indeterminate;
                this.checked = n.isChecked;
                this.chk.nativeElement.checked = this.checked;
            }
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleClick(event) {
        event.stopPropagation();
        if (!this.disabled) {
            this.tt.beforeClickNode({ instance: this.tt, rowNode: this.rowNode, event, type: 'checkbox' }).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (!e) {
                    return;
                }
                this.checked = !this.checked;
                if (this.tt.singleSelect) {
                    this.tt.clearAll();
                    if (this.checked) {
                        this.tt.selectNode(this.rowNode.id, true);
                    }
                    else {
                        this.tt.unSelectNode(this.rowNode.id, true);
                    }
                }
                else {
                    this.tt.toggleNodeWithCheckbox(event, this.rowNode, this.checked);
                }
            }));
        }
        return false;
    }
}
TreeTableCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'tt-checkbox',
                template: `
    <div class="custom-control custom-checkbox  custom-control-inline tt-checkbox">
        <input type="checkbox" #chk class="custom-control-input" [disabled]="disabled" [checked]="checked">
        <label class="custom-control-label" (click)="handleClick($event)"></label>
    </div>
    `,
                styles: [`
        :host {
            vertical-align: middle;
        }
        :host .custom-checkbox {
            opacity: 1;
            float: none;
        }
        `]
            }] }
];
/** @nocollapse */
TreeTableCheckboxComponent.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: TreetableService }
];
TreeTableCheckboxComponent.propDecorators = {
    cls1: [{ type: HostBinding, args: ['class.tree-toggler-checkbox',] }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    rowNode: [{ type: Input }],
    checkedChange: [{ type: Output }],
    chk: [{ type: ViewChild, args: ['chk',] }]
};
class DblClickRowDirective {
    /**
     * @param {?} tt
     * @param {?} el
     * @param {?} ttService
     * @param {?} selectRowDir
     */
    constructor(tt, el, ttService, selectRowDir) {
        this.tt = tt;
        this.el = el;
        this.ttService = ttService;
        this.selectRowDir = selectRowDir;
        this.enableDblClick = false;
        this.ttService = this.tt.ttService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.enableDblClick) {
            this.selectRowDir.delay = 0;
        }
        else {
            this.selectRowDir.delay = 200;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    ondblclick(event) {
        /** @type {?} */
        const prevEl = ((/** @type {?} */ (event.target))).previousSibling;
        if (prevEl && prevEl.type === 'checkbox') {
            return;
        }
        if (this.tt.disabled) {
            return false;
        }
        if (this.tt.multiSelect && this.dblclickNode) {
            if (this.dblclickNode.node.leaf) {
                return false;
            }
        }
        /** @type {?} */
        const clsName = event.target['className'];
        /** @type {?} */
        let togglerTag = null;
        if (clsName.indexOf('f-cmp-treetable-toggler') > -1) {
            togglerTag = event.target['querySelector']('.treenode-fold');
        }
        else {
            if (event.target['className'].indexOf('treenode-fold') > -1) {
                togglerTag = (/** @type {?} */ (event.target));
            }
        }
        if (togglerTag && togglerTag.style.visibility === 'visible') {
            return false;
        }
        if (this.selectRowDir) {
            this.selectRowDir.prevent = false;
            clearTimeout(this.selectRowDir.timer);
            if (this.selectRowDir.rowNode && this.enableDblClick) {
                /** @type {?} */
                const rn = this.selectRowDir.rowNode;
                if (rn.node.children && rn.node.children.length && !rn.node.leaf && this.tt.dblClickExpand) {
                    this.tt.toggleExpand(rn.node);
                }
                this.tt.dblClick.emit(rn.node);
            }
        }
        // event.stopPropagation();
    }
}
DblClickRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dblclick]'
            },] }
];
/** @nocollapse */
DblClickRowDirective.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: ElementRef },
    { type: TreetableService },
    { type: TreeTableSelectRowDirective, decorators: [{ type: Optional }, { type: Self }] }
];
DblClickRowDirective.propDecorators = {
    enableDblClick: [{ type: Input, args: ['dblclick',] }],
    dblclickNode: [{ type: Input }],
    ondblclick: [{ type: HostListener, args: ['dblclick', ['$event'],] }]
};
class CustomRowStyleDirective {
    /**
     * @param {?} injector
     * @param {?} ngZone
     * @param {?} el
     * @param {?} tt
     * @param {?} utils
     * @param {?} render
     */
    constructor(injector, ngZone, el, tt, utils, render) {
        this.injector = injector;
        this.ngZone = ngZone;
        this.el = el;
        this.tt = tt;
        this.utils = utils;
        this.render = render;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.col && this.tt.fixedColumns && this.tt.fixedHeader && this.col.fixed) {
            if (this.col.fixed === 'left' || this.col.fixed === 'right') {
                this.setRowStyle();
            }
            return;
        }
        else {
            this.setRowStyle();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setRowStyle() {
        /** @type {?} */
        const fn = this.tt.rowStyler;
        if (fn) {
            /** @type {?} */
            const sty = fn(this.rowNode.node);
            if (sty) {
                if (typeof sty === 'object' && (sty.style || sty.cls)) {
                    if (sty.style) {
                        Object.keys(sty.style).forEach((/**
                         * @param {?} s
                         * @return {?}
                         */
                        s => {
                            this.render.setStyle(this.el.nativeElement, s, sty.style[s]);
                        }));
                    }
                    if (sty.cls) {
                        sty.cls.split(',').forEach((/**
                         * @param {?} c
                         * @return {?}
                         */
                        c => {
                            this.render.addClass(this.el.nativeElement, c);
                        }));
                    }
                }
                else {
                    if (Array.isArray(sty) || typeof sty === 'string') {
                        /** @type {?} */
                        const cls = this.tt.getRowCls(this.rowNode);
                        if (cls && Object.keys(cls).length) {
                            Object.keys(cls).forEach((/**
                             * @param {?} c
                             * @return {?}
                             */
                            c => {
                                if (cls[c]) {
                                    this.render.addClass(this.el.nativeElement, c);
                                }
                            }));
                        }
                    }
                    else {
                        Object.keys(sty).forEach((/**
                         * @param {?} s
                         * @return {?}
                         */
                        s => {
                            this.render.setStyle(this.el.nativeElement, s, sty[s]);
                        }));
                    }
                }
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.rowNode && !changes.rowNode.isFirstChange()) {
            this.setRowStyle();
        }
    }
}
CustomRowStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[customRowStyle]'
            },] }
];
/** @nocollapse */
CustomRowStyleDirective.ctorParameters = () => [
    { type: Injector },
    { type: NgZone },
    { type: ElementRef },
    { type: TreeTableComponent },
    { type: CommonUtils },
    { type: Renderer2 }
];
CustomRowStyleDirective.propDecorators = {
    rowNode: [{ type: Input, args: ['customRowStyle',] }],
    col: [{ type: Input, args: ['field',] }]
};
class TTCustomCellStyleDirective {
    /**
     * @param {?} injector
     * @param {?} ngZone
     * @param {?} el
     * @param {?} tt
     * @param {?} utils
     * @param {?} render
     */
    constructor(injector, ngZone, el, tt, utils, render) {
        this.injector = injector;
        this.ngZone = ngZone;
        this.el = el;
        this.tt = tt;
        this.utils = utils;
        this.render = render;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.tt && this.tt.getCellCls) {
            this.setCellStyle();
        }
        if (!this.tt.showBorder && this.tt.columns.length === 1) {
            this.render.setStyle(this.el.nativeElement, 'border-width', '0px');
        }
    }
    /**
     * @private
     * @return {?}
     */
    setCellStyle() {
        /** @type {?} */
        const cellCls = this.tt.getCellCls(this.rowNode, this.column.field);
        if (this.column && this.column.styler) {
            if (cellCls && Object.keys(cellCls).length) {
                Object.keys(cellCls).forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => {
                    if (cellCls[c]) {
                        this.render.addClass(this.el.nativeElement, c);
                    }
                }));
            }
            /** @type {?} */
            const rowData = this.rowNode.node.data;
            /** @type {?} */
            const ccs = this.column.styler(this.utils.getValue(this.column.field, rowData), rowData, this.rowIndex, this.rowNode);
            if (ccs) {
                if (ccs.style || ccs.cls) {
                    if (ccs.style) {
                        Object.keys(ccs.style).forEach((/**
                         * @param {?} s
                         * @return {?}
                         */
                        s => {
                            this.render.setStyle(this.el.nativeElement, s, ccs.style[s]);
                        }));
                    }
                    if (ccs.cls) {
                        ccs.cls.split(',').forEach((/**
                         * @param {?} c
                         * @return {?}
                         */
                        c => {
                            if (c[0] === '!') {
                                this.render.removeClass(this.el.nativeElement, c.substring(1));
                            }
                            else {
                                this.render.addClass(this.el.nativeElement, c);
                            }
                        }));
                    }
                }
            }
        }
        else {
            /** @type {?} */
            let _sty = cellCls || {};
            /** @type {?} */
            const rowStyle = this.tt.getRowCls(this.rowNode) || {};
            /** @type {?} */
            const hasBackground = Object.keys(cellCls).find((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                return ['background', 'background-color', 'backgroundcolor'].indexOf(n.toLowerCase()) > -1;
            }));
            /** @type {?} */
            let _rowStyles = rowStyle;
            if (rowStyle.style) {
                _rowStyles = rowStyle.style;
            }
            /** @type {?} */
            let _cellStyles = _sty;
            if (_sty.style) {
                _cellStyles = _sty.style;
            }
            if (hasBackground) {
                _sty = Object.assign(_rowStyles, _cellStyles);
            }
            else {
                _sty = Object.assign(_cellStyles, _rowStyles);
            }
            Object.keys(_sty).forEach((/**
             * @param {?} s
             * @return {?}
             */
            s => {
                this.render.setStyle(this.el.nativeElement, s, _sty[s]);
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.rowNode && !changes.rowNode.isFirstChange()) {
            this.setCellStyle();
        }
    }
}
TTCustomCellStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[customCellStyle]'
            },] }
];
/** @nocollapse */
TTCustomCellStyleDirective.ctorParameters = () => [
    { type: Injector },
    { type: NgZone },
    { type: ElementRef },
    { type: TreeTableComponent },
    { type: CommonUtils },
    { type: Renderer2 }
];
TTCustomCellStyleDirective.propDecorators = {
    column: [{ type: Input, args: ['customCellStyle',] }],
    rowNode: [{ type: Input }],
    rowIndex: [{ type: Input }]
};
class TTResizableColumnDirective {
    /**
     * @param {?} tt
     * @param {?} ngzone
     * @param {?} el
     * @param {?} render
     */
    constructor(tt, ngzone, el, render) {
        this.tt = tt;
        this.ngzone = ngzone;
        this.el = el;
        this.render = render;
        this.enableResize = true;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.isEnable()) {
            this.render.addClass(this.el.nativeElement, 'resizable-column');
            this.resizer = document.createElement('span');
            this.resizer.className = 'column-resizer';
            this.el.nativeElement.appendChild(this.resizer);
            this.ngzone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.resizerMouseDownListener = this.onMouseDown.bind(this);
                this.resizer.addEventListener('mousedown', this.resizerMouseDownListener);
                this.el.nativeElement.addEventListener('mouseenter', this.onMouseEnter.bind(this));
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.enableResize && !changes.enableResize.isFirstChange()) {
            if (!this.isEnable() && this.resizer) {
                this.resizer.remove();
            }
        }
    }
    /**
     * @return {?}
     */
    isEnable() {
        return this.tt.resizableColumns && !this.tt.autoWidth && this.enableResize;
    }
    /**
     * @return {?}
     */
    bindDocumentEvents() {
        this.ngzone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.documentMouseMoveListener = this.onMouseMove.bind(this);
            document.addEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseUpListener = this.onMouseUp.bind(this);
            document.addEventListener('mouseup', this.documentMouseUpListener);
        }));
    }
    /**
     * @return {?}
     */
    unbindDocumentEvents() {
        if (this.documentMouseMoveListener) {
            document.removeEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseMoveListener = null;
        }
        if (this.documentMouseUpListener) {
            document.removeEventListener('mouseup', this.documentMouseUpListener);
            this.documentMouseUpListener = null;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        if (this.isEnable()) {
            this.tt.onColumnResizeBegin(event);
            this.bindDocumentEvents();
        }
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        this.tt.onColumnResize(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        this.tt.onColumnResizeEnd(event, this.el.nativeElement);
        this.unbindDocumentEvents();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.resizerMouseDownListener) {
            this.resizer.removeEventListener('mousedown', this.resizerMouseDownListener);
        }
        this.unbindDocumentEvents();
    }
}
TTResizableColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: '[resizable-column]'
            },] }
];
/** @nocollapse */
TTResizableColumnDirective.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 }
];
TTResizableColumnDirective.propDecorators = {
    enableResize: [{ type: Input, args: ['resizable-column',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FindInputComponent {
    /**
     * @param {?} el
     * @param {?} ngZone
     * @param {?} injector
     */
    constructor(el, ngZone, injector) {
        this.el = el;
        this.ngZone = ngZone;
        this.injector = injector;
        this.current = 0;
        this.count = 0;
        this.columns = [];
        this.close = new EventEmitter();
        this.valueChanged = new EventEmitter();
        this.enterHandler = new EventEmitter();
        this.findField = '';
        this.keyupEventSub = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.columns.length) {
            this.columns = this.columns.filter((/**
             * @param {?} c
             * @return {?}
             */
            c => !c.formatter && c.field));
            this.findField = this.columns[0].field;
        }
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.keyupEventSub = fromEvent(this.input.nativeElement, 'keyup').pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            (e) => (e.switch || e.keyCode) !== 13)), debounceTime(200), map((/**
             * @param {?} e
             * @return {?}
             */
            (e) => e.target.value))).subscribe((/**
             * @param {?} v
             * @return {?}
             */
            (v) => {
                this.valueChanged.emit({ value: v, field: this.findField });
            }));
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.input.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.keyupEventSub) {
            this.keyupEventSub.unsubscribe();
        }
        this.keyupEventSub = null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClose(event) {
        this.close.emit();
        return false;
    }
    /**
     * @param {?} $event
     * @param {?} step
     * @return {?}
     */
    onEnter($event, step) {
        this.enterHandler.emit(step);
        return false;
    }
}
FindInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'find-input',
                template: `
        <div class="f-find-input" style="">
            <div class="input-group">
                <div class="input-group-prepend">
                    <select class="form-control" [(ngModel)]="findField">
                        <option *ngFor="let col of columns" value="{{col.field}}">{{ col.title }}</option>
                    </select>
                </div>
                <input #input type="text" placeholder="至少2个字符" class="form-control"
                    (keydown.esc)="onClose($event)" (keydown.enter)="onEnter($event, 0)">
                <div class="input-group-append">
                    <span class="input-group-text">{{current}}/{{count}}</span>
                    <button class="btn btn-outline-secondary" type="button" title="上一个"
                        [disabled]="current === 0" (click)="onEnter($event, -1)">
                        <span class="f-icon f-icon-arrow-chevron-up"></span>
                    </button>
                    <button class="btn btn-outline-secondary" type="button" title="下一个"
                    [disabled]="current === count" (click)="onEnter($event, 1)">
                        <span class="f-icon f-icon-arrow-chevron-down"></span>
                    </button>
                    <button class="btn btn-outline-secondary" type="button" title="关闭" (click)="onClose($event)">
                        <span class="f-icon f-icon-close"></span>
                    </button>
                </div>
            </div>
        </div>
    `,
                styles: [`
        .f-find-input {
            width: 300px; height: 40px; background: #fefefe; position: absolute; right: 0; z-index: 10; padding: 5px;
            box-shadow: 0px 1px 7px 0px #bdbdbd;
            border-radius: 6px;
        }
        .f-find-input .input-group-text { border-right: 1px solid #ccc; font-size: 10px }
        .f-find-input .input-group-append { background: #fff; }
        .f-find-input .input-group-append button { padding:1px 6px;}
        .f-find-input .input-group-append button span{position: relative; top: 2px;}
        `]
            }] }
];
/** @nocollapse */
FindInputComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Injector }
];
FindInputComponent.propDecorators = {
    current: [{ type: Input }],
    count: [{ type: Input }],
    columns: [{ type: Input }],
    close: [{ type: Output }],
    valueChanged: [{ type: Output }],
    enterHandler: [{ type: Output }],
    input: [{ type: ViewChild, args: ['input',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreetableNodesPagerComponent {
    /**
     * @param {?} tt
     * @param {?} cd
     * @param {?} injector
     */
    constructor(tt, cd, injector) {
        this.tt = tt;
        this.cd = cd;
        this.injector = injector;
        this.disabled = false;
        this.pageChange = new EventEmitter();
        this.showTotal = false;
        this.showPager = new BehaviorSubject(false);
        this.pagerInfo = null;
        if (this.tt) {
            this.tt.expand.pipe(filter((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                return node.id === this.context.node.id && node.pagination && node.children.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => !n.__childs_loading__)).length;
            }))).subscribe((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                this.pagerInfo = Object.assign({}, node.pagination);
                this.showPager.next(true);
            }));
            this.tt.appendNew.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                /** @type {?} */
                const node = e.parent;
                if (node.id === this.context.node.id && node.pagination) {
                    this.pagerInfo = Object.assign({}, node.pagination);
                    this.showPager.next(true);
                }
            }));
            this.tt.collapse.subscribe((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                if (node.id === this.context.node.id) {
                    this.showPager.next(false);
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    get pagers() {
        /** @type {?} */
        const c = this.getPagerCount();
        if (c) {
            return new Array(c);
        }
        return [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setPagerInfo();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.context && !changes.context.isFirstChange()) {
            this.setPagerInfo();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setPagerInfo() {
        if (this.context) {
            const { node } = this.context;
            if (node && node.pagination) {
                this.pagerInfo = Object.assign({}, node.pagination);
                this.showPager.next(node.expanded && node.pagination);
            }
        }
    }
    /**
     * @return {?}
     */
    getPagerCount() {
        const { pageSize, total } = this.pagerInfo;
        if (!total) {
            return 0;
        }
        else {
            return Math.ceil(total / pageSize);
        }
    }
    /**
     * @return {?}
     */
    isFirstPager() {
        return this.pagerInfo.pageIndex === 1;
    }
    /**
     * @return {?}
     */
    isLastPager() {
        return this.pagerInfo.pageIndex === this.getPagerCount();
    }
    /**
     * Go to the previous page
     * @param {?} $event
     * @return {?}
     */
    previous($event) {
        $event.stopPropagation();
        this.setCurrent(this.pagerInfo.pageIndex - 1, this.pagerInfo.pageSize);
    }
    /**
     * Go to the next page
     * @param {?} $event
     * @return {?}
     */
    next($event) {
        $event.stopPropagation();
        this.setCurrent(this.pagerInfo.pageIndex + 1, this.pagerInfo.pageSize);
    }
    /**
     * @param {?} page
     * @param {?=} pageSize
     * @param {?=} $event
     * @return {?}
     */
    setCurrent(page, pageSize, $event) {
        if ($event) {
            $event.stopPropagation();
        }
        this.pageChange.emit({ pageIndex: page, pageSize, node: this.context.node, context: this.context });
    }
    /**
     * @param {?} newPageIndex
     * @return {?}
     */
    pagerChanged(newPageIndex) {
        this.setCurrent(newPageIndex, this.pagerInfo.pageSize);
    }
}
TreetableNodesPagerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nodes-pager',
                template: "\r\n<div style=\"justify-content: center;align-items: center;height: 100%;left: -6px;position: relative;\" class=\"d-flex f-utils-fill\" *ngIf=\"showPager | async\"  [ngStyle]=\" { 'opacity': (disabled ? 0.6 : 1), 'pointer-events': (disabled? 'none': '')  }\">\r\n    <ul class=\"treetable-nodes-pagerbar d-flex\"  (click)=\"$event.stopPropagation()\" >\r\n        <li class=\"pageinfo d-flex flex-row\" >\r\n            <div class=\"page-number-list\">\r\n                <div style=\"display: inline-block;\">\r\n                    {{pagerInfo.pageIndex}}\r\n                </div>\r\n                <select #pagerList class=\"page-index\" hidefocus=\"true\" [ngModel]=\"pagerInfo.pageIndex\" (ngModelChange)=\"pagerChanged($event)\">\r\n                    <option *ngFor=\"let t of pagers;let i=index\" [ngValue]=\"i + 1\">{{i + 1}}</option>\r\n                </select>\r\n            </div>\r\n           / {{ getPagerCount() }}</li>\r\n        <li class=\"pager-btn prev\" [class.disabled]=\"isFirstPager()\" (click)=\"previous($event)\" title=\"{{ 'pagination.previous'|locale: '\u4E0A\u4E00\u9875' }}\">\r\n            <span class=\"f-icon f-icon-arrow-chevron-left\"></span>\r\n        </li>\r\n        <li class=\"pager-btn next\"  [class.disabled]=\"isLastPager()\" (click)=\"next($event)\" title=\"{{ 'pagination.next'|locale: '\u4E0B\u4E00\u9875' }}\">\r\n            <span class=\"f-icon f-icon-arrow-chevron-right\"></span>\r\n        </li>\r\n        <li class=\"ml-2\" *ngIf=\"showTotal\">\r\n            {{pagerInfo?.total}}\r\n        </li>\r\n    </ul>\r\n\r\n</div>",
                styles: [`
        .treetable-nodes-pagerbar { height: 22px; line-height: 22px; list-style: none}
        .treetable-nodes-pagerbar li { float: left; box-sizing: border-box; }
        .treetable-nodes-pagerbar .pager-btn {
            width: 22px;
            height: 22px;
            text-align: center;
            border: 1px solid #ccc;
            background: rgb(248 249 250);
            cursor: pointer;
        }
        .treetable-nodes-pagerbar .pager-btn:hover {
            background: white;
        }
        .treetable-nodes-pagerbar .prev {}
        .treetable-nodes-pagerbar .next {
            border-left: 0;
        }

        .pager-btn.disabled{
            color: rgb(204 204 204);
            pointer-events: none;
        }
        .treetable-nodes-pagerbar .pageinfo {
            margin-right: 5px;
            padding-left: 0;
            font-weight: 400;
            padding-right: 5px;
        }

        .treetable-nodes-pagerbar .page-index {
            border: 0;
            background: transparent;
            outline: none;
            appearance: none;
            padding-left: 5px;
            min-width: 50px;
            position: absolute;
            height: 20px;
            text-align: left;
            opacity: 0;
            left: 0;
        }

        .treetable-nodes-pagerbar .page-number-list {
            height: 20px;
            min-width: 30px;
            max-width: 50px;
            overflow: hidden;
            text-align: center;
            position: relative;
            border-bottom: 1px solid #ced4da;
        }
        `]
            }] }
];
/** @nocollapse */
TreetableNodesPagerComponent.ctorParameters = () => [
    { type: TreeTableComponent },
    { type: ChangeDetectorRef },
    { type: Injector }
];
TreetableNodesPagerComponent.propDecorators = {
    disabled: [{ type: Input }],
    context: [{ type: Input }],
    pagerListEl: [{ type: ViewChild, args: ['pagerList',] }],
    pageChange: [{ type: Output }],
    showTotal: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ChildsLoadingComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
ChildsLoadingComponent.decorators = [
    { type: Component, args: [{
                selector: 'childs-loading',
                template: `
    <div class="loading">
        <span></span>
        <span></span>
        <span></span>
        <span></span>
        <span></span>
    </div>
    `,
                styles: [`
        .loading{
            width: 150px;
            height: 10px;
            margin: 0 auto;
            margin-top:10px;
            margin-bottom: 20px;
        }
        .loading span{
            display: inline-block;
            width: 10px;
            height: 100%;
            margin-right: 5px;
            border-radius: 50%;
            background: #59a1ff;
            -webkit-animation: load 1.04s ease infinite;
        }
        .loading span:last-child{
            margin-right: 0px;
        }
        @-webkit-keyframes load{
            0%{
                opacity: 1;
                -webkit-transform: scale(1.3);
            }
            100%{
                opacity: 0.2;
                -webkit-transform: scale(.3);
            }
        }
        .loading span:nth-child(1){
            -webkit-animation-delay:0.13s;
        }
        .loading span:nth-child(2){
            -webkit-animation-delay:0.26s;
        }
        .loading span:nth-child(3){
            -webkit-animation-delay:0.39s;
        }
        .loading span:nth-child(4){
            -webkit-animation-delay:0.52s;
        }
        .loading span:nth-child(5){
            -webkit-animation-delay:0.65s;
        }
        `]
            }] }
];
/** @nocollapse */
ChildsLoadingComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CellTipsPipe {
    /**
     * @param {?} commonUtils
     */
    constructor(commonUtils) {
        this.commonUtils = commonUtils;
    }
    /**
     * @param {?} col
     * @param {...?} args
     * @return {?}
     */
    transform(col, ...args) {
        if (col.showTips) {
            return this.getCellTooltipContent(col, args[0]);
        }
        return '';
    }
    /**
     * @private
     * @param {?} col
     * @param {?} tn
     * @return {?}
     */
    getCellTooltipContent(col, tn) {
        /** @type {?} */
        let txt = this.commonUtils.getValue(col.field, tn.data);
        if (col.tipContent) {
            if (typeof col.tipContent === 'string') {
                txt = col.tipContent;
            }
            else if (typeof col.tipContent === 'function') {
                txt = col.tipContent(txt, tn.data, col);
            }
        }
        else {
            if (col.formatter) {
                if (typeof col.formatter === 'object') {
                    if (col.formatter.type === 'enum') {
                        txt = this.commonUtils.getEnumTitleFromColumnOptions(txt, col.formatter.options);
                    }
                }
            }
        }
        return txt;
    }
}
CellTipsPipe.decorators = [
    { type: Pipe, args: [{ name: 'tipmsg' },] }
];
/** @nocollapse */
CellTipsPipe.ctorParameters = () => [
    { type: CommonUtils }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DisableNodePipe {
    /**
     * @param {?} node
     * @param {...?} args
     * @return {?}
     */
    transform(node, ...args) {
        /** @type {?} */
        const selectable = !node.selectable;
        /** @type {?} */
        let selectable2 = false;
        if (args && args.length) {
            if (args[0]) {
                selectable2 = args[0]({ node });
            }
            if (args[1]) { // 树表禁用
                return true;
            }
        }
        return selectable || selectable2;
    }
}
DisableNodePipe.decorators = [
    { type: Pipe, args: [{ name: 'disablenode' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeTableModule {
}
TreeTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    FarrisCommonModule.forRoot(),
                    PerfectScrollbarModule,
                    InputGroupModule,
                    LocaleModule.forRoot(),
                    DataColumnModule.forRoot(),
                    PaginationModule,
                    FarrisContextMenuModule,
                    FarrisFormsModule
                ],
                declarations: [
                    TreeTableComponent,
                    TTBodyComponent,
                    TreeTableTogglerComponent,
                    TreeTableSelectRowDirective,
                    TreeTableCheckboxComponent,
                    TreeTableHeaderCheckboxComponent,
                    DblClickRowDirective,
                    TTResizableColumnDirective,
                    TreeTableColumnDirective,
                    TTCustomCellStyleDirective,
                    FindInputComponent,
                    HighlightPipe,
                    CustomRowStyleDirective,
                    TreetableNodesPagerComponent,
                    ChildsLoadingComponent,
                    CellTipsPipe,
                    DisableNodePipe
                ],
                exports: [
                    TreeTableComponent,
                    TTBodyComponent,
                    TreeTableTogglerComponent,
                    TreeTableSelectRowDirective,
                    TreeTableCheckboxComponent,
                    TreeTableHeaderCheckboxComponent,
                    DblClickRowDirective,
                    TTResizableColumnDirective,
                    FarrisCommonModule,
                    TTCustomCellStyleDirective,
                    TreeTableColumnDirective,
                    HighlightPipe,
                    CustomRowStyleDirective,
                    TreetableNodesPagerComponent,
                    ChildsLoadingComponent,
                    CellTipsPipe,
                    DisableNodePipe,
                    FarrisContextMenuModule
                ],
                providers: [
                    TreetableService,
                    ResizeService,
                    TTHotkeys
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TreetableService, FindInputComponent, HighlightPipe, TTHotkeys, TreetableNodesPagerComponent, ChildsLoadingComponent, CellTipsPipe, DisableNodePipe, TreeTableModule, TreeTableColumnDirective, TreeTableComponent, TTBodyComponent, TreeTableTogglerComponent, TreeTableSelectRowDirective, TreeTableHeaderCheckboxComponent, TreeTableCheckboxComponent, DblClickRowDirective, CustomRowStyleDirective, TTCustomCellStyleDirective, TTResizableColumnDirective };

//# sourceMappingURL=farris-ui-treetable.js.map