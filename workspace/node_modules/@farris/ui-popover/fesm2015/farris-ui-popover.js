import { isBs3 } from '@farris/ui-modal/utils';
import { Subject } from 'rxjs';
import { Injectable, Directive, ElementRef, Input, Output, Renderer2, ViewContainerRef, Optional, Injector, NgZone, NgModule, ChangeDetectionStrategy, Component, ViewChild, defineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ComponentLoaderFactory } from '@farris/ui-modal/component-loader';
import { PositioningService } from '@farris/ui-modal/positioning';
import { CommonUtils, OverLayHiddenService, FarrisCommonModule } from '@farris/ui-common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the Popover directive.
 * You can inject this service, typically in your root component, and customize
 * the values of its properties in order to provide default values for all the
 * popovers used in the application.
 */
class PopoverConfig {
    constructor() {
        /**
         * Placement of a popover. Accepts: "top", "bottom", "left", "right", "auto"
         */
        this.placement = 'top';
        /**
         * Specifies events that should trigger. Supports a space separated list of
         * event names.
         */
        this.triggers = 'click';
        this.outsideClick = true;
    }
}
PopoverConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ PopoverConfig.ngInjectableDef = defineInjectable({ factory: function PopoverConfig_Factory() { return new PopoverConfig(); }, token: PopoverConfig, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverContainerComponent {
    /**
     * @param {?} config
     * @param {?} el
     */
    constructor(config, el) {
        this.el = el;
        this.mounseState = new Subject();
        Object.assign(this, config);
    }
    /**
     * @return {?}
     */
    get isBs3() {
        return isBs3();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.el) {
            this.mouseenterEvent = this.changeMouseState.bind(this, true);
            this.mouseleaveEvent = this.changeMouseState.bind(this, false);
            this.el.nativeElement.addEventListener('mouseenter', this.mouseenterEvent);
            this.el.nativeElement.addEventListener('mouseleave', this.mouseleaveEvent);
        }
    }
    /**
     * 获取鼠标变化状态
     * @return {?}
     */
    getMouseState() {
        return this.mounseState;
    }
    /**
     * 绑定的事件
     * @private
     * @param {?} state
     * @return {?}
     */
    changeMouseState(state) {
        this.mounseState.next(state);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.mouseenterEvent) {
            this.el.nativeElement.removeEventListener('mouseenter', this.mouseenterEvent);
        }
        if (this.mouseleaveEvent) {
            this.el.nativeElement.removeEventListener('mouseleave', this.mouseleaveEvent);
        }
        this.mounseState.unsubscribe();
    }
}
PopoverContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-popover',
                changeDetection: ChangeDetectionStrategy.OnPush,
                // tslint:disable-next-line
                host: {
                    '[class]': '"popover in popover-" + placement + " " + "bs-popover-" + placement + " " + placement + " " + containerClass',
                    '[class.show]': '!isBs3',
                    '[class.bs3]': 'isBs3',
                    role: 'tooltip',
                    style: 'display:block;'
                },
                template: "<div class=\"popover-arrow arrow\"></div>\r\n<h3 class=\"popover-title popover-header\" *ngIf=\"title\">{{ title }}</h3>\r\n<div #innerEle class=\"popover-content popover-body\" [ngClass]=\"containerClass\">\r\n  <ng-content></ng-content>\r\n</div>\r\n",
                styles: [`
    :host.bs3.popover-top {
      margin-bottom: 10px;
    }
    :host.bs3.popover.top>.arrow {
      margin-left: -2px;
    }
    :host.bs3.popover.top {
      margin-bottom: 10px;
    }
    :host.popover.bottom>.arrow {
      margin-left: -4px;
    }
    :host.bs3.bs-popover-left {
      margin-right: .5rem;
    }
    :host.bs3.bs-popover-right .arrow, :host.bs3.bs-popover-left .arrow{
      margin: .3rem 0;
    }
    :host.arrow-left .arrow {
        left: calc(50% - 10px);
    }
    `]
            }] }
];
/** @nocollapse */
PopoverContainerComponent.ctorParameters = () => [
    { type: PopoverConfig },
    { type: ElementRef, decorators: [{ type: Optional }] }
];
PopoverContainerComponent.propDecorators = {
    innerNode: [{ type: ViewChild, args: ['innerEle', { read: ElementRef },] }],
    placement: [{ type: Input }],
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A lightweight, extensible directive for fancy popover creation.
 */
class PopoverDirective {
    /**
     * @param {?} _config
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} _viewContainerRef
     * @param {?} cis
     * @param {?} _positionService
     * @param {?} inject
     */
    constructor(_config, _elementRef, _renderer, _viewContainerRef, cis, _positionService, inject) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._positionService = _positionService;
        this.inject = inject;
        /**
         * Close popover on outside click
         */
        this.outsideClick = true;
        /**
         * A selector specifying the element the popover should be appended to.
         */
        this.container = 'body';
        /**
         * Css class for popover container
         */
        this.containerClass = '';
        // 按条件激活
        this.popActive = true;
        // 显示动作
        this.showAction = 'show';
        this.isFixed = false;
        this._isInited = false;
        // 标记是否进入提示框内
        this.containerInOutState = false;
        this._bodyOverflow = '';
        if (this.inject) {
            this.ngZone = this.inject.get(NgZone, null);
            this.overlaySer = this.inject.get(OverLayHiddenService, null);
            this.commonUtils = this.inject.get(CommonUtils, new CommonUtils());
        }
        this._popover = cis
            .createLoader(_elementRef, _viewContainerRef, _renderer)
            .provide({ provide: PopoverConfig, useValue: _config });
        Object.assign(this, _config);
        this.onShown = this._popover.onShown;
        this.onHidden = this._popover.onHidden;
        // fix: no focus on button on Mac OS #1795
        if (typeof window !== 'undefined') {
            _elementRef.nativeElement.addEventListener('click', (/**
             * @return {?}
             */
            function () {
                try {
                    _elementRef.nativeElement.focus();
                }
                catch (err) {
                    return;
                }
            }));
        }
        if (!this.overlaySer) {
            this.overlaySer = new OverLayHiddenService();
        }
    }
    /**
     * Returns whether or not the popover is currently being shown
     * @return {?}
     */
    get isOpen() {
        return this._popover.isShown;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        if (value) {
            this[this.showAction]();
        }
        else {
            this.hide();
        }
    }
    /**
     * @private
     * @return {?}
     */
    hasScrollbarY() {
        if (!this._bodyOverflow) {
            this._bodyOverflow = getComputedStyle(document.body).overflow;
        }
        return document.body.scrollHeight > window.innerHeight && this._bodyOverflow !== 'hidden';
    }
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    show() {
        if (!this.popActive || this._popover.isShown || !this.popover) {
            return;
        }
        this._popover
            .attach(PopoverContainerComponent)
            .to(this.container)
            .position({ attachment: this.placement })
            .show({
            showType: "popover",
            content: this.popover,
            context: this.popoverContext,
            placement: this.placement,
            title: this.popoverTitle,
            containerClass: this.containerClass,
        });
        // if (!this.hasScrollbarY()) {
        //     this._renderer.addClass(document.body, 'f-loading-dot-wrapper');
        // }
        /*解决插入到body里的层级问题*/
        /** @type {?} */
        const zIndex = this.commonUtils.getFloatingLayerIndex();
        this._popover.instance['el'].nativeElement.style.position = 'fixed';
        this._popover.instance['el'].nativeElement.style.zIndex = zIndex;
        this.overlaySer.registerMouseEvent(this._elementRef.nativeElement, (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            /** @type {?} */
            const target = (/** @type {?} */ (e.target));
            if (this._popover.instance['el'].nativeElement.contains(target) ||
                target.closest('.overlay-pane')) {
                return;
            }
            this.hide();
        }));
        // this.isOpen = true;
        if (this.triggers == 'hover' && this._popover.instance && this._popover.instance.getMouseState) {
            this._popover.instance.getMouseState().subscribe((/**
             * @param {?} state
             * @return {?}
             */
            (state) => {
                this.containerInOutState = state;
                if (!state) {
                    this.hide();
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    show2() {
        if (!this.popActive || this._popover.isShown || !this.popover) {
            return;
        }
        /** @type {?} */
        const targetRef = this._popover
            .attach(PopoverContainerComponent)
            .to(this.container)
            .show({
            content: this.popover,
            context: this.popoverContext,
            placement: this.placement,
            title: this.popoverTitle,
            containerClass: this.containerClass
        });
        this.overlaySer.registerMouseEvent(this._elementRef.nativeElement, (/**
         * @return {?}
         */
        () => {
            this.hide();
        }));
        //this.isOpen = true;
        const { height: hostHeight, width: hostWidth, top, left } = this._elementRef.nativeElement.getBoundingClientRect();
        const { height: targetHeight, width: targetWidth } = targetRef.location.nativeElement.getBoundingClientRect();
        /** @type {?} */
        let targetTop;
        /** @type {?} */
        let targetLeft;
        switch (this.placement) {
            case 'bottom':
                targetTop = `${top - targetHeight - 8}px`;
                targetLeft = `${left + hostWidth / 2 - targetWidth / 2}px`;
                this._renderer.addClass(targetRef.location.nativeElement, `arrow-${'left'}`);
                break;
            case 'left':
                targetTop = `${top - targetHeight - 8}px`;
                targetLeft = `${left + hostWidth / 2 - targetWidth / 2}px`;
                this._renderer.addClass(targetRef.location.nativeElement, `arrow-${'left'}`);
                break;
            case 'right':
                targetTop = `${top - targetHeight - 8}px`;
                targetLeft = `${left + hostWidth / 2 - targetWidth / 2}px`;
                this._renderer.addClass(targetRef.location.nativeElement, `arrow-${'left'}`);
                break;
            default:
                targetTop = `${top - targetHeight - 8}px`;
                targetLeft = `${left + hostWidth / 2 - targetWidth / 2}px`;
                this._renderer.addClass(targetRef.location.nativeElement, `arrow-${'left'}`);
                break;
        }
        /** @type {?} */
        const zIndex = this.commonUtils.getFloatingLayerIndex();
        /** @type {?} */
        const postion = { top: targetTop, left: targetLeft, zIndex };
        this.setStyles(targetRef.location.nativeElement, postion);
    }
    /**
     * @param {?} element
     * @param {?} postion
     * @return {?}
     */
    setStyles(element, postion) {
        /** @type {?} */
        const paramsArr = Object.keys(postion);
        paramsArr &&
            paramsArr.forEach((/**
             * @param {?} param
             * @return {?}
             */
            param => {
                this._renderer.setStyle(element, param, postion[param]);
            }));
    }
    /**
     * @private
     * @return {?}
     */
    _hide() {
        this._popover.hide();
        this.overlaySer.destory(this._elementRef.nativeElement);
    }
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    hide() {
        if (this.triggers == 'hover' && this.ngZone) {
            if (this.isOpen) {
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        if (!this.containerInOutState) {
                            this._hide();
                        }
                    }), 300);
                }));
            }
            return;
        }
        if (this.isOpen) {
            this._hide();
        }
    }
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    toggle() {
        if (this.isOpen) {
            return this.hide();
        }
        this.show();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // fix: seems there are an issue with `routerLinkActive`
        // which result in duplicated call ngOnInit without call to ngOnDestroy
        // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
        if (this._isInited) {
            return;
        }
        this._isInited = true;
        if (this.isFixed) {
            this._positionService.setOptions({
                modifiers: {
                    preventOverflow: {
                        enabled: false
                    }
                }
            });
        }
        if (this.triggers == 'hover') {
            this._popover.listen({
                triggers: this.triggers,
                outsideClick: this.outsideClick,
                show: (/**
                 * @return {?}
                 */
                () => this[this.showAction]()),
                hide: (/**
                 * @return {?}
                 */
                () => this.hide())
            });
        }
        else {
            this._popover.listen({
                triggers: this.triggers,
                outsideClick: this.outsideClick,
                show: (/**
                 * @return {?}
                 */
                () => this[this.showAction]())
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._popover.dispose();
    }
}
PopoverDirective.decorators = [
    { type: Directive, args: [{ selector: '[farrisPopover]', exportAs: 'bs-popover' },] }
];
/** @nocollapse */
PopoverDirective.ctorParameters = () => [
    { type: PopoverConfig },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: ComponentLoaderFactory },
    { type: PositioningService },
    { type: Injector, decorators: [{ type: Optional }] }
];
PopoverDirective.propDecorators = {
    popover: [{ type: Input }],
    popoverContext: [{ type: Input }],
    popoverTitle: [{ type: Input }],
    placement: [{ type: Input }],
    outsideClick: [{ type: Input }],
    triggers: [{ type: Input }],
    container: [{ type: Input }],
    containerClass: [{ type: Input }],
    popActive: [{ type: Input }],
    showAction: [{ type: Input }],
    isOpen: [{ type: Input }],
    isFixed: [{ type: Input }],
    onShown: [{ type: Output }],
    onHidden: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: PopoverModule,
            providers: [PopoverConfig, ComponentLoaderFactory, PositioningService]
        };
    }
}
PopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FarrisCommonModule
                ],
                declarations: [PopoverDirective, PopoverContainerComponent],
                exports: [PopoverDirective],
                entryComponents: [PopoverContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { PopoverDirective, PopoverModule, PopoverConfig, PopoverContainerComponent };

//# sourceMappingURL=farris-ui-popover.js.map