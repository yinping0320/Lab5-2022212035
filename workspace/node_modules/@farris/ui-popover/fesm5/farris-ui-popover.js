import { isBs3 } from '@farris/ui-modal/utils';
import { Subject } from 'rxjs';
import { Injectable, NgModule, ChangeDetectionStrategy, Input, Component, Optional, ViewChild, ElementRef, Directive, Output, Renderer2, ViewContainerRef, Injector, NgZone, defineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ComponentLoaderFactory } from '@farris/ui-modal/component-loader';
import { PositioningService } from '@farris/ui-modal/positioning';
import { CommonUtils, OverLayHiddenService, FarrisCommonModule } from '@farris/ui-common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the Popover directive.
 * You can inject this service, typically in your root component, and customize
 * the values of its properties in order to provide default values for all the
 * popovers used in the application.
 */
var PopoverConfig = /** @class */ (function () {
    function PopoverConfig() {
        /**
         * Placement of a popover. Accepts: "top", "bottom", "left", "right", "auto"
         */
        this.placement = 'top';
        /**
         * Specifies events that should trigger. Supports a space separated list of
         * event names.
         */
        this.triggers = 'click';
        this.outsideClick = true;
    }
    PopoverConfig.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */ PopoverConfig.ngInjectableDef = defineInjectable({ factory: function PopoverConfig_Factory() { return new PopoverConfig(); }, token: PopoverConfig, providedIn: "root" });
    return PopoverConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PopoverContainerComponent = /** @class */ (function () {
    function PopoverContainerComponent(config, el) {
        this.el = el;
        this.mounseState = new Subject();
        Object.assign(this, config);
    }
    Object.defineProperty(PopoverContainerComponent.prototype, "isBs3", {
        get: /**
         * @return {?}
         */
        function () {
            return isBs3();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PopoverContainerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.el) {
            this.mouseenterEvent = this.changeMouseState.bind(this, true);
            this.mouseleaveEvent = this.changeMouseState.bind(this, false);
            this.el.nativeElement.addEventListener('mouseenter', this.mouseenterEvent);
            this.el.nativeElement.addEventListener('mouseleave', this.mouseleaveEvent);
        }
    };
    /**
     * 获取鼠标变化状态
     */
    /**
     * 获取鼠标变化状态
     * @return {?}
     */
    PopoverContainerComponent.prototype.getMouseState = /**
     * 获取鼠标变化状态
     * @return {?}
     */
    function () {
        return this.mounseState;
    };
    /**
     * 绑定的事件
     * @param state
     */
    /**
     * 绑定的事件
     * @private
     * @param {?} state
     * @return {?}
     */
    PopoverContainerComponent.prototype.changeMouseState = /**
     * 绑定的事件
     * @private
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this.mounseState.next(state);
    };
    /**
     * @return {?}
     */
    PopoverContainerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.mouseenterEvent) {
            this.el.nativeElement.removeEventListener('mouseenter', this.mouseenterEvent);
        }
        if (this.mouseleaveEvent) {
            this.el.nativeElement.removeEventListener('mouseleave', this.mouseleaveEvent);
        }
        this.mounseState.unsubscribe();
    };
    PopoverContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'farris-popover',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    // tslint:disable-next-line
                    host: {
                        '[class]': '"popover in popover-" + placement + " " + "bs-popover-" + placement + " " + placement + " " + containerClass',
                        '[class.show]': '!isBs3',
                        '[class.bs3]': 'isBs3',
                        role: 'tooltip',
                        style: 'display:block;'
                    },
                    template: "<div class=\"popover-arrow arrow\"></div>\r\n<h3 class=\"popover-title popover-header\" *ngIf=\"title\">{{ title }}</h3>\r\n<div #innerEle class=\"popover-content popover-body\" [ngClass]=\"containerClass\">\r\n  <ng-content></ng-content>\r\n</div>\r\n",
                    styles: ["\n    :host.bs3.popover-top {\n      margin-bottom: 10px;\n    }\n    :host.bs3.popover.top>.arrow {\n      margin-left: -2px;\n    }\n    :host.bs3.popover.top {\n      margin-bottom: 10px;\n    }\n    :host.popover.bottom>.arrow {\n      margin-left: -4px;\n    }\n    :host.bs3.bs-popover-left {\n      margin-right: .5rem;\n    }\n    :host.bs3.bs-popover-right .arrow, :host.bs3.bs-popover-left .arrow{\n      margin: .3rem 0;\n    }\n    :host.arrow-left .arrow {\n        left: calc(50% - 10px);\n    }\n    "]
                }] }
    ];
    /** @nocollapse */
    PopoverContainerComponent.ctorParameters = function () { return [
        { type: PopoverConfig },
        { type: ElementRef, decorators: [{ type: Optional }] }
    ]; };
    PopoverContainerComponent.propDecorators = {
        innerNode: [{ type: ViewChild, args: ['innerEle', { read: ElementRef },] }],
        placement: [{ type: Input }],
        title: [{ type: Input }]
    };
    return PopoverContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A lightweight, extensible directive for fancy popover creation.
 */
var PopoverDirective = /** @class */ (function () {
    function PopoverDirective(_config, _elementRef, _renderer, _viewContainerRef, cis, _positionService, inject) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._positionService = _positionService;
        this.inject = inject;
        /**
         * Close popover on outside click
         */
        this.outsideClick = true;
        /**
         * A selector specifying the element the popover should be appended to.
         */
        this.container = 'body';
        /**
         * Css class for popover container
         */
        this.containerClass = '';
        // 按条件激活
        this.popActive = true;
        // 显示动作
        this.showAction = 'show';
        this.isFixed = false;
        this._isInited = false;
        // 标记是否进入提示框内
        this.containerInOutState = false;
        this._bodyOverflow = '';
        if (this.inject) {
            this.ngZone = this.inject.get(NgZone, null);
            this.overlaySer = this.inject.get(OverLayHiddenService, null);
            this.commonUtils = this.inject.get(CommonUtils, new CommonUtils());
        }
        this._popover = cis
            .createLoader(_elementRef, _viewContainerRef, _renderer)
            .provide({ provide: PopoverConfig, useValue: _config });
        Object.assign(this, _config);
        this.onShown = this._popover.onShown;
        this.onHidden = this._popover.onHidden;
        // fix: no focus on button on Mac OS #1795
        if (typeof window !== 'undefined') {
            _elementRef.nativeElement.addEventListener('click', (/**
             * @return {?}
             */
            function () {
                try {
                    _elementRef.nativeElement.focus();
                }
                catch (err) {
                    return;
                }
            }));
        }
        if (!this.overlaySer) {
            this.overlaySer = new OverLayHiddenService();
        }
    }
    Object.defineProperty(PopoverDirective.prototype, "isOpen", {
        /**
         * Returns whether or not the popover is currently being shown
         */
        get: /**
         * Returns whether or not the popover is currently being shown
         * @return {?}
         */
        function () {
            return this._popover.isShown;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this[this.showAction]();
            }
            else {
                this.hide();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    PopoverDirective.prototype.hasScrollbarY = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this._bodyOverflow) {
            this._bodyOverflow = getComputedStyle(document.body).overflow;
        }
        return document.body.scrollHeight > window.innerHeight && this._bodyOverflow !== 'hidden';
    };
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    PopoverDirective.prototype.show = /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.popActive || this._popover.isShown || !this.popover) {
            return;
        }
        this._popover
            .attach(PopoverContainerComponent)
            .to(this.container)
            .position({ attachment: this.placement })
            .show({
            showType: "popover",
            content: this.popover,
            context: this.popoverContext,
            placement: this.placement,
            title: this.popoverTitle,
            containerClass: this.containerClass,
        });
        // if (!this.hasScrollbarY()) {
        //     this._renderer.addClass(document.body, 'f-loading-dot-wrapper');
        // }
        /*解决插入到body里的层级问题*/
        /** @type {?} */
        var zIndex = this.commonUtils.getFloatingLayerIndex();
        this._popover.instance['el'].nativeElement.style.position = 'fixed';
        this._popover.instance['el'].nativeElement.style.zIndex = zIndex;
        this.overlaySer.registerMouseEvent(this._elementRef.nativeElement, (/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            /** @type {?} */
            var target = (/** @type {?} */ (e.target));
            if (_this._popover.instance['el'].nativeElement.contains(target) ||
                target.closest('.overlay-pane')) {
                return;
            }
            _this.hide();
        }));
        // this.isOpen = true;
        if (this.triggers == 'hover' && this._popover.instance && this._popover.instance.getMouseState) {
            this._popover.instance.getMouseState().subscribe((/**
             * @param {?} state
             * @return {?}
             */
            function (state) {
                _this.containerInOutState = state;
                if (!state) {
                    _this.hide();
                }
            }));
        }
    };
    /**
     * @return {?}
     */
    PopoverDirective.prototype.show2 = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.popActive || this._popover.isShown || !this.popover) {
            return;
        }
        /** @type {?} */
        var targetRef = this._popover
            .attach(PopoverContainerComponent)
            .to(this.container)
            .show({
            content: this.popover,
            context: this.popoverContext,
            placement: this.placement,
            title: this.popoverTitle,
            containerClass: this.containerClass
        });
        this.overlaySer.registerMouseEvent(this._elementRef.nativeElement, (/**
         * @return {?}
         */
        function () {
            _this.hide();
        }));
        //this.isOpen = true;
        var _a = this._elementRef.nativeElement.getBoundingClientRect(), hostHeight = _a.height, hostWidth = _a.width, top = _a.top, left = _a.left;
        var _b = targetRef.location.nativeElement.getBoundingClientRect(), targetHeight = _b.height, targetWidth = _b.width;
        /** @type {?} */
        var targetTop;
        /** @type {?} */
        var targetLeft;
        switch (this.placement) {
            case 'bottom':
                targetTop = top - targetHeight - 8 + "px";
                targetLeft = left + hostWidth / 2 - targetWidth / 2 + "px";
                this._renderer.addClass(targetRef.location.nativeElement, "arrow-" + 'left');
                break;
            case 'left':
                targetTop = top - targetHeight - 8 + "px";
                targetLeft = left + hostWidth / 2 - targetWidth / 2 + "px";
                this._renderer.addClass(targetRef.location.nativeElement, "arrow-" + 'left');
                break;
            case 'right':
                targetTop = top - targetHeight - 8 + "px";
                targetLeft = left + hostWidth / 2 - targetWidth / 2 + "px";
                this._renderer.addClass(targetRef.location.nativeElement, "arrow-" + 'left');
                break;
            default:
                targetTop = top - targetHeight - 8 + "px";
                targetLeft = left + hostWidth / 2 - targetWidth / 2 + "px";
                this._renderer.addClass(targetRef.location.nativeElement, "arrow-" + 'left');
                break;
        }
        /** @type {?} */
        var zIndex = this.commonUtils.getFloatingLayerIndex();
        /** @type {?} */
        var postion = { top: targetTop, left: targetLeft, zIndex: zIndex };
        this.setStyles(targetRef.location.nativeElement, postion);
    };
    /**
     * @param {?} element
     * @param {?} postion
     * @return {?}
     */
    PopoverDirective.prototype.setStyles = /**
     * @param {?} element
     * @param {?} postion
     * @return {?}
     */
    function (element, postion) {
        var _this = this;
        /** @type {?} */
        var paramsArr = Object.keys(postion);
        paramsArr &&
            paramsArr.forEach((/**
             * @param {?} param
             * @return {?}
             */
            function (param) {
                _this._renderer.setStyle(element, param, postion[param]);
            }));
    };
    /**
     * @private
     * @return {?}
     */
    PopoverDirective.prototype._hide = /**
     * @private
     * @return {?}
     */
    function () {
        this._popover.hide();
        this.overlaySer.destory(this._elementRef.nativeElement);
    };
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    PopoverDirective.prototype.hide = /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.triggers == 'hover' && this.ngZone) {
            if (this.isOpen) {
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    setTimeout((/**
                     * @return {?}
                     */
                    function () {
                        if (!_this.containerInOutState) {
                            _this._hide();
                        }
                    }), 300);
                }));
            }
            return;
        }
        if (this.isOpen) {
            this._hide();
        }
    };
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    PopoverDirective.prototype.toggle = /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            return this.hide();
        }
        this.show();
    };
    /**
     * @return {?}
     */
    PopoverDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // fix: seems there are an issue with `routerLinkActive`
        // which result in duplicated call ngOnInit without call to ngOnDestroy
        // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
        if (this._isInited) {
            return;
        }
        this._isInited = true;
        if (this.isFixed) {
            this._positionService.setOptions({
                modifiers: {
                    preventOverflow: {
                        enabled: false
                    }
                }
            });
        }
        if (this.triggers == 'hover') {
            this._popover.listen({
                triggers: this.triggers,
                outsideClick: this.outsideClick,
                show: (/**
                 * @return {?}
                 */
                function () { return _this[_this.showAction](); }),
                hide: (/**
                 * @return {?}
                 */
                function () { return _this.hide(); })
            });
        }
        else {
            this._popover.listen({
                triggers: this.triggers,
                outsideClick: this.outsideClick,
                show: (/**
                 * @return {?}
                 */
                function () { return _this[_this.showAction](); })
            });
        }
    };
    /**
     * @return {?}
     */
    PopoverDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._popover.dispose();
    };
    PopoverDirective.decorators = [
        { type: Directive, args: [{ selector: '[farrisPopover]', exportAs: 'bs-popover' },] }
    ];
    /** @nocollapse */
    PopoverDirective.ctorParameters = function () { return [
        { type: PopoverConfig },
        { type: ElementRef },
        { type: Renderer2 },
        { type: ViewContainerRef },
        { type: ComponentLoaderFactory },
        { type: PositioningService },
        { type: Injector, decorators: [{ type: Optional }] }
    ]; };
    PopoverDirective.propDecorators = {
        popover: [{ type: Input }],
        popoverContext: [{ type: Input }],
        popoverTitle: [{ type: Input }],
        placement: [{ type: Input }],
        outsideClick: [{ type: Input }],
        triggers: [{ type: Input }],
        container: [{ type: Input }],
        containerClass: [{ type: Input }],
        popActive: [{ type: Input }],
        showAction: [{ type: Input }],
        isOpen: [{ type: Input }],
        isFixed: [{ type: Input }],
        onShown: [{ type: Output }],
        onHidden: [{ type: Output }]
    };
    return PopoverDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PopoverModule = /** @class */ (function () {
    function PopoverModule() {
    }
    /**
     * @return {?}
     */
    PopoverModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: PopoverModule,
            providers: [PopoverConfig, ComponentLoaderFactory, PositioningService]
        };
    };
    PopoverModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FarrisCommonModule
                    ],
                    declarations: [PopoverDirective, PopoverContainerComponent],
                    exports: [PopoverDirective],
                    entryComponents: [PopoverContainerComponent]
                },] }
    ];
    return PopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { PopoverDirective, PopoverModule, PopoverConfig, PopoverContainerComponent };

//# sourceMappingURL=farris-ui-popover.js.map