import { Subject } from 'rxjs';
import { DomSanitizer } from '@angular/platform-browser';
import { Injectable, RendererFactory2, NgZone, Pipe, SecurityContext, Directive, Input, ElementRef, Renderer2, ViewContainerRef, ComponentFactoryResolver, NgModule, Component, TemplateRef, ViewChild, ViewEncapsulation, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { OverLayHiddenService, CommonUtils, FarrisCommonModule } from '@farris/ui-common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AttentionService {
    /**
     * @param {?} renderFac
     * @param {?} ngZone
     */
    constructor(renderFac, ngZone) {
        this.ngZone = ngZone;
        this.renderer = renderFac.createRenderer(null, null);
    }
    /**
     * @param {?} els
     * @param {?=} timer
     * @return {?}
     */
    catchAttention(els, timer = 600) {
        if (els && els.length > 0) {
            /** @type {?} */
            let attentionEls = [];
            for (let k = 0; k < els.length; k++) {
                /** @type {?} */
                var attentionEl;
                if (typeof els[k].idOrEl == 'string') {
                    attentionEl = document.getElementById(els[k].idOrEl);
                }
                else {
                    attentionEl = els[k].idOrEl;
                }
                if (attentionEl) {
                    attentionEls.push(attentionEl);
                    this.renderer.addClass(attentionEl, 'f-catch-attention-debounce');
                }
            }
            // 移除class
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    for (let m = 0; m < attentionEls.length; m++) {
                        this.renderer.removeClass(attentionEls[m], 'f-catch-attention-debounce');
                    }
                }), timer);
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AttentionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AttentionService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: NgZone }
];
/** @nocollapse */ AttentionService.ngInjectableDef = defineInjectable({ factory: function AttentionService_Factory() { return new AttentionService(inject(RendererFactory2), inject(NgZone)); }, token: AttentionService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TooltipService {
    constructor() {
        /* tooltip位置 */
        this.placement$ = new Subject();
        /* tooltip控制显示 */
        this.show$ = new Subject();
        /* 计算位置 */
        this.calPosition$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
TooltipService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
TooltipService.ctorParameters = () => [];
/** @nocollapse */ TooltipService.ngInjectableDef = defineInjectable({ factory: function TooltipService_Factory() { return new TooltipService(); }, token: TooltipService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TooltipComponent {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.zIndex = "1070";
        this.contentIsString = true;
        this._tipWidth = '';
        this._tipCls = '';
        /* 位置 */
        this.placement = 'top';
        this.rectifyPlacement = 'top';
        this.rectifyGutter = 20;
        /* 位置样式 */
        this.positionStyle = {};
    }
    /* 普通文本内容 */
    /**
     * @param {?} value
     * @return {?}
     */
    set content(value) {
        if (value instanceof TemplateRef) {
            this.contentIsString = false;
            this.contentViewf.createEmbeddedView(value);
        }
        else {
            this.contentIsString = true;
            this.nfContent = value;
        }
    }
    /**
     * @return {?}
     */
    get content() {
        return this.nfContent;
    }
    /**
     * 因为表单生成没有排除factory,不能使用模板
     * @param {?} value
     * @return {?}
     */
    set tipWidth(value) {
        if (value != this._tipWidth) {
            if (value) {
                this.render.setStyle(this.innerNode.nativeElement, 'width', value);
                this.render.setStyle(this.innerNode.nativeElement, 'max-width', 'none');
            }
            else {
                this.render.removeStyle(this.innerNode.nativeElement, 'width');
                this.render.removeStyle(this.innerNode.nativeElement, 'max-width');
            }
            this._tipWidth = value;
        }
    }
    /**
     * @return {?}
     */
    get tipWidth() {
        return this._tipWidth;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set tipCls(value) {
        if (value != this._tipCls) {
            //移除旧样式
            this._tipCls && this.render.removeClass(this.el.nativeElement, this._tipCls);
            //追加新样式
            value && this.render.addClass(this.el.nativeElement, value);
            this._tipCls = value;
        }
    }
    /**
     * @return {?}
     */
    get tipCls() {
        return this._tipCls;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.hostBoundingClientRect) {
            this.judgeWidth();
            this.autoRectifyDirection();
            this.calculatePosition(this.hostBoundingClientRect);
        }
    }
    /**
     * 规则判断默认样式下出现滚动条，尺寸从默认变成大号
     * @return {?}
     */
    judgeWidth() {
        if (this.innerNode.nativeElement.scrollHeight > this.innerNode.nativeElement.clientHeight) {
            this.render.addClass(this.innerNode.nativeElement, 'tooltip-inner-lg');
        }
    }
    // 自动纠正方向
    /**
     * @private
     * @return {?}
     */
    autoRectifyDirection() {
        // 标记默认值
        this.rectifyPlacement = this.placement;
        // 整个提示位置
        /** @type {?} */
        const tooltipSize = this.tooltipNode.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const arrowSize = this.arrowNode.nativeElement.getBoundingClientRect();
        /*不考虑，提示框太大的情况,只考虑一次转换位置，
        太复杂的场景，实际项目中不会出现，简化处理此问题
        if(this.referenceBoundingRect.width>tooltipSize){
        }*/
        switch (this.placement) {
            case 'top':
            case 'top-left':
            case 'top-right':
                if (Math.abs(this.hostBoundingClientRect.top - this.referenceBoundingRect.top) < tooltipSize.height + arrowSize.height) {
                    // 高度放不开，转向
                    this.rectifyPlacement = this.rectifyPlacement.replace('top', 'bottom');
                }
                break;
            case 'bottom':
            case 'bottom-left':
            case 'bottom-right':
                if (Math.abs(this.hostBoundingClientRect.bottom - this.referenceBoundingRect.bottom) < tooltipSize.height + arrowSize.height) {
                    // 高度放不开，转向
                    this.rectifyPlacement = this.rectifyPlacement.replace('bottom', 'top');
                }
                break;
            case 'right':
            case 'right-top':
            case 'right-bottom':
                if (Math.abs(this.hostBoundingClientRect.right - this.referenceBoundingRect.right) < tooltipSize.width + arrowSize.width) {
                    // 宽度放不开，转向
                    this.rectifyPlacement = this.rectifyPlacement.replace('right', 'left');
                }
                break;
            case 'left':
            case 'left-top':
            case 'left-bottom':
                if (Math.abs(this.hostBoundingClientRect.left - this.referenceBoundingRect.left) < tooltipSize.width + arrowSize.width) {
                    // 宽度放不开，转向
                    this.rectifyPlacement = this.rectifyPlacement.replace('left', 'right');
                }
                break;
        }
        if (this.rectifyPlacement != this.placement) {
            this.tooltipNode.nativeElement.classList.remove('bs-tooltip-' + this.offsetDirection(this.placement));
            this.tooltipNode.nativeElement.classList.add('bs-tooltip-' + this.offsetDirection(this.rectifyPlacement));
        }
    }
    /**
     * 判断是否超出边界
     * @private
     * @param {?} rect
     * @param {?} value
     * @return {?}
     */
    isOverBounding(rect, value) {
        /** @type {?} */
        let isOver = false;
        /** @type {?} */
        let newValue = 0;
        switch (rect) {
            case 'left':
                if (value <= this.referenceBoundingRect.left) {
                    isOver = true;
                    newValue = this.referenceBoundingRect.left + this.rectifyGutter;
                }
                break;
            case 'right':
                if (value >= this.referenceBoundingRect.right) {
                    isOver = true;
                    newValue = this.referenceBoundingRect.right - this.rectifyGutter;
                }
                break;
            case 'top':
                if (value <= this.referenceBoundingRect.top) {
                    isOver = true;
                    newValue = this.referenceBoundingRect.top + this.rectifyGutter;
                }
                break;
            case 'bottom':
                if (value >= this.referenceBoundingRect.bottom) {
                    isOver = true;
                    newValue = this.referenceBoundingRect.bottom - this.rectifyGutter;
                }
                break;
        }
        return { isOver, newValue };
    }
    /**
     * @private
     * @param {?} datas
     * @param {?=} specialEl
     * @return {?}
     */
    containsEl(datas, specialEl = '') {
        if (!specialEl) {
            specialEl = this.rectifyPlacement;
        }
        for (var i = 0; i < datas.length; i++) {
            if (datas[i] == specialEl)
                return true;
        }
        return false;
    }
    /* 计算tooltip最新位置 */
    /**
     * @param {?} hostPosition
     * @return {?}
     */
    calculatePosition(hostPosition) {
        /** @type {?} */
        let top = 0;
        /** @type {?} */
        let left = 0;
        /** @type {?} */
        let right = 0;
        /** @type {?} */
        let bottom = 0;
        // 整个提示位置
        /** @type {?} */
        const tooltipSize = this.tooltipNode.nativeElement.getBoundingClientRect();
        /** @type {?} */
        const arrowSize = this.arrowNode.nativeElement.getBoundingClientRect();
        switch (this.rectifyPlacement) {
            case 'top':
                top = hostPosition.top - tooltipSize.height - 2;
                left = hostPosition.left + (hostPosition.width - tooltipSize.width) / 2;
                right = left + tooltipSize.width;
                break;
            case 'left':
                top = hostPosition.top + (hostPosition.height - tooltipSize.height) / 2;
                left = hostPosition.left - tooltipSize.width - 2;
                break;
            case 'right':
                top = hostPosition.top + (hostPosition.height - tooltipSize.height) / 2;
                left = hostPosition.right + 2;
                break;
            case 'bottom':
                top = hostPosition.bottom + arrowSize.height + 2;
                left = hostPosition.left + (hostPosition.width - tooltipSize.width) / 2;
                right = left + tooltipSize.width;
                break;
            case 'top-left':
                top = hostPosition.top - tooltipSize.height - 2;
                left = hostPosition.left;
                right = left + tooltipSize.width;
                break;
            case 'top-right':
                top = hostPosition.top - tooltipSize.height - 2;
                left = hostPosition.right - tooltipSize.width;
                right = hostPosition.right;
                break;
            case 'right-top':
                top = hostPosition.top;
                left = hostPosition.right + 2;
                this.arrowNode.nativeElement.style.top = '10%';
                break;
            case 'right-bottom':
                top = hostPosition.bottom - tooltipSize.height;
                left = hostPosition.right + 2;
                this.arrowNode.nativeElement.style.bottom = '10%';
                break;
            case 'bottom-left':
                top = hostPosition.bottom + arrowSize.height + 2;
                left = hostPosition.left;
                right = left + tooltipSize.width;
                break;
            case 'bottom-right':
                top = hostPosition.bottom + arrowSize.height + 2;
                left = hostPosition.right - tooltipSize.width;
                right = hostPosition.right;
                break;
            case 'left-top':
                top = hostPosition.top;
                left = hostPosition.left - tooltipSize.width - 2;
                this.arrowNode.nativeElement.style.top = '10%';
                break;
            case 'left-bottom':
                top = hostPosition.bottom - tooltipSize.height;
                left = hostPosition.left - tooltipSize.width - 2;
                this.arrowNode.nativeElement.style.bottom = '10%';
        }
        /** @type {?} */
        let overResult;
        /** @type {?} */
        let arrowLeft = 0;
        /** @type {?} */
        let arrowTop = 0;
        switch (this.rectifyPlacement) {
            case 'top':
            case 'top-left':
            case 'top-right':
            case 'bottom':
            case 'bottom-left':
            case 'bottom-right':
                overResult = this.isOverBounding('left', left);
                if (overResult.isOver) {
                    left = overResult.newValue;
                }
                else {
                    overResult = this.isOverBounding('right', right);
                    if (overResult.isOver) {
                        left = overResult.newValue - tooltipSize.width;
                    }
                }
                arrowLeft = left - hostPosition.left - hostPosition.width * 0.5 + arrowSize.width * 0.5;
                if (this.rectifyPlacement.indexOf('-left') > 0) {
                    arrowLeft += hostPosition.width * 0.4;
                }
                else if (this.rectifyPlacement.indexOf('-right') > 0) {
                    arrowLeft -= hostPosition.width * 0.4;
                }
                this.arrowNode.nativeElement.style.left = Math.abs(arrowLeft) + 'px';
                break;
            default:
                overResult = this.isOverBounding('top', top);
                if (overResult.isOver) {
                    top = overResult.newValue;
                }
                else {
                    overResult = this.isOverBounding('bottom', bottom);
                    if (overResult.isOver) {
                        top = overResult.newValue - tooltipSize.height;
                    }
                }
                arrowTop = top - hostPosition.top - hostPosition.height * 0.5 + arrowSize.height * 0.5;
                if (this.rectifyPlacement.indexOf('-top') > 0) {
                    arrowTop += hostPosition.height * 0.4;
                }
                else if (this.rectifyPlacement.indexOf('-bottom') > 0) {
                    arrowTop -= hostPosition.height * 0.4;
                }
                this.arrowNode.nativeElement.style.top = Math.abs(arrowTop) + 'px';
        }
        this.tooltipNode.nativeElement.style.top = top + 'px';
        this.tooltipNode.nativeElement.style.left = left + 'px';
    }
    /*
        *12个位置名解析
        * 因表单生成没有排除factory,而且使用了[class],只能在此处变更
        */
    /**
     * @param {?=} tplacement
     * @return {?}
     */
    offsetDirection(tplacement = '') {
        if (!tplacement) {
            tplacement = this.placement;
        }
        if (tplacement.indexOf('-') !== -1) {
            /** @type {?} */
            const index = tplacement.indexOf('-');
            return tplacement.substring(0, index);
        }
        return tplacement;
    }
}
TooltipComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-tooltip',
                template: "<div #tooltipEle [class]=\"('bs-tooltip-'+offsetDirection())+' tooltip show'\" [style.zIndex]=\"zIndex\">\r\n    <div #arrowEle class=\"arrow\"></div>\r\n    <div #innerEle class=\"tooltip-inner\">\r\n        <div #contentViewf class=\"tooltip-tmpl\">\r\n            <div *ngIf=\"contentIsString\" class=\"tooltip-text\" [innerHtml]=\"nfContent|tooltipHtml\"></div>\r\n            <ng-container *ngIf=\"!contentIsString\"> {{nfContent}}</ng-container>\r\n        </div>       \r\n    </div>\r\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [".bs-tooltip-bottom .arrow,.bs-tooltip-top .arrow{left:50%}.bs-tooltip-left .arrow,.bs-tooltip-right .arrow{top:25%}"]
            }] }
];
/** @nocollapse */
TooltipComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
TooltipComponent.propDecorators = {
    contentViewf: [{ type: ViewChild, args: ['contentViewf', { read: ViewContainerRef },] }],
    tooltipNode: [{ type: ViewChild, args: ['tooltipEle', { read: ElementRef },] }],
    arrowNode: [{ type: ViewChild, args: ['arrowEle', { read: ElementRef },] }],
    innerNode: [{ type: ViewChild, args: ['innerEle', { read: ElementRef },] }],
    zIndex: [{ type: Input }],
    content: [{ type: Input }],
    tipWidth: [{ type: Input }],
    tipCls: [{ type: Input }],
    placement: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisTooltipDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} viewContainerRef
     * @param {?} resolver
     */
    constructor(el, render, viewContainerRef, resolver) {
        this.el = el;
        this.render = render;
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
        this.tooltipEnable = true;
        /* 提示文本 */
        this.text = "";
        // 提示框样式
        this.tipCls = "";
        // 提示框宽度
        this.tipWidth = "";
        /* 位置 */
        this.placement = "top";
        this.zIndex = '';
        this.triggerMode = "hover";
        this.showTip = true;
        this.delay = 0;
        // 是否绑定了事件
        this.hasBindEvent = false;
        this.delayTimer = null;
        /* 生成提示组件 */
        this.componentFactory = this.resolver.resolveComponentFactory(TooltipComponent);
        this.overLayService = new OverLayHiddenService();
        this.commUtils = new CommonUtils();
    }
    // 5月7日追加这种写法，控制禁用、启用
    // 原来的时候value是空字符串
    /**
     * @param {?} value
     * @return {?}
     */
    set enableTooltip(value) {
        if (typeof value == "string" && value == "") {
            this.enableOrDisable(true);
        }
        else {
            this.enableOrDisable(value);
        }
    }
    /**
     * @return {?}
     */
    get enableTooltip() {
        return this.tooltipEnable;
    }
    /* 触发方式 */
    /**
     * @param {?} value
     * @return {?}
     */
    set trigger(value) {
        if (value) {
            if (value !== this.triggerMode) {
                this.triggerMode = value;
                this.unbindEvent();
                this.bindEvent();
            }
        }
    }
    /**
     * @return {?}
     */
    get trigger() {
        return this.triggerMode;
    }
    /* 禁用---跟其他控件的属性容易冲突，逐渐废弃。
         * 比如按钮可以设置禁用不触发点击，但想给出点击提示，这样就冲突了
         */
    /**
     * @param {?} value
     * @return {?}
     */
    set disable(value) {
        this.enableOrDisable(!value);
    }
    /**
     * @return {?}
     */
    get disable() {
        return !this.tooltipEnable;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.bindEvent();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() { }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unbindEvent();
        this.removeTooltip();
        this.overLayService.destory(this.el.nativeElement);
        this.overLayService = null;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    enableOrDisable(value) {
        this.tooltipEnable = value;
        if (this.tooltipEnable) {
            this.bindEvent();
        }
        else {
            this.unbindEvent();
        }
    }
    /**
     * @return {?}
     */
    bindEvent() {
        if (!this.tooltipEnable) {
            return;
        }
        // 是否已绑定事件
        if (this.hasBindEvent) {
            return;
        }
        if (this.trigger === "click") {
            // 鼠标点击
            this.clickEvent = this.render.listen(this.el.nativeElement, "click", (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.stopPropagation();
                this.appendTooltip();
                this.clickOutEvent = this.render.listen(document, "click", (/**
                 * @return {?}
                 */
                () => {
                    this.removeTooltip();
                    this.clickOutEvent();
                }));
            }));
        }
        else if (this.trigger === "focus") {
            // 聚焦
            // @Todo 需要把input等组件和普通组件分开
            this.focusDownEvent = this.render.listen(this.el.nativeElement, "mousedown", (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.preventDefault();
                this.appendTooltip();
            }));
            this.focusUpEvent = this.render.listen(this.el.nativeElement, "mouseup", (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.stopPropagation();
                this.removeTooltip();
            }));
        }
        else {
            // 鼠标移动上去
            this.mouseenterEvent = this.render.listen(this.el.nativeElement, "mouseenter", (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.stopPropagation();
                if (this.delay) {
                    if (this.delayTimer) {
                        clearTimeout(this.delayTimer);
                    }
                    this.delayTimer = setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this.appendTooltip();
                        clearTimeout(this.delayTimer);
                    }), this.delay);
                }
                else {
                    this.appendTooltip();
                }
            }));
            this.mouseleaveEvent = this.render.listen(this.el.nativeElement, "mouseleave", (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                e.stopPropagation();
                if (this.delayTimer) {
                    clearTimeout(this.delayTimer);
                }
                this.removeTooltip();
            }));
        }
        this.hasBindEvent = true;
    }
    /* 解绑事件 */
    /**
     * @return {?}
     */
    unbindEvent() {
        // 鼠标移上去
        if (this.mouseenterEvent) {
            this.mouseenterEvent();
        }
        if (this.mouseleaveEvent) {
            this.mouseleaveEvent();
        }
        if (this.clickEvent) {
            this.clickEvent();
        }
        if (this.clickOutEvent) {
            this.clickOutEvent();
        }
        if (this.focusDownEvent) {
            this.focusDownEvent();
        }
        if (this.focusUpEvent) {
            this.focusUpEvent();
        }
        this.hasBindEvent = false;
    }
    /* body  移除tooltip */
    /**
     * @return {?}
     */
    removeTooltip() {
        if (this.tooltip) {
            this.render.removeChild(document.body, this.tooltip.el.nativeElement);
            this._componentRef.changeDetectorRef.markForCheck();
            this._componentRef.changeDetectorRef.detectChanges();
            this._componentRef.destroy();
            this.viewContainerRef.clear();
            this.tooltip = null;
            this._componentRef = null;
            this.overLayService.destory(this.el.nativeElement);
        }
    }
    /**
     * @private
     * @return {?}
     */
    appendTooltip() {
        if (!this.showTip)
            return;
        this.generateTooltip();
        this.updateViewProps(this.placement, this.content, this.el.nativeElement.getBoundingClientRect(), this.getReferencePosition());
        this.overLayService.registerMouseEvent(this.el.nativeElement, (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.removeTooltip();
        }));
    }
    /* 更新tooltip组件属性 */
    /**
     * @private
     * @param {?} placement
     * @param {?} content
     * @param {?} hostBoundingClientRect
     * @param {?} referenceBoundingRect
     * @return {?}
     */
    updateViewProps(placement, content, hostBoundingClientRect, referenceBoundingRect) {
        this.tooltip.placement = placement;
        this.tooltip.content = content;
        this.tooltip.hostBoundingClientRect = hostBoundingClientRect;
        this.tooltip.tipCls = this.tipCls;
        this.tooltip.tipWidth = this.tipWidth;
        this.tooltip.referenceBoundingRect = referenceBoundingRect;
        this._componentRef.changeDetectorRef.markForCheck();
        this._componentRef.changeDetectorRef.detectChanges();
    }
    /* 构造tooltip结构 */
    /**
     * @private
     * @return {?}
     */
    generateTooltip() {
        this._componentRef = this.viewContainerRef.createComponent(this.componentFactory);
        this.tooltip = this._componentRef.instance;
        this.tooltip.zIndex = '' + this.commUtils.getFloatingLayerIndex();
        // 父元素中移除  添加到body中
        this.render.removeChild(this.render.parentNode(this.el.nativeElement), this.tooltip.el.nativeElement);
        this.render.appendChild(document.body, this.tooltip.el.nativeElement);
    }
    /**
     * 确认参照的边界
     * @private
     * @return {?}
     */
    getReferencePosition() {
        /** @type {?} */
        let rRight = document.documentElement.clientWidth;
        /** @type {?} */
        let rBottom = document.documentElement.clientHeight;
        /** @type {?} */
        let rTop = 0;
        /** @type {?} */
        let rLeft = 0;
        // 横向参照
        if (this.rectifyReferenceH) {
            /** @type {?} */
            let rectifyReferenceHEl = this.getRectifyReferenceElement(this.rectifyReferenceH);
            rRight = rectifyReferenceHEl.getBoundingClientRect().right;
            rLeft = rectifyReferenceHEl.getBoundingClientRect().left;
        }
        // 纵向参照
        if (this.rectifyReferenceV) {
            /** @type {?} */
            let rectifyReferenceVEl = this.getRectifyReferenceElement(this.rectifyReferenceV);
            rBottom = rectifyReferenceVEl.getBoundingClientRect().bottom;
            rTop = rectifyReferenceVEl.getBoundingClientRect().top;
        }
        return { top: rTop, left: rLeft, right: rRight, bottom: rBottom };
    }
    /**
     * 获取纠正元素
     * @private
     * @param {?} referenceEl
     * @return {?}
     */
    getRectifyReferenceElement(referenceEl) {
        if (referenceEl instanceof ElementRef) {
            return referenceEl.nativeElement;
        }
        else if (typeof referenceEl == "string") {
            return document.querySelector((/** @type {?} */ (referenceEl)));
        }
        return referenceEl;
    }
}
FarrisTooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: "[farrisTooltip]",
            },] }
];
/** @nocollapse */
FarrisTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
FarrisTooltipDirective.propDecorators = {
    enableTooltip: [{ type: Input, args: ["farrisTooltip",] }],
    text: [{ type: Input }],
    tipCls: [{ type: Input }],
    tipWidth: [{ type: Input }],
    placement: [{ type: Input }],
    zIndex: [{ type: Input }],
    trigger: [{ type: Input }],
    disable: [{ type: Input }],
    showTip: [{ type: Input }],
    rectifyReferenceH: [{ type: Input }],
    rectifyReferenceV: [{ type: Input }],
    delay: [{ type: Input }],
    content: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FInputTipsDirective {
    /**
     * @param {?} el
     * @param {?} ngzone
     * @param {?} render
     */
    constructor(el, ngzone, render) {
        this.el = el;
        this.ngzone = ngzone;
        this.render = render;
        this.cloneEl = null;
        this.tipsText = "";
        this._enableTips = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set enableTips(value) {
        if (this._enableTips !== value) {
            this._enableTips = value;
            this.changeEventBind();
        }
    }
    /**
     * @return {?}
     */
    get enableTips() {
        return this._enableTips;
    }
    /**
     * @private
     * @return {?}
     */
    createCloneEl() {
        if (!this.el.nativeElement) {
            return;
        }
        /** @type {?} */
        const global = {
            cloneCSSProperties: [
                'line-height', 'letter-spacing',
                'font-size', 'font-family', 'font-style', 'font-weight', 'border',
                'padding', 'height'
            ]
        };
        /** @type {?} */
        const el$ = window.getComputedStyle(this.el.nativeElement);
        this.cloneEl = this.render.createElement('span');
        this.cloneEl['innerText'] = el$['value'];
        global.cloneCSSProperties.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => {
            this.cloneEl.style[item] = el$.getPropertyValue(item);
        }));
        this.render.addClass(this.cloneEl, 'f-dir-hidden-el');
        this.render.appendChild(document.body, this.cloneEl);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.changeEventBind();
    }
    /**
     * @return {?}
     */
    changeEventBind() {
        if (this.enableTips) {
            this.ngzone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.mouseEnterListener = this.onMouseEnterHandler.bind(this);
                this.el.nativeElement.addEventListener('mouseenter', this.mouseEnterListener);
                this.mouseLeaveListener = this.onMouseLeaveHandler.bind(this);
                this.el.nativeElement.addEventListener('mouseleave', this.mouseLeaveListener);
            }));
        }
        else {
            if (this.mouseEnterListener) {
                this.el.nativeElement.removeEventListener('mouseenter', this.mouseEnterListener);
                this.mouseEnterListener = null;
                this.el.nativeElement.removeEventListener('mouseleave', this.mouseLeaveListener);
                this.mouseLeaveListener = null;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.cloneEl) {
            this.render.removeChild(document.body, this.cloneEl);
        }
    }
    /**
     * @return {?}
     */
    onMouseEnterHandler() {
        this.changeTitle();
    }
    /**
     * @return {?}
     */
    onMouseLeaveHandler() {
        // 移除提示
        this.render.setAttribute(this.el.nativeElement, 'title', '');
    }
    /**
     * @private
     * @return {?}
     */
    changeTitle() {
        if (!this.cloneEl) {
            this.createCloneEl();
        }
        this.tipsText = this.el.nativeElement['value'];
        this.cloneEl['innerText'] = this.tipsText;
        this.ngzone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (this.cloneEl.getBoundingClientRect().width > this.el.nativeElement.getBoundingClientRect().width) {
                    this.render.setAttribute(this.el.nativeElement, "title", this.tipsText);
                }
                else {
                    this.onMouseLeaveHandler();
                }
            }), 0);
        }));
    }
}
FInputTipsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[f-input-tips]'
            },] }
];
/** @nocollapse */
FInputTipsDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
FInputTipsDirective.propDecorators = {
    enableTips: [{ type: Input, args: ['f-input-tips',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// https://angular.io/guide/security
class tooltipHtmlPipe {
    /**
     * @param {?} _sanitizer
     */
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return this._sanitizer.sanitize(SecurityContext.HTML, this._sanitizer.bypassSecurityTrustHtml(value));
    }
}
tooltipHtmlPipe.decorators = [
    { type: Pipe, args: [{ name: 'tooltipHtml' },] }
];
/** @nocollapse */
tooltipHtmlPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisTooltipModule {
}
FarrisTooltipModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    FarrisTooltipDirective,
                    TooltipComponent,
                    FInputTipsDirective,
                    tooltipHtmlPipe,
                ],
                imports: [
                    CommonModule,
                    FarrisCommonModule
                ],
                providers: [AttentionService],
                entryComponents: [TooltipComponent],
                exports: [FarrisTooltipDirective, TooltipComponent, FInputTipsDirective],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AttentionService, TooltipService, FarrisTooltipDirective, FInputTipsDirective, tooltipHtmlPipe, TooltipComponent, FarrisTooltipModule };

//# sourceMappingURL=farris-ui-tooltip.js.map