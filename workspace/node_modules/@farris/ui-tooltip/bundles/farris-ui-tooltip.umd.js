(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/platform-browser'), require('@angular/core'), require('@angular/common'), require('@farris/ui-common')) :
    typeof define === 'function' && define.amd ? define('@farris/ui-tooltip', ['exports', 'rxjs', '@angular/platform-browser', '@angular/core', '@angular/common', '@farris/ui-common'], factory) :
    (factory((global.farris = global.farris || {}, global.farris['ui-tooltip'] = {}),global.rxjs,global.ng.platformBrowser,global.ng.core,global.ng.common,global.uiCommon));
}(this, (function (exports,rxjs,platformBrowser,i0,common,uiCommon) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AttentionService = /** @class */ (function () {
        function AttentionService(renderFac, ngZone) {
            this.ngZone = ngZone;
            this.renderer = renderFac.createRenderer(null, null);
        }
        /**
         * @param {?} els
         * @param {?=} timer
         * @return {?}
         */
        AttentionService.prototype.catchAttention = /**
         * @param {?} els
         * @param {?=} timer
         * @return {?}
         */
            function (els, timer) {
                var _this = this;
                if (timer === void 0) {
                    timer = 600;
                }
                if (els && els.length > 0) {
                    /** @type {?} */
                    var attentionEls_1 = [];
                    for (var k = 0; k < els.length; k++) {
                        /** @type {?} */
                        var attentionEl;
                        if (typeof els[k].idOrEl == 'string') {
                            attentionEl = document.getElementById(els[k].idOrEl);
                        }
                        else {
                            attentionEl = els[k].idOrEl;
                        }
                        if (attentionEl) {
                            attentionEls_1.push(attentionEl);
                            this.renderer.addClass(attentionEl, 'f-catch-attention-debounce');
                        }
                    }
                    // 移除class
                    this.ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        setTimeout(( /**
                         * @return {?}
                         */function () {
                            for (var m = 0; m < attentionEls_1.length; m++) {
                                _this.renderer.removeClass(attentionEls_1[m], 'f-catch-attention-debounce');
                            }
                        }), timer);
                    }));
                }
            };
        /**
         * @return {?}
         */
        AttentionService.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        AttentionService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        AttentionService.ctorParameters = function () {
            return [
                { type: i0.RendererFactory2 },
                { type: i0.NgZone }
            ];
        };
        /** @nocollapse */ AttentionService.ngInjectableDef = i0.defineInjectable({ factory: function AttentionService_Factory() { return new AttentionService(i0.inject(i0.RendererFactory2), i0.inject(i0.NgZone)); }, token: AttentionService, providedIn: "root" });
        return AttentionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TooltipService = /** @class */ (function () {
        function TooltipService() {
            /* tooltip位置 */
            this.placement$ = new rxjs.Subject();
            /* tooltip控制显示 */
            this.show$ = new rxjs.Subject();
            /* 计算位置 */
            this.calPosition$ = new rxjs.Subject();
        }
        /**
         * @return {?}
         */
        TooltipService.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        TooltipService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        TooltipService.ctorParameters = function () { return []; };
        /** @nocollapse */ TooltipService.ngInjectableDef = i0.defineInjectable({ factory: function TooltipService_Factory() { return new TooltipService(); }, token: TooltipService, providedIn: "root" });
        return TooltipService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TooltipComponent = /** @class */ (function () {
        function TooltipComponent(el, render) {
            this.el = el;
            this.render = render;
            this.zIndex = "1070";
            this.contentIsString = true;
            this._tipWidth = '';
            this._tipCls = '';
            /* 位置 */
            this.placement = 'top';
            this.rectifyPlacement = 'top';
            this.rectifyGutter = 20;
            /* 位置样式 */
            this.positionStyle = {};
        }
        Object.defineProperty(TooltipComponent.prototype, "content", {
            get: /**
             * @return {?}
             */ function () {
                return this.nfContent;
            },
            /* 普通文本内容 */
            set: /* 普通文本内容 */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value instanceof i0.TemplateRef) {
                    this.contentIsString = false;
                    this.contentViewf.createEmbeddedView(value);
                }
                else {
                    this.contentIsString = true;
                    this.nfContent = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipComponent.prototype, "tipWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this._tipWidth;
            },
            /**因为表单生成没有排除factory,不能使用模板 */
            set: /**
             * 因为表单生成没有排除factory,不能使用模板
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value != this._tipWidth) {
                    if (value) {
                        this.render.setStyle(this.innerNode.nativeElement, 'width', value);
                        this.render.setStyle(this.innerNode.nativeElement, 'max-width', 'none');
                    }
                    else {
                        this.render.removeStyle(this.innerNode.nativeElement, 'width');
                        this.render.removeStyle(this.innerNode.nativeElement, 'max-width');
                    }
                    this._tipWidth = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipComponent.prototype, "tipCls", {
            get: /**
             * @return {?}
             */ function () {
                return this._tipCls;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value != this._tipCls) {
                    //移除旧样式
                    this._tipCls && this.render.removeClass(this.el.nativeElement, this._tipCls);
                    //追加新样式
                    value && this.render.addClass(this.el.nativeElement, value);
                    this._tipCls = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TooltipComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        TooltipComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (this.hostBoundingClientRect) {
                    this.judgeWidth();
                    this.autoRectifyDirection();
                    this.calculatePosition(this.hostBoundingClientRect);
                }
            };
        /**
         * 规则判断默认样式下出现滚动条，尺寸从默认变成大号
         */
        /**
         * 规则判断默认样式下出现滚动条，尺寸从默认变成大号
         * @return {?}
         */
        TooltipComponent.prototype.judgeWidth = /**
         * 规则判断默认样式下出现滚动条，尺寸从默认变成大号
         * @return {?}
         */
            function () {
                if (this.innerNode.nativeElement.scrollHeight > this.innerNode.nativeElement.clientHeight) {
                    this.render.addClass(this.innerNode.nativeElement, 'tooltip-inner-lg');
                }
            };
        // 自动纠正方向
        // 自动纠正方向
        /**
         * @private
         * @return {?}
         */
        TooltipComponent.prototype.autoRectifyDirection =
            // 自动纠正方向
            /**
             * @private
             * @return {?}
             */
            function () {
                // 标记默认值
                this.rectifyPlacement = this.placement;
                // 整个提示位置
                /** @type {?} */
                var tooltipSize = this.tooltipNode.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var arrowSize = this.arrowNode.nativeElement.getBoundingClientRect();
                /*不考虑，提示框太大的情况,只考虑一次转换位置，
                太复杂的场景，实际项目中不会出现，简化处理此问题
                if(this.referenceBoundingRect.width>tooltipSize){
                }*/
                switch (this.placement) {
                    case 'top':
                    case 'top-left':
                    case 'top-right':
                        if (Math.abs(this.hostBoundingClientRect.top - this.referenceBoundingRect.top) < tooltipSize.height + arrowSize.height) {
                            // 高度放不开，转向
                            this.rectifyPlacement = this.rectifyPlacement.replace('top', 'bottom');
                        }
                        break;
                    case 'bottom':
                    case 'bottom-left':
                    case 'bottom-right':
                        if (Math.abs(this.hostBoundingClientRect.bottom - this.referenceBoundingRect.bottom) < tooltipSize.height + arrowSize.height) {
                            // 高度放不开，转向
                            this.rectifyPlacement = this.rectifyPlacement.replace('bottom', 'top');
                        }
                        break;
                    case 'right':
                    case 'right-top':
                    case 'right-bottom':
                        if (Math.abs(this.hostBoundingClientRect.right - this.referenceBoundingRect.right) < tooltipSize.width + arrowSize.width) {
                            // 宽度放不开，转向
                            this.rectifyPlacement = this.rectifyPlacement.replace('right', 'left');
                        }
                        break;
                    case 'left':
                    case 'left-top':
                    case 'left-bottom':
                        if (Math.abs(this.hostBoundingClientRect.left - this.referenceBoundingRect.left) < tooltipSize.width + arrowSize.width) {
                            // 宽度放不开，转向
                            this.rectifyPlacement = this.rectifyPlacement.replace('left', 'right');
                        }
                        break;
                }
                if (this.rectifyPlacement != this.placement) {
                    this.tooltipNode.nativeElement.classList.remove('bs-tooltip-' + this.offsetDirection(this.placement));
                    this.tooltipNode.nativeElement.classList.add('bs-tooltip-' + this.offsetDirection(this.rectifyPlacement));
                }
            };
        /**
         * 判断是否超出边界
         */
        /**
         * 判断是否超出边界
         * @private
         * @param {?} rect
         * @param {?} value
         * @return {?}
         */
        TooltipComponent.prototype.isOverBounding = /**
         * 判断是否超出边界
         * @private
         * @param {?} rect
         * @param {?} value
         * @return {?}
         */
            function (rect, value) {
                /** @type {?} */
                var isOver = false;
                /** @type {?} */
                var newValue = 0;
                switch (rect) {
                    case 'left':
                        if (value <= this.referenceBoundingRect.left) {
                            isOver = true;
                            newValue = this.referenceBoundingRect.left + this.rectifyGutter;
                        }
                        break;
                    case 'right':
                        if (value >= this.referenceBoundingRect.right) {
                            isOver = true;
                            newValue = this.referenceBoundingRect.right - this.rectifyGutter;
                        }
                        break;
                    case 'top':
                        if (value <= this.referenceBoundingRect.top) {
                            isOver = true;
                            newValue = this.referenceBoundingRect.top + this.rectifyGutter;
                        }
                        break;
                    case 'bottom':
                        if (value >= this.referenceBoundingRect.bottom) {
                            isOver = true;
                            newValue = this.referenceBoundingRect.bottom - this.rectifyGutter;
                        }
                        break;
                }
                return { isOver: isOver, newValue: newValue };
            };
        /**
         * @private
         * @param {?} datas
         * @param {?=} specialEl
         * @return {?}
         */
        TooltipComponent.prototype.containsEl = /**
         * @private
         * @param {?} datas
         * @param {?=} specialEl
         * @return {?}
         */
            function (datas, specialEl) {
                if (specialEl === void 0) {
                    specialEl = '';
                }
                if (!specialEl) {
                    specialEl = this.rectifyPlacement;
                }
                for (var i = 0; i < datas.length; i++) {
                    if (datas[i] == specialEl)
                        return true;
                }
                return false;
            };
        /* 计算tooltip最新位置 */
        /* 计算tooltip最新位置 */
        /**
         * @param {?} hostPosition
         * @return {?}
         */
        TooltipComponent.prototype.calculatePosition = /* 计算tooltip最新位置 */
            /**
             * @param {?} hostPosition
             * @return {?}
             */
            function (hostPosition) {
                /** @type {?} */
                var top = 0;
                /** @type {?} */
                var left = 0;
                /** @type {?} */
                var right = 0;
                /** @type {?} */
                var bottom = 0;
                // 整个提示位置
                /** @type {?} */
                var tooltipSize = this.tooltipNode.nativeElement.getBoundingClientRect();
                /** @type {?} */
                var arrowSize = this.arrowNode.nativeElement.getBoundingClientRect();
                switch (this.rectifyPlacement) {
                    case 'top':
                        top = hostPosition.top - tooltipSize.height - 2;
                        left = hostPosition.left + (hostPosition.width - tooltipSize.width) / 2;
                        right = left + tooltipSize.width;
                        break;
                    case 'left':
                        top = hostPosition.top + (hostPosition.height - tooltipSize.height) / 2;
                        left = hostPosition.left - tooltipSize.width - 2;
                        break;
                    case 'right':
                        top = hostPosition.top + (hostPosition.height - tooltipSize.height) / 2;
                        left = hostPosition.right + 2;
                        break;
                    case 'bottom':
                        top = hostPosition.bottom + arrowSize.height + 2;
                        left = hostPosition.left + (hostPosition.width - tooltipSize.width) / 2;
                        right = left + tooltipSize.width;
                        break;
                    case 'top-left':
                        top = hostPosition.top - tooltipSize.height - 2;
                        left = hostPosition.left;
                        right = left + tooltipSize.width;
                        break;
                    case 'top-right':
                        top = hostPosition.top - tooltipSize.height - 2;
                        left = hostPosition.right - tooltipSize.width;
                        right = hostPosition.right;
                        break;
                    case 'right-top':
                        top = hostPosition.top;
                        left = hostPosition.right + 2;
                        this.arrowNode.nativeElement.style.top = '10%';
                        break;
                    case 'right-bottom':
                        top = hostPosition.bottom - tooltipSize.height;
                        left = hostPosition.right + 2;
                        this.arrowNode.nativeElement.style.bottom = '10%';
                        break;
                    case 'bottom-left':
                        top = hostPosition.bottom + arrowSize.height + 2;
                        left = hostPosition.left;
                        right = left + tooltipSize.width;
                        break;
                    case 'bottom-right':
                        top = hostPosition.bottom + arrowSize.height + 2;
                        left = hostPosition.right - tooltipSize.width;
                        right = hostPosition.right;
                        break;
                    case 'left-top':
                        top = hostPosition.top;
                        left = hostPosition.left - tooltipSize.width - 2;
                        this.arrowNode.nativeElement.style.top = '10%';
                        break;
                    case 'left-bottom':
                        top = hostPosition.bottom - tooltipSize.height;
                        left = hostPosition.left - tooltipSize.width - 2;
                        this.arrowNode.nativeElement.style.bottom = '10%';
                }
                /** @type {?} */
                var overResult;
                /** @type {?} */
                var arrowLeft = 0;
                /** @type {?} */
                var arrowTop = 0;
                switch (this.rectifyPlacement) {
                    case 'top':
                    case 'top-left':
                    case 'top-right':
                    case 'bottom':
                    case 'bottom-left':
                    case 'bottom-right':
                        overResult = this.isOverBounding('left', left);
                        if (overResult.isOver) {
                            left = overResult.newValue;
                        }
                        else {
                            overResult = this.isOverBounding('right', right);
                            if (overResult.isOver) {
                                left = overResult.newValue - tooltipSize.width;
                            }
                        }
                        arrowLeft = left - hostPosition.left - hostPosition.width * 0.5 + arrowSize.width * 0.5;
                        if (this.rectifyPlacement.indexOf('-left') > 0) {
                            arrowLeft += hostPosition.width * 0.4;
                        }
                        else if (this.rectifyPlacement.indexOf('-right') > 0) {
                            arrowLeft -= hostPosition.width * 0.4;
                        }
                        this.arrowNode.nativeElement.style.left = Math.abs(arrowLeft) + 'px';
                        break;
                    default:
                        overResult = this.isOverBounding('top', top);
                        if (overResult.isOver) {
                            top = overResult.newValue;
                        }
                        else {
                            overResult = this.isOverBounding('bottom', bottom);
                            if (overResult.isOver) {
                                top = overResult.newValue - tooltipSize.height;
                            }
                        }
                        arrowTop = top - hostPosition.top - hostPosition.height * 0.5 + arrowSize.height * 0.5;
                        if (this.rectifyPlacement.indexOf('-top') > 0) {
                            arrowTop += hostPosition.height * 0.4;
                        }
                        else if (this.rectifyPlacement.indexOf('-bottom') > 0) {
                            arrowTop -= hostPosition.height * 0.4;
                        }
                        this.arrowNode.nativeElement.style.top = Math.abs(arrowTop) + 'px';
                }
                this.tooltipNode.nativeElement.style.top = top + 'px';
                this.tooltipNode.nativeElement.style.left = left + 'px';
            };
        /*
        *12个位置名解析
        * 因表单生成没有排除factory,而且使用了[class],只能在此处变更
        */
        /*
            *12个位置名解析
            * 因表单生成没有排除factory,而且使用了[class],只能在此处变更
            */
        /**
         * @param {?=} tplacement
         * @return {?}
         */
        TooltipComponent.prototype.offsetDirection = /*
            *12个位置名解析
            * 因表单生成没有排除factory,而且使用了[class],只能在此处变更
            */
            /**
             * @param {?=} tplacement
             * @return {?}
             */
            function (tplacement) {
                if (tplacement === void 0) {
                    tplacement = '';
                }
                if (!tplacement) {
                    tplacement = this.placement;
                }
                if (tplacement.indexOf('-') !== -1) {
                    /** @type {?} */
                    var index = tplacement.indexOf('-');
                    return tplacement.substring(0, index);
                }
                return tplacement;
            };
        TooltipComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'farris-tooltip',
                        template: "<div #tooltipEle [class]=\"('bs-tooltip-'+offsetDirection())+' tooltip show'\" [style.zIndex]=\"zIndex\">\r\n    <div #arrowEle class=\"arrow\"></div>\r\n    <div #innerEle class=\"tooltip-inner\">\r\n        <div #contentViewf class=\"tooltip-tmpl\">\r\n            <div *ngIf=\"contentIsString\" class=\"tooltip-text\" [innerHtml]=\"nfContent|tooltipHtml\"></div>\r\n            <ng-container *ngIf=\"!contentIsString\"> {{nfContent}}</ng-container>\r\n        </div>       \r\n    </div>\r\n</div>",
                        encapsulation: i0.ViewEncapsulation.None,
                        styles: [".bs-tooltip-bottom .arrow,.bs-tooltip-top .arrow{left:50%}.bs-tooltip-left .arrow,.bs-tooltip-right .arrow{top:25%}"]
                    }] }
        ];
        /** @nocollapse */
        TooltipComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        TooltipComponent.propDecorators = {
            contentViewf: [{ type: i0.ViewChild, args: ['contentViewf', { read: i0.ViewContainerRef },] }],
            tooltipNode: [{ type: i0.ViewChild, args: ['tooltipEle', { read: i0.ElementRef },] }],
            arrowNode: [{ type: i0.ViewChild, args: ['arrowEle', { read: i0.ElementRef },] }],
            innerNode: [{ type: i0.ViewChild, args: ['innerEle', { read: i0.ElementRef },] }],
            zIndex: [{ type: i0.Input }],
            content: [{ type: i0.Input }],
            tipWidth: [{ type: i0.Input }],
            tipCls: [{ type: i0.Input }],
            placement: [{ type: i0.Input }]
        };
        return TooltipComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FarrisTooltipDirective = /** @class */ (function () {
        function FarrisTooltipDirective(el, render, viewContainerRef, resolver) {
            this.el = el;
            this.render = render;
            this.viewContainerRef = viewContainerRef;
            this.resolver = resolver;
            this.tooltipEnable = true;
            /* 提示文本 */
            this.text = "";
            // 提示框样式
            this.tipCls = "";
            // 提示框宽度
            this.tipWidth = "";
            /* 位置 */
            this.placement = "top";
            this.zIndex = '';
            this.triggerMode = "hover";
            this.showTip = true;
            this.delay = 0;
            // 是否绑定了事件
            this.hasBindEvent = false;
            this.delayTimer = null;
            /* 生成提示组件 */
            this.componentFactory = this.resolver.resolveComponentFactory(TooltipComponent);
            this.overLayService = new uiCommon.OverLayHiddenService();
            this.commUtils = new uiCommon.CommonUtils();
        }
        Object.defineProperty(FarrisTooltipDirective.prototype, "enableTooltip", {
            get: /**
             * @return {?}
             */ function () {
                return this.tooltipEnable;
            },
            // 5月7日追加这种写法，控制禁用、启用
            // 原来的时候value是空字符串
            set: 
            // 5月7日追加这种写法，控制禁用、启用
            // 原来的时候value是空字符串
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value == "string" && value == "") {
                    this.enableOrDisable(true);
                }
                else {
                    this.enableOrDisable(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTooltipDirective.prototype, "trigger", {
            get: /**
             * @return {?}
             */ function () {
                return this.triggerMode;
            },
            /* 触发方式 */
            set: /* 触发方式 */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value) {
                    if (value !== this.triggerMode) {
                        this.triggerMode = value;
                        this.unbindEvent();
                        this.bindEvent();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTooltipDirective.prototype, "disable", {
            get: /**
             * @return {?}
             */ function () {
                return !this.tooltipEnable;
            },
            /* 禁用---跟其他控件的属性容易冲突，逐渐废弃。
             * 比如按钮可以设置禁用不触发点击，但想给出点击提示，这样就冲突了
             */
            set: /* 禁用---跟其他控件的属性容易冲突，逐渐废弃。
                 * 比如按钮可以设置禁用不触发点击，但想给出点击提示，这样就冲突了
                 */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.enableOrDisable(!value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FarrisTooltipDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.bindEvent();
            };
        /**
         * @return {?}
         */
        FarrisTooltipDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () { };
        /**
         * @return {?}
         */
        FarrisTooltipDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.unbindEvent();
                this.removeTooltip();
                this.overLayService.destory(this.el.nativeElement);
                this.overLayService = null;
            };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        FarrisTooltipDirective.prototype.enableOrDisable = /**
         * @private
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.tooltipEnable = value;
                if (this.tooltipEnable) {
                    this.bindEvent();
                }
                else {
                    this.unbindEvent();
                }
            };
        /**
         * @return {?}
         */
        FarrisTooltipDirective.prototype.bindEvent = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.tooltipEnable) {
                    return;
                }
                // 是否已绑定事件
                if (this.hasBindEvent) {
                    return;
                }
                if (this.trigger === "click") {
                    // 鼠标点击
                    this.clickEvent = this.render.listen(this.el.nativeElement, "click", ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        e.stopPropagation();
                        _this.appendTooltip();
                        _this.clickOutEvent = _this.render.listen(document, "click", ( /**
                         * @return {?}
                         */function () {
                            _this.removeTooltip();
                            _this.clickOutEvent();
                        }));
                    }));
                }
                else if (this.trigger === "focus") {
                    // 聚焦
                    // @Todo 需要把input等组件和普通组件分开
                    this.focusDownEvent = this.render.listen(this.el.nativeElement, "mousedown", ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        e.preventDefault();
                        _this.appendTooltip();
                    }));
                    this.focusUpEvent = this.render.listen(this.el.nativeElement, "mouseup", ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        e.stopPropagation();
                        _this.removeTooltip();
                    }));
                }
                else {
                    // 鼠标移动上去
                    this.mouseenterEvent = this.render.listen(this.el.nativeElement, "mouseenter", ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        e.stopPropagation();
                        if (_this.delay) {
                            if (_this.delayTimer) {
                                clearTimeout(_this.delayTimer);
                            }
                            _this.delayTimer = setTimeout(( /**
                             * @return {?}
                             */function () {
                                _this.appendTooltip();
                                clearTimeout(_this.delayTimer);
                            }), _this.delay);
                        }
                        else {
                            _this.appendTooltip();
                        }
                    }));
                    this.mouseleaveEvent = this.render.listen(this.el.nativeElement, "mouseleave", ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        e.stopPropagation();
                        if (_this.delayTimer) {
                            clearTimeout(_this.delayTimer);
                        }
                        _this.removeTooltip();
                    }));
                }
                this.hasBindEvent = true;
            };
        /* 解绑事件 */
        /* 解绑事件 */
        /**
         * @return {?}
         */
        FarrisTooltipDirective.prototype.unbindEvent = /* 解绑事件 */
            /**
             * @return {?}
             */
            function () {
                // 鼠标移上去
                if (this.mouseenterEvent) {
                    this.mouseenterEvent();
                }
                if (this.mouseleaveEvent) {
                    this.mouseleaveEvent();
                }
                if (this.clickEvent) {
                    this.clickEvent();
                }
                if (this.clickOutEvent) {
                    this.clickOutEvent();
                }
                if (this.focusDownEvent) {
                    this.focusDownEvent();
                }
                if (this.focusUpEvent) {
                    this.focusUpEvent();
                }
                this.hasBindEvent = false;
            };
        /* body  移除tooltip */
        /* body  移除tooltip */
        /**
         * @return {?}
         */
        FarrisTooltipDirective.prototype.removeTooltip = /* body  移除tooltip */
            /**
             * @return {?}
             */
            function () {
                if (this.tooltip) {
                    this.render.removeChild(document.body, this.tooltip.el.nativeElement);
                    this._componentRef.changeDetectorRef.markForCheck();
                    this._componentRef.changeDetectorRef.detectChanges();
                    this._componentRef.destroy();
                    this.viewContainerRef.clear();
                    this.tooltip = null;
                    this._componentRef = null;
                    this.overLayService.destory(this.el.nativeElement);
                }
            };
        /**
         * @private
         * @return {?}
         */
        FarrisTooltipDirective.prototype.appendTooltip = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.showTip)
                    return;
                this.generateTooltip();
                this.updateViewProps(this.placement, this.content, this.el.nativeElement.getBoundingClientRect(), this.getReferencePosition());
                this.overLayService.registerMouseEvent(this.el.nativeElement, ( /**
                 * @param {?} e
                 * @return {?}
                 */function (e) {
                    _this.removeTooltip();
                }));
            };
        /* 更新tooltip组件属性 */
        /* 更新tooltip组件属性 */
        /**
         * @private
         * @param {?} placement
         * @param {?} content
         * @param {?} hostBoundingClientRect
         * @param {?} referenceBoundingRect
         * @return {?}
         */
        FarrisTooltipDirective.prototype.updateViewProps = /* 更新tooltip组件属性 */
            /**
             * @private
             * @param {?} placement
             * @param {?} content
             * @param {?} hostBoundingClientRect
             * @param {?} referenceBoundingRect
             * @return {?}
             */
            function (placement, content, hostBoundingClientRect, referenceBoundingRect) {
                this.tooltip.placement = placement;
                this.tooltip.content = content;
                this.tooltip.hostBoundingClientRect = hostBoundingClientRect;
                this.tooltip.tipCls = this.tipCls;
                this.tooltip.tipWidth = this.tipWidth;
                this.tooltip.referenceBoundingRect = referenceBoundingRect;
                this._componentRef.changeDetectorRef.markForCheck();
                this._componentRef.changeDetectorRef.detectChanges();
            };
        /* 构造tooltip结构 */
        /* 构造tooltip结构 */
        /**
         * @private
         * @return {?}
         */
        FarrisTooltipDirective.prototype.generateTooltip = /* 构造tooltip结构 */
            /**
             * @private
             * @return {?}
             */
            function () {
                this._componentRef = this.viewContainerRef.createComponent(this.componentFactory);
                this.tooltip = this._componentRef.instance;
                this.tooltip.zIndex = '' + this.commUtils.getFloatingLayerIndex();
                // 父元素中移除  添加到body中
                this.render.removeChild(this.render.parentNode(this.el.nativeElement), this.tooltip.el.nativeElement);
                this.render.appendChild(document.body, this.tooltip.el.nativeElement);
            };
        /**
         * 确认参照的边界
         */
        /**
         * 确认参照的边界
         * @private
         * @return {?}
         */
        FarrisTooltipDirective.prototype.getReferencePosition = /**
         * 确认参照的边界
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var rRight = document.documentElement.clientWidth;
                /** @type {?} */
                var rBottom = document.documentElement.clientHeight;
                /** @type {?} */
                var rTop = 0;
                /** @type {?} */
                var rLeft = 0;
                // 横向参照
                if (this.rectifyReferenceH) {
                    /** @type {?} */
                    var rectifyReferenceHEl = this.getRectifyReferenceElement(this.rectifyReferenceH);
                    rRight = rectifyReferenceHEl.getBoundingClientRect().right;
                    rLeft = rectifyReferenceHEl.getBoundingClientRect().left;
                }
                // 纵向参照
                if (this.rectifyReferenceV) {
                    /** @type {?} */
                    var rectifyReferenceVEl = this.getRectifyReferenceElement(this.rectifyReferenceV);
                    rBottom = rectifyReferenceVEl.getBoundingClientRect().bottom;
                    rTop = rectifyReferenceVEl.getBoundingClientRect().top;
                }
                return { top: rTop, left: rLeft, right: rRight, bottom: rBottom };
            };
        /**
         * 获取纠正元素
         */
        /**
         * 获取纠正元素
         * @private
         * @param {?} referenceEl
         * @return {?}
         */
        FarrisTooltipDirective.prototype.getRectifyReferenceElement = /**
         * 获取纠正元素
         * @private
         * @param {?} referenceEl
         * @return {?}
         */
            function (referenceEl) {
                if (referenceEl instanceof i0.ElementRef) {
                    return referenceEl.nativeElement;
                }
                else if (typeof referenceEl == "string") {
                    return document.querySelector(( /** @type {?} */(referenceEl)));
                }
                return referenceEl;
            };
        FarrisTooltipDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: "[farrisTooltip]",
                    },] }
        ];
        /** @nocollapse */
        FarrisTooltipDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: i0.ViewContainerRef },
                { type: i0.ComponentFactoryResolver }
            ];
        };
        FarrisTooltipDirective.propDecorators = {
            enableTooltip: [{ type: i0.Input, args: ["farrisTooltip",] }],
            text: [{ type: i0.Input }],
            tipCls: [{ type: i0.Input }],
            tipWidth: [{ type: i0.Input }],
            placement: [{ type: i0.Input }],
            zIndex: [{ type: i0.Input }],
            trigger: [{ type: i0.Input }],
            disable: [{ type: i0.Input }],
            showTip: [{ type: i0.Input }],
            rectifyReferenceH: [{ type: i0.Input }],
            rectifyReferenceV: [{ type: i0.Input }],
            delay: [{ type: i0.Input }],
            content: [{ type: i0.Input }]
        };
        return FarrisTooltipDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FInputTipsDirective = /** @class */ (function () {
        function FInputTipsDirective(el, ngzone, render) {
            this.el = el;
            this.ngzone = ngzone;
            this.render = render;
            this.cloneEl = null;
            this.tipsText = "";
            this._enableTips = true;
        }
        Object.defineProperty(FInputTipsDirective.prototype, "enableTips", {
            get: /**
             * @return {?}
             */ function () {
                return this._enableTips;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._enableTips !== value) {
                    this._enableTips = value;
                    this.changeEventBind();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @return {?}
         */
        FInputTipsDirective.prototype.createCloneEl = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.el.nativeElement) {
                    return;
                }
                /** @type {?} */
                var global = {
                    cloneCSSProperties: [
                        'line-height', 'letter-spacing',
                        'font-size', 'font-family', 'font-style', 'font-weight', 'border',
                        'padding', 'height'
                    ]
                };
                /** @type {?} */
                var el$ = window.getComputedStyle(this.el.nativeElement);
                this.cloneEl = this.render.createElement('span');
                this.cloneEl['innerText'] = el$['value'];
                global.cloneCSSProperties.forEach(( /**
                 * @param {?} item
                 * @param {?} index
                 * @return {?}
                 */function (item, index) {
                    _this.cloneEl.style[item] = el$.getPropertyValue(item);
                }));
                this.render.addClass(this.cloneEl, 'f-dir-hidden-el');
                this.render.appendChild(document.body, this.cloneEl);
            };
        /**
         * @return {?}
         */
        FInputTipsDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.changeEventBind();
            };
        /**
         * @return {?}
         */
        FInputTipsDirective.prototype.changeEventBind = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.enableTips) {
                    this.ngzone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        _this.mouseEnterListener = _this.onMouseEnterHandler.bind(_this);
                        _this.el.nativeElement.addEventListener('mouseenter', _this.mouseEnterListener);
                        _this.mouseLeaveListener = _this.onMouseLeaveHandler.bind(_this);
                        _this.el.nativeElement.addEventListener('mouseleave', _this.mouseLeaveListener);
                    }));
                }
                else {
                    if (this.mouseEnterListener) {
                        this.el.nativeElement.removeEventListener('mouseenter', this.mouseEnterListener);
                        this.mouseEnterListener = null;
                        this.el.nativeElement.removeEventListener('mouseleave', this.mouseLeaveListener);
                        this.mouseLeaveListener = null;
                    }
                }
            };
        /**
         * @return {?}
         */
        FInputTipsDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.cloneEl) {
                    this.render.removeChild(document.body, this.cloneEl);
                }
            };
        /**
         * @return {?}
         */
        FInputTipsDirective.prototype.onMouseEnterHandler = /**
         * @return {?}
         */
            function () {
                this.changeTitle();
            };
        /**
         * @return {?}
         */
        FInputTipsDirective.prototype.onMouseLeaveHandler = /**
         * @return {?}
         */
            function () {
                // 移除提示
                this.render.setAttribute(this.el.nativeElement, 'title', '');
            };
        /**
         * @private
         * @return {?}
         */
        FInputTipsDirective.prototype.changeTitle = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.cloneEl) {
                    this.createCloneEl();
                }
                this.tipsText = this.el.nativeElement['value'];
                this.cloneEl['innerText'] = this.tipsText;
                this.ngzone.runOutsideAngular(( /**
                 * @return {?}
                 */function () {
                    setTimeout(( /**
                     * @return {?}
                     */function () {
                        if (_this.cloneEl.getBoundingClientRect().width > _this.el.nativeElement.getBoundingClientRect().width) {
                            _this.render.setAttribute(_this.el.nativeElement, "title", _this.tipsText);
                        }
                        else {
                            _this.onMouseLeaveHandler();
                        }
                    }), 0);
                }));
            };
        FInputTipsDirective.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[f-input-tips]'
                    },] }
        ];
        /** @nocollapse */
        FInputTipsDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.NgZone },
                { type: i0.Renderer2 }
            ];
        };
        FInputTipsDirective.propDecorators = {
            enableTips: [{ type: i0.Input, args: ['f-input-tips',] }]
        };
        return FInputTipsDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // https://angular.io/guide/security
    var tooltipHtmlPipe = /** @class */ (function () {
        function tooltipHtmlPipe(_sanitizer) {
            this._sanitizer = _sanitizer;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        tooltipHtmlPipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this._sanitizer.sanitize(i0.SecurityContext.HTML, this._sanitizer.bypassSecurityTrustHtml(value));
            };
        tooltipHtmlPipe.decorators = [
            { type: i0.Pipe, args: [{ name: 'tooltipHtml' },] }
        ];
        /** @nocollapse */
        tooltipHtmlPipe.ctorParameters = function () {
            return [
                { type: platformBrowser.DomSanitizer }
            ];
        };
        return tooltipHtmlPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FarrisTooltipModule = /** @class */ (function () {
        function FarrisTooltipModule() {
        }
        FarrisTooltipModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            FarrisTooltipDirective,
                            TooltipComponent,
                            FInputTipsDirective,
                            tooltipHtmlPipe,
                        ],
                        imports: [
                            common.CommonModule,
                            uiCommon.FarrisCommonModule
                        ],
                        providers: [AttentionService],
                        entryComponents: [TooltipComponent],
                        exports: [FarrisTooltipDirective, TooltipComponent, FInputTipsDirective],
                    },] }
        ];
        return FarrisTooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.AttentionService = AttentionService;
    exports.TooltipService = TooltipService;
    exports.FarrisTooltipDirective = FarrisTooltipDirective;
    exports.FInputTipsDirective = FInputTipsDirective;
    exports.tooltipHtmlPipe = tooltipHtmlPipe;
    exports.TooltipComponent = TooltipComponent;
    exports.FarrisTooltipModule = FarrisTooltipModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=farris-ui-tooltip.umd.js.map