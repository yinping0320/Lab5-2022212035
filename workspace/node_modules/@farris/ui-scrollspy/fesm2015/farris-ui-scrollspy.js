import { fromEvent, Subject } from 'rxjs';
import { throttleTime, debounceTime } from 'rxjs/operators';
import { animationFrame } from 'rxjs/internal/scheduler/animationFrame';
import { Injectable, NgZone, Component, Input, ElementRef, Directive, TemplateRef, ContentChild, ViewChild, ChangeDetectorRef, ViewEncapsulation, EventEmitter, Output, HostBinding, NgModule, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LocaleModule } from '@farris/ui-locale';
import { AngularDraggableModule } from '@farris/ui-draggable';
import { FarrisCommonModule } from '@farris/ui-common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisScrollSpyService {
    /**
     * @param {?} ngzone
     */
    constructor(ngzone) {
        this.ngzone = ngzone;
        // 监听区块当前时候的样式
        this.scrollSpyPartActiveClsName = 'f-scrollspy-part-active';
        this.fixedTabContainerClsName = 'f-scrollspy-container-fixed';
        this.parentFixedTabContainerClsName = 'f-scrollspy-container-fixed-parent';
        /**
         * 被监听滚动的contents
         */
        this.scrollContents = {};
        /**
         * 被监听滚动的sections
         */
        this.scrollSpies = {};
        /**
         * 监听滚动的锚点部分
         */
        this.scrollFollowSpipes = {};
        this.scrollSpyListFollowTypeChanges = {};
        /**
         * 滚动监听偏移距离
         */
        this.offsets = {};
        /**
         * 默认监听分组名称
         */
        this.defaultId = 'default';
        // currentSectionId: Subject<any> = new Subject();
        this.currentSectionIdObj = {};
        this.scrollChange = {};
    }
    //获取currentid
    /**
     * @param {?} groupId
     * @return {?}
     */
    getCurrentSectionId(groupId) {
        if (!groupId) {
            groupId = this.defaultId;
        }
        return this.currentSectionIdObj[groupId].subject;
        // return this.currentSectionId;
    }
    //滚动变化时改变currentid
    /**
     * @param {?} groupId
     * @param {?} value
     * @return {?}
     */
    setCurrentSectionId(groupId, value) {
        if (!groupId) {
            groupId = this.defaultId;
        }
        this.currentSectionIdObj[groupId].subject.next(value);
        //console.log(this.currentSectionIdObj);
        // this.currentSectionId.next(value);
    }
    //设置不同group组的currentid
    /**
     * @param {?} groupId
     * @param {?} value
     * @return {?}
     */
    setCurrentSectionIdObj(groupId, value) {
        if (!groupId) {
            groupId = this.defaultId;
        }
        if (!this.currentSectionIdObj[groupId]) {
            this.currentSectionIdObj[groupId] = (/** @type {?} */ ({
                subject: new Subject(),
                idValue: value
            }));
        }
        else {
            this.currentSectionIdObj[groupId].idValue = value;
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.scrollFollowSpipes[groupId] && this.scrollFollowSpipes[groupId].length) {
                /** @type {?} */
                let item = this.scrollFollowSpipes[groupId].find((/**
                 * @param {?} scrollFollowItem
                 * @return {?}
                 */
                scrollFollowItem => {
                    return scrollFollowItem['id'] == this.currentSectionIdObj[groupId].idValue;
                }));
                if (item) {
                    this.fScrollFollowClick(groupId, item);
                }
            }
        }), 0);
        // this.fScrollFollowClick(key,follow);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollSubscription.unsubscribe();
    }
    /**
     * Observer部分 供指令初始化调用
     * @param {?=} scrollSpyId
     * @return {?}
     */
    // public getCurrentSection$(scrollSpyId: string = this.defaultId): Observable<string> {
    //   if(scrollSpyId !== ''){
    //     return this.scrollChange[scrollSpyId];
    //   }
    //   else{
    //     return this.scrollChange[this.defaultId];
    //   }
    // }
    updateScrollGroup(scrollSpyId = this.defaultId) {
        /** @type {?} */
        const groupId = scrollSpyId !== '' ? scrollSpyId : this.defaultId;
        if (!this.scrollChange[groupId]) {
            this.scrollChange[groupId] = new Subject();
        }
        return this.scrollChange[groupId];
    }
    /**
     * @private
     * @param {?} eles
     * @param {?} $scrollContainer
     * @param {?} offset
     * @return {?}
     */
    findMinInToViewElement(eles, $scrollContainer, offset) {
        // 获取信息
        /** @type {?} */
        let scrollInfo = this.getBoundaryInfo($scrollContainer, offset);
        /** @type {?} */
        let len = eles.length;
        // [{el:元素,top:顶,height:高度}]
        /** @type {?} */
        let recordEles = [];
        /** @type {?} */
        let result = [];
        // 判断是否在视口
        /** @type {?} */
        let findInView = false;
        for (var k = 0; k < len; k++) {
            recordEles.push({ id: eles[k].id, top: eles[k].element.offsetTop, height: eles[k].element.offsetHeight });
            // recordEles[k]['ratio']=(recordEles[k]['top']+recordEles[k]['height'])/scrollInfo.contentHeight
        }
        /** @type {?} */
        var minIndex;
        /** @type {?} */
        var temp;
        for (var i = 0; i < len - 1; i++) {
            minIndex = i;
            for (var j = i + 1; j < len; j++) {
                if (recordEles[j].top < recordEles[minIndex].top) { //寻找最小的数
                    minIndex = j; //将最小数的索引保存
                }
            }
            temp = recordEles[i];
            recordEles[i] = recordEles[minIndex];
            recordEles[minIndex] = temp;
        }
        if (scrollInfo.top > scrollInfo.min) {
            // scrollTop 滚动到最后剩下在界面上的元素多个元素不能根据offsetTop来判断，应该显示哪个，按照比例来计算
            /** @type {?} */
            let scrollTopRatio = (scrollInfo.top - scrollInfo.min) / scrollInfo.boundary;
            // 判断top的位置
            //let ratioReferHeight=scrollInfo.boundary+scrollInfo.fixedHeight;
            /** @type {?} */
            let elRatio = 0;
            for (var k = 0; k < len; k++) {
                //recordEles[k]['radio']=(recordEles[k]['top']+recordEles[k]['height']-scrollInfo.min)/ratioReferHeight;
                if (recordEles[k].top - scrollInfo.offset >= scrollInfo.top || recordEles[k].top + recordEles[k].height - scrollInfo.offset > scrollInfo.top) {
                    elRatio = (recordEles[k]['top'] + recordEles[k]['height']) / scrollInfo.contentHeight;
                    if (!findInView && scrollTopRatio <= elRatio) {
                        findInView = true;
                        result.push(recordEles[k].id);
                        break;
                    }
                }
            }
            if (result.length == 0) {
                // 没找到，就返回最大的
                return [recordEles[len - 1].id];
            }
            return [result[0]];
        }
        else {
            // 页面较长时，按照scrollTop和offsetTop比较
            for (var k = 0; k < len; k++) {
                // 小于等于，考虑到容器有内上间距的情况
                if (recordEles[k].top - scrollInfo.offset <= scrollInfo.top && recordEles[k].top + recordEles[k].height - scrollInfo.offset >= scrollInfo.top) {
                    result.push(recordEles[k].id);
                    break;
                }
            }
            if (result.length == 0) {
                // 没找到，就返回最小的
                return [recordEles[0].id];
            }
            return [result[result.length - 1]];
        }
    }
    /**
     * @private
     * @param {?} $scrollContainer
     * @param {?} offset
     * @return {?}
     */
    getBoundaryInfo($scrollContainer, offset) {
        /** @type {?} */
        let fixedHeight = $scrollContainer.offsetHeight;
        /** @type {?} */
        let realRatio = ($scrollContainer.scrollHeight - fixedHeight) / fixedHeight;
        /** @type {?} */
        let maxRound = Math.ceil(realRatio);
        /** @type {?} */
        let minRound = maxRound - 1 > 0 ? maxRound - 1 : 0;
        // // 上下间距,此处影响比例的计算，试想容器有内上间距，元素的offsetTop不可能为0，但是容器的scrollTop初始为0
        /** @type {?} */
        let scrollContainerPaddingTop = parseFloat(getComputedStyle($scrollContainer, null).paddingTop);
        // let(element.currentStyle? element.currentStyle : window.getComputedStyle(element, null)).height);
        return {
            offset: offset ? offset : scrollContainerPaddingTop,
            top: $scrollContainer.scrollTop,
            bottom: $scrollContainer.scrollTop + fixedHeight,
            fixedHeight: fixedHeight,
            contentHeight: $scrollContainer.scrollHeight,
            min: minRound * fixedHeight,
            boundary: $scrollContainer.scrollHeight - (minRound + 1) * fixedHeight
        }; // 以offsetHeight为度量，记录offsetTop不足一个高度的具体长度,
    }
    /**
     * content部分滚动事件监听
     * @private
     * @param {?} key
     * @return {?}
     */
    subscribeScroll(key) {
        this.ngzone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.scrollSubscription = fromEvent(this.scrollContents[key], 'scroll')
                .pipe(debounceTime(100, animationFrame))
                .subscribe((/**
             * @return {?}
             */
            () => {
                if (this.scrollSpies[key]) {
                    const { currentSectionId, elements, subject } = this.scrollSpies[key];
                    /** @type {?} */
                    const findMinInViewIds = this.findMinInToViewElement(elements, this.scrollContents[key], this.offsets[key]);
                    if (!findMinInViewIds || !findMinInViewIds.length) {
                        return;
                    }
                    /** @type {?} */
                    const topElementId = findMinInViewIds[0];
                    //判断 点击是否是点击引起的滚动
                    if (this.scrollSpies[key].clickChange) {
                        this.scrollSpies[key].clickChange = false;
                        return;
                    }
                    else {
                        this.scrollSpies[key].clickChange = false;
                        if (topElementId !== currentSectionId) {
                            this.scrollSpies[key].currentSectionId = topElementId;
                            this.ngzone.run((/**
                             * @return {?}
                             */
                            () => {
                                subject.next(topElementId);
                            }));
                        }
                    }
                }
            }));
        }));
    }
    /**
     * tab部分点击事件监听
     * @private
     * @param {?} key
     * @return {?}
     */
    subscribeClick(key) {
        //Object.keys(this.scrollFollowSpipes).forEach((key:string):void=>{
        if (this.scrollFollowSpipes[key] && this.scrollFollowSpipes[key].length) {
            this.scrollFollowSpipes[key].forEach((/**
             * @param {?} follow
             * @return {?}
             */
            (follow) => {
                fromEvent(follow.element, 'click')
                    .pipe(throttleTime(100))
                    .subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    event.stopPropagation();
                    this.fScrollFollowClick(key, follow);
                    // if(this.scrollSpies[key]){
                    //   const { currentSectionId, elements, subject } = this.scrollSpies[key];
                    //   this.scrollSpies[key].clickChange = true;
                    //   if(follow.id !== currentSectionId){
                    //     const topElementInView = elements.find(el => el.id === follow.id);
                    //     if(!topElementInView) { return; }
                    //     this.scrollSpies[key].currentSectionId = follow.id;
                    //     //this.scrollContents[key].offsetTop
                    //     this.scrollContents[key].scrollTop = Math.round(topElementInView.element.offsetTop - this.offsets[key]);
                    //     subject.next(follow.id);
                    //   }
                    // }
                }));
            }));
        }
        //});
    }
    /**
     * @param {?} key
     * @param {?} follow
     * @return {?}
     */
    fScrollFollowClick(key, follow) {
        if (this.scrollSpies[key]) {
            const { currentSectionId, elements, subject } = this.scrollSpies[key];
            this.scrollSpies[key].clickChange = true;
            if (follow.id !== currentSectionId) {
                /** @type {?} */
                const topElementInView = elements.find((/**
                 * @param {?} el
                 * @return {?}
                 */
                el => el.id === follow.id));
                if (!topElementInView) {
                    return;
                }
                this.scrollSpies[key].currentSectionId = follow.id;
                //this.scrollContents[key].offsetTop
                if (this.scrollContents[key]) {
                    // 内容去有滚动
                    this.scrollContents[key].scrollTop = Math.round(topElementInView.element.offsetTop - this.offsets[key] - parseInt(getComputedStyle(this.scrollContents[key]).paddingTop, 10));
                }
                subject.next(follow.id);
            }
        }
    }
    /**
     * 添加需要被滚动监听部分
     * @param {?} element
     * @param {?=} contentId
     * @return {?}
     */
    addContentElement(element, contentId = this.defaultId) {
        if (contentId !== '') {
            this.scrollContents[contentId] = element;
            this.subscribeScroll(contentId);
        }
        else {
            this.scrollContents[this.defaultId] = element;
            this.subscribeScroll(this.defaultId);
        }
        // 判断是有待改变的状态
        this.updateContainerClsName(contentId);
    }
    /**
     * 移除需要被滚动监听部分元素
     * @param {?=} contentId
     * @return {?}
     */
    removeContentElement(contentId = this.defaultId) {
        /** @type {?} */
        const removeId = contentId !== '' ? contentId : this.defaultId;
        delete this.scrollSpies[removeId];
    }
    /**
     * 添加滚动监听tab部分元素
     * @param {?} element
     * @param {?} followId
     * @param {?=} followContentId
     * @return {?}
     */
    addFollowElement(element, followId, followContentId = this.defaultId) {
        /** @type {?} */
        const groupId = followContentId !== '' ? followContentId : this.defaultId;
        /** @type {?} */
        const follow = {
            element: element,
            id: followId
        };
        if (!this.scrollFollowSpipes[groupId]) {
            this.scrollFollowSpipes[groupId] = [];
        }
        //-------------------------此处没有处理重复ID
        /** @type {?} */
        const follows = this.scrollFollowSpipes[groupId];
        follows.push(follow);
        this.scrollFollowSpipes[groupId] = follows;
        this.subscribeClick(groupId);
    }
    /**
     * 移除滚动监听tab部分元素
     * @param {?} followId
     * @param {?=} followContentId
     * @return {?}
     */
    removeFollowElement(followId, followContentId = this.defaultId) {
        /** @type {?} */
        const elements = this.scrollFollowSpipes[followContentId].filter((/**
         * @param {?} el
         * @return {?}
         */
        el => {
            return el.id !== followId;
        }));
        if (!elements.length) {
            delete this.scrollFollowSpipes[followContentId];
            return;
        }
        this.scrollFollowSpipes[followContentId] = elements;
    }
    /**
     * 添加滚动监听锚点部分元素
     * @param {?} element
     * @param {?} scrollId
     * @param {?=} scrollGroupId
     * @return {?}
     */
    addElement(element, scrollId, scrollGroupId = this.defaultId) {
        if (!this.scrollSpies[scrollGroupId]) {
            this.scrollSpies[scrollGroupId] = (/** @type {?} */ ({
                elements: [],
                currentSectionId: '',
                subject: new Subject(),
            }));
            this.scrollSpies[scrollGroupId].subject
                .subscribe((/**
             * @param {?} currentSection
             * @return {?}
             */
            (currentSection) => {
                if (this.scrollChange[scrollGroupId]) {
                    this.scrollChange[scrollGroupId].next(currentSection);
                }
            }));
        }
        if (this.hasElement(scrollId, scrollGroupId)) {
            return;
        }
        /** @type {?} */
        const el = {
            element: element,
            id: scrollId
        }
        // 加入时，判断是否是当前
        ;
        // 加入时，判断是否是当前
        this.updateScrollSpyActiveClsName(scrollGroupId, el);
        /** @type {?} */
        const elements = this.scrollSpies[scrollGroupId].elements;
        elements.push(el);
        elements.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => b.element.getBoundingClientRect().top - a.element.getBoundingClientRect().top));
        this.scrollSpies[scrollGroupId].elements = elements;
    }
    /**
     * 移除滚动监听锚点部分元素
     * @param {?} scrollId
     * @param {?=} scrollGroupId
     * @return {?}
     */
    removeElement(scrollId, scrollGroupId = this.defaultId) {
        /** @type {?} */
        const elements = this.scrollSpies[scrollGroupId].elements.filter((/**
         * @param {?} el
         * @return {?}
         */
        (el) => {
            return el.id !== scrollId;
        }));
        if (!elements.length) {
            delete this.scrollSpies[scrollGroupId];
            return;
        }
        this.scrollSpies[scrollGroupId].elements = elements;
    }
    /**
     * 判断scrollGroupId 是否有id名为elementId 的元素
     * @private
     * @param {?} elementId
     * @param {?} scrollGroupId
     * @return {?}
     */
    hasElement(elementId, scrollGroupId) {
        return this.scrollSpies[scrollGroupId].elements.some((/**
         * @param {?} element
         * @return {?}
         */
        (element) => element.id === elementId));
    }
    /**
     * 设置offset
     * @param {?=} offset
     * @param {?=} contentId
     * @return {?}
     */
    setOffset(offset = 0, contentId = this.defaultId) {
        if (contentId !== '') {
            this.offsets[contentId] = offset;
        }
        else {
            this.offsets[this.defaultId] = offset;
        }
    }
    /*ScrollSpy组件(锚点列表区域）初始化预设defaultId */
    /**
     * @param {?} groupid
     * @return {?}
     */
    setGroupId(groupid) {
        if (groupid) {
            this.defaultId = groupid;
        }
    }
    /**
     * @return {?}
     */
    getGroupId() {
        return this.defaultId;
    }
    /*改变 ScrollSpy组件（锚点列表区域）的显示状态时 */
    /**
     * @param {?} groupid
     * @param {?} followTypeData
     * @return {?}
     */
    changeGroupIdFollowType(groupid, followTypeData) {
        this.scrollSpyListFollowTypeChanges[groupid] = followTypeData;
        this.updateContainerClsName(groupid);
    }
    /**
     * @private
     * @param {?} groupid
     * @return {?}
     */
    updateContainerClsName(groupid) {
        // 没有待更新变化
        if (!this.scrollSpyListFollowTypeChanges.hasOwnProperty(groupid)) {
            return;
        }
        // container并不存在的时候
        if (!this.scrollContents.hasOwnProperty(groupid)) {
            return;
        }
        /** @type {?} */
        let followTypeData = this.scrollSpyListFollowTypeChanges[groupid];
        /** @type {?} */
        let containerEl = this.scrollContents[groupid];
        // Container的Element 
        if (followTypeData['prev'] == 'fixedTab') {
            //移除class
            containerEl.className = containerEl.className.replace(this.fixedTabContainerClsName, '');
            containerEl.parentElement.classList.remove(this.parentFixedTabContainerClsName);
        }
        else if (followTypeData['next'] == 'fixedTab') {
            // 增加class
            containerEl.className += ' ' + this.fixedTabContainerClsName;
            // 给父元素增加高度
            containerEl.parentElement.classList.add(this.parentFixedTabContainerClsName);
        }
        this.scrollSpyListFollowTypeChanges[groupid] = null;
    }
    /**
     * @param {?} groupId
     * @param {?} currentId
     * @return {?}
     */
    updateScrollSpiesActiveClsName(groupId, currentId) {
        // 追加、移除class
        this.scrollSpies[groupId].elements.map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item.id == currentId) {
                // 找到当前
                if (item.element.className.indexOf(this.scrollSpyPartActiveClsName) < 0) {
                    item.element.className += ' ' + this.scrollSpyPartActiveClsName;
                }
            }
            else {
                // 其他
                item.element.className = item.element.className.replace(this.scrollSpyPartActiveClsName, '');
            }
        }));
    }
    /**
     * 当追加ScrollSpy块的时候，判断是否是已经设置的当前
     * @private
     * @param {?} groupId
     * @param {?} scrollEl
     * @return {?}
     */
    updateScrollSpyActiveClsName(groupId, scrollEl) {
        // 如果已设置
        if (this.currentSectionIdObj[groupId]) {
            if (this.currentSectionIdObj[groupId]['idValue'] == scrollEl.id) {
                scrollEl.element.className += ' ' + this.scrollSpyPartActiveClsName;
            }
        }
    }
}
FarrisScrollSpyService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FarrisScrollSpyService.ctorParameters = () => [
    { type: NgZone }
];
/** @nocollapse */ FarrisScrollSpyService.ngInjectableDef = defineInjectable({ factory: function FarrisScrollSpyService_Factory() { return new FarrisScrollSpyService(inject(NgZone)); }, token: FarrisScrollSpyService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getUuid() {
    /** @type {?} */
    var s = [];
    /** @type {?} */
    var hexDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
    }
    s[14] = "4";
    s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);
    s[8] = s[13] = s[18] = s[23] = "-";
    /** @type {?} */
    let uuid = s.join("");
    return uuid;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollspyItemTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
ScrollspyItemTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[scrollspyItem]'
            },] }
];
/** @nocollapse */
ScrollspyItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
class ScrollspyComponent {
    /**
     * @param {?} elementRef
     * @param {?} scrollSpy
     * @param {?} changeDetector
     */
    constructor(elementRef, scrollSpy, changeDetector) {
        this.elementRef = elementRef;
        this.scrollSpy = scrollSpy;
        this.changeDetector = changeDetector;
        this.ctx = null;
        /**
         * 当前滚动所有group
         */
        this.scrollGroupId = getUuid();
        /**
         * 当前滚动显示样式，默认 side 可选参数 tab、fixedTab
         */
        this._followType = 'side';
        // 记录状态改变
        this._emitFollowType = null;
        this.sidetabWidth = 145;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set fFollowType(value) {
        if (value !== this._followType) {
            this._emitFollowType = {
                prev: this._followType,
                next: value
            };
            this.changeFollowType();
            this._followType = value;
        }
    }
    /**
     * @return {?}
     */
    get fFollowType() {
        return this._followType;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set scrollspyData(value) {
        if (value) {
            this._scrollspyData = value.filter((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                if (item.hasOwnProperty('visible') && !item.visible) {
                    return false;
                }
                else {
                    return true;
                }
            }));
            if (this._scrollspyData && this._scrollspyData.length && !this.currentSectionId) {
                this.currentSectionId = this._scrollspyData[0].id;
            }
            this.scrollSpy.setCurrentSectionIdObj(this.scrollGroupId, this.currentSectionId);
        }
    }
    /**
     * @return {?}
     */
    get scrollspyData() {
        return this._scrollspyData;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // if(this.scrollspyData && this.scrollspyData.length && !this.currentSectionId ){
        //   this.currentSectionId = this.scrollspyData[0].id;
        // }
        // this.scrollSpy.setCurrentSectionIdObj(this.scrollGroupId, this.currentSectionId);
        // console.log(this.scrollGroupId);
        this.scrollSpy.setGroupId(this.scrollGroupId);
        this.changeFollowType();
        // 获取当前Section的Id
        this.scrollSpy.getCurrentSectionId(this.scrollGroupId).subscribe((/**
         * @param {?} currentId
         * @return {?}
         */
        (currentId) => {
            this.currentSectionId = currentId;
            this.scrollSpy.updateScrollSpiesActiveClsName(this.scrollGroupId, currentId);
        }));
        // 获取对应Container区域，在滚动时的当前Section的变化
        this.scrollSpy.updateScrollGroup(this.scrollGroupId).subscribe((/**
         * @param {?} currentSection
         * @return {?}
         */
        (currentSection) => {
            this.scrollSpy.setCurrentSectionId(this.scrollGroupId, currentSection);
        }));
    }
    // 改变FollowType时
    /**
     * @return {?}
     */
    changeFollowType() {
        if (this.scrollGroupId && this._emitFollowType) {
            this.scrollSpy.changeGroupIdFollowType(this.scrollGroupId, this._emitFollowType);
            this._emitFollowType = null;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /**
         * 当滚动位置为side时，该组件最近父节点添加relative定位
         * @type {?}
         */
        const parent = this.elementRef.nativeElement.parentElement;
        if (!parent.style.position && parent.style.position !== 'relative' && this.fFollowType === 'side') {
            parent.style.position = 'relative';
        }
        // if(this.scrollspyData && this.scrollspyData.length && this.currentSectionId){
        //   if(this.currentSectionId !== this.scrollspyData[0].id){
        //     console.log(222);
        //     const element = this.scrollyspyListEl.nativeElement.querySelector("#scrollspy-"+this.currentSectionId);
        //     const follow = {
        //       element: element,
        //       id: this.currentSectionId
        //     };
        //     const groupId = this.scrollGroupId ? this.scrollGroupId: 'default';
        //     this.scrollSpy.fScrollFollowClick(groupId,follow);
        //   }
        // }
    }
}
ScrollspyComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-scrollspy',
                template: "<div class=\"f-scrollspy\" [ngDraggable]=\"fFollowType === 'side'\" [lockAxis]=\"'x'\" [ngClass]=\"{'f-scrollspy-sidetabs': fFollowType === 'side' && !scrollspyTemplate&&!scrollspyItemComponentType,'f-scrollspy-tabs': fFollowType === 'tab' ||fFollowType === 'fixedTab' && !scrollspyTemplate &&!scrollspyItemComponentType,'f-scrollspy-fixedTab':fFollowType === 'fixedTab'}\">\r\n    <ng-container *ngIf=\"fFollowType === 'side' && !scrollspyTemplate&&!scrollspyItemComponentType\">\r\n        <div class=\"f-scrollspy-sidetabs-inner\" [ngStyle]=\"{'width': (fFollowType === 'side' && !scrollspyTemplate&&!scrollspyItemComponentType)? sidetabWidth/16 + 'rem': '','transform': (fFollowType === 'side' && !scrollspyTemplate &&!scrollspyItemComponentType)? 'translateX('+(sidetabWidth/16 + 'rem') +')' : ''}\">\r\n            <ng-container [ngTemplateOutlet]=\"scrollspyListTemplate\"></ng-container>\r\n        </div>\r\n        <div class=\"f-scrollspy-monitor-tip\">\r\n            <div class=\"f-scrollspy-monitor-tip-inner\">\r\n                <span class=\"f-icon f-icon-navigation\"></span>\r\n                <span class=\"f-scrollspy-monitor-tip-text\">{{ 'scrollspy.guide' | locale }}</span>\r\n                <span class=\"f-scrollspy-monitor-tip-img\">\r\n                </span>\r\n            </div>\r\n        </div>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"fFollowType === 'tab'||fFollowType === 'fixedTab' || scrollspyTemplate || scrollspyItemComponentType\">\r\n        <ng-container [ngTemplateOutlet]=\"scrollspyListTemplate\"></ng-container>\r\n    </ng-container>\r\n</div>\r\n\r\n\r\n<ng-template #scrollspyListTemplate>\r\n    <ul #scrollyspyList class=\"f-scrollspy-monitor-list\">\r\n        <li class=\"f-scrollspy-monitor-btn\" \r\n        *ngFor=\"let tab of scrollspyData;let i = index;let first = first;let last = last;\"\r\n        [class.active]=\"tab['id'] === currentSectionId\" \r\n        [fScrollFollowElement]=\"tab['id']\"\r\n        [fScrollElement]=\"scrollGroupId\"\r\n        [id]=\"'scrollspy-'+tab['id']\"\r\n        [title]=\"tab.title\">\r\n            <div *ngIf=\"scrollspyItemComponentType\" component-template [cmpRef]=\"scrollspyItemComponentType\" [ctx]=\"{scrollItem:tab,first:first,last:last,index:i,currentSectionId:currentSectionId}\"></div>\r\n            <ng-container *ngIf=\"!scrollspyItemComponentType\">\r\n                <ng-container *ngIf=\"!scrollspyTemplate;else scrollElement\">\r\n                    <span class=\"f-scrollspy-monitor-title\">{{tab.title}}</span>\r\n                </ng-container>                \r\n            </ng-container>\r\n            <ng-template #scrollElement>\r\n                <ng-container [ngTemplateOutlet]=\"scrollspyTemplate\" [ngTemplateOutletContext]=\"{scrollItem:tab,first:first,last:last,index:i}\"></ng-container>\r\n            </ng-template>\r\n        </li>\r\n    </ul>\r\n</ng-template>",
                encapsulation: ViewEncapsulation.None,
                styles: [".f-scrollspy .f-scrollspy-monitor-btn{display:inline-block}.f-scrollspy-sidetabs{display:-webkit-box;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;-webkit-box-align:center;align-items:center;position:absolute;top:0;right:0;z-index:999;overflow:hidden;width:1.75rem;-webkit-transition:width .5s;transition:width .5s}.f-scrollspy-sidetabs .f-scrollspy-sidetabs-inner{-webkit-transition:.5s;transition:.5s;min-height:115px;background:#fff;box-shadow:0 2px 6px 0 rgba(57,66,100,.14);border-radius:4px 0 0 4px;overflow:hidden}.f-scrollspy-sidetabs:hover{width:auto}.f-scrollspy-sidetabs:hover .f-scrollspy-sidetabs-inner{-webkit-transform:translateX(0)!important;transform:translateX(0)!important}.f-scrollspy-sidetabs:hover .f-scrollspy-monitor-tip{border-radius:0}.f-scrollspy-sidetabs .f-scrollspy-monitor-btn{position:relative;width:100%;height:1.3125rem;padding-left:1.1875rem;margin-bottom:.75rem}.f-scrollspy-sidetabs .f-scrollspy-monitor-btn::before{content:\"\";position:absolute;left:0;top:1rem;height:2rem;width:1px;border-left:1px dashed #e9e9e9;background-color:transparent;border-radius:.5px;z-index:8}.f-scrollspy-sidetabs .f-scrollspy-monitor-btn:last-child{margin-bottom:0}.f-scrollspy-sidetabs .f-scrollspy-monitor-btn:last-child::before{display:none}.f-scrollspy-sidetabs .f-scrollspy-monitor-btn::after{content:\"\";position:absolute;left:-.4375rem;top:.1875rem;width:.9375rem;height:.9375rem;border-radius:100%;z-index:9}.f-scrollspy-sidetabs .f-scrollspy-monitor-btn .f-scrollspy-monitor-title{display:inline-block;font-size:.875rem;color:rgba(0,0,0,.55);line-height:1.3125rem;cursor:pointer;width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.f-scrollspy-sidetabs .f-scrollspy-monitor-btn.active .f-scrollspy-monitor-title{color:rgba(0,0,0,.65);font-weight:600}.f-scrollspy-sidetabs .f-scrollspy-monitor-tip{position:absolute;right:0;top:0;bottom:0;width:1.75rem;border-radius:4px 0 0 4px}.f-scrollspy-sidetabs .f-scrollspy-monitor-tip-inner{position:relative;width:100%;height:100%;padding-top:.625rem}.f-scrollspy-sidetabs .f-scrollspy-monitor-tip-inner .f-scrollspy-monitor-tip-img{position:absolute;left:0;bottom:0;width:1.75rem;height:2.9375rem;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAABeCAYAAAB2K9dZAAAABGdBTUEAALGPC/xhBQAABC5JREFUeAHtm2tT1DAUhlnviooiIKDAAjri+NH//3tERERQRBTX99lpdnZLgZLTNOlOzsyZtKXJnidvm2uZGQwGs/JbM1Nqd8S1A5sgT5WcyH/Kj3q9HuedNwCdPdABPs8FAZ8pOZZ/xwX8T2nnbBywHPw9XXhR+LmAD3V8ID8W7EBpJ+wqwHGA2zpxsGeC3dP5vkDPx29K8binYD96BsYjuy/fE+hvzzKCZ6urYFUgtLxL8kVV0helnwT6t+rGmNcsgC7ung4AXRDortLPAk2mQWqy/6OsVfkHgc4pTcKaBHRAtL5vBLkpv+suxkpDADoW+lPUfOYuxEhDAsJD97ItyDV56N+qrL+2fpRG6J0g71dGEfBiW4AgPJK/F+STgDwXim4TkB/nkX0rSEZFrVjbgEDRb/YFSZcS3GIAOqgVQa65k1BpTECYlkJDxgZ0kOvTqqDjYsAe5J1MQUEHyTvZeOuaEiCgG4J86oibSFMDpAvZEmRjI57UABGNwQAzEWDNliIgULPy12Y6FZAqIGz0keaJc8qAQG4IkkfW21IHZEXglTedMqYOCBuDgMe+kF0AhG1dkF6talcAHwrSa5TTxLqo79Nz03yrUvGgzpqr7kO45/K5LgHS4LC2w+JypRVgC/rjsny4ZNklQKCWBcFeyMTKeQG2WIBNME2cUELiRp+IQuxuDU1wvJ9bcvY2L1hXGpnxwBnhDFtUpcDuyCvhyISCK3K2q38VqZKkjZnGvOCYVg13o6+KFkDGe27Mx84toPixPNV9+r5iq2XldxDpWaDF6XfY2PwmP5JPvNg674SVActB8zjQ5L6UA/lVzscJnbHrAB0IyrpHmQ8R2LruhKI+rSgv9nYBrCRt8wGEiP6I1rcvj77JqRguNV9AVyD9z6acJYYkzQoIFGWwx3Btn8TNbVsTgC5mBsLMvmmQkrEmAYFic7OR1bCmaqhpQOLifTStozQFRzkhACkXJRkgRLdQgIDx+QjvZVQLCQgYLav3ilgTNRMakBgZEJgWby2gbQC6UY8lTu+8bQASHI+pm3N6B+uTse5swqfsch6mXEyi68xCUJ2P+khdjHxdzPeo+B95LXOZa91svImnhUaHqVaVMa6le6EfvXSNpcgI5I/C+S+BS78hbxOQ2ABkPjmuIqtiLB7dZMBO3HRDOLBU2qH8grUNOK4ixwwGrHvyMFAOlbcrP5GPrK1GZvSDOiAQVOvLrXAqYmS8s+tyVB1ZDEB+c0NOQCEMNUfDxBiAIaDKZaLiELLtd7AcSMhzIE+nVUFXccvTDhhsPuhqMHqaFYwugTGArKCxAqNnzwpGl8AYQFbQWIHRs2cFo0tgDCAraKzA6NmzgtElMAaQFTRWYPTsWcHoEhgDyAoaKzB69qxgdAmMAWQFjRUYPXtWMLoExgCygsYKjJ596hX8D3/gzAAeM1fWAAAAAElFTkSuQmCC);background-size:100%}.f-scrollspy-sidetabs .f-scrollspy-monitor-tip-inner .f-icon{display:block;margin:0 auto .625rem;font-size:.875rem;color:#fff}.f-scrollspy-sidetabs .f-scrollspy-monitor-tip-inner .f-scrollspy-monitor-tip-text{display:block;width:.75rem;margin:0 auto;font-size:.875rem;line-height:1.25rem;color:#fff;text-align:center;text-shadow:0 1px 4px rgba(0,0,0,.06);word-wrap:break-word}.f-scrollspy-sidetabs .f-scrollspy-sidetabs-inner .f-scrollspy-monitor-list{padding:.75rem 3rem .875rem 1.25rem;-webkit-transition:.5s;transition:.5s}.f-scrollspy-tabs{flex-shrink:0;background-color:#fff;box-shadow:0 1px 5px 0 rgba(0,28,64,.06);border-radius:2px;padding:0 .125rem}.f-scrollspy-tabs .f-scrollspy-monitor-btn{position:relative;display:-webkit-inline-box;display:inline-flex;height:2.75rem;line-height:2.75rem;padding:0 .875rem;cursor:pointer;min-width:5.75rem;white-space:nowrap;-webkit-box-pack:center;justify-content:center}.f-scrollspy-tabs .f-scrollspy-monitor-btn .f-scrollspy-monitor-title{white-space:nowrap;font-size:1rem}.f-scrollspy-tabs .f-scrollspy-monitor-btn::after{content:\"\";position:absolute;left:50%;margin-left:-.625rem;bottom:.3125rem;width:1.25rem;height:.1875rem;border-radius:7.125rem}"]
            }] }
];
/** @nocollapse */
ScrollspyComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FarrisScrollSpyService },
    { type: ChangeDetectorRef }
];
ScrollspyComponent.propDecorators = {
    ctx: [{ type: Input }],
    scrollspyItemComponentType: [{ type: Input }],
    scrollspyTemplate: [{ type: ContentChild, args: [ScrollspyItemTemplateDirective, { read: TemplateRef },] }],
    currentSectionId: [{ type: Input }],
    scrollGroupId: [{ type: Input }],
    fFollowType: [{ type: Input }],
    sidetabWidth: [{ type: Input }],
    scrollyspyListEl: [{ type: ViewChild, args: ["scrollyspyList",] }],
    scrollspyData: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//锚点部分
class FarrisScrollSpyDirective {
    /**
     * @param {?} elementRef
     * @param {?} scrollSpy
     */
    constructor(elementRef, scrollSpy) {
        this.elementRef = elementRef;
        this.scrollSpy = scrollSpy;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.elementRef.nativeElement.className += ' f-scrollspy-part';
        if (!this.scrollGroupId) {
            this.scrollGroupId = this.scrollSpy.getGroupId();
        }
        //this.scrollSpy.addElement(this.elementRef.nativeElement, this.scrollId,this.scrollGroupId);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.scrollSpy.addElement(this.elementRef.nativeElement, this.scrollId, this.scrollGroupId);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollSpy.removeElement(this.scrollId, this.scrollGroupId);
    }
}
FarrisScrollSpyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fScrollSpy]'
            },] }
];
/** @nocollapse */
FarrisScrollSpyDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: FarrisScrollSpyService }
];
FarrisScrollSpyDirective.propDecorators = {
    scrollId: [{ type: Input, args: ['fScrollSpy',] }],
    scrollGroupId: [{ type: Input, args: ['fScrollGroup',] }]
};
//跟随点击
class FscrollFollowElementDirective {
    /**
     * @param {?} elementRef
     * @param {?} scrollSpy
     */
    constructor(elementRef, scrollSpy) {
        this.elementRef = elementRef;
        this.scrollSpy = scrollSpy;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.followGroupId) {
            this.followGroupId = this.scrollSpy.getGroupId();
        }
        this.scrollSpy.addFollowElement(this.elementRef.nativeElement, this.followId, this.followGroupId);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollSpy.removeFollowElement(this.followId, this.followGroupId);
    }
}
FscrollFollowElementDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fScrollFollowElement]'
            },] }
];
/** @nocollapse */
FscrollFollowElementDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: FarrisScrollSpyService }
];
FscrollFollowElementDirective.propDecorators = {
    followId: [{ type: Input, args: ['fScrollFollowElement',] }],
    followGroupId: [{ type: Input, args: ['fScrollElement',] }]
};
//监听滚动部分content
class FscrollSpyContainerDirective {
    /**
     * @param {?} elementRef
     * @param {?} scrollSpy
     * @param {?} changeDetector
     */
    constructor(elementRef, scrollSpy, changeDetector) {
        this.elementRef = elementRef;
        this.scrollSpy = scrollSpy;
        this.changeDetector = changeDetector;
        this.fScrollChange = new EventEmitter;
        this.position = "relative";
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.fScrollGroupId) {
            this.fScrollGroupId = this.scrollSpy.getGroupId();
        }
        this.elementRef.nativeElement.className += ' f-scrollspy-container';
        this.scrollSpy.addContentElement(this.elementRef.nativeElement, this.fScrollGroupId);
        this.scrollSpy.setOffset(this.fOffset, this.fScrollGroupId);
        this.scrollSpy.updateScrollGroup(this.fScrollGroupId).subscribe((/**
         * @param {?} currentSection
         * @return {?}
         */
        (currentSection) => {
            //console.log('111',currentSection);
            // bugNum:465991
            // console.log('section-group'+currentSection);
            this.fScrollChange.emit(currentSection);
            // this.scrollSpy.setCurrentSectionId(this.fScrollGroupId,currentSection);
            // this.changeDetector.markForCheck();
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // this.scrollSpy.getCurrentSection$(this.fScrollGroupId)
        // .subscribe((currentSection: string): void => {
        //   this.fScrollChange.next(currentSection);
        //   this.changeDetector.markForCheck();
        // });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollSpy.removeContentElement(this.fScrollGroupId);
    }
}
FscrollSpyContainerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fScrollSpyContainer]'
            },] }
];
/** @nocollapse */
FscrollSpyContainerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: FarrisScrollSpyService },
    { type: ChangeDetectorRef }
];
FscrollSpyContainerDirective.propDecorators = {
    fOffset: [{ type: Input }],
    fScrollGroupId: [{ type: Input, args: ['fScrollSpyContainer',] }],
    fScrollChange: [{ type: Output }],
    position: [{ type: HostBinding, args: ["style.position",] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollspyModule {
}
ScrollspyModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ScrollspyComponent, ScrollspyItemTemplateDirective, FarrisScrollSpyDirective, FscrollFollowElementDirective, FscrollSpyContainerDirective],
                imports: [
                    CommonModule,
                    AngularDraggableModule,
                    LocaleModule.forRoot(),
                    FarrisCommonModule
                ],
                providers: [
                    FarrisScrollSpyService
                ],
                exports: [ScrollspyComponent, ScrollspyItemTemplateDirective, FarrisScrollSpyDirective, FscrollFollowElementDirective, FscrollSpyContainerDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ScrollspyItemTemplateDirective, ScrollspyComponent, FarrisScrollSpyService, FarrisScrollSpyDirective, FscrollFollowElementDirective, FscrollSpyContainerDirective, ScrollspyModule, getUuid };

//# sourceMappingURL=farris-ui-scrollspy.js.map