import { InjectionToken, Injectable, Optional, Inject, defineInjectable, inject, Injector, INJECTOR, Directive, Input, HostListener, Component, ElementRef, HostBinding, NgModule } from '@angular/core';
import { NotifyService } from '@farris/ui-notify';
import { FileViewerService, FileListModule } from '@gsp-svc/file-viewer';
import { DownloadService, GspFormRemoveListEntity, GspFormUploadListEntity, GspFormUploadEntity, OperatingModes, GspFormDocInfo, UploadService, UploadDialogMoudle } from '@gsp-svc/formdoc-upload';
import { WEBAPI_PREFIX_TOKEN, FarrisCommonModule } from '@farris/ui-common';
import { UploadServerService, UploadStatus, FFileUploadModule } from '@farris/extend-file-upload';
import { Observable, of, forkJoin, Subject, concat, EMPTY } from 'rxjs';
import { switchMap, catchError, delay, map, expand, last, tap } from 'rxjs/operators';
import { LocaleService, LocaleModule } from '@farris/ui-locale';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/locale.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FARRIS_UPLOADSERVICE_LOCALEDATA = {
    'en': {
        'uploadAdapt': {
            'needFile': 'Please set the attachment to be downloaded',
            'recompile': 'Due to security issues, the attachment download provides a security verification mechanism, and the attachment download function needs to be recompiled',
            'uploadError': 'Upload failed'
        },
        'previewAdapt': {
            'notSupport': 'This file does not support preview'
        }
    },
    'zh-CHS': {
        'uploadAdapt': {
            'needFile': '请设置要下载的附件',
            'recompile': '因为安全问题，附件下载提供安全校验机制，附件下载功能需要重新编译',
            'uploadError': '上传失败'
        },
        'previewAdapt': {
            'notSupport': '此文件不支持预览'
        }
    },
    'zh-CHT': {
        'uploadAdapt': {
            'needFile': '請設定要下載的附件',
            'recompile': '因為安全問題，附件下載提供安全校驗機制，附件下載功能需要重新編譯',
            'uploadError': '上傳失敗'
        },
        'previewAdapt': {
            'notSupport': '此檔案不支持預覽'
        }
    }
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffileupload-adapt-unifile.config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FFileUploadAdaptUnifileConfig() { }
if (false) {
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.rootId;
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.formId;
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.mode;
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.options;
}
/** @type {?} */
const FFileUploadAdaptUnifileConfigToken = new InjectionToken('MFFileUploadAdaptUnifileConfig');
class FFileUploadAdaptUnifileConfigService {
    /**
     * @param {?} exConfig
     */
    constructor(exConfig) {
        this.config = (/** @type {?} */ ({
            rootId: '',
            formId: '',
            mode: 0
        }));
        this.basePerfixStr = '';
        if (exConfig) {
            Object.assign(this.config, exConfig);
        }
    }
    /**
     * 获取config属性的值
     * @return {?}
     */
    getConfig() {
        return this.config;
    }
    /**
     * 设置config的属性值
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setConfig(key, value) {
        this.config[key] = value;
    }
    /**
     * 设置基础路径
     * @param {?} value
     * @return {?}
     */
    setBasePath(value) {
        this.basePerfixStr = value;
    }
    /**
     * 获取基础路径
     * @return {?}
     */
    getBasePath() {
        return this.basePerfixStr;
    }
    /**
     * @param {?} localSer
     * @return {?}
     */
    setLocalState(localSer) {
        if (this.localSerStorage) {
            return true;
        }
        if (localSer && !this.localSerStorage) {
            localSer.setLocaleData(FARRIS_UPLOADSERVICE_LOCALEDATA);
            this.localSerStorage = localSer;
            return true;
        }
        return false;
    }
    /**
     * 获取多语言数据
     * 某些组件没有重新生成，要支持多语言
     * @param {?} lanKey
     * @return {?}
     */
    getLocalStr(lanKey) {
        /** @type {?} */
        let result = "";
        /** @type {?} */
        let defaultLocalId = 'en';
        if (this.localSerStorage) {
            result = this.localSerStorage.getValue(lanKey);
        }
        else {
            defaultLocalId = localStorage.getItem('languageCode') || 'zh-CHS';
        }
        if (!result) {
            result = lanKey.split('.').reduce((/**
             * @param {?} obj
             * @param {?} key
             * @return {?}
             */
            (obj, key) => {
                if (obj) {
                    return obj[key];
                }
                else {
                    return null;
                }
            }), FARRIS_UPLOADSERVICE_LOCALEDATA[defaultLocalId]);
        }
        return result;
    }
}
FFileUploadAdaptUnifileConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FFileUploadAdaptUnifileConfigService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FFileUploadAdaptUnifileConfigToken,] }] }
];
/** @nocollapse */ FFileUploadAdaptUnifileConfigService.ngInjectableDef = defineInjectable({ factory: function FFileUploadAdaptUnifileConfigService_Factory() { return new FFileUploadAdaptUnifileConfigService(inject(FFileUploadAdaptUnifileConfigToken, 8)); }, token: FFileUploadAdaptUnifileConfigService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    FFileUploadAdaptUnifileConfigService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    FFileUploadAdaptUnifileConfigService.prototype.basePerfixStr;
    /**
     * @type {?}
     * @private
     */
    FFileUploadAdaptUnifileConfigService.prototype.localSerStorage;
}
;

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-unifile.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FfilepreviewAdaptUnifileService {
    /**
     * @param {?} fileviewSer
     * @param {?} configSer
     * @param {?} downloadSer
     * @param {?} inject
     */
    constructor(fileviewSer, configSer, downloadSer, inject) {
        this.fileviewSer = fileviewSer;
        this.configSer = configSer;
        this.downloadSer = downloadSer;
        this.inject = inject;
        // 暂时用于简单合并
        this.previewExtendServerConfig = null;
        this.notifySer = null;
        this.perfixStr = '';
        this.extendData = this.configSer.getConfig();
        this.notifySer = this.fileviewSer['injector'].get(NotifyService, null);
        if (this.notifySer) {
            this.configSer.setLocalState(this.notifySer.localeService);
        }
        // 此处inject的时机和upload服务里的一样，此处不用再判断多语言
        if (this.inject) {
            if (WEBAPI_PREFIX_TOKEN) {
                this.perfixStr = this.inject.get(WEBAPI_PREFIX_TOKEN, '');
                this.configSer.setBasePath(this.perfixStr);
            }
        }
    }
    /**
     * 返回最终属性值
     * @private
     * @param {?} key
     * @param {?} extendValue
     * @return {?}
     */
    getFinallyConfig(key, extendValue) {
        if (extendValue && extendValue.hasOwnProperty(key)) {
            return extendValue[key];
        }
        // 避免下载等其他指令再传入扩展配置
        if (this.previewExtendServerConfig && this.previewExtendServerConfig.hasOwnProperty(key)) {
            return this.previewExtendServerConfig[key];
        }
        // 来自module中forRoot的配置
        if (this.extendData.hasOwnProperty(key)) {
            return this.extendData[key];
        }
        return null;
    }
    /**
     * 预览单个文件
     * @param {?} info
     * @param {?} extendService
     * @return {?}
     */
    previewFile(info, extendService) {
        return this.previewFileList([info], extendService);
    }
    /**
     * 预览整个列表
     * @param {?} infos
     * @param {?} extendService
     * @return {?}
     */
    previewFileList(infos, extendService) {
        //metadataIdList: string[]
        /** @type {?} */
        let rootId = this.getFinallyConfig('rootId', extendService);
        /** @type {?} */
        let metadataIdList = [];
        infos.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            metadataIdList.push(item.extend['metadataId']);
        }));
        /** @type {?} */
        let options = this.getFinallyConfig('options', extendService);
        if (options) {
            return this.fileviewSer.viewerFileList(metadataIdList, rootId, options);
        }
        else {
            return this.fileviewSer.viewerFileList(metadataIdList, rootId);
        }
    }
    /**
     * 下载附件
     * @param {?} info
     * @param {?} extendService
     * @return {?}
     */
    downloadFile(info, extendService) {
        if (!info.id) {
            /** @type {?} */
            let failMsg = this.getLocalStr('uploadAdapt.needFile');
            if (this.notifySer) {
                this.notifySer.warning(failMsg);
                return;
            }
            else {
                throw new Error(failMsg);
            }
        }
        window.open(this.getImgSrc(info, extendService));
    }
    /**
     * 下载附件
     * @param {?} infos
     * @param {?} extendService
     * @return {?}
     */
    multiDownloadFiles(infos, extendService) {
        //metadataIdList: string[]
        if (infos.length == 1) {
            this.downloadFile(infos[0], extendService);
        }
        else {
            /** @type {?} */
            let rootId = this.getFinallyConfig('rootId', extendService);
            /** @type {?} */
            let metadataIdList = [];
            infos.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                metadataIdList.push(item.extend['metadataId']);
            }));
            /** @type {?} */
            let url = this.downloadSer.getMultipleDownloadUrl(JSON.stringify(metadataIdList), rootId);
            window.open(url);
        }
    }
    /**
     * @param {?} infos
     * @param {?=} name
     * @param {?=} extendService
     * @return {?}
     */
    multiDownloadFilesWidthName(infos, name = "", extendService) {
        //metadataIdList: string[]
        if (infos.length == 1) {
            this.downloadFile(infos[0], extendService);
        }
        else {
            /** @type {?} */
            let rootId = this.getFinallyConfig('rootId', extendService);
            /** @type {?} */
            let metadataIdList = [];
            infos.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                metadataIdList.push(item.extend['metadataId']);
            }));
            /** @type {?} */
            let url = this.downloadSer.getMultipleDownloadUrlWithName(JSON.stringify(metadataIdList), rootId, name);
            window.open(url);
        }
    }
    /**
     * 获取下载链接
     * @param {?} info
     * @param {?} extendService
     * @return {?}
     */
    getImgSrc(info, extendService) {
        if (!info.id) {
            /** @type {?} */
            let failMsg = this.getLocalStr('uploadAdapt.needFile');
            if (this.notifySer) {
                this.notifySer.warning(failMsg);
                return;
            }
            else {
                throw new Error(failMsg);
            }
        }
        /** @type {?} */
        let url = '';
        /** @type {?} */
        let attachId = info.extend['metadataId'];
        /** @type {?} */
        let rootId = this.getFinallyConfig('rootId', extendService);
        // 文档服务服务单元名进行规范性调整，由document修改为dfs
        if (this.downloadSer) {
            if (rootId) {
                url = this.downloadSer.getDownloadUrl(attachId, rootId);
            }
        }
        else if (rootId) {
            console.warn(this.getLocalStr('uploadAdapt.recompile'));
            url = `${this.perfixStr}/api/runtime/dfs/v1.0/formdoc/filecontent?metadataid=${attachId}&rootid=${rootId}`;
        }
        return url;
    }
    /**
     * 根据预览指令的扩展配置获取
     * @param {?} value
     * @return {?}
     */
    setPreviwExtendServerConfig(value) {
        this.previewExtendServerConfig = value;
    }
    /**
     * @return {?}
     */
    getPreviewExtendServerConfig() {
        return this.previewExtendServerConfig;
    }
    /**
     * @param {?} lanKey
     * @return {?}
     */
    getLocalStr(lanKey) {
        return this.configSer.getLocalStr(lanKey);
    }
}
FfilepreviewAdaptUnifileService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FfilepreviewAdaptUnifileService.ctorParameters = () => [
    { type: FileViewerService },
    { type: FFileUploadAdaptUnifileConfigService },
    { type: DownloadService, decorators: [{ type: Optional }] },
    { type: Injector, decorators: [{ type: Optional }] }
];
/** @nocollapse */ FfilepreviewAdaptUnifileService.ngInjectableDef = defineInjectable({ factory: function FfilepreviewAdaptUnifileService_Factory() { return new FfilepreviewAdaptUnifileService(inject(FileViewerService), inject(FFileUploadAdaptUnifileConfigService), inject(DownloadService, 8), inject(INJECTOR, 8)); }, token: FfilepreviewAdaptUnifileService, providedIn: "root" });
if (false) {
    /** @type {?} */
    FfilepreviewAdaptUnifileService.prototype.extendData;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.previewExtendServerConfig;
    /** @type {?} */
    FfilepreviewAdaptUnifileService.prototype.notifySer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.perfixStr;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.fileviewSer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.configSer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.downloadSer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.inject;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-unifile-simple.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FFileAdaptPreviewFileDirective {
    /**
     * @param {?} previewSer
     */
    constructor(previewSer) {
        this.previewSer = previewSer;
        // 是否禁用预览
        this.viewDisabled = false;
        // 处理扩展的服务器端配置
        this.extendServerConfig = null;
    }
    /**
     * 捕获预览事件
     * @return {?}
     */
    filePreviewEventHandler() {
        if (!this.fileInfo || this.viewDisabled) {
            return;
        }
        this.previewSer.previewFile(this.fileInfo, this.extendServerConfig);
    }
}
FFileAdaptPreviewFileDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fFileAdaptPreviewFile]'
            },] }
];
/** @nocollapse */
FFileAdaptPreviewFileDirective.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService }
];
FFileAdaptPreviewFileDirective.propDecorators = {
    fileInfo: [{ type: Input, args: ['fFileAdaptPreviewFile',] }],
    filePreviewEventHandler: [{ type: HostListener, args: ['click', ['$event'],] }],
    viewDisabled: [{ type: Input }],
    extendServerConfig: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FFileAdaptPreviewFileDirective.prototype.fileInfo;
    /** @type {?} */
    FFileAdaptPreviewFileDirective.prototype.viewDisabled;
    /** @type {?} */
    FFileAdaptPreviewFileDirective.prototype.extendServerConfig;
    /**
     * @type {?}
     * @private
     */
    FFileAdaptPreviewFileDirective.prototype.previewSer;
}
class FFileAdaptDownloadFileDirective {
    /**
     * @param {?} previewSer
     */
    constructor(previewSer) {
        this.previewSer = previewSer;
        //重命名
        this.zipName = '';
        // 是否禁用下载
        this.downloadDisabled = false;
        // 处理扩展的服务器端配置
        this.extendServerConfig = null;
        // 是否启用批量下载
        this.enableMulti = false;
    }
    /**
     * 捕获预览事件
     * @return {?}
     */
    filePreviewEventHandler() {
        if (!this.fileInfo || this.downloadDisabled) {
            return;
        }
        if (this.enableMulti && this.fileInfo instanceof Array) {
            this.previewSer.multiDownloadFilesWidthName(this.fileInfo, this.zipName, this.extendServerConfig);
        }
        else {
            this.previewSer.downloadFile(this.fileInfo, this.extendServerConfig);
        }
    }
}
FFileAdaptDownloadFileDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fFileAdaptDownloadFile]'
            },] }
];
/** @nocollapse */
FFileAdaptDownloadFileDirective.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService }
];
FFileAdaptDownloadFileDirective.propDecorators = {
    fileInfo: [{ type: Input, args: ['fFileAdaptDownloadFile',] }],
    filePreviewEventHandler: [{ type: HostListener, args: ['click', ['$event'],] }],
    zipName: [{ type: Input }],
    downloadDisabled: [{ type: Input }],
    extendServerConfig: [{ type: Input }],
    enableMulti: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.fileInfo;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.zipName;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.downloadDisabled;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.extendServerConfig;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.enableMulti;
    /**
     * @type {?}
     * @private
     */
    FFileAdaptDownloadFileDirective.prototype.previewSer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-seeimg/ffilepreview-adapt-seeimg.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FfilepreviewAdaptSeeimgComponent {
    /**
     * @param {?} adpSer
     * @param {?} elementRef
     */
    constructor(adpSer, elementRef) {
        this.adpSer = adpSer;
        this.elementRef = elementRef;
        this.cls = true;
        // 是否启用图片的缩略图，默认为false；如果启用，图片类型会出现缩略图；不启用，根据类型显示图标
        this.enableThumbnail = false;
        // 图标的样式前缀
        this.clsPrefix = 'ffilepreview--filetype';
        // 显示缩略图中时，定义哪些后缀属于图片;
        this.supportImgSuffix = 'jpeg,jpg,gif,png,bmp';
        this.iconWidth = 38;
        // 缩略图的最大宽度
        this.maxThumbnailWidth = '100%';
        // 缩略图的最小宽度
        this.maxThumbnailHeight = '100%';
        // 处理扩展的服务器端配置，这样可以支持每个指令预览不同的目录，比如{'rootId':'default-root','formId':'formId'}
        this.extendServerConfig = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * 获取图片的链接
     * @return {?}
     */
    imgSrc() {
        return this.adpSer.getImgSrc(this.fileInfo, this.extendServerConfig);
    }
    /**
     * 判断是否是图片
     * @return {?}
     */
    isImage() {
        // 没有数据
        if (!this.fileInfo) {
            return false;
        }
        // 没有名称
        /** @type {?} */
        let fileName = this.fileInfo.name;
        if (!fileName) {
            return false;
        }
        /** @type {?} */
        let lastDotIndex = fileName.lastIndexOf(".");
        /** @type {?} */
        let fileSuffix = '';
        if (lastDotIndex > -1) {
            fileSuffix = fileName.substring(lastDotIndex + 1).toLocaleLowerCase();
        }
        if (!fileSuffix) {
            return false;
        }
        /** @type {?} */
        let tImgSuffixArray = this.supportImgSuffix.split(',');
        /** @type {?} */
        let tIndex = tImgSuffixArray.findIndex((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return item == fileSuffix;
        }));
        if (tIndex > -1) {
            return true;
        }
        return false;
    }
    /**
     * 获取文件类型样式
     * @return {?}
     */
    getFileTypeClassName() {
        /** @type {?} */
        let clsName = this.clsPrefix;
        // 如果名称为空
        if (!this.fileInfo || !this.fileInfo['name']) {
            return clsName + '-any';
        }
        /** @type {?} */
        let fileName = this.fileInfo['name'];
        /** @type {?} */
        let lastDotIndex = fileName.lastIndexOf(".");
        /** @type {?} */
        let fileSuffix = '';
        if (lastDotIndex > -1) {
            fileSuffix = fileName.substring(lastDotIndex + 1).toLocaleLowerCase();
        }
        switch (fileSuffix) {
            case 'pdf':
                clsName += '-pdf';
                break;
            case 'jpeg':
            case 'jpg':
            case 'gif':
            case 'png':
            case 'bmp':
                clsName += '-img';
                break;
            case 'ppt':
                clsName += '-ppt';
                break;
            case 'doc':
            case 'docx':
                clsName += '-doc';
                break;
            case 'xls':
            case 'xlsx':
                clsName += '-xls';
                break;
            case 'txt':
                clsName += '-txt';
                break;
            case 'zip':
                clsName += '-zip';
                break;
            default:
                clsName += '-any';
        }
        return clsName;
    }
}
FfilepreviewAdaptSeeimgComponent.decorators = [
    { type: Component, args: [{
                selector: 'ffilepreview-adapt-seeimg',
                template: "<div class=\"ffilepreview-seeimg--wrapper\" [ngClass]=\"{'ffilepreview-seeimg--thumbnail':enableThumbnail}\">\r\n  <ng-container *ngIf=\"enableThumbnail&&isImage();else notImage\">\r\n    <img class=\"ffilepreview-seeimg--img\" [src]=\"imgSrc()\" [ngStyle]=\"{'maxWidth':maxThumbnailWidth,'maxHeight':maxThumbnailHeight}\"/>\r\n  </ng-container>\r\n</div>\r\n<ng-template #notImage>\r\n  <span class=\"ffilepreview--filetype-icon\" [ngClass]=\"getFileTypeClassName()\" [ngStyle]=\"{'width':iconWidth+'px','height':iconWidth+'px'}\"></span>\r\n</ng-template>",
                styles: [":host{height:100%;width:100%;position:relative}.ffilepreview-seeimg--thumbnail{top:0;bottom:0;position:absolute;right:0;left:0;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center}.ffilepreview-seeimg--wrapper:hover{opacity:.8}.ffilepreview-seeimg--img{max-width:100%;max-height:100%;border-radius:4px}"]
            }] }
];
/** @nocollapse */
FfilepreviewAdaptSeeimgComponent.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService },
    { type: ElementRef }
];
FfilepreviewAdaptSeeimgComponent.propDecorators = {
    cls: [{ type: HostBinding, args: ['class.ffilepreview-adapt-seeimg',] }],
    enableThumbnail: [{ type: Input }],
    clsPrefix: [{ type: Input }],
    supportImgSuffix: [{ type: Input }],
    fileInfo: [{ type: Input }],
    iconWidth: [{ type: Input }],
    maxThumbnailWidth: [{ type: Input }],
    maxThumbnailHeight: [{ type: Input }],
    extendServerConfig: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.cls;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.enableThumbnail;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.clsPrefix;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.supportImgSuffix;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.fileInfo;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.iconWidth;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.maxThumbnailWidth;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.maxThumbnailHeight;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.extendServerConfig;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptSeeimgComponent.prototype.adpSer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptSeeimgComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffileupload-adapt-unifile.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function UploadServerConfig() { }
if (false) {
    /** @type {?} */
    UploadServerConfig.prototype.sameNameAllowed;
    /** @type {?} */
    UploadServerConfig.prototype.maxFileSize;
    /** @type {?} */
    UploadServerConfig.prototype.allowedMultiUpload;
    /** @type {?|undefined} */
    UploadServerConfig.prototype.uploadedFileInfoList;
    /** @type {?|undefined} */
    UploadServerConfig.prototype.oldUploadedFileList;
}
class FfileuploadAdaptUnifileService extends UploadServerService {
    /**
     * @param {?} uploadSer
     * @param {?} configSer
     * @param {?} inject
     */
    constructor(uploadSer, configSer, inject) {
        super();
        this.uploadSer = uploadSer;
        this.configSer = configSer;
        this.inject = inject;
        // 暂时用于简单合并
        this.bufferSize = 1024 * 1024;
        this.uploadedChunk = {};
        this.fileTotalChunk = {};
        this.serverConfig = null;
        this.extendData = this.configSer.getConfig();
        // 开始创建多语言服务
        /** @type {?} */
        let hasLocalSer = this.configSer.setLocalState(null);
        if (this.inject && !hasLocalSer) {
            // 如果存在inject，再次创建，inject是在某个版不能之后才出现的
            this.configSer.setLocalState(this.inject.get(LocaleService, null));
        }
    }
    /**
     * 因为被附件组件作为依赖类，导致此处获取不到最新的基路径值
     * @private
     * @return {?}
     */
    getPrefixStr() {
        return this.configSer.getBasePath();
    }
    /**
     * @private
     * @return {?}
     */
    uuid() {
        /** @type {?} */
        let S4 = (/**
         * @return {?}
         */
        function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        });
        /** @type {?} */
        let nGuid = S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();
        return nGuid;
    }
    /**
     * 删除文件
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    remove(files, event, extendService) {
        return this.innerRemoveList(files, event, extendService);
    }
    /**
     * @private
     * @param {?} files
     * @param {?} event
     * @param {?=} extendService
     * @return {?}
     */
    innerRemoveList(files, event, extendService = null) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            let removeFileInfo = new GspFormRemoveListEntity();
            /** @type {?} */
            let metadataIdList = [];
            files.forEach((/**
             * @param {?} fileItem
             * @return {?}
             */
            (fileItem) => {
                if (fileItem["response"]) {
                    metadataIdList.push(fileItem["response"]["metadataId"]);
                }
            }));
            removeFileInfo.mode = this.getFinallyConfig("mode", extendService);
            /** @type {?} */
            let rootId = this.getFinallyConfig("rootId", extendService);
            removeFileInfo.metadataIdList = [].concat(metadataIdList);
            this.uploadSer.removeList(metadataIdList, rootId).subscribe((/**
             * @param {?} result
             * @return {?}
             */
            (result) => {
                // 没有需要整合的服务器端返回数据
                observer.next({ type: "removed", files: files });
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                observer.error(error);
                observer.complete();
            }), (/**
             * @return {?}
             */
            () => {
                observer.complete();
            }));
        }));
    }
    /**
     * 上传文件
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    upload(files, event, extendService) {
        this.formId = this.getFinallyConfig("formId", extendService);
        this.rootId = this.getFinallyConfig("rootId", extendService);
        if (event.type == "sliceUpload") {
            /** @type {?} */
            const up$ = (/**
             * @return {?}
             */
            () => {
                if (this.serverConfig && this.serverConfig.allowedMultiUpload) {
                    if (!this.serverConfig.sameNameAllowed) {
                        return this.uploadSer.getUploadedFileInfoList(this.formId, this.rootId).pipe(switchMap((/**
                         * @param {?} res
                         * @return {?}
                         */
                        (res) => {
                            if (res != null && res.error == null) {
                                this.serverConfig.uploadedFileInfoList = res;
                                this.serverConfig.oldUploadedFileList = JSON.parse(JSON.stringify(res));
                                return this.uploadBigFile2(files, event, extendService);
                            }
                            return of(res);
                        })));
                    }
                    else {
                        return this.uploadBigFile2(files, event, extendService);
                    }
                }
                else {
                    return this.uploadBigFile(files, event, extendService);
                }
            });
            if (!this.serverConfig) {
                return this.getServerConfig(this.rootId).pipe(switchMap((/**
                 * @param {?} res
                 * @return {?}
                 */
                (res) => {
                    if (res != null && res.error == null) {
                        this.serverConfig = {
                            sameNameAllowed: res.sameNameAllowed,
                            allowedMultiUpload: res.allowedMultiUpload,
                            maxFileSize: parseInt(JSON.parse(res.validateConfiguration).maxFileSize)
                        };
                    }
                    return up$();
                })));
            }
            return up$();
        }
        return this.innerUploadList(files, event, extendService);
    }
    /**
     * 内部上传方式
     * @private
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    innerUploadList(files, event, extendService) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            /** @type {?} */
            let uploadInfo = new GspFormUploadListEntity();
            uploadInfo.formId = this.getFinallyConfig("formId", extendService);
            uploadInfo.mode = this.getFinallyConfig("mode", extendService);
            /** @type {?} */
            let rootId = this.getFinallyConfig("rootId", extendService);
            uploadInfo.docInfoList = [];
            /** @type {?} */
            let readerObserable = [];
            files.forEach((/**
             * @param {?} fileItem
             * @return {?}
             */
            (fileItem) => {
                /** @type {?} */
                let sub = new Observable((/**
                 * @param {?} obser
                 * @return {?}
                 */
                (obser) => {
                    /** @type {?} */
                    let reader = new FileReader();
                    // 暂不处理异常
                    reader.readAsBinaryString(fileItem.nativeFile);
                    reader.onload = (/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        /** @type {?} */
                        let info = (/** @type {?} */ ({ fileName: "", fileContent: "" }));
                        info["fileName"] = fileItem.name;
                        info["fileContent"] = btoa(reader.result.toString());
                        // 如果data里有数据，并且属性是配置的扩展属性
                        if (event.hasOwnProperty("data") &&
                            event["data"] &&
                            event["data"].hasOwnProperty("extProperty")) {
                            //
                            info["extProperty"] = event["data"]["extProperty"];
                        }
                        uploadInfo.docInfoList.push(info);
                        obser.next();
                        obser.complete();
                    });
                }));
                readerObserable.push(sub);
            }));
            forkJoin(readerObserable).subscribe((/**
             * @param {?} datas
             * @return {?}
             */
            (datas) => {
                //     metadataId: string;
                //  fileName: string;
                this.uploadSer.uploadList(uploadInfo, rootId).subscribe((/**
                 * @param {?} result
                 * @return {?}
                 */
                (result) => {
                    if (result.error) {
                        // 此接口一旦出现问题，所有附件都上传不通过
                        observer.error(this.errorInfoFormat(result.error, files));
                        observer.complete();
                        return;
                    }
                    // 合并返回结果到此处
                    result.forEach((/**
                     * @param {?} item
                     * @return {?}
                     */
                    (item) => {
                        /** @type {?} */
                        var findIndex = this.findFileIndexByFileName(files, item.fileName);
                        if (findIndex > -1) {
                            files[findIndex]["response"] = item;
                            files[findIndex]["progress"]["status"] = UploadStatus.Done;
                        }
                    }));
                    observer.next({ type: "done", files: files });
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    observer.error(this.errorInfoFormat(error, files));
                    observer.complete();
                }), (/**
                 * @return {?}
                 */
                () => {
                    observer.complete();
                }));
            }));
        }));
    }
    /**
     * 分片加载
     * @param {?} file
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    multipartUpload(file, event, extendService) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            // let fileInfo: FileInfo;
            /** @type {?} */
            let uuid = this.uuid();
            // let uuid = UUID.UUID();
            //reader.readAsBinaryString(selectedFile);
            //reader.onload = (e) => {
            /** @type {?} */
            let fileName = file.name;
            // fileInfo = {
            //   id: uuid,
            //   name: fileName,
            //   type: file.type,
            //   source: "",
            //   size: this.formatFileSize(file.size),
            //   fileSize: file.size,
            //   picListDisplayName: this.getMultipartDisplayName(fileName),
            //   queueListDisplayName: fileName,
            //   //content: reader.result.toString(),
            //   hasUploaded: false,
            //   mouseOn: false,
            //   selectd: false,
            //   isUploading: true,
            //   uploadResult: false,
            //   uploadProcess: 0,
            //   errorMessage: "",
            //   extensionDropListId: 0,
            //   extensionName: ""
            // }
            /** @type {?} */
            let chunkTotal = Math.ceil(file.size / this.bufferSize);
            // 标记当前附件总的分片数
            this.fileTotalChunk[uuid] = chunkTotal;
            /** @type {?} */
            let chunkIndex = 0;
            // 标记当前附件成功的分片数
            this.uploadedChunk[uuid] = 0;
            while (chunkIndex < chunkTotal) {
                /** @type {?} */
                let uploadInfo = new GspFormUploadEntity();
                uploadInfo.mode = OperatingModes.Temp;
                uploadInfo.formId = this.getFinallyConfig("formId", extendService);
                uploadInfo.rootId = this.getFinallyConfig("rootId", extendService);
                /** @type {?} */
                let docInfo = new GspFormDocInfo();
                docInfo.fileName = fileName;
                docInfo.metadataId = uuid;
                docInfo.total = chunkTotal;
                // 如果data里有数据，并且属性是配置的扩展属性
                if (event.hasOwnProperty("data") &&
                    event["data"] &&
                    event["data"].hasOwnProperty("extProperty")) {
                    docInfo["extProperty"] = (/** @type {?} */ (event["data"]["extProperty"]));
                }
                // 下一个文件大小
                /** @type {?} */
                let nextSize = Math.min((chunkIndex + 1) * this.bufferSize, file.size);
                // File类型
                /** @type {?} */
                let fileData = file["nativeFile"].slice(chunkIndex * this.bufferSize, nextSize);
                // 读取文件
                /** @type {?} */
                let reader = new FileReader();
                reader.readAsBinaryString(fileData);
                /** @type {?} */
                let innerIndex = chunkIndex;
                reader.onload = (/**
                 * @return {?}
                 */
                () => {
                    // 附件上传
                    docInfo.fileContent = btoa(reader.result.toString());
                    docInfo.index = innerIndex;
                    uploadInfo.docInfo = docInfo;
                    /** @type {?} */
                    let info = uploadInfo;
                    this.uploadSer.uploadFile(info).subscribe((/**
                     * @param {?} result
                     * @return {?}
                     */
                    (result) => {
                        if (result && result.error) {
                            // 分片上传有返回结果就是报错了
                            observer.error(this.errorInfoFormat(result.error, [file]));
                            observer.complete();
                            return;
                        }
                        else {
                            this.uploadedChunk[uuid]++;
                            if (this.uploadedChunk[docInfo.metadataId] ==
                                this.fileTotalChunk[docInfo.metadataId]) {
                                // 判断是所有分片都上传完成
                                file.progress = {
                                    status: UploadStatus.Done,
                                    data: {
                                        percentage: 100,
                                    },
                                };
                                file.response = docInfo;
                                delete this.uploadedChunk[uuid];
                                delete this.fileTotalChunk[uuid];
                                observer.next({ type: "done", files: [file] });
                                observer.complete();
                            }
                            else {
                                // 分片上传正常
                                /** @type {?} */
                                const percentage = Number.parseInt(((this.uploadedChunk[uuid] / this.fileTotalChunk[uuid]) *
                                    100).toFixed(0));
                                // 判断未上传完成
                                file.progress = {
                                    status: UploadStatus.Uploading,
                                    data: {
                                        percentage: percentage,
                                    },
                                };
                                observer.next({ type: "uploading", files: [file] });
                            }
                        }
                    }), (/**
                     * @param {?} error
                     * @return {?}
                     */
                    (error) => {
                        delete this.uploadedChunk[uuid];
                        delete this.fileTotalChunk[uuid];
                        observer.error(this.errorInfoFormat(error, [file]));
                        observer.complete();
                    }));
                });
                chunkIndex = chunkIndex + 1;
            }
        }));
    }
    /**
     * 获取分片的附件大小
     * @private
     * @param {?} size
     * @return {?}
     */
    formatFileSize(size) {
        if (size < 102400)
            return (size / 1024).toFixed(1) + "K";
        else if (size < 1024 * 1024)
            return (size / 1024).toFixed(0) + "K";
        else if (size < 100 * 1024 * 1024)
            return (size / 1024 / 1024).toFixed(1) + "M";
        else if (size < 1024 * 1024 * 1024)
            return (size / 1024 / 1024).toFixed(0) + "M";
        else
            return (size / 1024 / 1024 / 1024).toFixed(1) + "G";
    }
    /**
     * 获取分片的 附件名称
     * @private
     * @param {?} fileName
     * @return {?}
     */
    getMultipartDisplayName(fileName) {
        if (fileName.length <= 10)
            return fileName;
        else {
            /** @type {?} */
            let headContent = fileName.substring(0, 2);
            /** @type {?} */
            let tailContent = fileName.substring(fileName.lastIndexOf(".") - 2);
            return headContent + "…" + tailContent;
        }
    }
    /**
     * @private
     * @param {?} error
     * @param {?} files
     * @return {?}
     */
    errorInfoFormat(error, files) {
        //
        /** @type {?} */
        let errorFiles = files.map((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            return { id: item.id, name: item.name };
        }));
        /** @type {?} */
        let errorMsg = this.configSer.getLocalStr('uploadAdapt.uploadError');
        if (error) {
            return Object.assign(error, { files: errorFiles }, {
                message: error["Message"] || error["extensionMessage"] || errorMsg,
                type: "error",
            });
        }
        else {
            return Object.assign({ files: errorFiles }, { message: errorMsg, type: "error" });
        }
    }
    /**
     * 返回最终属性值
     * @private
     * @param {?} key
     * @param {?} extendValue
     * @return {?}
     */
    getFinallyConfig(key, extendValue) {
        if (extendValue && extendValue.hasOwnProperty(key)) {
            return extendValue[key];
        }
        return this.extendData[key];
    }
    /**
     * @private
     * @param {?} files
     * @param {?} fileName
     * @return {?}
     */
    findFileIndexByFileName(files, fileName) {
        // 按照肯定能找到文件来处理
        /** @type {?} */
        let findIndex = files.findIndex((/**
         * @param {?} file
         * @return {?}
         */
        (file) => file.name == fileName));
        return findIndex;
    }
    //#region 大文件分片上传
    /**
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    uploadBigFile(files, event, extendService) {
        /** @type {?} */
        const uploadChunks$ = new Subject();
        /** @type {?} */
        const _files = files.map((/**
         * @param {?} n
         * @return {?}
         */
        (n) => {
            /** @type {?} */
            const chunks = this._getBigFileChunks(n, event, extendService);
            return Object.assign({}, n, chunks);
        }));
        /** @type {?} */
        const uploadchunks$ = _files.map((/**
         * @param {?} f
         * @return {?}
         */
        (f) => this.uploadChunks(f, uploadChunks$)));
        concat(...uploadchunks$).subscribe((/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            f.progress = {
                status: UploadStatus.Done,
                data: {
                    percentage: 100,
                },
            };
            f.response = JSON.parse(f.chunks[0].get("docInfo"));
            uploadChunks$.next({ type: "done", files: [f] });
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            uploadChunks$.error(this.errorInfoFormat(error, files));
            uploadChunks$.complete();
        }), (/**
         * @return {?}
         */
        () => {
            uploadChunks$.complete();
        }));
        return uploadChunks$.asObservable();
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    uploadFileChunk(file) {
        /** @type {?} */
        const url = `${this.getPrefixStr()}/api/runtime/dfs/v1.0/formdoc/slice`;
        return this.uploadSer["http"]["http"]
            .post(url, file.chunks[file.total])
            .pipe(switchMap((/**
         * @return {?}
         */
        () => {
            return of(file);
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            return of(error);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @param {?} upChunk$
     * @return {?}
     */
    uploadChunks(file, upChunk$) {
        /** @type {?} */
        const doChunksRemain = (/**
         * @param {?} i
         * @return {?}
         */
        (i) => i > -1);
        /** @type {?} */
        const completeUpload = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => of(f));
        /** @type {?} */
        const uploadChunk = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            return this.uploadFileChunk(f).pipe(delay(100), map((/**
             * @param {?} f
             * @return {?}
             */
            (f) => {
                // 块数为0 时，即为此文件的所有块均上传成功
                f.progress = {
                    status: UploadStatus.Uploading,
                    data: {
                        percentage: ((f.total / f.chunks.length) * 100).toFixed(0),
                    },
                };
                upChunk$.next({ type: "uploading", files: [f] });
                return f;
            })));
        });
        /** @type {?} */
        const createMultipartUpload = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => of(f));
        return createMultipartUpload(file).pipe(
        // tap((f) => console.log("upload file", f.name)),
        expand((/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            if (doChunksRemain(--file.total)) {
                return uploadChunk(file);
            }
            return EMPTY;
        })), 
        // tap((f: any) => {
        //     console.log(`file: ${f.name} - remaining chunks: ${f.total}`);
        // }),
        last(), switchMap((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            return completeUpload(file);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    _getBigFileChunks(file, event, extendService) {
        /** @type {?} */
        let uuid = this.uuid();
        /** @type {?} */
        const formId = this.getFinallyConfig("formId", extendService);
        /** @type {?} */
        const rootId = this.getFinallyConfig("rootId", extendService);
        /** @type {?} */
        let realChunkSize = (event.chunkSize || 1) * this.bufferSize;
        /** @type {?} */
        let chunkTotal = Math.ceil(file.size / realChunkSize);
        /** @type {?} */
        let chunkIndex = 0;
        /** @type {?} */
        const fileChunks = { chunks: [], total: chunkTotal };
        while (chunkIndex < chunkTotal) {
            /** @type {?} */
            let uploadInfo = new GspFormUploadEntity();
            uploadInfo.mode = OperatingModes.Temp;
            uploadInfo.formId = formId;
            uploadInfo.rootId = rootId;
            /** @type {?} */
            let docInfo = new GspFormDocInfo();
            docInfo.fileName = file.name;
            docInfo.metadataId = uuid;
            docInfo.total = chunkTotal;
            /** @type {?} */
            let nextSize = Math.min((chunkIndex + 1) * realChunkSize, file.size);
            // File类型
            /** @type {?} */
            let fileData = file["nativeFile"].slice(chunkIndex * realChunkSize, nextSize);
            docInfo.size = file.size;
            docInfo.index = chunkIndex;
            docInfo.fileContent = "";
            // 如果data里有数据，并且属性是配置的扩展属性
            if (event.hasOwnProperty("data") &&
                event["data"] &&
                event["data"].hasOwnProperty("extProperty")) {
                docInfo["extProperty"] = (/** @type {?} */ (event["data"]["extProperty"]));
            }
            uploadInfo.docInfo = docInfo;
            //封装请求formdata
            /** @type {?} */
            let formData = new FormData();
            formData.append("uploadInfo", JSON.stringify(uploadInfo));
            formData.append("docInfo", JSON.stringify(docInfo));
            formData.append("file", fileData);
            fileChunks.chunks.push(formData);
            chunkIndex = chunkIndex + 1;
        }
        return fileChunks;
    }
    /**
     * 获取跟目录的配置
     * @private
     * @param {?} rootId
     * @return {?}
     */
    getServerConfig(rootId) {
        return this.uploadSer.getUploadInfo(rootId);
    }
    //#endregion
    //#region 读取相关配置分片上传至云服务器
    /**
     * @private
     * @param {?} file
     * @param {?} uploadChunks$
     * @return {?}
     */
    unorderedUploadBigFile(file, uploadChunks$) {
        if (!file.partList) {
            file.partList = [];
        }
        this.initMultiUpload(file).subscribe((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            if (r && r.error) {
                uploadChunks$.error(this.errorInfoFormat(r.error, [file]));
                uploadChunks$.complete();
                return;
            }
            file.chunks.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                this.multiUpload(n, r).subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                (res) => {
                    if (res && res.error) {
                        uploadChunks$.error(this.errorInfoFormat(res.error, [file]));
                        uploadChunks$.complete();
                        return;
                    }
                    file.progress = {
                        status: UploadStatus.Uploading,
                        data: {
                            percentage: (res.index / file.chunks.length * 100).toFixed(0)
                        }
                    };
                    uploadChunks$.next({ type: 'uploading', files: [file] });
                    if (res && res.result) {
                        file.partList.push(res.result);
                    }
                    if (file.partList.length === file.chunks.length) {
                        /** @type {?} */
                        let completeMultiUploadRequest = {};
                        completeMultiUploadRequest.metadataId = file.metadataId;
                        completeMultiUploadRequest.partList = file.partList;
                        completeMultiUploadRequest.rootId = this.rootId;
                        completeMultiUploadRequest.uploadId = file.uploadId;
                        completeMultiUploadRequest.size = file.size;
                        this.completeMultiUpload(completeMultiUploadRequest).subscribe((/**
                         * @param {?} cmur
                         * @return {?}
                         */
                        (cmur) => {
                            if (cmur && cmur.status != 200) {
                                uploadChunks$.error(this.errorInfoFormat(cmur.error, [file]));
                                uploadChunks$.complete();
                                return;
                            }
                            file.progress = {
                                status: UploadStatus.Done,
                                data: {
                                    percentage: 100
                                }
                            };
                            file.response = JSON.parse(file.chunks[0].get("docInfo"));
                            uploadChunks$.next({ type: 'done', files: [file] });
                        }), (/**
                         * @param {?} error
                         * @return {?}
                         */
                        error => {
                            uploadChunks$.error(this.errorInfoFormat(error, [file]));
                            uploadChunks$.complete();
                        }));
                    }
                }));
            }));
        }));
    }
    /**
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    uploadBigFile2(files, event, extendService) {
        /** @type {?} */
        const uploadChunks$ = new Subject();
        /** @type {?} */
        const formId = this.getFinallyConfig('formId', extendService);
        /** @type {?} */
        const rootId = this.getFinallyConfig('rootId', extendService);
        /** @type {?} */
        const _files = files.map((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            /** @type {?} */
            const chunks = this._getBigFileChunks2(n, event, extendService);
            return Object.assign({}, n, chunks, { formId, rootId });
        }));
        // 无序上传
        _files.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            this.unorderedUploadBigFile(n, uploadChunks$);
        }));
        // 有序上传
        // const uploadchunks$: Observable<any>[] =  _files.map((f) => this.uploadChunks2(f, uploadChunks$));
        // concat(...uploadchunks$).pipe(
        //     switchMap((f: any) => {
        //         let completeMultiUploadRequest: any = {};
        //         completeMultiUploadRequest.metadataId = f.metadataId;
        //         completeMultiUploadRequest.partList = f.partList;
        //         completeMultiUploadRequest.rootId = this.rootId;
        //         completeMultiUploadRequest.uploadId = f.uploadId;
        //         completeMultiUploadRequest.size = f.size;
        //         return this.completeMultiUpload(completeMultiUploadRequest).pipe(
        //             map(() => f)
        //         );
        //     })
        // ).subscribe(
        //     (f: any) => {
        //         f.progress = {
        //             status: UploadStatus.Done,
        //             data:  {
        //                 percentage: 100
        //             }
        //         };
        //         f.response = JSON.parse(f.chunks[0].get("docInfo"));
        //         uploadChunks$.next({type: 'done', files:[f]});
        //     },
        //     error => {
        //         uploadChunks$.error(this.errorInfoFormat(error, files));
        //         uploadChunks$.complete();
        //     },
        //     () => {
        //         uploadChunks$.complete();
        //         // console.log("all files uploaded")
        //     }
        // );
        return uploadChunks$.asObservable();
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    initMultiUpload(file) {
        /** @type {?} */
        let initRequest = {};
        initRequest.path = file.formId;
        initRequest.metadataId = this.uuid();
        initRequest.rootId = file.rootId;
        initRequest.size = file.size;
        initRequest.fileName = file.name;
        /** @type {?} */
        let url = `${this.getPrefixStr()}/api/runtime/dfs/v1.0/formdoc/multi/init`;
        return this.uploadSer['http']['http'].post(url, initRequest).pipe(tap((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            file.metadataId = initRequest.metadataId;
            file.uploadId = res.uploadId;
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            return of(error);
        })), map((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            res.metadataId = initRequest.metadataId;
            return res;
        })));
    }
    /**
     * @private
     * @param {?} request
     * @return {?}
     */
    completeMultiUpload(request) {
        /** @type {?} */
        let url = `${this.getPrefixStr()}/api/runtime/dfs/v1.0/formdoc/multi/complete`;
        return this.uploadSer['http']['http'].post(url, request).pipe(tap((/**
         * @param {?} res
         * @return {?}
         */
        (res) => { })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            return of(error);
        })));
    }
    /**
     * @private
     * @param {?} formdata
     * @param {?} r
     * @return {?}
     */
    multiUpload(formdata, r) {
        /** @type {?} */
        let url = `${this.getPrefixStr()}/api/runtime/dfs/v1.0/formdoc/multi/upload`;
        /** @type {?} */
        const mr = JSON.parse((/** @type {?} */ (formdata.get('multiRequest'))));
        mr.uploadId = r.uploadId;
        mr.metadataId = r.metadataId;
        formdata.set('multiRequest', JSON.stringify(mr));
        /** @type {?} */
        const di = JSON.parse((/** @type {?} */ (formdata.get('docInfo'))));
        di.metadataId = r.metadataId;
        formdata.set('docInfo', JSON.stringify(di));
        return this.uploadSer['http']['http'].post(url, formdata).pipe(tap((/**
         * @param {?} res
         * @return {?}
         */
        res => { })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            return of(error);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @param {?} upChunk$
     * @return {?}
     */
    uploadChunks2(file, upChunk$) {
        /** @type {?} */
        const total = file.total;
        /** @type {?} */
        let t = -1;
        /** @type {?} */
        const doChunksRemain = (/**
         * @param {?} i
         * @return {?}
         */
        (i) => i < total);
        /** @type {?} */
        const completeUpload = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => of(f));
        /** @type {?} */
        const uploadChunk = (/**
         * @param {?} f
         * @param {?} uploadId
         * @return {?}
         */
        (f, uploadId) => {
            return this.multiUpload(f, uploadId).pipe(delay(100), map((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                // 块数为0 时，即为此文件的所有块均上传成功
                file.progress = {
                    status: UploadStatus.Uploading,
                    data: {
                        percentage: (res.index / file.chunks.length * 100).toFixed(0)
                    }
                };
                upChunk$.next({ type: 'uploading', files: [file] });
                if (res && res.result) {
                    if (!file.partList) {
                        file.partList = [];
                    }
                    file.partList.push(res.result);
                }
                return file;
            })));
        });
        /** @type {?} */
        const createMultipartUpload = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            return this.initMultiUpload(f);
            // return of(f)
        });
        return createMultipartUpload(file).pipe(
        // tap((f) => console.log("upload file", f.name)),
        expand((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            if (doChunksRemain(++t)) {
                return uploadChunk(file.chunks[t], r);
            }
            return EMPTY;
        })), 
        // tap((f: any) => {
        //     console.log(`file: ${f.name} - remaining chunks: ${f.total}`);
        // }),
        last(), switchMap((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            return completeUpload(file);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    _getBigFileChunks2(file, event, extendService) {
        /** @type {?} */
        let uuid = this.uuid();
        /** @type {?} */
        const _bifferSize = Math.max(event.chunkSize, 5) * this.bufferSize;
        /** @type {?} */
        let chunkTotal = Math.ceil(file.size / _bifferSize);
        /** @type {?} */
        let chunkIndex = 0;
        /** @type {?} */
        const fileChunks = { chunks: [], total: chunkTotal };
        /** @type {?} */
        const rootId = this.getFinallyConfig('rootId', extendService);
        while (chunkIndex < chunkTotal) {
            /** @type {?} */
            let nextSize = Math.min((chunkIndex + 1) * _bifferSize, file.size);
            // File类型
            /** @type {?} */
            let fileData = file['nativeFile'].slice(chunkIndex * _bifferSize, nextSize);
            /** @type {?} */
            let multiRequest = {};
            multiRequest.metadataId = uuid;
            multiRequest.rootId = rootId;
            // multiRequest.uploadId = uploadId;
            multiRequest.index = chunkIndex;
            multiRequest.total = chunkTotal;
            multiRequest.size = fileData.size;
            //封装请求formdata
            /** @type {?} */
            let formData = new FormData();
            formData.append('multiRequest', JSON.stringify(multiRequest));
            formData.append('file', fileData);
            /** @type {?} */
            let docInfo = new GspFormDocInfo();
            docInfo.fileName = file.name;
            docInfo.metadataId = uuid;
            docInfo.total = chunkTotal;
            docInfo.size = file.size;
            docInfo.index = chunkIndex;
            docInfo.fileContent = "";
            formData.append("docInfo", JSON.stringify(docInfo));
            // 如果data里有数据，并且属性是配置的扩展属性
            if (event.hasOwnProperty("data") &&
                event["data"] &&
                event["data"].hasOwnProperty("extProperty")) {
                docInfo["extProperty"] = (/** @type {?} */ (event["data"]["extProperty"]));
            }
            fileChunks.chunks.push(formData);
            chunkIndex = chunkIndex + 1;
        }
        return fileChunks;
    }
}
FfileuploadAdaptUnifileService.previous = 0;
FfileuploadAdaptUnifileService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root",
            },] }
];
/** @nocollapse */
FfileuploadAdaptUnifileService.ctorParameters = () => [
    { type: UploadService },
    { type: FFileUploadAdaptUnifileConfigService },
    { type: Injector, decorators: [{ type: Optional }] }
];
/** @nocollapse */ FfileuploadAdaptUnifileService.ngInjectableDef = defineInjectable({ factory: function FfileuploadAdaptUnifileService_Factory() { return new FfileuploadAdaptUnifileService(inject(UploadService), inject(FFileUploadAdaptUnifileConfigService), inject(INJECTOR, 8)); }, token: FfileuploadAdaptUnifileService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.previous;
    /** @type {?} */
    FfileuploadAdaptUnifileService.prototype.extendData;
    /** @type {?} */
    FfileuploadAdaptUnifileService.prototype.bufferSize;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.uploadedChunk;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.fileTotalChunk;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.formId;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.rootId;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.serverConfig;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.uploadSer;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.configSer;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.inject;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-unifile.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FFilePreviewAdaptUnifileDirective {
    /**
     * @param {?} previewSer
     */
    constructor(previewSer) {
        this.previewSer = previewSer;
        /**
         * 处理扩展的服务器端配置
         */
        this._extendServeConfig = null;
    }
    /**
     * 捕获预览事件
     * @param {?} fileInfo
     * @return {?}
     */
    filePreviewEventHandler(fileInfo) {
        // 可以通过属性 extendServerConfig设置，也可以通过一体化组件的Input属性配置
        /** @type {?} */
        const previewOpts = Object.assign(this.extendServerConfig || {});
        previewOpts.options = Object.assign(previewOpts.options || {}, { showDownload: !!fileInfo.showDownload }, { showComments: !!fileInfo.showComments }, { modeless: !!fileInfo.modeless });
        if (previewOpts.options.showHeader === undefined) {
            previewOpts.options.showHeader = true;
        }
        if (previewOpts.options.showFileList === undefined) {
            previewOpts.options.showFileList = true;
        }
        if (previewOpts.options.showComments === undefined) {
            previewOpts.options.showComments = false;
        }
        if (previewOpts.options.modeless === undefined) {
            previewOpts.options.modeless = false;
        }
        // 支持修订模式
        // 文件扩展名
        /** @type {?} */
        const extendName = fileInfo.name.substr(fileInfo.name.lastIndexOf('.') + 1).toLowerCase();
        /** @type {?} */
        const enablePreviews = ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'jpg', 'jpeg', 'png', 'gif', 'bmp', 'pdf', 'txt', 'wps', 'wpt', 'et', 'dps'];
        if (enablePreviews.includes(extendName)) {
            this.previewSer.previewFile(fileInfo, previewOpts);
        }
        else {
            /** @type {?} */
            const msg = this.previewSer.getLocalStr("previewAdapt.notSupport");
            if (this.previewSer.notifySer) {
                this.previewSer.notifySer.warning(msg);
            }
            else {
                alert(msg);
            }
        }
    }
    /**
     * 捕获下载事件
     * @param {?} downloadEv
     * @return {?}
     */
    fileDownloadEventHandler(downloadEv) {
        // 如果是批量下载, downloadEv={fileInfos:[],name:}
        if (downloadEv && downloadEv['fileInfos'].length > 0) {
            if (downloadEv['fileInfos'].length > 1) {
                this.previewSer.multiDownloadFilesWidthName(downloadEv['fileInfos'], downloadEv['name'], this.extendServerConfig);
            }
            else {
                this.previewSer.downloadFile(downloadEv['fileInfos'][0], this.extendServerConfig);
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set extendServerConfig(value) {
        this._extendServeConfig = value;
        this.previewSer.setPreviwExtendServerConfig(value);
    }
    /**
     * @return {?}
     */
    get extendServerConfig() {
        return this._extendServeConfig;
    }
}
FFilePreviewAdaptUnifileDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fFilePreviewAdaptUnifile]',
                providers: [FfilepreviewAdaptUnifileService]
            },] }
];
/** @nocollapse */
FFilePreviewAdaptUnifileDirective.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService }
];
FFilePreviewAdaptUnifileDirective.propDecorators = {
    filePreviewEventHandler: [{ type: HostListener, args: ['filePreviewEvent', ['$event'],] }],
    fileDownloadEventHandler: [{ type: HostListener, args: ['fileDownloadEvent', ['$event'],] }],
    extendServerConfig: [{ type: Input }]
};
if (false) {
    /**
     * 处理扩展的服务器端配置
     * @type {?}
     * @private
     */
    FFilePreviewAdaptUnifileDirective.prototype._extendServeConfig;
    /**
     * @type {?}
     * @private
     */
    FFilePreviewAdaptUnifileDirective.prototype.previewSer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffileupload-adapt-unifile.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FfileuploadAdaptUnifileModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: FfileuploadAdaptUnifileModule,
            providers: [
                { provide: FFileUploadAdaptUnifileConfigToken, useValue: config },
                FFileUploadAdaptUnifileConfigService,
                FfilepreviewAdaptUnifileService,
                FileViewerService
            ]
        };
    }
}
FfileuploadAdaptUnifileModule.decorators = [
    { type: NgModule, args: [{
                declarations: [FFilePreviewAdaptUnifileDirective, FfilepreviewAdaptSeeimgComponent, FFileAdaptDownloadFileDirective, FFileAdaptPreviewFileDirective],
                imports: [
                    CommonModule,
                    UploadDialogMoudle,
                    FileListModule,
                    FFileUploadModule.forRoot(null, FfileuploadAdaptUnifileService),
                    FarrisCommonModule,
                    LocaleModule.forRoot()
                ],
                exports: [
                    FFileUploadModule,
                    FFilePreviewAdaptUnifileDirective,
                    FfilepreviewAdaptSeeimgComponent,
                    FFileAdaptDownloadFileDirective,
                    FFileAdaptPreviewFileDirective
                ],
                providers: [
                    FFileUploadAdaptUnifileConfigService,
                    FfilepreviewAdaptUnifileService,
                    FileViewerService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: farris-extend-fileupload-adapt-unifile.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { FFileAdaptDownloadFileDirective, FFileAdaptPreviewFileDirective, FFilePreviewAdaptUnifileDirective, FFileUploadAdaptUnifileConfigService, FFileUploadAdaptUnifileConfigToken, FfilepreviewAdaptSeeimgComponent, FfilepreviewAdaptUnifileService, FfileuploadAdaptUnifileModule, FfileuploadAdaptUnifileService };
//# sourceMappingURL=farris-extend-fileupload-adapt-unifile.js.map
