import { OnDestroy } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import { DataTypeInfo, IDisposable } from '../core/index';
import { Modification } from '../changeset/index';
import { Entity } from '../entity/index';
import { EntityCollection } from './entity_collection';
import { PaginationManager } from './pagination_manager';
import { DataChangeHistory } from './data_change_history';
import { SortConditionManager } from './sort_condition_manager';
import { FilterConditionManager } from './filter_condition_manager';
/**
 * 本地仓库
 * @description
 * # Repository
 *
 * Repository负责与后台接口交互并将接口返回的数据转换为Entity集合进行保存。因此Repository有两个重要的职责：后端交互、数据存储。
 * Repository中存储的数据是Entity类型，可以通过API对数据进行修改或删除。由于Repository和BindingData相互监听，对数据仓库的操作最终会通过BindingData更新到界面上。
 *
 * ## 实体操作
 * 实体操作仅对Repository本地已经存在的数据进行操作，不会发送请求。
 *
 * - 通过主键获取实体
 *
 *   ```javascript
 *    this.repository.entityCollection.getEntityById("id");
 *   ```
 *
 * - 删除实体数据
 *
 *   ```javascript
 *   this.repository.entityCollection.removeEntityById("id")
 *   ```
 *
 * - 清空所有实体
 *
 *   ```javascript
 *   this.repository.entityCollection.clear();
 *   ```
 *
 * - 将实体数据转换为json格式
 *
 *   ```javascript
 *   this.repository.entityCollection.toJSON();
 *   ```
 *
 * - 添加实体
 *
 *   ```javascript
 *   this.repository.entityCollection.addEntity(entity:T);
 *   ```
 * - 添加子表实体
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   entityManager.appendEntityByPath("/主实体Id/子表名s",{子表JSON数据});
 *   ```
 * - 批量添加实体
 *
 *   ```javascript
 *   this.repository.entityCollection.addEntities(entities:T[])
 *   ```
 *
 * - 批量添加子表实体
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   const childrenEntities = entityManager.createEntitiesByPath(["主实体Id","子表名s"], entityListData: any[])
 *   entityManager.appendEntitiesByPath(["主实体Id","子表名s"],childrenEntities);
 *   ```
 *
 * - 批量加载实体
 *
 *   ```javascript
 *   this.repository.entityCollection.loadEntities(entities:T[]);
 *   ```
 *
 *   > 加载实体会将本地仓库数据置为加载的实体。
 *
 * - 创建实体
 *
 *   ```javascript
 *   this.repository.buildEntity(JSON数据);
 *   ```
 *
 * - 批量创建实体
 *
 *   ```javascript
 *   this.repository.buildEntities(JSON数据);
 *   ```
 *
 * - 获取子表数据
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   entityManager.getEntityByPath(["主实体Id","子表名","子表id"]);
 *   ```
 *
 *   !> **注意** entityManager属性仅存在于BefRepository类，因此在使用EntityManager时应先将Repository转换为BefRepository
 *
 * - 获取所有子表数据
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   entityManager.getEntitiesByPath(["主实体Id","子表名"]);
 *   ```
 *
 *   > EntityManager不仅可以获取子表数据，同样可以获取主表数据。
 *   >
 *   > ```javascript
 *   > entityManager.getEntitiesByPath(["主实体Id"]);
 *   > ```
 *
 * - 获取实体属性值
 *
 *   ```javascript
 *   const entity = this.repository.entityCollection.getEntityById("id");
 *   cosnt name = entity['name'];
 *   // 或者
 *   const entity: any = this.repository.entityCollection.getEntityById("id");
 *   cosnt name = entity.name;
 *   ```
 *
 * ## 后端交互
 *
 * ​	通过接口操作后端数据，会直接对数据产生影响。
 *
 * - 更新实体数据
 *
 *   ```javascript
 *   this.repository.updateById('id');
 *   ```
 *
 * - 删除实体
 *
 *   ```javascript
 *   this.repository.removeById("id");
 *   ```
 *
 * - 批量删除实体
 *
 *   ```javascript
 *   this.repository.removeByIds(ids:string[])
 *   ```
 *
 * - 删除下级表数据
 *
 *   ```javascript
 *   this.repository.removeByPath(['主表Id','子表名','子表Id'])
 *   ```
 *
 * - 新增主实体
 *
 *   ```javascript
 *   this.repository.append();
 *   ```
 *
 * - 新增子实体
 *
 *   ```javascript
 *   this.repository.appendByPath(['主表id','子表名']);
 *   ```
 *
 * - 加载实体数据
 *
 *   ```javascript
 *   this.repository.getById('id');
 *   ```
 *
 * - 获取主表数据
 *
 *   ```javascript
 *   this.repository.getEntities(filter: any[], sorts: any[], pageSize: number | null, pageIndex: number | null)
 *
 *   ```
 *
 *   > pageSize、pageIndex可以不传。
 *
 * - 获取主表数据（POST方法）
 *
 *   ```javascript
 *   this.repository.filter(filter: any[], sorts: any[], pageSize: number | null, pageIndex: number | null)
 *   ```
 *
 * - 提交指定实体变更到后端
 *
 *   ```javascript
 *   this.repository.updateChangesById("id");
 *   ```
 *
 * - 提交所有变更
 *
 *   ```javascript
 *   this.repository.updateAllChanges();
 *   ```
 *
 * - 应用变更（保存）
 *
 *   ```javascript
 *   this.repository.applyChanges();
 *   ```
 *
 * - 取消变更
 *
 *   ```javascript
 *   this.repository.cancelChanges();
 *   ```
 *
 * - 清除Repository所有变更
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   befRepository.entityManager.clearAllEntityChanges();
 *   ```
 *
 * - 批量新增子表数据
 *   ```javascript
 *   this.repository.batchAppendByPath(path: string, defaultValues: Array<any>);
 *   ```
 *
 *   > path `string`：/主表id/从表前端nodeCode，如果/1/orders
 *   >
 *   > defaultValues `Array<any>`：新增从表时的默认值，数组，元素为对象，key为字段名，value为默认值。
 *
 * - 批量删除子表数据
 *
 *   ```javascript
 *   this.repository.batchRemoveByPath(path: string, ids: string);
 *   ```
 *
 *   > path `string`： /主表id/从表前端nodeCode，如果/1/orders
 *   >
 *   > ids `string` ：要删除的子表数据id，格式为`id1,id2,id3`
 */
export declare abstract class Repository<T extends Entity> implements IDisposable, OnDestroy {
    /**
     * 名称
     */
    private innerName;
    /**
     * API地址
     */
    apiUri: string;
    /**
     * 实体类型
     */
    entityType: any;
    /**
     * 实体类型信息
     * @todo：实体层应该事先一个EntityTypeInfo，并继承DataTypeInfo。
     */
    entityTypeInfo: DataTypeInfo;
    /**
     * 实体集合
     */
    entityCollection: EntityCollection<T>;
    /**
     * 用户分页配置信息
     */
    paginationInfo: any;
    /**
     * 数据变更历史（仅针对主表增加、各种表删除）
     */
    dataChangeHistory: DataChangeHistory;
    /**
     * 排序条件管理器
     */
    sortConditionManager: SortConditionManager;
    /**
     * 过滤条件管理器
     */
    filterConditionManager: FilterConditionManager;
    /**
     * 实体主键
     */
    readonly primaryKey: string;
    readonly changes: Subject<Modification>;
    /**
     * 实体变更集合
     */
    readonly entityCollectionChange: Subject<Modification>;
    /**
     * 获取名称
     */
    /**
    * 设置名称
    */
    name: string;
    paginationManager: PaginationManager<T>;
    destroy$: Subject<any>;
    /**
     * 构造函数
     */
    constructor();
    dispose(options?: any): void;
    ngOnDestroy(): void;
    updateEntityType(entityType: any): void;
    /**
     * 读取元数据
     */
    private readMetadata;
    /**
     * 初始化分页配置
     * @param config - 用户分页配置
     */
    setPaginationConfig(config: any): void;
    /**
     * 重置状态
     */
    reset(): void;
    /**
     * 创建实体
     * @param data
     */
    buildEntity(data: any): T;
    /**
     * 批量创建实体
     * @param listData
     */
    buildEntities(listData: any[]): T[];
    /**
     * 获取实体列表
     * @param filters -    过滤条件
     * @param sorts -      排序条件
     * @param pagination - 分页信息
     */
    abstract getEntities(filter: any[], sorts: any[], pageSize: number | null, pageIndex: number | null): Observable<T[]>;
    /**
     * 获取实体列表
     * @param filter - 过滤条件
     * @param sorts - 排序条件
     * @param pageSize - 分页大小
     * @param pageIndex - 当前分页
     */
    abstract filter(filter?: any[], sorts?: any[], pageSize?: number | null, pageIndex?: number | null): Observable<T[]>;
    /**
     * 获取实体列表
     */
    abstract getList(): Observable<T[]>;
    /**
     * 根据id获取实体
     * @param id - 实体标识
     */
    abstract getById(id: string): Observable<T>;
    /**
     * 根据id获取实体
     * @param id - 主实体id
     */
    abstract getEntityById(id: string): Observable<T>;
    /**
     * 分页查询从表/从从表数据
     * @param path - 绑定路径
     * @param ids - 绑定路径对应的主键
     * @param filter - 过滤条件
     * @param sort - 排序
     */
    abstract queryChild(paths: string[], pageIndex: number, pageSize: number, filter?: string, sort?: string): Observable<T[]>;
    /**
     * 根据id更新实体
     * @param id - 实体id
     */
    abstract updateById(id: string): Observable<T>;
    /**
     * 更新实体数据(子表分页)
     * @param id - 实体主键
     */
    abstract updateEntityById(id: string): Observable<T>;
    /**
     * 创建新实体，将该实体加载到列表
     */
    abstract create(): Observable<any>;
    /**
     * 创建新实体，并追加到实体列表
     */
    abstract append(): Observable<any>;
    /**
     * 创建新的子实体，并追加到实体列表
     * @param path - 实体路径
     */
    abstract appendByPath(path: string): Observable<any>;
    /**
     * 再指定位置插入数据
     */
    abstract insert(position: 1 | -1, defaultValue?: any): Observable<any>;
    /**
     * 在指定实体路径插入实体
     * @param path - 实体路径
     */
    abstract insertByPath(path: string, position: 1 | -1): Observable<any>;
    /**
     * 根据id删除对应实体
     * @param id - 内码
     */
    abstract removeById(id: string, ifSave?: boolean): Observable<any>;
    /**
     * 根据ids批量删除实体
     * @param id - ids
     * @param ifSave - 是否保存
     * @deprecated 已废弃，该接口使用querystring传参，存在超长问题。请使用batchRemove接口替代。
     */
    abstract removeByIds(ids: string[], ifSave?: boolean): Observable<any>;
    /**
     * 根据ids批量删除实体
     * @param ids - ids
     * @param ifSave - 是否保存
     */
    abstract batchRemove(ids: string[], ifSave?: boolean): Observable<any>;
    /**
     * 根据id删除path对应的后代实体
     */
    abstract removeByPath(path: string, id: string): any;
    /**
     * 提交id对应的根实体变更
     */
    abstract updateChangesById(id: string): Observable<boolean>;
    /**
     * 提交path对应的实体变更
     */
    abstract updateChangesByPath(path: string, id: string): Observable<boolean>;
    /**
     * 更新所有变更
     */
    abstract updateAllChanges(): Observable<boolean>;
    /**
     * 应用服务器端变更
     */
    abstract applyChanges(): Observable<boolean>;
    /**
     * 保存id对应数据的变更
     */
    abstract applyChangesById(id: string): Observable<boolean>;
    /**
     * 取消变更集
     */
    abstract cancelChanges(options?: any): Observable<boolean>;
    /**
     * 批量删除子表
     */
    abstract batchRemoveByPath(path: string, ids: string): Observable<boolean>;
    /**
     * 批量新增从表/从从表数据
     * @param path - 实体绑定路径，like 1/childs or 1/childs/11/childchilds
     * @param defaultValues - 默认实体数据数组
     * @description 后端接口只支持批量新增子表，批量新增主表目前不支持
     */
    abstract batchAppendByPath(path: string, defaultValues: Array<any>): Observable<any>;
    /**
     * 批量新增主表数据
     * @param defaultValues - 默认实体数据数组
     */
    abstract batchAppend(defaultValues: Array<any>): Observable<any>;
    /**
     * 检查当前业务上下文内是否存在未保存的变更
     */
    abstract hasChanges(): Observable<any>;
}
