import { Subscription } from 'rxjs';
import { IDisposable } from '../core/index';
import { EventPipeType } from './event-pipe-type';
export declare class EventPipe implements IDisposable {
    name: string;
    tokenValue: string;
    emitter: string;
    private parentEventPipeList;
    private lastEventId;
    /**
     * 事件对象
     */
    private eventSubject;
    /**
     * 订阅对象Map
     * key=订阅所在的FrameComponent
     * value：订阅evetnSubject产生的Subscription对象（rxjs的）
     */
    private subscriptionMap;
    /**
     *
     */
    private onceSubscriptionMap;
    /**
     * EventPipe类型，编译类型表单检查是否在同一上下文中，解析类型表单不判断
     */
    eventPipeType: EventPipeType;
    readonly subscriptions: Map<object, Subscription>;
    constructor(name: string, tokenValue: string, emitter: string, parentEventPipeList: Array<EventPipe>);
    /**
     * 发送事件
     */
    post(args: any, sender?: any, eventType?: any, eventId?: number): void;
    /**
     * 订阅事件
     */
    subscribe(eventHandler: (value: any) => void, receiver: object): IDisposable;
    subscribeOnce(eventHandler: (value: any) => void, caller: object): IDisposable;
    unSubscribe(subscriber: object): void;
    unSubscribeForOnce(): void;
    matchEmitterToken(emitter: string, tokenValue: string): boolean;
    examByTargetToken(target: string, tokenValue: string): boolean;
    dispose(subscriber: object): void;
    /**
     * 根据caller进行注销
     */
    disposeByCaller(caller: any): void;
    /**
     * 检查是否在同一个上下文中
     * @todo
     * 1、强识别了sender和receiver的结构来判断，不合理；
     * 2、应该声明一个接口来约束结构。
     */
    private isInSampeScope;
}
