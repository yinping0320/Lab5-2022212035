/**
 * 绑定数据相关定义
 * @author Witt<jiwt@inspur.com>
 * @todo
 * 1、全局的BindingData和局部的BindingData应该拆成两个类，两个类之间是装饰关系；；
 * 2、为了保持兼容，减少改动量，暂时放在一起，待进一步重构。
 */
import { OnDestroy } from '@angular/core';
import { Subject } from 'rxjs';
import { DataTypeInfo } from '../core/data-type-info';
import { Repository } from '../repository/index';
import { Change } from './changes';
import { BindingProperty } from './binding_property';
import { BindingList } from './binding_list';
import { InvokeOnValueChange } from './types';
import { IDisposable } from '../core';
/**
 * 绑定数据
 * @description
 * # BindingData
 *
 * BindingData用于直接和界面绑定，它持有一个不可变的数据集合（BindingList），数据集合中是一个个不可变的数据对象（BindingObject）。
 *
 * ## 更新界面数据
 *
 * ### 接口定义
 *
 * ```javascript
 * //根据paths设置属性值
 * //@param paths 属性路径数组
 * //@param value 属性值
 * //@param emitEventToView 如果设置为true，则发送事件通知订阅它的组件、指令去更新界面，默认为false。
 * //@param emitEventToEntity 如果设置为true，则同步去更新Entity上对应的字段，默认为true。
 * public setValue(paths: string[], value: any, emitEventToView: boolean = false, emitEventToEntity: boolean = true)
 * ```
 *
 * ### 示例
 *
 * - 更新主表数据
 *
 *   ```javascript
 *   bindingData.setValue(['name'],'ESG');
 *   ```
 *
 * - 更新子表数据
 *
 *   ```javascript
 *   bindingData.setValue(['soItems','price'],20);
 *   ```
 *
 * - 更新业务字段数据
 *
 *   ```javascript
 *   bindingData.setValue(['udt','udt_field'],'value');
 *   ```
 *
 * - 仅更新界面数据（不提交变更集）
 *
 *   ```javascript
 *   bindingData.setValue(['name'],'ESG',true,false);
 *   ```
 *
 *   > 注意：
 *   >
 *   > 仅更新界面数据时bindingData必须是对应组件上下文的bindingData。
 *   >
 *   > 更新数据的命令挂载到不同的组件，产生的效果也不相同。如果命令挂到了卡片视图模型，那么可以直接在构件中注入`FrameContext`或`BindingData`并更新数据就可以。但如果命令挂到了非卡片视图 * 模型，则应该先获取到卡片上下文的bindingData。
 *   >
 *   > - 命令挂在卡片视图模型:
 *   >
 *   >   ```javascript
 *   >   const frameContext = this.frameContext.bindingData;
 *   >   frameContext.bindingData.setValue(['name'],'ESG');
 *   >   ```
 *   >
 *   > - 命令挂在非卡片视图模型：
 *   >
 *   >   ```javascript
 *   >   const cardFrameContext = this.frameContext.appContext.frameContextManager.getFrameContextById('card-frameId');
 *   >   cardFrameContext.bindingData.setValue(['name'],'ESG');
 *   >   ```
 *
 * ## 获取界面数据
 *
 * ### 接口定义
 *
 *   ```javascript
 *   //获取paths对应的属性值
 *   //@param  paths 属性路径数组
 *   //@returns 属性值
 *   public getValue(paths: string[], useInitValue = false)
 *   ```
 *
 * ### 示例
 *
 * - 获取主表数据
 *
 *   ```javascript
 *   bindingData.getValue(['name']) //'ESG'
 *   ```
 *
 * - 获取从表中字段属性
 *
 *   ```javascript
 *   bindingData.getValue(['soItems','price']); // 20
 *   ```
 *
 * - 获取业务字段数据
 *
 *   ```javascript
 *   bindingData.getValue(['udt','udt_field']); // 'value'
 *   ```
 *
 * ## 获取指定BindingObject
 *
 * ### 接口定义
 *
 * ```javascript
 * //通过主键获取对应的bindingObject
 * bindingData.list.findById(id: string): BindingObject;
 * ```
 *
 * ### 示例
 * - 获取某个主实体
 *   ```javascript
 *   bindingData.list.findById("id");
 *   ```
 * - 获取某个实体下子表的所有数据
 *   ```javascript
 *   // 获取主实体
 *   const bindingObject = bindingData.list.findById("id") as BindingObject;
 *   // 获取该实体下的某个子表数据
 *   const bindingList = bindingObject.getValue("soItems") as BindingList;
 *   ```
 *
 * - 获取子表某一行数据
 *
 *   ```javascript
 *   //获取主实体
 *   const bindingObject = bindingData.list.findById("id") as BindingObject;
 *   //获取该实体下的某个子表数据
 *   const bindingList = bindingObject.getValue("soItems") as BindingList;
 *   //子表行数据
 *   const childrenBindingObject = bindingList.findById('子表数据id');
 *   const name = childrenBindingObject.getValue("name"); // 或者childrenBindingObject['name']
 *   ```
 *
 * ## 常见问题
 *
 * ### 赋值或取值时为何不用指定主键？
 *
 *    示例中取值或赋值时并没有指定主键值，这是由于BindingData赋值或取值时都是对当前行就行操作的，所以不需要指定主键。所以在计算&行切换场景下会导致取值或赋值错误，如本来想给第一行的某个字 * 段赋值，结果由于行切换导致把值赋给了其他行。
 *
 *    如果遇到赋值错误的情况可以通过BindingObject赋值或取值。
 *
 * ### 通过bindingData赋值了，界面也刷新了，但保存不上
 *
 *    这种情况多发生在有后端请求的情况下，比如通过bindingData赋值后紧接着有一个后端请求。由于bindingData赋值是异步的（目前是），这就可能导致赋值还没有结束（还没有产生变更）请求就发送 * 了，从而请求中没有对应的变更，请求回来后会默认清空本地变更，从而导致界面上显示数据已经修改，但数据库中数据并未修改。
 *
 *    解决该类问题可以通过实体赋值的方式，给实体赋值是同步的，赋值完成后变更就会产生，这样再发送请求时就可以把变更带到后端。
 */
declare class BindingData implements IDisposable, OnDestroy {
    /**
     * 数据类型描述
     */
    private dataTypeInfo;
    /**
     * 绑定该路径
     */
    bindingPath: string;
    /**
     * 可绑定的属性描述
     */
    properties: BindingProperty[];
    /**
     * 行切换事件暂停抛出
     */
    rowSelectedEventSuspend: boolean;
    /**
     * 数据列表
     */
    list: BindingList;
    private paginationInfo;
    pagingInfo: any;
    dispose(options?: any): void;
    ngOnDestroy(): void;
    /**
     * 设置分页信息
     * @param skip 跳过
     * @param take 获取
     * @param bindingPath 路径
     */
    setPagingInfo(skip: number, take: number, bindingPath: string): void;
    updatePagingInfo(pageInfo: {
        pageIndex?: number;
        pageSize?: number;
        total?: number;
    }, bindingPath: string): void;
    private firePagingChangeEvent;
    /**
     * 变更集
     */
    readonly changes: Subject<Change>;
    /**
     * 值变化执行器工厂，根据路径产生执行器
     */
    private valueChangeInvokerFactory;
    /**
     * 设置值变化执行器工厂
     * @param value 值变化执行器工厂
     */
    setValueChangeInvokerFactory(value: (paths: string[]) => InvokeOnValueChange): void;
    getValudChangeInvokerFactory(): (paths: string[]) => InvokeOnValueChange;
    /**
     * 初始化（已废弃）
     */
    init(repository: Repository<any>, bindingPath: string): void;
    /**
     * 根据Repository对BindingData进行初始化
     */
    initByRepository(repository: Repository<any>, bindingPath: string): void;
    /**
     * 初始化
     */
    initByBindingList(bindingList: BindingList, bindingPath: string): void;
    setDataTypeInfo(dataTypeInfo: DataTypeInfo): void;
    /**
     * 获取界面数据
     * @param paths 属性路径数组
     * @param useInitValue 是否使用默认值，默认为`false`
     * @returns 属性值
     */
    getValue(paths: string[], useInitValue?: boolean): any;
    /**
     * 该方法可以更新绑定层数据，从而达到更新界面数据的目的，进而更新本地仓库实体数据，产生变更，下次请求时会将变更带到后端并更新后端数据。
     * @param paths 属性路径数组
     * @param value 属性值
     * @param emitEventToView 如果设置为true，则发送事件通知订阅它的组件、指令去更新界面，默认为false。
     * @param emitEventToEntity 如果设置为true，则同步去更新Entity上对应的字段，默认为true。
     * @description
     * ## 示例
     *
     * ### 更新界面数据
     * 使用该方法时只传递path和value参数，其余参数使用默认值。该用法会更新界面数据，同时更新实体数据，实体数据更新时会产生变更，这样在下次请求时会将该变更带到后端，
     * 进而更新后端数据。
     * ```typescript
     * this.frameContext.bindingData.setValue(paths,value);
     * ```
     *
     * ### 仅更新界面数据
     * 有些场景下我们希望只更新界面的数据，不希望对后端数据产生影响，此时除传递paths和value参数外，还需要将emitEventToView设为true，emitEventToEntity设为false，
     * 此时必须使用对应BindingData的setValue方法：
     * ```typescript
     * const tableFrameContext = this.frameContext.appContext.frameContextManager.getFrameContextById('data-grid-component');
     * tableFrameContext.bindingData.setValue(paths,value,true,false);
     * ```
     * ## 注意事项
     * setValue为异步方法，如果调用该方法后随即发送后端请求，此时实体变更尚未产生，但请求已经发送，变更无法带到后端，导致变更丢失，出现界面上显示数据已经修改，
     * 但后端并未修改的问题。
     * 因此，如果赋值后随即发送请求应该使用实体赋值的方法。
     */
    setValue(paths: string[], value: any, emitEventToView?: boolean, emitEventToEntity?: boolean, errors?: any, context?: any): void;
    /**
     * 根据paths清空属性值
     */
    clearValue(paths: string[], emitEventToView?: boolean, emitEventToEntity?: boolean, context?: any): void;
    /**
     * 获取当前列表
     */
    getList(): any;
    /**
     * 获取当前对象
     */
    getObject(): any;
    /**
     * 绑定路径（仅路径部分，不包括属性）
     * @param bindingPath 绑定路径
     */
    getPath(bindingPath?: string[]): string[];
    /**
     * 清空绑定数据
     */
    reset(): void;
    /**
     * 通过绑定路径获取属性初始值
     * @param paths 绑定路径
     */
    private getInitValueByPaths;
    /**
     * 扩展BindingData属性，映射BindingData所持有的绑定列表当前行的属性，减少绑定层级。
     * @param properties 关联实体的属性集合
     */
    private extendProperties;
}
export { BindingData };
