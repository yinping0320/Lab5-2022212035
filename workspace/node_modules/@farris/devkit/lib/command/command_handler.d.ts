import { InjectionToken, OnDestroy } from '@angular/core';
import { Observable } from 'rxjs';
import { FrameContext } from '../frame/index';
import { VariableParseService } from '../variable/index';
import { Command } from './command';
import { CommandContext } from './command_context';
import { TaskFunc } from './flow/index';
import { IDisposable } from '../core';
/**
 * 命令处理抽象类，所有具体的命令处理类必须继承它，并实现schedule方法。
 */
declare abstract class CommandHandler implements IDisposable, OnDestroy {
    /**
     * 任务流程图
     */
    private taskFlow;
    /**
     * 上下文
     */
    protected frameContext: FrameContext;
    /**
     * 变量解析服务
     */
    protected parseService: VariableParseService;
    commandName: string;
    private destroy$;
    /**
     * 构造函数
     */
    constructor();
    dispose(options?: any): void;
    ngOnDestroy(): void;
    /**
     * 构造执行流程
     */
    abstract schedule(): any;
    /**
     * 初始化
     */
    init(frameContext: FrameContext, variableParseService: VariableParseService): void;
    /**
     * 执行任务
     * @param command 要执行的命令
     * @return 最后一个任务的执行结果
     * @todo：按功能拆分小函数
     */
    execute(command: Command): Observable<any>;
    /**
     * 等待销毁
     * @param commandContext
     */
    private waitForDestroy;
    /**
     * 显示错误信息
     */
    private displayError;
    /**
     * 参数国际化转换方法
     */
    private paramsTransform;
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    protected addTask(name: string, func: TaskFunc): void;
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    protected addLink(from: string, to: string, condition: string | boolean): void;
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    insertTask(target: string, name: string, func: TaskFunc): void;
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    afterTask(target: string, name: string, func: TaskFunc): void;
    /**
     * 替换任务
     * @param  name 要替换的任务名称
     * @param  func 替换函数
     */
    replaceTask(name: string, func: TaskFunc): void;
    /**
     * 调用方法
     */
    invoke(serviceInstance: any, method: string, args: any[], context: CommandContext): any;
    /**
     * 为服务设置命令上下文
     * @todo
     * 通过这种方式存在很大问题：
     * 1、会覆盖掉已有的context，给开发人员造成困扰和调试成本；
     * 2、服务中依赖了一个没有声明的对象，不符合面向对象的原则。
     * 建议解决方案：
     * 1、将context修改为某个特殊属性名；
     * 2、先检测服务上有没有一个CommandContext类型的context属性，有的话再赋值，
     *    这就要求需要使用context的服务需要是实现一个IContext接口。
     */
    protected setContextToServiceInstance(serviceInstance: any, context: CommandContext): void;
    /**
     * 根据参数描述信息转换参数类型
     */
    private transParamTypes;
}
/**
 * 命令处理器注入Token
 */
declare const COMMAND_HANDLERS_TOKEN: InjectionToken<CommandHandler>;
export { CommandHandler, COMMAND_HANDLERS_TOKEN };
