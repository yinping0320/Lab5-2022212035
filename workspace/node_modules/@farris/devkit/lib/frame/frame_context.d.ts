import { Injector, OnDestroy } from '@angular/core';
import { Entity } from '../entity/index';
import { Repository } from '../repository/index';
import { BindingData } from '../binding-data/index';
import { UIState } from '../ui-state/index';
import { Form } from '../form/index';
import { StateMachine } from '../state-machine/index';
import { ViewModel } from '../view-model/index';
import { CommandBus } from '../command/index';
import { Context } from '../context/index';
import { AppContext } from '../app/index';
import { EventBus } from '../event-bus-new/index';
import { FrameComponent } from './frame_component';
import { IExceptionHandler } from '../exception/types';
import { VariableParseService } from '../variable/variable_parse_service';
import { IContextMetadata } from '../app/app_metadata';
import { Translate } from '../i18n';
import { ExpressionEngineImpl } from '../expression/expression_engine_impl';
import { ExpressionManager } from '../expression/expression_manager';
import { ExpressionResult } from '../expression/expression_result';
import { Subject } from 'rxjs';
import { IDisposable } from '../core/index';
import { ComponentRefManager } from './component_ref_manager';
/**
 * 组件上下文
 * @description
 * # 上下文
 * ## Overview
 *
 * 每个组件（FrameComponent）都有自己的上下文（FrameContext）,通过上下文可以获取控制器的所有属性，如常用的`frameId`、`BindingData`、`Repository`、`ViewModel`、`StateMachine`、 * `UIState`等。上下文在内存中呈树形结构，依附于FrameComponent。结构如下：
 *
 * ![image-20210806204755378](https://open.inspuronline.com/iGIX/assets/cloudplus/igix_2110/farris/devkit/guide/images/image-20210806204755378.png)
 *
 * 从上图我们可以看出每个上下文都有自己的`ViewModel`、`UIState`，那么如何确定一个命令在执行时用的是哪个上下文呢？其实无论命令在哪个地方被调用，上下文都是命令所在的组件的上下文。即，如果 * 命令挂载到了`detail-form-component`的视图模型，但命令最终被`root-component`上的按钮调用了，其上下文仍然是`detail-from-component`组件的上下文。之所以出现这种现象和Angular的依赖注 * 入密不可分，由于Angular在查找`provider`的时候总是从自己的组件开始向上找，如果在组件内部找到了则不再继续查找，如果找不到则会继续向上，如果查找到最上级依然找不到就会报`No provider  * for xx`错误。
 *
 * 既然如此，如果我们在`detail-form-component`中想要获取`root-component`中定义的变量（UIState）该如何做呢？答案是切换上下文，可以通过以下方式实现：
 *
 * ```typescript
 * // 方法1
 * const rootFrameContext = this.frameContext.root;
 * // 方法2
 * const rootFrameContext = this.frameContext.appContext.frameContextManager.getFrameContextById('root-component');
 * ```
 *
 * 通常在编写`Web构件`时先引入FrameContext，如：
 *
 * ```javascript
 * import {FrameContext,BindingData,Repository} from '@farris/devkit';
 *
 * constructor(private frameContext:FrameContext){}
 *
 * public method(){
 *     const bindingData: BindingData = this.frameContext.bindingData;
 *     const repository: Repository = this.frameContext.repository;
 * }
 * ```
 *
 * > `FrameContext`称为`ViewModelContext`更合适，可以理解为`MVVM`架构中`VM`的上下文。
 *
 * 控制器中亦存在`ViewModel`的概念。和`MVVM`架构中的的VM一致，所以也可以从`VM`访问常用的属性。如：
 *
 * ```typescript
 * import {BindingData,Repository,ViewModel} from '@farris/devkit';
 *
 * constructor(private viewModel:ViewModel){}
 *
 * public method(){
 *     const bindingData: BindingData = this.viewModel.bindingData;
 *     const repository: Repository = this.viewModel.repository;
 * }
 * ```
 *
 *
 *
 * ## 常用操作
 *
 * ### 获取当前上下文所属的组件
 *
 * ```typescript
 * this.frameContext.frameComponent;
 * ```
 *
 * ### 获取当前上下文的根上下文
 *
 * ```typescript
 * this.frameContext.root;
 * ```
 *
 * ### 获取当前上下文的appContext
 *
 * ```typescript
 * this.frameContext.appContext;
 * ```
 *
 * ### 获取指定frameId的上下文
 *
 * ```typescript
 * this.frameContext.appContext.frameContextManager.getFrameContextById('data-grid-component');
 * ```
 *
 * ### 获取表单所有上下文
 *
 * ```typescript
 * this.frameContext.appContext.frameContextManager.getFrameContexts();
 * ```
 *
 *
 *
 * ## 常用属性
 *
 * ### BindingData
 *
 * [参考]([浪潮企业云开放平台 (inspuronline.com)](https://open.inspuronline.com/iGIX/#/document/mddoc/igix-2103%2Ffarris%2Fdevkit%2Fguide%2F绑定数据.md))
 *
 * ### Repository
 *
 * [参考]([浪潮企业云开放平台 (inspuronline.com)](https://open.inspuronline.com/iGIX/#/document/mddoc/igix-2103%2Ffarris%2Fdevkit%2Fguide%2F仓库.md))
 *
 * ### ViewModel
 *
 * 控制器中ViewMode同MVVM架构中的VM，和FrameContext类似，可以通过ViewModel拿到FrameContext，同样的也可以通过FrameContext拿到ViewModel。
 *
 * ### namespace
 *
 * 命名空间，主要在组合表单场景用到，每一个表单都有自己的命名空间，被组合进来的表单其命名空间是相同的，如A表单组合了B表单，则B表单具有相同的命名空间，命名空间主要用于表单隔离。
 *
 * ### root
 *
 * 获取整个表单的根上下文
 *
 * ### uiState
 *
 * 获取当前组件的变量
 *
 * ### frameId
 *
 * 上下文标识。
 */
export declare class FrameContext extends Context implements IDisposable, OnDestroy {
    injector: Injector;
    typeName: string;
    protected isDestoried: boolean;
    isDisposed: boolean;
    /**
     * id
     */
    frameId: string;
    /**
     * 注入器
     */
    /**
     * 应用上下文
     */
    appContext: AppContext;
    /**
     * 根组件上下文
     */
    root: FrameContext;
    /**
     * 父ViewModel
     */
    parent: FrameContext;
    /**
     * 后代节点
     */
    children: Map<string, FrameContext>;
    /**
     * 实体仓库
     */
    repository: Repository<Entity>;
    /**
     * 命令总线
     */
    commandBus: CommandBus;
    /**
     * 事件总线
     */
    eventBus: EventBus;
    /**
     * 视图模型
     */
    viewModel: ViewModel;
    /**
     * 数据绑定
     */
    bindingData: BindingData;
    /**
     * UI状态
     */
    uiState: UIState;
    /**
     * 状态机
     */
    stateMachine: StateMachine;
    /**
     * 表单
     */
    form: Form;
    /**
     * 所属组件
     */
    frameComponent: FrameComponent;
    /**
     * 异常处理
     */
    exceptionHandler: IExceptionHandler;
    /**
     * 表单命名空间
     */
    namespace: string;
    variableParseService: VariableParseService;
    metadata: IContextMetadata;
    /**
     * 暂停事件抛出
     */
    suspend: boolean;
    expressionEngineImpl: ExpressionEngineImpl;
    expressionManager: ExpressionManager;
    expressionResult: ExpressionResult;
    /**
     * 索引(从0开始)
     */
    index: number;
    /**
     * 多语
     */
    translate: Translate;
    /**
     * 上下文销毁流
     */
    destorySignal: Subject<any>;
    /**
     * 组件引用管理
     */
    componentRefManager: ComponentRefManager;
    /**
     * 启用后端变更检测
     */
    enableServerSideChangeDetection: boolean;
    /**
     * 构造函数
     * @param injector 注入器
     */
    constructor(injector: Injector, parent: FrameContext);
    dispose(options?: any): void;
    ngOnDestroy(): void;
    /**
     * 通过组件标识获取对应的组件实例
     * @param id 组件标识
     * @returns
     */
    getComponentById<T>(id: string): T;
    /**
     * 获取指定标识的所有组件
     * @param id 组件标识
     */
    getComponentsById<T>(id: string): T[];
    bindInjector(componentInjector: Injector): void;
    /**
     * 初始化
     * @todo:
     * 1、CommandHandler中的服务可能会注入Context，所以CommandHandler创建时必须已经存在ComponentContext
     * 2、ViewModel的buildCommands中会使用CommandBus，为了保证顺序，将ViewModel的创建也放在init中。
     */
    init(frameComponent: FrameComponent): void;
    initExpression(): void;
    /**
     * 订阅异常消息
     */
    protected registerExceptionHandler(): void;
    protected registerAppContextDestroyEvent(): void;
    /**
     * 获取表单appcontext，即最上层appcontext
     */
    getFormAppContext(): AppContext;
    /**
     * 获取frameId
     * @description 获取完整的FrameId，在非普通表单中该值等于frameId，在组合表单中该值为namespace_frameId
     */
    getFrameId(relativeFrameId: string): string;
    /**
     * 初始化Repository
     */
    private initializeRepository;
    private initializeForm;
    private initializeStateMachine;
    private initializeCommandBus;
    /**
     * 初始化ViewModel
     * @todo
     * 1、需要按照一定的顺序进行初始化，否则依赖无法正确处理；
     * 2、暂时使用init解决Context和其他部分的循环依赖问题，待优化；
     */
    private initializeViewModel;
    /**
     * 初始化BindingData
     * @summary
     * 老表单：repositoryName为空，复制当前Repository里的数据；
     * 新表单：repositoryName有值，引用全局BindingData里的数据；
     */
    private initializeBindingData;
    /**
     * 初始化UIState
     * 合并路由参数到UIState中
     */
    private initializeUiState;
    /**
     * 注册子ViewModel
     * @todo
     * 1、propName写死了
     */
    regViewModel(viewModel: ViewModel): void;
    /**
     * 检查是否为根FrameContext
     * @summary
     * 检查该FrameContext是不是所在AppContext中的根FrameContext
     */
    isRootFrameContext(): boolean;
    /**
     * 通过namespace获取当前表单的root-framecontext(非整个表单)
     * @description
     * 如果为组合表单，其当前表单的root-framecontext为单个表单的framecontext，而非整个表单的framecontext
     */
    getVirtualRootFrameContext(): FrameContext;
    getContextById(identify: string): any;
    getViewModel(viewModelName: string): ViewModel;
    attachViewComponent(viewComponent: FrameComponent): void;
    invoke(actionPath: string, $event: any): any;
}
