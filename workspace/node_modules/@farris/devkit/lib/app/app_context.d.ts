/**
 * 应用上下文
 * @author Witt<jiwt@inspur.com>
 * @todo
 * 1、parnet和AppContextManager是否必要？按理说就是应该隔离上下文，表单之间通过事件通讯进行交互；
 */
import { Injector, OnDestroy } from '@angular/core';
import { Router } from '@angular/router';
import { Context } from '../context/index';
import { Change } from '../binding-data';
import { FrameContextManager } from './frame_contex_manager';
import { FrameComponentRefresher } from './frame_component_refresher';
import { RepositoryManager } from './repository_mananger';
import { BindingDataManager } from './binding_data_manager';
import { ChangeDetectionController } from './change_detection_controller';
import { AppContextManager } from './app_context_manager';
import { Subject } from 'rxjs';
import { ComponentManager } from './component_manager';
import { ContextMetadataBuilder } from './app_metadata_collector';
import { FormModule, IStateMachine } from '../schema/form-metadata';
import { CommandController } from '../command';
import { StateMachine } from '../state-machine';
import { IContextMetadata } from './app_metadata';
import { VariableParseService } from '../variable';
import { ViewModelManager } from './view_model_manager';
import { Repository } from '../repository';
import { Entity } from '../entity';
import { UIState } from '../ui-state';
import { ContextMetadataManager } from './render_context_metadata_manager';
import { FrameContext } from '../frame/frame_context';
import { EventBus } from '../event-bus-new';
import { IDisposeOptions, RunMode } from '../core';
import { IDisposable } from '../core';
declare class AppContext extends Context implements OnDestroy, IDisposable {
    typeName: string;
    /**
     * 注入器
     */
    injector: Injector;
    /**
     * 根应用上下文
     */
    root: AppContext;
    /**
     * 上级应用上下文
     */
    parent: AppContext;
    /**
     * 应用上下文管理器
     */
    appContextManager: AppContextManager;
    /**
     * FrameContext管理器
     */
    frameContextManager: FrameContextManager;
    /**
     * FrameComponent刷新器
     */
    frameComponentRefresher: FrameComponentRefresher;
    /**
     * Repository管理器
     */
    repositoryManager: RepositoryManager;
    /**
     * 绑定数据管理器
     */
    bindingDataManager: BindingDataManager;
    /**
     * 视图模型管理器
     */
    viewModelManager: ViewModelManager;
    contextMetadataManager: ContextMetadataManager;
    /**
     * 变更检测控制器
     */
    changeDetectionController: ChangeDetectionController;
    /**
     * 是否已经销毁
     */
    isFormDestoryed: boolean;
    /**
     * 应用程序标识
     */
    applicationId: string;
    private token;
    /**
     * 是否使用独立的eventBus
     * @memberof AppContext
     */
    useIsoluteEventBus: boolean;
    /**
     * 独立的eventBus实例
     *
     * @type {EventBus}
     * @memberof AppContext
     */
    isoluteEventBus: EventBus;
    /**
     * 已废弃：请使用FrameContextManager的getFrameContextMap方法代替。
     * @deprecated
     * @summary
     * 已经有运行时直接用中括号访问该属性的场景，虽然是private，但要进行兼容。
     */
    private readonly frameContexts;
    /**
     * 消息管道
     */
    messagePipe: Subject<any>;
    /**
     * 表单Id
     */
    formId: string;
    /**
     * 组件实例数组
     */
    componentRefs: Map<string, Map<string, any>>;
    /**
     * 视图组件管理器
     */
    componentManager: ComponentManager;
    /**
     * 记录confirm弹窗是否打开
     */
    opened: boolean;
    /**
     * 排序条件管理器
     */
    /**
     * 过滤条件管理器
     */
    protected contextMetadataBuilder: ContextMetadataBuilder;
    /**
     * 应用上下文元数据描述
     */
    metadata: IContextMetadata;
    /**
     * 应用程序上下文全局状态
     */
    uiState: UIState;
    /**
     * 实体仓库
     */
    repository: Repository<Entity>;
    /**
     * 状态机
     */
    stateMachine: StateMachine;
    variableParseService: VariableParseService;
    namespace: string;
    router: Router;
    formMetadataContent: any;
    /**
     * 控制器运行模式，支持compatible | highSpeed
     */
    runMode: RunMode;
    /**
     * 编辑态时启用表格头
     */
    enableGridHeaderWhenEditing: boolean;
    /**
     * tabId
     */
    tabId: string;
    readonly formModule: FormModule;
    controllers: {
        [id: string]: CommandController;
    };
    /**
     * 应用上下文销毁信号
     */
    destorySignal: Subject<IDisposeOptions | any>;
    disposed: boolean;
    private dynamicOptions;
    /**
     * 构造函数
     */
    constructor(injector: Injector, appContextManager: AppContextManager, parent: AppContext);
    dispose(options?: IDisposeOptions): void;
    ngOnDestroy(): void;
    /**
     * 由表单元数据、状态机元数据、前端构件元数据初始化解析型应用上下文
     * @param formMetadataContent 表单元数据
     * @param stateMachineMetadata 状态机元数据
     * @param controllers 前端构件元数据
     */
    initializeByMetadata(formMetadataContent: any, stateMachineMetadata: IStateMachine, controllers: {
        [id: string]: CommandController;
    }, options: {
        valueConverterMap?: any;
    }): void;
    /**
     * Register current AppContext instance to AppContextManager
     */
    registerToManager(): void;
    /**
     * Unregister current AppContext instance from AppContextManager
     */
    unregisterFromManager(): void;
    /**
     * 注册FrameContext
     */
    regFrameContext(frameContext: any): void;
    regContextMetadata(componentId: string, contextMetadata: IContextMetadata): void;
    /**
     * 获取整个表单的AppContext
     */
    getFormAppContext(): this;
    /**
     * 销毁表单
     * @todo: 临时解决表单关闭后对象没有销毁亦获取不到销毁时机的问题,应依赖angular本身的销毁机制
     */
    destory(): void;
    readonly isDestoryed: boolean;
    /**
     * 应用id
     */
    ApplicationId: string;
    Token: string;
    /**
     * 已废弃：请使用FrameComponentRefresher的refreshComponent方法代替。
     * @deprecated
     */
    registerCommandHandler(frameId: string, component: any): void;
    /**
     * 已废弃：请使用FrameComponentRefresher的refreshComponent方法代替。
     * @deprecated
     */
    refresh(): void;
    /**
     * 已废弃：请使用FrameContextManager的getFrameContextById方法代替。
     * @deprecated
     */
    getFrameContext(frameId: string): any;
    getContextById(identify: string): any;
    /**
     * 已废弃：请使用FrameContextManager的getFrameContextMap方法代替。
     * @deprecated
     */
    getAllFrameContexts(): Map<string, FrameContext>;
    /**
     * 处理行变更
     */
    handleSelectChange(change: Change, srcFrameContext: any): void;
    buildRenderViewContext(componentId: string): void;
    private buildRenderViewContextRecursively;
    getComponentProviders(componentId: string): any[];
}
export { AppContext };
