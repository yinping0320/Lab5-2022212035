import { isEqual } from 'lodash-es';
import moment from 'moment';
import { List, Map as Map$1 } from 'immutable';
import { FormControl, FormGroup } from '@angular/forms';
import ValidatorJS__default from 'validator';
import { format, isDate, parseISO, isEqual as isEqual$1, compareAsc } from 'date-fns';
import { HttpClient, HttpParams } from '@angular/common/http';
import { BasePathService } from '@farris/rtf';
import { Router } from '@angular/router';
import { Expression, ExpressionContext, ExpressionEngine } from '@farris/expression-engine';
import { BigNumber } from 'bignumber.js';
import { filter, takeUntil, tap, concatMap, map, takeLast, take, throwIfEmpty, every, catchError, switchMap } from 'rxjs/operators';
import { Subject, from, of, Observable, BehaviorSubject, EMPTY, isObservable } from 'rxjs';
import { InjectionToken, Injectable, Inject, Injector, Optional, SkipSelf, Type, InjectFlags, ChangeDetectorRef, ReflectiveInjector, NgModule } from '@angular/core';

const ANNOTATIONS = '__annotations__';
const PARAMETERS = '__parameters__';
const PROP_METADATA = '__prop__metadata__';
/**
 * @suppress {globalThis}
 */
function makeDecorator(name, props, parentClass, chainFn, typeFn) {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
        if (this instanceof DecoratorFactory) {
            metaCtor.call(this, ...args);
            return this;
        }
        const annotationInstance = new DecoratorFactory(...args);
        const typeDecorator = function createTypeDecorator(cls) {
            typeFn && typeFn(cls, ...args);
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const annotations = cls.hasOwnProperty(ANNOTATIONS) ?
                cls[ANNOTATIONS] :
                Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
            annotations.push(annotationInstance);
            return cls;
        };
        if (chainFn) {
            chainFn(typeDecorator);
        }
        return typeDecorator;
    }
    if (parentClass) {
        DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
}
function makeMetadataCtor(props) {
    return function ctor(...args) {
        if (props) {
            const values = props(...args);
            // tslint:disable-next-line:forin
            for (const propName in values) {
                this[propName] = values[propName];
            }
        }
    };
}
function makeParamDecorator(name, props, parentClass) {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
        if (this instanceof ParamDecoratorFactory) {
            metaCtor.apply(this, args);
            return this;
        }
        const annotationInstance = new ParamDecoratorFactory(...args);
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
        function ParamDecorator(cls, unusedKey, index) {
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const parameters = cls.hasOwnProperty(PARAMETERS) ?
                cls[PARAMETERS] :
                Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
            // there might be gaps if some in between parameters do not have annotations.
            // we pad with nulls.
            while (parameters.length <= index) {
                parameters.push(null);
            }
            (parameters[index] = parameters[index] || []).push(annotationInstance);
            return cls;
        }
    }
    if (parentClass) {
        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
}
function makePropDecorator(name, props, parentClass) {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
        if (this instanceof PropDecoratorFactory) {
            metaCtor.apply(this, args);
            return this;
        }
        const decoratorInstance = new PropDecoratorFactory(...args);
        // tslint:disable-next-line:no-shadowed-variable
        return function PropDecorator(target, name) {
            const constructor = target.constructor;
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const meta = constructor.hasOwnProperty(PROP_METADATA) ?
                constructor[PROP_METADATA] :
                Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
            meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
            meta[name].unshift(decoratorInstance);
        };
    }
    if (parentClass) {
        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
}

//import { Cacheable, DefaultCacheProvider } from '../../cache';
/**
 * 元数据解析
 * 约束：
 * 1、类型装饰器：在某个类型上，某种类型的装饰器，只使用一次，不重复添加；
 * 2、属性装饰器：在某个属性上，某种类型的装饰器，只使用一次，不重复添加
 */
class MetadataUtil {
    // ----------------------------------------
    // 类型元数据
    // ----------------------------------------
    /**
     * 获取类元数据
     * 返回结果形如：
     * [
     *   Injectable
     *   NgViewModel
     *   NgViewModel
     * ]
     */
    static getClassMetadatas(constructor) {
        const metadatas = constructor[ANNOTATIONS];
        return metadatas;
    }
    /**
     * 获取某个class上的某种装饰器
     * 返回结果：NgViewModel
     */
    static getClassMetadataByName(constructor, metadataName) {
        const metadata = this.getClassMetadataByNameWithTranslate(constructor, metadataName, null, null);
        return metadata;
    }
    static getClassMetadataByNameWithTranslate(constructor, metadataName, translateService, keysToTranslate) {
        const allClassMetadatas = this.getClassMetadatas(constructor);
        if (!allClassMetadatas) {
            return null;
        }
        const metadata = allClassMetadatas.find((classMetadata) => {
            return classMetadata.ngMetadataName === metadataName;
        });
        this.translateMetadataByName(metadata, translateService, keysToTranslate);
        return metadata;
    }
    // ----------------------------------------
    // 属性元数据
    // ----------------------------------------
    /**
     * 获取所有属性的所有元数据
     * 返回格式：
     * {
     *   propName1: [ NgDefaultValue, NgMaxLength, NgMinLength],
     *   propName2: [ NgDefaultValue, NgMaxLength, NgMinLength]
     * }
     */
    // @Cacheable({ key: ((context: any, args: any[]) => args[0]), provider: new DefaultCacheProvider() })
    static getPropsMetadatas(constructor) {
        const allPropMetadatas = constructor[PROP_METADATA];
        return allPropMetadatas;
    }
    /**
     * 获取所有属性的某一类型的元数据
     * 如果同一属性
     * 返回结果：
     * {
     *    propName1: NgDefaultValue,
     *    propName2: NgDefaultValue
     * }
     */
    // @Cache({ provider: new MemoryCacheProvider(new MetadataKeyCompare()), key: ((context: any, args: any[]) => { return { constructor: args[0], metadataName: args[1] } }) })
    static getPropsMetadatasByName(constructor, metadataName) {
        const metadatas = this.getPropsMetadatasByNameWithTranslate(constructor, metadataName);
        return metadatas;
    }
    static getPropsMetadatasByNameWithTranslate(constructor, metadataName, translateService, keysToTranslate) {
        const metadatas = {};
        // 读取构造函数中存储的类属性注解。
        const allPropMetadatas = this.getPropsMetadatas(constructor);
        if (!allPropMetadatas) {
            return metadatas;
        }
        // 遍历所有属性提取注解信息。
        Object.keys(allPropMetadatas).forEach((propName) => {
            // 提取当前属性注解对象
            const propMetadatas = allPropMetadatas[propName];
            // 提取指定类型的注解项
            const metadata = propMetadatas.find((propMetadata) => {
                return propMetadata.ngMetadataName === metadataName;
            });
            if (metadata) {
                metadatas[propName] = metadata;
            }
        });
        // 翻译指定属性的值
        this.translateMetadatasByName(metadatas, translateService, keysToTranslate);
        return metadatas;
    }
    static translateMetadatasByName(metadatas, translateService, keysToTranslate) {
        Object.keys(metadatas).forEach((propName) => {
            // 提取指定类型的注解项
            this.translateMetadataByName(metadatas[propName], translateService, keysToTranslate);
        });
        return metadatas;
    }
    static translateMetadataByName(metadata, translateService, keysToTranslate) {
        if (metadata && translateService && keysToTranslate) {
            keysToTranslate.forEach((metadataPropKey) => {
                const propertyVariable = metadata[metadataPropKey];
                try {
                    if (propertyVariable && propertyVariable.startsWith('{{') && propertyVariable.endsWith('}}')) {
                        const translateKey = propertyVariable.replace('{{', '').replace('}}', '').trim();
                        metadata[metadataPropKey] = translateService.transform(translateKey, null);
                    }
                }
                catch (e) {
                    console.info(e);
                }
            });
        }
        return metadata;
    }
    /**
     * 获取某个属性的所有元数据
     * 返回格式：[ NgDefaultValue, NgMaxLength, NgMinLength]
     */
    static getPropMetadatasByName(constructor, propName) {
        // 暂不实现
        return null;
    }
    /**
     * 获取某个属性的某种元数据
     * 返回格式：NgDefaultValue
     */
    static getPropMetadataByName(constructor, propName, metadataName) {
        // 暂不实现
        return null;
    }
}

/**
 * 变更记录
 */
class Modification {
    /**
     * 构造函数
     * @param value 新值
     * @param modifyType 变更类型
     * @param path 变更路径
     * @param preValue 旧值
     */
    constructor(value, modifyType, path, preValue, position) {
        this.type = modifyType;
        this.value = value;
        this.preValue = preValue;
        this.path = path;
        this.position = position;
    }
}
/**
 * 变更类型
 */
var ModifyType;
(function (ModifyType) {
    /**
     * 添加
     */
    ModifyType["Add"] = "ADD";
    /**
     * 添加数据
     */
    ModifyType["AddData"] = "AddData";
    /**
     * 克隆数据
     */
    ModifyType["Clone"] = "CLONE";
    /**
     * 删除
     */
    ModifyType["Remove"] = "REMOVE";
    ModifyType["RemoveData"] = "RemoveData";
    /**
     * 修改
     */
    ModifyType["ValueChange"] = "VALUE_CHANGE";
    /**
     * 加载
     */
    ModifyType["Load"] = "LOAD";
    /**
     * 未改变
     */
    ModifyType["UnChanged"] = "UNCHANGED";
    /**
     * 分页信息变更
     */
    ModifyType["PaginationInfoChange"] = "PAGINATION_INFO_CHANGE";
    /**
     * 插入
     */
    ModifyType["Insert"] = "Insert";
    /**
     * 更新实体
     */
    ModifyType["Update"] = "UPDATE";
})(ModifyType || (ModifyType = {}));

/*
 * @Author: Lucus, Witt
 * @Date: 2018-10-30 15:53:59
 * @Last Modified by: Witt
 * @Last Modified time: 2018-11-08 17:25:08
 */
// function isEqual(value: any, other: any) {
//   return JSON.stringify(value) === JSON.stringify(other);
// }
/**
 * 实体数据变更集
 */
class ChangeSet {
    constructor() {
        /**
         * 变更集合
         */
        this.modifications = [];
    }
    /**
     *  获取所有的变更记录
     */
    get changes() {
        return this.modifications;
    }
    /**
     * 将变更集添加到集合中
     * ### 使用示例
     * ```
     * const changeSet = new ChangeSet();
     * const modify = new Modification('newValue', ModifyType.ValueChange, [1, 'title'], 'oldValue');
     * changeSet.append(modify)
     * ```
     * @param changeItem 变更数据
     */
    append(modification) {
        switch (modification.type) {
            case ModifyType.ValueChange:
                this.appendValueChangeModification(modification);
                break;
            case ModifyType.Add:
            case ModifyType.Insert:
            case ModifyType.Clone:
                this.appendAddModification(modification);
                break;
            case ModifyType.Remove:
                this.appendRemoveModification(modification);
                break;
            case ModifyType.Load:
                break;
            default:
                break;
        }
    }
    /**
     * 添加值变化变更
     */
    appendValueChangeModification(modification) {
        const value = modification.value;
        const path = modification.path.join('/');
        const existedModification = this.findModifyItemsPath(modification.path);
        if (existedModification) {
            // 如果存在相同路径的ValueChange类型的变更集，则更新值；
            existedModification.value = value;
        }
        else {
            const existedAddModification = this.findNewAddItemsPath(modification.path);
            if (existedAddModification) {
                // @todo：
                // 1、此处逻辑有问题，value是个字符串，不能直接assign；
                // 2、之所以没有出现问题，是因为都是服务器端新增，新增后，客户端清空了所有变更。
                // 如果存在涵盖该ValueChange变更的Add变更，则更新Add变更对应的数据；
                existedAddModification.value = Object.assign({}, existedAddModification.value, value);
            }
            else {
                // 其他情况，新增一条ValueChange变更。
                this.modifications.push(modification);
            }
        }
    }
    /**
     * 添加新增变更
     */
    appendAddModification(modification) {
        const value = modification.value;
        const path = modification.path.join('/');
        const existedModification = this.findNewAddItemsPath(modification.path);
        if (existedModification) {
            // 1、如果已经存在相同路径的Add变更，则合并Value。
            existedModification.value = existedModification.value.concat(value);
        }
        else {
            // 2、如果没有，则新增一条Add变更。
            this.modifications.push(modification);
        }
    }
    /**
     * 添加删除变更
     */
    appendRemoveModification(modification) {
        const path = modification.path;
        const primaryKey = Object.keys(modification.value)[0];
        const primaryKeyValue = modification.value[primaryKey];
        // 1、存在相同path的新增变更，移除新增变更，不需要添加删除变更；
        // @todo：待重构（1、只考虑了主从情况，2、临时用多重循环实现）
        this.modifications.forEach((addModification) => {
            // 只处理新增变更
            if (addModification.type !== ModifyType.Add && addModification.type !== ModifyType.Insert && addModification.type !== ModifyType.Clone) {
                return;
            }
            // @todo 只考虑主从结构，再深的层次暂不考虑
            if (isEqual(addModification.path, path) === false) {
                return;
            }
            // 遍历新增新增变更的value（value是个数组），移除相匹配的新增删除
            addModification.value = addModification.value.filter((addDataItem) => {
                return addDataItem[primaryKey] !== primaryKeyValue;
            });
        });
        // 2、移除对应的修改变更
        const fullRemovePath = path.concat(`${primaryKey}:${primaryKeyValue}`);
        this.modifications = this.modifications.filter((valueModification) => {
            if (valueModification.type !== ModifyType.ValueChange) {
                return true;
            }
            const valueChangePath = Array.from(valueModification.path);
            valueChangePath.pop();
            // 路径相同进行移除
            const isToRemove = isEqual(valueChangePath, fullRemovePath);
            return !isToRemove;
        });
        // 先删除下级删除变更，再插入
        // 主要针对从从表删除之后，又删除子表时，根实体上还存在从从表删除变更的场景
        this.removeDescendantRemoveModifications(modification);
        this.modifications.push(modification);
    }
    /**
     * 清空变更集合
     */
    clear() {
        this.modifications = [];
    }
    /**
     * 根据path获取Add类型的变更记录
     * @param path 变更路径
     */
    findNewAddItemsPath(path) {
        return this.modifications.find((value, index) => {
            return isEqual(path, value.path) && (value.type === ModifyType.Add || value.type === ModifyType.Insert || value.type === ModifyType.Clone);
        });
    }
    /**
     * 根据path获取ValueChange类型的变更记录
     * @param path 变更路径
     */
    findModifyItemsPath(path) {
        return this.modifications.find((value, index) => {
            return isEqual(path, value.path) && value.type === ModifyType.ValueChange;
        });
    }
    /**
     * 删除后代（包括自己）所有的删除变更
     * @todo：临时做一个最小化修改
     */
    removeDescendantRemoveModifications(parentRemoveModification) {
        const parentPathWithId = this.createRemovePathWithId(parentRemoveModification);
        // 删除后代修改变更
        this.modifications = this.modifications.filter((modification) => {
            if (modification.type !== ModifyType.Remove) {
                return true;
            }
            const descendantPathWithId = this.createRemovePathWithId(modification);
            const isDescendant = this.isDescendantPath(parentPathWithId, descendantPathWithId);
            return !isDescendant;
        });
    }
    /**
     * 获取删除路径的完整格式
     * @summary
     * 1、目前删除变更的路径标记到父集合；
     * 2、为了方便比较，将被删除的数据id加入到路径中
     */
    createRemovePathWithId(modification) {
        const path = modification.path;
        const primaryKey = Object.keys(modification.value)[0];
        const primaryKeyValue = modification.value[primaryKey];
        const pathWithId = path.concat([`${primaryKey}:${primaryKeyValue}`]);
        return pathWithId;
    }
    /**
     * 判断是否是后代节点路径
     * @param parentPath 父节点路径
     * @param descendantPath 后代节点
     */
    isDescendantPath(parentPath, descendantPath) {
        if (parentPath.length > descendantPath.length) {
            return false;
        }
        let isDescendantPath = true;
        parentPath.forEach((parentPathItem, parentPathItemIndex) => {
            if (parentPathItem !== descendantPath[parentPathItemIndex]) {
                isDescendantPath = false;
                return;
            }
        });
        return isDescendantPath;
    }
}

function isPlainObject(value) {
    if (!(typeof value === 'object' && value !== null) || Object.prototype.toString.call({}) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    let proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
}
/**
 * --------------------------------------------------------------------------------
 * NgField
 * --------------------------------------------------------------------------------
 */
/** 实体属性注解器名称 */
const NG_FIELD = 'NgField';
function makeNgFieldDecorator(options) {
    let metadata = {
        primary: false,
        foreign: false
    };
    if (options) {
        const paramType = typeof options;
        switch (paramType) {
            case 'boolean':
                metadata.primary = Boolean(options);
                break;
            case 'string':
                metadata.dataField = String(options);
                break;
            case 'object':
                metadata = Object.assign(metadata, options);
                break;
        }
    }
    return metadata;
}
/**
 * 实体属性注解
 *
 * ### 使用示例
 * ```
 * export class UserEntity extends Entity {
 *      @NgField({
 *          primary: true,
 *          dataField: 'id',
 *          ...
 *      })
 *      userid: string;
 *      userName: string;
 * }
 * ```
 */
const NgField = makePropDecorator(NG_FIELD, makeNgFieldDecorator);
/**
 * --------------------------------------------------------------------------------
 * NgField
 * --------------------------------------------------------------------------------
 */
/** NgList 注解器名称 */
const NG_LIST = 'NgList';
function makeNgListDecorator(options) {
    if (isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 实体属性注解
 * ### 使用示例
 * ```
 * export class UserEntity extends Entity {
 *      @NgField({
 *          primary: true,
 *          dataField: 'id',
 *          ...
 *      })
 *      userid: string;
 *      userName: string;
 *      @NgList({
 *          dataField: 'roles',
 *          formType: Role
 *      })
 *      Roles: EntityList<Role>
 * }
 * ```
 */
const NgList = makePropDecorator(NG_LIST, makeNgListDecorator);
/**
 * --------------------------------------------------------------------------------
 * NgObject
 * --------------------------------------------------------------------------------
 */
/** NgObject 实体属性注解器名称 */
const NG_OBJECT = 'NgObject';
function makeNgObjectDecorator(options) {
    if (isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 实体属性注解
 * ### 使用示例
 *
 * ```
 *  export class UserEntity entends Entity {
 *      @NgField(true)  // 设置为主键
 *      id: string;
 *      @NgField('name')  // 设置数据映射字段为 name
 *      userName: string;
 *
 *      depid: string;
 *
 *      @NgObject(Department)  // 设置引用类型为 Department 实体类
 *      epartment: Department;
 *  }
 * ```
 */
const NgObject = makePropDecorator(NG_OBJECT, makeNgObjectDecorator);
/**
 * --------------------------------------------------------------------------------
 * NgDynamicProperty
 * --------------------------------------------------------------------------------
 */
/** NgObject 实体属性注解器名称 */
const NG_Dynamic = 'NgDynamic';
function makeNgDynamicDecorator(options) {
    if (isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 实体属性注解
 * ### 使用示例
 *
 * ```
 *  export class UserEntity entends Entity {
 *      @NgField(true)  // 设置为主键
 *      id: string;
 *      @NgField('name')  // 设置数据映射字段为 name
 *      userName: string;
 *
 *      depid: string;
 *
 *      @NgDynamic(Department)  // 设置引用类型为 Department 实体类
 *      epartment: Department;
 *  }
 * ```
 */
const NgDynamic = makePropDecorator(NG_Dynamic, makeNgDynamicDecorator);

const NG_ENTITY = 'NgEntity';
/**
 * 实体装饰器
 * @param options options
 */
function NgEntity(options) {
    const decoratorFactory = makeDecorator(NG_ENTITY, (obj) => obj);
    return decoratorFactory(options);
}

/**
 * 属性注解器通用方法
 */
class FieldMetadataUtil {
    /**
     * 获取实体所有的简单属性元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgObjectProperty}
     */
    static getNgFields(target) {
        return MetadataUtil.getPropsMetadatasByName(target, NG_FIELD);
    }
    /**
     * 获取某个简单属性的元数据
     */
    static getNgField(target, propName) {
        const ngFields = this.getNgFields(target);
        const ngField = ngFields[propName];
        return ngField;
    }
    /**
     * 获取实体属性在原始数据中的属性名
     */
    static getDataField(target, propName) {
        const ngField = this.getNgField(target, propName);
        return ngField.dataField || propName;
    }
    /**
     * 获取标注为NgObject的属性的元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgObjectProperty}
     */
    static getNgObjects(target) {
        return MetadataUtil.getPropsMetadatasByName(target, NG_OBJECT);
    }
    static getNgDynamic(target) {
        return MetadataUtil.getPropsMetadatasByName(target, NG_Dynamic);
    }
    /**
     * 获取标注为NgList的属性的元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgListProperty}
     */
    static getNgList(target) {
        return MetadataUtil.getPropsMetadatasByName(target, NG_LIST);
    }
    /**
     * 获取实体标注为主键的属性元数据
     * @param target 实体类型
     */
    static getPrimaryFieldMetadata(target) {
        const ngFieldObj = FieldMetadataUtil.getNgFields(target);
        const primaryKey = Object.keys(ngFieldObj).find((prop) => {
            return ngFieldObj[prop].primary;
        });
        if (primaryKey) {
            const propMeta = ngFieldObj[primaryKey];
            propMeta.property = primaryKey;
            if (!propMeta.dataField) {
                propMeta.dataField = primaryKey;
            }
            return propMeta;
        }
        return undefined;
    }
    /**
     * 获取主键名称，没有主键时返回空字符串
     */
    static getPrimaryKey(entityType) {
        const primaryNgField = this.getPrimaryFieldMetadata(entityType);
        if (!primaryNgField) {
            return '';
        }
        return primaryNgField.property;
    }
    // static udtMap = {};
    /**
     * 获取NgField 的验证规则元数据
     * @param target 实体类Type
     */
    static getValidationMetadata(target) {
        const fieldMetadatas = FieldMetadataUtil.getNgFields(target);
        // this.udtMap = Object.assign(this.udtMap || {}, FieldMetadataUtil.getNgObjects(target) || {});
        // let udtParentName = '';
        // Object.keys(this.udtMap).forEach(key => {
        //   // 当前实体是udt类型时
        //   if (this.udtMap[key].type.name === target.name) {
        //     // 找出当前udt实体的父级信息
        //     udtParentName = key;
        //   }
        // });
        const metadatas = {};
        // let primaryId = '';
        // let udtPrimaryId = '';
        // 不进行验证的属性名
        // const excludeIDs = [];
        // 排除udt的主键
        // Object.keys(fieldMetadatas).forEach(key => {
        //   if (fieldMetadatas[key].primary || fieldMetadatas[key].foreign) {
        //     primaryId = fieldMetadatas[key].dataField;
        //     udtPrimaryId = fieldMetadatas[key].dataField + '_ID';
        //     excludeIDs.push(fieldMetadatas[key].dataField);
        //   }
        // });
        Object.keys(fieldMetadatas).forEach(key => {
            if (fieldMetadatas[key].primary || fieldMetadatas[key].foreign) {
                return;
            }
            const validRules = fieldMetadatas[key].validRules;
            // if (excludeIDs.indexOf(key) > -1) {
            //   return;
            // }
            if (validRules && validRules.length) {
                validRules.map(rule => {
                    rule.property = key;
                    rule['targetName'] = target.name;
                });
                metadatas[key] = validRules;
            }
        });
        return metadatas;
    }
    static getValidationMetadataWithPath(object) {
        const target = object.constructor;
        const fieldMetadatas = FieldMetadataUtil.getNgFields(target);
        const parentPaths = object.getPaths().path || [];
        const metadatas = {};
        Object.keys(fieldMetadatas).forEach((key) => {
            if (fieldMetadatas[key].primary || fieldMetadatas[key].foreign) {
                return;
            }
            const validRules = fieldMetadatas[key].validRules;
            if (validRules && validRules.length) {
                const propertyPath = parentPaths.concat([]);
                propertyPath.push(key);
                const property = propertyPath.join('.');
                validRules.map((rule) => {
                    rule.property = key;
                    rule['targetName'] = target.name;
                    rule['path'] = property;
                });
                metadatas[key] = validRules;
            }
        });
        return metadatas;
    }
}

/**
 * 实体元数据工具类
 */
class EntityMetadataUtil {
    /**
     * 获取所有属性
     * @todo：封装根据基类获取所有元数据的方法，解决重复代码
     */
    static getAllNgProperties(entityType) {
        const ngPlainProperties = this.getNgFieldProperties(entityType);
        const ngEntityProperties = this.getNgObjectProperties(entityType);
        const ngDynamicProperties = this.getNgDynamicProperties(entityType);
        const ngEntityListProperties = this.getNgObjectProperties(entityType);
        return Object.assign({}, ngPlainProperties, ngEntityProperties, ngDynamicProperties, ngEntityListProperties);
    }
    /**
     * 获取实体元数据描述
     */
    static getNgEntityMatadata(entityType) {
        return MetadataUtil.getClassMetadataByNameWithTranslate(entityType, NG_ENTITY);
    }
    /**
     * 获取NgField的属性元数据
     */
    static getNgFieldProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, NG_FIELD);
    }
    /**
     * 获取NgObject属性元数据
     */
    static getNgObjectProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, NG_OBJECT);
    }
    /**
     * 获取NgDynamic属性元数据
     */
    static getNgDynamicProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, NG_Dynamic);
    }
    /**
     * 获取NgList属性元数据
     */
    static getNgListProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, NG_LIST);
    }
    /**
     * 获取主键属性元数据
     */
    static getPrimaryKeyProperty(entityType) {
        let primaryKeyProperty;
        const ngPlainProperties = EntityMetadataUtil.getNgFieldProperties(entityType);
        Object.keys(ngPlainProperties).forEach((propName) => {
            const ngProperty = ngPlainProperties[propName];
            if (ngProperty.primary === true) {
                primaryKeyProperty = ngProperty;
            }
        });
        return primaryKeyProperty;
    }
}

const PARENT_PATH = '__PARENT_PATH__';
const PARENT_CLASS = '__PARENT__';

function EntityFactory(T, data) {
    // const entity = new T(data);
    const entity = EntityTypeCreator.create(T, data);
    return entity;
}
function DynamicFactory(T, data) {
    const entity = new T(data);
    return entity;
}

class EntityTypeCreator {
    static create(constructor, data) {
        const entityType = this.getType(constructor);
        const entity = new entityType(data);
        entity.constructor = constructor;
        return entity;
    }
    // @Cache({ key: ((context: any, args: any[]) => { return args[0] }), provider: new MemoryCacheProvider() })
    static createType(constructor) {
        const entityType = class EntityType extends Entity {
            constructor(data) {
                super(data);
            }
        };
        const entityPrototype = entityType.prototype;
        this.extendProperties(constructor, entityPrototype);
        return entityType;
    }
    static extendProperties(constructor, entityPrototype) {
        const ngFields = FieldMetadataUtil.getNgFields(constructor);
        const ngObjects = FieldMetadataUtil.getNgObjects(constructor);
        const ngLists = FieldMetadataUtil.getNgList(constructor);
        const ngDynamic = FieldMetadataUtil.getNgDynamic(constructor);
        this.extendPlainProperty(entityPrototype, ngFields);
        this.extendListProperty(entityPrototype, ngLists);
        this.extendObjectProperty(entityPrototype, ngObjects);
        this.extendDynamicProperty(entityPrototype, ngDynamic);
    }
    static extendPlainProperty(entityPrototype, ngFields) {
        Object.keys(ngFields).forEach(function (propName) {
            const ngField = ngFields[propName];
            // const dataField = ngField.dataField || propName;
            Object.defineProperty(entityPrototype, propName, {
                get: function () {
                    const value = this.getPropValue(propName, ngField);
                    return value;
                },
                set: function (newPropValue) {
                    // 值相同时不触发变更。
                    const oldPropValue = this.getPropValue(propName, ngField);
                    if (this.isPropValueChanged(propName, ngField, newPropValue, oldPropValue) === false) {
                        return;
                    }
                    this.setPropValue(propName, ngField, newPropValue);
                    const changeSetValue = this.preparePropValue(propName, ngField, newPropValue);
                    this.emitValueChange(propName, ngField, newPropValue, oldPropValue, changeSetValue);
                }
            });
        });
    }
    static extendListProperty(entityPrototype, ngListMetadata) {
        Object.keys(ngListMetadata).forEach(function (propertyName) {
            const key = `__${propertyName}__`;
            Object.defineProperty(entityPrototype, propertyName, {
                get: function () {
                    let entityList = this[key];
                    if (!entityList) {
                        const fieldMetadata = ngListMetadata[propertyName];
                        const path = this.createPath(propertyName);
                        const dataField = fieldMetadata.dataField || propertyName;
                        const val = this.data[dataField];
                        entityList = new EntityList();
                        entityList[PARENT_CLASS] = this;
                        entityList[PARENT_PATH] = path;
                        if (val) {
                            const entities = val.map(v => EntityFactory(fieldMetadata.type, v));
                            entityList.loadEntities(entities);
                        }
                        entityList.onListChanged.subscribe(value => {
                            if (value) {
                                if (entityList[PARENT_PATH][0] !== value.path[0]) {
                                    value.path = entityList[PARENT_PATH].concat(value.path);
                                }
                                this.setChanges(value);
                            }
                        });
                        this[key] = entityList;
                    }
                    return entityList;
                },
                set: function (value) {
                    this[key] = value;
                }
            });
        });
    }
    static extendObjectProperty(entityPrototype, ngObjectMetadata) {
        Object.keys(ngObjectMetadata).forEach(function (propertyName) {
            const fieldMetadata = ngObjectMetadata[propertyName];
            const key = `__${propertyName}__`;
            // 如果没有值用一个空对象代替
            Object.defineProperty(entityPrototype, propertyName, {
                get: function () {
                    let childEntity = this[key];
                    const path = this.createPath(propertyName);
                    if (!childEntity) {
                        const dataField = fieldMetadata.dataField || propertyName;
                        // val不存在时，用空对象代替
                        const val = this.data[dataField] || {};
                        childEntity = EntityTypeCreator.buildEntity(path, val, this, fieldMetadata);
                        this[key] = childEntity;
                    }
                    return childEntity;
                },
                set: function (value) {
                    const path = this.createPath(propertyName);
                    const modifyInfo = {
                        path: path,
                        value: value.data,
                        preValue: this[propertyName].data,
                        type: ModifyType.ValueChange
                    };
                    const childEntity = EntityTypeCreator.buildEntity(path, value, this, fieldMetadata);
                    this[key] = childEntity;
                    this.setChanges(modifyInfo);
                }
            });
        });
    }
    static extendDynamicProperty(entityPrototype, ngDynamicMetadata) {
        Object.keys(ngDynamicMetadata).forEach(function (propertyName) {
            const fieldMetadata = ngDynamicMetadata[propertyName];
            const key = `__${propertyName}__`;
            Object.defineProperty(entityPrototype, propertyName, {
                get: function () {
                    let dynamicEntity = this[key];
                    const path = this.createPath(propertyName);
                    if (!dynamicEntity) {
                        const dataField = fieldMetadata.dataField || propertyName;
                        const originalData = this.data[dataField] || {};
                        dynamicEntity = EntityTypeCreator.buildDynamic(path, originalData, this, fieldMetadata);
                        this[key] = dynamicEntity;
                    }
                    return dynamicEntity;
                },
                set: function (value) {
                    const path = this.createPath(propertyName);
                    const modifyInfo = {
                        path: path,
                        value: value.data,
                        preValue: this[propertyName].data,
                        type: ModifyType.ValueChange
                    };
                    let dynamicEntity = EntityTypeCreator.buildDynamic(path, value, this, fieldMetadata);
                    this[key] = dynamicEntity;
                    this.setChanges(modifyInfo);
                }
            });
        });
    }
    static getType(constructor) {
        if (this.buffer.has(constructor)) {
            return this.buffer.get(constructor);
        }
        const entityType = this.createType(constructor);
        this.buffer.set(constructor, entityType);
        return entityType;
    }
    static buildEntity(parentPath, value, parent, fieldMetadata) {
        let instance;
        if (value instanceof fieldMetadata.type) {
            instance = value;
        }
        else {
            instance = EntityFactory(fieldMetadata.type, value);
        }
        instance[PARENT_CLASS] = parent;
        instance[PARENT_PATH] = parentPath;
        instance.onValueChanged.subscribe(changes => {
            if (changes) {
                changes.path = (parent[PARENT_PATH] || []).concat(changes.path);
                const change = Object.assign({}, changes, { fromParent: true });
                parent.setChanges(change);
            }
        });
        return instance;
    }
    static buildDynamic(parentPath, value, parent, fieldMetadata) {
        let instance;
        if (value instanceof fieldMetadata.type) {
            instance = value;
        }
        else {
            instance = DynamicFactory(fieldMetadata.type, value);
        }
        instance[PARENT_CLASS] = parent;
        instance[PARENT_PATH] = parentPath;
        instance.onValueChanged.subscribe(changes => {
            if (changes) {
                changes.path = (parent[PARENT_PATH] || []).concat(changes.path);
                parent.setChanges(changes);
            }
        });
        return instance;
    }
}
EntityTypeCreator.buffer = new Map();

/**
 * 创建实体
 * @param entityType 实体类型
 * @param entityData 实体数据
 */
function createEntity(entityType, entityData) {
    let entity;
    if (entityType && entityType.prototype && entityType.prototype.typeName === 'ConcreteEntityPrototype') {
        entity = new entityType(entityData);
    }
    else {
        entity = EntityTypeCreator.create(entityType, entityData); //new entityType(entityData); 
    }
    entity.constructor = entityType;
    return entity;
}
/**
 * 批量创建实体
 * @param entityType     实体类型
 * @param entityListData 实体数据数组
 */
function createEntities(entityType, entityListData) {
    const entities = [];
    entityListData.forEach((entityData) => {
        const entity = createEntity(entityType, entityData);
        entities.push(entity);
    });
    return entities;
}
/**
 * 已弃用：请使用createEntity方法代替。
 */
function EntityFactory$1(T, data) {
    const entity = new T(data);
    return entity;
}

const validationMessage = {};
/**
 * 验证类型定义
 */
class ValidationTypes {
    /**
     * 判断验证类型是否合法
     * @param type 验证类型
     */
    static isValidType(type) {
        return (type !== `isValidType` &&
            type !== 'getMessage' &&
            Object.keys(this)
                .map(key => this[key])
                .indexOf(type) !== -1);
    }
    /**
     * 获取指定验证类型的提示信息
     * @param type 验证类型
     * @returns 返回验证信息
     */
    static getMessage(type) {
        const messages = validationMessage[this.CURRENT_LANGUAGE] || validationMessage['zh-CHS'];
        return messages[type] || '';
    }
    static setCurrentLanguage(language) {
        this.CURRENT_LANGUAGE = language;
    }
}
ValidationTypes.CURRENT_LANGUAGE = 'zh-CNS';
/**
 * 条件验证表达式
 */
ValidationTypes.CUSTOM_VALIDATION = `customValidation`;
/**
 * 必填
 */
ValidationTypes.REQUIRED = 'required';
/**
 * 比较值是否相同
 */
ValidationTypes.EQUALS = 'equals';
/**
 * 比较值是否不相同
 */
ValidationTypes.NOT_EQUALS = 'notEquals';
/**
 * 数字
 */
ValidationTypes.IS_NUMBER = 'isNumber';
/**
 * 整数
 */
ValidationTypes.IS_INT = 'isInt';
/**
 * 浮点数
 */
ValidationTypes.IS_FLOAT = 'isFloat';
/**
 * 字符串
 */
ValidationTypes.IS_STRING = 'isString';
/**
 * 布尔值
 */
ValidationTypes.IS_BOOLEAN = 'isBoolean';
/**
 * 日期
 */
ValidationTypes.IS_DATE = 'isDate';
/**
 * 日期字符串
 */
ValidationTypes.IS_DATE_STRING = 'isDateString';
/**
 * 布尔值字符串
 */
ValidationTypes.IS_BOOLEAN_STRING = 'isBooleanString';
/**
 * 数字字符串
 */
ValidationTypes.IS_NUMBER_STRING = 'isNumberString';
/**
 * 邮箱地址
 */
ValidationTypes.IS_EMAIL = 'isEmail';
/**
 * JSON
 */
ValidationTypes.IS_JSON = 'isJSON';
/**
 * 字符串小写
 */
ValidationTypes.IS_LOWERCASE = 'isLowercase';
/**
 * 字符串大写
 */
ValidationTypes.IS_UPPERCASE = 'isUppercase';
/**
 * 数字范围
 */
ValidationTypes.RANGE = 'range';
/**
 * 最小值
 */
ValidationTypes.MIN = 'min';
/**
 * 最小值
 */
ValidationTypes.MINVALUE = 'minValue';
/**
 * 最大值
 */
ValidationTypes.MAX = 'max';
/**
 * 最大值
 */
ValidationTypes.MAXVALUE = 'maxValue';
/**
 * 长度
 */
ValidationTypes.LENGTH = 'length';
/**
 * 字符串最大长度
 */
ValidationTypes.MAX_LENGTH = 'maxLength';
/**
 * 字符串最小长度
 */
ValidationTypes.MIN_LENGTH = 'minLength';
/**
 * 最小日期
 */
ValidationTypes.MIN_DATE = 'minDate';
/**
 * 最大日期
 */
ValidationTypes.MAX_DATE = 'maxDate';
/**
 * 排除非法字符
 */
ValidationTypes.EXCLUDE = 'exclude';
/**
 * 正则表达式
 */
ValidationTypes.MATCHES = 'matches';
ValidationTypes.FIELD_CONTAINER = 'fieldContainer';
validationMessage['zh-CHS'] = {
    fieldContainer: `$target 第 $value 行`,
    required: `请输入'$property'`,
    equals: `'$property'的值与$constraint1不相等`,
    notEquals: `'$property'的值不能与'$constraint1'相同`,
    isNumber: `'$property'的值不是数字`,
    isInt: `'$property'的值不是整数`,
    isFloat: `'$property'的值不是浮点型数字`,
    isBoolean: `'$property'的值不是布尔值`,
    isDate: `'$property'的值不是有效日期`,
    isEmail: `邮箱地址不正确`,
    min: `'$property'的值不应小于$constraint1`,
    minValue: `'$property'的值不应小于$constraint1`,
    minDate: `'$property'的日期不应早于$constraint1`,
    max: `'$property'的值不应大于$constraint1`,
    maxValue: `'$property'的值不应大于$constraint1`,
    maxDate: `'$property'不应晚于$constraint1`,
    isBooleanString: `'$property'的值不是有效布尔值`,
    isDateString: `'$property'的值不是有效的日期`,
    isLowercase: `'$property'的值应全部为小写字符串`,
    isUppercase: `'$property'的值应全部为大写字符串`,
    length: `'$property'的长度应介于$constraint1~$constraint2之间`,
    range: `'$property'的值应介于$constraint1~$constraint2之间`,
    maxLength: `'$property'的长度不得大于$constraint1`,
    minLength: `'$property'的长度不得小于$constraint1`,
    isNumberString: `'$property'的值不是数字`,
    exclude: `'$property'的值不能包含：$constraint1`,
    matches: `'$property'校验不通过`
};
validationMessage['en'] = {
    fieldContainer: `$target row $value`,
    required: `Please input '$property'`,
    equals: `'$property' should equals '$constraint1'`,
    notEquals: `'$property' should not equals '$constraint1'`,
    isNumber: `'$property' should be number`,
    isInt: `'$property' should be integer`,
    isFloat: `'$property' should be float`,
    isBoolean: `'$property' should be boolean`,
    isDate: `'$property' should be date`,
    isEmail: `'$property' should be e-mail address`,
    min: `'$property' should not less than $constraint1`,
    minValue: `'$property' should not less than $constraint1`,
    minDate: `'$property' should not early than $constraint1`,
    max: `'$property' should not bigger than $constraint1`,
    maxValue: `'$property' should not bigger than $constraint1`,
    maxDate: `'$property' should not late than $constraint1`,
    isBooleanString: `'$property' should be boolean string`,
    isDateString: `'$property' should be date string`,
    isLowercase: `'$property' should be lowercase charactor`,
    isUppercase: `'$property' should be uppercase charactor`,
    length: `'$property' length should between $constraint1~$constraint2之间`,
    range: `'$property' value should between $constraint1~$constraint2之间`,
    maxLength: `'$property' should not longer than $constraint1`,
    minLength: `'$property' should not shorter than $constraint1`,
    isNumberString: `'$property' should be number string`,
    exclude: `'$property' should not include $constraint1`,
    matches: `'$property' calibration failed`
};
validationMessage['zh-CHT'] = {
    fieldContainer: `$target 第 $value 行`,
    required: `請輸入'$property'`,
    equals: `'$property'的值與$constraint1不相等`,
    notEquals: `'$property'的值不能與'$constraint1'相同`,
    isNumber: `'$property'的值不是數字`,
    isInt: `'$property'的值不是整數`,
    isFloat: `'$property'的值不是浮點型數字`,
    isBoolean: `'$property'的值不是佈爾值`,
    isDate: `'$property'的值不是有效日期`,
    isEmail: `郵箱地址不正確`,
    min: `'$property'的值不應小於$constraint1`,
    minValue: `'$property'的值不應小於$constraint1`,
    minDate: `'$property'的日期不應早於$constraint1`,
    max: `'$property'的值不應大於$constraint1`,
    maxValue: `'$property'的值不應大於$constraint1`,
    maxDate: `'$property'不應晚於$constraint1`,
    isBooleanString: `'$property'的值不是有效佈爾值`,
    isDateString: `'$property'的值不是有效的日期`,
    isLowercase: `'$property'的值應全部爲小冩字符串`,
    isUppercase: `'$property'的值應全部爲大冩字符串`,
    length: `'$property'的長度應介於$constraint1~$constraint2之間`,
    range: `'$property'的值應介於$constraint1~$constraint2之間`,
    maxLength: `'$property'的長度不得大於$constraint1`,
    minLength: `'$property'的長度不得小於$constraint1`,
    isNumberString: `'$property'的值不是數字`,
    exclude: `'$property'的值不能包含：$constraint1`,
    matches: `'$property'校驗不通過`
};

/**
 * 验证错误信息
 */
class ValidationError {
    constructor() {
        /**
         * 待验证的对象是否为数组集合
         */
        this.isArray = false;
        /**
         * 待验证的对象所属集合中的索引
         */
        this.index = undefined;
    }
}

/**
 * 执行数据验证
 */
class ValidationExecutor {
    constructor(validator) {
        this.validator = validator;
        /** 异步验证请求集合 */
        this.awaitingPromises = [];
    }
    /**
     * 将信息中的关键字替换为具体实体对象中的信息
     * @param message 验证信息
     * @param metadata 验证规则
     * @param value 待验证的值
     */
    static replaceMessageSpecialTokens(message, metadata, value) {
        let messageString;
        if (message instanceof Function) {
            messageString = message(metadata);
        }
        else if (typeof message === 'string') {
            messageString = message;
        }
        if (messageString && metadata.constraints instanceof Array) {
            metadata.constraints.forEach((constraint, index) => {
                messageString = messageString.replace(new RegExp(`\\$constraint${index + 1}`, 'g'), constraint);
            });
        }
        if (messageString && value !== undefined && value !== null) {
            messageString = messageString.replace(/\$value/g, value);
        }
        if (messageString) {
            messageString = messageString.replace(/\$property/g, metadata.property);
        }
        if (messageString) {
            messageString = messageString.replace(/\$target/g, metadata.targetName);
        }
        return messageString;
    }
    /**
     * 验证实例对象
     * @param object 验证实例对象
     * @param newValue 实体将要更新的值
     * @param validationErrors 验证信息集合
     * @param propertyName 实例对象属性
     * @param index 所属集合实例中索引
     */
    execute(object, newValue, validationErrors, propertyName, index, externalRules, currentRowId, frameContext) {
        // if (!currentRowId) {
        //   currentRowId = object.primaryValue;
        // }
        if (!externalRules && frameContext) {
            externalRules = frameContext.form.getValidationRules();
        }
        // 提取实体上定义的验证描述
        // 格式{key:[rule1,rule2]}
        let validateMetadatas = FieldMetadataUtil.getValidationMetadataWithPath(object);
        const remainedExternalRules = new Map();
        // 合并额外验证规则
        if (externalRules) {
            // const parentPathArray: string[] = object['__PARENT_PATH__'] ? [...object['__PARENT_PATH__']] : [''];
            // if (parentPathArray.length > 1) {
            //   parentPathArray[0] = '';
            // }
            const parentPathArray = [];
            let objectCursor = object;
            while (objectCursor && objectCursor !== objectCursor['__PARENT__']) {
                const cursorParentPath = objectCursor['__PARENT_PATH__'] ? objectCursor['__PARENT_PATH__'][1] : '';
                // if (parentPathArray[parentPathArray.length - 1] !== cursorParentPath) {
                parentPathArray.push(cursorParentPath);
                // }
                objectCursor = objectCursor['__PARENT__'];
                if (objectCursor instanceof EntityList) {
                    objectCursor = objectCursor['__PARENT__'];
                }
            }
            const parentPath = parentPathArray.reverse().join('/');
            externalRules.forEach((rules, path) => {
                if (path) {
                    // 提取额外验证规则字段路径
                    const pathArray = path.split('/');
                    // 提取字段名称
                    const fieldName = pathArray.pop();
                    // 提取字段父路径
                    const fieldParentPath = pathArray.join('/');
                    // 匹配外部验证规则和实体验证规则父路径
                    if (parentPath === fieldParentPath) {
                        validateMetadatas[fieldName] = [...(validateMetadatas[fieldName] || [])];
                        // 合并外部校验规则到实体校验规则，并同步外部验证规则显示信息至实体验证规则，如：中英文字段描述、字段所在位置。
                        if (rules.length) {
                            let targetId = '';
                            rules.forEach(rule => {
                                if (rule.targetId && rule.targetId.length > targetId.length) {
                                    targetId = rule.targetId;
                                }
                                validateMetadatas[fieldName].push(rule);
                            });
                            validateMetadatas[fieldName].forEach((validateRule) => {
                                validateRule.targetId = targetId;
                                validateRule.targetName = rules[0].targetName;
                                validateRule.property = rules[0].property;
                                if (rules[0].frameContext) {
                                    validateRule.frameContext = rules[0].frameContext;
                                }
                                validateRule.fullPath = rules[0].fullPath;
                                validateRule['initialized'] = true;
                            });
                        }
                    }
                    else {
                        remainedExternalRules.set(path, rules);
                    }
                }
            });
        }
        // 处理校验规则中的属性名称
        // 场景为前端未开启校验或form校验规则中对应绑定路径中对应控件未开启校验，导致上一步骤中组件名、字段名未能同步为对应中文
        if (validateMetadatas && Object.keys(validateMetadatas).length > 0) {
            Object.keys(validateMetadatas).forEach((fieldName) => {
                const validateRules = validateMetadatas[fieldName];
                if (validateRules && validateRules.length > 0) {
                    const firstValidateRule = validateRules[0];
                    const path = firstValidateRule['path'];
                    if (path) {
                        validateRules.forEach((validateRule) => {
                            // 将initialized判断外移减少代码执行次数
                            if (validateRule['initialized'] !== true) {
                                const bindingPaths = path.split('.');
                                const form = this.getForm(bindingPaths, frameContext);
                                const formControl = this.getFormControl(bindingPaths, frameContext);
                                if (formControl) {
                                    validateRule.targetId = formControl.id;
                                    validateRule.targetName = form && form.formGroupName;
                                    validateRule.property = formControl.name || formControl.defaultI18nValue || '';
                                }
                            }
                        });
                    }
                }
            });
        }
        // 过滤出当前验证属性的验证规则
        if (propertyName) {
            validateMetadatas = Object.keys(validateMetadatas)
                .filter(key => key === propertyName)
                .reduce((val, curr) => Object.assign({}, val, { [curr]: validateMetadatas[curr] }), {});
        }
        // validateMetadatas = {rule:当前属性的所有校验规则}
        Object.keys(validateMetadatas).filter((key) => object && (object.hasOwnProperty(key) ||
            (object.constructor.prototype &&
                object.constructor.prototype.typeName &&
                object.constructor.prototype.hasOwnProperty(key)) ||
            object['__proto__'].hasOwnProperty(key))).forEach(key => {
            // todo: 没用兼容value是undefined的情况
            let value = newValue;
            if (newValue === undefined) {
                value = object[key];
            }
            let isMultLanguageField = false;
            const multiLangFields = this.getMultiLanguageFields(object);
            if (multiLangFields && multiLangFields.length > 0) {
                if (multiLangFields.includes(key)) {
                    isMultLanguageField = true;
                }
            }
            // const value = newValue ||
            const validateRules = validateMetadatas[key];
            if (validateRules.length) {
                const { property: fieldName, targetId: field, frameContext, fullPath } = validateRules[0];
                // const fieldContainerName = Number.isInteger(index) ?
                // `${validateRules[0].targetName} 第${index + 1}行` : validateRules[0].targetName;
                const fieldContainerName = Number.isInteger(index) ?
                    ValidationExecutor.replaceMessageSpecialTokens(ValidationTypes.getMessage(ValidationTypes.FIELD_CONTAINER), validateRules[0], index + 1) : validateRules[0].targetName;
                const validationDisplayName = fieldContainerName ? `${fieldContainerName} - ${fieldName}` : `${fieldName}`;
                // const property = validateRules['path'] || key;
                const validationError = this.generateValidationError(object, value, key, validationDisplayName, index, field, frameContext, fullPath);
                if (index !== undefined) {
                    validationError['index'] = index;
                }
                validationErrors.push(validationError);
                this.defaultValidations(object, value, validateRules, validationError, isMultLanguageField, currentRowId);
            }
        });
        this.objectValidations(object, validationErrors, propertyName, index, remainedExternalRules, currentRowId, frameContext);
        this.listValidations(object, validationErrors, propertyName, index, remainedExternalRules, frameContext);
        // this.sortValidationErrors(validationErrors);
        // todo 存在某些ngObject类型的数据，界面上没有，实体中有，实体设置了必填，导致验证不通过无法保存的问题
        // if (!propertyName) {
        //     this.objectValidations(object, validationErrors);
        // }
    }
    getMultiLanguageFields(entity) {
        if (entity && entity.constructor) {
            const ngFields = FieldMetadataUtil.getNgFields(entity.constructor);
            return Object.keys(ngFields).filter((fieldName) => ngFields[fieldName].enableMultiLangInput);
        }
        return null;
    }
    /**
     * 清除通过验证信息
     * @param errors 验证失败信息
     */
    stripEmptyErrors(errors) {
        return errors.filter(error => {
            if (error.children) {
                error.children = this.stripEmptyErrors(error.children);
            }
            if (Object.keys(error.constraints).length === 0) {
                if (error.children.length === 0) {
                    return false;
                }
                else {
                    delete error.constraints;
                }
            }
            return true;
        });
    }
    /**
     * 生成未通过验证的对象
     * @param object 要验证的实体实例对象
     * @param value 要验证的值
     * @param propertyName 待验证的实体属性名称
     * @param index 验证数据索引
     * @param field 待验证字段
     */
    generateValidationError(object, value, property, propertyName, index, field, frameContext, fullPath) {
        const validationError = new ValidationError();
        validationError.target = object;
        validationError.value = value;
        validationError.property = property;
        validationError.propertyName = propertyName;
        validationError.field = field;
        validationError.index = index;
        validationError.children = [];
        validationError.constraints = {};
        if (frameContext) {
            validationError.frameContext = frameContext;
        }
        validationError.fullPath = fullPath;
        return validationError;
    }
    /**
     * 验证实体中的属性
     * @param object 要验证的实体实例对象
     * @param value 要验证的值
     * @param validateRules 验证规则
     * @param errorMap 难证信息。{[key]: message}
     *
     * key: 验证规则名称
     * message: 验证信息
     */
    defaultValidations(object, value, validateRules, validationError, isMultLanguageField, currentRowId) {
        const errorMap = validationError.constraints;
        return validateRules
            .filter((validateRule) => {
            // 验证实体属性是否符合规则
            const validValue = this.validator.validateValueByMetadata(object, value, validateRule, isMultLanguageField, currentRowId);
            if (validValue instanceof Promise) {
                const promise = validValue.then((isValid) => {
                    if (!isValid) {
                        const { type, messageString: message } = this.createValidationError(object, value, validateRule);
                        errorMap[type] = message;
                        validationError.rule = validateRule;
                    }
                });
                this.awaitingPromises.push(promise);
            }
            return !validValue;
        })
            .forEach((validateRule) => {
            // 不符合规则，生成错误信息
            const { type: key, messageString: message } = this.createValidationError(object, value, validateRule);
            errorMap[key] = message;
            validationError.rule = validateRule;
        });
    }
    /**
     * 验证列表中的每条记录
     * @param object 要验证的实体实例对象
     * @param errors 验证失败的信息集合
     * @param property 属性名称
     * @param parentIndex 当前集合的父对象所属集合列表中的索引。
     */
    listValidations(object, errors, property, parentIndex, externalRules, frameContext) {
        const INDEX_LABEL = "__ACTUAL_INDEX__";
        const listFields = FieldMetadataUtil.getNgList(object.constructor);
        if (!listFields) {
            return;
        }
        let keys = Object.keys(listFields);
        if (property) {
            keys = keys.filter(key => key === property);
        }
        keys.forEach(propertyName => {
            const metadata = listFields[propertyName];
            const clzType = metadata.type;
            const value = object[propertyName];
            if (value) {
                const parentPaths = object.getPaths().path || [];
                parentPaths.push(propertyName);
                const validationError = this.generateValidationError(object, value.items, parentPaths.join('.'), propertyName, parentIndex);
                validationError.isArray = true;
                errors.push(validationError);
                value.items.forEach((entity, index) => {
                    let actualIndex = entity[INDEX_LABEL] ? entity[INDEX_LABEL] : index;
                    this.execute(entity, undefined, validationError.children, undefined, actualIndex, externalRules, entity.primaryValue, frameContext);
                });
            }
        });
    }
    /**
     * 验证实体中的引用对象
     * @param object 要验证的实体对象
     * @param errors 错误信息集合
     */
    objectValidations(object, errors, property, parentIndex, externalRules, currentRowId, frameContext) {
        const objectFields = FieldMetadataUtil.getNgObjects(object.constructor);
        if (!objectFields || Object.keys(objectFields).length < 1) {
            return;
        }
        let keys = Object.keys(objectFields);
        if (property) {
            keys = keys.filter(key => key === property);
        }
        keys.forEach(propertyName => {
            const metadata = objectFields[propertyName];
            const objectType = metadata.type;
            const value = object[propertyName];
            if (value) {
                this.execute(value, undefined, errors, undefined, parentIndex, externalRules, currentRowId, frameContext);
            }
        });
    }
    /**
     * 创建验证规则信息
     * @param object 要验证的实体对象
     * @param value 验证的值
     * @param metadata 验证规则
     */
    createValidationError(object, value, metadata) {
        // const targetName = object.constructor ? (object.constructor as any).name : undefined;
        const type = metadata.type;
        // 获取校验提示信息：先使用内置规则获取，获取不到时使用元数据上的提示，以兼容表达式场景
        let message = ValidationTypes.getMessage(type);
        if (!message) {
            message = metadata.message;
        }
        if (ValidationTypes.isValidType(type) && (type === ValidationTypes.MAXVALUE || type === ValidationTypes.MINVALUE)) {
            if (this.isDateString(value) && metadata.constraints && metadata.constraints.length) {
                // 获取日期类型的提示信息
                const extType = type === ValidationTypes.MINVALUE ? ValidationTypes.MIN_DATE : ValidationTypes.MAX_DATE;
                message = ValidationTypes.getMessage(extType);
                /*if (metadata.constraints[0]) {
                  metadata.constraints[0] = DateUtil.format(metadata.constraints[0], 'yyyy-MM-dd HH:mm:ss');
                }*/
            }
        }
        const messageString = ValidationExecutor.replaceMessageSpecialTokens(message, metadata, value);
        return { type, messageString, metadata };
    }
    getFrameContext(bindingPaths, eventFrameContext) {
        if (!bindingPaths || bindingPaths.length < 1 || !eventFrameContext) {
            return null;
        }
        const paths = bindingPaths.concat([]);
        paths.pop();
        const bindingPath = paths.join('/');
        const frameContext = eventFrameContext.appContext.frameContextManager.getFrameContexts().find((context) => context && context.viewModel && context.viewModel.bindingPath && context.viewModel.bindingPath.split('/').filter(p => p).join('/') === bindingPath);
        return frameContext || null;
    }
    getForm(bindingPaths, eventFrameContext) {
        if (!bindingPaths || bindingPaths.length < 1 || !eventFrameContext) {
            return null;
        }
        const frameContext = this.getFrameContext(bindingPaths, eventFrameContext);
        return frameContext && frameContext.form || null;
    }
    getFormControl(bindingPaths, eventFrameContext) {
        if (!bindingPaths || bindingPaths.length < 1 || !eventFrameContext) {
            return null;
        }
        const paths = bindingPaths.concat([]);
        const propertyName = paths.pop();
        const frameContext = this.getFrameContext(bindingPaths, eventFrameContext);
        const formControl = frameContext && frameContext.form && frameContext.form.ngFormControls && frameContext.form.ngFormControls[propertyName] || null;
        return formControl;
    }
    isDateString(value) {
        const regex = /\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])(T|\s?)?(([0-2]\d:[0-5]\d)?(:[0-5]\d(?:\.\d+)))?(?:Z|\+[0-2]\d(?:\:[0-5]\d)?)?/g;
        return regex.test(value);
    }
}

/**
 * 数据验证帮助类，提供一些公共的操作方法函数
 */
class ValidationUtils {
    /**
     * 将错误信息集合转变为可读性高的文本数组
     * @param errors 验证失败错误集合
     * @param messages 返回的错误信息文本集合
     * @param parentPath 验证属性上级路径
     */
    static createDetailedErrorMessage(errors, messages = [], parentPath = '') {
        errors.forEach(error => {
            const targetName = error.target ? error.target.constructor.name : '';
            const property = error.propertyName;
            const propConstraintFailed = (propertyName) => `   - 属性 ${parentPath}${propertyName} 验证失败的规则:  \n` +
                `${Object.keys(error.constraints)
                    .map(ruleName => {
                    return `        #${ruleName}: ${error.constraints[ruleName]}\n`;
                })
                    .join('')}`;
            if (!parentPath) {
                messages.push(`类型为 ${targetName} 的实例对象数据验证失败，详细信息：\n`);
                if (error.constraints) {
                    messages.push(propConstraintFailed(property));
                }
                if (error.children.length) {
                    ValidationUtils.createDetailedErrorMessage(error.children, messages, property);
                }
            }
            else {
                const formattedProperty = Number.isInteger(+error.index)
                    ? `[${error.index}].${property}`
                    : `${parentPath ? `.` : ``}${property}`;
                if (error.constraints) {
                    messages.push(propConstraintFailed(formattedProperty));
                }
                if (error.children.length) {
                    ValidationUtils.createDetailedErrorMessage(error.children, messages, `${parentPath}${formattedProperty}`);
                }
            }
        });
        return messages;
    }
    /**
     * 错误信息集合转换为简单对象格式
     * @param errors 错误信息集合
     * @param errObj 返回简单对象。如:
     * ```
     * { name: { required: '必填', max: '最大值99' },
     *   list: {
     *      0: { name:{required: '必填'},
     *           age: { min: '最小值 20' }
     *         },
     *      2: { ... }
     *   }
     * }
     *
     * ```
     */
    static convertErrorsToNormalObject(errors, errObj) {
        errors.forEach(err => {
            const property = err.propertyName;
            const buildArray = (childErrors) => {
                const itemErr = {};
                childErrors.forEach((childErr) => {
                    if (childErr.children.length) {
                        itemErr[childErr.index] = ValidationUtils.convertErrorsToNormalObject(childErr.children, childErr);
                    }
                    else {
                        if (itemErr[childErr.index]) {
                            itemErr[childErr.index] = Object.assign({}, itemErr[childErr.index], {
                                [childErr.propertyName]: childErr.constraints
                            });
                        }
                        else {
                            itemErr[childErr.index] = { [childErr.propertyName]: childErr.constraints };
                        }
                    }
                });
                return itemErr;
            };
            if (!err.isArray) {
                if (!err.children.length) {
                    errObj[property] = err.constraints;
                }
                else {
                    errObj[property] = ValidationUtils.convertErrorsToNormalObject(err.children, errObj);
                }
            }
            else {
                errObj[property] = buildArray(err.children);
            }
        });
        return errObj;
    }
}

/**
 * 日期处理类
 */
class DateUtil {
    /**
     * 将日期（或日期字符串）转换为完整的的ISO格式的字符串
     */
    static formatISO(dateOrDateString) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const dateObj = this.parse(dateOrDateString);
        return format(dateObj, this.defaultISOFormat);
    }
    /**
     * 将日期（或日期字符串）转换为指定格式的字符串
     * @param dateOrDateString 日期对象或符合ISO8601规范的日期字符串
     * @param dateFormat 日期格式字符串
     */
    static format(dateOrDateString, dateFormat) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const dateObj = this.parse(dateOrDateString);
        dateFormat = dateFormat ? dateFormat : this.defaultDisplayFormat;
        return format(dateObj, dateFormat);
    }
    /**
     * 创建日期
     * @param dateOrDateString 日期对象或符合ISO8601规范的日期字符串
     */
    static parse(dateOrDateString) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return null;
        }
        if (this.isDate(dateOrDateString) === true) {
            return dateOrDateString;
        }
        return parseISO(dateOrDateString);
    }
    /**
     * 是否是日期对象
     */
    static isDate(date) {
        return isDate(date);
    }
    /**
     * 是否是空日期或者空日期字符串
     * @param dateOrDateString 日期或日期字符串
     */
    static isEmptyDateOrDateString(dateOrDateString) {
        if (this.isDate(dateOrDateString) === true) {
            return this.isEmptyDate(dateOrDateString);
        }
        return this.isEmptyDateString(dateOrDateString);
    }
    /**
     * 是否为空日期字符串
     * @param date 日期对象
     */
    static isEmptyDate(date) {
        if (!date) {
            return true;
        }
        return false;
    }
    /**
     * 是否是空日期字符串
     * @param dateString 日期字符串
     */
    static isEmptyDateString(dateString) {
        if (!dateString || dateString.startsWith('0001-01-01') === true) {
            return true;
        }
        return false;
    }
    /**
     * 两个日期是否相等
     * @param dateOrDateString1 日期对象或字符串
     * @param dateOrDateString1 日期对象或字符串
     * @return 相等返回true，否则返回false
     */
    static isEqual(dateOrDateString1, dateOrDateString2) {
        const dateObj1 = this.parse(dateOrDateString1);
        const dateObj2 = this.parse(dateOrDateString2);
        if (dateObj1 === dateObj2) {
            return true;
        }
        return isEqual$1(dateObj1, dateObj2);
    }
    /**
     * 两个日期是否相等
     * @param dateOrDateString1 日期对象或字符串
     * @param dateOrDateString1 日期对象或字符串
     * @return 返回-1、0、1
     */
    static compare(dateOrDateString1, dateOrDateString2) {
        const dateObj1 = this.parse(dateOrDateString1);
        const dateObj2 = this.parse(dateOrDateString2);
        if (this.isEqual(dateObj1, dateObj2) === true) {
            return 0;
        }
        // 处理解析后为null的场景，null比所有有效日期小
        if (!dateObj1 && this.isDate(dateObj2) === true) {
            return -1;
        }
        if (!dateObj2 && this.isDate(dateObj1) === true) {
            return 1;
        }
        return compareAsc(dateObj1, dateObj2);
    }
}
/**
 * 空日期字符串（N版）
 * @todo：兼容服务器端，不应该在devkit体现这种兼容，待移除
 */
// static emptyDateTimeString = '0001-01-01T00:00:00';
DateUtil.emptyDateTimeString = null;
/**
 * 默认空日期字符串（ISO标准格式）
 */
// static emptyISODateTimeString = '0001-01-01T00:00:00+00:00';
DateUtil.emptyISODateTimeString = null;
/**
 * 默认日期听格式
 */
DateUtil.defaultISOFormat = `yyyy-MM-dd'T'HH:mm:ssxxx`;
DateUtil.defaultDisplayFormat = 'yyyy-MM-dd HH:mm:ss';
DateUtil.defaultDateFormat = 'yyyy-MM-dd';
DateUtil.defaultTimeFormat = 'HH:mm:ss';

class TranslateService {
    /**
     * 设置多语服务
     * @param translate translate
     */
    static setTranslate(translate) {
        if (translate) {
            this.translate = translate;
        }
    }
    /**
     * 获取当前语言
     */
    static getCurrentLanguage() {
        return this.translate && this.translate.getCurrentLanguage() || this.defaultLanguage;
    }
    static dispose() {
        this.translate = null;
    }
}
TranslateService.defaultLanguage = 'zh-CHS';
TranslateService.translate = null;

/**
 * 校验实体实例对象数据
 */
class Validator {
    constructor() {
        this.validatorJs = ValidatorJS__default;
    }
    /**
     * 验证实例对象中数据是否合法
     * @param object 待校验的实例对象
     * @param propertyName 待校验实例对象属性名称，为空则验证实例对象中所有带有验证规则的属性
     */
    // tslint:disable-next-line: max-line-length
    validate(object, propertyName, value, externalRules, index, frameContext) {
        const validationErrors = [];
        const executor = new ValidationExecutor(this);
        executor.execute(object, value, validationErrors, propertyName, index, externalRules, null, frameContext);
        return Promise.all(executor.awaitingPromises).then(() => {
            const errors = executor.stripEmptyErrors(validationErrors);
            this.sortValidationErrors(errors);
            return this.buildErrors(errors);
        });
    }
    /**
     * 校验信息排序（为了兼容树形表）
     * @param validationErrors 验证信息数组
     */
    sortValidationErrors(validationErrors) {
        // 如果存在无序号的信息则不排序
        let sortable = true;
        validationErrors.forEach(info => {
            if (info.children && info.children.length > 1) {
                this.sortValidationErrors(info.children);
            }
            if (typeof info.index !== "number") {
                sortable = false;
            }
        });
        if (sortable) {
            validationErrors.sort((a, b) => a.index - b.index);
        }
    }
    /**
     * 执行校验
     * @param object
     * @param propertyName
     * @param value
     * @param externalRules
     * @param index
     * @param frameContext
     * @param ignoreAsyncValidateRules
     * @returns
     */
    verify(object, propertyName, value, externalRules, index, frameContext, ignoreAsyncValidateRules = false) {
        const validationErrors = [];
        const executor = new ValidationExecutor(this);
        executor.execute(object, value, validationErrors, propertyName, index, externalRules, null, frameContext);
        if (executor.awaitingPromises && executor.awaitingPromises.length > 0 && ignoreAsyncValidateRules === false) {
            return Promise.all(executor.awaitingPromises).then(() => {
                const errors = executor.stripEmptyErrors(validationErrors);
                const result = this.buildErrors(errors);
                return result;
            });
        }
        else {
            const errors = executor.stripEmptyErrors(validationErrors);
            return this.buildErrors(errors);
        }
    }
    /**
     * 验证实体属性元数据中设置的校验规则是否合法
     * @param object 实例对象
     * @param value 待校验的值
     * @param validateRule 验证规则
     */
    validateValueByMetadata(object, value, validateRule, isMultLanguageField, currentRowId) {
        const validType = validateRule.type;
        let constraintsToValidate = [];
        if (validateRule.constraints) {
            constraintsToValidate = validateRule.constraints.map(param => {
                if (typeof param === 'function') {
                    return param(object, value);
                }
                return param;
            });
        }
        else {
            validateRule.constraints = [];
        }
        if (ValidationTypes.isValidType(validType)) {
            if (validType === ValidationTypes.MAXVALUE) {
                const rule = constraintsToValidate[0];
                if (this.isDateString(value) || this.isDate(value) || this.isDateString(rule) || this.isDate(rule)) {
                    // 如果日期值不存在，则不判断大小
                    if (!value) {
                        return true;
                    }
                    if (value.indexOf('~') !== -1) {
                        // 不对日期区间进行校验
                        return true;
                    }
                    return this[ValidationTypes.MAX_DATE](DateUtil.parse(value), isMultLanguageField, new Date(constraintsToValidate[0]));
                }
                else {
                    return this[ValidationTypes.MAXVALUE](value, isMultLanguageField, constraintsToValidate[0]);
                }
            }
            else if (validType === ValidationTypes.MINVALUE) {
                // 如果是null或undefined，直接返回true
                if (constraintsToValidate[0] === null || constraintsToValidate[0] === undefined) {
                    return true;
                }
                if (this.isDateString(value) || this.isDate(value)) {
                    if (constraintsToValidate[0] === 0) {
                        return true;
                    }
                    return this[ValidationTypes.MIN_DATE](DateUtil.parse(value), isMultLanguageField, DateUtil.parse(constraintsToValidate[0]));
                }
                else if (this.isNumber(value)) {
                    return this[ValidationTypes.MIN](value, isMultLanguageField, constraintsToValidate[0]);
                }
            }
            else {
                return this[validType](value, isMultLanguageField, ...constraintsToValidate);
            }
        }
        else {
            if (typeof validateRule.eval === 'function') {
                const bindingPath = validateRule.bindingPath;
                const bindingPaths = bindingPath.split('/').filter(p => p);
                let fieldName = validateRule.field;
                if (bindingPaths.length !== 0) {
                    const prefix = bindingPaths.join('/');
                    fieldName = `${prefix}/${fieldName.split('.').filter(p => p).join('/')}`;
                }
                const options = { patch: { [fieldName]: value } };
                options.currentRows = [];
                const parentEntityListPaths = object && typeof object['getEntityListPath'] === 'function' && object.getEntityListPath();
                if (parentEntityListPaths.length === 4) {
                    const childrenList = parentEntityListPaths.slice(1, 3).reverse();
                    options.currentRows.push({ bindingPath: childrenList[1], primaryValue: childrenList[0].split(':')[1] });
                }
                if (currentRowId) {
                    if (validateRule.bindingPath.split('/').filter(p => p).length !== 0) {
                        const primaryValue = object && typeof object['getMainEntityPrimaryValue'] === 'function' && object.getMainEntityPrimaryValue();
                        options.currentRows.push({ bindingPath: '/', primaryValue: primaryValue });
                    }
                    options.currentRow = { bindingPath: validateRule.bindingPath, primaryValue: currentRowId };
                }
                else {
                    const primaryValue = object && typeof object['getMainEntityPrimaryValue'] === 'function' && object.getMainEntityPrimaryValue();
                    options.currentRows.push({ bindingPath: '/', primaryValue: primaryValue });
                }
                const result = validateRule.eval(options);
                if (validateRule.type === "require" /* Require */) {
                    const isValid = this.required(value, isMultLanguageField);
                    if (result) {
                        return isValid;
                    }
                    else {
                        return true;
                    }
                }
                else {
                    return result;
                }
            }
        }
        return true;
    }
    buildErrors(errors) {
        const msg = new Set(ValidationUtils.createDetailedErrorMessage(errors));
        const newMsg = [];
        msg.forEach(v => {
            newMsg.push(v);
        });
        return {
            isValid: errors.length === 0,
            errors,
            message: newMsg.join('')
        };
    }
    /** 自定义验证 */
    customValidation(value, comparison) {
        return comparison;
    }
    isEmptyValue(value) {
        const result = value === '' || value === null || value === undefined
            || value === '0001-01-01' || value === '0001-01-01 00:00:00' || value === '0001-01-01T00:00:00';
        return result;
    }
    /** 必填项 */
    required(value, isMultLanguageField) {
        if (isMultLanguageField) {
            const currentLanguage = TranslateService.getCurrentLanguage();
            if (Object.keys(value).length < 1) {
                return false;
            }
            // 如果能够获取到当前语言，那么当前语言对应的输入不能为空
            if (currentLanguage) {
                return !!value[currentLanguage];
            }
            // 如果当前语言为空，那么必填要求至少有一个输入
            // const allEmpty = Object.values(value).every((v: any) => !v || v.length < 1); // .filter((v: any) => !v || v.length < 1);
            // if (allEmpty) {
            //   return false;
            // }
            return true;
        }
        if (typeof value === 'object' && value !== null) {
            if (!Object.keys(value).length) {
                return false;
            }
            value = Object.values(value)[0];
        }
        // tslint:disable: max-line-length
        return value !== '' && value !== null && value !== undefined
            && value !== '0001-01-01' && value !== '0001-01-01 00:00:00' && value !== '0001-01-01T00:00:00';
    }
    /** 判断两个值是否相等 */
    equals(value, comparison) {
        return value === comparison;
    }
    /**
     * 检查 value 是否不等于参照值
     * @param value 要检查的值
     * @param comparison 对比参照值
     */
    notEquals(value, comparison) {
        return value !== comparison;
    }
    /**
     * 判断value 是否为数字
     * @param value 要检查的值
     * @param options 验证选项
     */
    isNumber(value, options = {}) {
        if (value === Infinity || value === -Infinity) {
            return options.allowInfinity;
        }
        if (Number.isNaN(value)) {
            return options.allowNaN;
        }
        return Number.isFinite(value);
    }
    /** 判断value是否为整数 */
    isInt(value) {
        return Number.isInteger(value);
    }
    /** 是否为浮点类型 */
    isFloat(value) {
        if (this.isNumber(value) || this.isNumberString(value)) {
            return this.validatorJs.isFloat(value);
        }
        return false;
    }
    /**
     * 检查给定的value 是否布尔值
     */
    isBoolean(value) {
        return value instanceof Boolean || typeof value === 'boolean';
    }
    /**
     * 检查给定的value 是否为字符串
     */
    isString(value) {
        return value instanceof String || typeof value === 'string';
    }
    /**
     * 检查给定的value 是否为日期
     */
    isDate(value) {
        return value instanceof Date && !isNaN(value.getTime());
    }
    /**
     * 检查给定的value 是否为日期字符串
     */
    isDateString(value) {
        const regex = /\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])(T|\s?)?(([0-2]\d:[0-5]\d)?(:[0-5]\d(?:\.\d+)))?(?:Z|\+[0-2]\d(?:\:[0-5]\d)?)?/g;
        return this.isString(value) && regex.test(value) && this.validatorJs.toDate(value);
    }
    /** 判断value 的长度是否在允许的最小值 和最大值之间 */
    length(value, min, max, isMultLanguageField) {
        return typeof value === 'string' && this.validatorJs.isLength(value, min, max);
    }
    /**
     * 检查给定的value的长度是否符合设定的最小值
     * @param value 待检查的字符串
     * @param min 最小长度
     */
    minLength(value, isMultLanguageField, min) {
        if (isMultLanguageField) {
            // const currentLanguage = TranslateService.getCurrentLanguage();
            if (typeof value === 'object') {
                const hasInvalidLangs = Object.values(value).filter((v) => v && v.length < min);
                if (hasInvalidLangs && hasInvalidLangs.length > 0) {
                    return false;
                }
            }
            // if (currentLanguage) {
            //   return value[currentLanguage] ? value[currentLanguage].length > min : true;
            // }
            // 如果无法获取当前语言，则只要有一种语言的输入长度大于最小长度即可。
            // const hasValidLangs = Object.values(value).filter((v: any) => v && v.length > min);
            // if (hasValidLangs.length > 0) {
            //   return true;
            // }
            // return false;
            return true;
        }
        if (value && typeof value !== 'string') {
            value = value.toString();
        }
        return !value || (typeof value === 'string' && this.length(value, min));
    }
    /**
     * 检查给定的value的长度是否符合设定的最大值
     * @param value 待检查的字符串
     * @param max 最大长度
     */
    maxLength(value, isMultLanguageField, max) {
        if (isMultLanguageField) {
            // const currentLanguage = TranslateService.getCurrentLanguage();
            // if (currentLanguage) {
            //   return value[currentLanguage] ? value[currentLanguage].length < max : true;
            // }
            if (typeof value === 'object') {
                const hasInvalidLangs = Object.values(value).filter((v) => v && v.length > max);
                if (hasInvalidLangs.length > 0) {
                    return false;
                }
            }
            return true;
        }
        if (typeof value === 'object') {
            for (const key in value) {
                if (value.hasOwnProperty(key)) {
                    const element = value[key];
                    if (typeof element === 'string' && !this.length(value[key], 0, max)) {
                        return false;
                    }
                }
            }
            return true;
        }
        if (value && typeof value !== 'string') {
            value = value.toString();
        }
        return !value || (typeof value === 'string' && this.length(value, 0, max));
    }
    /** 检查value的值是否在 最大值与最小值之间 */
    range(value, isMultLanguageField, min, max) {
        return typeof value === 'number' && this.isNumber(min) && this.isNumber(max) && value >= min && value <= max;
    }
    /**
     * 日期类型的值是否在某个区间
     * @param value value
     * @param min 最小值
     * @param max 最大值
     */
    dateRange(value, isMultLanguageField, rule, type) {
        // 2010~2020|04~05|03 11:00:00~05 12:00:00
        if (!value) {
            return true;
        }
        if (type === 'maxValue' || type === 'maxDate') {
            if (this.isYearRange(value) || this.isMonthOrDayRange(value)) {
                return this.maxValue(parseInt(this.getRangeValue(value, 1)), isMultLanguageField, parseInt(rule.split(' ')[0]));
            }
            else if (this.isDayTimeRange(value)) {
                return true;
            }
        }
        else if (type === 'minValue' || type === 'minDate') {
            if (this.isYearRange(value) || this.isMonthOrDayRange(value)) {
                return this.maxValue(parseInt(this.getRangeValue(value, 0)), isMultLanguageField, parseInt(rule.split(' ')[0]));
            }
            else if (this.isDayTimeRange(value)) {
                return true;
            }
        }
        return false;
    }
    getRangeValue(value, position, splitor = '~') {
        return value.split(splitor)[position];
    }
    isDateRange(value) {
        if (typeof value !== 'string') {
            value = value.toString();
        }
        return /(\d{4}|\d{2})/.test(value);
    }
    /**
     * 是否年度区间
     * @param value value
     */
    isYearRange(value) {
        if (typeof value !== 'string') {
            value = value.toString();
        }
        return /^\d{4}~\d{4}$/.test(value);
    }
    /**
     * 是否为年月区间
     * @param value value
     */
    isYearMonthRange(value) {
        if (typeof value !== 'string') {
            value = value.toString();
        }
        return /^\d{4}-\d{2}~\d{4}-\d{2}$/.test(value);
    }
    /**
     * 是否为月或天的区间
     * @param value value
     */
    isMonthOrDayRange(value) {
        if (typeof value !== 'string') {
            value = value.toString();
        }
        return /^[0|1|2|3]\d{1}~[0|1|2|3]\d{1}$/.test(value);
    }
    /**
     * 是否为天+时间的区间
     * @param value value
     */
    isDayTimeRange(value) {
        if (typeof value !== 'string') {
            value = value.toString();
        }
        return /^[0|1|2|3]\d{1} \d{2}:\d{2}:\d{2}~[0|1|2|3]\d{1} \d{2}:\d{2}:\d{2}$/.test(value);
    }
    /**
     * Checks if the first number is greater than second.
     */
    min(num, isMultLanguageField, min) {
        return typeof num === 'number' && typeof min === 'number' && num >= min;
    }
    /**
     * 最小值验证
     */
    minValue(num, isMultLanguageField, min) {
        // 如果值不存在，则不进行最小值的判断
        if (num === null || num === undefined) {
            return true;
        }
        // 按照大数处理
        if ((typeof num === 'string' && num.match(/^(-?\d+)(\.\d+)?$/g)) || (typeof min === 'string' && min.match(/^(-?\d+)(\.\d+)?$/g))) {
            const value = new BigNumber(num);
            const maxValue = new BigNumber(min);
            return value.isGreaterThanOrEqualTo(maxValue);
        }
        return typeof num === 'number' && typeof min === 'number' && num >= min;
    }
    /**
     * Checks if the first number is less than second.
     */
    max(num, isMultLanguageField, max) {
        // 如果值不存在，则不进行最小值的判断
        if (num === null || num === undefined) {
            return true;
        }
        return typeof num === 'number' && typeof max === 'number' && num <= max;
    }
    /**
     * 最大值验证
     */
    maxValue(num, isMultLanguageField, max) {
        // 如果值不存在，则不进行最小值的判断
        if (num === null || num === undefined) {
            return true;
        }
        // 按照大数处理
        if ((typeof num === 'string' && num.match(/^(-?\d+)(\.\d+)?$/g)) || (typeof max === 'string' && max.match(/^(-?\d+)(\.\d+)?$/g))) {
            const value = new BigNumber(num);
            const maxValue = new BigNumber(max);
            return value.isLessThanOrEqualTo(maxValue);
        }
        return typeof num === 'number' && typeof max === 'number' && num <= max;
    }
    /**
     * Checks if the value is a date that's after the specified date.
     */
    minDate(date, isMultLanguageField, minDate) {
        if (!date) {
            return true;
        }
        return date && date.getTime() >= minDate.getTime();
    }
    /**
     * Checks if the value is a date that's before the specified date.
     */
    maxDate(date, isMultLanguageField, maxDate) {
        // 如果值不存在，则不进行最小值的判断
        if (date === null || date === undefined) {
            return true;
        }
        return date && date.getTime() <= maxDate.getTime();
    }
    /**
     * Checks if a string is a boolean.
     * If given value is not a string, then it returns false.
     */
    isBooleanString(value) {
        return typeof value === 'string' && this.validatorJs.isBoolean(value);
    }
    /**
     * Checks if the string is numeric.
     * If given value is not a string, then it returns false.
     */
    isNumberString(value) {
        return typeof value === 'string' && this.validatorJs.isNumeric(value);
    }
    /**
     * Checks if the string contains the seed.
     * If given value is not a string, then it returns false.
     */
    contains(value, isMultLanguageField, seed) {
        return typeof value === 'string' && this.validatorJs.contains(value, seed);
    }
    /**
     * Checks if the string does not contain the seed.
     * If given value is not a string, then it returns false.
     */
    notContains(value, isMultLanguageField, seed) {
        return typeof value === 'string' && !this.validatorJs.contains(value, seed);
    }
    /**
     * Checks if the string is an email.
     * If given value is not a string, then it returns false.
     */
    isEmail(value) {
        return typeof value === 'string' && this.validatorJs.isEmail(value);
    }
    /**
     * Checks if the string is valid JSON (note: uses JSON.parse).
     * If given value is not a string, then it returns false.
     */
    isJSON(value) {
        return typeof value === 'string' && this.validatorJs.isJSON(value);
    }
    /**
     * Checks if the string is lowercase.
     * If given value is not a string, then it returns false.
     */
    isLowercase(value) {
        return typeof value === 'string' && this.validatorJs.isLowercase(value);
    }
    /**
     * Checks if the string is uppercase.
     * If given value is not a string, then it returns false.
     */
    isUppercase(value) {
        return typeof value === 'string' && this.validatorJs.isUppercase(value);
    }
    /**
     * 验证字符串是否包含非法字符
     * @param value 验证的字符串
     * @param someChars 非法字符。如：#￥%@$
     */
    exclude(value, isMultLanguageField, someChars) {
        const arrChar = someChars.split('');
        let counter = 0;
        arrChar.forEach(val => {
            if (this.contains(value, isMultLanguageField, val)) {
                counter++;
            }
        });
        return counter === 0;
    }
    /**
     * 自定义正则验证
     * @param value 待验证的字符串
     * @param pattern 正则表达式
     */
    matches(value, isMultLanguageField, pattern) {
        value = (value === null || value === undefined) ? '' : value.toString();
        if (value === '') {
            return true;
        }
        return this.validatorJs.matches(value, pattern);
    }
}

/**
 * 实体集合列表
 */
class EntityList {
    // #endregion
    /**
     * @param data JSON数据集合
     * @param type 集合中的实体类型
     */
    constructor(data, type) {
        this.__type__ = 'EntityList';
        // #region 私有属性
        this.originalData = [];
        /**
         * 已废弃：请勿使用
         */
        this.listChanged = new Subject();
        /**
         * 已废弃：请勿使用
         */
        this.changeSet = new ChangeSet();
        /**
         * 已废弃：请勿使用
         */
        this.validator = new Validator();
        // #endregion
        // #region 公有属性
        /**
         * 集合改变时触发(新增、行记录修改、删除)
         * @event
         */
        this.onListChanged = this.listChanged.asObservable();
        this.clear();
        if (data) {
            // this.loadEntities(data);
            data.forEach(item => {
                this.initEntity(EntityFactory$1(type, item));
            });
        }
    }
    /**
     * 获取项集合
     */
    get items() {
        return this.rawData;
    }
    /**
     * 列表变更集
     */
    get changes() {
        return this.changeSet.changes;
    }
    /**
     * 迭代器
     */
    *[Symbol.iterator]() {
        yield* this.items;
    }
    // #region 公有方法
    /** 加载实体列表 */
    loadEntities(entities) {
        this.clear();
        entities.forEach(entity => {
            this.initEntity(entity);
        });
        // 发送Load变更
        const changeItem = {
            path: [],
            value: entities,
            preValue: undefined,
            type: ModifyType.Load,
            target: this
        };
        this.setChanges(changeItem);
    }
    /**
     * 清空
     */
    clear() {
        this.rawData = [];
        this.originalData = [];
    }
    /**
     * 添加实体对象到集合中，并返回新加的对象
     * @param entity 实体对象
     * @param isCloned 克隆
     */
    appendNew(entity, isCloned = false) {
        const newEntity = this.initEntity(entity, true);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Add
        };
        if (isCloned === true) {
            changeItem.type = ModifyType.Clone;
        }
        this.setChanges(changeItem);
        return newEntity;
    }
    /**
     * 在指定位置插入实体
     * @param entity 实体
     * @param position 插入位置
     */
    insert(entity, position) {
        const newEntity = this.initEntity(entity, true);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Insert,
            position: position,
        };
        this.setChanges(changeItem);
        return newEntity;
    }
    /**
     * 追加实体
     */
    appendEntity(entity) {
        const newEntity = this.initEntity(entity, true);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Add
        };
        this.setChanges(changeItem);
    }
    /**
     * 批量追加实体
     */
    appendEntities(entities) {
        const newEntites = entities.map((entity) => {
            return this.initEntity(entity, true);
        });
        const changeItem = {
            path: [],
            value: newEntites,
            preValue: undefined,
            type: ModifyType.Add
        };
        this.setChanges(changeItem);
    }
    /**
     * 删除指定主键ID 的实体对象，返回布尔，true 删除成功，false 删除失败
     * @param primaryId 主键ID
     */
    remove(primaryId) {
        const total = this.count();
        const indexToRemove = this.rawData.findIndex((entity) => {
            return entity.primaryValue === primaryId;
        });
        if (indexToRemove === -1) {
            return false;
        }
        const entityToRemove = this.rawData[indexToRemove];
        this.rawData.splice(indexToRemove, 1);
        // 删除变更
        const changeItem = {
            path: [],
            value: { [entityToRemove.primaryProperty.dataField]: primaryId },
            preValue: undefined,
            type: ModifyType.Remove
        };
        this.updateIndex(total);
        this.setChanges(changeItem);
        return true;
    }
    /**
     * 从集合中获取指定ID值的实体对象
     * @param id 主键值
     */
    get(id) {
        return this.items.find(item => {
            return item.primaryValue === id;
        });
    }
    /**
     * 将变更记录添加到集合变更集中
     * @param value 变更记录
     */
    setChanges(modinfo) {
        // 向app层发送的变更
        this.listChanged.next(modinfo);
        // 构造向changeSet中添加的chagne
        const change = Object.assign({}, modinfo);
        if ((modinfo.type === ModifyType.Add || modinfo.type === ModifyType.Insert || modinfo.type === ModifyType.Clone) && modinfo.value[0] instanceof Entity) {
            change.value = [modinfo.value[0].data];
        }
        this.changeSet.append(change);
    }
    /** 集合总记录数 */
    count() {
        return this.items.length;
    }
    /**
     * 获取实体对象的索引值
     */
    indexOf(entity) {
        return this.items.indexOf(entity);
    }
    /**
     * 计算集合中某个属性的总和
     * @param propertyName 属性名称
     */
    sum(propertyName) {
        if (this.count() === 0) {
            return 0;
        }
        return this.items.reduce((val, curr) => {
            return val + curr[propertyName];
        }, 0);
    }
    /**
     * 集合数据验证
     */
    validate() {
        const propertyName = this.getPropertyName();
        return from(this.validator.validate(this[PARENT_CLASS], propertyName));
    }
    /**
     * 已废弃：请使用toJSON方法代替
     * @deprecated
     */
    toJson() {
        return this.rawData;
    }
    /**
     * 转换为JSON格式
     */
    toJSON() {
        const result = [];
        this.items.forEach((entity) => {
            result.push(entity.toJSON());
        });
        return result;
    }
    toArray() {
        return this.items;
    }
    // #endregion
    // #region 私有方法
    /**
     * 实体初始化
     * @param entity 实体
     */
    initEntity(entity, isNewEntity = false) {
        entity[PARENT_CLASS] = this;
        entity[PARENT_PATH] = this[PARENT_PATH];
        entity.onValueChanged.subscribe((v) => {
            const path = v.path;
            const value = v.value;
            const preValue = v.preValue;
            const operator = v.type;
            const subChanges = { path, value, preValue, type: operator };
            if (v.changeSetValue !== undefined) {
                subChanges['changeSetValue'] = v.changeSetValue;
            }
            this.setChanges(subChanges);
        });
        // TODO: 添加数据验证逻辑代码
        const newLength = this.rawData.push(entity);
        this[newLength - 1] = entity;
        if (!isNewEntity) {
            this.originalData.push(entity.toJSON());
        }
        return entity;
    }
    /**
     * 更新索引
     * @param total 总记录数
     */
    updateIndex(total) {
        for (let i = 0; i < total; i++) {
            delete this[i];
        }
        this.rawData.forEach((entity, index) => {
            this[index] = entity;
        });
    }
    /**
     * 获取属性名称
     */
    getPropertyName() {
        const path = this[PARENT_PATH];
        if (path && path.length) {
            const name = path[path.length - 1];
            return name;
        }
        return undefined;
    }
}

// export type ClassType = new (...args: any[]) => any;
const BigNumberType = 'BigNumber';
var DataChangeType;
(function (DataChangeType) {
    DataChangeType[DataChangeType["Add"] = 0] = "Add";
    DataChangeType[DataChangeType["Delete"] = 1] = "Delete";
})(DataChangeType || (DataChangeType = {}));
var HttpMethod;
(function (HttpMethod) {
    HttpMethod["GET"] = "GET";
    HttpMethod["POST"] = "POST";
    HttpMethod["PUT"] = "PUT";
    HttpMethod["DELETE"] = "DELETE";
})(HttpMethod || (HttpMethod = {}));
/**
 * 后端消息
 */
// tslint:disable-next-line: no-namespace
var BackEndMessage;
(function (BackEndMessage) {
    /**
     * 消息级别
     */
    let Level;
    (function (Level) {
        Level["Error"] = "Error";
        Level["Info"] = "Info";
        Level["Warning"] = "Warning";
    })(Level = BackEndMessage.Level || (BackEndMessage.Level = {}));
    /**
     * 消息
     * @description 接口执行成功，但有info/warning级别的消息
     */
    class Message {
        constructor(bizMessages, context) {
            this.bizMessages = bizMessages;
            this.context = context;
        }
    }
    BackEndMessage.Message = Message;
})(BackEndMessage || (BackEndMessage = {}));
var RunMode;
(function (RunMode) {
    RunMode["compatible"] = "compatible";
    RunMode["highSpeed"] = "highSpeed";
})(RunMode || (RunMode = {}));
/**
 * 控制器运行模式，compatible | highSpeed
 */
const DEVKIT_RUN_MODE = new InjectionToken('@farris/devkit_run_mode');
/**
 * 组件类型
 */
var ComponentType;
(function (ComponentType) {
    ComponentType["farrisDataGridComponent"] = "farrisDatagridComponent";
    ComponentType["farrisTreeTalbeComponent"] = "farrisTreeTalbeComponent";
    ComponentType["primengTreeComponent"] = "primengTreeComponent";
    ComponentType["kendoGridComponent"] = "kendoGridComponent";
})(ComponentType || (ComponentType = {}));
var DestroyOpportunity;
(function (DestroyOpportunity) {
    DestroyOpportunity["AppContextDestroy"] = "AppContextDestroy";
    DestroyOpportunity["MenuOrAppClose"] = "MenuOrAppClose";
})(DestroyOpportunity || (DestroyOpportunity = {}));

class UserSettingsService {
    static setUserSettings(userSettings) {
        this.userSettings = userSettings;
        this.timeZone = undefined;
        this.timeZoneOffset = undefined;
    }
    /**
     * 获取用户配置的时区
     */
    static getTimeZone() {
        if (this.timeZone !== undefined) {
            return this.timeZone;
        }
        const timeZone = this.userSettings && this.userSettings.timeZone || null;
        this.timeZone = timeZone;
        return timeZone;
    }
    static getTimeZoneOffset() {
        if (this.timeZoneOffset !== undefined) {
            return this.timeZoneOffset;
        }
        const timeZoneOffset = this.userSettings && this.userSettings.timeZoneOffset || null;
        this.timeZoneOffset = timeZoneOffset;
        return timeZoneOffset;
    }
}
UserSettingsService.userSettings = null;
UserSettingsService.timeZone = undefined;
UserSettingsService.timeZoneOffset = undefined;

//import { timezones } from './time_zones';
//import { Timezone } from './types';
class ZonedTime {
    /**
     * 将指定时区的时间转换为UTC时区时间（带时区）
     * @param date 时间
     * @param timeZone 时区
     */
    // public static zonedTimeToUtc(date: Date | string | number, timeZone: string): string {
    //   timeZone = this.getStandardTimezoneName(timeZone);
    //   return moment.tz(date, timeZone).utc().format();
    // }
    /**
     * 将带时区的时间转换为指定时区的时间字符串
     * @param date 时间
     * @param timeZone 时区
     * @param format 时间格式
     */
    // public static zonedTimeToSpecialZoneTimeString(date: Date | string | number, timeZone: string, format: string = 'YYYY-MM-DD HH:mm:ss.SSS'): string {
    //   timeZone = this.getStandardTimezoneName(timeZone);
    //   return moment(date).tz(timeZone).format(format);
    // }
    /**
     * 获取标准时区名称
     * @param tz 时区
     */
    // public static getStandardTimezoneName(tz: string) {
    //   let momentZone = moment.tz.zone(tz);
    //   let standardTimezone = tz;
    //   if (!momentZone) {
    //     const timezone = timezones.find((item: Timezone) => item.value === tz || item.utc.includes(tz));
    //     standardTimezone = timezone && timezone.utc[0] || null;
    //   }
    //   return standardTimezone;
    // }
    static zonedTimeToSpecialTimeZoneOffsetTimeString(date, offset = 0, format$$1 = 'YYYY-MM-DD HH:mm:ss.SSS') {
        const utcTime = moment(date).utc();
        const offsetMinutes = offset * 60;
        const result = utcTime.add(offsetMinutes, 'm');
        return result.format(format$$1);
    }
    static timeZoneOffsetTimeToUtcTimeString(date, offset, format$$1 = 'YYYY-MM-DD HH:mm:ss.SSS') {
        return moment(date).utcOffset(offset, true).toISOString();
    }
}

/**
 * 路由参数服务
 */
class RouterParamService {
    /**
     * 获取参数
     */
    getParams(url) {
        const allParams = this.getAllParams();
        return allParams[url] || {};
    }
    /**
     * 设置参数
     */
    setParams(url, params) {
        const allParams = this.getAllParams();
        allParams[url] = params;
        this.setAllParams(allParams);
    }
    /**
     * 清空参数
     */
    clearParams() {
        throw new Error('Not Implemented');
    }
    /**
     * 获取全部参数
     */
    getAllParams() {
        const allParamsJson = window.sessionStorage.getItem('ROUTER_PARAMS') || '{}';
        const allParams = JSON.parse(allParamsJson);
        return allParams;
    }
    /**
     * 设置所有的参数
     */
    setAllParams(allParams) {
        allParams = allParams || {};
        const allParamsJson = JSON.stringify(allParams);
        window.sessionStorage.setItem('ROUTER_PARAMS', allParamsJson);
    }
    /**
     * 清空所有参数
     */
    clearAllParams() {
        window.sessionStorage.setItem('ROUTER_PARAMS', '{}');
    }
}
RouterParamService.decorators = [
    { type: Injectable }
];

/**
 * 变更相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 绑定数据变更类型
 */
var ChangeType;
(function (ChangeType) {
    ChangeType["Update"] = "Update";
    ChangeType["Load"] = "Load";
    ChangeType["Append"] = "Append";
    ChangeType["Remove"] = "Remove";
    ChangeType["Swap"] = "Swap";
    ChangeType["SelectionChanged"] = "SelectionChanged";
    ChangeType["ValueChanged"] = "ValueChanged";
    ChangeType["UpdateErrors"] = "UpdateErrors";
    ChangeType["GlobalSelectionChanged"] = "GlobalSelectionChanged";
    /**
     * 分页信息变化
     */
    ChangeType["PaginationInfoChange"] = "PaginationInfoChange";
})(ChangeType || (ChangeType = {}));
/**
 * 视图变更类型
 */
var ViewChangeType;
(function (ViewChangeType) {
    ViewChangeType[ViewChangeType["ValueChanged"] = 0] = "ValueChanged";
})(ViewChangeType || (ViewChangeType = {}));

/**
 * 绑定属性相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 属性类型
 */
var BindingPropertyType;
(function (BindingPropertyType) {
    /**
     * 简单类型
     */
    BindingPropertyType["Plain"] = "Plain";
    /**
     * 对象类型
     */
    BindingPropertyType["Object"] = "Object";
    /**
     * 列表类型
     */
    BindingPropertyType["List"] = "List";
    /**
     * 动态类型
     */
    BindingPropertyType["Dynamic"] = "Dynamic";
})(BindingPropertyType || (BindingPropertyType = {}));

/**
 * 属性工具类
 */
class PropertyUtil {
    /**
     * 获取实体上的属性集合，并将他们转换成BindingProperty集合
     * @param  entityType 实体类型
     * @returns 绑定属性集合
     */
    static getProperties(entityType) {
        const properties = [];
        // Plain
        const ngFieldProperties = FieldMetadataUtil.getNgFields(entityType);
        Object.keys(ngFieldProperties).forEach((propertyName) => {
            const ngFieldProperty = ngFieldProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Plain,
                isPrimaryKey: ngFieldProperty.primary,
                isForeignKey: ngFieldProperty.foreign,
                enableMultiLangInput: ngFieldProperty.enableMultiLangInput
            });
        });
        // Object
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propertyName) => {
            const ngObjectProperty = ngObjectProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Object,
                entityType: ngObjectProperty.type
            });
        });
        // List
        const ngListProperties = FieldMetadataUtil.getNgList(entityType);
        Object.keys(ngListProperties).forEach((propertyName) => {
            const ngListProperty = ngListProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.List,
                entityType: ngListProperty.type
            });
        });
        // Dynamics
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propertyName) => {
            const ngDynamicProperty = ngDynamicProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Dynamic,
                entityType: ngDynamicProperty.type
            });
        });
        return properties;
    }
    static getDynamicProperties(dynamicData) {
        const properties = [];
        Object.keys(dynamicData).forEach((propertyName) => {
            if (dynamicData.hasOwnProperty(propertyName)) {
                if (dynamicData[propertyName] instanceof Object) {
                    properties.push({
                        name: propertyName,
                        type: BindingPropertyType.Dynamic,
                        entityType: null
                    });
                }
                else {
                    properties.push({
                        name: propertyName,
                        type: BindingPropertyType.Plain,
                        isPrimaryKey: false,
                        isForeignKey: false
                    });
                }
            }
        });
        return properties;
    }
    /**
     * 根据属性名获取属性
     */
    static getPropertyByName(properties, propertyName) {
        const targetProperty = properties.find((property) => {
            return property.name === propertyName;
        });
        return targetProperty;
    }
    /**
     * 获取实体主键名
     * @param properties 属性集合
     * @returns 主键名
     */
    static getPrimaryKey(properties) {
        // 实体必须有主键，如果没有主键在构造实体的时候就已经报错，这里不需要再进行检查
        const primaryProperty = properties.find((property) => {
            return property.isPrimaryKey === true;
        });
        return primaryProperty ? primaryProperty.name : '';
    }
}

/**
 * BindingListTypeFactory
 */
class BindingListTypeFactory {
    static create(bindingProperties) {
        const bindingListType = this.getType(bindingProperties);
        const bindingList = new bindingListType(bindingProperties);
        return bindingList;
    }
    /**
     * 创建BindingList模板类
     * @param bindingProperties
     * @returns
     */
    static createType(bindingProperties) {
        const bindingListType = class BindingListType extends BindingList {
            constructor(properties) {
                super(properties);
            }
        };
        const bindingListTypePrototype = bindingListType.prototype;
        this.extendProperties(bindingListTypePrototype, bindingProperties);
        return bindingListType;
    }
    /**
     * 扩展BindingList模板类属性
     * @param bindingListPrototype bindingList原型
     * @param bindingProperties 属性数组
     */
    static extendProperties(bindingListPrototype, bindingProperties) {
        bindingProperties.forEach((bindingProperty) => {
            const propertyName = bindingProperty.name;
            Object.defineProperty(bindingListPrototype, propertyName, {
                get: function () {
                    return this.currentItem[propertyName];
                }
            });
        });
    }
    /**
     * 获取缓存的bindingList模板类
     * @param bindingProperties bindingList属性
     * @returns
     */
    static getType(bindingProperties) {
        if (this.provider.has(bindingProperties)) {
            return this.provider.get(bindingProperties);
        }
        const bindingListType = this.createType(bindingProperties);
        this.provider.set(bindingProperties, bindingListType);
        return bindingListType;
    }
}
BindingListTypeFactory.provider = new Map();

/**
 * 绑定列表工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingList工厂用于创建一个空的BindingList对象，并将当前行的属性影射到BindingList对象上。
 *
 * **示例代码**
 * ```ts
 * const deptProperties: BindingProperty[] = PropertyUtil.getProperties(DeptEntity);
 * const deptList = BindingListFactory.create(deptProperties);
 * ```
 */
class BindingListFactory {
    /**
     * 创建BindingList实例，并扩展其属性
     * @param bindingProperties 绑定属性集合
     */
    static create(bindingProperties) {
        // const bindingList = new BindingList(bindingProperties);
        // this.extendProperties(bindingList, bindingProperties);
        const bindingList = BindingListTypeFactory.create(bindingProperties);
        return bindingList;
    }
    /**
     * 扩展BindingList属性，将当前行上的属性映射到列表上
     * @param bindingList       要扩展的绑定列表
     * @param bindingProperties 绑定属性集合
     */
    static extendProperties(bindingList, bindingProperties) {
        bindingProperties.forEach((bindingProperty) => {
            const propertyName = bindingProperty.name;
            Object.defineProperty(bindingList, propertyName, {
                get: () => {
                    return bindingList.currentItem[propertyName];
                }
            });
        });
    }
}

// import { BindingObjectFactory } from './binding_object_factory';
/**
 * BindingObjectTypeFactory
 */
class BindingObjectTypeFactory {
    /**
     * 创建BindingObject
     * @param properties
     * @returns
     */
    static create(properties) {
        const bindingObjectType = this.getType(properties);
        return new bindingObjectType();
    }
    /**
     * 创建原型类型
     * @param properties
     * @returns
     */
    static createType(properties) {
        // 继承原绑定对象所有属性
        const bindingObjectType = class BindingObjectType extends BaseBindingObject {
            constructor() {
                super();
                // this.innerValues = ImmutableMap(Object.assign({}, data));
            }
        };
        // 获取主键
        const primaryKey = PropertyUtil.getPrimaryKey(properties);
        // 设置主键
        bindingObjectType.prototype.primaryKey = primaryKey;
        bindingObjectType.prototype.properties = properties;
        // 将属性扩展到原型对象上
        this.extendProperties(bindingObjectType.prototype, properties);
        return bindingObjectType;
    }
    /**
     * 扩展原型属性
     * @param typePrototype
     * @param properties
     */
    static extendProperties(typePrototype, properties) {
        // 扩展BindingObject属性
        properties.forEach((property) => {
            if (property.type === BindingPropertyType.List) {
                this.extendListProperty(typePrototype, property);
            }
            else if (property.type === BindingPropertyType.Object) {
                this.extendObjectProperty(typePrototype, property);
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                this.extendDynamicObjectProperty(typePrototype, property);
            }
            else {
                this.extendPlainProperty(typePrototype, property);
            }
        });
    }
    /**
     * 扩展原型列表属性
     * @param typePrototype
     * @param property
     */
    static extendListProperty(typePrototype, property) {
        const propertyName = property.name;
        const childListProperties = PropertyUtil.getProperties(property.entityType);
        const key = `_${propertyName}_`;
        // 将子的BindingList实例赋值给当前属性
        Object.defineProperty(typePrototype, propertyName, {
            get: function () {
                let bindingList = this[key];
                if (!bindingList) {
                    bindingList = BindingListFactory.create(childListProperties);
                    this[key] = bindingList;
                    // 加载数据
                    const data = this.getValue(propertyName);
                    if (data) {
                        const bindingObjects = data.map((item) => {
                            const bindingObject = BindingObjectTypeFactory.create(childListProperties);
                            return bindingObject;
                        });
                        bindingList.load(bindingObjects);
                    }
                    // 指定子List的parent、监听子List的changes事件
                    bindingList.parent = this;
                    bindingList.changes.subscribe((change) => {
                        change.path.unshift(propertyName);
                        change.isBindingListTransmited = true;
                        this.changes.next(change);
                    });
                }
                return bindingList;
            },
            set: function (bindingList) {
                this[key] = bindingList;
            }
        });
    }
    /**
     * 扩展原型对象属性
     * @param typePrototype
     * @param property
     */
    static extendObjectProperty(typePrototype, property) {
        const propertyName = property.name;
        const childObjectProperties = PropertyUtil.getProperties(property.entityType);
        const key = `_${propertyName}_`;
        Object.defineProperty(typePrototype, propertyName, {
            get: function () {
                let bindingObject = this[key];
                if (!bindingObject) {
                    const value = this.getValue(propertyName) || {};
                    bindingObject = BindingObjectTypeFactory.create(childObjectProperties);
                    this[key] = bindingObject;
                    // 指定子Object的parent、监听子Object的changes事件
                    bindingObject.parent = this;
                    bindingObject.changes.subscribe((change) => {
                        change.path.unshift(propertyName);
                        this.changes.next(change);
                    });
                }
                return bindingObject;
            },
            set: function (value) {
                this[key] = value;
            }
        });
    }
    /**
     * 扩展原型动态属性
     * @param typePrototype
     * @param property
     */
    static extendDynamicObjectProperty(typePrototype, property) {
        const propertyName = property.name;
        // Object.defineProperty(typePrototype, propertyName, {
        //   value: null
        // });
        typePrototype[propertyName] = null;
    }
    /**
     * 扩展原型简单属性
     * @param typePrototype
     * @param property
     */
    static extendPlainProperty(typePrototype, property) {
        const propertyName = property.name;
        Object.defineProperty(typePrototype, propertyName, {
            get: function () {
                if (property.enableMultiLangInput === true) {
                    let value = this.getValue(propertyName, false);
                    if (!value) {
                        value = this.getValue(propertyName, false);
                        const langCode = TranslateService.getCurrentLanguage();
                        return { [langCode]: value };
                    }
                    return value;
                }
                else {
                    const value = this.getValue(propertyName);
                    return value;
                }
            },
            set: function (value) {
                const oldValue = this.getValue(propertyName);
                if (value === oldValue) {
                    return;
                }
                this.setValue(propertyName, value, true, true);
            }
        });
    }
    /**
     * 获取缓存的bindingList模板类
     * @param properties bindingList属性
     * @returns
     */
    static getType(properties) {
        if (this.provider.has(properties)) {
            return this.provider.get(properties);
        }
        const bindingObjectType = this.createType(properties);
        this.provider.set(properties, bindingObjectType);
        return bindingObjectType;
    }
}
BindingObjectTypeFactory.provider = new Map();

/**
 * 绑定对象工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingObject工厂用于创建一个空的BindingObject对象，并对其属性进行扩展。
 *
 * **扩展属性处理**
 *
 * 对于要扩展的属性（BindingProperty）有三种处理：
 * - 普通属性：初始化为一个undefined，并包装get、set方法，通过set方法监听变更；
 * - 对象属性：初始化为一个空的BindingObject对象，并监听子对象的变更；
 * - 列表属性：初始化为一个空的BindingList对象，并监听子列表的变更；
 *
 * **示例代码**
 *
 * ```ts
 *  const empProperties = PropertyUtil.getProperties(EmpEntity);
 * const empBindingObject = BindingObjectFactory.create(properties);
 * ```
 */
class BindingObjectFactory {
    /**
     * 创建BindingObject实例
     * @param properties 要扩展的属性集合
     * @returns 带扩展属性的空BindingObject对象
     */
    static create(properties, fromEntity) {
        const bindingObjectType = BindingObjectTypeFactory.create(properties /*, data*/);
        bindingObjectType.fromEntity = fromEntity;
        return bindingObjectType;
    }
    static createDynamicBindingObject(data) {
        const properties = PropertyUtil.getDynamicProperties(data);
        const object = BindingObjectTypeFactory.create(properties /*, data*/); //new BindingObject(properties);
        this.extendProperties(object, properties);
        return object;
    }
    /**
     * 扩展属性绑定对象的属性
     * @param object     要扩展的绑定对象
     * @param properties 绑定属性集合
     */
    static extendProperties(object, properties) {
        // 扩展BindingObject属性
        properties.forEach((property) => {
            if (property.type === BindingPropertyType.List) {
                this.extendListProperty(object, property);
            }
            else if (property.type === BindingPropertyType.Object) {
                this.extendObjectProperty(object, property);
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                this.extendDynamicObjectProperty(object, property);
            }
            else {
                this.extendPlainProperty(object, property);
            }
        });
    }
    /**
     * 扩展列表类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 列表类型的绑定属性集合
     */
    static extendListProperty(object, property) {
        const propertyName = property.name;
        const childListProperties = PropertyUtil.getProperties(property.entityType);
        const childList = BindingListFactory.create(childListProperties);
        // 指定子List的parent、监听子List的changes事件
        childList.parent = object;
        childList.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            change.isBindingListTransmited = true;
            object.changes.next(change);
        });
        // 将子的BindingList实例赋值给当前属性
        Object.defineProperty(object, propertyName, {
            value: childList
        });
    }
    /**
     * 扩展对象类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 对象类型的绑定属性集合
     */
    static extendObjectProperty(object, property) {
        const propertyName = property.name;
        const childObjectProperties = PropertyUtil.getProperties(property.entityType);
        const childObject = this.create(childObjectProperties);
        // 指定子Object的parent、监听子Object的changes事件
        childObject.parent = object;
        childObject.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        Object.defineProperty(object, propertyName, {
            value: childObject
        });
    }
    static extendDynamicObjectProperty(object, property) {
        const propertyName = property.name;
        object[propertyName] = null;
    }
    static attachDynamicObjectProperty(object, propertyName, dynamicObject) {
        dynamicObject.parent = object;
        dynamicObject.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        Object.defineProperty(object, propertyName, {
            value: dynamicObject
        });
    }
    /**
     * 扩展简单类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 简单类型的绑定属性集合
     */
    static extendPlainProperty(object, property) {
        const propertyName = property.name;
        Object.defineProperty(object, propertyName, {
            get: () => {
                return object.getValue(propertyName);
            },
            set: (value) => {
                const oldValue = object.getValue(propertyName);
                if (value === oldValue) {
                    return;
                }
                object.setValue(propertyName, value, true, true);
            }
        });
    }
}

/**
 * ----------------------------------------
 * NgValidateForm
 * ----------------------------------------
 */
/**
 * 子表单装饰器名称
 */
const NG_VALIDATE_FORM = 'NgValidateForm';
/**
 * 表单装饰器工厂
 */
function NgValidateForm(options) {
    const decoratorFactory = makeDecorator(NG_VALIDATE_FORM, (obj) => obj);
    return decoratorFactory(options);
}
/**
 * ----------------------------------------
 * NgChildForm
 * ----------------------------------------
 */
/**
 * 子表单装饰器名称
 */
const NG_CHILD_FORM = 'NgChildForm';
/**
 * 子表单装饰器工厂
 */
const NgChildForm = makePropDecorator(NG_CHILD_FORM, (obj) => obj);
/**
 * ----------------------------------------
 * NgChildFormArray
 * ----------------------------------------
 */
/**
 * 子表单数组装饰器名称
 * @type {string}
 */
const NG_CHILD_FORM_ARRAY = 'NgChildFormArray';
/**
 * 子表单数组装饰器工厂
 */
const NgChildFormArray = makePropDecorator(NG_CHILD_FORM_ARRAY, (obj) => obj);
/**
 * ----------------------------------------
 * NgFormControl
 * ----------------------------------------
 */
/**
 * 表单控件装饰器名称
 * @type {string}
 */
const NG_FORM_CONTROL = 'NgFormControl';
/**
 * 表单控件装饰器工厂
 */
const NgFormControl = makePropDecorator(NG_FORM_CONTROL, (obj) => obj);

/**
 * 数据路径处理
 */
class BindingPathConverter {
    /**
     * (BindingPathString | BindingPathArray) => BindingPathArray
     * @param bindingPath BindingPath的字符串或者数组格式
     * @return BindingPath数组
     */
    static toBindingPathArray(bindingPath) {
        let bindingPathArray;
        if (typeof bindingPath === 'string') {
            bindingPathArray = bindingPath.split('/').filter((part) => {
                return part !== '';
            });
            return bindingPathArray;
        }
        else {
            bindingPathArray = bindingPath.concat([]);
        }
        return bindingPathArray;
    }
    /**
     * BindingPathArray => BindingPathString
     */
    static toBindingPathString(bindingPathArray) {
        return '/' + bindingPathArray.join('/');
    }
}

/**
 * BindingPath比较器
 */
class BindingPathComparer {
    /**
     * 是否相等
     */
    static isEqual(srcPath, dstPath) {
        const srcPathArray = BindingPathConverter.toBindingPathArray(srcPath);
        const dstPathArray = BindingPathConverter.toBindingPathArray(dstPath);
        const isEqual$$1 = srcPathArray.every((srcPathItem, srcPathIndex) => {
            return srcPathItem === dstPathArray[srcPathIndex];
        });
        return isEqual$$1;
    }
    /**
     * 是否是父路径
     */
    static isParent(childPath, parentPath) {
        const childPathArray = BindingPathConverter.toBindingPathArray(childPath);
        const parentPathArray = BindingPathConverter.toBindingPathArray(parentPath);
        // 长度差1个
        if (childPathArray.length !== parentPathArray.length + 1) {
            return;
        }
        return this.isAncestor(childPath, parentPath);
    }
    /**
     * 是否是祖先路径
     */
    static isAncestor(descendantPath, ancestorPath) {
        const descendantPathArray = BindingPathConverter.toBindingPathArray(descendantPath);
        const ancestorPathArray = BindingPathConverter.toBindingPathArray(ancestorPath);
        if (descendantPath.length <= ancestorPathArray.length) {
            return false;
        }
        const isAncestor = ancestorPathArray.every((ancestorPathItem, ancestorPathIndex) => {
            return ancestorPathItem === descendantPathArray[ancestorPathIndex];
        });
        return isAncestor;
    }
}

/**
 * BindingPath遍历器
 */
class BindingPathTraverser {
    /**
     * 获取叶子节点的Path
     */
    static getLeafPathString(bindingPath) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPath);
        return bindingPathArray.pop();
    }
    /**
     * 获取父路径
     */
    static getParentPathString(bindingPath) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPath);
        bindingPathArray.pop();
        return '/' + bindingPathArray.join('/');
    }
}

/**
 * EntityPath转换器
 */
class EntityPathConverter {
    /**
     * 转换为Entity可识别的路径
     * 根：[]
     * 主表：['id:xxx', 'name'],
     * 关联：['id:xxx', 'deptInfo', 'id:xxx', 'name']
     * UDT: ['id:xxx', 'updateInfo', ':', 'createdOn']
     * 从表：['id:xxx', 'edus', 'id:xxx', 'name'],
     * 从从表：['id:xxx', 'edus', 'id:xxx', 'grades', 'id:xxx', 'name']
     */
    static toEntityPathArray(bindingPathString, bindingData) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPathString);
        const entityPathArray = [];
        if (bindingPathArray.length === 0) {
            return entityPathArray;
        }
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            switch (propInfo.type) {
                case BindingPropertyType.Plain:
                    entityPathArray.push(propName);
                    break;
                case BindingPropertyType.Object:
                    currentBindingObject = currentBindingObject[propName];
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                case BindingPropertyType.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                default:
                    break;
            }
        });
        return entityPathArray;
    }
    /**
     * 创建路径中的主键部分
     */
    static createPrimaryKeyPath(primaryKey, primaryKeyValue) {
        return `${primaryKey}:${primaryKeyValue}`;
    }
}

/**
 * 实体路径比较器
 */
class EntityPathComparer {
}

/**
 * 表单路径转换类
 */
class FormPathConverter {
    /**
     * ControlPathString => BingingPathArray
     * @params controlPath FormControl对应的数据绑定路径（BindingData的bindingPaht + FormControl的binding）
     * @return BindingPath数组
     */
    static toBindingPathArray(formPahtString) {
        const bindingPathArray = formPahtString.split('.').filter((part) => {
            return part !== '';
        });
        return bindingPathArray;
    }
}

/**
 * 数据路径转换、比较等工具类
 * @summary
 * ----------------------------------------
 * 术语：
 * BindingPath：数组形式；
 * BindingPathString：BindingPath的字符串形式，用/分隔；
 * ControlPathString：BindingPath的字符串形式，用.分隔；
 *
 * EntityPath：数组形式；
 * EntityPathString：EntityPath的字符串形式，使用/分隔；
 * ----------------------------------------
 */

/*
 * @Author: Witt
 * @Date: 2018-12-27 09:25:38
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-27 09:39:10
 */
/**
 * 路径类型
 */
var DataPathNodeType;
(function (DataPathNodeType) {
    /**
     * 标记该节点是一个实体主键值，用来在列表上定位一个实体
     */
    DataPathNodeType["DataId"] = "DataId";
    /**
     * 标记该节点是一个属性名，用来在对象上定位一个属性
     */
    DataPathNodeType["PropName"] = "PropName";
})(DataPathNodeType || (DataPathNodeType = {}));
/**
 * 路径节点
 */
class DataPathNode {
    /**
     * 构造函数
     */
    constructor(type, data) {
        this.type = type;
        this.value = data;
        this.prev = null;
        this.next = null;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-27 09:26:41
 * @Last Modified by: Witt
 * @Last Modified time: 2019-01-15 22:00:45
 */
/**
 * 变更路径（简单双向列表）
 */
class DataPath {
    /**
     * 构造函数
     */
    constructor() {
        this.head = new DataPathNode(null, null);
        this.length = 0;
    }
    /**
     * 添加一个节点到头部
     */
    unshift(type, data) {
        const newNode = new DataPathNode(type, data);
        newNode.next = this.head.next;
        newNode.prev = this.head;
        this.head.next = newNode;
        if (newNode.next) {
            newNode.next.prev = newNode;
        }
        this.length++;
    }
    /**
     * 在链表最后追加一个节点
     */
    push(type, data) {
        const tailNode = this.getTail();
        const newNode = new DataPathNode(type, data);
        tailNode.next = newNode;
        this.length++;
    }
    /**
     * 获取链表尾部节点
     */
    getTail() {
        let lastNode = this.head;
        while (lastNode.next) {
            lastNode = lastNode.next;
        }
        return lastNode;
    }
    /**
     * 转换为数组格式
     */
    toArray() {
        const pathArray = [];
        let currentNode = this.head.next;
        while (currentNode) {
            pathArray.push(`${currentNode.type}:${currentNode.value}`);
            currentNode = currentNode.next;
        }
        return pathArray;
    }
    /**
     * 转换为字符串格式
     */
    toString() {
        const pathArray = this.toArray();
        const pathString = pathArray.join(', ');
        return `[${pathString}]`;
    }
    /**
     * 拷贝
     */
    clone() {
        const newDataPath = new DataPath();
        let curDataNode = this.head.next;
        while (curDataNode) {
            newDataPath.push(curDataNode.type, curDataNode.value);
            curDataNode = curDataNode.next;
        }
        return newDataPath;
    }
}

/**
 * 数据Path工厂类
 */
class DataPathCreator$$1 {
    /**
     * 将长路径数组或字符串转换为
     * @param fullPathArrayOrString 路径数组或字符串
     * @param repository 实体仓库
     * @summary
     * 1、长路径格式说明参考：data-path.md
     */
    static createByLongPathFromRoot(fullPathArrayOrString, entityManager) {
        const dataPath = new DataPath();
        const fullPathArray = fullPathArrayOrString;
        if (!fullPathArray || fullPathArray.length === 0) {
            return dataPath;
        }
        let currentNodeInfo = {
            nodeValue: fullPathArray.shift(),
            nodeType: DataPathNodeType.DataId,
            entityTypeInfo: new DataTypeInfo(entityManager.entityType)
        };
        while (currentNodeInfo) {
            dataPath.push(currentNodeInfo.nodeType, currentNodeInfo.nodeValue);
            // 处理下一个节点
            const nextNodeValue = fullPathArray.shift();
            if (!nextNodeValue || !currentNodeInfo.entityTypeInfo) {
                break;
            }
            currentNodeInfo = this.getNextPathNodeInfo(currentNodeInfo, nextNodeValue);
        }
        return dataPath;
    }
    /**
     * 获取下一个路径节点的信息
     * @param parentNodeInfo 当前路径节点信息
     * @param nextNodeValue 下一个路径节点的值
     * @summary
     * 1、这个递归写的很绕，说明数据结构设计不合理；
     * 2、多个因素混用了一个结构；
     */
    static getNextPathNodeInfo(parentNodeInfo, nextNodeValue) {
        const parentNodeValue = parentNodeInfo.nodeValue;
        const parentNodeType = parentNodeInfo.nodeType;
        const parentEntityTypeInfo = parentNodeInfo.entityTypeInfo;
        if (!nextNodeValue || !parentEntityTypeInfo) {
            return null;
        }
        const nextPathNodeInfo = {
            nodeValue: nextNodeValue,
            nodeType: null,
            entityTypeInfo: null
        };
        // DataNodeType=List：下一节点肯定是Object，并且EntityTypeInfo不变
        if (parentNodeType === DataPathNodeType.DataId) {
            nextPathNodeInfo.nodeType = DataPathNodeType.PropName;
            nextPathNodeInfo.entityTypeInfo = parentEntityTypeInfo;
        }
        else {
            // DataNodeType=Object：必然对应一个属性信息
            const nextPropInfo = parentEntityTypeInfo.getPropInfoByName(parentNodeValue);
            if (nextPropInfo.group === DataPropGroup.List) {
                // EntityPropGroup=EntityList：下一个节点是List类型。
                nextPathNodeInfo.nodeType = DataPathNodeType.DataId;
                nextPathNodeInfo.entityTypeInfo = nextPropInfo.typeInfo;
            }
            else {
                // EntityPropGroup=Entity：       下级entityTypeInfo为
                // EntityPropGroup=Dynamic|Plain：null
                nextPathNodeInfo.nodeType = DataPathNodeType.PropName;
                nextPathNodeInfo.entityTypeInfo = nextPropInfo.group === DataPropGroup.Object ? nextPropInfo.typeInfo : null;
            }
        }
        return nextPathNodeInfo;
    }
    /**
     * @param fullPathArrayOrString 路径数组或字符串
     * @param repository 实体仓库
     * @summary
     * 1、长路径格式说明参考：data-path.md
     * 2、shortPathArrayOrString暂时只支持字符串数组
     */
    static createByShortPathFromRoot(shortPathArrayOrString, entityManager, bindingData) {
        const dataPath = new DataPath();
        const shortPathArray = shortPathArrayOrString;
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        let currentEntityTypeInfo = new DataTypeInfo(entityManager.entityType);
        dataPath.push(DataPathNodeType.DataId, currentBindingObject.primaryKeyValue);
        // 遍历下级节点
        shortPathArray.forEach((propName) => {
            const propInfo = currentEntityTypeInfo.getPropInfoByName(propName);
            switch (propInfo.group) {
                case DataPropGroup.Plain:
                    dataPath.push(DataPathNodeType.PropName, propName);
                    break;
                case DataPropGroup.Object:
                    currentBindingObject = currentBindingObject[propName];
                    currentEntityTypeInfo = propInfo.typeInfo;
                    dataPath.push(DataPathNodeType.PropName, propName);
                    break;
                case DataPropGroup.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    currentEntityTypeInfo = propInfo.typeInfo;
                    dataPath.push(DataPathNodeType.PropName, propName);
                    dataPath.push(DataPathNodeType.DataId, currentBindingObject.primaryKeyValue);
                    break;
                default:
                    break;
            }
        });
        return dataPath;
    }
}

/**
 * 获取path对应的实体
 * @summary
 * 关于path的格式如下：
 * - 主表：[parentId]
 * - 主表关联: [parentId, assoInfo]
 * - 从表: [parentId, child1s, child1Id]
 * - 从表关联：[parentId, child1s, child1Id, assoInfo]
 * - 从从表: [parentId, child1s, child1Id, grand11s, grand11Id]
 * - 从从表关联：[parentId, child1s, child1Id, grand11s, grand11Id, assoInfo]
 */

/*
 * @Author: Witt
 * @Date: 2019-08-14 14:11:51
 * @Last Modified by: Witt
 * @Last Modified time: 2019-08-14 16:11:51
 */
/**
 * 实体属性分组
 */
var DataPropGroup;
(function (DataPropGroup) {
    /**
     * 简单类型
     */
    DataPropGroup["Plain"] = "Plain";
    /**
     * 实体类型
     */
    DataPropGroup["Object"] = "Object";
    /**
     * 动态实体类型
     */
    DataPropGroup["Dynamic"] = "Dynamic";
    /**
     * 列表类型
     */
    DataPropGroup["List"] = "List";
})(DataPropGroup || (DataPropGroup = {}));
/**
 * 实体属性信息
 */
class DataPropInfo {
}

/*
 * @Author: Witt
 * @Date: 2018-12-07 09:05:09
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-27 20:35:02
 */
/**
 * 实体类型信息
 * @todo：
 * 1、构造时不应该识别Entity模块的东西，应该是更抽象的；
 * 2、构造函数应该接收一个Builder接口，由Entity或者其他实现层来实现这个接口。
 */
class DataTypeInfo {
    /**
     * 是否为值对象
     */
    get isValueObject() {
        return !this.primaryKey;
    }
    /**
     * 构造函数
     * @todo：不应该识别
     */
    constructor(type) {
        this.type = type;
        this.primaryKey = '';
        this.foreignKey = '';
        this.propInfoMap = new Map();
        this.collectEntityInfos();
        this.collectPropInfos();
    }
    getBindingPathByTableName(tableName) {
        const fullEntityPath = this.getFullEntityPath(this, tableName);
        if (!fullEntityPath) {
            return null;
        }
        fullEntityPath.splice(0, 1);
        return '/' + fullEntityPath.join('/');
    }
    getFullEntityPath(dataTypeInfo, tableName, paths = []) {
        if (dataTypeInfo.entityInfo && (dataTypeInfo.entityInfo.nodeCode === tableName || dataTypeInfo.entityInfo.originalCode === tableName)) {
            paths.push(dataTypeInfo.entityInfo.nodeCode);
            return paths;
        }
        const props = Array.from(dataTypeInfo.propInfoMap.values()).filter(p => p.typeInfo);
        if (props.length < 1) {
            paths = [];
            return paths;
        }
        if (dataTypeInfo.entityInfo) {
            paths.push(dataTypeInfo.entityInfo.nodeCode);
        }
        for (let idx = 0; idx < props.length; idx++) {
            const dataTypeInfo = props[idx].typeInfo;
            const path = this.getFullEntityPath(dataTypeInfo, tableName);
            if (!path || path.length < 1) {
                continue;
            }
            else {
                paths = paths.concat(path);
                return paths;
            }
        }
        return null;
    }
    /**
     * 获取全部属性信息
     */
    getPropInfos() {
        return Array.from(this.propInfoMap.values()).filter((propInfo) => !propInfo.isVOField);
    }
    /**
     * 获取全部属性的名称
     */
    getPropNames() {
        const propNames = [];
        const propInfos = this.getPropInfos();
        propInfos.forEach((propInfo) => {
            propNames.push(propInfo.name);
        });
        return propNames;
    }
    /**
     * 根据group获取属性信息数组
     */
    getPropInfosByGroup(group) {
        const allPropInfos = Array.from(this.propInfoMap.values());
        const propInfos = allPropInfos.filter((propInfo) => {
            return propInfo.group === group && !propInfo.isVOField;
        });
        return propInfos;
    }
    /**
     * 根据group获取属性名称数组
     * @param group 属性分组
     */
    getPropNamesByGroup(group) {
        const propNames = [];
        const propInfos = this.getPropInfosByGroup(group);
        propInfos.forEach((propInfo) => {
            propNames.push(propInfo.name);
        });
        return propNames;
    }
    /**
     * 根据propName获取属性信息
     */
    getPropInfoByName(propName) {
        if (this.propInfoMap.has(propName)) {
            return this.propInfoMap.get(propName);
        }
        return null;
    }
    /**
     * 根据path获取属性信息
     */
    getPropInfoByPath(path) {
        // 先复制，防止shift方法产生污染
        const arrPath = path.concat([]);
        if (arrPath.length === 0) {
            throw Error(`属性路径不能为空`);
        }
        // 循环查找
        let typeInfo = this;
        let propInfo = null;
        while (typeInfo && arrPath.length > 0) {
            const propName = arrPath.shift();
            propInfo = typeInfo.getPropInfoByName(propName);
            if (!propInfo) {
                throw Error(`路径${path}中存在不正确的节点${propName}，请检查`);
            }
            typeInfo = propInfo.typeInfo;
            // 如果是动态列，并且路径数组里还有属性，统一设置为null(动态列不再描述属性信息)
            if (propInfo.group === DataPropGroup.Dynamic && arrPath.length > 0) {
                propInfo = null;
                typeInfo = null;
            }
        }
        return propInfo;
    }
    /**
     * 根据path获取对应属性的TypeInfo
     */
    getTypeInfoByPath(path) {
        // 空数组时返回
        if (path.length === 0) {
            return this;
        }
        // 获取对应属性信息
        const propInfo = this.getPropInfoByPath(path);
        if (!propInfo.typeInfo) {
            throw Error(`路径${path}无法定位到一个EntityTypeInfo，请检查`);
        }
        return propInfo.typeInfo;
    }
    /**
     * 获取主键的属性信息
     */
    getPrimaryKeyPropInfo() {
        return this.getPropInfoByName(this.primaryKey);
    }
    /**
     * 根据name获取影射名
     */
    getPropMappingByName(name) {
        const propInfo = this.getPropInfoByName(name);
        if (!propInfo) {
            return '';
        }
        return propInfo.mapping;
    }
    /**
     * 根据path获取映射名
     */
    getPropMappingByPath(path) {
        const propInfo = this.getPropInfoByPath(path);
        if (!propInfo) {
            return '';
        }
        return propInfo.mapping;
    }
    /**
     * 检查属性是否属于特定的分组
     */
    checkPropGroup(propName, propGroup) {
        const propInfo = this.getPropInfoByName(propName);
        if (propInfo && propInfo.group === propGroup) {
            return true;
        }
        return false;
    }
    /**
     * --------------------------------------------------------------------------------
     * 属性元数据 => 属性描述信息
     * --------------------------------------------------------------------------------
     */
    /**
     * 搜集所有属性信息
     * @todo：消除重复代码，ts不支持interface类型检测，暂时通过遍历实现。
     */
    collectPropInfos() {
        // 简单属性
        const ngPlainProperties = EntityMetadataUtil.getNgFieldProperties(this.type);
        Object.keys(ngPlainProperties).forEach((propName) => {
            const ngProperty = ngPlainProperties[propName];
            if (ngProperty.primary === true) {
                this.primaryKey = propName;
            }
            if (ngProperty.foreign === true) {
                this.foreignKey = propName;
            }
            this.addPropInfo(DataPropGroup.Plain, propName, ngProperty.dataField, null, ngProperty);
        });
        // 实体属性
        const ngEntityProperties = EntityMetadataUtil.getNgObjectProperties(this.type);
        Object.keys(ngEntityProperties).forEach((propName) => {
            const ngProperty = ngEntityProperties[propName];
            this.addPropInfo(DataPropGroup.Object, propName, ngProperty.dataField, ngProperty.type, ngProperty);
        });
        // 动态实体属性
        const ngDynamicProperties = EntityMetadataUtil.getNgDynamicProperties(this.type);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            const ngProperty = ngDynamicProperties[propName];
            this.addPropInfo(DataPropGroup.Dynamic, propName, ngProperty.dataField, null, ngProperty);
        });
        // 实体列表属性
        const ngEntityListProperties = EntityMetadataUtil.getNgListProperties(this.type);
        Object.keys(ngEntityListProperties).forEach((propName) => {
            const ngProperty = ngEntityListProperties[propName];
            this.addPropInfo(DataPropGroup.List, propName, ngProperty.dataField, ngProperty.type, ngProperty);
        });
    }
    collectEntityInfos() {
        let entityInfo = EntityMetadataUtil.getNgEntityMatadata(this.type);
        if (!entityInfo) {
            // 应用于解析表单
            entityInfo = {
                originalCode: this.type["code"],
                nodeCode: this.type["label"]
            };
        }
        this.entityInfo = entityInfo;
    }
    /**
     * 添加属性信息
     */
    addPropInfo(group, name, mapping, type, metadataInfo) {
        // 没有设置影射时，用属性名充当影射
        mapping = mapping ? mapping : name;
        let typeInfo = null;
        if (type) {
            typeInfo = new DataTypeInfo(type);
        }
        const propInfo = { group, name, mapping, typeInfo, metadataInfo };
        this.propInfoMap.set(name, propInfo);
        // 将vo字段也加入便于表达式查找
        const originalDataField = metadataInfo && metadataInfo.originalDataField;
        if (originalDataField && !this.propInfoMap.has(originalDataField)) {
            this.propInfoMap.set(originalDataField, Object.assign({}, propInfo, { isVOField: true }));
        }
        else if (metadataInfo && metadataInfo.type) {
            const entityInfo = EntityMetadataUtil.getNgEntityMatadata(metadataInfo.type);
            if (entityInfo && entityInfo.originalCode) {
                this.propInfoMap.set(entityInfo.originalCode, Object.assign({}, propInfo, { isVOField: true }));
            }
        }
    }
}

/**
 * 表单模块路径
 */
const FORM_PATH_TOKEN = new InjectionToken('@farris/devkit form path token');
/**
 * 后端消息处理器
 */
const BACK_END_MESSAGE_HANDLER_TOKEN = new InjectionToken('@farris/devkit_back_end_message_handler');
const MESSAGE_SERVICE_TOKEN = new InjectionToken('@farris/message_service_token');
const NOTIFY_SERVICE_TOKEN = new InjectionToken('@farris/notify_service_token');
/**
 * 变更集提交策略,entire | valid
 * @description entire是指提交所有变更，valid是指仅提交前端校验通过的变更
 */
const CHANGE_SET_POLICY_TOKEN = new InjectionToken('@farris/changeset_policy_token');
/**
 * 启用服务器端变更检测
 */
const ENABLE_SERVER_SIDE_CHANGE_DETECTION_TOKEN = new InjectionToken('@farris/enable_server_side_change_detection_token');
/**
 * 启用编辑态过滤排序
 */
const ENABLE_EDIT_STATE_FILTER_SORTING = new InjectionToken('@farris/enable_edit_state_filter_sorting_token');

/**
  * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
  *
  * This function will take an already-encoded URL and encode all the non-URL
  * code points. This function will not encode the "%" character unless it is
  * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
  * be encoded as `%25foo`).
  *
  * This encode is meant to be "safe" and does not throw errors. It will try as
  * hard as it can to properly encode the given URL, including replacing any raw,
  * unpaired surrogate pairs with the Unicode replacement character prior to
  * encoding.
  *
  * @param {string} url
  * @return {string}
  * @public
  */
function encodeUrl(url) {
    const ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    const UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    const UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';
    return String(url)
        .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
        .replace(ENCODE_CHARS_REGEXP, encodeURI)
        .replace(/#/g, '%23').replace(/&/g, '%26');
}

class Core {
    static warn(message, ...optionalParams) {
        this.logable() && console && console.warn(message, ...optionalParams);
    }
    static error(message, ...optionalParams) {
        this.logable() && console && console.error(message, ...optionalParams);
    }
    static log(message, ...optionalParams) {
        this.logable() && console && console.log(message, ...optionalParams);
    }
    static logable() {
        return window && window.localStorage && window.localStorage.getItem('__DEVKIT_LOGABLE__') === 'true' || false;
    }
}

function escape(value) {
    if (!value || typeof value !== 'string') {
        return value;
    }
    return value
        .replace(/[\\]/g, '\\\\')
        .replace(/[\"]/g, '\\\"')
        .replace(/[\/]/g, '\\/')
        .replace(/[\b]/g, '\\b')
        .replace(/[\f]/g, '\\f')
        .replace(/[\n]/g, '\\n')
        .replace(/[\r]/g, '\\r')
        .replace(/[\t]/g, '\\t');
}

const RESOLVER_TOKEN = new InjectionToken('@farris_resolver_token');
const ENTITY_TEMPLATE = 'ENTITY~';
const STATE_TEMPLATE = 'STATE~';
const GROUP_FUNCTIONS = ['SumByProp', 'CountByProp', 'AvgByProp', 'MaxByProp', 'MinByProp', 'IsExistRecord', 'ListContains', 'ListGreaterThan', 'ListLessThan', 'ListStartWith', 'ListEndWith', 'MultiplyChildNumber', 'SortChildData', 'IsContainMatch', 'MinValueOfPeriod', 'MaxValueOfPeriod', 'AvgValueOfPeriod'];

class ResolverRegistry {
    constructor(injector, resolvers) {
        this.injector = injector;
        this.resolvers = resolvers;
    }
}
ResolverRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ResolverRegistry.ctorParameters = () => [
    { type: Injector },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [RESOLVER_TOKEN,] }] }
];

const NG_REPOSITORY = 'NgRepository';
/**
 * NgRepository
 */
function NgRepository(options) {
    const decoratorFactory = makeDecorator(NG_REPOSITORY, (obj) => obj);
    return decoratorFactory(options);
}

// tslint:disable: no-bitwise
/**
 * 实体集合
 * @todo：应该用EntityList代替。
 */
class EntityCollection {
    /**
     * 构造函数
     */
    constructor(entityType) {
        this.innerEntitySet = new Set();
        this.innerEntityMap = new Map();
        this.collectionChanged = new Subject();
        this.changes = new Subject();
        this.entityType = entityType;
        this.primaryKey = FieldMetadataUtil.getPrimaryKey(this.entityType) || entityType.prototype.primaryKey;
    }
    /**
     *变更策略
     */
    set changeSetPolicy(policy) {
        this._changeSetPolicy = policy;
    }
    get changeSetPolicy() {
        return this._changeSetPolicy;
    }
    /**
     * 实体数量
     */
    count() {
        return this.innerEntitySet.size;
    }
    get entityTypeName() {
        return this.entityType.name;
    }
    /**
     * 是否包含指定主键值的实体
     * @param id 主键值
     */
    has(id) {
        return this.innerEntityMap.has(id);
    }
    /**
     * 清空全部实体
     */
    clear() {
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        this.notifyCollectionChanged(new Modification([], ModifyType.Load));
    }
    /**
     * 清空全部实体
     * @param isReset 是否为重置实体操作
     */
    reset(notify = true) {
        this.innerEntityMap.forEach(entity => {
            entity.unsubscribe.next();
            entity.unsubscribe.complete();
        });
        this.innerEntitySet.forEach(entity => {
            entity.unsubscribe.next();
            entity.unsubscribe.complete();
        });
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        if (notify === true) {
            const modification = new Modification([], ModifyType.Load);
            modification.isReset = true;
            this.notifyCollectionChanged(modification);
        }
    }
    /**
     * 转换为实体数组
     */
    toArray() {
        return Array.from(this.innerEntitySet);
    }
    /**
     * 转换为JSON数组
     */
    toJSON() {
        const result = [];
        const entities = this.toArray();
        entities.forEach((entity) => {
            result.push(entity.toJSON());
        });
        return result;
    }
    /**
     * 批量加载实体
     */
    loadEntities(entities, entityCreate = false) {
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        entities.forEach(entity => {
            this.extendChangeSetPolicyProperty(entity);
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
            this.listenEntityChangeEvent(entity);
        });
        const modification = new Modification(entities, ModifyType.Load);
        modification.entityCreate = entityCreate;
        this.notifyCollectionChanged(modification);
    }
    /**
     * 追加实体
     * @param entity 要追加的实体
     * @param isCloned 实体是否是克隆的
     */
    addEntity(entity, isCloned = false) {
        this.verifyEntityToAdd(entity);
        this.extendChangeSetPolicyProperty(entity);
        this.innerEntitySet.add(entity);
        this.innerEntityMap.set(entity[this.primaryKey], entity);
        this.listenEntityChangeEvent(entity);
        const modifyType = isCloned ? ModifyType.Clone : ModifyType.Add;
        this.notifyCollectionChanged(new Modification([entity], modifyType));
    }
    /**
     * 在当前行前或后插入数据
     * @param entity 实体
     * @param position 位置
     */
    insertEntity(entity, position) {
        this.verifyEntityToAdd(entity);
        this.extendChangeSetPolicyProperty(entity);
        this.innerEntitySet.add(entity);
        this.innerEntityMap.set(entity[this.primaryKey], entity);
        this.listenEntityChangeEvent(entity);
        this.notifyCollectionChanged(new Modification(entity, ModifyType.Insert, null, null, position));
    }
    /**
     * 更新实体
     * @param entity entity
     * @param data 实体数据
     */
    updateEntity(entity, data) {
        entity.load(data);
        this.notifyCollectionChanged(new Modification(data, ModifyType.Update, null, null));
    }
    /**
     * 批量追加实体
     * @param entities 要加载的实体数组
     */
    addEntities(entities, options = null) {
        if (!entities) {
            return;
        }
        const entitiesToAdd = [];
        entities.forEach(entity => {
            this.verifyEntityToAdd(entity);
            entitiesToAdd.push(entity);
        });
        entitiesToAdd.forEach(entity => {
            this.extendChangeSetPolicyProperty(entity);
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
            this.listenEntityChangeEvent(entity);
        });
        const isTreeNodeLoadScene = options && options.isTreeNodeLoadScene || false;
        const modification = new Modification(entitiesToAdd, ModifyType.Add);
        modification.isTreeNodeLoadScene = isTreeNodeLoadScene;
        this.notifyCollectionChanged(modification);
    }
    /**
     * 添加实体（不切换当前行）
     * @param entities 实体
     */
    addData(entities, options = null) {
        if (!entities) {
            return;
        }
        const entitiesToAdd = [];
        entities.forEach(entity => {
            this.verifyEntityToAdd(entity);
            entitiesToAdd.push(entity);
        });
        entitiesToAdd.forEach(entity => {
            this.extendChangeSetPolicyProperty(entity);
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
            this.listenEntityChangeEvent(entity);
        });
        // 针对树分层加载场景
        const isTreeNodeLoadScene = options && options.isTreeNodeLoadScene || false;
        const modification = new Modification(entitiesToAdd, ModifyType.AddData);
        modification.isTreeNodeLoadScene = isTreeNodeLoadScene;
        this.notifyCollectionChanged(modification);
    }
    /**
     * 为实体扩展变更策略属性
     * @param entity
     */
    extendChangeSetPolicyProperty(entity) {
        if (entity) {
            entity.changeSetPolicy = this.changeSetPolicy;
        }
    }
    /**
     * 根据主键值获取实体
     */
    getEntityById(identity) {
        if (this.innerEntityMap.has(identity) === false) {
            return null;
        }
        const entity = this.innerEntityMap.get(identity);
        return entity;
    }
    /**
     * 根据路径获取实体
     */
    getEntityByPath(pathArray) {
        const rootEntityId = pathArray[0].split(':')[1];
        let parentNode = this.getEntityById(rootEntityId);
        for (let i = 1; i < pathArray.length && parentNode; i = i + 1) {
            const currentPath = pathArray[i];
            if ((parentNode instanceof Entity) || (parentNode.typeName === 'ConcreteEntityPrototype')) {
                // @todo：强识了别冒号
                if (currentPath.indexOf(':') === -1) {
                    parentNode = parentNode[pathArray[i]];
                }
            }
            else {
                parentNode = parentNode.get(pathArray[i].split(':')[1]);
            }
        }
        return parentNode;
    }
    /**
     * id:1/a/id:2/c
     * @param pathArray 路径数组
     */
    getEntitiesByPath(pathArray) {
        const rootEntityId = pathArray[0].split(':')[1];
        let entity = this.getEntityById(rootEntityId);
        for (let i = 1; i < pathArray.length && entity; i += 2) {
            const path = pathArray[i];
            entity = entity[path];
            if (!(entity instanceof EntityList)) {
                throw new Error('路径格式错误');
            }
            if ((i + 1) < pathArray.length) {
                const id = pathArray[i + 1].split(':')[1];
                entity = entity.get(id);
            }
        }
        return entity;
    }
    /**
     * 返回符合指定条件的实体集合
     * @param predicate 条件谓词
     */
    getEntities(predicate) {
        const entities = Array.from(this.innerEntitySet);
        const matchedEntities = entities.filter(predicate);
        return matchedEntities;
    }
    /**
     * 获取全部实体
     */
    getAllEntities() {
        return Array.from(this.innerEntitySet);
    }
    /**
     * 根据主键值删除对应实体
     * @param identity 主键值
     */
    removeEntityById(identity) {
        this.verifyEntityToRemove(identity);
        const entityToRemove = this.innerEntityMap.get(identity);
        this.innerEntityMap.delete(identity);
        this.innerEntitySet.delete(entityToRemove);
        this.notifyCollectionChanged(new Modification([entityToRemove], ModifyType.Remove));
        return entityToRemove;
    }
    removeEntitiesByIds(id) {
    }
    /**
     * 删除符合条件的实体集合
     */
    removeEntities(predicate) {
        const entitiesToRemove = Array.from(this.innerEntitySet).filter(predicate);
        entitiesToRemove.forEach(entityToRemove => {
            this.innerEntityMap.delete(entityToRemove[this.primaryKey]);
            this.innerEntitySet.delete(entityToRemove);
        });
        this.notifyCollectionChanged(new Modification(entitiesToRemove, ModifyType.Remove));
        return entitiesToRemove;
    }
    /**
     * 移除数据（不切换当前行）
     * @param predicate 过滤函数
     */
    removeData(predicate) {
        const entitiesToRemove = Array.from(this.innerEntitySet).filter(predicate);
        entitiesToRemove.forEach(entityToRemove => {
            this.innerEntityMap.delete(entityToRemove[this.primaryKey]);
            this.innerEntitySet.delete(entityToRemove);
        });
        this.notifyCollectionChanged(new Modification(entitiesToRemove, ModifyType.RemoveData));
        return entitiesToRemove;
    }
    /**
     * 重置子表数据
     * @param paths 路径
     * 路径格式 ['id:provinceId','id:cityMDMs','zoneMDMs']
     * @description path参数格式
     * ```json
     * [
     * "id:b5ed23ca-88d9-4377-98ec-92f35c1325f1",
     * "cityMDMs",
     * "id:373706af-622f-4aea-a006-dddbffd7bda3",
     * "zoneMDMs"
     * ]
     * ```
     * @param entities 实体数组
     */
    resetEntities(paths, entities) {
        if (paths[0].indexOf(':') === -1) {
            throw new Error('路径格式错误');
        }
        // 获取主实体
        const id = paths[0].split(':')[1];
        let entity = this.innerEntityMap.get(id);
        let entityList = entity[paths[1]];
        if (!entity) {
            throw new Error(`找不到主键为${id}的实体`);
        }
        for (let index = 2; index < paths.length; index += 2) {
            const pathInfo = paths[index].split(':');
            const entityId = pathInfo[1];
            // 获取到当前层级的实体
            entity = entityList.get(entityId);
            if (!entity) {
                throw new Error(`找不到主键为${id}的实体`);
            }
            // 获取当前层级实体下的列表属性
            entityList = entity[paths[index + 1]];
        }
        entityList.clear();
        entityList.loadEntities(entities);
    }
    /**
     * 验证实体是否能够添加
     */
    verifyEntityToAdd(entity) {
        if (this.has(entity[this.primaryKey])) {
            throw new Error(`The repository already had an item with the save identity of '${entity[this.primaryKey]}'`);
        }
        return true;
    }
    /**
     * 验证实体是否能移除
     */
    verifyEntityToRemove(identity) {
        if (!this.has(identity)) {
            throw new Error(`The entity with identity of '${identity} dose not exsit.'`);
        }
        return true;
    }
    /**
     * 实体集合变更流
     */
    notifyCollectionChanged(modification) {
        this.collectionChanged.next(modification);
    }
    listenEntityChangeEvent(entity) {
        if (entity) {
            entity.onValueChanged.subscribe((change) => this.changes.next(change));
        }
    }
    //#region 分页
    /**
     * 设置分页大小
     */
    set pageSize(pageSize) {
        if (typeof (pageSize) !== 'number' || pageSize < 0) {
            throw new Error('Invalid parameter:pageSize');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { pageSize });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        // this.notifyCollectionChanged(new Modification(this.paginationInfo[this.entityTypeName], ModifyType.PaginationInfoChange));
        this.paginationInfo = Object.assign({}, original, { pageSize });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取分页大小
     * @description 如果用户未指定分页大小则默认为0，即获取所有数据
     */
    get pageSize() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.pageSize || 0;
        }
        return 0;
    }
    /**
     * 设置数据总条数
     */
    set totalCount(total) {
        if (typeof (total) !== 'number' || total < 0) {
            throw new Error('Invalid parameter:total');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { total });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        this.paginationInfo = Object.assign({}, original, { total });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取数据总条数
     */
    get totalCount() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.total || 0;
        }
        return 0;
    }
    /**
     * 设置当前页码
     */
    set pageIndex(pageIndex) {
        if (typeof (pageIndex) !== 'number' || pageIndex < 0) {
            throw new Error('Invalid parameter:pageIndex');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { pageIndex });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        this.paginationInfo = Object.assign({}, original, { pageIndex });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取当前页码
     */
    get pageIndex() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.pageIndex || 1;
        }
        return 1;
    }
    /**
     * 更新分页信息
     * @param path 绑定路径
     * @param pageInfo 分页信息
     */
    updatePaginationInfoByPath(path, pageInfo) {
        const original = this.paginationInfo;
        const { pageIndex, pageSize } = pageInfo;
        const total = pageInfo && (pageInfo.totalCount || pageInfo.total) || 0;
        const paginationInfo = Object.assign({}, original, { pageIndex, pageSize, total });
        this.setPaginationConfigByPath(path, paginationInfo);
    }
    /**
     * 根据路径获取分页大小
     * @param path 路径
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationInfo;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0).map(item => item.trim());
        let config = this.paginationInfo;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 设置分页信息
     * @param path 路径
     * @param value 值，其中总条数key为total
     */
    setPaginationConfigByPath(path, value) {
        const original = JSON.stringify(this.paginationInfo);
        if (!path || path === '/') {
            this.paginationInfo = value;
        }
        else {
            if (!Array.isArray(path)) {
                path = path.toString().match(/[^/[\]]+/g) || [];
            }
            path.slice(0, -1).reduce((prev, current, index) => Object(prev[current]) === prev[current]
                ? prev[current]
                : prev[current] = Math.abs(path[index + 1]) >> 0 === +path[index + 1]
                    ? []
                    : {}, this.paginationInfo)[path[path.length - 1]] = value;
        }
        if (JSON.stringify(this.paginationInfo) !== original) {
            this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
        }
        return this.paginationInfo;
    }
}

/*
 * @Author: Witt
 * @Date: 2019-03-07 17:24:38
 * @Last Modified by:   Witt
 * @Last Modified time: 2019-03-11 19:50:38
 */
/**
 * 实体管理类
 */
class EntityManager {
    /**
     * 构造函数
     */
    constructor(entityCollection) {
        this.entityCollection = entityCollection;
        this.entityType = entityCollection.entityType;
    }
    // #region 创建实体相关方法
    /**
     * 创建实体
     */
    createEntity(entityData) {
        const entity = createEntity(this.entityType, entityData);
        return entity;
    }
    /**
     * 批量创建实体
     */
    createEntities(entityListData, entityType) {
        const entities = createEntities(this.entityType, entityListData);
        return entities;
    }
    /**
     * 批量创建下级实体
     * @param fPath fpath
     * @param entityListData 实体数据
     */
    createEntitiesByPath(fPath, entityListData) {
        const subPaths = fPath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fPath}]格式不对`);
        }
        if (entityListData.length < 1) {
            return [];
        }
        let childEntityList;
        let propInfo;
        let propName;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            propName = subPaths[i];
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            const entityType = propInfo ? propInfo.propEntityType : this.entityType;
            propInfo = EntityUtil.getPropInfo(entityType, propName);
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fPath}`);
            }
        }
        const entities = entityListData.map(entityData => {
            return createEntity(propInfo.propEntityType, entityData);
        });
        return entities;
    }
    // #endregion
    // #region 获取实体、实体数组相关方法
    /**
     * 获取path对应的实体
     */
    getEntityByPath(path) {
        const entity = this.getEntityNodeByPath(path);
        return entity;
    }
    /**
     * 获取path对应的实体
     */
    getEntitiesByPath(path) {
        const entityCollectionOrList = this.getEntityNodeByPath(path);
        let entities;
        if (entityCollectionOrList instanceof EntityCollection === true) {
            entities = entityCollectionOrList.toArray();
        }
        else {
            entities = entityCollectionOrList.toArray();
        }
        return entities;
    }
    /**
     * 获取实体节点
     * @param path 节点路径
     */
    getEntityNodeByPath(path) {
        const dataPath = DataPathCreator$$1.createByLongPathFromRoot(path, this);
        let entityNode = this.entityCollection;
        let pathNode = dataPath.head.next;
        while (pathNode) {
            if (pathNode.type === DataPathNodeType.DataId) {
                if (entityNode instanceof EntityCollection === true) {
                    entityNode = entityNode.getEntityById(pathNode.value);
                }
                else {
                    entityNode = entityNode.get(pathNode.value);
                }
            }
            else {
                entityNode = entityNode[pathNode.value];
            }
            if (!entityNode) {
                throw new Error(`找不到${pathNode.value}对应的数据节点`);
            }
            pathNode = pathNode.next;
        }
        return entityNode;
    }
    // #endregion
    // #region 获取、设置属性值
    /**
     * 获取path对应的实体属性值
     */
    getPropValueByPath(path) {
        const propName = path.pop();
        const entity = this.getEntityByPath(path);
        return entity[propName];
    }
    /**
     * 设置path对应实体的属性值
     */
    setPropValueByPath(path, propValue) {
        const propName = path.pop();
        const entity = this.getEntityByPath(path);
        entity[propName] = propValue;
    }
    // #endregion
    // #region 插入实体
    /**
     * 在path对应实体前插入实体
     */
    insertEntityBeforeByPath(fpath) {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前批量插入实体
     */
    insertEntitiesBeforeByPath() {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前插入实体
     */
    insertEntityAfterByPath() {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前批量插入实体
     */
    insertEntitiesAfterByPath() {
        throw new Error('Not Implemented');
    }
    // #endregion
    // #region 追加实体
    /**
     * 在path对应的实体集合中追加1个实体
     */
    // public appendEntityByPath(fpath: string[], entity: Entity): void {
    //   const entityCollectionOrList = this.getEntityNodeByPath(fpath);
    //   if (entityCollectionOrList instanceof EntityCollection === true) {
    //     const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
    //     entityCollection.addEntity(entity);
    //   } else {
    //     const entityList = (entityCollectionOrList as EntityList<Entity>);
    //     entityList.appendEntity(entity);
    //   }
    // }
    /**
     * 根据path获取实体集合
     * @param fpath 路径 /id/childsNode/id/xxx
     * @param entityData 实体数据
     * @param initialData[可选] 默认值
     */
    appendEntityByPath(fpath, entityData, initialData, isCloned = false) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        let propInfo;
        let propName;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            propName = subPaths[i];
            // todo: EntityCollection重构之后这里无需差异处理
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            const entityType = propInfo ? propInfo.propEntityType : this.entityType;
            propInfo = EntityUtil.getPropInfo(entityType, propName);
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        // const propInfo = EntityUtil.getPropInfo(this.entityType, propName);
        const childEntity = createEntity(propInfo.propEntityType, entityData);
        // 在实体的实例上增加默认值属性，以便在createBindingObject时存放默认值
        // if (initialData) {
        //   EntityUtil.appendInitialData(childEntity, initialData);
        // }
        childEntityList.appendNew(childEntity, isCloned);
        return childEntity;
    }
    /**
     * 在指定位置插入实体
     * @param fpath 父路径
     * @param entityData 实体数据
     * @param initialData 初始数据
     * @param position 插入位置
     */
    insertEntityByPath(fpath, entityData, initialData, position) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        let propInfo;
        let propName;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            propName = subPaths[i];
            // todo: EntityCollection重构之后这里无需差异处理
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            const entityType = propInfo ? propInfo.propEntityType : this.entityType;
            propInfo = EntityUtil.getPropInfo(entityType, propName);
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        // const propInfo = EntityUtil.getPropInfo(this.entityType, propName);
        const childEntity = createEntity(propInfo.propEntityType, entityData);
        // 在实体的实例上增加默认值属性，以便在createBindingObject时存放默认值
        // if (initialData) {
        //   EntityUtil.appendInitialData(childEntity, initialData);
        // }
        childEntityList.insert(childEntity, position);
        return childEntity;
    }
    /**
     * 在path对应的实体集合中追加多个实体
     */
    appendEntitiesByPath(fpath, entities) {
        const entityCollectionOrList = this.getEntityNodeByPath(fpath);
        if (entityCollectionOrList instanceof EntityCollection === true) {
            const entityCollection = entityCollectionOrList;
            entityCollection.addEntities(entities);
        }
        else {
            const entityList = entityCollectionOrList;
            entityList.appendEntities(entities);
        }
    }
    // #endregion
    // #region 删除实体
    /**
     * 从fapth对应的实体集合中删除id对应的实体
     */
    // public removeEntityByPath(fpath: string[], id: string): void {
    //   const entityCollectionOrList = this.getEntityNodeByPath(fpath);
    //   if (entityCollectionOrList instanceof EntityCollection === true) {
    //     const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
    //     entityCollection.removeEntityById(id);
    //   } else {
    //     const entityList = (entityCollectionOrList as EntityList<Entity>);
    //     entityList.remove(id);
    //   }
    // }
    /**
     * 根据path获取实体集合
     * @param fpath path
     */
    removeEntityByPath(fpath, id) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            const propName = subPaths[i];
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        childEntityList.remove(id);
    }
    /**
     * 从fapth对应的实体集合中删除ids对应的实体
     */
    removeEntitiesByPath(fpath, ids) {
        // const entityCollectionOrList = this.getEntityNodeByPath(fpath);
        // if (entityCollectionOrList instanceof EntityCollection === true) {
        //   const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
        //   entityCollection.removeEntitiesByIds(ids);
        // } else {
        //   const entityList = (entityCollectionOrList as EntityList<Entity>);
        //   entityList.remove(ids);
        // }
        throw new Error('Not Implemented');
    }
    // #endregion
    // #region 清空变更集相关方法
    /**
     * 清空所有实体的变更集
     */
    clearAllEntityChanges() {
        const entities = this.entityCollection.toArray();
        entities.forEach((entity) => {
            entity.changes.splice(0, entity.changes.length);
        });
    }
    /**
     * 清空id指定的实体变更集
     */
    clearEntityChangesById(id) {
        const entity = this.entityCollection.getEntityById(id);
        if (!entity) {
            return;
        }
        entity.changes.splice(0, entity.changes.length);
    }
    /**
     * 清空ids数组中指定的实体的变更集
     */
    clearEntityChangesByIds(ids) {
        if (!ids || ids.length < 0) {
            return;
        }
        ids.forEach((id) => {
            this.clearEntityChangesById(id);
        });
    }
    // #endregion
    // #region 变更集检查相关方法
    /**
     * 检查所有的实体，是否有未提交的变更
     */
    checkAllEntityChanges() {
        const entities = this.entityCollection.toArray();
        const hasChanges = entities.some((entity) => {
            if (entity.changes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        });
        return hasChanges;
    }
    /**
     * 检查id对应的实体，是否有未提交的变更
     */
    checkEntityChangesById(id) {
        const entity = this.entityCollection.getEntityById(id);
        if (!entity) {
            return false;
        }
        return entity.changes.length > 0;
    }
    // #endregion
    // #region 不规范方法，待废弃
    /**
     * 待废弃
     * @deprecated
     */
    clearEntityChangesByArray(idArray) {
        this.clearEntityChangesByIds(idArray);
    }
}

// tslint:disable: no-bitwise
class PaginationManager {
    constructor(entityType, paginationConfig) {
        this.entityType = entityType;
        this.paginationConfig = paginationConfig;
        if (this.paginationConfig === null || this.paginationConfig === undefined) {
            this.paginationConfig = this.getNgListProperties();
        }
        // 兼容老表单，将之前的主表分页信息展开到分页配置根中
        this.expandMainEntityConfig();
        this.deleteMainEntityConfig();
        this.removeLasts();
    }
    /**
     * 主表分页信息展开到分页配置根中
     */
    expandMainEntityConfig() {
        const entityName = this.entityType.typeName || this.entityType.name;
        if (this.paginationConfig.hasOwnProperty(entityName)) {
            const entityConfig = this.paginationConfig[entityName];
            this.paginationConfig = Object.assign(this.paginationConfig, entityConfig);
        }
        else {
            this.paginationConfig = Object.assign(this.paginationConfig, { pageSize: this.paginationConfig['pageSize'] || 0 });
        }
    }
    /**
     * 删除子表分页配置key后面的s
     */
    removeLasts() {
        const entityName = this.entityType.typeName || this.entityType.name;
        Object.keys(this.paginationConfig).forEach(key => {
            if (key !== entityName && key.endsWith('s')) {
                const newKey = key.substring(0, key.length - 1);
                this.paginationConfig[newKey] = this.paginationConfig[key];
                delete this.paginationConfig[key];
            }
        });
    }
    /**
     * 删除主表实体配置信息
     */
    deleteMainEntityConfig() {
        const entityName = this.entityType.typeName || this.entityType.name;
        delete this.paginationConfig[entityName];
    }
    /**
     * 获取分页信息
     */
    get pagination() {
        return this.paginationConfig;
    }
    /**
     * 获取分页信息
     * @param path 路径
     * @param defaultValue 默认值
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationConfig;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0);
        let config = this.paginationConfig;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 设置分页信息
     * @param path 路径
     * @param value 值
     */
    setPaginationConfigByPath(path, value) {
        if (!Array.isArray(path)) {
            path = path.toString().match(/[^/[\]]+/g) || [];
        }
        path.slice(0, -1).reduce((prev, current, index) => Object(prev[current]) === prev[current]
            ? prev[current]
            : prev[current] = Math.abs(path[index + 1]) >> 0 === +path[index + 1]
                ? []
                : {}, this.paginationConfig)[path[path.length - 1]] = value;
        return this.paginationConfig;
    }
    /**
     * 递归获取当前实体的所有NgList属性
     * @param defaultPageSize defaultPageSize
     */
    getNgListProperties(defaultPageSize = 0) {
        const getChilds = (objectType) => {
            const listProperties = FieldMetadataUtil.getNgList(objectType);
            let result = {};
            if (Object.keys(listProperties).length < 1) {
                return result;
            }
            Object.keys(listProperties).forEach(prop => {
                let itemTypeName = listProperties[prop].dataField;
                // 去掉尾部的s
                if (itemTypeName.endsWith('s')) {
                    itemTypeName = itemTypeName.substring(0, itemTypeName.length - 1);
                }
                result[itemTypeName] = {
                    pageSize: defaultPageSize
                };
                const child = getChilds(listProperties[prop].type);
                if (child !== null && Object.keys(child).length > 0) {
                    result = Object.assign({}, result, child);
                }
            });
            return result;
        };
        const childs = getChilds(this.entityType);
        const root = Object.assign({}, { pageSize: defaultPageSize }, childs);
        return root;
    }
}
PaginationManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PaginationManager.ctorParameters = () => [
    { type: undefined },
    { type: undefined }
];

class DataChangeHistory {
    constructor() {
        this.history = [];
    }
    addChange(dataChange) {
        const changeType = DataChangeType[dataChange.changeType];
        this[`on${changeType}Data`](dataChange);
    }
    addChanges(dataChange) {
        dataChange.forEach(change => this.addChange(change));
    }
    clear() {
        this.history.splice(0, this.history.length);
    }
    clearByIds(ids) {
        this.history = this.history.filter(item => {
            if (item.fpath && item.fpath !== '/' && item.fpath.includes('/')) {
                for (const id of ids) {
                    const include = item.fpath.split('/').includes(id);
                    return !include;
                }
            }
            else {
                return !ids.includes(item.dataId);
            }
        });
    }
    isChanged() {
        return this.history.length > 0;
    }
    onAddData(dataChange) {
        this.history.push(dataChange);
    }
    onDeleteData(dataChange) {
        const index = this.history.findIndex(item => item.dataId === dataChange.dataId && item.changeType === DataChangeType.Add);
        if (index >= 0) {
            this.history.splice(index, 1);
        }
        else {
            this.history.push(dataChange);
        }
    }
}

/**
 * 排序条件管理
 */
class SortConditionManager {
    constructor() {
        this.sorts = new Map();
    }
    /**
     * 根据bingdingPath获取排序规则
     * @param bindingPath bindingPath
     * @param directionConverter converter
     */
    getConditionsByBindingPath(bindingPath, directionConverter) {
        let conditions = this.sorts.get(bindingPath) || [];
        if (conditions.length < 1) {
            return conditions;
        }
        if (typeof directionConverter === 'function') {
            conditions = conditions.map(condition => {
                const sortType = directionConverter(condition.SortType);
                return { SortField: condition.SortField, SortType: sortType };
            });
        }
        return conditions;
    }
    /**
     * 增加排序条件
     * @param bindingPath 绑定路径
     * @param field 排序字段
     * @param direction 排序方向 asc|desc
     */
    addCondition(bindingPath, field, direction) {
        // 取消排序
        if (!field || !direction) {
            this.sorts.delete(bindingPath);
            return;
        }
        const isBindingPathExist = this.sorts.has(bindingPath);
        const condition = { SortField: field, SortType: direction };
        if (!isBindingPathExist) {
            this.sorts.set(bindingPath, [condition]);
        }
        else {
            const bindingPathSortConditions = this.sorts.get(bindingPath) || [];
            // new condition will override the previous condition
            const conditionIndex = bindingPathSortConditions.findIndex(item => item.SortField === field);
            if (conditionIndex !== -1) {
                bindingPathSortConditions[conditionIndex] = condition;
            }
            else {
                bindingPathSortConditions.push(condition);
            }
        }
    }
    removeCondition(bindingPath, field) {
        throw new Error('not implement!');
    }
    /**
     * 批量增加排序条件
     * @param bindingPath bindingPath
     * @param fields fields , seprated by comma
     * @param directions directions , seprated by comma
     * @description set conditions and overwrite all conditions which has the same bindingPath
     */
    setConditions(bindingPath, fields, directions) {
        // 取消排序
        if (!fields || !directions) {
            this.sorts.delete(bindingPath);
            return;
        }
        const filedsArray = fields.split(',').filter(item => item);
        const directionsArray = directions.split(',').filter(item => item);
        if (filedsArray.length !== directionsArray.length) {
            throw new Error('arguments error,fields and direction are not match.');
        }
        const conditions = [];
        filedsArray.forEach((field, index) => {
            const condition = { SortField: field, SortType: directionsArray[index] };
            conditions.push(condition);
        });
        this.sorts.set(bindingPath, conditions);
    }
    /**
     * 清空所有排序条件
     */
    clear() {
        this.sorts.clear();
    }
}

/**
 * 过滤条件管理器
 */
class FilterConditionManager {
    constructor() {
        this.filters = new Map();
    }
    /**
     * 获取过滤条件
     * @param bindingPath 绑定路径
     */
    getFilters(bindingPath) {
        return this.filters.get(bindingPath) || [];
    }
    /**
     * 自定义合并
     * @param bindingPath 绑定路径
     * @param merge 合并函数
     */
    mergeCondition(bindingPath, merge) {
        const conditions = this.filters.get(bindingPath) || [];
        const result = merge(conditions);
        this.filters.set(bindingPath, result);
    }
    /**
     * 增加过滤条件
     * @param bindingPath 绑定路径
     * @param condition 过滤条件
     */
    addCondition(bindingPath, condition) {
        // 通过bindingPath获取对应的过滤条件
        const conditions = this.filters.get(bindingPath);
        const index = this.findConditionIndex(bindingPath, condition);
        if (index !== -1) {
            conditions[index] = condition;
        }
        else {
            conditions.push(condition);
        }
    }
    /**
     * 批量增加过滤条件
     * @param bindingPath 绑定路径
     * @param conditions 过滤条件数组
     */
    addConditions(bindingPath, conditions) {
        if (!conditions || !Array.isArray(conditions) || conditions.length < 1) {
            return;
        }
        conditions.forEach(condition => {
            this.addCondition(bindingPath, condition);
        });
    }
    /**
     * 删除过滤条件
     * @param bindingPath 绑定路径
     * @param predicate 条件表达式
     */
    removeCondition(bindingPath, predicate) {
        const conditions = this.filters.get(bindingPath);
        if (!conditions || conditions.length < 1) {
            return;
        }
        const removes = conditions.filter(predicate);
        if (removes) {
            removes.forEach(condition => {
                const index = this.findConditionIndex(bindingPath, condition);
                if (index >= 0) {
                    conditions.splice(index, 1);
                }
            });
        }
    }
    /**
     * 清空过滤条件
     */
    clear() {
        this.filters.clear();
    }
    /**
     * 设置过滤条件数组
     * @param bindingPath 绑定路径
     * @param conditions 过滤条件数组
     */
    setConditions(bindingPath, conditions) {
        this.filters.set(bindingPath, conditions);
    }
    /**
     * 查找过滤条件索引
     * @param bindingPath 绑定路径
     * @param condition 过滤条件
     */
    findConditionIndex(bindingPath, condition) {
        if (!condition || typeof (condition) !== 'object' || Object.keys(condition).length < 1) {
            return -1;
        }
        const conditions = this.filters.get(bindingPath);
        if (!conditions || conditions.length < 1) {
            return -1;
        }
        return conditions.findIndex((value, index) => {
            let isEqual$$1 = true;
            const props = Object.keys(condition);
            for (const prop of props) {
                if (!(value && value.hasOwnProperty(prop) && value[prop] === condition[prop])) {
                    isEqual$$1 = false;
                    break;
                }
            }
            return isEqual$$1;
        });
    }
}

// tslint:disable: no-bitwise
// get uniqueId
class UID {
    static create(redix) {
        const timestamp = Date.now().valueOf();
        let uuid = 0;
        if (timestamp > UID.previous) {
            UID.previous = timestamp;
            uuid = timestamp;
        }
        else {
            UID.previous = UID.previous + 100;
            uuid = UID.previous;
        }
        return uuid.toString(redix);
    }
}
UID.previous = 0;

/**
 * 本地仓库
 * @description
 * # Repository
 *
 * Repository负责与后台接口交互并将接口返回的数据转换为Entity集合进行保存。因此Repository有两个重要的职责：后端交互、数据存储。
 * Repository中存储的数据是Entity类型，可以通过API对数据进行修改或删除。由于Repository和BindingData相互监听，对数据仓库的操作最终会通过BindingData更新到界面上。
 *
 * ## 实体操作
 * 实体操作仅对Repository本地已经存在的数据进行操作，不会发送请求。
 *
 * - 通过主键获取实体
 *
 *   ```javascript
 *    this.repository.entityCollection.getEntityById("id");
 *   ```
 *
 * - 删除实体数据
 *
 *   ```javascript
 *   this.repository.entityCollection.removeEntityById("id")
 *   ```
 *
 * - 清空所有实体
 *
 *   ```javascript
 *   this.repository.entityCollection.clear();
 *   ```
 *
 * - 将实体数据转换为json格式
 *
 *   ```javascript
 *   this.repository.entityCollection.toJSON();
 *   ```
 *
 * - 添加实体
 *
 *   ```javascript
 *   this.repository.entityCollection.addEntity(entity:T);
 *   ```
 * - 添加子表实体
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   entityManager.appendEntityByPath("/主实体Id/子表名s",{子表JSON数据});
 *   ```
 * - 批量添加实体
 *
 *   ```javascript
 *   this.repository.entityCollection.addEntities(entities:T[])
 *   ```
 *
 * - 批量添加子表实体
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   const childrenEntities = entityManager.createEntitiesByPath(["主实体Id","子表名s"], entityListData: any[])
 *   entityManager.appendEntitiesByPath(["主实体Id","子表名s"],childrenEntities);
 *   ```
 *
 * - 批量加载实体
 *
 *   ```javascript
 *   this.repository.entityCollection.loadEntities(entities:T[]);
 *   ```
 *
 *   > 加载实体会将本地仓库数据置为加载的实体。
 *
 * - 创建实体
 *
 *   ```javascript
 *   this.repository.buildEntity(JSON数据);
 *   ```
 *
 * - 批量创建实体
 *
 *   ```javascript
 *   this.repository.buildEntities(JSON数据);
 *   ```
 *
 * - 获取子表数据
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   entityManager.getEntityByPath(["主实体Id","子表名","子表id"]);
 *   ```
 *
 *   !> **注意** entityManager属性仅存在于BefRepository类，因此在使用EntityManager时应先将Repository转换为BefRepository
 *
 * - 获取所有子表数据
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   const entityManager = befRepository.entityManager;
 *   entityManager.getEntitiesByPath(["主实体Id","子表名"]);
 *   ```
 *
 *   > EntityManager不仅可以获取子表数据，同样可以获取主表数据。
 *   >
 *   > ```javascript
 *   > entityManager.getEntitiesByPath(["主实体Id"]);
 *   > ```
 *
 * - 获取实体属性值
 *
 *   ```javascript
 *   const entity = this.repository.entityCollection.getEntityById("id");
 *   cosnt name = entity['name'];
 *   // 或者
 *   const entity: any = this.repository.entityCollection.getEntityById("id");
 *   cosnt name = entity.name;
 *   ```
 *
 * ## 后端交互
 *
 * ​	通过接口操作后端数据，会直接对数据产生影响。
 *
 * - 更新实体数据
 *
 *   ```javascript
 *   this.repository.updateById('id');
 *   ```
 *
 * - 删除实体
 *
 *   ```javascript
 *   this.repository.removeById("id");
 *   ```
 *
 * - 批量删除实体
 *
 *   ```javascript
 *   this.repository.removeByIds(ids:string[])
 *   ```
 *
 * - 删除下级表数据
 *
 *   ```javascript
 *   this.repository.removeByPath(['主表Id','子表名','子表Id'])
 *   ```
 *
 * - 新增主实体
 *
 *   ```javascript
 *   this.repository.append();
 *   ```
 *
 * - 新增子实体
 *
 *   ```javascript
 *   this.repository.appendByPath(['主表id','子表名']);
 *   ```
 *
 * - 加载实体数据
 *
 *   ```javascript
 *   this.repository.getById('id');
 *   ```
 *
 * - 获取主表数据
 *
 *   ```javascript
 *   this.repository.getEntities(filter: any[], sorts: any[], pageSize: number | null, pageIndex: number | null)
 *
 *   ```
 *
 *   > pageSize、pageIndex可以不传。
 *
 * - 获取主表数据（POST方法）
 *
 *   ```javascript
 *   this.repository.filter(filter: any[], sorts: any[], pageSize: number | null, pageIndex: number | null)
 *   ```
 *
 * - 提交指定实体变更到后端
 *
 *   ```javascript
 *   this.repository.updateChangesById("id");
 *   ```
 *
 * - 提交所有变更
 *
 *   ```javascript
 *   this.repository.updateAllChanges();
 *   ```
 *
 * - 应用变更（保存）
 *
 *   ```javascript
 *   this.repository.applyChanges();
 *   ```
 *
 * - 取消变更
 *
 *   ```javascript
 *   this.repository.cancelChanges();
 *   ```
 *
 * - 清除Repository所有变更
 *
 *   ```javascript
 *   const befRepository = this.repository as BefRepository<any>;
 *   befRepository.entityManager.clearAllEntityChanges();
 *   ```
 *
 * - 批量新增子表数据
 *   ```javascript
 *   this.repository.batchAppendByPath(path: string, defaultValues: Array<any>);
 *   ```
 *
 *   > path `string`：/主表id/从表前端nodeCode，如果/1/orders
 *   >
 *   > defaultValues `Array<any>`：新增从表时的默认值，数组，元素为对象，key为字段名，value为默认值。
 *
 * - 批量删除子表数据
 *
 *   ```javascript
 *   this.repository.batchRemoveByPath(path: string, ids: string);
 *   ```
 *
 *   > path `string`： /主表id/从表前端nodeCode，如果/1/orders
 *   >
 *   > ids `string` ：要删除的子表数据id，格式为`id1,id2,id3`
 */
class Repository {
    // #endregion
    /**
     * 构造函数
     */
    constructor() {
        /**
         * 用户分页配置信息
         */
        this.paginationInfo = null;
        this.readMetadata();
        if (this.entityType) {
            this.entityTypeInfo = new DataTypeInfo(this.entityType);
            this.entityCollection = new EntityCollection(this.entityType);
        }
        this.dataChangeHistory = new DataChangeHistory();
        this.sortConditionManager = new SortConditionManager();
        this.filterConditionManager = new FilterConditionManager();
        this.destroy$ = new Subject();
    }
    // #endregion
    // #region get/set方法
    /**
     * 实体主键
     */
    get primaryKey() {
        return this.entityCollection.primaryKey;
    }
    get changes() {
        return this.entityCollection.changes;
    }
    /**
     * 实体变更集合
     */
    get entityCollectionChange() {
        return this.entityCollection.collectionChanged;
    }
    /**
     * 获取名称
     */
    get name() {
        // 1、老表单没有name属性
        // 2、不能使用construcotr.name，压缩脚本会把name改掉，或者压缩成相同的名称（目前发现已知）
        if (!this.innerName) {
            const guid = UID.create();
            this.innerName = `Repository_${guid}`;
        }
        return this.innerName;
    }
    /**
     * 设置名称
     */
    set name(value) {
        this.innerName = value;
    }
    dispose(options) {
        this.paginationManager = null;
        if (this.destroy$) {
            this.destroy$.next();
            this.destroy$.complete();
            this.destroy$ = null;
        }
        if (this.entityCollection) {
            this.entityCollection.reset(false);
            // this.entityCollection = null;
        }
    }
    ngOnDestroy() {
        this.dispose();
    }
    updateEntityType(entityType) {
        this.entityType = entityType;
        this.entityTypeInfo = new DataTypeInfo(this.entityType);
        this.entityCollection = new EntityCollection(this.entityType);
    }
    /**
     * 读取元数据
     */
    readMetadata() {
        const repositoryMetadata = MetadataUtil.getClassMetadataByName(this.constructor, 'NgRepository');
        if (repositoryMetadata) {
            // API地址
            this.apiUri = repositoryMetadata.apiUrl;
            // 实体类型
            this.entityType = repositoryMetadata.entityType;
        }
    }
    /**
     * 初始化分页配置
     * @param config - 用户分页配置
     */
    setPaginationConfig(config) {
        this.paginationManager = new PaginationManager(this.entityType, config);
        const { pageSize = 0 } = this.paginationManager.getPaginationConfigByPath('/') || {};
        // tslint:disable-next-line: max-line-length
        this.entityCollection.paginationInfo = Object.assign({ pageSize }, this.paginationManager.pagination, this.entityCollection.paginationInfo);
        // 无需再单独设置一次pageSize，减少一次变更
        // this.entityCollection.pageSize = pageSize;
    }
    /**
     * 重置状态
     */
    reset() {
        this.entityCollection.reset();
    }
    /**
     * 创建实体
     * @param data
     */
    buildEntity(data) {
        const entity = createEntity(this.entityType, data);
        return entity;
    }
    /**
     * 批量创建实体
     * @param listData
     */
    buildEntities(listData) {
        const entities = createEntities(this.entityType, listData);
        return entities;
    }
}
Repository.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Repository.ctorParameters = () => [];

/*
 * @Author: Witt
 * @Date: 2019-02-28 15:46:07
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-09-03 19:10:53
 */
/**
 * 空Repository实现
 */
class DefaultRepository extends Repository {
    constructor(injector) {
        super();
        this.injector = injector;
        // 初始化实体管理器
        this.entityManager = new EntityManager(this.entityCollection);
    }
    /**
     * 获取实体列表
     */
    getEntities(filter$$1, sorts, pageSize, pageIndex) {
        throw new Error('Not Implemented');
    }
    filter(filter$$1, sorts, pageSize, pageIndex) {
        throw new Error('Not Implemented');
    }
    /**
     * 获取实体列表
     */
    getList() {
        throw new Error('Not Implemented');
    }
    /**
     * 根据id获取实体
     * @param id 主实体id
     */
    getById(id) {
        throw new Error('Not Implemented');
    }
    /**
     * 根据id获取子表分页的实体
     * @param id 主实体id
     */
    getEntityById(id) {
        throw new Error('Not Implemented');
    }
    /**
     * 分页查询从表/从从表数据
     * @param path 绑定路径
     * @param ids 绑定路径对应的主键
     * @param filter 过滤条件
     * @param sort 排序
     */
    queryChild(paths, pageIndex, pageSize, filter$$1, sort) {
        throw new Error('Not Implemented');
    }
    /**
     * 根据id更新实体
     */
    updateById(id) {
        throw new Error('Not Implemented');
    }
    /**
     * 更新实体数据(子表分页)
     * @param id 实体主键
     */
    updateEntityById(id) {
        throw new Error('Not Implemented');
    }
    /**
     * 创建实体
     */
    create() {
        throw new Error('Not Implemented');
    }
    /**
     * 创建新实体，并追加到实体列表
     */
    append() {
        throw new Error('Not Implemented');
    }
    /**
     * 创建新的子实体，并追加到实体列表
     */
    appendByPath(path) {
        throw new Error('Not Implemented');
    }
    /**
     * 再指定位置插入数据
     * @param position 插入位置
     * @param defaultValue 默认值
     */
    insert(position, defaultValue) {
        throw new Error('Not Implemented');
    }
    /**
     * 在指定实体路径插入实体
     * @param path 实体路径
     * @param position 插入位置
     */
    insertByPath(path, position) {
        throw new Error('Not Implemented');
    }
    /**
     * 根据id删除对应实体
     */
    removeById(id, ifSave) {
        throw new Error('Not Implemented');
    }
    /**
     * 根据ids批量删除实体
     * @param ids ids
     * @param ifSave 是否保存
     */
    batchRemove(ids, ifSave) {
        throw new Error('Not Implemented');
    }
    /**
     * 根据ids批量删除实体
     */
    removeByIds(id, ifSave) {
        throw new Error('Not Implemented');
    }
    /**
     * 根据id删除path对应的后代实体
     */
    removeByPath(path, id) {
        throw new Error('Not Implemented');
    }
    /**
     * 提交id对应的根实体变更
     */
    updateChangesById(id) {
        throw new Error('Not Implemented');
    }
    /**
     * 提交path对应的实体变更
     */
    updateChangesByPath(path, id) {
        throw new Error('Not Implemented');
    }
    /**
     * 更新所有变更
     */
    updateAllChanges() {
        throw new Error('Not Implemented');
    }
    /**
     * 应用服务器端变更
     */
    applyChanges() {
        throw new Error('Not Implemented');
    }
    /**
     * 保存id对应数据的变更
     */
    applyChangesById(id) {
        throw new Error('Not Implemented');
    }
    /**
     * 取消变更集
     */
    cancelChanges(options) {
        throw new Error('Not Implemented');
    }
    /**
     * 批量删除子表
     */
    batchRemoveByPath(path, ids) {
        throw new Error('Not Implemented');
    }
    /**
     * 批量新增从表/从从表数据
     * @param path 实体绑定路径，like 1/childs or 1/childs/11/childchilds
     * @param defaultValues 默认实体数据数组
     */
    batchAppendByPath(path, defaultValues) {
        throw new Error('Not Implemented');
    }
    /**
     * 批量新增主表数据
     * @param path 实体绑定路径，like 1/childs or 1/childs/11/childchilds
     * @param defaultValues 默认实体数据数组
     */
    batchAppend(defaultValues) {
        throw new Error('Not Implemented');
    }
    hasChanges() {
        throw new Error('Not Implemented');
    }
}
DefaultRepository.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DefaultRepository.ctorParameters = () => [
    { type: Injector }
];

/* eslint-disable new-cap */
class EntityDependencyResolver {
    constructor(repository) {
        this.repository = repository;
        this.entityTypeInfo = this.repository && this.repository.entityTypeInfo || null;
    }
    /**
     * 解析用户表达式中的实体依赖
     * @param expr 用户配置的完整表达式
     * @returns
     */
    resolve(expr) {
        const groupFunctionDependencies = ExpressionUtil.getGroupFunctionDependency(expr, this.repository.entityTypeInfo);
        const entityDependencies = this.getEntityDependency(expr);
        // 去除错误的到子表的依赖
        if (groupFunctionDependencies && groupFunctionDependencies.length > 0 && entityDependencies && entityDependencies.length > 0) {
            groupFunctionDependencies.forEach((dep) => {
                const index = entityDependencies.findIndex((item) => dep.startsWith(item));
                if (index !== -1) {
                    entityDependencies.splice(index, 1);
                }
            });
        }
        // 去重
        const merged = [...groupFunctionDependencies, ...entityDependencies];
        const deps = [...new Set(merged)];
        return deps;
    }
    /**
     * 获取合法的实体属性表达式
     * @param entityPropertyExpression 实体属性表达式
     * @returns
     */
    getValidEntityPropertyExpression(entityPropertyExpression) {
        const propPaths = entityPropertyExpression.split('.');
        let propInfo = null;
        try {
            propInfo = this.entityTypeInfo.getPropInfoByPath(propPaths);
        }
        catch (e) { }
        if (!propInfo) {
            if (propPaths.length > 1) {
                propPaths.pop();
                return this.getValidEntityPropertyExpression(propPaths.join('.'));
            }
            else {
                return null;
            }
        }
        else {
            return entityPropertyExpression.split('.');
        }
    }
    /**
     * 获取所有实体依赖
     * @param expr 表达式字符串
     * @returns
     */
    getEntityDependency(expr) {
        const deps = [];
        if (this.entityTypeInfo) {
            // 使用正则匹配出所有实体
            const regex = new RegExp(`[\\'\\"]?\\s*(${this.entityTypeInfo.entityInfo.nodeCode}|${this.entityTypeInfo.entityInfo.originalCode})[\\.\\[\\]a-zA-Z0-9_]+\\s*[\\'\\"]?`, 'g');
            const entityPropertyExpressions = expr.match(regex);
            if (Array.isArray(entityPropertyExpressions) && entityPropertyExpressions.length > 0) {
                // 解析出所有实体相关的字符串，以主实体名字开头，包含主实体属性或子表
                entityPropertyExpressions.forEach((item) => {
                    if (item.indexOf('.') === -1) {
                        return;
                    }
                    // 去空格
                    item = item.trim().replace(/\"/g, '');
                    const paths = ExpressionUtil.convertToNodeCode(item, this.repository.entityTypeInfo);
                    item = paths.join('.');
                    // 截去主实体及点
                    item = item.substr(item.indexOf('.') + 1);
                    const dep = this.getValidEntityPropertyExpression(item);
                    if (dep && Array.isArray(dep) && dep.length > 0) {
                        // 此处必须加上主实体的名字来区分依赖的是实体还是其他类型的数据
                        dep.splice(0, 0, ENTITY_TEMPLATE);
                        deps.push(dep.join('/'));
                    }
                });
            }
        }
        return deps;
    }
}
EntityDependencyResolver.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EntityDependencyResolver.ctorParameters = () => [
    { type: Repository }
];

const CONTEXT_FUNCTIONS = ['GetContextParameter', 'GetSessionValue'];
class StateDependencyResolver {
    resolve(expr) {
        const deps = [];
        const regex = new RegExp(`DefaultFunction\\.(${CONTEXT_FUNCTIONS.join('|')})\\s*\\([^\\r\\n\\)]*\\)`, 'g');
        const contextFunctions = expr.match(regex);
        if (contextFunctions && contextFunctions.length > 0) {
            // todo: 使用正则匹配时可能会因为参数中有逗号导致问题，后续使用ast解析
            const argumentsRegex = /\(([^\r\n\)]*)\)/;
            contextFunctions.forEach((groupFunction) => {
                const argumentMatchResult = groupFunction.match(argumentsRegex);
                if (argumentMatchResult.length === 2) {
                    const argument = argumentMatchResult[1].trim().replace(/\"/g, '');
                    const dep = ['STATE~'];
                    dep.push(argument);
                    deps.push(dep.join('/'));
                }
            });
        }
        return deps;
    }
}

/**
 * 用户自定义参数解析器
 */
class CommentDependencyResolver {
    resolve(expr) {
        const dependencies = [];
        if (!expr || expr.length < 1) {
            return dependencies;
        }
        const defineRegex = /\/\*\*\s*__define__\((.*)\)\s*\*\//;
        const defineMatchArray = expr.match(defineRegex);
        if (defineMatchArray && defineMatchArray.length === 2) {
            const defineString = defineMatchArray[1].trim();
            let defineObject = null;
            try {
                defineObject = JSON.parse(defineString);
            }
            catch (e) {
                console.warn(`自定义依赖解析失败：${defineString}`);
            }
            if (defineObject && defineObject.hasOwnProperty('deps') && Array.isArray(defineObject['deps'])) {
                dependencies.push(...defineObject['deps']);
            }
        }
        return dependencies;
    }
}
CommentDependencyResolver.decorators = [
    { type: Injectable }
];

class ResolveService {
    constructor(injector, resolverRegistry) {
        this.injector = injector;
        this.resolverRegistry = resolverRegistry;
    }
    resolve(expression) {
        const deps = [];
        if (!this.resolverRegistry || !this.resolverRegistry.resolvers || this.resolverRegistry.resolvers.length < 1) {
            return;
        }
        // 优先使用用户自定义的依赖
        const commentDependencyResolver = this.resolverRegistry.resolvers.find((resolver) => resolver instanceof CommentDependencyResolver);
        if (commentDependencyResolver) {
            const commentDependencies = commentDependencyResolver.resolve(expression);
            if (commentDependencies && Array.isArray(commentDependencies) && commentDependencies.length > 0) {
                deps.push(...commentDependencies);
            }
        }
        // 如果用户已经自定义了依赖，则不再计算
        if (deps && deps.length > 0) {
            return deps;
        }
        this.resolverRegistry.resolvers.forEach((resolver) => {
            // 再解析一次也可以，返回的依然是空数组
            if (resolver instanceof CommentDependencyResolver) {
                return;
            }
            const dependency = resolver.resolve(expression);
            if (dependency && dependency.length > 0) {
                deps.push(...dependency);
            }
        });
        // 去重
        return [...new Set(deps)];
    }
}
ResolveService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ResolveService.ctorParameters = () => [
    { type: Injector },
    { type: ResolverRegistry }
];

// export * from './resolver';

class ExpressionUtil {
    static getGroupFunctionDependency(expr, entityTypeInfo) {
        const deps = [];
        // 获取聚合函数依赖项
        const groupFunctionRegex = new RegExp(`DefaultFunction\\.(${GROUP_FUNCTIONS.join('|')})\\s*\\([^\\r\\n\\)]*\\)`, 'g');
        const groupFunctions = expr.match(groupFunctionRegex);
        if (groupFunctions && groupFunctions.length > 0) {
            // todo: 使用正则匹配时可能会因为参数中有逗号导致问题，后续使用ast解析
            const argumentsRegex = /\(([^\r\n\)]*)\)/;
            const methodNameRegex = /DefaultFunction\.(\S*)\(/;
            groupFunctions.forEach((groupFunction) => {
                const argumentMatchResult = groupFunction.match(argumentsRegex);
                const methodNameMatchResult = groupFunction.match(methodNameRegex);
                let methodName = null;
                if (methodNameMatchResult && methodNameMatchResult.length == 2) {
                    methodName = methodNameMatchResult[1];
                }
                if (argumentMatchResult.length === 2) {
                    const argument = argumentMatchResult[1];
                    const args = argument.split(',').map((p) => p.replace(/\"/g, ''));
                    if (args && args.length === 2) {
                        let item = args.join('.');
                        item = this.convertToNodeCode(item, entityTypeInfo).join('.');
                        // 移除主表code
                        item = item.substr(item.indexOf('.') + 1);
                        const dep = item.split('.');
                        dep.splice(0, 0, ENTITY_TEMPLATE);
                        deps.push(dep.join('/'));
                    }
                    else if (args && args.length === 3) {
                        if (methodName === 'MultiplyChildNumber') {
                            // support MultiplyChildNumber
                            // [Entity.childrens,prop1,prop2]
                            const prefix = args[0]; // like Entity.childrens
                            // const tableName = args[0];// prefix.substring(prefix.indexOf('.')+1);
                            const prop1FullPath = `${prefix}.${args[1]}`;
                            const prop2FullPath = `${prefix}.${args[2]}`;
                            [prop1FullPath, prop2FullPath].forEach((item) => {
                                item = this.convertToNodeCode(item, entityTypeInfo).join('.');
                                item = item.substr(item.indexOf('.') + 1);
                                const dep = item.split('.');
                                dep.splice(0, 0, ENTITY_TEMPLATE);
                                deps.push(dep.join('/'));
                            });
                        }
                        else if (methodName === 'IsContainMatch' || methodName === 'SortChildData') {
                            // [Entity.childrens,prop1,prop2]
                            const prefix = args[0]; // like Entity.childrens
                            // const tableName = args[0];// prefix.substring(prefix.indexOf('.')+1);
                            let item = `${prefix}.${args[1]}`;
                            item = this.convertToNodeCode(item, entityTypeInfo).join('.');
                            item = item.substr(item.indexOf('.') + 1);
                            const dep = item.split('.');
                            dep.splice(0, 0, ENTITY_TEMPLATE);
                            deps.push(dep.join('/'));
                        }
                    }
                    else if (args && args.length === 4) ;
                    else if (args && args.length === 5) {
                        if (['MinValueOfPeriod', 'MaxValueOfPeriod', 'AvgValueOfPeriod'].includes(methodName)) {
                            // [Entity.childrens,prop1,prop2]
                            const prefix = args[0]; // like Entity.childrens
                            // const tableName = args[0];// prefix.substring(prefix.indexOf('.')+1);
                            const prop1FullPath = `${prefix}.${args[1]}`;
                            const prop2FullPath = `${prefix}.${args[2]}`;
                            [prop1FullPath, prop2FullPath].forEach((item) => {
                                item = this.convertToNodeCode(item, entityTypeInfo).join('.');
                                item = item.substr(item.indexOf('.') + 1);
                                const dep = item.split('.');
                                dep.splice(0, 0, ENTITY_TEMPLATE);
                                deps.push(dep.join('/'));
                            });
                        }
                    }
                    else {
                        throw new Error(`无法解析参数： ${JSON.stringify(argument)}`);
                    }
                }
            });
        }
        return deps;
    }
    /**
     * 将voCode转换为前端nodeCode
     * @param entityExpression like Entity.Child.p1
     * @returns
     */
    static convertToNodeCode(entityExpression, entityTypeInfo) {
        // UserEntity.storys.p1
        const nodeCodes = [];
        if (entityTypeInfo && entityExpression.includes('.')) {
            const entityExpressions = entityExpression.split('.') || [];
            let dataTypeInfo = entityTypeInfo;
            for (let index = 0; index < entityExpressions.length; index++) {
                const prop = entityExpressions[index];
                if (dataTypeInfo && dataTypeInfo.entityInfo && dataTypeInfo.entityInfo.nodeCode === prop || dataTypeInfo.entityInfo.originalCode === prop) {
                    // 第一个是主表code，不能转nodeCode
                    if (index === 0) {
                        nodeCodes.push(dataTypeInfo.entityInfo.originalCode);
                    }
                    else {
                        nodeCodes.push(dataTypeInfo.entityInfo.nodeCode);
                    }
                    // 下一级可能为子表、对象或属性
                    const nextNodeCode = entityExpressions[index + 1];
                    if (!nextNodeCode) {
                        break;
                    }
                    const nextNodeCodePropInfo = dataTypeInfo.getPropInfoByName(nextNodeCode);
                    if (!nextNodeCodePropInfo) {
                        break;
                    }
                    // 下一级为子表或对象
                    if (nextNodeCodePropInfo.typeInfo) {
                        dataTypeInfo = nextNodeCodePropInfo.typeInfo;
                    }
                }
                else if (dataTypeInfo && dataTypeInfo.getPropInfoByName(prop)) {
                    const dataPropInfo = dataTypeInfo.getPropInfoByName(prop);
                    nodeCodes.push(dataPropInfo.name);
                }
                else {
                    // throw new Error(`错误的属性参数 ${entityExpression}`);
                    break;
                }
            }
        }
        return nodeCodes;
    }
    /**
     * 找到元数据中所有实体路径
     * @param dataTypeInfo
     * @param results
     * @param paths
     */
    static getChildrenEntityPaths(dataTypeInfo, results, paths = []) {
        const list = dataTypeInfo.getPropInfosByGroup(DataPropGroup.List);
        if (list && list.length > 0) {
            list.forEach((dataPropInfo) => {
                if (paths.length === 0) {
                    results.push([dataPropInfo.name]);
                }
                const childrens = dataPropInfo.typeInfo.getPropInfosByGroup(DataPropGroup.List);
                if (childrens && childrens.length > 0) {
                    paths.push(dataPropInfo.name);
                    childrens.forEach((dataPropInfo) => {
                        this.getChildrenEntityPaths(dataPropInfo.typeInfo, results, paths);
                    });
                }
                else {
                    if (paths.length !== 0) {
                        paths.push(dataPropInfo.name);
                        results.push([...paths]);
                    }
                    paths.length = 0;
                }
            });
        }
        else {
            if (paths.length > 0) {
                paths.push(dataTypeInfo.entityInfo.nodeCode);
                results.push([...paths]);
            }
            paths.length = 0;
        }
    }
    /**
     * 获取指定绑定路径的当前行数据
     * @param paths 绑定路径
     * @param bindingData
     * @returns
     */
    static getCurrentRowByPaths(paths, bindingData) {
        let result = null;
        const bindingList = bindingData.getValue(paths);
        if (bindingList && bindingList.length > 0) {
            const primaryValue = bindingList.currentItem.primaryKeyValue || null;
            // 使用事件中的主键
            // 主表或下级表新增，此时事件行就是当前行，无需处理
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
    /**
     * 从实体路径中获取级数最大的从表或从从表
     * @param paths
     * @returns
     */
    static getAvailableChildrenPathsFromEntityPaths(paths, entityTypeInfo) {
        let nodeCodes = [];
        paths = [...paths];
        while (paths.length > 0) {
            const dataPropInfo = entityTypeInfo.getPropInfoByPath(paths);
            if (dataPropInfo && dataPropInfo.group === 'List') {
                nodeCodes = paths;
                break;
            }
            paths.pop();
        }
        return nodeCodes;
    }
    /**
     * 从路径中获取绑定路径
     * @param paths 路径
     * @param entityTypeInfo entityTypeInfo
     * @returns
     */
    static getBindingPath(paths, entityTypeInfo) {
        paths = this.getEntityPath(paths);
        const entityPaths = this.getAvailableChildrenPathsFromEntityPaths(paths, entityTypeInfo);
        return entityPaths;
    }
    static getEntityPath(path) {
        const paths = path.filter((value, index) => {
            if (index % 2 === 0 && value.includes(':')) {
                return false;
            }
            else {
                return true;
            }
        });
        return paths;
    }
}

class DataTypeInfoUtil {
    /**
     * 递归获取实体的所有下级实体编号
     * @param dataTypeInfo
     * @param results
    */
    static getChildrenNodeCodes(dataTypeInfo, results = []) {
        const list = dataTypeInfo.getPropInfosByGroup(DataPropGroup.List);
        if (list && list.length > 0) {
            list.forEach((dataPropInfo) => {
                results.push(dataPropInfo.name);
                const childrens = dataPropInfo.typeInfo.getPropInfosByGroup(DataPropGroup.List);
                if (childrens && childrens.length > 0) {
                    childrens.forEach((dataPropInfo) => {
                        results.push(dataPropInfo.name);
                        this.getChildrenNodeCodes(dataPropInfo.typeInfo, results);
                    });
                }
            });
        }
    }
}

// tslint:disable: max-line-length
/**
 * 表单定义
 */
class Form extends FormGroup {
    /**
     * 构造函数
     */
    constructor() {
        super({}, null, null);
        this.raisedByValidateEffector = false;
        this.isShowValidationMsg = false;
        this.validatorJs = ValidatorJS__default;
        this.controlIdMap = {};
        this.cardControls = {};
        this.isShowPropMap = {};
        this.destroy$ = new Subject();
        // this.excludeRuleTypes = {};
    }
    /**
     * 名称
     */
    get formGroupName() {
        return this.ngValidateForm ? this.ngValidateForm.formGroupName : '';
    }
    /**
     * 是否启用表单验证
     */
    get enableValidate() {
        return this.ngValidateForm ? this.ngValidateForm.enableValidate : false;
    }
    get translateService() {
        return this.translate;
    }
    ngOnDestroy() {
        this.dispose();
    }
    dispose(options) {
        if (this.destroy$) {
            this.destroy$.next();
            this.destroy$.complete();
            this.destroy$ = null;
        }
        Form.insMap[this.constructor.name] = null;
        this.frameContext = null;
        this.bindingData = null;
        this.ngChildForms = null;
        this.metaDatas = null;
        this.ngFormControls = {};
        this.controls = {};
        this.disposeValidation();
    }
    /**
     * 将formControl的错误信息更新到cardControl上
     */
    static updateErrors(propertyName, errorObj, id, value, isGrid) {
        Object.keys(Form.insMap).forEach(key => {
            const form = Form.insMap[key];
            if (!form) {
                return;
            }
            if (id) {
                form.setControlValue(propertyName, value);
            }
            if (form.enableValidate) {
                form.isFormValid(propertyName, errorObj, id, isGrid);
            }
        });
    }
    /**
     * 设置dom属性为显示状态
     * @param domPropertyName dom属性
     */
    setIsShowmap(domPropertyName) {
        this.isShowPropMap[domPropertyName] = true;
    }
    setShowValidationMsg(flag) {
        this.raisedByValidateEffector = false;
        this.isShowValidationMsg = flag;
    }
    setControlValue(key, value) {
        const bindingObject = this.bindingData && this.bindingData.getObject() || null;
        if (bindingObject && bindingObject.controlMap) {
            bindingObject.controlMap[key] = this.getGridItemControl(key, value);
        }
    }
    /**
     * 根据dom属性名称获取错误信息
     * @param domPropertyName dom属性名称
     */
    getCardControlErrors(domPropertyName) {
        this.setIsShowmap(domPropertyName);
        return this.cardControls[domPropertyName] && this.cardControls[domPropertyName].errors;
    }
    /**
     * 获取字段校验错误
     * @param domPropertyName
     * @returns
     */
    getFormControlErrors(domPropertyName) {
        return this.cardControls[domPropertyName] && this.cardControls[domPropertyName].errors;
    }
    getGridControlErrors(domPropertyName, id) {
        this.setIsShowmap(domPropertyName);
        return this.controlIdMap[id] && this.controlIdMap[id][domPropertyName] && this.controlIdMap[id][domPropertyName]['errors'];
    }
    isFormValid(propertyName, errorObj, id, isGrid) {
        let prefix = '';
        // 如果校验信息是由表达式触发的，不处理
        if (this.raisedByValidateEffector) {
            return;
        }
        const isGridComponent = this.frameContext.frameComponent.isGridComponent;
        if (isGridComponent !== undefined) {
            isGrid = isGridComponent;
        }
        //拼接子表frontNodeCode
        const bindingPaths = this.bindingPath.split('/').filter(p => p);
        if (bindingPaths.length > 0) {
            prefix = bindingPaths.join('.').concat('.');
        }
        // 界面上绑定的字段名
        const domPropertyName = this.getDomPropertyNameByEntityProp(propertyName, prefix);
        // 传了属性名，但却拿不到dom名称，说明当前组件中没有该字段对应的控件
        if (propertyName && !domPropertyName) {
            return true;
        }
        // 若界面上不存在当前属性（动态列），不进行验证
        if (domPropertyName && !this.isShowPropMap[domPropertyName]) {
            return true;
        }
        let isValid = true;
        const bindingObject = this.bindingData.getObject();
        const currentId = bindingObject.primaryKeyValue;
        const isSubForm = this.bindingPath !== '/';
        const bindingList = this.bindingData.getList();
        // 子表单无数据时，保存时会有一条空数据阻碍验证，所以此处跳过只有一行的情况
        if (isSubForm && bindingList.innerList.size === 0) {
            return true;
        }
        // 无数据时不做校验
        if (!currentId) {
            return true;
        }
        // dataGrid修改时，根据id，创建formControl，并设置错误对象
        if (id && domPropertyName) {
            // if (this.controlIdMap[id] && Object.keys(this.controlIdMap[id]).length === 0) {
            //   this.controlIdMap[id] = {};
            // }
            this.controlIdMap[id] = this.controlIdMap[id] || {};
            this.controlIdMap[id][domPropertyName] = {
                errors: errorObj
            };
        }
        // 将grid的FormControl同步到界面展示用的controlIDMap中
        // const currentBindingObject = bindingList.currentItem as BindingObject;
        const currentBindingObject = bindingObject;
        if (id && id !== currentId) {
            return;
        }
        // 验证全部字段时，清空已有的错误信息
        if (!propertyName && !id) {
            currentBindingObject.controlMap = {};
            this.controlIdMap = {};
            this.cardControls = {};
        }
        Object.keys(this.controls).forEach((key) => {
            if (this.isShowPropMap[key] !== true) {
                return;
            }
            // 同步实体错误信息
            if (key === domPropertyName) {
                // 实体验证的信息直接赋值
                if (errorObj && Object.keys(errorObj).length > 0) {
                    // 卡片的错误
                    if (!isGrid) {
                        // 实体层同步过来的错误，目前结构{ruleType:{name:'',value:'',originalErrors:[ValidationError]}}，其中name为校验失败的错误信息
                        // 遍历错误，将validator返回的错误信息国际化
                        Object.keys(errorObj).map((validType) => {
                            const validationError = errorObj[validType] && errorObj[validType]['error'] || null;
                            if (validationError) {
                                const validateRule = validationError.rule;
                                const ngFormControl = this.getngFormControlByBinding(validateRule.field);
                                if (ngFormControl) {
                                    validateRule.property = ngFormControl.name || ngFormControl.defaultI18nValue;
                                    validateRule.targetId = ngFormControl.id;
                                    validateRule.targetName = this.formGroupName;
                                    // 修正校验必填表达式类型和多语资源中key不一致的问题
                                    const fixedValidType = validType === 'require' ? 'required' : validType;
                                    const messageTemplate = ValidationTypes.getMessage(fixedValidType);
                                    if (messageTemplate) {
                                        const invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, validateRule, ngFormControl.name);
                                        errorObj[validType]['name'] = invalidMessage;
                                    }
                                }
                                // todo: ngFormControl暂时不设置
                                // errorObj['name'] = this.getErrorByRuleType(validType, validateRule, null);
                            }
                        });
                        this.cardControls[key] = {
                            errors: errorObj
                        };
                    }
                }
                else {
                    this.cardControls[key] = {};
                }
            }
            if (this.controls[key] && this.controls[key].errors && Object.keys(this.controls[key].errors).length > 0) {
                // 将错误同步到界面展示的位置
                // 认为控件错误只包含错误类型，通过错误类型获取具体的错误信息
                this.cardControls[key] = {
                    errors: Object.assign({}, this.cardControls[key] && this.cardControls[key].errors, this.controls[key].errors)
                };
                isValid = false;
            }
        });
        // 处理只开启前端校验，未在BE上启用必填校验的情况
        if (this.cardControls) {
            Object.keys(this.cardControls).forEach(key => {
                if (this.cardControls[key] && this.cardControls[key].errors) {
                    Object.keys(this.cardControls[key].errors).forEach(validType => {
                        if (typeof this.cardControls[key].errors[validType] !== 'object') {
                            // 获取对应的校验信息
                            const validateRules = this.ngFormControls[key].validRules || [];
                            const rules = [].concat(validateRules);
                            const validateRule = rules.find(item => item.type === validType);
                            if (validateRule) {
                                validateRule.targetName = this.formGroupName;
                                const messageTemplate = ValidationTypes.getMessage(validType);
                                const invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, validateRule, '');
                                this.cardControls[key].errors[key] = { value: this.controls[key] && this.controls[key].value || '', name: invalidMessage };
                            }
                        }
                    });
                }
            });
        }
        Object.keys(this.cardControls).forEach((key) => {
            if (this.cardControls[key] && this.cardControls[key].errors && Object.keys(this.cardControls[key].errors).length > 0) {
                isValid = false;
            }
        });
        return isValid;
    }
    /**
     * 更新表单错误信息
     * @param errors 错误消息
     */
    updateFormErrors(errors, forceShow = false, from$$1 = '') {
        if (from$$1 && from$$1 === 'backend') {
            this.clearBackendError();
        }
        // 原来是否已经显示错误，如果已经显示了则增加，否则替换
        if (this.isShowValidationMsg === true || forceShow === true) {
            this.isShowValidationMsg = true;
            Object.keys(errors).forEach((key) => {
                if (errors[key].errors && Object.keys(errors[key].errors).length > 0) {
                    // 如果控件本身没有错误，则直接使用外部传递过来的错误，否则合并错误
                    this.cardControls[key] = {
                        errors: Object.assign({}, this.cardControls[key] && this.cardControls[key].errors, errors[key].errors)
                    };
                }
                else {
                    // 移除内存中的错误信息
                    this.cardControls[key] = {
                        errors: {}
                    };
                    // 重置控件错误信息
                    this.controls[key].setErrors(null);
                    this.controls[key].markAsTouched();
                }
            });
        }
    }
    /**
     * 清空后端消息
     */
    clearBackendError() {
        Object.keys(this.cardControls).forEach(key => {
            const errors = this.cardControls[key] && this.cardControls[key].errors || null;
            if (errors) {
                Object.keys(errors).forEach(errorType => {
                    if (errorType && errorType.startsWith('backend-message-')) {
                        delete errors[errorType];
                    }
                });
                if (errors && Object.keys(errors).length === 0) {
                    delete this.cardControls[key].errors;
                }
            }
            else {
                this.cardControls[key] = {};
            }
        });
    }
    /**
     * 根据实体属性获取ngFormControl
     * @param binding 控件绑定的实体属性名
     */
    getngFormControlByBinding(binding) {
        return Object.values(this.ngFormControls).find((ngFormControl) => ngFormControl.binding && ngFormControl.binding === binding);
    }
    disposeValidation() {
        const properties = this.constructor[PROP_METADATA];
        if (properties && Object.keys(properties).length > 0) {
            Object.keys(properties).forEach((key) => {
                const props = this.constructor[PROP_METADATA][key];
                if (props && props.length > 0) {
                    props.forEach((item) => {
                        if (item.validRules && Array.isArray(item.validRules) && item.validRules.length > 0) {
                            item.validRules = item.validRules.filter(item => !(item.eval && typeof (item.eval) === 'function'));
                        }
                    });
                }
            });
        }
    }
    /**
     * 根据dom属性和校验类型获取错误信息
     * @param domProperty dom属性
     * @param validateRuleType 校验类型
     */
    getErrorMessage(domProperty, validateRuleType) {
        const formControl = this.ngFormControls[domProperty];
        if (formControl) {
            const validRules = formControl.validRules;
            const rules = [];
            if (!Array.isArray(validRules)) {
                rules.push(validRules);
            }
            else {
                rules.push(...validRules);
            }
            const rule = rules.find(item => item.type === validateRuleType);
            if (rule) {
                const controlName = formControl.name;
                const messageTemplate = ValidationTypes.getMessage(validateRuleType);
                const message = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, rule, controlName);
                return message;
            }
            return null;
        }
        return null;
    }
    /**
     * 初始化Form
     * @param context 上下文
     */
    init(bindingData, bindingPath, frameContext) {
        this.frameContext = frameContext;
        this.bindingData = bindingData;
        this.bindingPath = bindingPath;
        // 校验信息变化时重置卡片校验信息
        if (this.frameContext && this.frameContext.viewModel && this.frameContext.viewModel.verifycationChanged) {
            this.frameContext.viewModel.verifycationChanged.subscribe((verifycations) => {
                if (!verifycations || verifycations.length < 1) {
                    this.resetCardValidMsg();
                }
            });
        }
        this.buildForm();
        // @todo: 这种方式做key，如果脚本被压缩，存在风险
        Form.insMap[this.constructor.name] = this;
    }
    /**
     * 构造表单
     */
    buildForm() {
        this.collectMetadatas();
        // this.createChildFormArrays();
        this.createChildForms();
        this.createControls();
    }
    /**
     * 重置表单验证信息
     */
    resetCardValidMsg() {
        this.cardControls = {};
        // 剔除 列表中新增后取消,删除的项对应的control信息
        Object.keys(this.controlIdMap).forEach(id => {
            if (!this.bindingData.getList().innerList.map(x => x.id).includes(id)) {
                delete this.controlIdMap[id];
            }
        });
        this.resetFormControls();
        this.setShowValidationMsg(false);
    }
    /**
     * 更新字段校验规则
     * @param propertyName 属性名
     * @param isRequired 是否必填
     */
    updateFieldValidateRule(propertyName, isRequired) {
        if (!propertyName) {
            return;
        }
        const formControl = this.controls[propertyName];
        // 清空全部校验条件
        if (formControl) {
            formControl.clearValidators();
            formControl.markAsUntouched();
            formControl.markAsPristine();
            formControl.setErrors([]);
        }
        // 动态必填场景时生成器不再在formControl上生成必填规则
        // 因此validRules可能为空
        const ngFormControl = this.ngFormControls[propertyName];
        let validateRules = ngFormControl && ngFormControl.validRules || [];
        if (!Array.isArray(validateRules)) {
            validateRules = [validateRules];
        }
        const requiredRuleIndex = validateRules.findIndex((validateRule) => validateRule.type === ValidationTypes.REQUIRED);
        if (isRequired) {
            // 必填但控件没有必填规则，添加必填规则
            if (requiredRuleIndex == -1) {
                const validateRule = { type: ValidationTypes.REQUIRED, constraints: [true] };
                // 扩展属性，以生成正确的错误提示
                const displayFieldName = ngFormControl && (ngFormControl.name || ngFormControl.defaultI18nValue) || '';
                validateRule.targetId = ngFormControl && ngFormControl.id || null;
                validateRule.targetName = this.formGroupName;
                validateRule.property = displayFieldName;
                validateRule.field = ngFormControl && ngFormControl.binding;
                validateRules.push(validateRule);
            }
        }
        else {
            // 非必填场景，如果有必填规则，移除
            if (requiredRuleIndex !== -1) {
                validateRules.splice(requiredRuleIndex, 1);
            }
        }
        // 整理校验规则
        const validators = [];
        Array.prototype.forEach.call(validateRules, ((ruleObj) => {
            const validateFn = this.getValidatorByRuleObj(ruleObj, this.ngFormControls[propertyName]);
            if (validateFn) {
                validators.push(validateFn);
            }
        }));
        this.ngFormControls[propertyName].validRules = validateRules;
        this.controls[propertyName].setValidators(validators);
    }
    addFieldValidateRule(propertyName, message, expressionId, ruleType) {
        const formControl = this.controls[propertyName];
        if (formControl) {
            // 清空全部校验条件
            formControl.setErrors(null);
        }
        const ngFormControl = this.ngFormControls[propertyName];
        let validateRules = this.ngFormControls[propertyName].validRules;
        if (!validateRules) {
            validateRules = [];
        }
        if (!Array.isArray(validateRules)) {
            validateRules = [validateRules];
        }
        const index = validateRules.findIndex((rule) => rule && rule.expressionId === expressionId);
        if (index !== -1) {
            validateRules.splice(index, 1);
        }
        const bindingPath = this.frameContext.viewModel.bindingPath;
        const bindingPaths = bindingPath.split('/').filter(p => p);
        if (bindingPaths.length !== 0) {
            const prefix = bindingPaths.join('/');
            const binding = ngFormControl.binding || '';
            const property = binding.split('.').join('/');
        }
        const context = this.frameContext;
        const validateRule = {
            type: ruleType,
            message: message,
            expressionId: expressionId,
            constraints: [],
            bindingPath: bindingPaths.join('/'),
            eval: function (options) {
                return context.viewModel.expression.validate(expressionId, options);
            }
        };
        validateRules.push(validateRule);
        this.ngFormControls[propertyName].validRules = validateRules;
        // if (this.ngFormControls[propertyName] && validateRules.length > 0) {
        //   const validators: ValidatorFn[] = [];
        //   Array.prototype.forEach.call(validateRules, ((ruleObj: ValidateRule) => {
        //     const validateFn = this.getValidatorByRuleObj(ruleObj, this.ngFormControls[propertyName]);
        //     if (validateFn) {
        //       validators.push(validateFn);
        //     }
        //   }));
        //   this.controls[propertyName].setValidators(validators);
        // }
    }
    /**
     * 根据规则对象生成validator
     * @param ruleObj: ValidateRule
     */
    getValidatorByRuleObj(ruleObj, ngFormControl) {
        const { type, constraints = [], message = null } = ruleObj;
        const displayText = ngFormControl.name || ngFormControl.defaultI18nValue || '';
        const ruleHandlerObj = {
            required: (control) => {
                const value = control.value;
                let isValid = value !== '' && value !== null && value !== undefined && value !== '0001-01-01' && value !== '0001-01-01 00:00:00' && value !== '0001-01-01T00:00:00';
                const parentPaths = this.bindingPath.split('/').filter(p => p);
                const controlPaths = ngFormControl.binding.split('.');
                const paths = parentPaths.concat(controlPaths);
                const propInfo = this.getPropInfoByPath(paths);
                const isMultiLangInput = propInfo && propInfo.metadataInfo.enableMultiLangInput;
                if (isMultiLangInput) {
                    const currentLanguage = TranslateService.getCurrentLanguage();
                    const currentLangValue = value && value[currentLanguage];
                    isValid = currentLangValue !== '' && currentLangValue !== null && currentLangValue !== undefined && currentLangValue !== '0001-01-01' && currentLangValue !== '0001-01-01 00:00:00' && currentLangValue !== '0001-01-01T00:00:00';
                }
                const messageTemplate = ValidationTypes.getMessage(ValidationTypes.REQUIRED);
                const invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                if (isValid && control.errors && control.errors.required) {
                    // 修复帮助映射早于控件赋值导致汇总错误消息时帮助必填错误未被清空的问题
                    delete control.errors.required;
                    this.isFormValid(paths.join('.'));
                }
                return isValid ? null : { required: { value: control.value, name: invalidMessage } };
            },
            maxLength: (control) => {
                const isInValid = control.value && control.value.toString().length > constraints[0];
                const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MAX_LENGTH);
                const invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                return isInValid ? { maxLength: { value: control.value, name: invalidMessage } } : null;
            },
            minLength: (control) => {
                const isInValid = control.value && control.value.toString().length < constraints[0];
                const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MAX_LENGTH);
                const invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                return isInValid ? { minLength: { value: control.value, name: invalidMessage } } : null;
            },
            minValue: (control) => {
                let isInValid = false;
                let invalidMessage = '';
                // 这里只做最小值判断，如果用户未输入则不应该做判断
                if (control.value === null || control.value === undefined) {
                    return null;
                }
                if (typeof control.value === 'number' && typeof constraints[0] === 'number') {
                    isInValid = control.value < constraints[0];
                    const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MINVALUE);
                    invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                    // invalidMessage = `${ngFormControl.name}的值不应小于${constraints[0]}`;
                }
                else if (ngFormControl && ngFormControl.bigNumber === true) {
                    // 大数
                    const minValue = new BigNumber(constraints[0]);
                    const value = new BigNumber(control.value);
                    isInValid = minValue.isGreaterThan(value);
                    const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MINVALUE);
                    invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                }
                else {
                    const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MIN_DATE);
                    // 假定为日期
                    // 不管控件的值为什么，只要条件不存咋或是null或0或undefined或""，则不对比大小，无意义
                    if (!constraints || constraints.length < 1 || !constraints[0]) {
                        return null;
                    }
                    if (control.value instanceof Date) {
                        isInValid = control.value < parseISO(constraints[0]);
                    }
                    else {
                        isInValid = parseISO(control.value) < parseISO(constraints[0]);
                    }
                    invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                }
                return isInValid ? { minValue: { value: control.value, name: invalidMessage } } : null;
            },
            maxValue: (control) => {
                let isInValid = false;
                let invalidMessage = '';
                if (control.value === null || control.value === undefined) {
                    return null;
                }
                if (typeof control.value === 'number' && typeof constraints[0] === 'number') {
                    isInValid = control.value > constraints[0];
                    const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MAXVALUE);
                    invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                    // invalidMessage = `${ngFormControl.name}的值不应大于${constraints[0]}`;
                }
                else if (ngFormControl && ngFormControl.bigNumber === true) {
                    // 大数
                    const maxValue = new BigNumber(constraints[0]);
                    const value = new BigNumber(control.value);
                    isInValid = maxValue.isLessThan(value);
                    const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MAXVALUE);
                    invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                }
                else {
                    // 假定为日期
                    const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MAX_DATE);
                    if (control.value instanceof Date) {
                        isInValid = control.value > new Date(constraints[0]);
                        // invalidMessage = `${ngFormControl.name}的值不应晚于${constraints[0]}`;
                    }
                    else {
                        isInValid = new Date(control.value) > new Date(constraints[0]);
                        // invalidMessage = `${ngFormControl.name}的值不应早于${constraints[0]}`;
                    }
                    invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                }
                return isInValid ? { maxValue: { value: control.value, name: invalidMessage } } : null;
            },
            exclude: (control) => {
                const isValid = typeof control.value === 'string' && !this.validatorJs.contains(control.value, constraints[0]);
                const messageTemplate = ValidationTypes.getMessage(ValidationTypes.EXCLUDE);
                const invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                return isValid ? null : { exclude: { value: control.value, name: invalidMessage } };
            },
            matches: (control) => {
                const value = (control.value === null || control.value === undefined) ? '' : control.value.toString();
                const isValid = value === '' ? true : this.validatorJs.matches(value, constraints[0]);
                let invalidMessage = message;
                if (!invalidMessage) {
                    const messageTemplate = ValidationTypes.getMessage(ValidationTypes.MATCHES);
                    invalidMessage = ValidationExecutor.replaceMessageSpecialTokens(messageTemplate, ruleObj, control.value);
                }
                return isValid ? null : { matches: { value: control.value, name: invalidMessage } };
            }
        };
        return ruleHandlerObj[type];
    }
    /**
     * 搜集属性装饰器
     */
    collectMetadatas() {
        this.ngValidateForm = this.frameContext.metadata.form ? MetadataUtil.translateMetadataByName(this.frameContext.metadata.form, this.translateService, ['formGroupName']) :
            MetadataUtil.getClassMetadataByNameWithTranslate(this.constructor, NG_VALIDATE_FORM, this.translateService, ['formGroupName']);
        this.ngFormControls = this.collectionFormControlMetadats(this.frameContext.metadata.formControls);
        this.ngChildForms = this.frameContext.metadata.subForms || MetadataUtil.getPropsMetadatasByName(this.constructor, NG_CHILD_FORM);
    }
    collectionFormControlMetadats(preloadMetadata = null) {
        const metadatas = preloadMetadata ? MetadataUtil.translateMetadatasByName(preloadMetadata, this.translateService, ['name']) :
            MetadataUtil.getPropsMetadatasByNameWithTranslate(this.constructor, NG_FORM_CONTROL, this.translateService, ['name']);
        // 向验证规则中附加表单信息，用于显示验证提示。
        if (metadatas) {
            Object.keys(metadatas).forEach((propName) => {
                const ngFormControl = metadatas[propName];
                const displayFieldName = ngFormControl.name || ngFormControl.defaultI18nValue || '';
                const formControlId = ngFormControl.id;
                if (Array.isArray(ngFormControl.validRules)) {
                    ngFormControl.validRules.forEach((validationRule) => {
                        validationRule.targetId = formControlId;
                        validationRule.targetName = this.formGroupName;
                        validationRule.property = displayFieldName;
                        validationRule.field = ngFormControl.binding;
                    });
                }
            });
        }
        return metadatas;
    }
    // 获取grid中每条数据的formControl
    getGridItemControl(propName, value) {
        const createControlFromRules = propertyName => {
            const validators = [];
            // 设置form中定义的验证规则
            if (this.ngFormControls[propertyName] && Array.isArray(this.ngFormControls[propertyName].validRules)) {
                Array.prototype.forEach.call(this.ngFormControls[propertyName].validRules, ((ruleObj) => {
                    const validateFn = this.getValidatorByRuleObj(ruleObj, this.ngFormControls[propertyName]);
                    if (validateFn) {
                        validators.push(validateFn);
                    }
                }));
            }
            return new FormControl(value, { validators: validators, updateOn: 'blur' });
        };
        return createControlFromRules(propName);
    }
    // 根据实体属性名获取界面绑定的属性名
    getDomPropertyNameByEntityProp(propertyName, prefix = '') {
        let domPropertyName = '';
        Object.keys(this.ngFormControls).forEach(key => {
            const binding = `${prefix}${this.ngFormControls[key].binding}`;
            if (binding === propertyName) {
                domPropertyName = key;
            }
        });
        return domPropertyName;
    }
    /**
     * 创建FormControl
     */
    createControls() {
        Object.keys(this.ngFormControls).forEach((propName) => {
            const ngFormControl = this.ngFormControls[propName];
            const validators = [];
            // 设置form中定义的验证规则
            if (Array.isArray(this.ngFormControls[propName].validRules)) {
                Array.prototype.forEach.call(this.ngFormControls[propName].validRules, (ruleObj => {
                    const validateFn = this.getValidatorByRuleObj(ruleObj, this.ngFormControls[propName]);
                    if (validateFn) {
                        validators.push(validateFn);
                    }
                }));
            }
            const updateOn = ngFormControl.updateOn ? ngFormControl.updateOn : 'blur';
            const control = new FormControl(null, { validators: validators, updateOn: updateOn });
            if (ngFormControl.binding) {
                this.setUpBindingDataPipeline(control, ngFormControl.binding, ngFormControl.valueConverter);
            }
            this.controls[propName] = control;
            this[propName] = control;
        });
    }
    /**
     * 创建FormGroup
     */
    createChildForms() {
        Object.keys(this.ngChildForms).forEach((propName) => {
            const ngFormGroup = this.ngChildForms[propName];
            // 构造子Form
            const formGroup = new ngFormGroup.formType();
            formGroup.init(this.bindingData, this.bindingPath, this.frameContext);
            this.controls[propName] = formGroup;
            this[propName] = formGroup;
        });
    }
    /*
    * 新增FormControls
     */
    addControls(column, converter) {
        const updateOn = column && column.editor && column.editor.updateOn ? column.editor.updateOn : 'blur';
        const formControl = new FormControl('', { updateOn: updateOn });
        const fieldPath = column.dataField;
        // 日期格式  需要格式化
        // this.setUpBindingDataPipeline(formControl, fieldPath, converter);
        if (column.editor && column.editor.binding) {
            this.setUpBindingDataPipeline(formControl, fieldPath, converter);
            this.controls[column.editor.binding.path] = formControl;
            this[column.editor.binding.path] = formControl;
        }
    }
    /**
     * 搭建control和table之间的通道
     * @param control 控件
     * @param bindingFieldPath 绑定的字段名
     */
    setUpBindingDataPipeline(control, bindingFieldPath, converter) {
        if (!this.bindingData) {
            throw Error('当前组件上下文中找不到BindingData，请检查！');
        }
        // 如果converter存在，则写入上下文，Converter中可能会需要从injector中获取当前语言信息
        // __FRAME_CONTEXT__ 未使用
        /*if (converter) {
          converter['__FRAME_CONTEXT__'] = this.frameContext;
        }*/
        // 将bindignPath与bindingFieldPath合并
        if (this.bindingPath.length > 1) {
            bindingFieldPath = this.bindingPath.substr(1).replace(/\//g, '.') + '.' + bindingFieldPath;
        }
        const bindingPaths = bindingFieldPath.split('.');
        const propertyName = bindingPaths[bindingPaths.length - 1];
        // 设置初始值
        const initValue = this.getValueFromBindingData(bindingPaths, converter);
        control.setValue(initValue);
        // 设置初始值
        // BindingData => control
        this.bindingData.changes.pipe(takeUntil(this.destroy$)).pipe(filter((change) => {
            const bindingObject = this.bindingData.getObject();
            const changePath = change.path.join('.');
            if (change.isUdt) {
                return changePath === bindingFieldPath;
            }
            if (change.type === ChangeType.ValueChanged) {
                // path完全匹配
                return changePath === bindingFieldPath;
            }
            else if (change.type === ChangeType.Load || change.type === ChangeType.SelectionChanged || change.type === ChangeType.Remove || change.type === ChangeType.Update) {
                // 对于ObjectChanged、SelectionChanged，匹配到父级
                const changePathWithDot = changePath === '' ? changePath : changePath + '.';
                // 主表新增或切换时，重置错误信息
                if (change && change.type === ChangeType.Load) {
                    this.resetCardValidMsg();
                }
                return bindingFieldPath.indexOf(changePathWithDot) === 0;
            }
            else if (change.type === ChangeType.UpdateErrors) {
                if (changePath === bindingFieldPath) {
                    this.cardControls[propertyName] = this.cardControls[propertyName] || {};
                    if (bindingFieldPath && this.controls[propertyName]) {
                        if (bindingObject.primaryKeyValue === change.id) {
                            this.cardControls[propertyName].errors = change.errors;
                        }
                    }
                    // 没有错误时
                    if (!change.path || !bindingFieldPath || !change.errors) {
                        this.cardControls[propertyName].errors = null;
                        this.isFormValid(bindingFieldPath);
                    }
                    return false;
                }
            }
            else {
                return false;
            }
        })).subscribe((change) => {
            let fullEntityProp = propertyName;
            // udt字段展示时需要将父级属性名和自身属性名用'_'连接
            let pathPrefix = '';
            if (change.isUdt) {
                if (change.isGrid) {
                    // grid 将从表主字段去除
                    change.path.shift();
                }
                if (change.path.length) {
                    pathPrefix = change.path.join('.');
                }
                fullEntityProp = pathPrefix;
            }
            const value = this.bindingData.getValue(bindingPaths, false);
            const newControlValue = converter ? converter.convertFrom(value) : value;
            // 设置FormControl
            const domPropName = this.getDomPropertyNameByEntityProp(fullEntityProp);
            this.cardControls[domPropName] = this.cardControls[domPropName] || {};
            if (change.errors) {
                this.cardControls[domPropName].errors = change.errors;
            }
            // dataGrid保存时，根据id，创建formControl，并设置错误对象
            if (change.id) {
                if (this.controlIdMap[change.id] && Object.keys(this.controlIdMap[change.id]).length === 0) {
                    this.controlIdMap[change.id] = {};
                }
                this.controlIdMap[change.id] = this.controlIdMap[change.id] || {};
                if (change.errors) {
                    this.controlIdMap[change.id][domPropName] = {
                        errors: change.errors
                    };
                }
            }
            // 如果和控件上的值一样，则不再更新控件的值
            if (JSON.stringify(control.value) === JSON.stringify(newControlValue)) {
                return;
            }
            // 正则判断是否为日期
            control.setValue(newControlValue);
        });
        // control => BindingData
        control.valueChanges.pipe(takeUntil(this.destroy$)).subscribe((value) => {
            const oldBindingValue = this.bindingData.getValue(bindingPaths);
            // 如果是日期，比较年月日是否相等，相等则不重新赋值
            if (value && value.constructor && value.constructor.name === 'Date') {
                const isValidDate = !isNaN(value);
                if (!isValidDate) {
                    return;
                }
                if (oldBindingValue && converter) {
                    const oldValue = converter.convertFrom(oldBindingValue);
                    if (this.compareDate(value, oldValue) === true) {
                        return;
                    }
                }
            }
            // 如果是日期，比较年月日是否相等，相等则不重新赋值
            if (this.isDate(converter) === true) {
                if (DateUtil.isEqual(value, oldBindingValue) === true) {
                    return;
                }
            }
            // 如果和BindingData上的值和控件最新的值一样，则不再更新BindingData
            const newBindingValue = converter ? converter.convertTo(value) : value;
            if (JSON.stringify(oldBindingValue) === JSON.stringify(newBindingValue)) {
                return;
            }
            // if (!this.isFormValid(propertyName, null, null, false)) {
            //   const errors = this.cardControls[propertyName] && this.cardControls[propertyName].errors || {};
            //   this.bindingData.setValue(bindingPaths, newBindingValue, false, true, errors);
            // } else {
            this.clearBackEndMessages(propertyName);
            const emitEventToView = this.frameContext.appContext.runMode === RunMode.highSpeed;
            this.bindingData.setValue(bindingPaths, newBindingValue, emitEventToView, true, null, { frameContext: this.frameContext });
            //}
        });
    }
    /**
     * 判断是否是日期字段
     * 1、目前没有办法判断一个字段是否是日期，只能根据Converter来判断；
     * 2、Devkit不能依赖KendoBinding，不能直接判断DateConverter；
     * 3、不能使用constructor.name,压缩后name变了；
     * 4、暂时根据format属性来判断，一旦其他Converter有format，则判断失效，暂时没有这种情况
     * @todo
     * 为日期字段添加注解，根据注解来判断
     */
    isDate(converter) {
        let isDateConverter = false;
        // if (converter && converter.constructor && converter.constructor.name === 'DateConverter') {
        //   isDateConverter = true;
        // }
        if (converter && converter.hasOwnProperty('format') === true) {
            isDateConverter = true;
        }
        return isDateConverter;
    }
    /**
     * 比较日期（只比较年月日）
     */
    compareDate(srcDate, dstDate) {
        if (!srcDate || !dstDate) {
            return srcDate === dstDate;
        }
        const isEqual$$1 = srcDate.getFullYear() === dstDate.getFullYear()
            && srcDate.getMonth() === dstDate.getMonth()
            && srcDate.getDate() === dstDate.getDate()
            && srcDate.getHours() === dstDate.getHours()
            && srcDate.getMinutes() === dstDate.getMinutes()
            && srcDate.getSeconds() === dstDate.getSeconds();
        return isEqual$$1;
    }
    getPropInfoByPath(path) {
        const entityType = this.frameContext && this.frameContext.repository.entityType || null;
        if (entityType) {
            const dataTypeInfo = new DataTypeInfo(entityType);
            const propInfo = dataTypeInfo.getPropInfoByPath(path);
            return propInfo;
            // const isMultiLangInput = propInfo.metadataInfo.enableMultiLangInput;
        }
        return null;
    }
    /**
     * 从BindingData中获取指定路径的值
     */
    getValueFromBindingData(bindingPaths, converter) {
        const value = this.bindingData.getValue(bindingPaths);
        const converteredValue = converter ? converter.convertFrom(value) : value;
        return converteredValue;
    }
    getEntityValueChangingListeners() {
        const listeners = {};
        Object.keys(this.ngFormControls).forEach((propName) => {
            const ngFormControl = this.ngFormControls[propName];
            if (ngFormControl.valueChanging) {
                listeners[ngFormControl.binding] = ngFormControl.valueChanging;
            }
        });
        return listeners;
    }
    getEntityValueChangedListeners() {
        const listeners = {};
        Object.keys(this.ngFormControls).forEach((propName) => {
            const ngFormControl = this.ngFormControls[propName];
            if (ngFormControl.valueChanged) {
                listeners[ngFormControl.binding] = ngFormControl.valueChanged;
            }
        });
        return listeners;
    }
    /**
     * 获取所有的前端验证规则
     * @description
     * 返回的校验规则为Map<string,ValidateRule>,其中key为全路径，从bindingPath开始到实体属性，以/分隔
     */
    getValidationRules() {
        const validatoinRules = new Map();
        let parentPath = this.bindingPath;
        if (parentPath.length && parentPath === '/') {
            parentPath = '';
        }
        Object.keys(this.ngFormControls).forEach((propName) => {
            // const fieldName = `${parentPath}/${propName}`;
            if (this.isShowPropMap[propName] === true || Object.keys(this.isShowPropMap).length === 0) {
                const ngFormControl = this.ngFormControls[propName];
                const displayFieldName = ngFormControl.name || ngFormControl.defaultI18nValue || '';
                const bindingPathArray = ngFormControl.binding ? ngFormControl.binding.split('.') : [propName];
                const fieldNameArray = [parentPath, ...bindingPathArray];
                const fieldName = fieldNameArray.join('/');
                if (Array.isArray(ngFormControl.validRules) && ngFormControl.validRules.length > 0) {
                    let validationrulesToAdd = [...ngFormControl.validRules];
                    // if (this.excludeRuleTypes && this.excludeRuleTypes[propName] && this.excludeRuleTypes[propName].length > 0) {
                    //   validationrulesToAdd = ngFormControl.validRules.filter((item) => !this.excludeRuleTypes[propName].includes(item.type));
                    // }
                    validationrulesToAdd.forEach((validationRule) => {
                        validationRule.targetId = ngFormControl.id;
                        validationRule.targetName = this.formGroupName;
                        validationRule.property = displayFieldName;
                        validationRule.field = ngFormControl.binding;
                        validationRule.fullPath = fieldName;
                        if (this.frameContext) {
                            validationRule.frameContext = this.frameContext;
                        }
                    });
                    validatoinRules.set(fieldName, validationrulesToAdd);
                }
                else {
                    validatoinRules.set(fieldName, [{
                            type: 'setDisplayInfo',
                            targetId: ngFormControl.id,
                            targetName: this.formGroupName,
                            property: displayFieldName,
                            fullPath: fieldName,
                            frameContext: this.frameContext
                        }]);
                }
            }
        });
        return validatoinRules;
    }
    setTranslateService(translateService) {
        if (!translateService) {
            return;
        }
        this.translate = translateService;
        ValidationTypes.setCurrentLanguage(translateService.getCurrentLanguage());
    }
    /**
     * 重置控件状态
     */
    resetFormControls() {
        if (Object.keys(this.controls).length > 0) {
            Object.keys(this.controls).forEach((prop) => {
                const formControl = this.controls[prop];
                formControl.markAsUntouched();
                formControl.markAsPristine();
            });
        }
    }
    clearBackEndMessages(domPropertyName) {
        if (domPropertyName) {
            if (this.cardControls[domPropertyName] && this.cardControls[domPropertyName]['errors'] && !!Object.keys(this.cardControls[domPropertyName]['errors']).find(item => item.startsWith('message-'))) {
                const messageKeys = Object.keys(this.cardControls[domPropertyName]['errors']).filter(item => item.startsWith('message-'));
                const errors = Object.assign({}, this.cardControls[domPropertyName]['errors']);
                messageKeys.forEach(key => delete errors[key]);
                this.cardControls[domPropertyName] = { errors: errors };
            }
        }
        else {
            Object.keys(this.cardControls).forEach(propertyName => {
                if (this.cardControls[propertyName] && this.cardControls[propertyName]['errors'] && !!Object.keys(this.cardControls[propertyName]['errors']).find(item => item.startsWith('message-'))) {
                    const messageKeys = Object.keys(this.cardControls[propertyName]['errors']).filter(item => item.startsWith('message-'));
                    const errors = Object.assign({}, this.cardControls[propertyName]['errors']);
                    messageKeys.forEach(key => delete errors[key]);
                    this.cardControls[propertyName] = { errors: errors };
                }
            });
        }
    }
}
/**
 * 存放所有实例的映射
 */
Form.insMap = {};
Form.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Form.ctorParameters = () => [];

/**
 * 实体操作工具类
 */
class EntityUtil {
    /**
     * 将entity的数据加载到bindingObject中，并保持两者同步。
     * @param entity        实体对象
     * @param bindingObject 绑定对象
     */
    static loadEntity(entity, bindingObject) {
        // 遍历bindingObject的properties进行赋值
        bindingObject.properties.forEach((property) => {
            const propertyName = property.name;
            if (property.type === BindingPropertyType.List) {
                this.loadEntityList(entity[propertyName] || entity[PARENT_CLASS], bindingObject[propertyName]);
            }
            else if (property.type === BindingPropertyType.Object) {
                if (entity && entity[propertyName] && this.isEffectiveField(entity, propertyName)) {
                    this.loadEntity(entity[propertyName], bindingObject[propertyName]);
                }
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                if (entity && entity[propertyName]) {
                    const dynamicObject = BindingObjectFactory.createDynamicBindingObject(entity[propertyName].data);
                    BindingObjectFactory.attachDynamicObjectProperty(bindingObject, propertyName, dynamicObject);
                    this.loadEntity(entity[propertyName], bindingObject[propertyName]);
                }
            }
            else {
                if (this.isEffectiveField(entity, propertyName)) {
                    const value = entity[propertyName];
                    bindingObject.setValue(propertyName, value, false, false);
                }
            }
        });
        this.setUpEntityPipeline(entity, bindingObject);
    }
    /**
     * 建立entity和bindingObject之间的关联
     * @param entity        实体对象
     * @param bindingObject 绑定对象
     */
    static setUpEntityPipeline(entity, bindingObject) {
        if (!entity || !bindingObject) {
            return;
        }
        // 监听entity变更
        entity.onValueChanged.pipe(takeUntil(entity.unsubscribe)).subscribe((modification) => {
            if (modification.type !== ModifyType.ValueChange || modification.path.length === 0 || modification.fromParent === true) {
                return;
            }
            const propertyName = modification.path[modification.path.length - 1];
            const primaryKeyPath = modification.path[modification.path.length - 2];
            // 验证主键是否匹配
            // 存在主键并且主键不是id时才检查（值对象、关联对象不检查）
            if (bindingObject.primaryKey && bindingObject.primaryKey === 'id') {
                const primaryKey = bindingObject.primaryKey;
                const primaryKeyValue = bindingObject.getValue(primaryKey);
                if (primaryKeyPath !== `${primaryKey}:${primaryKeyValue}`) {
                    return;
                }
            }
            // TODO:修复动态列不触发变更的问题，临时方案，应该有单独的dynamicBindingObject类
            if (modification.dynamic) {
                if (bindingObject['__original__']) {
                    return;
                }
                const value = modification.value;
                const target = bindingObject[propertyName];
                if (!target) {
                    return;
                }
                Object.keys(value).forEach((key) => {
                    if (target.getValue(key) === value[key]) {
                        return;
                    }
                    target.setValue(key, value[key], true, false);
                });
            }
            else {
                // 值没有发生变化，不再设置
                // TODO: 通过bindingObject修改entity属性值时，entity总会触发一个变更回来，如果不截获这个重复的变更，会导致重复或死循环
                if (bindingObject.getValue(propertyName) === modification.value) {
                    return;
                }
                bindingObject.setValue(propertyName, modification.value, true, false, modification.errors);
            }
        });
        // 监听bindingObject变更
        bindingObject.viewChanges.pipe(takeUntil(bindingObject.unsubscribe)).subscribe((viewChange) => {
            const value = viewChange.value;
            const propertyName = viewChange.path[0];
            let pathPrefix = '';
            const pathData = entity.getPaths();
            const paths = pathData.path;
            let id = bindingObject['id'];
            bindingObject['__original__'] = true;
            // if (pathData.isUdt) {
            // grid中udt没有id，从父级中取出id，以便存放验证信息
            const getParentId = (target) => {
                let parentId = '';
                const findId = (item) => {
                    if (item && item && item['id']) {
                        parentId = item['id'];
                        return;
                    }
                    else if (item['parent']) {
                        findId(item['parent']);
                    }
                };
                findId(target);
                return parentId;
            };
            id = getParentId(bindingObject);
            // if (pathData.isGrid) {
            //   // grid 将从表主字段去除
            //   paths.pop();
            // }
            if (paths.length) {
                pathPrefix = paths.join('.') + '.';
            }
            // }
            const controlProp = pathPrefix + propertyName;
            // 调用实体验证，并将错误信息合并到formControl上
            const entityValidate = (callback) => {
                const enableValidate = Object.values(Form.insMap).find(item => item && item.enableValidate);
                if (!enableValidate) {
                    if (typeof callback === 'function') {
                        callback(null);
                    }
                    return;
                }
                entity.validateFromUtilSync(propertyName, value, result => {
                    const errorObj = {};
                    if (result.errors && result.errors.length > 0) {
                        result.errors.forEach((error) => {
                            if (error.constraints) {
                                Object.keys(error.constraints).forEach(key => {
                                    errorObj[key] = {
                                        value: value,
                                        name: error.constraints[key],
                                        error: error
                                    };
                                });
                            }
                        });
                    }
                    // 先设置实体验证信息，再设置form验证信息，然后在form.isFormValid内部整合实体验证form验证信息
                    Form.updateErrors(controlProp, errorObj, id, value, pathData.isGrid);
                    const formErrors = viewChange['errors'] || {};
                    const mergedErrors = Object.assign({}, formErrors, errorObj);
                    let validateError = null;
                    if (Object.keys(mergedErrors).length > 0) {
                        validateError = { [propertyName]: mergedErrors };
                    }
                    if (typeof (callback) === 'function') {
                        callback(validateError);
                    }
                }, viewChange.context);
            };
            // 不是主键值字段时，要先检查主键是否存在，并且主键是否相等（防止后代变更冒泡上来）
            // 非主键属性变更时，要先检查主键是否匹配（如果主键也修改了，要求先修改主键再修改其他值）
            if (bindingObject.primaryKey) {
                const primaryKey = bindingObject.primaryKey;
                if (propertyName !== primaryKey) {
                    if (!entity[primaryKey] || entity[primaryKey] !== bindingObject[primaryKey]) {
                        entityValidate();
                        return;
                    }
                }
                else if (entity[propertyName] !== value) {
                    // todo: 因异步校验未结束实体主键没有被赋值，导致实体其他属性无法赋值，待后续前端校验重构时去掉
                    entity[propertyName] = value;
                    entityValidate();
                    return;
                }
            }
            // 如果BindingObject上的属性值和Entity上对应属性值一样，则不再设置
            if (entity[propertyName] === value) {
                entityValidate();
                return;
            }
            // 调用表单验证,通过后调用实体验证
            // bingdingObject变化后，先调用实体上的验证，通过后再设置实体的变动
            entityValidate((errors) => {
                entity.errors = errors;
                entity[propertyName] = value;
            });
        });
    }
    /**
     * 将entityList中的Entity对象转换为BindingObject对象，加载到bindingList中，并保持entityList和bindingList同步。
     * @param entityList  实体列表
     * @param bindingList 绑定列表
     */
    static loadEntityList(entityList, bindingList) {
        this.loadEntities(entityList.items, bindingList);
        this.setUpEntityListPipeline(entityList, bindingList);
    }
    /**
     * 建立entityList和bindingList之间的关联
     * @param entityList  实体列表
     * @param bindingList 绑定列表
     */
    static setUpEntityListPipeline(entityList, bindingList) {
        entityList.onListChanged.subscribe((modification) => {
            const target = modification['target'];
            if (target && target !== entityList) {
                return;
            }
            switch (modification.type) {
                // 添加实体
                case ModifyType.Add:
                case ModifyType.Clone:
                    {
                        const entitiesToAdd = modification.value;
                        if (entitiesToAdd.length === 0) {
                            return;
                        }
                        // 检查父id是否一致，冒泡导致的变更不处理
                        const paths = modification.path;
                        const parentPath = paths[paths.length - 2];
                        const parentId = bindingList.parent.primaryKeyValue;
                        if (parentPath.indexOf(parentId) === -1) {
                            return;
                        }
                        this.appendEntities(modification.value, bindingList, modification.type === ModifyType.Clone);
                    }
                    break;
                case ModifyType.Insert:
                    {
                        // 检查父id是否一致，冒泡导致的变更不处理
                        const paths = modification.path;
                        const parentPath = paths[paths.length - 2];
                        const parentId = bindingList.parent.primaryKeyValue;
                        const position = modification.position;
                        if (parentPath.indexOf(parentId) === -1) {
                            return;
                        }
                        this.insertEntity(modification.value[0], bindingList, position);
                    }
                    break;
                // 删除实体
                case ModifyType.Remove:
                    {
                        // 检查父id是否一致，冒泡导致的变更不处理
                        const paths = modification.path;
                        const parentPath = paths[paths.length - 2];
                        const parentId = bindingList.parent.primaryKeyValue;
                        if (parentPath.indexOf(parentId) === -1) {
                            return;
                        }
                        // 删除实体（value格式待商榷，目前value的格式为 { primaryKey: primaryValue}）
                        const id = modification.value[bindingList.primaryKey];
                        bindingList.removeByIds([id]);
                        // this.removeEntities(<Entity[]>modification.value, bindingList);
                    }
                    break;
                // 加载实体
                case ModifyType.Load:
                    // 检查父id是否一致，冒泡导致的变更不处理
                    const paths = modification.path;
                    const parentPath = paths[paths.length - 2];
                    const parentId = bindingList.parent.primaryKeyValue;
                    if (parentPath.indexOf(parentId) === -1) {
                        return;
                    }
                    const entities = modification.value;
                    this.loadEntities(entities, bindingList);
                    break;
                default:
                    break;
            }
        });
    }
    /**
     * 监听repository变化，保持repository和bindingList同步。
     * @param repository  实体仓库
     * @param bindingList 绑定列表
     */
    static loadRepository(repository, bindingList) {
        // 初次加载
        const entities = Array.from(repository.entityCollection.toArray());
        this.loadEntities(entities, bindingList);
        // 监听变化
        repository.entityCollectionChange.pipe(takeUntil(repository.destroy$)).subscribe((modification) => {
            switch (modification.type) {
                case ModifyType.Load:
                    bindingList.clear(true);
                    this.loadEntities(modification.value, bindingList, modification.entityCreate);
                    break;
                case ModifyType.Add:
                case ModifyType.Clone:
                    this.appendEntities(modification.value, bindingList, modification.type === ModifyType.Clone, { isTreeNodeLoadScene: modification.isTreeNodeLoadScene });
                    break;
                case ModifyType.AddData:
                    this.addData(modification.value, bindingList, { isTreeNodeLoadScene: modification.isTreeNodeLoadScene });
                    break;
                case ModifyType.Insert:
                    this.insertEntity(modification.value, bindingList, modification.position);
                    break;
                case ModifyType.Remove:
                    this.removeEntities(modification.value, bindingList);
                    break;
                case ModifyType.RemoveData:
                    this.removeData(modification.value, bindingList);
                    break;
                case ModifyType.PaginationInfoChange:
                    // 分页信息无需同步到bindingList，放到bindingData即可。保留此处只是为了兼容产品部可能使用bindingList上分页信息的场景
                    bindingList.paginationInfo = modification.value;
                    break;
                default:
                    break;
            }
        });
        // 监听BindingList数据变化
        bindingList.changes.pipe(takeUntil(bindingList.destroy$)).subscribe((change) => {
            if (change.type === ChangeType.PaginationInfoChange) {
                const entityCollection = repository.entityCollection;
                // const entityTypeName = entityCollection.entityTypeName;
                // const original = entityCollection.paginationInfo[entityTypeName];
                // const entityPaginationInfo = Object.assign({}, original, change.value);
                entityCollection.paginationInfo = Object.assign({}, entityCollection.paginationInfo, change.value);
            }
        });
    }
    /**
     * 将entities中的Entity对象转换为BindingObject对象，并加载到bindingList中
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static loadEntities(entities, bindingList, entityCreate = false) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.load(bindingObjects, entityCreate);
    }
    /**
     * 将entities中的Entity对象转换为BIndingObject对象，并追加到bindingList中
     * @param entities    实体数组
     * @param bindingList 绑定列表
     * @param isCloned 是否克隆数据
     * @param options 上下文
     */
    static appendEntities(entities, bindingList, isCloned = false, options = null) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.append(bindingObjects, isCloned, options);
    }
    /**
     * 是否是有效的字段
     * @param entity 实体
     * @param propertyName 字段
     * @returns
     */
    static isEffectiveField(entity, propertyName) {
        if (!entity || !propertyName) {
            return false;
        }
        propertyName = propertyName.toLowerCase();
        if (entity['__farris_effective_fields__']) {
            return entity['__farris_effective_fields__'].includes(propertyName);
        }
        if (entity['farris_effective_fields'] && typeof entity['farris_effective_fields'] === 'string') {
            const effectiveFields = entity['farris_effective_fields'].split(',').filter(p => p).map(item => item.toLowerCase());
            entity['__farris_effective_fields__'] = effectiveFields;
            return effectiveFields.includes(propertyName);
        }
        return true;
    }
    /**
     * 增加实体数据（不切换当前行）
     * @param entities
     * @param bindingList
     */
    static addData(entities, bindingList, options = null) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.addData(bindingObjects, options);
    }
    static insertEntity(entity, bindingList, position) {
        const bindingObject = this.createBindingObject(entity, bindingList);
        bindingList.insert(bindingObject, position);
    }
    /**
     * 从bindingList移除entities对应的BindingObject对象
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static removeEntities(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return;
        }
        // 归集要删除的id数组
        const primaryKey = bindingList.primaryKey;
        const ids = [];
        entities.forEach((entity) => {
            ids.push(entity[primaryKey]);
        });
        bindingList.removeByIds(ids);
    }
    static removeData(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return;
        }
        // 归集要删除的id数组
        const primaryKey = bindingList.primaryKey;
        const ids = [];
        entities.forEach((entity) => {
            ids.push(entity[primaryKey]);
        });
        bindingList.removeDataByIds(ids);
    }
    /**
     * 将entities中的Entity对象转换为BindingObject对象
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static createBindingObjects(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return [];
        }
        const bindingObjects = [];
        entities.forEach((entity) => {
            const bindingObject = BindingObjectFactory.create(bindingList.properties, true);
            // bindingObject['_ENTITY_'] = entity;
            this.loadEntity(entity, bindingObject);
            // // 为bindingObject设置默认值initialData属性
            // if (entity['initialData']) {
            //   bindingObject['initialData'] = entity['initialData'];
            // }
            bindingObjects.push(bindingObject);
        });
        return bindingObjects;
    }
    static createBindingObject(entity, bindingList) {
        const bindingObject = BindingObjectFactory.create(bindingList.properties, true);
        this.loadEntity(entity, bindingObject);
        return bindingObject;
    }
    static watchReposiroty(repository, bindingData) {
        // reposiroty => bindingData
        repository.entityCollectionChange.subscribe((modification) => {
            switch (modification.type) {
                case ModifyType.PaginationInfoChange:
                    bindingData.pagingInfo = modification.value;
                    break;
                default:
                    break;
            }
        });
    }
    /**
     * 查找属性的类型
     * @param entityType 实体类型
     * @param targetPropName 属性名称
     * @return 属性信息，包含属性类型（NgField、NgObject、NgList）和属性对应的实体类型（当NgField类型时为null）
     */
    static getPropInfo(entityType, targetPropName) {
        let propType;
        let propEntityType;
        // NgField
        const ngFieldProperties = FieldMetadataUtil.getNgFields(entityType);
        Object.keys(ngFieldProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgField';
                propEntityType = null;
            }
        });
        // NgObject
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgObject';
                propEntityType = ngObjectProperties[propName].type;
            }
        });
        // NgList
        const ngListProperties = FieldMetadataUtil.getNgList(entityType);
        Object.keys(ngListProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgList';
                propEntityType = ngListProperties[propName].type;
            }
        });
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgDynamic';
                propEntityType = ngDynamicProperties[propName].type;
            }
        });
        return { propType, propEntityType };
    }
    /**
     * 获取实体的主键名
     * @param entityType 实体类型
     */
    static getPrimaryKey(entityType) {
        const primaryNgFiledProp = FieldMetadataUtil.getPrimaryFieldMetadata(entityType);
        if (primaryNgFiledProp) {
            return primaryNgFiledProp.dataField;
        }
        else {
            return '';
        }
    }
    /**
     * 是否为对象属性
     */
    static isObjectProp(entityType, targetPropName) {
        let isObjectProp = false;
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propName) => {
            if (propName === targetPropName) {
                isObjectProp = true;
            }
        });
        return isObjectProp;
    }
    /**
     * 检查是否是动态列属性
     */
    static isDynamicProp(entityType, targetPropName) {
        let isDynamicProp = false;
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            if (propName === targetPropName) {
                isDynamicProp = true;
            }
        });
        return isDynamicProp;
    }
    /**
     * 为实体增加initialData属性
     * @param entity 实体实例
     * @param initialData 默认值对象
     */
    static appendInitialData(entity, initialData) {
        const data = Object.assign({}, initialData);
        delete data.id;
        delete data.parentID;
        entity['initialData'] = data;
    }
}

// tslint:disable: max-line-length member-ordering
/**
 * 绑定数据
 * @description
 * # BindingData
 *
 * BindingData用于直接和界面绑定，它持有一个不可变的数据集合（BindingList），数据集合中是一个个不可变的数据对象（BindingObject）。
 *
 * ## 更新界面数据
 *
 * ### 接口定义
 *
 * ```javascript
 * //根据paths设置属性值
 * //@param paths 属性路径数组
 * //@param value 属性值
 * //@param emitEventToView 如果设置为true，则发送事件通知订阅它的组件、指令去更新界面，默认为false。
 * //@param emitEventToEntity 如果设置为true，则同步去更新Entity上对应的字段，默认为true。
 * public setValue(paths: string[], value: any, emitEventToView: boolean = false, emitEventToEntity: boolean = true)
 * ```
 *
 * ### 示例
 *
 * - 更新主表数据
 *
 *   ```javascript
 *   bindingData.setValue(['name'],'ESG');
 *   ```
 *
 * - 更新子表数据
 *
 *   ```javascript
 *   bindingData.setValue(['soItems','price'],20);
 *   ```
 *
 * - 更新业务字段数据
 *
 *   ```javascript
 *   bindingData.setValue(['udt','udt_field'],'value');
 *   ```
 *
 * - 仅更新界面数据（不提交变更集）
 *
 *   ```javascript
 *   bindingData.setValue(['name'],'ESG',true,false);
 *   ```
 *
 *   > 注意：
 *   >
 *   > 仅更新界面数据时bindingData必须是对应组件上下文的bindingData。
 *   >
 *   > 更新数据的命令挂载到不同的组件，产生的效果也不相同。如果命令挂到了卡片视图模型，那么可以直接在构件中注入`FrameContext`或`BindingData`并更新数据就可以。但如果命令挂到了非卡片视图 * 模型，则应该先获取到卡片上下文的bindingData。
 *   >
 *   > - 命令挂在卡片视图模型:
 *   >
 *   >   ```javascript
 *   >   const frameContext = this.frameContext.bindingData;
 *   >   frameContext.bindingData.setValue(['name'],'ESG');
 *   >   ```
 *   >
 *   > - 命令挂在非卡片视图模型：
 *   >
 *   >   ```javascript
 *   >   const cardFrameContext = this.frameContext.appContext.frameContextManager.getFrameContextById('card-frameId');
 *   >   cardFrameContext.bindingData.setValue(['name'],'ESG');
 *   >   ```
 *
 * ## 获取界面数据
 *
 * ### 接口定义
 *
 *   ```javascript
 *   //获取paths对应的属性值
 *   //@param  paths 属性路径数组
 *   //@returns 属性值
 *   public getValue(paths: string[], useInitValue = false)
 *   ```
 *
 * ### 示例
 *
 * - 获取主表数据
 *
 *   ```javascript
 *   bindingData.getValue(['name']) //'ESG'
 *   ```
 *
 * - 获取从表中字段属性
 *
 *   ```javascript
 *   bindingData.getValue(['soItems','price']); // 20
 *   ```
 *
 * - 获取业务字段数据
 *
 *   ```javascript
 *   bindingData.getValue(['udt','udt_field']); // 'value'
 *   ```
 *
 * ## 获取指定BindingObject
 *
 * ### 接口定义
 *
 * ```javascript
 * //通过主键获取对应的bindingObject
 * bindingData.list.findById(id: string): BindingObject;
 * ```
 *
 * ### 示例
 * - 获取某个主实体
 *   ```javascript
 *   bindingData.list.findById("id");
 *   ```
 * - 获取某个实体下子表的所有数据
 *   ```javascript
 *   // 获取主实体
 *   const bindingObject = bindingData.list.findById("id") as BindingObject;
 *   // 获取该实体下的某个子表数据
 *   const bindingList = bindingObject.getValue("soItems") as BindingList;
 *   ```
 *
 * - 获取子表某一行数据
 *
 *   ```javascript
 *   //获取主实体
 *   const bindingObject = bindingData.list.findById("id") as BindingObject;
 *   //获取该实体下的某个子表数据
 *   const bindingList = bindingObject.getValue("soItems") as BindingList;
 *   //子表行数据
 *   const childrenBindingObject = bindingList.findById('子表数据id');
 *   const name = childrenBindingObject.getValue("name"); // 或者childrenBindingObject['name']
 *   ```
 *
 * ## 常见问题
 *
 * ### 赋值或取值时为何不用指定主键？
 *
 *    示例中取值或赋值时并没有指定主键值，这是由于BindingData赋值或取值时都是对当前行就行操作的，所以不需要指定主键。所以在计算&行切换场景下会导致取值或赋值错误，如本来想给第一行的某个字 * 段赋值，结果由于行切换导致把值赋给了其他行。
 *
 *    如果遇到赋值错误的情况可以通过BindingObject赋值或取值。
 *
 * ### 通过bindingData赋值了，界面也刷新了，但保存不上
 *
 *    这种情况多发生在有后端请求的情况下，比如通过bindingData赋值后紧接着有一个后端请求。由于bindingData赋值是异步的（目前是），这就可能导致赋值还没有结束（还没有产生变更）请求就发送 * 了，从而请求中没有对应的变更，请求回来后会默认清空本地变更，从而导致界面上显示数据已经修改，但数据库中数据并未修改。
 *
 *    解决该类问题可以通过实体赋值的方式，给实体赋值是同步的，赋值完成后变更就会产生，这样再发送请求时就可以把变更带到后端。
 */
class BindingData {
    constructor() {
        this.paginationInfo = null;
    }
    set pagingInfo(pagingInfo) {
        this.paginationInfo = pagingInfo;
        this.firePagingChangeEvent();
    }
    get pagingInfo() {
        return this.paginationInfo;
    }
    dispose(options) {
        this.list.dispose();
    }
    ngOnDestroy() {
        this.dispose();
    }
    /**
     * 设置分页信息
     * @param skip 跳过
     * @param take 获取
     * @param bindingPath 路径
     */
    setPagingInfo(skip, take$$1, bindingPath) {
        if (bindingPath.length < 1 || bindingPath === '/') {
            this.paginationInfo = Object.assign(this.paginationInfo, { pageSize: take$$1, pageIndex: skip / take$$1 + 1 });
        }
        else {
            let pagingInfo = this.paginationInfo || {};
            const bindingPaths = bindingPath.substr(1).split('/').filter(item => !!item && item.length > 0); // .map(item => item.substring(0, item.length - 1));
            let nodeCode = bindingPaths[bindingPaths.length - 1];
            // 去s
            nodeCode = nodeCode.substr(0, nodeCode.length - 1);
            // 找到父级
            // 获取当前实体上级的主键
            const paths = bindingPaths.slice(0, bindingPaths.length - 1);
            const parentObject = this.getValue(paths);
            if (parentObject && parentObject[parentObject.primaryKey]) {
                // const key = `${nodeCode}_${parentObject[parentObject.primaryKey]}`;
                const key = `${nodeCode}`;
                pagingInfo = pagingInfo[key] || {};
                pagingInfo.pageIndex = ((skip / take$$1) || 0) + 1;
                pagingInfo.pageSize = take$$1 || 0;
            }
        }
        this.firePagingChangeEvent();
    }
    updatePagingInfo(pageInfo, bindingPath) {
        if (bindingPath.length < 1 || bindingPath === '/') {
            this.paginationInfo = Object.assign(this.paginationInfo, pageInfo);
        }
        else {
            let pagingInfo = this.paginationInfo || {};
            const bindingPaths = bindingPath.substr(1).split('/').filter(item => !!item && item.length > 0); // .map(item => item.substring(0, item.length - 1));
            let nodeCode = bindingPaths[bindingPaths.length - 1];
            // 去s
            nodeCode = nodeCode.substr(0, nodeCode.length - 1);
            pagingInfo[nodeCode] = Object.assign(pagingInfo[nodeCode], pageInfo);
        }
        this.firePagingChangeEvent();
    }
    firePagingChangeEvent() {
        this.list.changes.next({
            type: ChangeType.PaginationInfoChange,
            path: this.bindingPath && this.bindingPath.split('/').filter(p => p) || [],
            value: this.paginationInfo
        });
    }
    /**
     * 变更集
     */
    get changes() {
        return this.list.changes;
    }
    /**
     * 设置值变化执行器工厂
     * @param value 值变化执行器工厂
     */
    setValueChangeInvokerFactory(value) {
        this.valueChangeInvokerFactory = value;
    }
    getValudChangeInvokerFactory() {
        return this.valueChangeInvokerFactory;
    }
    /**
     * 初始化（已废弃）
     */
    init(repository, bindingPath) {
        this.initByRepository(repository, bindingPath);
    }
    /**
     * 根据Repository对BindingData进行初始化
     */
    initByRepository(repository, bindingPath) {
        this.bindingPath = bindingPath;
        this.properties = PropertyUtil.getProperties(repository.entityType);
        this.list = BindingListFactory.create(this.properties);
        // 从repository初始化bindingData
        this.pagingInfo = repository.entityCollection.paginationInfo;
        // @todo
        // BindingData不应该知道Repository，加载数据、建立关联关系的过程应该转移到外边
        EntityUtil.loadRepository(repository, this.list);
        this.dataTypeInfo = repository.entityTypeInfo;
        this.extendProperties(this.properties);
    }
    /**
     * 初始化
     */
    initByBindingList(bindingList, bindingPath) {
        this.list = bindingList;
        this.bindingPath = bindingPath;
        this.extendProperties(this.list.properties);
    }
    setDataTypeInfo(dataTypeInfo) {
        this.dataTypeInfo = dataTypeInfo;
    }
    /**
     * 获取界面数据
     * @param paths 属性路径数组
     * @param useInitValue 是否使用默认值，默认为`false`
     * @returns 属性值
     */
    getValue(paths, useInitValue = false) {
        let target = this.list;
        paths.forEach((path) => {
            if (target) {
                target = target[path];
            }
        });
        if (useInitValue === true && paths && paths.length > 0) {
            const initValue = this.getInitValueByPaths(paths);
            if (target === undefined && target !== initValue) {
                target = initValue;
            }
        }
        return target;
    }
    /**
     * 该方法可以更新绑定层数据，从而达到更新界面数据的目的，进而更新本地仓库实体数据，产生变更，下次请求时会将变更带到后端并更新后端数据。
     * @param paths 属性路径数组
     * @param value 属性值
     * @param emitEventToView 如果设置为true，则发送事件通知订阅它的组件、指令去更新界面，默认为false。
     * @param emitEventToEntity 如果设置为true，则同步去更新Entity上对应的字段，默认为true。
     * @description
     * ## 示例
     *
     * ### 更新界面数据
     * 使用该方法时只传递path和value参数，其余参数使用默认值。该用法会更新界面数据，同时更新实体数据，实体数据更新时会产生变更，这样在下次请求时会将该变更带到后端，
     * 进而更新后端数据。
     * ```typescript
     * this.frameContext.bindingData.setValue(paths,value);
     * ```
     *
     * ### 仅更新界面数据
     * 有些场景下我们希望只更新界面的数据，不希望对后端数据产生影响，此时除传递paths和value参数外，还需要将emitEventToView设为true，emitEventToEntity设为false，
     * 此时必须使用对应BindingData的setValue方法：
     * ```typescript
     * const tableFrameContext = this.frameContext.appContext.frameContextManager.getFrameContextById('data-grid-component');
     * tableFrameContext.bindingData.setValue(paths,value,true,false);
     * ```
     * ## 注意事项
     * setValue为异步方法，如果调用该方法后随即发送后端请求，此时实体变更尚未产生，但请求已经发送，变更无法带到后端，导致变更丢失，出现界面上显示数据已经修改，
     * 但后端并未修改的问题。
     * 因此，如果赋值后随即发送请求应该使用实体赋值的方法。
     */
    setValue(paths, value, emitEventToView = false, emitEventToEntity = true, errors = {}, context) {
        if (!paths || paths.length === 0) {
            throw Error('路径不能为空');
        }
        const parentPaths = paths.slice(0, paths.length - 1);
        const propName = paths[paths.length - 1];
        let parent = this.getValue(parentPaths);
        if (!parent) {
            throw Error('找不到要设置的对象');
        }
        if (parent instanceof BindingData) {
            parent = parent.list.currentItem;
        }
        else if (parent instanceof BindingList) {
            parent = parent.currentItem;
        }
        if (!!this.valueChangeInvokerFactory) {
            parent.setValue(propName, value, emitEventToView, emitEventToEntity, errors, this.valueChangeInvokerFactory(paths), context);
        }
        else {
            parent.setValue(propName, value, emitEventToView, emitEventToEntity, errors, null, context);
        }
    }
    /**
     * 根据paths清空属性值
     */
    clearValue(paths, emitEventToView = false, emitEventToEntity = true, context) {
        let initValue;
        const propInfo = this.dataTypeInfo.getPropInfoByPath(paths);
        if (propInfo && propInfo.metadataInfo && propInfo.metadataInfo.initValue !== undefined) {
            initValue = propInfo.metadataInfo.initValue;
        }
        else {
            // 原来的帮助映射中，强行纠正了数值的情况，保持一致
            const oldValue = this.getValue(paths);
            if (typeof oldValue === 'number') {
                initValue = 0;
            }
            else {
                initValue = '';
            }
        }
        this.setValue(paths, initValue, emitEventToView, emitEventToEntity, null, context);
    }
    /**
     * 获取当前列表
     */
    getList() {
        if (!this.bindingPath || this.bindingPath === '/') {
            return this.list;
        }
        const bindingPath = this.bindingPath.substr(1);
        const bindingPathArray = bindingPath.split('/').filter((part) => {
            return part !== '';
        });
        return this.getValue(bindingPathArray);
    }
    /**
     * 获取当前对象
     */
    getObject() {
        const bindingList = this.getList();
        return bindingList.currentItem;
    }
    /**
     * 绑定路径（仅路径部分，不包括属性）
     * @param bindingPath 绑定路径
     */
    getPath(bindingPath) {
        const bindingPaths = bindingPath.filter(p => p);
        const path = [`${this.list.primaryKey}:${this.list.currentId}`];
        bindingPaths.forEach((item) => {
            path.push(item);
            const list = this[item];
            if (list) {
                path.push(`${list.primaryKey}:${list.currentId}`);
            }
        });
        return path;
    }
    /**
     * 清空绑定数据
     */
    reset() {
        this.list.clear(true);
    }
    /**
     * 通过绑定路径获取属性初始值
     * @param paths 绑定路径
     */
    getInitValueByPaths(paths) {
        let initValue;
        const propInfo = this.dataTypeInfo && this.dataTypeInfo.getPropInfoByPath(paths) || null;
        if (propInfo && propInfo.metadataInfo && propInfo.metadataInfo.initValue !== undefined) {
            initValue = propInfo.metadataInfo.initValue;
        }
        return initValue;
    }
    /**
     * 扩展BindingData属性，映射BindingData所持有的绑定列表当前行的属性，减少绑定层级。
     * @param properties 关联实体的属性集合
     */
    extendProperties(properties) {
        properties.forEach((property) => {
            const propName = property.name;
            Object.defineProperty(this, propName, {
                get: () => {
                    return this.list.currentItem[propName];
                },
                set: (value) => {
                    this.list.currentItem[propName] = value;
                }
            });
        });
    }
}
BindingData.decorators = [
    { type: Injectable }
];

var Compare;
(function (Compare) {
    /**
     * 等于
     */
    Compare[Compare["Equal"] = 0] = "Equal";
    /**
     * 不等于
     */
    Compare[Compare["NotEqual"] = 1] = "NotEqual";
    /**
     * 大于
     */
    Compare[Compare["Greater"] = 2] = "Greater";
    /**
     * 大于等于
     */
    Compare[Compare["GreaterOrEqual"] = 3] = "GreaterOrEqual";
    /**
     * 小于
     */
    Compare[Compare["Less"] = 4] = "Less";
    /**
     * 小于等于
     */
    Compare[Compare["LessOrEqual"] = 5] = "LessOrEqual";
    /**
     * 包含
     */
    Compare[Compare["Like"] = 6] = "Like";
    /**
     * 不包含
     */
    Compare[Compare["NotLike"] = 9] = "NotLike";
    Compare[Compare["In"] = 14] = "In";
    /**
     * 为空
     */
    Compare[Compare["Empty"] = 1001] = "Empty";
    /**
     * 不为空
     */
    Compare[Compare["NotEmpty"] = 1002] = "NotEmpty";
})(Compare || (Compare = {}));
var FilterRelation;
(function (FilterRelation) {
    FilterRelation[FilterRelation["Empty"] = 0] = "Empty";
    /**
     * 并且
     */
    FilterRelation[FilterRelation["And"] = 1] = "And";
    /**
     * 或者
     */
    FilterRelation[FilterRelation["Or"] = 2] = "Or";
})(FilterRelation || (FilterRelation = {}));
/**
 * 值类型
 */
var ExpressValueType;
(function (ExpressValueType) {
    /**
     * 值
     */
    ExpressValueType[ExpressValueType["Value"] = 0] = "Value";
    /**
     * 表达式
     */
    ExpressValueType[ExpressValueType["Expression"] = 1] = "Expression";
    /**
     * 前端表达式
     */
    ExpressValueType["FrontExpress"] = "frontExpress";
})(ExpressValueType || (ExpressValueType = {}));
const LeftBracket = [
    '', '(', '((', '((('
];
const RighttBracket = [
    '', ')', '))', ')))'
];

class DataFilter {
    constructor() { }
    getCurrentLanguage() {
        return window.localStorage.getItem('languageCode') || 'zh-CHS';
    }
    getCompareResult(fieldDataValue, operator, targetValue) {
        const op = parseInt('' + operator, 10);
        switch (op) {
            case Compare.Equal:
                return fieldDataValue == targetValue;
            case Compare.NotEqual:
                return ('' + fieldDataValue).toLowerCase() !== ('' + targetValue).toLowerCase();
            case Compare.Greater:
                return fieldDataValue > targetValue;
            case Compare.GreaterOrEqual:
                return fieldDataValue >= targetValue;
            case Compare.Less:
                return fieldDataValue < targetValue;
            case Compare.LessOrEqual:
                return fieldDataValue <= targetValue;
            case Compare.Like:
                return ('' + fieldDataValue).toLowerCase().indexOf(targetValue.toLowerCase()) > -1;
            case Compare.NotLike:
                return ('' + fieldDataValue).toLowerCase().indexOf(targetValue.toLowerCase()) === -1;
            case Compare.In:
                targetValue = targetValue || [];
                return targetValue.findIndex((n) => n == fieldDataValue) > -1;
            case 1001: // Empty
                return fieldDataValue === '' || fieldDataValue === null;
            case 1002: // NotEmpty
                return fieldDataValue !== '' && fieldDataValue !== null;
            case 1003: // Null
                return fieldDataValue === null;
            case 1004: // NotNull
                return fieldDataValue !== null;
        }
    }
    getValue(object, propertyName) {
        return propertyName.split('.').filter(p => p).reduce((result, property) => {
            if (result) {
                return result[property] === undefined ? null : result[property];
            }
            else {
                return null;
            }
        }, object);
    }
}
DataFilter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DataFilter.ctorParameters = () => [];

class ArrayFilterConditionDataFilter extends DataFilter {
    constructor() {
        super();
    }
    filter(data, conditions) {
        if (data && data.size) {
            return data.filter((n) => this.validateRowData(n, conditions));
        }
        return data;
    }
    validateRowData(bindingObject, conditions) {
        if (!conditions || conditions.length === 0) {
            return true;
        }
        return this.checkRowDataWithCondition(bindingObject, conditions);
    }
    checkRowDataWithCondition(bindingObject, conditions) {
        let resultObj = null;
        if (conditions) {
            resultObj = {};
            conditions.forEach((condition) => {
                const field = condition.FilterField;
                let fieldValue = this.getValue(bindingObject, field);
                const bindingProperty = bindingObject.properties.find((item) => item.name === field);
                if (bindingProperty && bindingProperty.enableMultiLangInput && fieldValue) {
                    fieldValue = fieldValue[this.getCurrentLanguage()];
                }
                const where = condition;
                const { Value, Compare: operator1 } = where;
                if (where) {
                    const r = this.getCompareResult(fieldValue, operator1, Value);
                    if (resultObj[field] === undefined) {
                        resultObj[field] = [r];
                    }
                    else {
                        resultObj[field].push(r);
                    }
                }
            });
        }
        // return this.checkAllFieldResult(resultObj);
        const fields = Object.keys(resultObj);
        const result = [];
        fields.forEach((f) => {
            const _filters = conditions.filter((n) => n.FilterField === f);
            if (resultObj[f].length === 1) {
                result.push(resultObj[f][0]);
            }
            else {
                if (_filters[0].Relation === 1 && resultObj[f].length === 2) { // and
                    result.push(resultObj[f][0] && resultObj[f][1]);
                }
                else { // or
                    result.push(resultObj[f].indexOf(true) > -1);
                }
            }
        });
        return result.indexOf(false) === -1;
    }
}
ArrayFilterConditionDataFilter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ArrayFilterConditionDataFilter.ctorParameters = () => [];

class ObjectFilterConditionDataFilter extends DataFilter {
    constructor() {
        super();
    }
    filter(data, conditions) {
        if (data && data.size) {
            return data.filter((row) => this.validateRowData(row, conditions));
        }
        return data;
    }
    validateRowData(bindingObject, conditions) {
        if (!conditions || Object.keys(conditions).length === 0) {
            return true;
        }
        return this.checkAllFieldInRowData(bindingObject, conditions);
    }
    checkAllFieldInRowData(bindingObject, conditions) {
        let resultObj = null;
        const currentLanguage = this.getCurrentLanguage();
        if (conditions) {
            const fields = Object.keys(conditions);
            resultObj = {};
            fields.forEach((field) => {
                let fieldValue = this.getValue(bindingObject, field);
                const property = bindingObject.properties.find((item) => item.name === field);
                if (property && property.enableMultiLangInput && fieldValue) {
                    fieldValue = fieldValue[currentLanguage];
                }
                const where = conditions[field];
                const { value1, operator1, relation, operator2, value2 } = where;
                if (where) {
                    const result = this.getCompareResult(fieldValue, operator1, value1);
                    resultObj[field] = result;
                    if (relation) {
                        const result2 = this.getCompareResult(fieldValue, operator2, value2);
                        resultObj[field] = this.getRelationResult(result, relation, result2);
                    }
                }
            });
        }
        return this.checkAllFieldResult(resultObj);
    }
    getRelationResult(result1, relation, result2) {
        const _relation = relation.toLowerCase();
        if (_relation === 'and') {
            return result1 && result2;
        }
        else {
            return result1 || result2;
        }
    }
    checkAllFieldResult(resultObj) {
        if (!resultObj) {
            return true;
        }
        return Object.values(resultObj).reduce((c, n) => {
            return c && n;
        }, true);
    }
}
ObjectFilterConditionDataFilter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ObjectFilterConditionDataFilter.ctorParameters = () => [];

/**
 * 绑定列表相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingList是一个BindingObject集合
 */
class BindingList {
    /**
     * 构造函数
     */
    constructor(properties) {
        this.__type__ = 'BindingList';
        this.sortFields = [];
        this.sortDirections = [];
        /**
         * 界面数据源
         */
        this.defaultView = null;
        // #region 分页相关
        /**
         * 分页信息
         */
        this._paginationInfo = null;
        this.properties = properties;
        this.primaryKey = PropertyUtil.getPrimaryKey(properties);
        this.changes = new Subject();
        this.innerList = List();
        this.currentId = null;
        this.destroy$ = new Subject();
        this.updateDefaultView(this.changes);
    }
    set paginationInfo(sPaginationInfo) {
        this._paginationInfo = sPaginationInfo;
        if (this._paginationInfo === sPaginationInfo) {
            return;
        }
        this.changes.next({
            type: ChangeType.PaginationInfoChange,
            path: [],
            value: this._paginationInfo
        });
    }
    get paginationInfo() {
        return this._paginationInfo;
    }
    /**
     * 获取页码
     */
    get pageIndex() {
        if (!!this.paginationInfo && this.paginationInfo.hasOwnProperty("pageIndex")) {
            return this.paginationInfo.pageIndex;
        }
        return 1;
    }
    /**
     * 获取分页大小
     */
    get pageSize() {
        if (!!this.paginationInfo && this.paginationInfo.hasOwnProperty("pageSize")) {
            return this.paginationInfo.pageSize;
        }
        return 0;
    }
    /**
     * 获取数据总项数
     */
    get total() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.total || this.paginationInfo.totalCount;
        }
        return 0;
    }
    /**
     * 获取跳过的数据条数
     */
    get skip() {
        const pageIndex = this.pageIndex;
        const pageSize = this.pageSize;
        return (pageIndex - 1) * pageSize;
    }
    /**
     * 前台设置分页信息
     * @param skip skip
     * @param take take
     */
    setPaginationInfo(skip, take$$1) {
        this.paginationInfo = Object.assign({}, this.paginationInfo, {
            pageSize: take$$1,
            pageIndex: skip / take$$1 + 1
        });
        /*this.changes.next({
          type: ChangeType.PaginationInfoChange,
          path: [],
          value: this.paginationInfo
        });*/
    }
    //#endregion
    /**
     * 当前行对应的绑定对象
     * 如果currentId为null，则创建一个空结构，防止绑定报错；
     */
    get currentItem() {
        const currentItem = this.findById(this.currentId);
        if (!currentItem) {
            if (!this.emptyCurrentItem) {
                this.emptyCurrentItem = BindingObjectFactory.create(this.properties);
            }
            return this.emptyCurrentItem;
        }
        return currentItem;
    }
    /**
     * 绑定对象的数量
     */
    get length() {
        return this.innerList.count();
    }
    /**
     * 销毁
     * @param options
     */
    dispose(options) {
        this.clear(true);
        if (this.destroy$) {
            this.destroy$.next();
            this.destroy$.complete();
            this.destroy$ = null;
        }
    }
    /**
     * 添加[Symbol.iterator]，使之能通过for of遍历
     */
    [Symbol.iterator]() {
        const self = this;
        let index = -1;
        const size = this.innerList.size;
        return {
            next: function () {
                index++;
                if (index < size) {
                    return { done: false, value: self.innerList.get(index) };
                }
                return { done: true, value: undefined };
            }
        };
    }
    /**
     * 批量加载绑定对象，加载之前先清空绑定列表，并重置当前行，加载之后将第一行设置为默认当前行。
     * @param objects 要加载绑定对象数组
     */
    load(objects, entityCreate = false) {
        // 重置列表
        this.innerList = this.innerList.clear();
        if (objects.length !== 0) {
            // 加载数据
            objects.forEach((object) => {
                this.add(object);
            });
            // 设置默认当前行
            const currentItem = this.findById(this.currentId);
            if (!currentItem) {
                const firstId = objects[0][this.primaryKey];
                this.setCurrentId(firstId, false, false);
            }
        }
        else {
            this.currentId = null;
        }
        const change = {
            type: ChangeType.Load,
            path: [],
            value: objects
        };
        change.create = entityCreate;
        // 触发事件
        this.changes.next(change);
    }
    /**
     * 批量追加绑定对象，追加之后将最后一个追加的绑定对象设置为当前行。
     * @param objects 要加载绑定对象数组
     */
    append(objects, isCloned = false, options = null) {
        if (objects.length === 0) {
            return;
        }
        // 加载BindingObject
        objects.forEach((object) => {
            this.add(object);
        });
        // 当前行为新追加的最后1行
        const lastId = objects[objects.length - 1][this.primaryKey];
        this.setCurrentId(lastId, true, true);
        // 触发事件
        const change = {
            type: ChangeType.Append,
            path: [],
            value: objects,
            isTreeNodeLoadScene: options && options.isTreeNodeLoadScene
        };
        if (isCloned) {
            change.isCloned = true;
        }
        this.changes.next(change);
    }
    /**
     * 增加数据
     * @param objects 实体
     * @param options 上下文
     * @description 增加实体数据，但不切换当前行
     */
    addData(objects, options = null) {
        if (objects.length === 0) {
            return;
        }
        // 加载BindingObject
        objects.forEach((object) => {
            this.add(object);
        });
        // 触发事件
        this.changes.next({
            type: ChangeType.Append,
            path: [],
            value: objects,
            isTreeNodeLoadScene: options && options.isTreeNodeLoadScene
        });
    }
    insert(object, position) {
        const currentIndex = this.innerList.findIndex((obj) => obj.primaryKeyValue === this.currentId);
        // 加载BindingObject
        if (position === 1) {
            this.innerList = this.innerList.insert(currentIndex + 1, object);
        }
        else if (position === -1) {
            this.innerList = this.innerList.insert(currentIndex, object);
        }
        else {
            this.innerList = this.innerList.push(object);
        }
        object.parent = this;
        // 监听object变更，并继续向上抛，由于list有当前行的概念，不需要在path中追加路径
        object.changes.subscribe((change) => {
            this.changes.next(change);
        });
        this.setCurrentId(object.primaryKeyValue, true, true);
        // 触发事件
        this.changes.next({
            type: ChangeType.Append,
            path: [],
            value: object,
            detail: {
                type: 'insert',
                position
            }
        });
    }
    /**
     * 添加绑定对象，并建立绑定对象和绑定列表之间的关联。
     * @param object 绑定对象
     */
    add(object) {
        this.innerList = this.innerList.push(object);
        object.parent = this;
        // 监听object变更，并继续向上抛，由于list有当前行的概念，不需要在path中追加路径
        object.changes.subscribe((change) => {
            this.changes.next(change);
        });
    }
    /**
     * 删除主键值数组对应的绑定对象。
     * @param ids 主键值数组
     */
    removeByIds(ids) {
        if (!ids || ids.length === 0) {
            return;
        }
        let nextCurrentId = this.currentId;
        ids.forEach((id) => {
            // 如果当前行被删除，计算下一当前行
            if (id === nextCurrentId) {
                nextCurrentId = this.getCurrentIdBeforeDeleting();
            }
            // 删除对象，找不到时跳过
            const index = this.getIndexById(id);
            if (index === -1) {
                return;
            }
            this.innerList = this.innerList.delete(index);
        });
        // 重新设置当前行
        if (this.innerList.count() === 0) {
            this.currentId = null;
        }
        else {
            this.setCurrentId(nextCurrentId, false, false);
        }
        // 出发行删除事件
        this.changes.next({
            type: ChangeType.Remove,
            path: [],
            value: ids
        });
    }
    /**
     * 删除数据（不切换当前行）
     * @param ids ids
     */
    removeDataByIds(ids) {
        if (!ids || ids.length === 0) {
            return;
        }
        ids.forEach((id) => {
            // 删除对象，找不到时跳过
            const index = this.getIndexById(id);
            if (index === -1) {
                return;
            }
            this.innerList = this.innerList.delete(index);
        });
        // 出发行删除事件
        this.changes.next({
            type: ChangeType.Remove,
            path: [],
            value: ids
        });
    }
    /**
     * 清空
     */
    clear(clearOnly = false) {
        this.innerList.forEach((item) => {
            item['_ENTITY_'] = null;
            item.unsubscribe.next();
            item.unsubscribe.complete();
            item.changes.complete();
            item.viewChanges.complete();
        });
        this.innerList = this.innerList.clear();
        if (!clearOnly) {
            this.currentId = null;
            this.changes.next({
                type: ChangeType.Remove,
                path: [],
                value: []
            });
        }
    }
    /**
     * 如果当前行被删除，删除之前重新计算当前行的位置，并返回下一当前行的主键值。
     * - 如果被删除的行是最后1行，则上移1行；
     * - 其他情况，下移1行。
     */
    getCurrentIdBeforeDeleting() {
        let nextIndex = -1;
        const currentIndex = this.getIndexById(this.currentId);
        if (currentIndex === this.length - 1) {
            nextIndex = currentIndex - 1;
        }
        else {
            nextIndex = currentIndex + 1;
        }
        return this.getIdByIndex(nextIndex);
    }
    /**
     * 根据主键值获取对应绑定对象
     * @param   id 要查找的主键值
     * @returns 找到时返回对应BindingObject， 找不到时返回null
     */
    findById(id) {
        let target;
        target = this.innerList.find((item) => {
            return item.getValue(this.primaryKey) === id;
        });
        return target === undefined ? null : target;
    }
    /**
     * 将主键值为id的绑定对象设置为当前行
     * @param  id        要设置的主键值
     * @param  emitEvent 是否发送当前行变更事件
     * @param  force 强制切换
     */
    setCurrentId(id, emitEvent = true, emitGlobalEvent = true, force = false) {
        if (this.currentId === id && !force) {
            return;
        }
        // 不存在时设置为null
        // const currentObj = this.findById(id);
        // if (!currentObj) {
        //   this.currentId = null;
        // } else {
        //   this.currentId = id;
        // }
        // @todo：找不到时按理应该设置为null，目前是直接返回，框架部分功能依赖该特性。
        const currentObj = this.findById(id);
        if (!currentObj && !force) {
            return;
        }
        this.currentId = id;
        // 发出行切换事件
        if (emitEvent === true) {
            this.changes.next({
                type: ChangeType.SelectionChanged,
                path: [],
                value: this.currentItem,
                force
            });
        }
        // 是否发送全局的行切换事件
        if (emitGlobalEvent === true) {
            this.changes.next({
                type: ChangeType.GlobalSelectionChanged,
                path: [],
                value: this.currentItem,
                force
            });
        }
    }
    /**
     * 根据主键值为id的绑定对象的索引
     * @param id 主键值
     * @returns 找到时返回对应的index，找不到时返回-1
     */
    getIndexById(id) {
        return this.innerList.findIndex((obj) => {
            return obj[this.primaryKey] === id;
        });
    }
    /**
     * 根据索引位置获取对应绑定对象的主键值
     * @reutrn 找到时返回对应主键值，找不到返回null
     */
    getIdByIndex(index) {
        if (index < 0 || index > this.length) {
            return null;
        }
        if (this.innerList.has(index) === false) {
            return null;
        }
        const obj = this.innerList.get(index);
        return obj[this.primaryKey];
    }
    /**
     * 转换为BindingObject数组
     */
    toArray() {
        return this.innerList.toArray();
    }
    /**
     * 交互数据位置
     * @param id1 id1
     * @param id2 id2
     */
    swapById(id1, id2) {
        const item1 = this.innerList.find((element) => element.primaryKeyValue === id1);
        const item2 = this.innerList.find((element) => element.primaryKeyValue === id2);
        this.innerList = this.innerList.map((bindingObject, index) => {
            if (bindingObject.primaryKeyValue === id1) {
                return item2;
            }
            else if (bindingObject.primaryKeyValue === id2) {
                return item1;
            }
            else
                return bindingObject;
        }).toList();
        this.changes.next({
            type: ChangeType.Swap,
            path: [],
            detail: {
                type: 'swap',
                id: [id1, id2]
            }
        });
    }
    /**
     * 转换为JSON对象
     * @param options 配置
     * @returns 普通对象数组
     */
    toJSON(options) {
        const result = [];
        this.innerList.forEach((obj) => {
            result.push(obj.toJSON(options));
        });
        return result;
    }
    /**
     * 过滤列表数据
     * @param conditions 过滤条件
     */
    filter(conditions) {
        if (this.defaultView === null) {
            this.defaultView = this.innerList.toList();
        }
        let list;
        if (Array.isArray(conditions)) {
            const filter$$1 = new ArrayFilterConditionDataFilter();
            list = this.defaultView.filter((bindingObject) => {
                return filter$$1.validateRowData(bindingObject, conditions);
            }).toList();
        }
        else {
            const filter$$1 = new ObjectFilterConditionDataFilter();
            list = this.defaultView.filter((bindingObject) => {
                return filter$$1.validateRowData(bindingObject, conditions);
            }).toList();
        }
        // 如果有排序条件，则对过滤后的结果进行排序
        if (this.sortFields && this.sortFields.length > 0) {
            this.innerList = list.sort(this.comparator(this.sortFields, this.sortDirections)).toList();
        }
        else {
            this.innerList = list;
        }
    }
    /**
     * 获取分页信息
     * @param path 路径
     * @param defaultValue 默认值
     * @throws 路径必须为字符串！
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationInfo;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter((item) => !!item && item.trim().length > 0).map((item) => item.trim());
        let config = this.paginationInfo;
        paths.forEach((item) => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 对bindingList就行排序
     * @param fields - 排序字段
     * @param directions - 排序规则字段
     * @param options - 参数
     * @throws argument error
     */
    sortBy(fields, directions, options) {
        if (!this.defaultView) {
            this.defaultView = this.innerList.toList();
        }
        // 默认升序
        const arrFields = typeof fields === 'string' ? fields.split(',').filter((p) => p) : fields || [];
        const arrDirections = typeof directions === 'string' ? directions.split(',').filter((p) => p) : directions || [];
        // 排序字段和排序方式应一致
        if (arrFields.length !== arrDirections.length) {
            throw new Error('sortBy:fields and directions not match');
        }
        this.sortFields = arrFields;
        this.sortDirections = arrDirections;
        if (!this.sortFields || this.sortFields.length < 1) {
            if (this.defaultView) {
                this.innerList = this.defaultView.toList();
                // 清空过滤条件后重置原始数据源
                this.defaultView = null;
            }
        }
        else {
            this.innerList = this.innerList.sort(this.comparator(arrFields, arrDirections)).toList();
        }
    }
    getValue(target, propName, isMultiLangProp = false, currentLanguage = 'zh-CHS') {
        if (target instanceof BindingList) {
            target = target.currentItem;
        }
        else if (target instanceof BindingData) {
            target = target.list.currentItem;
        }
        let result = null;
        if (propName.indexOf('.') === -1) {
            result = target[propName];
        }
        else {
            const props = propName.split('.');
            for (const prop of props) {
                target = result = this.getValue(target, prop, isMultiLangProp, currentLanguage);
            }
        }
        if (isMultiLangProp && result && result.hasOwnProperty(currentLanguage)) {
            return result[currentLanguage];
        }
        else {
            return result;
        }
    }
    /**
     * 排序器
     * @param props - 排序字段
     * @param orders - 排序规则
     * @returns
     */
    comparator(props, orders) {
        return (item1, item2) => {
            return props.reduce((result, prop) => {
                if (result === 0) {
                    const bindingProperty = this.properties.find((item) => item.name === prop);
                    let isMultiLangProp = false;
                    if (bindingProperty) {
                        isMultiLangProp = bindingProperty.enableMultiLangInput;
                    }
                    const currentLanguage = TranslateService.getCurrentLanguage();
                    const order = ['asc'].includes(orders[props.indexOf(prop)]) ? 1 : -1;
                    let item1Value = this.getValue(item1, prop, isMultiLangProp, currentLanguage);
                    let item2Value = this.getValue(item2, prop, isMultiLangProp, currentLanguage);
                    if (item1Value === null || item1Value === undefined) {
                        item1Value = '';
                    }
                    if (item2Value === null || item2Value === undefined) {
                        item2Value = '';
                    }
                    if (typeof item1Value === 'string' && typeof item2Value === 'string') {
                        const localeCompareResult = item1Value.localeCompare(item2Value);
                        result = localeCompareResult * order;
                    }
                    else {
                        if (item1Value > item2Value) {
                            result = order * 1;
                        }
                        if (item1Value < item2Value) {
                            result = order * -1;
                        }
                    }
                }
                return result;
            }, 0);
        };
    }
    updateDefaultView(change) {
        change.pipe(takeUntil(this.destroy$)).subscribe((change) => {
            if (this.defaultView !== null && ((change.path.length === 0 && [ChangeType.Load, ChangeType.Append, ChangeType.Remove, ChangeType.Swap].includes(change.type)) || (change.type === ChangeType.ValueChanged && change.isBindingListTransmited !== true))) {
                switch (change.type) {
                    case ChangeType.Load:
                        this.defaultView = this.innerList.toList();
                        break;
                    case ChangeType.Append: {
                        // 插入
                        if (change.detail && change.detail.type === 'insert') {
                            const position = change.detail.position;
                            const object = change.value;
                            const currentIndex = this.innerList.findIndex((obj) => obj.primaryKeyValue === this.currentId);
                            // 加载BindingObject
                            if (position === 1) {
                                this.defaultView = this.defaultView.insert(currentIndex + 1, object);
                            }
                            else if (position === -1) {
                                this.defaultView = this.defaultView.insert(currentIndex, object);
                            }
                            else {
                                this.defaultView = this.defaultView.push(object);
                            }
                        }
                        else {
                            const objects = change.value;
                            this.defaultView = this.defaultView.push(...objects);
                        }
                        break;
                    }
                    case ChangeType.Remove:
                        const ids = change.value;
                        if (ids.length === 0) {
                            this.defaultView = this.defaultView.clear();
                        }
                        else {
                            ids.forEach((id) => {
                                const index = this.defaultView.findIndex((bindingObject) => bindingObject.primaryKeyValue === id);
                                this.defaultView = this.defaultView.delete(index);
                            });
                        }
                        break;
                    case ChangeType.ValueChanged:
                        const id = change.id;
                        const bindingObject = this.defaultView.find((obj) => obj.primaryKeyValue === id);
                        const paths = change.path.concat([]);
                        const propertyName = paths.pop();
                        const target = paths.reduce((object, path) => {
                            return object[path];
                        }, bindingObject);
                        if (target) {
                            target.setValue(propertyName, change.value);
                        }
                        break;
                    case ChangeType.Swap:
                        const [id1, id2] = change.detail && change.detail.id;
                        const item1 = this.defaultView.find((element) => element.primaryKeyValue === id1);
                        const item2 = this.defaultView.find((element) => element.primaryKeyValue === id2);
                        this.defaultView = this.defaultView.map((bindingObject, index) => {
                            if (bindingObject.primaryKeyValue === id1) {
                                return item2;
                            }
                            else if (bindingObject.primaryKeyValue === id2) {
                                return item1;
                            }
                            else
                                return bindingObject;
                        }).toList();
                        break;
                    // case ChangeType.SortChanged:
                    //   const { fields = [], directions = [] } = change.detail || {};
                    //   this.defaultView = this.defaultView.sort(this.comparator(fields, directions)).toList();
                    //   break;
                }
            }
        });
    }
}

/**
 * 绑定对象基类
 */
class BaseBindingObject {
    // private __differ__ = this.differ();
    constructor() {
        this.__type__ = 'BindingObject';
        /**
         * 绑定到实体
         */
        this.fromEntity = undefined;
        /**
         * 标识是否提交过
         */
        this.isShowValidationMsg = false;
        /**
         * 销毁流
         */
        this.unsubscribe = new Subject();
        /**
         * 以{ [propertyName]: FormControl }的形式存放每条数据的control
         */
        this.controlMap = {};
        this.innerValues = Map$1();
        this.changes = new Subject();
        this.viewChanges = new Subject();
    }
    /**
     * 主键值
     */
    get primaryKeyValue() {
        return this.primaryKey ? this.getValue(this.primaryKey) : '';
    }
    /**
     * 数据行的主键值
     */
    get rowPrimaryKeyValue() {
        const row = this.getRow(this);
        return row && row.primaryKeyValue || null;
    }
    /**
     * 设置是否提交过
     */
    setShowValidationMsg(flag) {
        this.isShowValidationMsg = flag;
    }
    // public abstract load(data: any);
    /**
     * 根据属性名获取属性值
     * @param   propertyName 属性名
     * @returns 属性值
     */
    getValue(propertyName) {
        return this.innerValues.get(propertyName);
    }
    /**
     * 设置属性值
     * @param propertyName        属性名
     * @param propertyValue       属性值
     * @param emitEventToView     是否通知View层去更新界面，默认为false
     * @param emitEventToEntity   是否通知Entity层去更新值，默认为false
     * @param errors              错误消息
     * @param invokeOnValueChange 值变化事件执行句柄
     */
    setValue(propertyName, propertyValue, emitEventToView = false, emitEventToEntity = false, errors, invokeOnValueChange, context) {
        // 屏蔽掉无效的赋值，防止后续赋值对比时跳过，导致实体无法赋值
        // if (this.primaryKey && !this.primaryKeyValue && this.primaryKey !== propertyName) {
        //   return;
        // }
        const oldPropertyValue = this.getValue(propertyName);
        // 由于特定原因（@邵珠强），无法屏蔽oldPropertyValue === propertyValue
        // if (oldPropertyValue === propertyValue) {
        //   return;
        // }
        if (!invokeOnValueChange || oldPropertyValue === propertyValue) {
            // 设定缺省
            invokeOnValueChange = function (preValue, value, entityChanged, primaryValue) {
                return of(true);
            };
        }
        if (emitEventToEntity === true) {
            // BUG 322301，删除@2019.08.10; 如果无对应实体，则中止值传递; 这种情况发生在带从表的单据新增，从表响应Load变化的情况；
            // if(!this.innerValues.has(propertyName)) {
            //   return;
            // }
            // 执行实体值变化前事件
            invokeOnValueChange(oldPropertyValue, propertyValue, false, this.rowPrimaryKeyValue).subscribe((result) => {
                if (result) {
                    //this.__differ__.onValueChange();
                    // 如果成功，执行变化，并通知实体变化
                    this.innerValues = this.innerValues.set(propertyName, propertyValue);
                    // this.data[propertyName] = propertyValue;
                    const viewChange = this.buildViewChangesContext(propertyName, propertyValue, oldPropertyValue, errors, context);
                    this.viewChanges.next(viewChange);
                    // 如果需要通知视图，通知视图相应修改
                    if (emitEventToView === true) {
                        const change = this.buildChangesContext(propertyName, propertyValue, context, errors);
                        this.changes.next(change);
                    }
                    // 执行实体值变化后事件
                    invokeOnValueChange(oldPropertyValue, propertyValue, true, this.rowPrimaryKeyValue).subscribe();
                }
                else {
                    // 如果失败，不再通知实体变化
                    // 并执行界面回滚操作
                    const change = this.buildChangesContext(propertyName, oldPropertyValue, context, errors);
                    this.changes.next(change);
                }
            });
        }
        else {
            //this.__differ__.onValueChange();
            // `emitEventToEntity === false`, 则认定实体值已经发生变化，通知视图变化，并触发实体值变化后事件
            this.innerValues = this.innerValues.set(propertyName, propertyValue);
            // this.data[propertyName] = propertyValue;
            if (emitEventToView === true) {
                const change = this.buildChangesContext(propertyName, propertyValue, context, errors);
                this.changes.next(change);
            }
            // 执行实体值变化后事件
            invokeOnValueChange(oldPropertyValue, propertyValue, true, this.rowPrimaryKeyValue).subscribe();
        }
    }
    /**
     * 将BindingObject实例转换成JSON对象
     */
    toJSON(options) {
        //if (!this.__differ__.isChange()) {
        //  return this.__differ__.value();
        //}
        const langCode = this.getCurrentLanguage(); //window.localStorage.getItem('languageCode') || 'zh-CHS';
        const result = {};
        this.properties.forEach((property) => {
            const propName = property.name;
            if (property.type === BindingPropertyType.List) {
                const list = this[propName];
                result[propName] = list.toJSON(options);
            }
            else if (property.type === BindingPropertyType.Object) {
                const object = this[propName];
                result[propName] = object.toJSON(options);
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                const object = this[propName];
                result[propName] = object.toJSON(options);
            }
            else {
                // 1、对于多语录入字段；
                // 2、传入ignoreMultiLangInput标志，则取当前语言的值给控件。
                if (property.enableMultiLangInput === true) {
                    // 忽略多语字段，只返回当前语言
                    if (options && options.ignoreMultiLangInput === true) {
                        const multiLangValueObj = this.getValue(propName);
                        if (multiLangValueObj) {
                            result[propName] = multiLangValueObj[langCode];
                        }
                        else {
                            result[propName] = multiLangValueObj;
                        }
                    }
                    else if (options && options.useFullMultiLangProperty) {
                        // 给审批提供的扩展 @2021-10-13
                        const multiLangValueObj = this.getValue(propName);
                        if (multiLangValueObj) {
                            result[`${propName}_MULTILANGUAGE`] = multiLangValueObj;
                            // 除返回多语字段外，将当前语言也返回
                            result[propName] = multiLangValueObj[langCode];
                        }
                    }
                    else {
                        const multiLangValueObj = this.getValue(propName);
                        if (!multiLangValueObj) {
                            result[propName] = { [langCode]: multiLangValueObj };
                        }
                        else {
                            result[propName] = multiLangValueObj;
                        }
                    }
                }
                else {
                    result[propName] = this.getValue(propName);
                }
            }
        });
        // this.__differ__.update(result);
        return result;
    }
    /**
     * 获取当前语言
     * @returns
     */
    getCurrentLanguage() {
        this.currentLanguage = this.currentLanguage || window.localStorage.getItem('languageCode') || 'zh-CHS';
        return this.currentLanguage;
    }
    /**
     * 构造bindignData变更上下文
     * @param propertyName
     * @param propertyValue
     * @param context
     * @param errors
     * @param type
     * @returns
     */
    buildChangesContext(propertyName, propertyValue, context, errors, type = ChangeType.ValueChanged) {
        const object = this.getRow(this);
        const id = object ? object.primaryKeyValue : null;
        return {
            type: type,
            path: [propertyName],
            value: propertyValue,
            id: id,
            errors: errors,
            context
        };
    }
    /**
     * 构造viewChanges上下文
     * @param propertyName
     * @param value
     * @param preValue
     * @param errors
     * @param context
     * @param type
     * @returns
     */
    buildViewChangesContext(propertyName, value, preValue, errors, context, type = ViewChangeType.ValueChanged) {
        return {
            type: type,
            path: [propertyName],
            value: value,
            preValue: preValue,
            errors: errors,
            context
        };
    }
    getRow(bindingObject) {
        if (bindingObject && bindingObject.fromEntity) {
            return bindingObject;
        }
        if (bindingObject.parent && !(bindingObject.parent instanceof BindingList)) {
            return this.getRow(bindingObject.parent);
        }
        else {
            return bindingObject;
        }
    }
    makeHash() {
        var text = "";
        var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (var i = 0; i < 10; i++)
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        return text;
    }
    differ() {
        let previous, next, value;
        return {
            onValueChange: () => {
                next = this.makeHash();
            },
            isChange: () => {
                return next !== previous;
            },
            update: (result) => {
                value = result;
                previous = next;
            },
            value: () => {
                return value;
            }
        };
    }
}

/**
 * BindingObject是Entity在绑定层的一个影射，它将Entity内的数据转换为不可变对象，并用于界面绑定。
 */
class BindingObject extends BaseBindingObject {
    /**
     * 构造函数
     * @param properties 属性集合
     */
    constructor(properties) {
        super();
        this.properties = properties;
        this.primaryKey = PropertyUtil.getPrimaryKey(properties);
    }
}

class BindingDataFactory {
    /**
     * 根据Repository创建一个BindingData
     */
    static createFromRepository(repository, bindingPath) {
        const bindingData = new BindingData();
        const bindingProperties = PropertyUtil.getProperties(repository.entityType);
        const bindingList = BindingListFactory.create(bindingProperties);
        bindingData.initByBindingList(bindingList, bindingPath);
        bindingData.setDataTypeInfo(repository.entityTypeInfo);
        EntityUtil.loadRepository(repository, bindingList);
        // 从repository初始化bindingData
        bindingData.pagingInfo = repository.entityCollection.paginationInfo;
        return bindingData;
    }
    /**
     * 根据EntityManager创建BindingData，并建立双向关联（请勿使用）
     * @internal
     * @summary
     * 1、该方法暂时仅供内部单元测试使用；
     * 2、该方法暂时只创建BindingData，不建立双向关联
     */
    static createFromEntityManager(entityManager, bindingPath) {
        const bindingData = new BindingData();
        const bindingProperties = PropertyUtil.getProperties(entityManager.entityType);
        const bindingList = BindingListFactory.create(bindingProperties);
        bindingData.initByBindingList(bindingList, bindingPath);
        // 初始化数据
        const entities = entityManager.getEntitiesByPath([]);
        EntityUtil.loadEntities(entities, bindingList);
        return bindingData;
    }
    /**
     * 根据已经存在的BindingData创建一个新的BindingData
     */
    static createFromExistingBindingData(existingBindingData, bindingPath) {
        const bindingData = new BindingData();
        bindingData.initByBindingList(existingBindingData.list, bindingPath);
        return bindingData;
    }
}

/**
 * 绑定装饰器相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * NgBindingData装饰器名称
 * @formType {string}
 */
const NG_BINDING_DATA = 'NgBindingData';
/**
 * NgBindingContext
 */
// export const NgBindingData: NgBindingDataDecorator =
//   makeDecorator(NG_BINDING_DATA, (obj: NgBindingData) => obj);
function NgBindingData(options) {
    const decoratorFactory = makeDecorator(NG_BINDING_DATA, (obj) => obj);
    return decoratorFactory(options);
}

/**
 * 路径处理工具类（处理/PathNode1/PathNode2/...格式的路径）
 */
class DataPathUtil {
    /**
     * 转换成BindingData可识别的路径
     */
    static convertToBindingPathArray(path) {
        const bindingPathArray = path.split('/').filter((part) => {
            return part !== '';
        });
        return bindingPathArray;
    }
    /**
     * 转换为Entity可识别的路径
     * 根：[]
     * 主表：['id:xxx', 'name'],
     * 关联：['id:xxx', 'deptInfo', 'id:xxx', 'name']
     * UDT: ['id:xxx', 'updateInfo', ':', 'createdOn']
     * 从表：['id:xxx', 'edus', 'id:xxx', 'name'],
     * 从从表：['id:xxx', 'edus', 'id:xxx', 'grades', 'id:xxx', 'name']
     */
    static convertToEntityPathArray(path, bindingData) {
        const bindingPathArray = this.convertToBindingPathArray(path);
        const entityPathArray = [];
        if (bindingPathArray.length === 0) {
            return entityPathArray;
        }
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            switch (propInfo.type) {
                case BindingPropertyType.Plain:
                    entityPathArray.push(propName);
                    break;
                case BindingPropertyType.Object:
                    currentBindingObject = currentBindingObject[propName];
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                case BindingPropertyType.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                default:
                    break;
            }
        });
        return entityPathArray;
    }
    /**
     * 转换为RestUrl里的路径
     *
     * 返回结果：
     * 主表（/）：/
     * 从表（/jiwtEdus）：/xxx/jiwtEdus
     * 从从表（/jiwtEdus/jiwtGrades）： /xxx/jiwtEdus/xxx/jiwtGrades
     */
    static convertToRestUrl(path, bindingData) {
        const bindingPathArray = this.convertToBindingPathArray(path);
        const restPathArray = [];
        let currentBindingObject = bindingData.list.currentItem;
        restPathArray.push(currentBindingObject.primaryKeyValue);
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            if (propInfo.type !== BindingPropertyType.List) {
                throw new Error(`${propInfo.name}不是子表对应的属性`);
            }
            const currentBindingList = currentBindingObject[propName];
            currentBindingObject = currentBindingList.currentItem;
            restPathArray.push(propName);
            restPathArray.push(currentBindingObject.primaryKeyValue);
        });
        // 移除最后一个主键
        restPathArray.pop();
        return '/' + restPathArray.join('/');
    }
    /**
     * 获取叶子节点的Path
     */
    static getLeafPath(path) {
        const pathArray = DataPathUtil.convertToBindingPathArray(path);
        return pathArray.pop();
    }
    /**
     * 获取父路径
     */
    static getParentPath(path) {
        const pathArray = DataPathUtil.convertToBindingPathArray(path);
        pathArray.pop();
        return '/' + pathArray.join('/');
    }
    /**
     * 创建路径中的主键部分
     */
    static createPrimaryKeyPath(primaryKey, primaryKeyValue) {
        return `${primaryKey}:${primaryKeyValue}`;
    }
}

// tslint:disable: max-line-length
/**
 * GUID创建服务
 * @scope 静态类没有提供Provider
 */
class Guid {
    constructor(guid) {
        if (!guid) {
            throw new TypeError('Invalid argument; `value` has no value.');
        }
        this.value = Guid.EMPTY;
        if (guid) {
            this.value = guid;
        }
    }
    static isGuid(guid) {
        const value = guid.toString();
        return guid && (guid instanceof Guid || Guid.validator.test(value));
    }
    static create() {
        return new Guid(UID.create());
    }
    static createEmpty() {
        return new Guid('');
    }
    static parse(guid) {
        return new Guid(guid);
    }
    static raw() {
        return UID.create();
    }
    equals(other) {
        // Comparing string `value` against provided `guid` will auto-call
        // toString on `guid` for comparison
        return Guid.isGuid(other) && this.value === other.toString();
    }
    isEmpty() {
        return this.value === Guid.EMPTY;
    }
    toString() {
        return this.value;
    }
    toJSON() {
        return {
            value: this.value,
        };
    }
}
Guid.validator = new RegExp('^[a-z0-9]+$', 'i');
Guid.EMPTY = '';

class RunModeService {
    static setRunMode(mode) {
        RunModeService.mode = mode;
    }
    static getRunMode() {
        return RunModeService.mode;
    }
}
RunModeService.mode = null;

/**
 * @author Lucas Huang
 * 实体抽象基类，所有实体必须扩展自Entity
 *
 * ### 使用示例
 * ```
 * export class UserEntity extends Entity {
 *    userId: string;
 *    userName: string;
 *
 *    constructor(data: any){
 *        super(data);
 *    }
 * }
 * ```
 */
class Entity {
    // #endregion
    /**
     * @param data JSON数据
     */
    constructor(data) {
        // #region 私有、保护属性
        /**
         * 验证错误集合
         */
        this.validErrors = {};
        this.primaryFieldMetadata = null;
        this.originalData = undefined;
        /**
         * 增量变更集合
         */
        this.changeSet = new ChangeSet();
        /**
         * 是否正在验证
         */
        this.isValidating = false;
        /**
         * 新数据
         */
        this.newData = undefined;
        /**
         * 销毁流
         */
        this.unsubscribe = new Subject();
        // #endregion
        // #region 公有属性
        /**
         * 变更流
         */
        this.valueChanged = new Subject();
        /**
         * 属性值改变时触发
         *
         * ### 使用示例
         * ```
         *  const entity = new UserEntity(data);
         *  entity.onValueChanged.subscribe((data: Modification) => {
         *      console.log(data);
         *  })
         *
         * ```
         *
         * @event
         */
        this.onValueChanged = this.valueChanged.asObservable();
        this.onUpdate = new Subject();
        this.validator = new Validator();
        this.newData = Object.assign({}, data);
        this.originalData = Object.assign({}, data);
        this.onValueChanged = this.valueChanged;
        // this.onValueChanged = this.valueChanged.pipe(
        //     scan((x: Modification, curr: Modification) => {
        //         if (x) {
        //             if (isEqual(x.path, curr.path) && x.type === curr.type) {
        //                 return Object.assign(x, curr);
        //             }
        //             return curr;
        //         }
        //         return curr;
        //     })
        // );
        if (RunModeService.getRunMode() === RunMode.compatible) {
            this.initialize();
        }
        // this.validate();
    }
    /**
     * 返回JSON格式的数据
     */
    get data() {
        return this.newData;
    }
    set data(value) {
        this.newData = value;
    }
    /**
     * 验证错误集合
     */
    get errors() {
        return this.validErrors;
    }
    set errors(errors) {
        this.validErrors = errors;
    }
    set changeSetPolicy(policy) {
        this._changeSetPolicy = policy;
    }
    get changeSetPolicy() {
        return this._changeSetPolicy;
    }
    /**
     * 实体变更集
     */
    get changes() {
        return this.changeSet.changes;
    }
    /**
     * 实体主键元数据
     */
    get primaryProperty() {
        if (!this.primaryFieldMetadata) {
            this.primaryFieldMetadata = FieldMetadataUtil.getPrimaryFieldMetadata(this.constructor);
        }
        return this.primaryFieldMetadata;
    }
    /**
     * 主键
     * @todo
     * 1、没有主键时返回''不合理，应该返回undefined
     */
    get primaryKey() {
        if (this.primaryProperty) {
            return this.primaryProperty.property;
        }
        else {
            return '';
        }
    }
    /**
     * 实体主键值
     * 1、没有主键时返回''不合理，应该返回undefined
     */
    get primaryValue() {
        if (this.primaryKey) {
            // return this[this.primaryProperty.property].toString();
            const primaryValue = this[this.primaryProperty.property];
            return primaryValue ? primaryValue : '';
        }
        else {
            return '';
        }
    }
    // #region 公有方法
    /**
     * 将变更记录保存至变更集中
     * @param value 变更记录
     */
    setChanges(value) {
        const propertyName = value.path[value.path.length - 1];
        // @todo：事件会从下级向上冒泡，change可能是下级的，不能和当前Entity的newData合并。
        // this.newData = Object.assign(this.newData, { [propertyName]: value.value });
        this.valueChanged.next(value);
        if (!(this.validErrors && Object.keys(this.validErrors).includes(propertyName) && this.changeSetPolicy === 'valid')) {
            if (value && value.changeSetValue !== undefined) {
                value = JSON.parse(JSON.stringify(value));
                value.value = value.changeSetValue;
            }
            this.changeSet.append(value);
        }
    }
    /**
     * 校验实体各属性的值
     * @param propertyName 属性名称，如果为空，则验证实体中所有设置了验证规则的属性
     * @returns Observable<ValidationResult>
     * ### 示例
     * ```
     *  const entity = new UserEntity(data);
     *  entity.validate().subscribe(result =>{
     *      if(result.isValid){
     *          ...
     *      } else {
     *          console.log(result.message);
     *      }
     *  })
     *
     * ```
     */
    // tslint:disable-next-line: max-line-length
    validate(propertyName, value, externalRules, index, frameContext) {
        return from(this.validator.validate(this, propertyName, value, externalRules, index, frameContext)).pipe(tap(result => {
            if (!result.isValid) {
                this.validErrors = ValidationUtils.convertErrorsToNormalObject(result.errors, {});
            }
            else {
                this.validErrors = {};
            }
        }));
    }
    validateAll(validateContext) {
    }
    // 用于在entity_util中调用，如果有错误，会将验证结果传入回调cb
    validateFromUtil(propertyName, value, cb, context) {
        this.validErrors = {};
        from(this.validator.validate(this, propertyName, value, null, undefined, context && context.frameContext || null)).subscribe(result => {
            if (!result.isValid) {
                this.validErrors = ValidationUtils.convertErrorsToNormalObject(result.errors, {});
            }
            // 不应重新赋值，这里仅是实体校验通过
            /*else {
              // 如果BindingObject上的属性值和Entity上对应属性值一样，则不再设置
              if (this[propertyName] === value) {
                return;
              }
              this[propertyName] = value;
            }*/
            cb(result);
        });
    }
    /**
     * 同步校验
     * @param propertyName
     * @param value
     * @param cb
     */
    validateFromUtilSync(propertyName, value, cb, context) {
        this.validErrors = {};
        const result = this.validator.verify(this, propertyName, value, null, undefined, context && context.frameContext || null, true);
        if (result && !result.isValid) {
            this.validErrors = ValidationUtils.convertErrorsToNormalObject(result.errors, {});
        }
        cb(result);
    }
    getPaths() {
        const pathObj = {
            path: [],
            isUdt: false,
            isGrid: false
        };
        const handleParent = item => {
            const parentPaths = item[PARENT_PATH];
            if (parentPaths) {
                const prop = parentPaths[parentPaths.length - 1];
                // 父级所在实体包含的ngObject，存在当前实体字段，则判断为UDt字段
                if (Object.keys(FieldMetadataUtil.getNgObjects(item[PARENT_CLASS].constructor)).indexOf(prop) > -1) {
                    pathObj.isUdt = true;
                }
                // 存在类型为ngList，则判断为grid
                if (item instanceof EntityList === true) {
                    pathObj.isGrid = true;
                }
                else {
                    pathObj.path.push(prop);
                }
            }
            if (item[PARENT_CLASS]) {
                handleParent(item[PARENT_CLASS]);
            }
        };
        handleParent(this);
        pathObj.path = pathObj.path.reverse();
        return pathObj;
    }
    getEntityListPath() {
        let paths = [];
        const handleParent = (item) => {
            const parentPaths = item[PARENT_PATH];
            if (parentPaths) {
                if (item instanceof EntityList === true) {
                    const path = parentPaths.concat([]).reverse();
                    Array.prototype.push.apply(paths, path);
                }
            }
            if (item[PARENT_CLASS]) {
                handleParent(item[PARENT_CLASS]);
            }
        };
        handleParent(this);
        return paths.reverse();
    }
    getMainEntityPrimaryValue() {
        let item = this;
        while (item[PARENT_CLASS]) {
            item = item[PARENT_CLASS];
        }
        return item.primaryValue;
    }
    /**
     * 加载数据
     * @param data 新数据
     */
    load(data, options = {}) {
        if (!data) {
            data = {};
        }
        this.loadFields(data);
        if (!options || (options && options.loadChild !== false)) {
            this.loadLists(data);
        }
        this.loadObjects(data);
        this.loadDynamicObjects(data);
        this.newData = Object.assign({}, data);
        this.originalData = Object.assign({}, data);
    }
    /**
     * 转换为JSON
     * @param buildChanges 是否构造变更集
     * @param includeMultiLanguageField 是否包含多语字段
     */
    toJSON(buildChanges) {
        const result = {};
        // 简单属性
        const ngFields = FieldMetadataUtil.getNgFields(this.constructor);
        Object.keys(ngFields).forEach((propName) => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            if (buildChanges === true && ngField.enableTimeZone === true) {
                result[dataField] = this.data[propName];
            }
            else {
                result[dataField] = this[propName];
            }
        });
        // 对象属性
        const ngObjects = FieldMetadataUtil.getNgObjects(this.constructor);
        Object.keys(ngObjects).forEach((propName) => {
            const ngObject = ngObjects[propName];
            const dataField = ngObject.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON(buildChanges) : {};
        });
        // 动态属性
        const ngDynamics = FieldMetadataUtil.getNgDynamic(this.constructor);
        Object.keys(ngDynamics).forEach((propName) => {
            const ngDynamic = ngDynamics[propName];
            const dataField = ngDynamic.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON(buildChanges) : {};
        });
        // 列表属性
        const ngLists = FieldMetadataUtil.getNgList(this.constructor);
        Object.keys(ngLists).forEach((propName) => {
            const ngList = ngLists[propName];
            const dataField = ngList.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON(buildChanges) : {};
        });
        return result;
    }
    // #endregion
    //#region 实体初始化相关private方法
    /**
     * 初始化实体
     */
    initialize() {
        const constructor = this.constructor;
        const ngFields = FieldMetadataUtil.getNgFields(constructor);
        const ngObjects = FieldMetadataUtil.getNgObjects(constructor);
        const ngLists = FieldMetadataUtil.getNgList(constructor);
        const ngDynamic = FieldMetadataUtil.getNgDynamic(constructor);
        this.initializeNormalField(ngFields);
        this.initializeList(ngLists);
        this.initializeObject(ngObjects);
        this.initializeDynamic(ngDynamic);
    }
    /**
     * 创建path
     * @param propertyName 属性名称
     */
    createPath(propertyName) {
        const primaryFieldMetadata = this.primaryProperty;
        if (primaryFieldMetadata) {
            const primaryDataField = primaryFieldMetadata.dataField;
            return [primaryDataField + ':' + this.primaryValue, propertyName];
        }
        else {
            return [':', propertyName];
        }
    }
    /**
     * 属性字段初始化
     * @param ngFields 属性字段元数据
     */
    initializeNormalField(ngFields) {
        Object.keys(ngFields).forEach(propName => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            if (delete this[propName]) {
                Object.defineProperty(this, propName, {
                    get: function () {
                        const value = this.getPropValue(propName, ngField);
                        return value;
                    },
                    set: function (newPropValue) {
                        // 值相同时不触发变更。
                        const oldPropValue = this.getPropValue(propName, ngField);
                        if (this.isPropValueChanged(propName, ngField, newPropValue, oldPropValue) === false) {
                            return;
                        }
                        this.setPropValue(propName, ngField, newPropValue);
                        const changeSetValue = this.preparePropValue(propName, ngField, newPropValue);
                        this.emitValueChange(propName, ngField, newPropValue, oldPropValue, changeSetValue);
                    }
                });
            }
        });
    }
    /**
     * 初始化列表类型的元数据
     * @param ngListMetadata 列表类型元数据
     */
    initializeList(ngListMetadata) {
        Object.keys(ngListMetadata).forEach(propertyName => {
            const fieldMetadata = ngListMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            const val = this.data[dataField];
            const entityList = new EntityList();
            entityList[PARENT_CLASS] = this;
            entityList[PARENT_PATH] = path;
            if (val) {
                const entities = val.map(v => EntityFactory(fieldMetadata.type, v));
                entityList.loadEntities(entities);
            }
            entityList.onListChanged.subscribe(value => {
                if (value) {
                    if (entityList[PARENT_PATH][0] !== value.path[0]) {
                        value.path = entityList[PARENT_PATH].concat(value.path);
                    }
                    this.setChanges(value);
                }
            });
            this[propertyName] = entityList;
        });
    }
    /**
     * 初始化子对象
     * @param ngObjectMetadata 子对象元数据
     */
    initializeObject(ngObjectMetadata) {
        Object.keys(ngObjectMetadata).forEach(propertyName => {
            const fieldMetadata = ngObjectMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            // val不存在时，用空对象代替
            const val = this.data[dataField] || {};
            const createEntityFromJsonData = (value) => {
                let instance;
                if (value instanceof fieldMetadata.type) {
                    instance = value;
                }
                else {
                    instance = EntityFactory(fieldMetadata.type, value);
                }
                instance[PARENT_CLASS] = this;
                instance[PARENT_PATH] = path;
                instance.onValueChanged.subscribe(changes => {
                    if (changes) {
                        changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                        this.setChanges(changes);
                    }
                });
                return instance;
            };
            // 如果没有值用一个空对象代替
            let childEntity = createEntityFromJsonData(val);
            if (delete this[propertyName]) {
                Object.defineProperty(this, propertyName, {
                    get: () => {
                        return childEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: childEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        childEntity = createEntityFromJsonData(value);
                        this.setChanges(modifyInfo);
                    }
                });
            }
        });
    }
    initializeDynamic(ngDynamicMetadata) {
        Object.keys(ngDynamicMetadata).forEach(propertyName => {
            const fieldMetadata = ngDynamicMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            const originalData = this.data[dataField] || {};
            const createEntityFromJsonData = (value) => {
                let instance;
                if (value instanceof fieldMetadata.type) {
                    instance = value;
                }
                else {
                    instance = EntityFactory(fieldMetadata.type, value);
                }
                instance[PARENT_CLASS] = this;
                instance[PARENT_PATH] = path;
                instance.onValueChanged.subscribe(changes => {
                    if (changes) {
                        changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                        this.setChanges(changes);
                    }
                });
                return instance;
            };
            let dynamicEntity = createEntityFromJsonData(originalData);
            if (delete this[propertyName]) {
                Object.defineProperty(this, propertyName, {
                    get: function () {
                        return dynamicEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: dynamicEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        dynamicEntity = createEntityFromJsonData(value);
                        this.setChanges(modifyInfo);
                    }
                });
            }
        });
    }
    //#endregion
    // #region 加载实体数据相关private、projected方法
    /**
     * 加载简单字段值
     * @todo 临时用修改的方式模拟
     */
    loadFields(data) {
        const ngFields = FieldMetadataUtil.getNgFields(this.constructor);
        Object.keys(ngFields).forEach((propName) => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            // if (ngField.primary === false) {
            //   this[propName] = data[dataField];
            // }
            let propValue = data[dataField];
            if (ngField.enableTimeZone === true) {
                const timeZoneOffset = UserSettingsService.getTimeZoneOffset();
                if (timeZoneOffset !== null && propValue) {
                    propValue = ZonedTime.zonedTimeToSpecialTimeZoneOffsetTimeString(propValue, timeZoneOffset);
                }
            }
            this[propName] = propValue;
        });
    }
    /**
     * 加载子列表数据
     * @param data 数据
     */
    loadLists(data) {
        const ngLists = FieldMetadataUtil.getNgList(this.constructor);
        Object.keys(ngLists).forEach((propName) => {
            const ngList = ngLists[propName];
            const dataField = ngList.dataField || propName;
            const entityType = ngList.type;
            // 创建实体
            const listData = data[dataField];
            if (listData) {
                const entities = listData.map((entityData) => {
                    return EntityFactory(entityType, entityData);
                });
                this[propName].loadEntities(entities);
            }
            else {
                this[propName].loadEntities([]);
            }
        });
    }
    loadObjects(data) {
        const ngObjects = FieldMetadataUtil.getNgObjects(this.constructor);
        Object.keys(ngObjects).forEach((propName) => {
            const ngObject = ngObjects[propName];
            const dataField = ngObject.dataField || propName;
            const objectData = data[dataField];
            const entity = this[propName];
            if (!entity || !objectData) {
                return;
            }
            entity.load(objectData);
        });
    }
    loadDynamicObjects(data) {
        const ngDynamicObjects = FieldMetadataUtil.getNgDynamic(this.constructor);
        Object.keys(ngDynamicObjects).forEach((propName) => {
            const ngDynamicObject = ngDynamicObjects[propName];
            const dataField = ngDynamicObject.dataField || propName;
            const dynamicData = data[dataField] || {};
            const dynamicEntity = this[propName];
            if (!dynamicEntity) {
                return;
            }
            dynamicEntity.loadDynamicData(dynamicData);
        });
    }
    // #endregion
    // #region 私有工具方法
    /**
     * 发送值变更
     */
    emitValueChange(propName, propMetadata, newPropValue, oldPropValue, changeSetValue = undefined) {
        const change = {
            path: this.createPath(propName),
            value: newPropValue,
            changeSetValue,
            preValue: oldPropValue,
            type: ModifyType.ValueChange
        };
        if (this[PARENT_PATH]) {
            change.path = this[PARENT_PATH].concat(change.path);
        }
        this.setChanges(change);
    }
    /**
     * 准备提交给后端的属性值
     * @param propName 属性
     * @param propMetadata 属性描述
     * @param propValue 属性值
     */
    preparePropValue(propName, propMetadata, propValue) {
        let value = undefined;
        // 只要启用时区，传给后端的时间就必须带时区，因此当获取用户时区失败的时候，获取浏览器当前时区
        if (propMetadata.enableTimeZone === true) {
            const timeZoneOffset = UserSettingsService.getTimeZoneOffset();
            if (timeZoneOffset !== null && propValue) {
                value = ZonedTime.timeZoneOffsetTimeToUtcTimeString(propValue, timeZoneOffset);
            }
        }
        return value;
    }
    /**
     * 获取属性值
     */
    getPropValue(propName, propMetadata) {
        const dataField = propMetadata.dataField || propName;
        let value = this.data[dataField];
        // 对多语录入字段，query不返回问题进行兼容
        if (propMetadata.enableMultiLangInput === true && !value) {
            const langCode = window.localStorage.getItem('languageCode') || 'zh-CHS';
            const originDataField = dataField.replace('_MULTILANGUAGE', '');
            return {
                [langCode]: this.data[originDataField]
            };
        }
        // 启用时区
        if (propMetadata.enableTimeZone === true) {
            const timeZoneOffset = UserSettingsService.getTimeZoneOffset();
            if (timeZoneOffset !== null && value) {
                return ZonedTime.zonedTimeToSpecialTimeZoneOffsetTimeString(value, timeZoneOffset);
            }
        }
        if (propMetadata.originalDataFieldType === BigNumberType) {
            value = value !== null && value !== undefined && value.toString() || null;
        }
        return value;
    }
    /**
     * 设置属性值
     */
    setPropValue(propName, propMetadata, propValue) {
        const dataField = propMetadata.dataField || propName;
        if (propMetadata.originalDataFieldType === BigNumberType) {
            this.data[dataField] = propValue === null ? null : propValue && propValue.toString() || '';
        }
        else {
            if (propMetadata.enableTimeZone === true) {
                const timeZoneOffset = UserSettingsService.getTimeZoneOffset();
                if (timeZoneOffset !== null && propValue) {
                    propValue = ZonedTime.timeZoneOffsetTimeToUtcTimeString(propValue, timeZoneOffset);
                }
            }
            this.data[dataField] = propValue;
        }
    }
    /**
     * 检查属性值是否发生变化
     */
    isPropValueChanged(propName, propMetadata, newPropValue, oldPropValue) {
        if (propMetadata.enableMultiLangInput === true) {
            if (this.isEmptyMultiLangPropValue(newPropValue) === true && this.isEmptyMultiLangPropValue(oldPropValue) === true) {
                return false;
            }
            return JSON.stringify(newPropValue) !== JSON.stringify(oldPropValue);
        }
        else if (propMetadata.originalDataFieldType === BigNumberType) {
            if (typeof newPropValue !== 'string' && newPropValue !== null && newPropValue !== undefined) {
                newPropValue = newPropValue.toString();
            }
            return newPropValue !== oldPropValue;
        }
        else {
            return newPropValue !== oldPropValue;
        }
    }
    /**
     * 多语录入字段的值是否为空
     */
    isEmptyMultiLangPropValue(value) {
        if (!value) {
            return true;
        }
        const keys = Object.keys(value);
        if (keys.length === 0) {
            return true;
        }
        // 值全部为空，视为空
        const vals = Object.values(value);
        const allEmptyVal = vals.every((val) => {
            return !val;
        });
        if (allEmptyVal === true) {
            return true;
        }
        return false;
    }
}

/**
 * 支持动态字段集合的动态实体
 */
class DynamicEntity extends Entity {
    /**
     * 是否是嵌套的动态实体
     */
    get IsNested() {
        return this[PARENT_CLASS] instanceof DynamicEntity;
    }
    /**
     * @param data JSON数据
     */
    constructor(data) {
        super(data);
        this.loadDynamicData(data);
    }
    loadDynamicData(dynamicData) {
        this.initializeDynamicField(dynamicData);
        // super.loadFields(dynamicData);
    }
    /**
     * 初始化动态数据
     * @param dynamicData 动态数据
     */
    initializeDynamicField(dynamicData) {
        // 遍历动态数据的key，创建动态实体属性。
        Object.keys(dynamicData).forEach(propertyName => {
            const dataField = propertyName;
            if (delete this[propertyName]) {
                if (dynamicData[propertyName] instanceof Object) {
                    const path = this.createPath(propertyName);
                    let dynamicEntity = this.createDynamicEntityFromJsonData(dynamicData[propertyName], path);
                    // this.constructor['__prop__metadata__'] = this.constructor['__prop__metadata__'] || {};
                    // NgObject({
                    //     /** 字段名称 */
                    //     dataField: propertyName,
                    //     /** 原始字段名称 */
                    //     originalDataField: propertyName,
                    //     /** 是否为外键 */
                    //     type: DynamicEntity
                    // })(this, propertyName);
                    Object.defineProperty(this, propertyName, {
                        get: function () {
                            return dynamicEntity;
                        },
                        set: function (value) {
                            const modifyInfo = {
                                path: dynamicEntity[PARENT_PATH],
                                value: value.data,
                                preValue: this[propertyName].data,
                                type: ModifyType.ValueChange
                            };
                            dynamicEntity = this.createDynamicEntityFromJsonData(value, path);
                            this.setChanges(modifyInfo);
                        }
                    });
                }
                else {
                    // this.constructor['__prop__metadata__'] = this.constructor['__prop__metadata__'] || {};
                    // NgField({
                    //     /** 字段名称 */
                    //     dataField: propertyName,
                    //     /** 原始字段名称 */
                    //     originalDataField: propertyName,
                    //     /** 是否为主键 */
                    //     primary: false,
                    //     /** 是否为外键 */
                    //     foreign: false
                    // })(this, propertyName);
                    Object.defineProperty(this, propertyName, {
                        // 定义返回数据方法。
                        get: function () {
                            // 从初始数据返回字段值。
                            return this.data[dataField];
                        },
                        set: function (value) {
                            // 值相同时不触发变更。
                            const oldValue = this.data[dataField];
                            if (oldValue === value) {
                                return;
                            }
                            // 更新元数据数据。
                            this.data[dataField] = value;
                            // 变更集
                            const changes = {
                                type: ModifyType.ValueChange,
                                path: this.createPath(propertyName),
                                value: value,
                                preValue: oldValue
                            };
                            if (this[PARENT_PATH]) {
                                changes.path = this[PARENT_PATH].concat(changes.path);
                            }
                            this.setChanges(changes);
                        }
                    });
                }
            }
        });
    }
    createDynamicEntityFromJsonData(value, parentPath) {
        let instance;
        if (value instanceof DynamicEntity) {
            instance = value;
        }
        else {
            instance = new DynamicEntity(value);
            instance.constructor = DynamicEntity;
        }
        instance[PARENT_CLASS] = this;
        instance[PARENT_PATH] = parentPath;
        instance.onValueChanged.pipe(takeUntil(this.unsubscribe)).subscribe(changes => {
            if (changes) {
                changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                this.setChanges(changes);
            }
        });
        return instance;
    }
    /**
     * 将变更记录保存至变更集中
     * @param value 变更记录
     * @todo
     * 1、preValue的处理有问题，下级传递上来的变更这样可以，根DyanmicaEntity上的，data已经发生变化，prevalue和value是一样了；
     * 2、当value是下级冒泡上来的，需要根据value去更新当前层级的data，该逻辑不应该放在setChagnes，待修改。
     */
    setChanges(value) {
        const propertyName = value.path[value.path.length - 1];
        const preValue = Object.assign({}, this.data);
        this.newData = Object.assign(this.newData, { [propertyName]: value.value });
        let parentPath = value.path;
        if (value.path.length > 2) {
            parentPath = value.path.slice(0, value.path.length - 2);
        }
        // 统一不使用构造函数（保持和其他位置对Modification的构造一致）
        // const parentModification = new Modification(this.data, value.type, parentPath, preValue);
        const parentModification = {
            path: parentPath,
            value: this.data,
            preValue: preValue,
            type: value.type,
            dynamic: true
        };
        this.valueChanged.next(parentModification);
        this.changeSet.append(value);
    }
    /**
     * toJSON
     */
    toJSON() {
        return this.data;
    }
}

const ENTITY_DATA_SERVICE_TOKEN = new InjectionToken('@farris/devkit ENTITY_DATA_SERVICE');

const entityPrototype = {
    /**
     * 获取属性值
     */
    getFieldValue: function (schemaField) {
        const fieldName = schemaField.label;
        const value = this.data[fieldName];
        // 对多语录入字段，query不返回问题进行兼容
        if (schemaField.multiLanguage === true && !value) {
            const langCode = window.localStorage.getItem('languageCode') || 'zh-CHS';
            const originDataField = fieldName.replace('_MULTILANGUAGE', '');
            return {
                [langCode]: this.data[originDataField]
            };
        }
        return value;
    },
    /**
     * 设置属性值
     */
    setFieldValue: function (schemaField, propertyValue) {
        const fieldName = schemaField.label;
        this.data[fieldName] = propertyValue;
    },
    /**
     * 获取复杂类型对象的值
     * @param schemaField Schema字段描述
     * @returns 复杂类型对象的值
     */
    getComplexFieldValue: function (schemaField) {
        const fieldName = schemaField.label;
        const objectPropertyValue = this.innerEntities[fieldName];
        return objectPropertyValue;
    },
    /**
     * 向实体复杂类型字段赋值
     * @param schemaField Schema字段描述
     * @param ComplexField 复杂类型字段的类型定义
     * @param propertyValue 属性值
     */
    setComplexFieldValue: function (schemaField, ComplexField, propertyValue) {
        // 提取字段名
        const fieldName = schemaField.label;
        let complexFieldInstance = null;
        if (propertyValue instanceof ComplexField) {
            complexFieldInstance = propertyValue;
        }
        else {
            complexFieldInstance = new ComplexField(propertyValue);
            complexFieldInstance.constructor = ComplexField;
        }
        // 提取复杂类型对象的值
        const objectPropertyValue = this.innerEntities[fieldName];
        const propertyPath = (objectPropertyValue && objectPropertyValue[PARENT_PATH]) || complexFieldInstance[PARENT_PATH];
        // 构造变更信息
        const changeInfo = {
            // 提取变更对象相对于根实体的路径
            path: propertyPath,
            // 记录对象最新值
            value: propertyValue,
            // 记录对象历史值
            preValue: (this[fieldName] && this[fieldName].data) || null,
            // 标记这是一个值变化变更
            type: ModifyType.ValueChange
        };
        // 创建新的对象
        this.innerEntities[fieldName] = complexFieldInstance;
        // this.innerEntities[fieldName] = new ComplexField(propertyValue);
        // 记录本次数据变更
        if (!this.isInitializing) {
            this.setChanges(changeInfo);
        }
    },
    /**
     * 获取指定的子实体列表
     * @param schemaEntity 实体描述
     * @returns 子实体列表
     */
    getEntities: function (schemaEntity) {
        const dataField = schemaEntity.label;
        const listPropertyValue = this.innerEntities[dataField];
        return listPropertyValue;
    },
    /**
     * 更新指定子实体的值
     * @param schemaEntity 实体描述
     * @param propertyValue 实体列表
     */
    setEntities: function (schemaEntity, propertyValue) {
        const dataField = schemaEntity.label;
        this.innerEntities[dataField] = propertyValue;
    },
    /**
     * 检查属性值是否发生变化
     */
    isFieldValueChanged: function (schemaField, newPropValue, oldPropValue) {
        if (schemaField.multiLanguage === true) {
            if (this.isEmptyMultiLangPropValue(newPropValue) === true && this.isEmptyMultiLangPropValue(oldPropValue) === true) {
                return false;
            }
            return JSON.stringify(newPropValue) !== JSON.stringify(oldPropValue);
        }
        else {
            return newPropValue !== oldPropValue;
        }
    },
    /**
     * 多语录入字段的值是否为空
     */
    isEmptyMultiLangPropValue(value) {
        if (!value) {
            return true;
        }
        const keys = Object.keys(value);
        if (keys.length === 0) {
            return true;
        }
        // 值全部为空，视为空
        const vals = Object.values(value);
        const allEmptyVal = vals.every((val) => {
            return !val;
        });
        if (allEmptyVal === true) {
            return true;
        }
        return false;
    },
    /**
     * 发送值变更
     */
    emitFieldValueChange: function (schemaField, newPropValue, oldPropValue) {
        if (!this.isInitializing) {
            const fieldName = schemaField.label;
            const changeInfo = {
                path: this.createPath(fieldName),
                value: newPropValue,
                preValue: oldPropValue,
                type: ModifyType.ValueChange
            };
            if (this[PARENT_PATH]) {
                changeInfo.path = this[PARENT_PATH].concat(changeInfo.path);
            }
            this.setChanges(changeInfo);
        }
    },
    /**
     * 将变更记录保存至变更集中
     * @param value 变更记录
     */
    setChanges: function (value) {
        const propertyName = value.path[value.path.length - 1];
        // @todo：事件会从下级向上冒泡，change可能是下级的，不能和当前Entity的newData合并。
        // this.newData = Object.assign(this.newData, { [propertyName]: value.value });
        this.valueChanged.next(value);
        if (!(this.validErrors && Object.keys(this.validErrors).includes(propertyName))) {
            this.changeSet.append(value);
        }
    },
    /**
     * 创建path
     * @param propertyName 属性名称
     */
    createPath: function (propertyName) {
        if (this.primaryKey) {
            return [this.primaryKey + ':' + this.primaryValue, propertyName];
        }
        else {
            return [':', propertyName];
        }
    },
    getPaths() {
        const pathObj = {
            path: [],
            isUdt: false,
            isGrid: false
        };
        const handleParent = item => {
            const parentPaths = item[PARENT_PATH];
            if (parentPaths) {
                const prop = parentPaths[parentPaths.length - 1];
                // 父级所在实体包含的ngObject，存在当前实体字段，则判断为UDt字段
                if (Object.keys(FieldMetadataUtil.getNgObjects(item[PARENT_CLASS].constructor)).indexOf(prop) > -1) {
                    pathObj.isUdt = true;
                }
                // 存在类型为ngList，则判断为grid
                if (item instanceof EntityList === true) {
                    pathObj.isGrid = true;
                }
                else {
                    pathObj.path.push(prop);
                }
            }
            if (item[PARENT_CLASS]) {
                handleParent(item[PARENT_CLASS]);
            }
        };
        handleParent(this);
        pathObj.path = pathObj.path.reverse();
        return pathObj;
    },
    validate(propertyName, value, externalRules, index) {
        return from(this.validator.validate(this, propertyName, value, externalRules, index)).pipe(tap((result) => {
            if (!result.isValid) {
                this.validErrors = ValidationUtils.convertErrorsToNormalObject(result.errors, {});
            }
            else {
                this.validErrors = {};
            }
        }));
    },
    validateAll(validateContext) {
    },
    /**
     * 用于在entity_util中调用，如果有错误，会将验证结果传入回调cb
     */
    validateFromUtil(propertyName, value, cb) {
        this.validErrors = {};
        from(this.validator.validate(this, propertyName, value)).subscribe((result) => {
            if (!result.isValid) {
                this.validErrors = ValidationUtils.convertErrorsToNormalObject(result.errors, {});
            }
            // 不应重新赋值，这里仅是实体校验通过
            /*else {
              // 如果BindingObject上的属性值和Entity上对应属性值一样，则不再设置
              if (this[propertyName] === value) {
                return;
              }
              this[propertyName] = value;
            }*/
            cb(result);
        });
    },
    /**
     * 将实体数据转换为JSON格式
     */
    toJSON(buildChanges) {
        // 声明转换初始值
        const result = {};
        // 提取简单类型字段的值
        const ngFields = FieldMetadataUtil.getNgFields(this.constructor);
        Object.keys(ngFields).forEach((propName) => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            if (buildChanges === true && ngField.enableTimeZone === true) {
                result[dataField] = this.data[propName];
            }
            else {
                result[dataField] = this[propName];
            }
        });
        // 提取对象类型字段的值
        const ngObjects = FieldMetadataUtil.getNgObjects(this.constructor);
        Object.keys(ngObjects).forEach((propName) => {
            const ngObject = ngObjects[propName];
            const dataField = ngObject.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON(buildChanges) : {};
        });
        // 提取动态属性字段的值
        const ngDynamics = FieldMetadataUtil.getNgDynamic(this.constructor);
        Object.keys(ngDynamics).forEach((propName) => {
            const ngDynamic = ngDynamics[propName];
            const dataField = ngDynamic.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON(buildChanges) : {};
        });
        // 提取列表字段的属性
        const ngLists = FieldMetadataUtil.getNgList(this.constructor);
        Object.keys(ngLists).forEach((propName) => {
            const ngList = ngLists[propName];
            const dataField = ngList.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON(buildChanges) : {};
        });
        return result;
    }
};

/**
 * schema
 */
class Schema {
}
/**
 * 实体
 */
class SchemaEntity {
}
/**
 * 实体类型对象
 */
class SchemaEntityType {
}
/**
 * 字段
 */
class SchemaEntityField {
}
/**
 * 字段类型对象
 */
class SchemaEntityFieldType {
}
/**
 * 字段编辑器对象
 */
class SchemaEntityFieldEditor {
}
/**
 * 字段类型枚举
 */
var SchemaEntityField$Type;
(function (SchemaEntityField$Type) {
    /**
     * 简单类型字段
     */
    SchemaEntityField$Type["SimpleField"] = "SimpleField";
    /**
     * 关联/UDT类型字段
     */
    SchemaEntityField$Type["ComplexField"] = "ComplexField";
})(SchemaEntityField$Type || (SchemaEntityField$Type = {}));
/**
 * 字段类型对象中的类型枚举
 */
var SchemaEntityFieldType$Type;
(function (SchemaEntityFieldType$Type) {
    /**
     * 字符串
     */
    SchemaEntityFieldType$Type["StringType"] = "StringType";
    /**
     * 备注
     */
    SchemaEntityFieldType$Type["TextType"] = "TextType";
    /**
     * 数字（整数、浮点数）
     */
    SchemaEntityFieldType$Type["NumericType"] = "NumericType";
    /**
     * 布尔
     */
    SchemaEntityFieldType$Type["BooleanType"] = "BooleanType";
    /**
     * 日期
     */
    SchemaEntityFieldType$Type["DateType"] = "DateType";
    /**
     * 日期时间
     */
    SchemaEntityFieldType$Type["DateTimeType"] = "DateTimeType";
    /**
     * 枚举
     */
    SchemaEntityFieldType$Type["EnumType"] = "EnumType";
    /**
     * 实体类
     */
    SchemaEntityFieldType$Type["EntityType"] = "EntityType";
    /**
     * 分级码
     */
    SchemaEntityFieldType$Type["HierarchyType"] = "HierarchyType";
    /**
     * 对象
     */
    SchemaEntityFieldType$Type["ObjectType"] = "ObjectType";
    /**
     * 数字（大数据）
     */
    SchemaEntityFieldType$Type["BigNumericType"] = "BigNumericType";
})(SchemaEntityFieldType$Type || (SchemaEntityFieldType$Type = {}));
/**
 * 字段类型中的名称
 */
var SchemaEntityFieldTypeName;
(function (SchemaEntityFieldTypeName) {
    /**
     * 简单类型字段
     */
    SchemaEntityFieldTypeName["String"] = "String";
    /**
     * 日期时间
     */
    SchemaEntityFieldTypeName["DateTime"] = "DateTime";
    /**
     * 日期
     */
    SchemaEntityFieldTypeName["Date"] = "Date";
    /**
     * 枚举
     */
    SchemaEntityFieldTypeName["Enum"] = "Enum";
    /**
     * 布尔
     */
    SchemaEntityFieldTypeName["Boolean"] = "Boolean";
    /**
     * 数字
     */
    SchemaEntityFieldTypeName["Number"] = "Number";
    /**
     * 备注
     */
    SchemaEntityFieldTypeName["Text"] = "Text";
    /**
     * 大数字
     */
    SchemaEntityFieldTypeName["BigNumber"] = "BigNumber";
})(SchemaEntityFieldTypeName || (SchemaEntityFieldTypeName = {}));

/**
 * 实体类型工厂
 * 用来根据实体Schema描述信息创建实体类型
 */
class EntityTypeFactory {
    constructor() { }
    /**
     * 由实体Schema结构创建实体类型
     * @param schema 实体Schema结构
     * @returns 实体类型
     */
    create(schema) {
        // 提取Schema定义中的第一个是实体描述
        const schemaType = schema.entities[0].type;
        // 创建实体类型
        const entityType = this.createClass(schemaType, schema.entities[0]);
        return entityType;
    }
    /**
     * 由实体Schema类型描述创建实体类
     * @param schemaType Schema实体类型描述
     * @returns 实体类型
     */
    createClass(schemaType, relateSchema) {
        const attachEntityInstanceData = this.createEntityInstanceDataInitializer(schemaType);
        // 创建指定实体类型的初始化函数，用来在实体类型构造函数中为实体实例赋值
        const initialize = (entityInstance, entityData, entityTypeConstructor) => {
            entityInstance.isInitializing = true;
            attachEntityInstanceData(entityInstance, entityData, entityTypeConstructor);
            entityInstance.isInitializing = false;
        };
        // 声明实体类构造函数
        const ConcreteEntity = function (data) {
            // 创建实体变更集
            this.changeSet = new ChangeSet();
            // 初始化实体验证状态
            this.isValidating = false;
            // 设置unsubscribe 取消订阅事件
            this.unsubscribe = new Subject();
            // 初始化实体验证信息
            this.validErrors = {};
            // 初始化验证器
            this.validator = new Validator();
            // 初始化实体数据副本
            this.innerData = Object.assign({}, data);
            // 初始化子实体对象集合
            this.innerEntities = {};
            // 初始化实体值变化事件
            this.valueChanged = new Subject();
            this.onValueChanged = this.valueChanged;
            this.validateFromUtilSync = function (propertyName, value, cb, context) {
                this.validErrors = {};
                const result = this.validator.verify(this, propertyName, value, null, undefined, context && context.frameContext || null, true);
                if (result && !result.isValid) {
                    this.validErrors = ValidationUtils.convertErrorsToNormalObject(result.errors, {});
                }
                cb(result);
            };
            // 调用初始化方法，初始化实体数据
            initialize(this, data, ConcreteEntity);
            this.load = (newData) => {
                attachEntityInstanceData(this, newData, ConcreteEntity);
                this.data = newData;
            };
        };
        // 在实体类构造函数中记录视图类型名称
        ConcreteEntity.typeName = `${schemaType.name}Entity`;
        ConcreteEntity.code = relateSchema.code;
        ConcreteEntity.label = relateSchema.label;
        // 在实体类构造函数中记录其下直接引用的子类型
        ConcreteEntity.types = {};
        ConcreteEntity.__prop__metadata__ = {};
        // 构造实体类的原型对象
        const entityTypePrototype = Object.assign({ typeName: 'ConcreteEntityPrototype' }, entityPrototype);
        // 向实体类原型对象中定义预制属性
        this.definePresetProperty(entityTypePrototype, schemaType);
        // 向实体类原型对象中定义字段属性get/set方法
        this.defineFieldsToPrototype(entityTypePrototype, schemaType.fields, schemaType.primary, ConcreteEntity);
        // 向实体类原型对象中定义访问子实体的get/set方法
        this.defineEntitiesToPrototype(entityTypePrototype, schemaType.entities, ConcreteEntity);
        // 将实体类的原型对象指向新构造的原型对象。
        ConcreteEntity.prototype = entityTypePrototype;
        return ConcreteEntity;
    }
    /**
     * 向实体类原型对象中定义预制属性
     * @param prototypeObject 实体类原型对象
     * @param schemaType Schema类型描述
     */
    definePresetProperty(prototypeObject, schemaType) {
        /**
         * 实体数据
         */
        Object.defineProperty(prototypeObject, 'data', {
            get: function () {
                if (!this.innerData) {
                    this.innerData = {};
                }
                return this.innerData;
            },
            set: function (value) {
                this.innerData = value;
            }
        });
        /**
         * 实体验证信息
         */
        Object.defineProperty(prototypeObject, 'errors', {
            get: function () {
                return this.validErrors;
            },
            set: function (errors) {
                this.validErrors = errors;
            }
        });
        /**
         * 实体变更集
         */
        Object.defineProperty(prototypeObject, 'changes', {
            get: function () {
                return this.changeSet.changes;
            }
        });
        /**
         * 实体主键
         */
        Object.defineProperty(prototypeObject, 'primaryProperty', {
            // tslint:disable-next-line: only-arrow-functions
            get: function () {
                // return schemaType.primary;
                return prototypeObject.innerPrimaryProperty || { dataField: schemaType.primary };
            }
        });
        /**
         * 实体主键
         */
        Object.defineProperty(prototypeObject, 'primaryKey', {
            // tslint:disable-next-line: only-arrow-functions
            get: function () {
                return schemaType.primary || '';
            }
        });
        /**
         * 实体主键的值
         */
        Object.defineProperty(prototypeObject, 'primaryValue', {
            get: function () {
                if (this.primaryKey) {
                    // return this[this.primaryProperty.property].toString();
                    const primaryValue = this[this.primaryKey];
                    return primaryValue ? primaryValue : '';
                }
                else {
                    return '';
                }
            }
        });
    }
    /**
     * 向实体类定义字段属性
     * @param prototypeObject 实体类原型对象
     * @param fields 字段描述集合
     * @param parentEntityType 父类型
     */
    defineFieldsToPrototype(prototypeObject, fields, primary, parentEntityType) {
        if (fields && fields.length) {
            // 遍历Schema中描述的字段，在实体原型对象上定义字段访问函数
            fields.forEach(schemaEntityField => {
                switch (schemaEntityField.$type) {
                    // 定义简单类型字段
                    case SchemaEntityField$Type.SimpleField:
                        this.defineSimpleFieldToPrototype(prototypeObject, schemaEntityField, primary, parentEntityType);
                        break;
                    // 定义复杂类型字段
                    case SchemaEntityField$Type.ComplexField:
                        this.defineComplexFieldToPrototype(prototypeObject, schemaEntityField, parentEntityType);
                        break;
                }
            });
        }
    }
    /**
     * 向实体类定义简单类型字段
     * @param prototypeObject 实体类原型对象
     * @param schemaField 字段描述
     */
    defineSimpleFieldToPrototype(prototypeObject, schemaField, primary, parentEntityType) {
        const propertyName = schemaField.label;
        Object.defineProperty(prototypeObject, propertyName, {
            get: function () {
                return this.getFieldValue(schemaField);
            },
            set: function (newPropValue) {
                // 值相同时不触发变更。
                const oldPropValue = this.getFieldValue(schemaField);
                if (this.isFieldValueChanged(schemaField, newPropValue, oldPropValue) === false) {
                    return;
                }
                this.setFieldValue(schemaField, newPropValue);
                this.emitFieldValueChange(schemaField, newPropValue, oldPropValue);
            }
        });
        const fieldMetadata = {
            /** 字段名称 */
            dataField: this.getDataField(schemaField),
            /** 原始字段名称 */
            originalDataField: schemaField.code,
            /** 原始字段类型 */
            originalDataFieldType: schemaField.type.name,
            /**
             * 原始字段
             * @description 对应到scheme的path属性
             */
            path: schemaField.path,
            primary: schemaField.label === primary,
            enableMultiLangInput: this.getEnableMultiLangInput(schemaField),
            defaultValue: schemaField.defaultValue,
            ngMetadataName: NG_FIELD
        };
        if (schemaField['enableStdTimeFormat'] && fieldMetadata.originalDataFieldType == "DateTime") {
            fieldMetadata["enableTimeZone"] = true;
        }
        if (fieldMetadata.primary) {
            prototypeObject.innerPrimaryProperty = fieldMetadata;
        }
        if (!parentEntityType.__prop__metadata__[propertyName]) {
            parentEntityType.__prop__metadata__[propertyName] = [];
        }
        parentEntityType.__prop__metadata__[propertyName].push(fieldMetadata);
    }
    getDataField(schemaField) {
        if (schemaField.multiLanguage) {
            return schemaField.label + "_" + "MULTILANGUAGE";
        }
        return schemaField.label;
    }
    getEnableMultiLangInput(schemaField) {
        if (schemaField.multiLanguage) {
            return true;
        }
    }
    /**
     * 向实体类定义复杂类型字段
     * @param prototypeObject 实体类原型对象
     * @param schemaField 字段描述
     * @param parentEntityType 父类型
     */
    defineComplexFieldToPrototype(prototypeObject, schemaField, parentEntityType) {
        const complexFieldType = this.createClass(schemaField.type, schemaField);
        parentEntityType.types[schemaField.type.name] = complexFieldType;
        const propertyName = schemaField.label;
        Object.defineProperty(prototypeObject, propertyName, {
            get: function () {
                const fieldValue = this.getComplexFieldValue(schemaField);
                return fieldValue;
            },
            set: function (value) {
                this.setComplexFieldValue(schemaField, complexFieldType, value);
            }
        });
        const fieldMetadata = {
            /** 映射字段 */
            dataField: schemaField.label,
            /** 原始字段名称 */
            originalDataField: schemaField.code,
            /** 引用实体类型 */
            type: complexFieldType,
            /**
             * 原始字段
             * @description 对应到scheme的path属性
             */
            path: schemaField.path,
            ngMetadataName: NG_OBJECT
        };
        if (!parentEntityType.__prop__metadata__[propertyName]) {
            parentEntityType.__prop__metadata__[propertyName] = [];
        }
        parentEntityType.__prop__metadata__[propertyName].push(fieldMetadata);
    }
    /**
     * 向实体类定义子实体
     * @param prototypeObject 实体类原型对象
     * @param entities 实体描述集合
     * @param parentEntityType 父类型
     */
    defineEntitiesToPrototype(prototypeObject, entities, parentEntityType) {
        if (entities && entities.length) {
            // 遍历Schema中描述的子实体，在实体对象上定义子实体列表
            entities.forEach(schemaEntity => {
                const complexFieldType = this.createClass(schemaEntity.type, schemaEntity);
                parentEntityType.types[schemaEntity.type.name] = complexFieldType;
                // 提取子实体在实体对象上的属性名
                const propertyName = schemaEntity.label;
                Object.defineProperty(prototypeObject, propertyName, {
                    get: function () {
                        const fieldValue = this.getEntities(schemaEntity);
                        return fieldValue;
                    },
                    set: function (value) {
                        this.setEntities(schemaEntity, value);
                    }
                });
                const entitMetadata = {
                    /** 字段名称 */
                    dataField: schemaEntity.label,
                    /** 原始字段名称 */
                    originalDataField: '',
                    /** 实体类型 */
                    type: complexFieldType,
                    ngMetadataName: NG_LIST
                };
                if (!parentEntityType.__prop__metadata__[propertyName]) {
                    parentEntityType.__prop__metadata__[propertyName] = [];
                }
                parentEntityType.__prop__metadata__[propertyName].push(entitMetadata);
            });
        }
    }
    /**
     * 创建初始化实体对象方法
     * @param schemaType 实体类型描述
     * @returns 初始化实体对象方法
     */
    createEntityInstanceDataInitializer(schemaType) {
        /**
         * 实体初始化函数，用来初始化实体的复杂类型数据和子实体数据
         * @param entityInstance 实体类型实例
         * @param data 实体原始数据
         * @param entityTypeConstructor 实体类型构造函数
         */
        const initializer = (entityInstance, entityData, entityTypeConstructor) => {
            // 初始化复杂类型字段
            schemaType.fields
                // 过滤复杂类型字段
                .filter(field => field.$type === SchemaEntityField$Type.ComplexField)
                // 遍历复杂类型字段创建对应实体类型数据
                .forEach(field => {
                // 提取字段名
                const fieldName = field.label;
                // 提取实体类型下的所有子实体类型
                const includedEntityTypes = entityTypeConstructor.types;
                // 获取复杂类型字段对应的实体类型
                const ComplexField = includedEntityTypes[field.type.name];
                // 提取复杂类型字段原始数据
                const fieldData = entityData ? entityData[fieldName] : null;
                // 创建复杂类型字段对象路径
                const path = entityInstance.createPath(fieldName);
                let complexFieldValue = entityInstance[fieldName];
                if (complexFieldValue instanceof ComplexField) {
                    complexFieldValue.load(fieldData);
                }
                else {
                    // 创建复杂类型字段实体实例
                    complexFieldValue = new ComplexField(fieldData);
                    complexFieldValue.constructor = ComplexField;
                    complexFieldValue[PARENT_CLASS] = entityInstance;
                    complexFieldValue[PARENT_PATH] = path;
                    complexFieldValue.onValueChanged.subscribe(changes => {
                        if (changes) {
                            changes.path = (entityInstance[PARENT_PATH] || []).concat(changes.path);
                            const modification = Object.assign({}, changes, { fromParent: true });
                            entityInstance.setChanges(modification);
                        }
                    });
                    entityInstance[fieldName] = complexFieldValue;
                }
            });
            // 初始化子实体
            if (schemaType.entities) {
                // 遍历子实体创建对应实体类型的数据
                schemaType.entities.forEach(schemaEntity => {
                    // 提取子实体名
                    const subEntityName = schemaEntity.label;
                    // 提取实体类型下的所有子实体类型
                    const includedEntityTypes = entityTypeConstructor.types;
                    // 创建子实体对象路径
                    const path = entityInstance.createPath(subEntityName);
                    // 创建子实体对象集合
                    let entityList = entityInstance[subEntityName];
                    if (!(entityList instanceof EntityList)) {
                        entityList = new EntityList();
                        // 向子实体列表注册子实体变化事件
                        entityList.onListChanged.subscribe(value => {
                            if (value) {
                                if (entityList[PARENT_PATH][0] !== value.path[0]) {
                                    value.path = entityList[PARENT_PATH].concat(value.path);
                                }
                                entityInstance.setChanges(value);
                            }
                        });
                        // 向实体类型实例上直接存储子实体对象列表
                        entityInstance[subEntityName] = entityList;
                    }
                    entityList[PARENT_CLASS] = entityTypeConstructor;
                    entityList[PARENT_PATH] = path;
                    // 提取子实体类型名称
                    const schemaEntityTypeName = schemaEntity.type.name;
                    // 获取子实体类型
                    const ConcreteEntity = includedEntityTypes[schemaEntityTypeName];
                    const originalEntityDataArray = entityData ? entityData[subEntityName] : null;
                    // 构造子实体集合
                    if (originalEntityDataArray) {
                        // 遍历子实体原始数据，构造实体对象集合
                        const entities = originalEntityDataArray.map((originalEntityData) => {
                            const concreteEntityInstance = new ConcreteEntity(originalEntityData);
                            concreteEntityInstance.constructor = ConcreteEntity;
                            return concreteEntityInstance;
                        });
                        // 向子实体列表中添加子实体对象
                        entityList.loadEntities(entities);
                    }
                });
            }
            // 初始化简单字段
            schemaType.fields
                // 过滤复杂类型字段
                .filter(field => field.$type === SchemaEntityField$Type.SimpleField)
                // 遍历复杂类型字段创建对应实体类型数据
                .forEach(function (field) {
                // 提取字段名
                const fieldName = field.label;
                let propValue = entityData ? entityData[fieldName] : null;
                if (field['enableTimeZone'] === true) {
                    const timeZoneOffset = UserSettingsService.getTimeZoneOffset();
                    if (timeZoneOffset !== null && propValue) {
                        propValue = ZonedTime.zonedTimeToSpecialTimeZoneOffsetTimeString(propValue, timeZoneOffset);
                    }
                }
                entityInstance[fieldName] = propValue;
            });
        };
        return initializer;
    }
}

/* eslint-disable new-cap */
class RestfulService {
    /**
     * 构造函数
     * @param httpClient http客户端
     */
    constructor(httpClient) {
        this.httpClient = httpClient;
    }
    /**
     * 发送GET请求
     * @param uri 请求地址
     * @param params 请求参数
     */
    get(uri, params, options) {
        return this.request(uri, 'GET', params, options);
    }
    /**
     * 发送POST请求
     * @param uri 请求地址
     * @param params 请求参数
     */
    put(uri, body, params, options) {
        const optionsWithBody = this.addBody(options, body);
        return this.request(uri, 'PUT', params, optionsWithBody);
    }
    /**
     * 发送PUT请求
     * @param uri 请求地址
     * @param params 请求参数
     */
    post(uri, body, params, options) {
        const optionsWithBody = this.addBody(options, body);
        return this.request(uri, 'POST', params, optionsWithBody);
    }
    /**
     * 发送DELETE请求
     * @param uri 请求地址
     * @param params 请求参数
     */
    delete(uri, params, options) {
        return this.request(uri, 'DELETE', params, options);
    }
    /**
     * 发送请求
     * @param uri 请求地址
     * @param params 请求参数
     */
    request(uri, method, params, options = {}) {
        options = options || {};
        if (params) {
            const httpParams = this.buildParams(params);
            options.params = httpParams;
        }
        const methodName = method;
        uri = BasePathService.convertPath(uri);
        const result = this.httpClient.request(methodName, uri, options);
        return result;
    }
    /**
     * 构造Http请求参数
     * @param params 请求参数
     */
    buildParams(params) {
        let httpParams = new HttpParams();
        for (const key in params) {
            if (params.hasOwnProperty(key)) {
                const value = params[key].toString();
                httpParams = httpParams.append(key, value);
            }
        }
        return httpParams;
    }
    addBody(options, body) {
        options = options || {};
        const mergedOptions = Object.assign(options, { body: body });
        return mergedOptions;
    }
}
RestfulService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RestfulService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * ----------------------------------------
 * NgCommandHandler
 * ----------------------------------------
 */
/**
 * 命令处理装饰器名称
 */
const NG_COMMAND_HANDLER = 'NgCommandHandler';
/**
 * 命令处理装饰器工厂
 */
// export const NgCommandHandler: NgCommandHandlerDecorator =
//   makeDecorator(NG_COMMAND_HANDLER, (handler: NgCommandHandler) => handler);
function NgCommandHandler(options) {
    const decoratorFactory = makeDecorator(NG_COMMAND_HANDLER, (handler) => handler);
    return decoratorFactory(options);
}
/**
 * ----------------------------------------
 * NgCommandHandlerExtender
 * ----------------------------------------
 */
/**
 * 命令处理扩展装饰器名称
 */
const NG_COMMAND_HANDLER_EXTENDER = 'NgCommandHandlerExtender';
/**
 * 命令处理扩展装饰器工厂
 */
function NgCommandHandlerExtender(options) {
    const decoratorFactory = makeDecorator(NG_COMMAND_HANDLER_EXTENDER, (extender) => extender);
    return decoratorFactory(options);
}

/*
 * @Author: aalizzwell
 * @Date: 2019-10-25 13:30:52
 * @Last Modified by:   aalizzwell
 * @Last Modified time: 2019-10-25 13:30:52
 */
const isObservable$1 = (value) => {
    if (!value) {
        return false;
    }
    if (value[Symbol.observable] && value === value[Symbol.observable]()) {
        return true;
    }
    if (value['@@observable'] && value === value['@@observable']()) {
        return true;
    }
    if (value instanceof Observable) {
        return true;
    }
    return false;
};

/**
 * 任务节点
 */
class TaskNode {
    /**
     * 构造函数
     */
    constructor(name, func) {
        this.name = name;
        this.func = func;
    }
    /**
     * 执行任务函数
     */
    execute(context) {
        const result = this.func(context);
        const result$ = isObservable$1(result) ? result : of(result);
        return result$;
    }
}

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
const VARIABLE_PARSERS = new InjectionToken('variable parsers');

/*
 * StateMachine变量解析
 * @Author: Witt
 * @Date: 2018-12-04 17:09:42
 * @Last Modified by: Witt
 * @Last Modified time: 2019-10-30 11:07:10
 */
// import { AppContext } from '../app/index';
// import { FrameContext } from '../frame/index';
// import { CommandContext } from '../command/index';
/**
 * 解析辅助工具类
 */
class ParseUtil {
    /**
     * 获取应用上下文
     */
    static getAppContext(context) {
        if (context.typeName === 'CommandContext') {
            return context.frameContext.appContext;
        }
        else if (context.appContext) {
            return context.appContext;
        }
        else if (context.typeName === 'AppContext') {
            return context;
        }
        else {
            throw new Error('上下文中找不到AppContext，请检查！');
        }
    }
    /**
     * 获取当前Frame的Context
     */
    static getFrameContext(context) {
        if (context.typeName === 'CommandContext') {
            return context.frameContext;
        }
        else if (context.typeName === 'FrameContext') {
            return context;
        }
        else {
            throw new Error('上下文中找不到FrameContext，请检查！');
        }
    }
    /**
     * 获取根Frame的Context
     */
    static getRootFrameContext(context) {
        const frameContext = this.getFrameContext(context);
        return frameContext.root;
    }
    /**
     * 根据frameId获取FrameContext
     */
    static getFrameContextById(context, frameId) {
        const appContext = this.getAppContext(context);
        return appContext.frameContextManager.getFrameContextById(frameId);
    }
}

/**
 * 数据源变量解析
 * @author Witt <jiwt@inspur.com>
 */
/**
 * 数据变量解析
 */
class DataVariableParser {
    /**
     * 解析变量
     * @param expression 表达式
     * @param context 上下文
     */
    parse(expression, context) {
        const appContext = ParseUtil.getAppContext(context);
        const paths = this.extractPaths(expression);
        if (paths.length === 1) {
            const value = this.getValue(paths[0], appContext);
            // 1、单个的表达式：直接求值
            if (expression === `{DATA~${paths[0]}}`) {
                return value;
            }
            else if (expression === `{:DATA~${paths[0]}}`) {
                // 该内容是JSON的一部分，需要转义特殊字符
                return escape(value);
            }
        }
        // 2、其他情况：字符串替换
        paths.forEach((path) => {
            const replaceValue = this.getValue(path, appContext);
            const searchValue = `{DATA~${path}}`;
            expression = expression.replace(searchValue, replaceValue);
            const target = `{:DATA~${path}}`;
            if (expression.includes(target)) {
                const value = escape(replaceValue);
                expression = expression.replace(target, value);
            }
        });
        return expression;
    }
    /**
     * 提取路径
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const DATA_PATTERN_G = /\{:?DATA~(\S+?)\}/g;
        const dataVariables = expression.match(DATA_PATTERN_G);
        if (dataVariables === null) {
            return [];
        }
        // 提取后边的路径
        const DATA_PATTERN = /\{:?DATA~(\S+?)\}/;
        dataVariables.forEach(dataVariable => {
            const pathMatches = dataVariable.match(DATA_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取值
     * @param path 路径：/
     */
    getValue(path, appContext) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const frameContext = appContext.getFrameContext(parts[0]);
        if (!frameContext) {
            throw new Error(`${path}不正确，请检查！`);
        }
        const bindingData = frameContext.bindingData;
        if (!bindingData) {
            throw new Error(`${path}不正确，请检查！`);
        }
        return bindingData.getValue(parts.slice(1));
    }
}
DataVariableParser.decorators = [
    { type: Injectable }
];

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
/**
 * 数据变量解析
 */
class UIStateVariableParser {
    /**
     * 解析变量
     * @param expression 形如：/frameId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const appContext = ParseUtil.getAppContext(context);
        const paths = this.extractPaths(expression);
        if (paths.length === 1) {
            const value = this.getUIState(paths[0], appContext);
            // 1、单个的表达式：直接求值
            if (expression === `{UISTATE~${paths[0]}}`) {
                return value;
            }
            else if (expression === `{:UISTATE~${paths[0]}}`) {
                return escape(value);
            }
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{UISTATE~${path}}`;
            const replaceValue = this.getUIState(path, appContext);
            expression = expression.replace(searchValue, replaceValue);
            const target = `{:UISTATE~${path}}`;
            if (expression.includes(target)) {
                const value = escape(replaceValue);
                expression = expression.replace(target, value);
            }
        });
        return expression;
    }
    /**
     * 提取路径
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const UI_STATE_PATTERN_G = /\{:?UISTATE~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        if (uiStateVariables === null) {
            return [];
        }
        // 提取后边的路径
        const UI_STATE_PATTERN = /\{:?UISTATE~(\S+?)\}/;
        uiStateVariables.forEach((uiStateVariable) => {
            const pathMatches = uiStateVariable.match(UI_STATE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取UIState
     */
    getUIState(path, appContext) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const [frameId, stateName] = parts;
        const frameContext = appContext.getFrameContext(frameId);
        let state = frameContext && frameContext.uiState[stateName];
        if (state && state.constructor.toString().startsWith('function Date()')) {
            return this.formatDate(state);
        }
        for (let i = 2; i < parts.length; i++) {
            state = state[parts[i]];
            // 复杂对象一层层查找下去，如果某一层不存在，结果可以是undefined，但是要直接返回undefined避免报错。
            if (!state) {
                return state;
            }
        }
        return state;
    }
    /**
     * @todo：待删除
     */
    formatDate(value) {
        if (!value) {
            return '';
        }
        // 年
        const year = value.getFullYear();
        // 月
        let month = (value.getMonth() + 1).toString();
        month = month.length === 1 ? ('0' + month) : month;
        // 日
        let day = value.getDate().toString();
        day = day.length === 1 ? ('0' + day) : day;
        return `${year}-${month}-${day}`;
    }
}
UIStateVariableParser.decorators = [
    { type: Injectable }
];

/*
 * StateMachine变量解析
 * @Author: Witt
 * @Date: 2018-12-04 17:09:42
 * @Last Modified by: Witt
 * @Last Modified time: 2019-10-30 11:07:10
 */
/**
 * 状态机变量解析
 * @summary
 *
 * 解析策略：
 * 1、不带frameId，从顶层StateMachine中解析
 * {STATEMACHINE~/states/key}
 * {STATEMACHINE~/renderStates/key}
 *
 * 2、带frameId，从frameId对应的FrameContext的StateMachine中解析
 * {STATEMACHINE~/frameId/states/key}
 * {STATEMACHINE~/frameId/renderStates/key}
 *
 * 存在的问题：
 * 1、不带frameId从顶层StateMachine解析仅为了兼容，将来改为从当前FrameContext的StateMachine中解析；
 * 2、组合表单中顶层StateMachine是主表单的rootFrameContext的StateMachine，显然不合理（既成事实）；
 * 3、farmeId如果是states或renderStates，导致解析失败，几率很小，但又风险。
 */
class StateMachineVariableParser {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 解析变量
     * @param expression 变量：格式形如：/frameId/componentId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{STATEMACHINE~${paths[0]}}`) {
            return this.getValue(paths[0], context);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{STATEMACHINE~${path}}`;
            const replaceValue = this.getValue(path, context);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取Session变量名
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的StateMachine变量字符串
        const STATE_MACHINE_PATTERN_G = /\{STATEMACHINE~(\S+?)\}/g;
        const stateMachineVariables = expression.match(STATE_MACHINE_PATTERN_G);
        if (stateMachineVariables === null) {
            return [];
        }
        // 提取后边的路径
        const STATE_MACHINE_PATTERN = /\{STATEMACHINE~(\S+?)\}/;
        stateMachineVariables.forEach(sessionVariable => {
            const pathMatches = sessionVariable.match(STATE_MACHINE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取对应的值
     */
    getValue(path, context) {
        const pathObj = this.getPathObj(path);
        const stateMachine = this.getTargetStateMachine(pathObj.frameId, context);
        if (pathObj.type === 'currentState') {
            return stateMachine.context.state;
        }
        else if (pathObj.type === 'renderStates') {
            return stateMachine[pathObj.name];
        }
        else {
            throw new Error(`不支类型为${pathObj.type}的状态机变量`);
        }
    }
    /**
     * 解析path，并获取对应的StateMachine实例
     */
    getTargetStateMachine(frameId, context) {
        let targetFrameContext;
        if (frameId) {
            targetFrameContext = ParseUtil.getFrameContextById(context, frameId);
        }
        else {
            targetFrameContext = ParseUtil.getRootFrameContext(context);
        }
        if (!targetFrameContext || !targetFrameContext.stateMachine) {
            throw new Error('找不到对应的状态机实例，请检查！');
        }
        return targetFrameContext.stateMachine;
    }
    /**
     * 将Path解析为格式化的Path对象
     */
    getPathObj(path) {
        let parsedPathObj;
        const parts = this.splitPath(path);
        if (parts[0] === 'currentState' || parts[0] === 'renderStates') {
            parsedPathObj = {
                frameId: '',
                type: parts[0],
                name: parts[1]
            };
        }
        else {
            parsedPathObj = {
                frameId: parts[0],
                type: parts[1],
                name: parts[2]
            };
        }
        return parsedPathObj;
    }
    /**
     * 分隔Path
     */
    splitPath(path) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        return parts;
    }
}
StateMachineVariableParser.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateMachineVariableParser.ctorParameters = () => [];

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
/**
 * 命令变量解析
 * {COMMAND~/params/key}
 * {COMMAND~/results/taskName}
 */
class CommandVariableParser {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 解析变量
     * @param expression 变量：格式形如：/frameId/componentId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{COMMAND~${paths[0]}}`) {
            return this.getValue(paths[0], context);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{COMMAND~${path}}`;
            const replaceValue = this.getValue(path, context);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取Session变量名
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const UI_STATE_PATTERN_G = /\{COMMAND~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        if (uiStateVariables === null) {
            return [];
        }
        // 提取后边的路径
        const UI_STATE_PATTERN = /\{COMMAND~(\S+?)\}/;
        uiStateVariables.forEach(sessionVariable => {
            const pathMatches = sessionVariable.match(UI_STATE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取UIState
     */
    getValue(path, context) {
        if (context instanceof CommandContext === false) {
            throw new Error('当前上下文不支持COMMAND变量，请检查！');
        }
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const type = parts.shift();
        if (type === 'params') {
            const paramKey = parts.shift();
            return context.command.params[paramKey];
        }
        else if (type === 'results') {
            return parts.reduce((results, paramKey) => {
                return results && results[paramKey];
            }, context.results);
        }
    }
}
CommandVariableParser.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CommandVariableParser.ctorParameters = () => [];

/**
 * 变量解析服务
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 变量解析服务
 * 职责：
 * 1、解析字符串中的变量，并替换成相应的值；
 * 2、对表达式进行求值。
 *
 * @todo 对表达式求值的部分和表达式功能重叠，是否转移到表达式中？
 */
class VariableParseService {
    /**
     * 构造变量解析服务
     * @param parsers 解析器集合
     */
    constructor(parsers) {
        this.parsers = parsers;
    }
    /**
     * 解析表达式
     * @param expression 表达式
     * @param context 上下文
     */
    parse(target, context, eventParam) {
        if (typeof target === 'string' && target.length > 0) {
            // 字符串，直接解析
            return this.parseExpression(target, context, eventParam);
        }
        else if (Array.isArray(target)) {
            // 遍历数组
            target.forEach((item, itemIndex) => {
                if (typeof item === 'string') {
                    target[itemIndex] = this.parseExpression(item, context, eventParam);
                }
                else {
                    target[itemIndex] = this.parse(item, context, eventParam);
                }
            });
        }
        else if (typeof target === 'object' && target !== null) {
            // 遍历对象可枚举属性
            const keys = Object.keys(target);
            keys.forEach(key => {
                if (typeof target[key] === 'string') {
                    target[key] = this.parseExpression(target[key], context, eventParam);
                }
                else {
                    target[key] = this.parse(target[key], context, eventParam);
                }
            });
        }
        return target;
    }
    /**
     * 表达式求值
     */
    evaluate(expression, context, eventParam) {
        const parsedExpression = this.parse(expression, context, eventParam);
        return (new Function('return ' + parsedExpression))();
    }
    /**
     * 解析表达式
     * @param expression 表达式
     * @param context 上下文
     */
    parseExpression(expression, context, eventParam) {
        // 空串直接返回
        if (expression === '') {
            return '';
        }
        this.parsers.forEach(parser => {
            if (typeof expression === 'string') {
                expression = parser.parse(expression, context, eventParam);
            }
        });
        return expression;
    }
}
VariableParseService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
VariableParseService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [VARIABLE_PARSERS,] }] }
];

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
const VARIABLE_MATCHER = /#{\S+?}/g;
/**
 * 数据变量解析
 */
class FrameIdVariableParser {
    /**
     * 解析变量
     * @param expression 形如：/#{root-component}/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        this.context = context;
        const variables = this.extractVariables(expression);
        if (!variables || variables.length < 1) {
            return expression;
        }
        variables.forEach((exp) => {
            const frameId = this.getVariableValue(exp);
            expression = expression.replace(VARIABLE_MATCHER, frameId);
        });
        return expression;
    }
    /**
     * 计算表达式的值
     * @param expression like #{root-component}
     */
    getVariableValue(expression) {
        const relativeFrameId = expression.substring(2, expression.length - 1);
        return this.getFullFrameId(relativeFrameId);
    }
    extractVariables(expression) {
        if (!expression) {
            return [];
        }
        return expression.match(VARIABLE_MATCHER);
    }
    /**
     * 获取补全的frameId
     * @param frameId frameId
     */
    getFullFrameId(frameId) {
        const frameContext = ParseUtil.getFrameContext(this.context);
        const namespace = frameContext.namespace || '';
        const prefix = namespace ? `${namespace}_` : '';
        return `${prefix}${frameId}`;
    }
}
FrameIdVariableParser.decorators = [
    { type: Injectable }
];

const FORM_STATES_EXP = /\{FORMSTATE~\/(\S+?)\}/g;
const FORM_STATE_EXP = /\{FORMSTATE~\/(\S+?)\}/;
class FormStateVariableParser {
    /**
     * 解析表达式变量
     */
    parse(expression, context) {
        this.context = context;
        const variables = this.extractVariables(expression);
        if (!variables || variables.length < 1) {
            return expression;
        }
        variables.forEach(variableExpression => {
            const exprs = variableExpression.match(FORM_STATE_EXP);
            if (exprs && exprs.length === 2) {
                const variable = exprs[1];
                const value = this.getVariableValue(variable);
                expression = expression.replace(FORM_STATE_EXP, value);
            }
        });
        return expression;
    }
    /**
     * 获取变量的值
     * @param variable 变量
     */
    getVariableValue(variable) {
        const frameContext = ParseUtil.getFrameContext(this.context);
        const appContext = frameContext.appContext;
        const formVariable = appContext.params.get(variable);
        return formVariable;
    }
    /**
     * 获取到表达式中所有FormState变量数组
     * @param expression 表达式
     */
    extractVariables(expression) {
        if (!expression) {
            return null;
        }
        const formStates = expression.match(FORM_STATES_EXP);
        if (!formStates || formStates.length < 1) {
            return null;
        }
        return formStates;
    }
}

const EVENT_PARAMS_EXP = /\{EVENTPARAM~\/(\S+?)\}/g;
const EVENT_PARAM_EXP = /\{EVENTPARAM~\/(\S+?)\}/;
/**
 * 命令参数解析器
 */
class EventParamVariableParser {
    parse(expression, context, eventParam) {
        this.context = context;
        const variables = this.extractVariables(expression);
        if (!variables || variables.length < 1) {
            return expression;
        }
        variables.forEach(variableExpression => {
            const exprs = variableExpression.match(EVENT_PARAM_EXP);
            if (exprs && exprs.length === 2) {
                const variable = exprs[1];
                const value = this.getVariableValue(variable, eventParam);
                expression = expression.replace(EVENT_PARAM_EXP, value);
            }
        });
        return expression;
    }
    /**
     * 匹配表达式中的符合正则表达式的项
     * @param expression 表达式
     * @returns
     */
    extractVariables(expression) {
        if (!expression) {
            return null;
        }
        const variables = expression.match(EVENT_PARAMS_EXP);
        if (!variables || variables.length < 1) {
            return null;
        }
        return variables;
    }
    /**
     * 获取变量的值
     * @param variable 变量
     */
    getVariableValue(variable, eventParam) {
        if (!eventParam || !variable) {
            return null;
        }
        const variables = variable.split('/').filter(p => p);
        const result = variables.reduce((target, key) => {
            if (target) {
                return target[key];
            }
            else {
                return null;
            }
        }, eventParam);
        return result;
    }
}
EventParamVariableParser.decorators = [
    { type: Injectable }
];

// Providers
const VARIABLE_PROVIDERS = [
    { provide: VARIABLE_PARSERS, multi: true, useClass: FrameIdVariableParser },
    { provide: VARIABLE_PARSERS, multi: true, useClass: FormStateVariableParser },
    { provide: VARIABLE_PARSERS, multi: true, useClass: EventParamVariableParser },
    { provide: VARIABLE_PARSERS, multi: true, useClass: DataVariableParser },
    { provide: VARIABLE_PARSERS, multi: true, useClass: UIStateVariableParser },
    { provide: VARIABLE_PARSERS, multi: true, useClass: StateMachineVariableParser },
    { provide: VARIABLE_PARSERS, multi: true, useClass: CommandVariableParser },
    VariableParseService
];

/**
 * 任务链接
 */
class TaskLink {
    /**
     * 构造函数
     */
    constructor(from$$1, to, condition) {
        this.from = from$$1;
        this.to = to;
        this.condition = condition;
    }
    /**
     * 是否能够
     */
    canLink(context) {
        const type = typeof this.condition;
        let canLink;
        switch (type) {
            case 'boolean':
                canLink = this.condition;
                break;
            case 'function':
                canLink = this.condition(context);
                break;
            case 'string':
                const parseService = context && context.frameContext && context.frameContext.injector && context.frameContext.injector.get(VariableParseService);
                canLink = parseService && parseService.evaluate(this.condition, context);
                break;
            default:
                canLink = false;
                break;
        }
        return canLink;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-10-17 14:13:40
 * @Last Modified by: Witt
 * @Last Modified time: 2018-10-17 16:08:34
 */
/**
 * 任务执行流程
 */
class TaskFlow {
    constructor() {
        /**
         * 节点集合
         */
        this.nodes = [];
        /**
         * 边集合
         */
        this.links = [];
        // #endregion
    }
    // #region 节点操作
    /**
     * 添加节点
     */
    addNode(name, func) {
        const node = new TaskNode(name, func);
        this.nodes.push(node);
    }
    /**
     * 批量添加链接
     */
    addNodes(nodes) {
        this.nodes = this.nodes.concat(nodes);
    }
    /**
     * 在目标节点之前插入一个节点
     * @param target 目标节点名称
     * @param name 名称
     * @param func 函数
     */
    insertNode(target, name, func) {
        const index = this.findNodeIndex(target);
        const node = this.createNode(name, func);
        this.nodes.splice(index, 0, node);
    }
    /**
     * 在目标节点之前插入一个节点
     */
    appendNode(target, name, func) {
        const index = this.findNodeIndex(target) + 1;
        const node = this.createNode(name, func);
        this.nodes.splice(index, 0, node);
    }
    /**
     * 获取节点索引
     * @param name 名称
     */
    findNodeIndex(name) {
        return this.nodes.findIndex((node) => {
            return node.name === name;
        });
    }
    /**
     * 创建任务节点
     * @param name 名称
     * @param func 函数
     */
    createNode(name, func) {
        const node = new TaskNode(name, func);
        return node;
    }
    // #endregion
    // #region 链接操作
    /**
     * 添加链接
     * @param name 名称
     * @param func 函数
     */
    addLink(from$$1, to, condition) {
        const link = this.createLink(from$$1, to, condition);
        this.links.push(link);
    }
    /**
     * 批量添加链接
     */
    addLinks(links) {
        this.links = this.links.concat(links);
    }
    /**
     * 创建链接
     */
    createLink(from$$1, to, condition) {
        const link = new TaskLink(from$$1, to, condition);
        return link;
    }
    // #endregion
    // #region 流程控制
    /**
     * 获取下一个节点
     * @param from    源节点名称
     * @param context 上下文
     */
    getNext(from$$1, context) {
        if (!from$$1) {
            return this.nodes.shift();
        }
        // 符合满足条件的边
        const nextLink = this.links.find((link) => {
            return link.from === from$$1 && link.canLink(context);
        });
        if (!nextLink) {
            return;
        }
        return this.nodes.find((node) => {
            return node.name === nextLink.to;
        });
    }
    // #endregion
    // #region 其他方法
    /**
     * 克隆任务流
     */
    clone() {
        const taskFlow = new TaskFlow();
        taskFlow.addNodes(this.nodes);
        taskFlow.addLinks(this.links);
        return taskFlow;
    }
}

/**
 * Command上下文
 */
class CommandContext {
    /**
     * 构造函数
     * @param command 命令
     * @param frameContext 框架上下文
     */
    constructor(command, frameContext) {
        this.typeName = 'CommandContext';
        /**
         * 执行结果
         * 记录每一个task执行的结果
         */
        this.results = {};
        this.command = command;
        this.frameContext = frameContext;
    }
    dispose() {
        this.eventParam = null;
        this.command = null;
        this.results = null;
        this.latestResult = null;
        this.frameContext = null;
    }
    clearResults() {
        this.results = null;
    }
}

const TranslateToken = new InjectionToken('@farris/devkit TranslateToken');

/**
 * 命令处理抽象类，所有具体的命令处理类必须继承它，并实现schedule方法。
 */
class CommandHandler {
    /**
     * 构造函数
     */
    constructor() {
        this.destroy$ = new Subject();
    }
    dispose(options) {
        if (this.destroy$) {
            this.destroy$.next();
            this.destroy$.complete();
        }
        this.frameContext = null;
    }
    ngOnDestroy() {
        this.dispose();
    }
    /**
     * 初始化
     */
    init(frameContext, variableParseService) {
        this.frameContext = frameContext;
        this.parseService = variableParseService;
        this.taskFlow = new TaskFlow();
        this.schedule();
    }
    /**
     * 执行任务
     * @param command 要执行的命令
     * @return 最后一个任务的执行结果
     * @todo：按功能拆分小函数
     */
    execute(command) {
        const lastTaskResult$ = new Subject();
        const taskFlow = this.taskFlow.clone();
        // setTimeout暂时不能去掉的原因：
        // 1、树表单加载数据，依赖TreeTableBinding里设置的全局变量，需要延后执行加载时机；
        // 2、关闭前命令需要延迟执行。
        setTimeout(() => {
            if (!this.frameContext || this.frameContext.isDisposed) {
                return EMPTY;
            }
            // 1、解析参数
            // 避免解析变量时修改了原始的command
            const { eventParam = null } = Object.assign({}, command);
            delete command.eventParam;
            const commandToExecute = JSON.parse(JSON.stringify(command));
            commandToExecute.params = this.paramsTransform(commandToExecute.params);
            commandToExecute.params = this.parseService.parse(commandToExecute.params, this.frameContext, eventParam);
            command.eventParam = eventParam;
            commandToExecute.eventParam = eventParam;
            this.transParamTypes(commandToExecute.params, commandToExecute.paramDescriptions);
            // 2、串联任务流
            const initContext = new CommandContext(commandToExecute, this.frameContext);
            initContext.eventParam = command.eventParam || null;
            const context$ = new BehaviorSubject(initContext);
            let currentTask = taskFlow.getNext('', initContext);
            const highOrder$ = context$.pipe(concatMap((context) => {
                const result$ = currentTask.execute(context);
                return result$.pipe(take(1), map((result) => {
                    // 写入执行结果
                    context.results[currentTask.name] = result;
                    context.latestResult = result;
                    currentTask = taskFlow.getNext(currentTask.name, context);
                    // 操作控制流
                    if (currentTask) {
                        context$.next(context);
                    }
                    else {
                        context$.complete();
                    }
                    // 将结果流转换为context流
                    return context;
                }), throwIfEmpty(() => {
                    context$.complete();
                }));
            }));
            // 3、执行合并后的任务流
            highOrder$.pipe(takeLast(1)).subscribe({
                next: (context) => {
                    this.waitForDestroy(context);
                    lastTaskResult$.next(context.latestResult);
                },
                error: (error) => {
                    this.waitForDestroy(initContext);
                    this.displayError(error);
                    lastTaskResult$.error(error || '');
                },
                complete: () => {
                    this.waitForDestroy(initContext);
                    lastTaskResult$.complete();
                },
            });
        }, 0);
        return lastTaskResult$;
    }
    /**
     * 等待销毁
     * @param commandContext
     */
    waitForDestroy(commandContext) {
        if (!commandContext) {
            return;
        }
        commandContext.clearResults();
        if (this.frameContext && this.frameContext.appContext && this.frameContext.appContext.destorySignal) {
            this.frameContext.appContext.destorySignal.pipe(takeUntil(this.destroy$)).subscribe(() => {
                if (commandContext) {
                    commandContext.dispose();
                    commandContext = null;
                }
            });
        }
    }
    /**
     * 显示错误信息
     */
    displayError(error) {
        if (!error) {
            return;
        }
        if (!console || !console.error) {
            return;
        }
        console.error(error);
    }
    /**
     * 参数国际化转换方法
     */
    paramsTransform(params) {
        const exp = /\{\{(\w+)\}\}/g;
        if (!params) {
            return null;
        }
        const translateService = this.frameContext && this.frameContext.injector && this.frameContext.injector.get(TranslateToken, null) || null;
        const pArray = Object.keys(params);
        const result = {};
        if (pArray.length === 0) {
            return params;
        }
        pArray.forEach((p) => {
            let ele = params[p];
            if (ele && exp.test(ele) && translateService) {
                ele = ele.replace(exp, ($1, $2) => {
                    return translateService.transform($2, null);
                });
            }
            result[p] = ele;
        });
        return result;
    }
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    addTask(name, func) {
        this.taskFlow.addNode(name, func);
    }
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    addLink(from$$1, to, condition) {
        this.taskFlow.addLink(from$$1, to, condition);
    }
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    insertTask(target, name, func) {
        throw new Error('Not Implemented');
    }
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    afterTask(target, name, func) {
        throw new Error('Not Implemented');
    }
    /**
     * 替换任务
     * @param  name 要替换的任务名称
     * @param  func 替换函数
     */
    replaceTask(name, func) {
        throw new Error('Not Implement');
    }
    /**
     * 调用方法
     */
    invoke(serviceInstance, method, args, context) {
        this.setContextToServiceInstance(serviceInstance, context);
        const parsedArgs = this.parseService.parse(args, context, context.eventParam);
        return serviceInstance[method](...parsedArgs);
    }
    /**
     * 为服务设置命令上下文
     * @todo
     * 通过这种方式存在很大问题：
     * 1、会覆盖掉已有的context，给开发人员造成困扰和调试成本；
     * 2、服务中依赖了一个没有声明的对象，不符合面向对象的原则。
     * 建议解决方案：
     * 1、将context修改为某个特殊属性名；
     * 2、先检测服务上有没有一个CommandContext类型的context属性，有的话再赋值，
     *    这就要求需要使用context的服务需要是实现一个IContext接口。
     */
    setContextToServiceInstance(serviceInstance, context) {
        // 如果服务上已经存在context属性，并且该属性不是CommandContext类型，则不能覆盖
        const serviceContext = serviceInstance.context;
        if (serviceContext && (serviceContext instanceof CommandContext === false)) {
            return;
        }
        serviceInstance.context = context;
    }
    /**
     * 根据参数描述信息转换参数类型
     */
    transParamTypes(params, paramDescriptions) {
        if (!paramDescriptions) {
            return;
        }
        const keys = Object.keys(params);
        keys.forEach(key => {
            if (!paramDescriptions[key] || !paramDescriptions[key].type) {
                return;
            }
            const parType = paramDescriptions[key].type;
            const value = params[key];
            if (value === undefined || value === null || typeof value === parType) {
                return; // 值不存在或类型匹配，无需处理
            }
            switch (parType) {
                case 'string':
                    // 其实转换前的参数都是string，这里不会走到
                    params[key] = value + '';
                    break;
                case 'int':
                case 'double':
                case 'number':
                    // 前端数值类型只有number，这里兼容命令构件上设置为int和double的情况
                    const numResult = Number(value);
                    if (isNaN(numResult)) {
                        throw Error(`类型转换失败，参数${key}值为${value}，无法转换为${parType}类型。`);
                    }
                    params[key] = numResult;
                    break;
                case 'boolean':
                    let boolResult;
                    const strValue = (value + '').toLowerCase();
                    if (strValue === 'true') {
                        boolResult = true;
                    }
                    else if (strValue === 'false') {
                        boolResult = false;
                    }
                    else {
                        // throw Error(`类型转换失败，参数${key}值为${value}，无法转换为${parType}类型。`);
                        boolResult = false;
                    }
                    params[key] = boolResult;
                    break;
                case 'datetime':
                    // todo：日期时间暂不处理
                    break;
                case 'object':
                    // 表达式解析出来的参数，无需处理，按原类型返回
                    // todo: 输入参数是个json串，转成object
                    break;
                default:
                    break;
            }
        });
    }
}
/**
 * 命令处理器注入Token
 */
const COMMAND_HANDLERS_TOKEN = new InjectionToken('@Farris Command Handlers');

/**
 * 命令处理注册器相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理注册器
 */
class CommandHandlerRegistry {
    /**
     * 构造函数
     * @param handlers 命令处理实例数组
     */
    constructor(handlers) {
        const self = this;
        this.handlerMap = new Map();
        if (handlers) {
            handlers.forEach((handler) => {
                self.regist(handler);
            });
        }
    }
    /**
     * 添加命令处理
     * @param  commandName    命令名称
     * @param  commandHandler 命令处理实例
     */
    set(commandName, commandHandler) {
        if (this.handlerMap.has(commandName)) {
            throw new Error(commandName + '对应的CommandHandler已经存在');
        }
        this.handlerMap.set(commandName, commandHandler);
    }
    /**
     * 获取命令处理
     * @param   commandName 命令名称
     * @returns 命令处理实例
     */
    get(commandName) {
        if (this.handlerMap.has(commandName) === false) {
            throw new Error('找不到' + commandName + '对应的CommandHandler');
        }
        return this.handlerMap.get(commandName);
    }
    /**
     * 注册命令处理
     * @param handlers 命令处理实例
     */
    regist(commandHandler) {
        let commandName = commandHandler.commandName;
        if (!commandName) {
            // 根据metadata获取对应的Command名称
            const handlerMetadata = MetadataUtil.getClassMetadataByName(commandHandler.constructor, NG_COMMAND_HANDLER);
            if (!handlerMetadata) {
                throw new Error('CommandHandler必须指定要处理的命令名称');
            }
            commandName = handlerMetadata.commandName;
        }
        this.set(commandName, commandHandler);
    }
    /**
     * 清空所有命令处理器
     */
    dispose() {
        if (this.handlerMap) {
            this.handlerMap.forEach(handler => {
                handler.dispose();
            });
        }
        this.handlerMap.clear();
    }
}
CommandHandlerRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CommandHandlerRegistry.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [COMMAND_HANDLERS_TOKEN,] }] }
];

/**
 * 命令处理扩展相关
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理扩展抽象类
 *
 * CommandHandler由一个个Task串联而成，这些Task不是一成不变，
 * 通过CommandHandlerExtender可以在不同的时机对它扩展，
 * 通过它我们可以在任务之后新增一个任务或者替换掉原来的一个任务。
 *
 * ### 定义并注册扩展
 *
 * **定义一个扩展**
 *
 * 按如下步骤可以实现一个扩展：
 * - 继承CommandHandlerExtender抽象基类；
 * - 实现extend方法，在其内部对任务进行扩展、替换；
 * - 添加NgCommandHandlerExtender指定要扩展的命令。
 *
 * ```ts
 * @Injectable()
 * @NgCommandHandlerExtender({
 *    commandName: 'formLoad'
 *  })
 * class FormLoadExtender extends CommandHandlerExtender {
 *
 *   extend(handler: CommandHandler): CommandHandler {
 *
 *     // 扩展一个任务
 *     handler.extendTask('loadData', (originalResult) => {
 *       console.log('do sth. to the original result');
 *     });
 *
 *     // 替换一个任务
 *     handler.extendTask('transitState', () => {
 *       console.log('transit to other state');
 *     });
 *
 *     return handler;
 *   }
 * }
 * ```
 * 在extend方法内部：
 * - 通过extendTask方法扩展任务，一个任务可以被多次扩展，多个扩展依次附加到原来的任务之上；
 * - 通过replaceTask方法替换任务，一个任务可以被多次替换，以最后一个替换为准。
 *
 * **注册扩展**
 *
 * 我们将包含FormLoadHandlerExtender的数组传递给CommandModule.setup方法，
 * 由它来统一进行注册。
 * ```ts
 * @NgModule({
 *   imports: [
 *     CommandModule.setup([FormLoadHandler], [FormLoadHandlerExtender])
 *   ]
 * })
 * class SimpleModule {}
 * ```
 */
class CommandHandlerExtender {
}
CommandHandlerExtender.decorators = [
    { type: Injectable }
];
/**
 * 命令处理器扩展注入Token
 */
const COMMAND_HANDLER_EXTENDERS_TOKEN = new InjectionToken('@farris/devkit CommandHandler Extenders');

/**
 * 命令处理扩展注册器相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理扩展注册器
 */
class CommandHandlerExtenderRegistry {
    /**
     * 构造函数
     * @param extenders 命令扩展实例数组
     */
    constructor(extenders) {
        const self = this;
        this.extendersMap = new Map();
        if (extenders) {
            extenders.forEach((extender) => {
                self.regist(extender);
            });
        }
    }
    /**
     * 获取命令扩展实例数组
     * @param   commandName 命令名称
     * @returns 命令处理扩展实例数组
     */
    get(commandName) {
        if (this.extendersMap.has(commandName) === false) {
            return [];
        }
        return this.extendersMap.get(commandName);
    }
    /**
     * 添加命令扩展
     * @param commandName Command名称
     * @param extender    CommandHandlerExtender实例
     * @return void
     */
    set(commandName, extender) {
        if (this.extendersMap.has(commandName)) {
            // 如果commandName对应的扩展已经存在，则在扩展数组中追加
            this.extendersMap.get(commandName).push(extender);
        }
        else {
            // 如果不存在，则创建新的扩展数组，并追加
            this.extendersMap.set(commandName, [extender]);
        }
    }
    /**
     * 注册命令扩展
     * @param extender CommandHandlerExtender实例
     */
    regist(extender) {
        // 通过元数据获取要扩展的Comamnd名称
        const extenderMetadata = MetadataUtil.getClassMetadataByName(extender.constructor, NG_COMMAND_HANDLER_EXTENDER);
        if (!extenderMetadata) {
            throw new Error('CommandHandlerExtender必须指定要扩展的命令名称');
        }
        const commandName = extenderMetadata.commandName;
        // 添加到Map中
        this.set(commandName, extender);
    }
    dispose() {
        this.extendersMap.clear();
    }
}
CommandHandlerExtenderRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CommandHandlerExtenderRegistry.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [COMMAND_HANDLER_EXTENDERS_TOKEN,] }] }
];

/**
 * NgComponentState元数据名称
 */
const NG_COMPONENT_STATE = 'NgParam';
/**
 * NgUIState
 */
const NgParam = makePropDecorator(NG_COMPONENT_STATE, (obj) => obj);

class UIStateMetadataUtil {
    /**
     * 获取NgUIState的属性元数据
     * @param
     * @returns 属性元数据对象
     * @example
     * 返回格式：
     * {
     *    '属性名称': <NgUIStateProperty>{ ...}
     * }
     */
    static getUIFields(target) {
        return MetadataUtil.getPropsMetadatasByName(target, NG_COMPONENT_STATE);
    }
}

/*
 * @Author: Witt
 * @Date: 2018-11-17 13:38:23
 * @Last Modified by: Witt
 * @Last Modified time: 2018-11-17 13:38:50
 * @todo：临时删除原有功能，待重构
 */
/**
 * UI状态
 */
class UIState {
    constructor() {
        this.paramTypeTransform = false;
        this.changes = new Subject();
        this.innerData = Object.assign({});
        this._init();
    }
    _init() {
        const uiFields = UIStateMetadataUtil.getUIFields(this.constructor);
        this.initializeUIField(uiFields);
    }
    initialize(context) {
        const uiFields = context.metadata.uiStates || UIStateMetadataUtil.getUIFields(this.constructor);
        this.initializeUIField(uiFields);
    }
    initializeUIField(uiFieldMetadata) {
        Object.keys(uiFieldMetadata).forEach(propertyName => {
            const fieldMetadata = uiFieldMetadata[propertyName];
            const uiField = fieldMetadata.stateName || propertyName;
            if (delete this[propertyName]) {
                this.defineProperty(propertyName, uiField);
            }
        });
    }
    isExistProperty(propertyName) {
        if (this.innerData.hasOwnProperty(propertyName) || this.hasOwnProperty(propertyName)) {
            return true;
        }
        return false;
    }
    defineProperty(propertyName, field = null) {
        Object.defineProperty(this, propertyName, {
            get: function () {
                return field !== null ? this.innerData[field] : this.innerData[propertyName];
            },
            set: function (value) {
                // 值相同时不触发变更
                const oldValue = field !== null ? this.innerData[field] : this.innerData[propertyName];
                if (this.paramTypeTransform === true) {
                    const ngParams = UIStateMetadataUtil.getUIFields(this.constructor);
                    const ngParam = ngParams && ngParams[propertyName] || null;
                    const dataType = ngParam && ngParam.originalDataType || null;
                    if (dataType) {
                        value = this.transform(value, dataType);
                    }
                }
                if (oldValue === value) {
                    return;
                }
                if (field !== null) {
                    this.innerData[field] = value;
                }
                else {
                    this.innerData[propertyName] = value;
                }
                this.changes.next({
                    field: propertyName,
                    value: value
                });
            }
        });
    }
    setPropertyValue(propertyName, value) {
        if (propertyName === '' || propertyName === undefined) {
            return;
        }
        if (!this.isExistProperty(propertyName)) {
            this.defineProperty(propertyName);
        }
        this[propertyName] = value;
    }
    transform(target, dataType) {
        if (!dataType) {
            return target;
        }
        dataType = dataType.toLowerCase();
        if (dataType === 'string') {
            if (target === null || target === undefined) {
                return target;
            }
            return target.toString();
        }
        else if (dataType === 'number') {
            if (target === undefined) {
                return undefined;
            }
            const result = Number(target);
            if (isNaN(result)) {
                throw new Error(`${target}无法转换为数字！`);
            }
            return result;
        }
        else if (dataType === 'boolean') {
            if (typeof target === 'boolean') {
                return target;
            }
            else {
                if (target === null || target === undefined) {
                    return false;
                }
                target = target.toString().toLowerCase();
                if (target === 'false') {
                    return false;
                }
                else if (target === 'true') {
                    return true;
                }
                else {
                    throw new Error(`${target}无法转换为布尔类型！`);
                }
            }
        }
        else if (dataType === 'date' || dataType === 'datetime') {
            // 日期、日期时间在前端依然按照字符串处理
            return target;
        }
        else if (dataType === 'object') {
            if (typeof target === 'object') {
                return target;
            }
            else {
                try {
                    return JSON.parse(target);
                }
                catch (_a) {
                    throw new Error(`${target}无法转换为对象！`);
                }
            }
        }
        else {
            return target;
        }
    }
}
UIState.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UIState.ctorParameters = () => [];

/**
 * 变量类型转换
 */
const PARAM_TYPE_TRANSFORM_TOKEN = new InjectionToken('@farris/devkit_param_type_transform');

/**
 * --------------------------------------------------------------------------------
 * State相关
 * --------------------------------------------------------------------------------
 */
/**
 * 基本状态：表单的基本状态，通过State的运算确定RenderState的值，进而控制页面控件的状态。
 */
class State {
    /**
     * 构造函数
     * @param name 状态名称
     */
    constructor(name) {
        this.name = name;
    }
}
/**
 * 初始渲染状态
 */
const initialUIState = false;

/**
 * 状态机上下文
 */
class StateMachineContext {
    /**
     * 构造函数
     * @param stateMachine 状态机
     * @param initialState 初始状态
     */
    constructor(stateMachine) {
        this.stateMachine = stateMachine;
        // this.state = initialState.name;
    }
    initialize(variableParseService, initialState) {
        this.frameContext = this.stateMachine && this.stateMachine.frameContext || null;
        this.state = this.state || (initialState ? initialState.name : '');
        this.parser = variableParseService;
        this.stateMachineEvent = this.stateMachine.stateMachineEvent;
    }
    /**
     * 状态迁移
     * @param stateName 下一状态的名称
     */
    transitTo(stateName) {
        const nextState = this.stateMachine.states[stateName];
        if (nextState) {
            this.state = nextState.name;
            this.stateMachine.render();
        }
    }
    parse(expression, targetType) {
        if (expression === null || expression === undefined) {
            return expression;
        }
        const context = this.stateMachineEvent.getFrameContext(expression) || this.stateMachine.frameContext;
        switch (targetType) {
            case 'source':
                return this.parseSourceValue(expression, context);
            case 'target':
                return this.parser.parse(expression, context);
        }
    }
    parseSourceValue(expression, context) {
        if (expression === null || expression === undefined) {
            return expression;
        }
        let result = expression.trim();
        result = this.parser.parse(result, context);
        if (result === 'state') {
            result = this.state;
        }
        return result;
    }
    // 兼容旧版本
    get(expression) {
        return this.getUIState(expression);
    }
    // 解析uistate变量表达式并返回表达式的值
    getUIState(expression) {
        if (!expression) {
            return;
        }
        const frameContext = this.stateMachineEvent.getFrameContext(expression);
        if (!frameContext) {
            return;
        }
        this.stateMachineEvent.ListenUIStateChange(frameContext, expression);
        if (this.parser) {
            const value = this.parser.parse(expression, frameContext);
            if (value === null) {
                return null;
            }
            if (typeof value === 'object' && Object.keys(value).length === 0) {
                return null;
            }
            return value;
        }
        else {
            throw new Error('未初始化变量解析器。');
        }
    }
    // 解析data变量表达式并返回表达式的值
    getData(expression) {
        if (!expression) {
            return;
        }
        const frameContext = this.stateMachineEvent.getFrameContext(expression);
        if (!frameContext) {
            return;
        }
        this.stateMachineEvent.ListenEntityChange(frameContext, expression);
        if (this.parser) {
            const value = this.parser.parse(expression, frameContext);
            if (value === null) {
                return null;
            }
            if (typeof value === 'object' && Object.keys(value).length === 0) {
                return null;
            }
            return value;
        }
        else {
            throw new Error('未初始化变量解析器。');
        }
    }
}

/**
 * 状态机事件，监听uistate的变化和entity的变化
 */
class StateMachineEvent {
    constructor(stateMachine) {
        this.stateMachine = stateMachine;
        this.uiFieldList = [];
        this.dataFieldList = [];
        this.frameContextMap = new Map();
        this.dataFrameContextMap = new Map();
    }
    get appContext() {
        return this.stateMachine.appContext;
    }
    initialize(frameContext) {
        this.frameContext = frameContext;
    }
    /**
     * 暂时把这个方法放了这个地方，等季老师共用方法调整后，直接引用他的方法，该方法可删除
     */
    extractPaths(expression) {
        let path = '';
        const UI_STATE_PATTERN_G = /\{UISTATE~(\S+?)\}$/g;
        const DATA_PATTERN_G = /\{DATA~(\S+?)\}$/g;
        if (typeof expression === 'string') {
            const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
            const dataVariables = expression.match(DATA_PATTERN_G);
            if (uiStateVariables !== null) {
                const UI_STATE_PATTERN = /\{UISTATE~(\S+?)\}$/;
                uiStateVariables.forEach((uiStateVariable) => {
                    const pathMatches = uiStateVariable.match(UI_STATE_PATTERN);
                    if (pathMatches != null && pathMatches.length === 2) {
                        path = pathMatches[1];
                    }
                });
            }
            if (dataVariables !== null) {
                const DATA_PATTERN = /\{DATA~(\S+?)\}$/;
                dataVariables.forEach((dataVariable) => {
                    const pathMatches = dataVariable.match(DATA_PATTERN);
                    if (pathMatches != null && pathMatches.length === 2) {
                        path = pathMatches[1];
                    }
                });
            }
        }
        return path;
    }
    // 根据表达式返回当前组件的frameContext
    getFrameContext(expression) {
        let frameId = this.extractPaths(expression).split('/')[1] || '';
        if (frameId.startsWith('#{') && frameId.endsWith('}') && this.frameContext) {
            const relativeFrameId = frameId.substring(2, frameId.length - 1);
            frameId = this.frameContext.namespace ? `${this.frameContext.namespace}_${relativeFrameId}` : relativeFrameId;
        }
        return this.appContext.getFrameContext(frameId);
    }
    // 根据表达式返回当前组件的字段(可能是实体字段也可能是uistate的字段)
    getFrameField(expression) {
        return this.extractPaths(expression).split('/')[2];
    }
    // 监听表单变量的变化
    ListenUIStateChange(frameContext, expression) {
        const frameField = this.getFrameField(expression);
        if (!this.frameContextMap.has(frameContext)) {
            this.frameContextMap.set(frameContext, this.uiFieldList);
            frameContext.uiState.changes.subscribe((data) => {
                if (data.field && this.frameContextMap.get(frameContext).indexOf(data.field) > -1) {
                    this.stateMachine.render();
                }
            });
        }
        if (this.frameContextMap.get(frameContext).indexOf(frameField) === -1) {
            this.uiFieldList.push(frameField);
        }
    }
    // 监听实体数据的变化
    ListenEntityChange(frameContext, expression) {
        if (!this.dataFrameContextMap.has(frameContext)) {
            this.dataFrameContextMap.set(frameContext, this.dataFieldList);
            frameContext.bindingData.changes.subscribe((change) => {
                // 切换当前行用到的是
                if (change.type === 'Load' || change.type === 'SelectionChanged') {
                    this.stateMachine.render();
                }
                if (change.path.join() && this.isAccordingValue(this.dataFrameContextMap.get(frameContext), change.path.join('/'))) {
                    this.stateMachine.render();
                }
            });
        }
        if (this.dataFrameContextMap.get(frameContext).indexOf(expression) === -1) {
            this.dataFieldList.push(expression);
        }
    }
    // 监听是否是解析的数据发生变化
    isAccordingValue(arr, path) {
        return arr.find(item => {
            return item.indexOf(path) > -1;
        }) === undefined ? false : true;
    }
}
StateMachineEvent.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateMachineEvent.ctorParameters = () => [
    { type: StateMachine }
];

/**
 * 预置界面效果处理
 */
const effectHandlers = {
    /**
     * 预置状态迁移处理
     */
    transit: {
        /**
         * 执行状态迁移
         * @param stateMachine  状态机对象
         * @param stateName     下一状态的名称
         * @param preconditions 迁移条件
         */
        // tslint:disable-next-line: only-arrow-functions
        perform: function (statemachine, stateName, preconditons = []) {
            const nextState = statemachine.states[stateName];
            statemachine.context.transitTo(nextState.name);
            statemachine.render();
        }
    }
};
/**
 * 状态机
 *
 * ### 基本概念
 * 状态机中有三个重要的概念：
 * - 页面状态（State）：页面的整体状态，比如查看状态、编辑状态；
 * - 控件状态（RenderState）：控制具体控件的状态；
 * - 迁移动作（Action）：当动作发生时，将页面切换到指定的页面状态。
 *
 * ### 定义状态机
 *
 * **基本步骤**
 *
 * - 继承StateMachine基类，并添加NgStatemachine注解；
 * - 定义页面状态、控件状态、迁移动作。
 *
 * **状态机中的注解**
 *
 * - NgStatemachine：将类标记为状态机，并进行扩展；
 * - NgState：将属性标记为页面状态，通过initialState可以标记此状态是否为初始状态；
 * - NgRenderState：将属性标记为控件状态，通过render方法指定控件状态的切换规则，
 *   一般情况下是通过对页面状态进行逻辑运算来确定。
 * - NgAction：将属性标记为迁移动作，通过transitTo指定动作执行时要迁移到哪个页面状态。
 *
 * ```ts
 * @Injectable()
 * @NgStatemachine()
 * class SimpleStateMachine extends StateMachine {
 *
 *   // 查看状态，设置为初始状态
 *   @NgState({ initialState: true })
 *   viewState: State;
 *
 *   // 编辑状态
 *   @NgState()
 *   editState: State;
 *
 *   // 编辑按钮是否允许点击
 *   @NgRenderState({
 *     render: (context) => context.state === 'viewState'
 *   })
 *   canEdit: RenderState;
 *
 *   // 保存按钮是否允许点击
 *   @NgRenderState({
 *     render: (context) => context.state === 'editState'
 *   })
 *   canSave: RenderState;
 *
 *   // 输入控件是否允许输入
 *   @NgRenderState({
 *     render: (context) => context.state === 'editState'
 *   })
 *   canInput: RenderState;
 *
 *   // 迁移到编辑状态
 *   @NgAction({ transitTo: 'editState' })
 *   edit: Action;
 *
 *   // 迁移到查看状态
 *   @NgAction({ transitTo: 'viewState' })
 *   view: Action;
 * }
 * ```
 * 在上边的代码中做了如下定义：
 * - 两个页面状态：查看状态、编辑状态，
 * - 三个控件状态：分别用来控制编辑按钮、保存按钮、输入控件的状态，
 * - 两个迁移动作：view动作用来将页面切换到查看状态，edit动作用来将页面切换到编辑状态。
 *
 *
 * ### 在模板中使用状态机
 *
 * 模板中我们主要使用的是控件状态，多个控件可以共享一个控件状态。
 *
 * ```html
 * <button type="button" [disabled]="!viewModel.stateMachine.canEdit">编辑</button>
 * <button type="button" [disabled]="!viewModel.stateMachine.canSave">保存</button>
 * <input id="code" [disabled]="!viewModel.stateMachine.canInput" />
 * <input id="name" [disabled]="!viewModel.stateMachine.canInput" />
 * ```
 *
 * ### 执行状态迁移
 * 通过执行状态机上的动作来将页面切换到页面状态，进而改变控件状态。
 * 假设我们有这么一个场景，当用户点击保存按钮的时候，我们先执行保存，保存完成后将状态迁移到查看状态。
 * 我们可以定义一个CommandHandler，添加两个对应的任务，具体代码如下：
 * ```ts
 * @Injectable()
 * @NgCommandHandler({
 *   commandName: 'save'
 * })
 * class SaveHandler extends CommandHandler {
 *
 *   schedule() {
 *     this.addTask('save', () => {
 *       // 实现保存
 *     });
 *
 *     // 状态迁移
 *     this.addTask('transitState', ) => {
 *       this.stateMachine['view']();
 *     });
 *   }
 * }
 * ```
 */
class StateMachine {
    /**
     * 构造函数
     */
    constructor() {
        this.isStateInited = false;
        this.isDisposed = false;
        const propsMetadatas = MetadataUtil.getPropsMetadatas(this.constructor);
        // 遍历所有属性装饰器，并调用相应的build方法
        if (propsMetadatas) {
            Object.keys(propsMetadatas).forEach((propName) => {
                const propMetadatas = propsMetadatas[propName];
                propMetadatas.forEach(propMetadata => {
                    this['build' + propMetadata.ngMetadataName](propName, propMetadata);
                });
            });
        }
        // if (!this.initialState) {
        //   throw new Error('请在NgState注解中指定状态机的初始状态。');
        // }
        this.stateChange = new BehaviorSubject(false);
        this.context = new StateMachineContext(this);
        this.stateMachineEvent = new StateMachineEvent(this);
    }
    dispose(options) {
        this.isDisposed = true;
        this.frameContext = null;
        this.appContext = null;
        this.context = null;
        this.stateMachineEvent = null;
        this.metadatas = null;
    }
    ngOnDestroy() {
        this.dispose();
    }
    // 状态机变更，为了在绑定数据之后执行状态机的操作，把render方法延后执行。
    initialize(frameContext, variableParseService) {
        this.appContext = frameContext.appContext;
        this.frameContext = frameContext;
        const stateMachineMetadata = this.appContext.metadata.stateMachine || this.collectionMetadata();
        this.metadatas = stateMachineMetadata;
        this.buildStateMachine(stateMachineMetadata);
        // if (!this.initialState) {
        //   throw new Error('请在NgState注解中指定状态机的初始状态。');
        // }
        this.context.initialize(variableParseService, this.initialState);
        this.stateMachineEvent.initialize(this.frameContext);
        this.render();
    }
    collectionMetadata() {
        const stateMachineMetadata = {
            states: {},
            renderStates: {},
            actions: {}
        };
        const propsMetadatas = MetadataUtil.getPropsMetadatas(this.constructor);
        if (propsMetadatas) {
            Object.keys(propsMetadatas).forEach((propName) => {
                const propMetadatas = propsMetadatas[propName];
                propMetadatas.forEach(propMetadata => {
                    switch (propMetadata.ngMetadataName) {
                        case 'NgState':
                            stateMachineMetadata.states[propName] = propMetadata;
                            break;
                        case 'NgRenderState':
                            stateMachineMetadata.renderStates[propName] = propMetadata;
                            break;
                        case 'NgAction':
                            stateMachineMetadata.actions[propName] = propMetadata;
                            break;
                    }
                });
            });
        }
        return stateMachineMetadata;
    }
    buildStateMachine(metadata) {
        Object.keys(metadata.states).forEach((stateName) => {
            this.buildNgState(stateName, metadata.states[stateName]);
        });
        Object.keys(metadata.renderStates).forEach((renderStateName) => {
            this.buildNgRenderState(renderStateName, metadata.renderStates[renderStateName]);
        });
        Object.keys(metadata.actions).forEach((actionName) => {
            this.buildNgAction(actionName, metadata.actions[actionName]);
        });
    }
    /**
     * 构造状态
     * @param stateName 状态名称
     * @param ngState   状态对象
     */
    buildNgState(stateName, ngState) {
        this.states = this.states || {};
        this[stateName] = new State(stateName);
        this.states[stateName] = this[stateName];
        if (ngState.initialState) {
            this.initialState = this[stateName];
        }
    }
    /**
     * 构造界面状态
     * @param renderStateName 渲染状态名称
     * @param ngRenderState   渲染状态元数据
     */
    buildNgRenderState(renderStateName, ngRenderState) {
        this.renderStates = this.renderStates || {};
        this[renderStateName] = initialUIState;
        this.renderStates[renderStateName] = this[renderStateName];
        // 将renderState上指定的render加入到renders中
        this.renders = this.renders || {};
        this.renders[renderStateName] = ngRenderState.render;
    }
    /**
     * 构造动作
     * @param actionName 动作名称
     * @param ngAction   动作元数据
     */
    buildNgAction(actionName, ngAction) {
        this[actionName] = () => {
            effectHandlers.transit.perform(this, ngAction.transitTo, ngAction.precondition);
        };
    }
    /**
     * 重新计算所有渲染状态的值
     * 当 state切换的时候，调用遍历所有的render方法，更改renderState
     */
    render() {
        if (this.isDisposed) {
            return;
        }
        for (const renderStateName in this.renderStates) {
            if (this.renderStates.hasOwnProperty(renderStateName) === false) {
                continue;
            }
            const stateRender = this.renders[renderStateName];
            if (!stateRender) {
                continue;
            }
            // 调用render方法，更新renderState
            this.renderStates[renderStateName] = stateRender(this.context);
            this[renderStateName] = this.renderStates[renderStateName];
        }
        this.stateChange.next(this.context.state);
    }
}

/**
 * NgState
 */
const NgState = makePropDecorator('NgState', (obj) => obj);
/**
 * NgRenderState
 */
const NgRenderState = makePropDecorator('NgRenderState', (obj) => obj);
/**
 * NgRenderStateDecorator
 */
const NgAction = makePropDecorator('NgAction', (action) => action);

/**
 * 命令装饰器名称
 * @type {string}
 */
const NG_COMMAND = 'NgCommand';
/**
 * 命令装饰器工厂
 * @type {any}
 */
const NgCommand = makePropDecorator(NG_COMMAND, (obj) => obj);

/**
 * ViewModel是界面层访问应用层的入口。
 *
 * ### 定义ViewModel
 *
 * 定义ViewModel需要以下几个步骤：
 *
 * 1、定义的ViewModel需要继承ViewModel基类
 * 2、使用NgViewModel关联相关对象，比如：绑定数据（SinmpleDemoBindingData）、表单（SimpleDemoForm）、
 *    状态机（SimpleDemoStateMachine）等，但所有这些关联都是可选的，用不到或者自己单独实现时，不指定即可。
 * 3、同时我们需要传递一个injector给基类的构造函数，在ViewModel实例化时，会从injector获取NgViewModel声明的各个类型的实例。
 *
 * 下面我们来定义一个简单的ViewModel，代码如下：
 * ```ts
 * import { Injector, Injectable } from '@angular/core';
 * import { NgViewModel, ViewModel } from '@farris/devkit';
 *
 * @Injectable()
 * @NgViewModel({
 *   children: [],
 *   binding: SimpleDemoBindingData,
 *   form: SimpleDemoForm,
 *   stateMachine: SimpleDemoStateMachine,
 * })
 * class SimpleDemoViewModel extends ViewModel {
 *    constructor(injector: Injector) {
 *      super(injector);
 *    }
 *    @NgCommand({
 *      name: 'formLoad',
 *      params: {
 *        dataId: '1'
 *      }
 *    })
 *    public formLoad() {}
 * }
 * export { SimpleDemoViewModel };
 * ```
 *
 * 通过组件的构造函数，我们将ViewModel注入进组件
 * ```ts
 * @Component({
 *   selector: 'app-simple-demo',
 *   templateUrl: './simple-demo.component.html'
 * })
 * class SimpleDemoComponent implements OnInit {
 *
 *   public viewModel: SimpleDemoViewModel;
 *
 *   constructor(viewModel: SimpleDemoViewModel) {
 *     this.viewModel = viewModel;
 *   }
 * }
 * ```
 *
 * ### 组件模板中使用ViewModel
 *
 * 我们可以在模板中绑定NgViewModel中指定的 BindingData、Form、StateMachine的实例。
 * ```html
 * * <!--绑定数据-->
 * <p>{{viewModel.bindingData.name}}</p>
 *
 * <!--绑定表单-->
 * <form [formGroup]="viewModel.form">
 *   <input type="text" formControlName="name">
 * </form>
 *
 * <!--绑定状态机-->
 * <button type="button" [disabled]="!viewModel.stateMachine.canAdd">新增 </button>
 * * ```
 *
 * 我们在模板中绑定绑定viewModel的一个方法作为事件处理，这个方法可以是普通的方法，也可以是用NgCommand注解修饰过的。
 * ```html
 * <button type="button" (click)="viewModel.add()">新增 </button>
 * ```
 *
 * ### 组合的ViewModle
 *
 * 当界面比较复杂时，我们对界面按一定的粒度进行拆分，拆分出来的各个组成部分分别对应一个ViewModel，这样就形成了一个ViewModel树。
 * 我们在父的ViewModel的NgViewModel注解中通过在children属性中声明它的子ViewModel，将它们关联起来。
 * 假设我们有一个左列表右卡片的界面，我们可以为左列表、右卡片分别定义一个ViewModel，然后在页面的ViewModel中，将它们组合起来，
 * 代码如下：
 * ```ts
 * @Injectable()
 *  @NgViewModel({
 *  children: [LeftListViewModel, RightCardViewModel],
 *    binding: NestedDemoBindingData,
 * })
 * class NestedDemoViewModel extends ViewModel {
 *   constructor(injector: Injector) {
 *     super(injector);
 *   }
 * }
 * export { NestedDemoViewModel };
 * ```
 */
class ViewModel {
    /**
     * kendogrid option
     */
    // constructor(metadata?: IContextMetadata) {
    //   if (!this.bindingPath && metadata && metadata.bindingTo) {
    //     this.bindingPath = metadata.bindingTo;
    //   }
    // }
    constructor() {
        /**
         * 界面验证信息
         */
        this.verifyInformations = [];
        this.verifycationChanged = new Subject();
    }
    /**
     * 表达式服务
     */
    get expression() {
        return this.frameContext.expressionManager;
    }
    /**
     * 表达式结果
     */
    get expressionResult() {
        return this.frameContext.expressionResult;
    }
    ngOnDestroy() {
        this.dispose();
    }
    dispose(options) {
        // this.frameContext = null;
        // this.bindingData = null;
        // this.stateMachine = null;
        this.form = null;
        // this.uiState = null;
        if (this.entityValueChangingListeners) {
            this.entityValueChangingListeners.clear();
        }
        if (this.entityValueChangedListeners) {
            this.entityValueChangedListeners.clear();
        }
        if (this.verifycationChanged) {
            this.verifycationChanged.complete();
            this.verifycationChanged = null;
        }
    }
    setMetadata(metadata) {
        if (!this.bindingPath && metadata && metadata.bindingTo) {
            this.bindingPath = metadata.bindingTo;
        }
    }
    /**
     * 初始化
     */
    init(context) {
        if (!this.name) {
            this.name = context.metadata.viewModelCode || this.constructor.name;
        }
        this.frameContext = context;
        this.bindingData = context.bindingData;
        this.uiState = context.uiState;
        this.form = context.form;
        this.stateMachine = context.stateMachine;
        this.buildCommands(context);
        this.entityValueChangingListeners = new Map();
        this.entityValueChangedListeners = new Map();
        // 为bindingData赋值值变化监听器
        if (this.bindingData) {
            this.bindingData.setValueChangeInvokerFactory((paths) => {
                return (preValue, value, entityChanged, primaryValue) => {
                    const plainPath = '/' + paths.join('/');
                    let command;
                    if (entityChanged === false) {
                        command = this.entityValueChangingListeners[plainPath];
                    }
                    else {
                        command = this.entityValueChangedListeners[plainPath];
                    }
                    if (!!command) {
                        const change = {
                            paths: paths,
                            preValue: preValue,
                            value: value,
                            id: primaryValue,
                            changed: entityChanged
                        };
                        const triggerFlag = 'trigger:';
                        const commands = command.split(';').filter(p => p);
                        // 过滤出所有值变化前后事件
                        const valueChangeCommands = commands.filter(item => !item.startsWith(triggerFlag));
                        // 过滤出所有组件通讯
                        const triggers = commands.filter(item => item.startsWith(triggerFlag));
                        const squence = valueChangeCommands.concat(triggers);
                        let valueChangeSuccess = true;
                        return from(squence).pipe(concatMap(item => {
                            if (!valueChangeSuccess && entityChanged === false) {
                                return EMPTY;
                            }
                            if (item.startsWith(triggerFlag)) {
                                // 值变化前后事件绑定了组件通信
                                const eventName = item.substring(8);
                                this.frameContext.frameComponent.trigger(eventName);
                                valueChangeSuccess = true;
                                return of(true);
                            }
                            else {
                                return this[item](change).pipe(tap((result) => {
                                    valueChangeSuccess = result;
                                }));
                            }
                        }), every((result) => result));
                        // return this[command](change).pipe(map(result => {
                        //   return result === false ? false : true;
                        // }));
                    }
                    else {
                        return of(true);
                    }
                };
            });
        }
        this.initListeners();
    }
    /**
     * 绑定命令
     */
    buildCommands(context) {
        const ngCommands = context.metadata.commands || MetadataUtil.getPropsMetadatasByName(this.constructor, NG_COMMAND);
        this.metadatas = ngCommands;
        this.keybindingMap = new Map();
        Object.keys(ngCommands).forEach((propertyName) => {
            const ngCommand = ngCommands[propertyName];
            // 注册快捷键
            if (ngCommand.keyBinding) {
                this.keybindingMap.set(propertyName, ngCommand.keyBinding);
            }
            Object.defineProperty(this, propertyName, {
                value: (data) => {
                    if (context.isDisposed) {
                        return EMPTY;
                    }
                    // 获取命令处理上下文
                    let targetContext = context;
                    if (ngCommand.frameId) {
                        targetContext = context.appContext.getFrameContext(ngCommand.frameId);
                    }
                    const command = {
                        name: ngCommand.name,
                        params: ngCommand.params,
                        paramDescriptions: ngCommand.paramDescriptions,
                        eventParam: data || null
                    };
                    return targetContext.commandBus.dispatch(command);
                }
            });
        });
    }
    /**
     * 从Form获取监听器
     */
    initListeners() {
        const extractPath = (bindingBasePath, bindingPath) => {
            return '/' + bindingBasePath.split('/').concat(bindingPath.split('.')).filter((item) => item.length > 0).join('/');
        };
        if (this.form) {
            const valueChangingListeners = this.form.getEntityValueChangingListeners();
            Object.keys(valueChangingListeners).forEach((bindingPath) => {
                const plainPath = extractPath(this.bindingPath, bindingPath);
                this.entityValueChangingListeners[plainPath] = valueChangingListeners[bindingPath];
            });
            const valueChangedListeners = this.form.getEntityValueChangedListeners();
            Object.keys(valueChangedListeners).forEach((bindingPath) => {
                const plainPath = extractPath(this.bindingPath, bindingPath);
                this.entityValueChangedListeners[plainPath] = valueChangedListeners[bindingPath];
            });
        }
    }
    bindToParent(parent) {
        if (parent) {
            if (parent.verifycationChanged) {
                parent.verifycationChanged.subscribe(verifyInformations => {
                    if (this.verifycationChanged) {
                        this.verifycationChanged.next(verifyInformations);
                    }
                });
            }
        }
    }
    /**
     * 合并审批及表单表达式并计算结果
     * @param expression 表达式
     * @returns
     */
    transform(expression) {
        if (Array.isArray(expression)) {
            const wfConf = expression.find(item => item && item.source === 'wf');
            if (wfConf && wfConf.value) {
                return this.transform(wfConf.value);
            }
            else {
                return this.transform(expression[0]);
            }
        }
        else {
            if (typeof expression === 'boolean') {
                return expression;
            }
            else if (typeof expression === 'string') {
                return new Function('ctx', `return ${expression}`).apply(this.frameContext, [this]);
            }
            else {
                // 表达式result
                return expression;
            }
        }
    }
}
ViewModel.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ViewModel.ctorParameters = () => [];

class Context {
    constructor() {
        /**
         * 上下文变量
         */
        this.params = new Map();
    }
    /**
     * 获取变量
     */
    getParam(key) {
        return this.params.get(key);
    }
    /**
     * 设置变量
     */
    setParam(key, value) {
        this.params.set(key, value);
    }
}
Context.decorators = [
    { type: Injectable }
];

/*
 * @Author: Witt
 * @Date: 2018-12-29 10:46:01
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-30 17:56:02
 */
/**
 * BindingData管理类
 */
class BindingDataManager {
    /**
     * 构造函数
     */
    constructor() {
        this.bindingDataMap = new Map();
    }
    /**
     * 获取BindingDataMap
     */
    getBindingDataMap() {
        return this.bindingDataMap;
    }
    /**
     * 根据name获取BindingData
     * @return 找不到时返回undefined
     */
    getBindingDataByName(name) {
        return this.bindingDataMap.get(name);
    }
    /**
     * 初始化全局的BindingData
     * @description 仅在高速模式时注册bindingData
     */
    regBindingData(name, bindingData) {
        this.bindingDataMap.set(name, bindingData);
    }
    unRegisteBindingData(name) {
        this.bindingDataMap.delete(name);
    }
    /**
     * 是否Repository已经存在
     */
    ifBindingDataExits(name) {
        const bindingData = this.getBindingDataByName(name);
        return bindingData ? true : false;
    }
    dispose() {
        this.bindingDataMap.clear();
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-29 10:46:01
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-30 18:06:11
 */
/**
 * Repository管理类
 */
class RepositoryManager {
    /**
     * 构造函数
     */
    constructor() {
        this.repositoryMap = new Map();
    }
    /**
     * 注册Repository
     */
    regRepository(name, repository) {
        this.repositoryMap.set(name, repository);
    }
    unRegisteRepository(name) {
        this.repositoryMap.delete(name);
    }
    /**
     * 获取RepositoryMap
     * @internal
     */
    getRepositoryMap() {
        return this.repositoryMap;
    }
    /**
     * 获取Repository数组
     */
    getRepositories() {
        return Array.from(this.repositoryMap.values());
    }
    /**
     * 根据name获取Repository
     */
    getRepositoryByName(name) {
        return this.repositoryMap.get(name);
    }
    /**
     * 是否Repository已经存在
     */
    ifRepositoryExits(name) {
        const repository = this.getRepositoryByName(name);
        return repository ? true : false;
    }
    dispose() {
        // this.repositoryMap.forEach((repo: Repository<any>) => {
        //   if (repo) {
        //     repo.entityCollection.reset(false);
        //   }
        // });
        this.repositoryMap.clear();
    }
}
RepositoryManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RepositoryManager.ctorParameters = () => [];

/**
 * FrameComponent刷新器
 */
class FrameComponentRefresher {
    /**
     * 构造函数
     */
    constructor() {
        this.frameComponentMap = new Map();
    }
    /**
     * 刷新组件
     */
    refreshComponents() {
        this.frameComponentMap.forEach((component, frameId) => {
            if (typeof component['onFormLoad'] === 'function') {
                component.onFormLoad();
            }
        });
    }
    /**
     * 注册组件
     * @param frameId   FrameId
     * @param component Frame组件实例
     */
    regFrameComponent(frameId, component) {
        this.frameComponentMap.set(frameId, component);
    }
    /**
     * 注销组件注册
     */
    unregFrameContext(frameContext) {
        const frameId = frameContext.frameId;
        this.frameComponentMap.delete(frameId);
    }
    dispose() {
        this.frameComponentMap.clear();
    }
}

/**
 * 变更检测控制器
 */
class ChangeDetectionController {
    /**
     * 构造函数
     */
    constructor(frameContextManager) {
        this.frameContextManager = frameContextManager;
    }
    /**
     * 所有的FrameContext数组
     */
    get frameContexts() {
        return this.frameContextManager.getFrameContexts();
    }
    /**
     * 将所有的FrameComponent重新加入到变更检测树
     * @todo
     * 1、该方法仅供数据源变更产生大量变更时优化性能使用；
     * 2、加setTimeout来保证数据变更流完成之后，再执行变更检测，目前父对象是通过subscribe监听子对象变化，导致产生异步；
     * 3、应该从根本上解决该问题，而不是setTimeout。
     */
    reattach() {
        setTimeout(() => {
            this.frameContexts.forEach((frameContext) => {
                frameContext.frameComponent.reattach();
                frameContext.frameComponent.detectChanges();
            });
        });
    }
    /**
     * 将所有的FrameComponent脱离变更检测树
     */
    detach() {
        this.frameContexts.forEach((frameContext) => {
            frameContext.frameComponent.detach();
        });
    }
}

/**
 * The manager for all appContexts.
 * @summary
 * 1, The generator create unique frameId dynamically for each frameContext in the combination forms.
 * 2, Combined form and Host form visit each other by these unique frameIds.
 * 3, Now we make these forms has own appContext, they can't visit each other in old way.
 * 4, For compatible purpose, we collect all appContexts together and search frameContext in these appContexts by unque frameId.
 */
class AppContextManager {
    /**
     * constructor
     */
    constructor() {
        this.appContextSet = new Set();
    }
    /**
     * Register AppContext
     */
    registerAppContext(appContext) {
        this.appContextSet.add(appContext);
    }
    /**
     * Unregister AppContext
     */
    unregisterAppContext(appContext) {
        this.appContextSet.delete(appContext);
    }
    /**
     * Get an array of all AppContexts.
     */
    getAppContexts() {
        return Array.from(this.appContextSet);
    }
}

class ComponentManager {
    constructor(appContext) {
        this.appContext = appContext;
    }
    get(paths) {
        if (!Array.isArray(paths) || paths.length < 1) {
            throw new Error('Argument error !');
        }
        if (!this.appContext || !this.appContext.componentRefs || this.appContext.componentRefs.size < 1) {
            return null;
        }
        const componentRefs = this.appContext.componentRefs;
        let component = componentRefs;
        paths.forEach(path => {
            component = component && component.get(path) || null;
        });
        return component;
    }
    /**
     * 获取指定frame下所有的组件
     * @param frameId
     * @returns
     */
    getComponentsByFrameId(frameId) {
        if (!this.appContext || !this.appContext.componentRefs || this.appContext.componentRefs.size < 1) {
            return null;
        }
        const componentRefs = this.appContext.componentRefs;
        return componentRefs.get(frameId);
    }
}

/**
 * 表单Id
 */
const FORM_ID = new InjectionToken('@farris/devkit FORM_ID');

class DomService {
    constructor() { }
    getElementByBinding(contents, bindingFieldId, parentElement) {
        const controls = [];
        for (const element of contents) {
            // 优先变量数据集合类组件
            if (element.fields) { // 列表
                const childControls = this.getElementByBinding(element.fields, bindingFieldId, element);
                controls.push(...childControls);
            }
            // 其次遍历容器类组件
            else if (element.contents) { // 容器组件
                const childControls = this.getElementByBinding(element.contents, bindingFieldId, element);
                controls.push(...childControls);
            }
            // 再次遍历集合类字段节点
            else if (element.editor) {
                const childControls = this.getElementByBinding([element.editor], bindingFieldId, element);
                controls.push(...childControls);
            }
            // 最后遍历输入类组件
            else if (element.binding && element.binding.field === bindingFieldId) {
                controls.push({
                    element: element,
                    parentElement: parentElement
                });
            }
        }
        return controls;
    }
}

class FormContent {
}
class FormContentForDB {
    constructor(content) {
        this.Id = content.Id;
        this.Code = content.Code;
        this.Name = content.Name;
        this.Contents = JSON.stringify(content.Contents);
    }
}
class FormMetadaDataDom {
}
class FormModule {
}
// export class FormDeclaration {
//     events: Array<any>;
//     commands: Array<any>;
//     states: Array<any>;
// }
class FormOptions {
}

class SchemaService {
    constructor() { }
    /**
     * 根据字段标识数组获取指定字段集合
     * @param fieldIds 字段标识数组
     * @param schema 实体结构
     * @param viewModel 视图模型
     * @returns 已Map形式存储的指定字段字典
     */
    getFieldsByIds(fieldIds, schema, viewModel) {
        const specifiedFieldsMap = new Map();
        const entities = schema.entities;
        if (entities && entities.length && viewModel) {
            const entityPath = viewModel.bindTo;
            const fields = this.getEntityFields(entities, entityPath);
            const fieldsMap = this.flattenFields(fields);
            fieldIds.forEach(fieldId => {
                if (fieldsMap.has(fieldId)) {
                    specifiedFieldsMap.set(fieldId, fieldsMap.get(fieldId));
                }
            });
        }
        return specifiedFieldsMap;
    }
    /**
     * 将字段列表打平为字典结构
     * @param fields 字段属性
     * @param fieldsMap 缺省参数，用来存储字段的Map对象
     * @returns 以Map形式存储的字段字段
     */
    flattenFields(fields, fieldsMap = new Map()) {
        for (const field of fields) {
            fieldsMap.set(field.id, field);
            if (field.type && field.type.fields && field.type.fields.length > 0) {
                this.flattenFields(field.type.fields, fieldsMap);
            }
        }
        return fieldsMap;
    }
    /**
     * 获取表字段列表
     * @param entities 实体对象集合
     * @param entityPath 指定实体路径，根实体路径为'/'
     */
    getEntityFields(entities, entityPath) {
        if (entities && entities.length) {
            const splitIndex = entityPath.indexOf('/');
            if (splitIndex > -1) {
                entityPath = entityPath.slice(splitIndex + 1, entityPath.length);
            }
            // 遍历所有实体，查找匹配指定路径的实体
            for (const entity of entities) {
                if (entityPath === '' || entityPath === entity.code || entityPath === entity.label) {
                    return entity.type.fields;
                }
                else {
                    const fields = this.getEntityFields(entity.type.entities, entityPath);
                    if (fields && fields.length) {
                        return fields;
                    }
                }
            }
        }
        return [];
    }
}

class ContextMetadataBuilder {
    constructor() {
    }
    /**
     * 构造应用程序上下文元数据
     * @param formMetadataContent 表单元数据
     * @param stateMachineMetadata 状态机元数
     * @returns 应用程序上下文元数据
     */
    buildAppContextMetadata(formMetadataContent, stateMachineMetadata) {
        const module = formMetadataContent.module;
        const uiStates = module.states;
        const appContextMetadata = {
            identify: module.code,
            namespace: '',
            stateMachine: this.buildStataMachineMetadata(stateMachineMetadata),
            uiStates: this.buildUiStateMetadata(uiStates)
        };
        return appContextMetadata;
    }
    /**
     * 构造视图上下文元数据
     * @param componentId 组件标识
     * @param viewModel 视图模型元数据
     * @param declarations 外部接口定义
     * @param subscriptions 事件订阅定义
     * @returns 视图上下文元数据
     */
    buildViewContextMetadata(component, viewModel, schema, controllers, dynamicOptions) {
        const contextMetadata = {
            identify: component.id,
            namespace: '',
            commands: this.buildCommand(viewModel.commands),
            commandHandlers: this.buildCommandHandlers(viewModel.commands, controllers),
            commandHandlerExtends: [],
            form: this.buildFormMetadata(viewModel),
            formControls: this.buildFormControlMetadata(viewModel.fields, viewModel, schema, component, dynamicOptions),
            subForms: null,
            uiStates: this.buildUiStateMetadata(viewModel.states),
            bindingTo: viewModel.bindTo,
            viewModelCode: viewModel.code
        };
        return contextMetadata;
    }
    buildCommand(commandMetadataArray) {
        const commands = {};
        commandMetadataArray.reduce((previousValue, commandMetadata) => {
            const ngCommand = {
                name: commandMetadata.code,
                params: {},
                paramDescriptions: {}
            };
            commandMetadata.params.reduce((previousCommand, param) => {
                previousCommand.params[param.name] = param.value;
                previousCommand.paramDescriptions[param.name] = { type: 'string' };
                return previousCommand;
            }, ngCommand);
            previousValue[commandMetadata.code] = ngCommand;
            return previousValue;
        }, commands);
        return commands;
    }
    buildFormMetadata(viewModel) {
        return {
            formGroupName: viewModel.name,
            enableValidate: viewModel.enableValidation
        };
    }
    buildFormControlMetadata(formFields, viewModel, schema, component, dynamicOptions) {
        const formControls = {};
        const formFieldIds = formFields.map(formField => formField.id);
        const schemaService = new SchemaService();
        const formFieldsMap = schemaService.getFieldsByIds(formFieldIds, schema, viewModel);
        const domService = new DomService();
        formFields.reduce((previousValue, field) => {
            const schemaEntityField = formFieldsMap.has(field.id) ? formFieldsMap.get(field.id) : null;
            const binding = schemaEntityField ? schemaEntityField.bindingPath : '';
            const parentElement = {};
            // parentElement 作为引用方式 往外传递
            const domElements = domService.getElementByBinding(component.contents, field.id, parentElement);
            const validRules = [];
            let matchedElement;
            let parentMatchedElement;
            if (domElements && domElements.length >= 1) {
                matchedElement = domElements[0].element;
                parentMatchedElement = domElements[0].parentElement;
                const keys = 'maxValue,minValue,required,require';
                Object.keys(matchedElement).forEach(key => {
                    if (keys.includes(key)) {
                        if (key === 'maxValue' && (matchedElement[key] !== null && matchedElement[key] !== undefined)) {
                            // 把最大值属性转换成validRule
                            validRules.push({ type: 'maxValue', constraints: [matchedElement[key]] });
                        }
                        else if (key === 'minValue' && (matchedElement[key] !== null && matchedElement[key] !== undefined)) {
                            // 把最小值属性转换成validRule
                            validRules.push({ type: 'minValue', constraints: [matchedElement[key]] });
                        }
                        else if (key === 'required' || key === 'require') {
                            // 把必填属性转换成validRule
                            // 必填表达式可以为状态机
                            if (matchedElement[key] === 'true' || matchedElement[key] === true) {
                                validRules.push({ type: 'required', constraints: [true] });
                            }
                        }
                    }
                });
            }
            previousValue[field.fieldName] = {
                /** 控件标识 */
                id: field.fieldName,
                /** 控件名称 todo: 需要支持多语言 */
                name: this.getTitle(matchedElement, parentMatchedElement, field.fieldName),
                /** 绑定字段路径 */
                binding,
                /** 控件值更新时机 */
                updateOn: field.updateOn,
                /** 控件默认名称 */
                defaultI18nValue: this.getTitle(matchedElement, parentMatchedElement, field.fieldName),
                valueChanging: field.valueChanging,
                valueChanged: field.valueChanged,
                valueConverter: this.generateConverter(schemaEntityField, dynamicOptions),
                /** 验证规则 */
                validRules
            };
            return previousValue;
        }, formControls);
        return formControls;
    }
    /**
     * 获取对应的title值
     * @param matchedElement
     * @param defaultValue
     * @returns
     */
    getTitle(matchedElement, parentMatchedElement, defaultValue) {
        if (!matchedElement) {
            return defaultValue;
        }
        if (parentMatchedElement.type == 'GridField') {
            return parentMatchedElement.caption || defaultValue;
        }
        return matchedElement.title || defaultValue;
    }
    /**
     * 构造对应的converter
     * @param field
     * @returns
     */
    generateConverter(field, dynamicOptions) {
        const valueConverterMap = dynamicOptions["valueConverterMap"];
        if (!valueConverterMap || !field) {
            return;
        }
        if (field.type && (field.type.name == 'Date' || field.type.name == 'DateTime') && !field.converter) {
            field.converter = valueConverterMap["Date"];
        }
        if (field.multiLanguage && !field.converter) {
            field.converter = valueConverterMap["MultiLang"];
        }
        return field.converter;
    }
    /**
     * 由状态机元数据创建状态机上下文描述
     * @param stateMachineMetadata 状态机元数据
     * @returns 状态机上下文描述
     */
    buildStataMachineMetadata(stateMachineMetadata) {
        // 声明状态机上下文元数据
        const stateMachine = {
            states: {},
            renderStates: {},
            actions: {}
        };
        if (!stateMachineMetadata) {
            return stateMachine;
        }
        // 由状态机元数据构造NgState
        stateMachineMetadata.state.reduce((previousValue, state) => {
            previousValue.states[state.state] = {
                initialState: state.state === stateMachineMetadata.initialState
            };
            return previousValue;
        }, stateMachine);
        // 由状态机元数据构造NgRenderState
        Object.keys(stateMachineMetadata.renderState)
            .reduce((previousValue, renderStateName) => {
            const renderStateMetadata = stateMachineMetadata.renderState[renderStateName];
            const renderFunction = this.buildRenderFunction(renderStateMetadata);
            previousValue.renderStates[renderStateName] = {
                render: renderFunction
            };
            // previousValue.renderStates[renderStateName] = {
            //   render: (context: StateMachineContext) => {
            //     return context.parser.parse(renderStateMetadata.condition, this);
            //   }
            // };
            return previousValue;
        }, stateMachine);
        // 由状态机元数据构造NgAction
        Object.keys(stateMachineMetadata.action)
            .reduce((previousValue, actionName) => {
            const actionMetadata = stateMachineMetadata.action[actionName];
            previousValue.actions[actionName] = {
                precondition: actionMetadata.precondition,
                transitTo: actionMetadata.transitTo
            };
            return previousValue;
        }, stateMachine);
        // 返回状态机元数据
        return stateMachine;
    }
    buildUiStateMetadata(states) {
        const uiStates = {};
        states.reduce((previousValue, uiState) => {
            previousValue[uiState.code] = {
                stateName: uiState.code
            };
            return previousValue;
        }, uiStates);
        return uiStates;
    }
    buildRenderFunction(renderStateMetadata) {
        if (renderStateMetadata && renderStateMetadata.condition.length) {
            const renderFunctionString = renderStateMetadata.condition.reduce((previousFunctionString, condition) => {
                let conditionTarget = condition.target;
                if (!conditionTarget.startsWith('\'')) {
                    conditionTarget = `'${conditionTarget}`;
                }
                if (!conditionTarget.endsWith('\'')) {
                    conditionTarget = `${conditionTarget}'`;
                }
                let conditionSource = condition.source;
                if (conditionSource.indexOf('\'') < 0) {
                    conditionSource = `'${conditionSource}'`;
                }
                if (conditionSource.indexOf('getUIState') > -1) {
                    conditionSource = conditionSource.replace('getUIState', 'context.getUIState');
                }
                if (conditionSource.indexOf('getData') > -1) {
                    conditionSource = conditionSource.replace('getData', 'context.getData');
                }
                // tslint:disable-next-line: max-line-length
                let functionString = `${condition.lBracket || ''}context.parse(${conditionSource},'source')${condition.compare}${condition.target}${condition.rBracket || ''}`;
                if (condition.relation) {
                    switch (condition.relation.trim().toLocaleLowerCase()) {
                        case 'or':
                            functionString += '||';
                            break;
                        case 'and':
                            functionString += '&&';
                            break;
                    }
                }
                return previousFunctionString + functionString;
            }, '');
            if (renderFunctionString) {
                return new Function('context', `return ${renderFunctionString};`);
            }
        }
        return new Function('context', 'return true;');
    }
    buildCommandHandlers(commandMetadataArray, controllers) {
        const commandHandlers = [];
        commandMetadataArray.reduce((previousValue, commandReference) => {
            const commandName = commandReference.code;
            const controllerId = commandReference.cmpId;
            const controller = controllers[controllerId];
            const method = Object.assign({}, controller.methods[commandReference.handlerName]);
            method.params = method.params && method.params.map(param => Object.assign({}, param));
            if (method.params && method.params.length) {
                commandReference.params.reduce((previousMethodValue, param) => {
                    const methodParam = previousMethodValue.params.find(value => value.name === param.name);
                    if (methodParam) {
                        methodParam.expression = param.value;
                    }
                    return previousMethodValue;
                }, method);
            }
            const commandHandler = new DynamicCommandHandler(commandName, method);
            previousValue.push(commandHandler);
            return previousValue;
        }, commandHandlers);
        return commandHandlers;
    }
}

/**
 * ViewModel管理类
 */
class ViewModelManager {
    /**
     * 构造函数
     */
    constructor() {
        this.viewModelMap = new Map();
    }
    /**
     * 获取ViewModelMap
     */
    getViewModelMap() {
        return this.viewModelMap;
    }
    /**
     * 根据name获取ViewModel
     * @return 找不到时返回undefined
     */
    getViewModelByName(name) {
        return this.viewModelMap.get(name);
    }
    /**
     * 初始化全局的viewModel
     */
    register(name, viewModel) {
        this.viewModelMap.set(name, viewModel);
    }
    /**
     * 是否Repository已经存在
     */
    exsit(name) {
        const viewModel = this.getViewModelByName(name);
        return viewModel ? true : false;
    }
    dispose() {
        this.viewModelMap.clear();
    }
}

/**
 * ContextMetadata管理类
 */
class ContextMetadataManager {
    /**
     * 构造函数
     */
    constructor() {
        this.contextMetadataMap = new Map();
    }
    /**
     * 获取ContextMetadataMap
     */
    getContextMetadataMap() {
        return this.contextMetadataMap;
    }
    /**
     * 根据name获取ContextMetadata
     * @return 找不到时返回undefined
     */
    getContextMetadataByName(name) {
        return this.contextMetadataMap.get(name);
    }
    /**
     * 初始化全局的ContextMetadata
     */
    register(name, contextMetadata) {
        this.contextMetadataMap.set(name, contextMetadata);
    }
    /**
     * ContextMetadata是否已经存在
     */
    exsit(name) {
        const contextMetadata = this.getContextMetadataByName(name);
        return contextMetadata ? true : false;
    }
}

const FRAME_ID = new InjectionToken('@farris/devkit FRAME_ID');
/**
 * 表单命名空间
 */
const NAMESPACE = new InjectionToken('@farris/devkit NAMESPACE');
/**
 * 组件初始化时的处理器
 */
const FRAME_COMPONENT_INIT_HANDLER_TOKEN = new InjectionToken('@farris/frame_component_init_handler_token');

/**
 * 应用上下文
 * @author Witt<jiwt@inspur.com>
 * @todo
 * 1、parnet和AppContextManager是否必要？按理说就是应该隔离上下文，表单之间通过事件通讯进行交互；
 */
class AppContext extends Context {
    /**
     * 构造函数
     */
    constructor(injector, appContextManager, parent) {
        super();
        this.typeName = 'AppContext';
        /**
         * 是否已经销毁
         */
        this.isFormDestoryed = false;
        /**
         * 应用程序标识
         */
        this.applicationId = null;
        this.token = null;
        /**
         * 是否使用独立的eventBus
         * @memberof AppContext
         */
        this.useIsoluteEventBus = false;
        /**
         * 应用上下文元数据描述
         */
        this.metadata = {};
        /**
         * 编辑态时启用表格头
         */
        this.enableGridHeaderWhenEditing = false;
        this.disposed = false;
        this.destorySignal = new Subject();
        this.injector = injector;
        this.appContextManager = appContextManager;
        this.formId = this.injector && this.injector.get(FORM_ID, null) || null;
        // 默认运行模式为兼容模式
        this.runMode = this.injector && this.injector.get(DEVKIT_RUN_MODE, RunMode.compatible) || RunMode.compatible;
        RunModeService.setRunMode(this.runMode);
        this.params.set('formId', this.formId);
        this.params.set('appId', this.ApplicationId);
        this.params.set('token', this.Token);
        // 确定父子关系
        if (!parent) {
            this.parent = null;
            this.root = this;
        }
        else {
            this.parent = parent;
            this.root = parent.root;
        }
        this.registerToManager();
        this.frameContextManager = new FrameContextManager(this);
        this.frameComponentRefresher = new FrameComponentRefresher();
        this.repositoryManager = new RepositoryManager();
        this.bindingDataManager = new BindingDataManager();
        this.changeDetectionController = new ChangeDetectionController(this.frameContextManager);
        this.messagePipe = new Subject();
        this.componentRefs = new Map();
        this.componentManager = new ComponentManager(this);
        this.contextMetadataManager = new ContextMetadataManager();
        this.opened = false;
        // this.sortConditionManager = new SortConditionManager();
        // this.filterConditionManager = new FilterConditionManager();
        this.router = this.injector && this.injector.get(Router);
        this.viewModelManager = new ViewModelManager();
        this.contextMetadataBuilder = new ContextMetadataBuilder();
        this.variableParseService = new VariableParseService([
            new FrameIdVariableParser(),
            new DataVariableParser(),
            new UIStateVariableParser(),
            new StateMachineVariableParser(),
            new CommandVariableParser()
        ]);
    }
    /**
     * 已废弃：请使用FrameContextManager的getFrameContextMap方法代替。
     * @deprecated
     * @summary
     * 已经有运行时直接用中括号访问该属性的场景，虽然是private，但要进行兼容。
     */
    get frameContexts() {
        return this.frameContextManager.getFrameContextMap();
    }
    get formModule() {
        return this.formMetadataContent ? this.formMetadataContent.module : null;
    }
    dispose(options) {
        if (this.disposed) {
            return;
        }
        this.isFormDestoryed = true;
        this.disposed = true;
        this.router = null;
        this.unregisterFromManager();
        this.componentRefs.clear();
        if (this.stateMachine) {
            this.stateMachine.dispose();
            this.stateMachine = null;
        }
        this.frameComponentRefresher.dispose();
        this.frameContextManager.dispose();
        this.repositoryManager.dispose();
        this.viewModelManager.dispose();
        this.bindingDataManager.dispose();
        if (this.messagePipe) {
            this.messagePipe.complete();
            this.messagePipe = null;
        }
        this.injector = null;
        if (this.destorySignal) {
            this.destorySignal.next(options);
            this.destorySignal.complete();
        }
    }
    ngOnDestroy() {
        this.dispose({ opportunity: DestroyOpportunity.AppContextDestroy });
    }
    /**
     * 由表单元数据、状态机元数据、前端构件元数据初始化解析型应用上下文
     * @param formMetadataContent 表单元数据
     * @param stateMachineMetadata 状态机元数据
     * @param controllers 前端构件元数据
     */
    initializeByMetadata(formMetadataContent, stateMachineMetadata, controllers, options) {
        this.metadata = this.contextMetadataBuilder.buildAppContextMetadata(formMetadataContent, stateMachineMetadata);
        if (!this.stateMachine) {
            // 避免由于组合表单，获取到父级状态机实例的问题
            // this.stateMachine = this.injector.get(StateMachine, new StateMachine());
            this.stateMachine = new StateMachine();
        }
        this.formMetadataContent = formMetadataContent;
        this.controllers = controllers;
        this.dynamicOptions = options;
    }
    /**
     * Register current AppContext instance to AppContextManager
     */
    registerToManager() {
        if (!this.appContextManager) {
            return;
        }
        this.appContextManager.registerAppContext(this);
    }
    /**
     * Unregister current AppContext instance from AppContextManager
     */
    unregisterFromManager() {
        if (!this.appContextManager) {
            return;
        }
        this.appContextManager.unregisterAppContext(this);
    }
    /**
     * 注册FrameContext
     */
    regFrameContext(frameContext) {
        const repository = frameContext.repository;
        const repositoryName = repository.name;
        // Repository
        if (this.repositoryManager.ifRepositoryExits(repositoryName) === false) {
            this.repositoryManager.regRepository(repositoryName, repository);
        }
        // BindingData
        if (this.bindingDataManager.ifBindingDataExits(repositoryName) === false) {
            let bindingData = null;
            // 仅高速模式下使用bindingDataManager
            if (this.runMode === RunMode.highSpeed) {
                bindingData = BindingDataFactory.createFromRepository(repository, '/');
                this.bindingDataManager.regBindingData(repositoryName, bindingData);
            }
        }
        // 考虑路由再次进入的时候，AppContext没有被注销，但Component被再次构造的场景
        this.frameContextManager.regFrameContext(frameContext);
    }
    regContextMetadata(componentId, contextMetadata) {
        if (!this.contextMetadataManager.exsit(componentId)) {
            this.contextMetadataManager.register(componentId, contextMetadata);
        }
    }
    /**
     * 获取整个表单的AppContext
     */
    getFormAppContext() {
        return this;
    }
    /**
     * 销毁表单
     * @todo: 临时解决表单关闭后对象没有销毁亦获取不到销毁时机的问题,应依赖angular本身的销毁机制
     */
    destory() {
        this.dispose();
    }
    get isDestoryed() {
        return this.isFormDestoryed;
    }
    /**
     * 应用id
     */
    get ApplicationId() {
        if (!!this.applicationId) {
            return this.applicationId;
        }
        this.applicationId = UID.create();
        return this.applicationId;
    }
    set ApplicationId(appId) {
        this.applicationId = appId;
    }
    get Token() {
        if (!!this.token) {
            return this.token;
        }
        this.token = UID.create();
        return this.token;
    }
    set Token(token) {
        this.token = token;
    }
    // #region 弃用的老方法
    /**
     * 已废弃：请使用FrameComponentRefresher的refreshComponent方法代替。
     * @deprecated
     */
    registerCommandHandler(frameId, component) {
        this.frameComponentRefresher.regFrameComponent(frameId, component);
    }
    /**
     * 已废弃：请使用FrameComponentRefresher的refreshComponent方法代替。
     * @deprecated
     */
    refresh() {
        this.frameComponentRefresher.refreshComponents();
    }
    /**
     * 已废弃：请使用FrameContextManager的getFrameContextById方法代替。
     * @deprecated
     */
    getFrameContext(frameId) {
        return this.frameContextManager.getFrameContextById(frameId);
    }
    getContextById(identify) {
        const context = this.frameContextManager.getFrameContextById(identify);
        return context;
    }
    /**
     * 已废弃：请使用FrameContextManager的getFrameContextMap方法代替。
     * @deprecated
     */
    getAllFrameContexts() {
        return this.frameContextManager.getFrameContextMap();
    }
    /**
     * 处理行变更
     */
    handleSelectChange(change, srcFrameContext) {
        const force = change.force || false;
        this.frameContexts.forEach((targetFrameContext) => {
            // 相同的FrameCotnext或者Repository不一致的情况下，不同步
            if (targetFrameContext === srcFrameContext
                || targetFrameContext.repository !== srcFrameContext.repository) {
                return;
            }
            const bindingData = targetFrameContext.bindingData;
            const bindingList = bindingData.getValue(change.path);
            const currentId = change.value['id'];
            if (bindingList && bindingList.currentId !== currentId || force) {
                // 设置当前行，但不对外广播
                bindingList.setCurrentId(currentId, true, false, force);
            }
        });
    }
    // #endregion
    buildRenderViewContext(componentId) {
        // 提取视图模型集合
        const viewModels = this.formModule.viewmodels;
        // 提取组件描述集合
        const viewComponents = this.formModule.components;
        // 提取schema节点
        const schema = this.formModule.schemas[0];
        // 查找匹配指定标识的组件节点
        const matchedComponent = viewComponents.find(component => component.id === componentId);
        // 匹配指定组件的视图模型节点
        const matchedViewModel = viewModels.find(viewModel => matchedComponent.viewModel === viewModel.id);
        // 查找匹配视图模型的父节点
        const parentViewModel = viewModels.find(viewModel => viewModel.id === matchedViewModel.parent);
        let parentComponentId = '';
        // 如果匹配上上级视图模型，提上级视图标识
        if (parentViewModel) {
            const parentComponent = viewComponents.find(component => component.viewModel === parentViewModel.id);
            if (parentComponent) {
                parentComponentId = parentComponent.id;
            }
        }
        // 如果存在上级组件，提取器上下文对象。
        // const parentViewContext = parentComponentId ? this.getContextById(parentComponentId) : null;
        // this.buildRenderViewContextRecursively(matchedViewModel, parentViewContext, schema);
        this.buildRenderViewContextRecursively(matchedViewModel, schema);
    }
    buildRenderViewContextRecursively(viewModel, schema) {
        const controllers = this.controllers;
        const viewComponents = this.formModule.components;
        const matchedComponent = viewComponents.find(component => component.viewModel === viewModel.id);
        const contextMetadata = this.contextMetadataBuilder.buildViewContextMetadata(matchedComponent, viewModel, schema, controllers, this.dynamicOptions);
        // const commandHandlers: CommandHandler[] = this.buildCommandHandlers(viewModel.commands, controllers);
        // const commandHandlerExtends: CommandHandlerExtender[] = [];
        // const viewContext = new ViewComponentContext();
        //   contextMetadata,
        //   this,
        //   parent,
        //   this.injector
        // );
        // this.regFrameContext(viewContext);
        // viewContext.init();
        const contextMetadataId = (this.namespace ? (this.namespace + '_') : '') + matchedComponent.id;
        contextMetadata.namespace = this.namespace || '';
        this.regContextMetadata(contextMetadataId, contextMetadata);
        const viewModels = this.formModule.viewmodels;
        const subViewModels = viewModels.filter(subViewModel => subViewModel.parent === viewModel.id);
        if (subViewModels && subViewModels.length) {
            subViewModels.forEach(subViewModel => {
                this.buildRenderViewContextRecursively(subViewModel, schema);
            });
        }
    }
    getComponentProviders(componentId) {
        const contextMetadata = this.contextMetadataManager.getContextMetadataByName(componentId);
        const bindingData = new BindingData();
        const form = new Form();
        const namespace = contextMetadata.namespace;
        const repository = this.repository || this.injector.get(Repository, null);
        const stateMachine = this.stateMachine;
        const uiState = new UIState();
        const viewModel = new ViewModel();
        viewModel.setMetadata(contextMetadata);
        return [
            { provide: FRAME_ID, useValue: componentId },
            { provide: NAMESPACE, useValue: namespace },
            { provide: FrameContext, useClass: FrameContext },
            { provide: AppContext, useValue: this },
            { provide: BindingData, useValue: bindingData },
            { provide: Form, useValue: form },
            { provide: Repository, useValue: repository },
            { provide: StateMachine, useValue: stateMachine },
            { provide: UIState, useValue: uiState },
            { provide: ViewModel, useValue: viewModel },
            {
                provide: VariableParseService, useValue: new VariableParseService([
                    new FrameIdVariableParser(),
                    new DataVariableParser(),
                    new UIStateVariableParser(),
                    new StateMachineVariableParser(),
                    new CommandVariableParser()
                ])
            }
        ];
    }
}
AppContext.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AppContext.ctorParameters = () => [
    { type: Injector, decorators: [{ type: Optional }] },
    { type: AppContextManager, decorators: [{ type: Optional }] },
    { type: AppContext, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

/*
 * @Author: Witt
 * @Date: 2018-12-30 17:11:37
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-30 17:19:01
 */
/**
 * FrameContext管理类
 */
class FrameContextManager {
    /**
     * 构造函数
     */
    constructor(appContext) {
        this.frameContextMap = new Map();
        this.frameContextSet = new Set();
        this.appContext = appContext;
    }
    /**
     * 注册FrameContext
     */
    regFrameContext(frameContext) {
        const frameId = frameContext.frameId;
        // 如果存在，先删除
        if (this.frameContextMap.has(frameId) === true) {
            const existedFrameContext = this.frameContextMap.get(frameId);
            this.frameContextMap.delete(frameId);
            this.frameContextSet.delete(existedFrameContext);
        }
        frameContext.index = this.frameContextSet.size;
        this.frameContextMap.set(frameId, frameContext);
        this.frameContextSet.add(frameContext);
    }
    /**
     * 注销组件注册
     */
    unregFrameContext(frameContext) {
        const frameId = frameContext.frameId;
        this.frameContextMap.delete(frameId);
        this.frameContextSet.delete(frameContext);
        // 仅在高速模式下才会在bindingDataManager中注册绑定数据实例
        if (this.appContext.runMode === RunMode.highSpeed) {
            const namespace = frameContext.namespace;
            const repositoryName = frameContext.repository && frameContext.repository.name;
            // 获取ns相同的framecontext，如果已经没有组件上下文了需要销毁bindingData
            const frameContexts = this.getFrameContextsByNamespace(namespace);
            if (!frameContexts || frameContexts.length < 1) {
                this.appContext.bindingDataManager.unRegisteBindingData(repositoryName);
            }
        }
    }
    /**
     * 获取FrameContextMap
     */
    getFrameContextMap() {
        return this.frameContextMap;
    }
    /**
     * 获取全部FrameContext
     */
    getFrameContexts() {
        return Array.from(this.frameContextSet);
    }
    /**
     * 获取组合表单某个表单的所有frameContext
     * @param namespace 命名空间
     */
    getFrameContextsByNamespace(namespace) {
        return Array.from(this.frameContextSet).filter((frameContext) => frameContext && frameContext.namespace === namespace);
    }
    /**
     * 根据id获取FrameContext
     */
    getFrameContextById(frameId) {
        const targetFrameContext = this.frameContextMap.get(frameId);
        if (targetFrameContext) {
            return targetFrameContext;
        }
        return this.getFrameContextFromAllAppContexts(frameId);
    }
    /**
     * Get the root FrameContext instance
     * @return Return the FrameContext instance whose parent is null, and undefined otherwise.
     */
    getRootFrameContext() {
        const frameContexts = this.getFrameContexts();
        const rootFrameContext = frameContexts.find((frameContext) => {
            return frameContext.parent === null;
        });
        return rootFrameContext;
    }
    dispose() {
        this.frameContextMap.clear();
        this.frameContextSet.clear();
    }
    /**
     * 遍历所有的AppContext查找指定的
     * @summary
     * 1、老表单中所有的frameId均不重复；
     * 2、现在隔离了AppContxt，在当前AppContext找不到的时候，查找所有AppContext；
     * 3、隔离后，标准的访问方式是通过事件通信，此处仅仅是临时兼容。
     */
    getFrameContextFromAllAppContexts(frameId) {
        if (!this.appContext.appContextManager) {
            return;
        }
        let targetFrameContext;
        const appContexts = this.appContext.appContextManager.getAppContexts();
        appContexts.some((appContext) => {
            const frameContextMap = appContext.frameContextManager.getFrameContextMap();
            if (frameContextMap.has(frameId) === true) {
                targetFrameContext = frameContextMap.get(frameId);
                return true;
            }
            else {
                return false;
            }
        });
        return targetFrameContext;
    }
}
FrameContextManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrameContextManager.ctorParameters = () => [
    { type: AppContext }
];

/**
 * 应用（表单）上下文
 * ----------------------------------------
 * @todo
 * 1、AppContext与其他组成部分之间应该使用依赖注入；
 * 2、各个Manager之间的依赖应该使用依赖注入处理；
 * 3、由于目前的修改原则是不引起大量的重新编译，只能暂时通过new来实现。
 * ----------------------------------------
 */

class EventBusProxy {
    constructor(eventBus, hostType, eventTokenValueProvider) {
        this.eventBus = eventBus;
        this.hostType = hostType;
        this.eventTokenValueProvider = eventTokenValueProvider;
    }
    post(eventName, data) {
        this.eventBus.post(this.hostType, this.eventTokenValueProvider(), eventName, data);
    }
}

const NG_DECLARATION = 'NgDeclaration';
/**
 * NgDeclaration
 * 公开事件属性装饰器工厂
 */
function NgDeclaration(options) {
    const decoratorFactory = makePropDecorator(NG_DECLARATION, (obj) => obj);
    return decoratorFactory(options);
}

var EventTypeEnum;
(function (EventTypeEnum) {
    EventTypeEnum[EventTypeEnum["COMPONENT"] = 0] = "COMPONENT";
    EventTypeEnum[EventTypeEnum["ROUTE"] = 1] = "ROUTE";
})(EventTypeEnum || (EventTypeEnum = {}));

class Declaration {
    constructor() {
    }
    /**
     * 初始化
     */
    init(frameComponent) {
        if (!frameComponent) {
            return;
        }
        this.bindDeclaration(frameComponent, null);
    }
    /**
     *  依据定义列表进行初始化
     * @param frameComponent 表单component实例
     * @param ngDeclarations 事件定义列表信息
     */
    initWithDeclarations(frameComponent, ngDeclarations) {
        if (!frameComponent) {
            return;
        }
        this.bindDeclaration(frameComponent, null);
    }
    /**
     * 基于事件元数据构建事件
     * 调整访问级别 便于解析表单进行初始化动作
     * @param context 框架上下文
     */
    bindDeclaration(frameComponent, ngDeclarations) {
        const context = frameComponent.context;
        if (!context) {
            return;
        }
        const ngPublicEventProps = ngDeclarations ? ngDeclarations : this.getNgPublicEvent();
        if (!ngPublicEventProps) {
            return;
        }
        Object.keys(ngPublicEventProps).forEach((propertyName) => {
            const ngExportEvent = ngPublicEventProps[propertyName];
            Object.defineProperty(this, propertyName, {
                value: (params) => {
                    // 获取命令处理上下文
                    const targetContext = context;
                    // todo: 给ngExportEvent添加frameId（保证框架之间的事件隔离）
                    // if (ngExportEvent.frameId) {
                    //   targetContext = context.appContext.getFrameContext(ngExportEvent.frameId);
                    // }
                    const root = targetContext.root;
                    const emitter = ngExportEvent.token;
                    const tokenValue = ngExportEvent.token;
                    const eventName = ngExportEvent.name;
                    let eventArgs = JSON.parse(JSON.stringify(ngExportEvent.params));
                    const eventType = ngExportEvent.type;
                    const eventBus = targetContext.eventBus || root.eventBus;
                    if (!eventBus) {
                        return;
                    }
                    const injector = targetContext.injector || root.injector;
                    const variableParseService = injector.get(VariableParseService);
                    // 执行参数解析
                    setTimeout(() => {
                        eventArgs = variableParseService.parse(eventArgs, targetContext, params);
                        const eventSender = targetContext.frameComponent;
                        let currentContext = targetContext;
                        const eventId = new Date().valueOf();
                        if (eventType && eventType === EventTypeEnum.ROUTE) {
                            // 事件依次向上冒泡
                            while (currentContext) {
                                currentContext.eventBus.post(emitter, tokenValue, eventName, eventArgs, eventSender, eventType, eventId);
                                // currentContext = currentContext.parent;
                                currentContext = this.getParentContext(currentContext);
                            }
                        }
                        else {
                            eventBus.post(emitter, tokenValue, eventName, eventArgs, eventSender);
                        }
                    }, 0);
                }
            });
        });
    }
    /**
     * 获取事件定义列表
     * @returns  事件定义
     */
    getNgPublicEvent() {
        return MetadataUtil.getPropsMetadatasByName(this.constructor, NG_DECLARATION);
    }
    /**
     * 获取父Context
     * @param context 当前上下文
     */
    getParentContext(context) {
        // 首先查找直接上级FrameContext
        if (context.parent) {
            return context.parent;
        }
        // 到了AppContext边界，返回上级AppContext的根FrameContext
        const parentAppContext = context.appContext.parent;
        if (parentAppContext) {
            return parentAppContext.frameContextManager.getRootFrameContext();
        }
        return null;
    }
}
Declaration.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Declaration.ctorParameters = () => [];

const NG_SUBSCRIPTION = 'NgSubscription';
class ParamMap {
}
/**
 * NgSubscription
 * 事件订阅属性装饰器工厂
 */
function NgSubscription(options) {
    const decoratorFactory = makePropDecorator(NG_SUBSCRIPTION, (obj) => obj);
    return decoratorFactory(options);
}
function getNgSubscriptionDecoratorFactory() {
    const decoratorFactory = makePropDecorator(NG_SUBSCRIPTION, (obj) => obj);
    return decoratorFactory;
}

class Subscription {
    /**
     * 初始化
     */
    init(frameComponent) {
        if (!frameComponent) {
            return;
        }
        return this.bindSubscription(frameComponent, null);
    }
    /**
     *  根据订阅列表进行初始化
     * @param frameComponent
     * @param ngEvents 订阅列表
     * @returns eventPipes
     */
    initWithSubscriptions(frameComponent, ngEvents) {
        if (!frameComponent) {
            return;
        }
        return this.bindSubscription(frameComponent, ngEvents);
    }
    /**
     * 更改成为public形式 目的为了解析表单可以进行重新绑定
     * @param frameComponent
     * @param ngEvents
     * @returns
     */
    bindSubscription(frameComponent, ngEvents) {
        const context = frameComponent.context;
        if (!context) {
            return;
        }
        const ngEventHandlerProps = ngEvents ? ngEvents : this.getNgEvents(frameComponent);
        if (!ngEventHandlerProps) {
            return;
        }
        const eventPipes = [];
        Object.keys(ngEventHandlerProps).forEach((propertyName) => {
            const ngImportEvent = ngEventHandlerProps[propertyName];
            // 获取待订阅方法详情，尝试执行订阅
            const targetContext = context;
            const receiver = frameComponent;
            const emitter = ngImportEvent.token;
            const tokenValue = ngImportEvent.token;
            const eventName = ngImportEvent.name;
            const paramMapCollection = ngImportEvent.paramMapCollection;
            const eventPipe = targetContext.eventBus.on(emitter, tokenValue, eventName, receiver, (eventArgs) => {
                this.subscriptionHandler(eventArgs, paramMapCollection, targetContext);
                const eventHandler = frameComponent[eventName];
                if (!eventHandler) {
                    return;
                }
                try {
                    eventHandler(receiver, eventArgs);
                }
                catch (_a) {
                    throw new Error('Error invoking method ' + eventName);
                }
            });
            eventPipes.push(eventPipe);
        });
        return eventPipes;
    }
    /**
     * 获取组件订阅列表
     * @param frameComponent 表单component
     * @returns 组件订阅列表信息
     */
    getNgEvents(frameComponent) {
        return MetadataUtil.getPropsMetadatasByName(frameComponent.constructor, NG_SUBSCRIPTION);
    }
    subscriptionHandler(param, paramMapCollection, currentFrameContext) {
        if (!param || !paramMapCollection || paramMapCollection.length <= 0 || !currentFrameContext) {
            return;
        }
        this.paramMap2UiState(param, paramMapCollection, currentFrameContext);
    }
    /**
     * 设置paramMap后，将param映射到UISTATE上
     */
    paramMap2UiState(param, paramMapCollection, currentFrameContext) {
        for (let i = 0; i < paramMapCollection.length; i++) {
            const from$$1 = paramMapCollection[i].from;
            const frameId = paramMapCollection[i].frameId;
            const to = paramMapCollection[i].to;
            if (!from$$1 || !frameId || !to) {
                continue;
            }
            const destContext = this.getFrameContext(frameId, currentFrameContext);
            if (destContext == null) {
                continue;
            }
            this.setUiStateProperty(to, param[from$$1], destContext.uiState);
            // this.setUiStateProperty(to, param[from], currentFrameContext.uiState);
        }
    }
    getFrameContext(targetFrameContextId, currentContext) {
        let destContext = null;
        try {
            destContext = currentContext.appContext.getFrameContext(targetFrameContextId);
        }
        catch (_a) {
            throw new Error('Error in Getting FrameContext');
        }
        return destContext;
    }
    setUiStateProperty(propertyName, propertyValue, uiState) {
        try {
            uiState.setPropertyValue(propertyName, propertyValue);
        }
        catch (_a) {
            throw new Error("Error in Setting Property Value of the current UISTATE" + uiState);
        }
    }
}
Subscription.decorators = [
    { type: Injectable }
];

var EventPipeType;
(function (EventPipeType) {
    EventPipeType[EventPipeType["Compile"] = 0] = "Compile";
    EventPipeType[EventPipeType["Parsing"] = 1] = "Parsing";
})(EventPipeType || (EventPipeType = {}));

class EventPipe {
    constructor(name, tokenValue, emitter, parentEventPipeList) {
        this.name = name;
        this.tokenValue = tokenValue;
        this.emitter = emitter;
        this.parentEventPipeList = parentEventPipeList;
        this.lastEventId = -1;
        /**
         * EventPipe类型，编译类型表单检查是否在同一上下文中，解析类型表单不判断
         */
        this.eventPipeType = EventPipeType.Compile;
        this.eventSubject = new Subject();
        this.subscriptionMap = new Map();
        this.onceSubscriptionMap = new Map();
        if (this.parentEventPipeList) {
            this.parentEventPipeList.push(this);
        }
    }
    get subscriptions() {
        return this.subscriptionMap;
    }
    /**
     * 发送事件
     */
    post(args, sender, eventType, eventId) {
        const eventData = {
            args: args,
            sender: sender,
            eventType,
            eventId
        };
        this.eventSubject.next(eventData);
    }
    /**
     * 订阅事件
     */
    subscribe(eventHandler, receiver) {
        // 对于弹窗，caller是弹窗中的组件，每次caller不同，但还是会重复注册。
        // 重复订阅检测
        const subscriptionInMap = this.subscriptionMap.get(receiver);
        if (subscriptionInMap != null) {
            subscriptionInMap.unsubscribe();
            this.subscriptionMap.delete(receiver);
        }
        const subscription = this.eventSubject.subscribe((eventData) => {
            const args = eventData.args;
            const sender = eventData.sender;
            const eventType = eventData.eventType || null;
            const eventId = eventData.eventId || 0;
            if (this.lastEventId >= eventId) {
                return;
            }
            this.lastEventId = eventId;
            // 判断sender和receiver的关系，如果在同一个AppContext或者在在一棵树上，则处理
            // 该判断主要解决SPA模式下，一个页面被打开多次的场景。
            if (!(eventType === EventTypeEnum.ROUTE)) {
                if (this.isInSampeScope(sender, receiver) === false) {
                    return;
                }
            }
            eventHandler.call(receiver, args);
        });
        this.subscriptionMap.set(receiver, subscription);
        return this;
    }
    subscribeOnce(eventHandler, caller) {
        const subscription = this.eventSubject.subscribe((value) => eventHandler.call(caller, value));
        this.onceSubscriptionMap.set(caller, subscription);
        return this;
    }
    unSubscribe(subscriber) {
        let subscription = this.subscriptionMap.get(subscriber);
        if (subscription) {
            subscription.unsubscribe();
            subscription = null;
            this.subscriptionMap.delete(subscriber);
        }
        else {
            subscription = this.onceSubscriptionMap.get(subscriber);
            if (subscription) {
                subscription.unsubscribe();
                subscription = null;
                this.onceSubscriptionMap.delete(subscriber);
            }
        }
    }
    // 注销使用once方法注册的订阅。
    unSubscribeForOnce() {
        for (const subscriber of Array.from(this.onceSubscriptionMap.keys())) {
            this.unSubscribe(subscriber);
        }
    }
    matchEmitterToken(emitter, tokenValue) {
        if (this.emitter && emitter && this.emitter !== emitter) {
            return false;
        }
        if (this.tokenValue && tokenValue && this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    }
    examByTargetToken(target, tokenValue) {
        if (this.emitter !== target) {
            return false;
        }
        if (this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    }
    dispose(subscriber) {
        this.unSubscribe(subscriber);
        if (this.subscriptionMap.size === 0 && this.parentEventPipeList) {
            const location = this.parentEventPipeList.findIndex(item => item === this);
            if (location !== -1) {
                this.parentEventPipeList.splice(location, 1);
            }
        }
    }
    /**
     * 根据caller进行注销
     */
    disposeByCaller(caller) {
        const subscriptionInMap = this.subscriptionMap.get(caller);
        if (subscriptionInMap != null) {
            subscriptionInMap.unsubscribe();
            this.subscriptionMap.delete(caller);
        }
    }
    /**
     * 检查是否在同一个上下文中
     * @todo
     * 1、强识别了sender和receiver的结构来判断，不合理；
     * 2、应该声明一个接口来约束结构。
     */
    isInSampeScope(sender, receiver) {
        // 用来区分编译类型的表单，还是解析类型的表单
        if (this.eventPipeType === EventPipeType.Parsing) {
            return true;
        }
        // 兼容老代码，sender不存在时，不进行检测
        if (!sender) {
            return true;
        }
        // 异常处理场景
        if (sender === receiver) {
            return true;
        }
        // 判断是否是FrameContext
        if (!sender.context || !sender.context.appContext ||
            !receiver.context || !receiver.context.appContext) {
            return false;
        }
        const senderAppContext = sender.context.appContext;
        const receiverAppContext = receiver.context.appContext;
        // 情况1：现状
        // 对于老表单，在模块上注入了一个AppContext；
        // 组合表单中主表单的root-component（被组合的表单的root-componetn上没有注入）上注入了AppContext
        // SPA模式下，如法通过Root AppContext区分，是不是同一个菜单内的事件；
        // 只能判断根组件上的AppContext来判断
        // 判断根AppContext是否一致
        if (senderAppContext === receiverAppContext) {
            return true;
        }
        // 情况2：注入改造后
        // 如果以后注入关系改造了，模块上的AppContext移除掉
        // 组合表单中每个root-component都拥有一个AppContext;
        // 组合表单中主表单的root-component的AppContext为Root AppContext
        // if (senderAppContext.root === receiverAppContext.root) {
        //   return true;
        // }
        // 情况3：注入改造后老表单兼容
        // 如果以后注入关系改造了，但产品部没有重新编译;
        // 和情况2类似，不同的是模块上还遗留了一个AppContext；
        // 此时Root Appcontext还是模块上的，如何来判断？
        // 1、考虑通过sender的injector一直网上找，找到模块之前的那个组件injector，从其中拿AppContext来判断；
        // 2、找一个全部重新编译的时机再改造。
        if ((senderAppContext.useIsoluteEventBus && senderAppContext.isoluteEventBus) ||
            (receiverAppContext.useIsoluteEventBus && receiverAppContext.isoluteEventBus)) {
            // 如果存在独立加载js  那么
            return true;
        }
        return false;
    }
}

class EventBus {
    constructor() {
        this.proxyMap = new Map();
        this.eventMap = new Map();
    }
    getProxy(ownerType, eventTokenValueProvider) {
        const ownerName = ownerType.constructor.typeName || ownerType.constructor.name;
        if (!this.proxyMap.has(ownerName)) {
            this.proxyMap.set(ownerName, new EventBusProxy(this, ownerType, eventTokenValueProvider));
        }
        return this.proxyMap.get(ownerName);
    }
    /**
     * 发送事件，通知订阅者接收消息。
     */
    // tslint:disable-next-line: max-line-length
    post(emitterType, tokenValue, eventName, eventArgs, sender, eventType, eventId) {
        const eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            return;
        }
        if (!emitterType) {
            console.error('post方法的参数emitterType不能为空。');
            return;
        }
        let emitter;
        if (emitterType instanceof Type) {
            emitter = emitterType.typeName || emitterType.name;
        }
        else {
            emitter = emitterType;
        }
        if (typeof eventId === 'undefined') {
            eventId = new Date().valueOf();
        }
        for (const eventPipe of eventPipeList) {
            if (eventPipe.matchEmitterToken(emitter, tokenValue)) {
                eventPipe.post(eventArgs, sender, eventType, eventId);
                eventPipe.unSubscribeForOnce();
            }
        }
    }
    /**
     * 订阅事件
     */
    on(target, tokenValue, eventName, caller, handler) {
        return this.getEventPipe(eventName, target, tokenValue).subscribe(handler, caller);
    }
    /**
     * 注销监听
     * @param target
     * @param tokenValue
     * @param eventName
     * @param caller
     */
    off(target, tokenValue, eventName, caller) {
        const eventPipeList = this.eventMap.get(eventName);
        if (eventPipeList) {
            const index = eventPipeList.findIndex((eventPipe) => {
                if (eventPipe.subscriptions.get(caller)) {
                    return eventPipe.name === eventName && eventPipe.tokenValue === tokenValue && eventPipe.emitter === target;
                }
                return false;
            });
            if (index !== -1) {
                eventPipeList.splice(index, 1);
            }
        }
    }
    /**
     * 订阅一次。接收到一次消息之后自动取消订阅
     */
    once(target, tokenValue, eventName, caller, handler) {
        return this.getEventPipe(eventName, target, tokenValue).subscribeOnce(handler, caller);
    }
    /**
     * 发送一个请求事件，获取监听者的响应并处理
     */
    requestFor(target, tokenValue, requestName, requestValue, success, fail) {
        const eventPipe = this.findExistEventPipe(requestName, 'RequestSubject', tokenValue);
        if (eventPipe) {
            this.once(target, tokenValue, requestName, this, (response) => {
                if (response.status === 'success') {
                    success(response.data);
                }
                else {
                    if (fail) {
                        fail('No target responser listening');
                    }
                }
            });
            eventPipe.post({ target: target, token: tokenValue, data: requestValue });
        }
        else {
            if (fail) {
                fail('No target responser listening.');
            }
        }
    }
    /**
     * 监听一个请求事件，给出响应
     */
    responseOn(responseSubject, requestName, callback) {
        this.on('RequestSubject', null, requestName, this, (requestObj) => {
            const response = { status: 'fail', data: null };
            if (responseSubject === requestObj.target) {
                response.data = callback(requestObj.data);
                response.status = 'success';
            }
            this.post(requestObj.target, requestObj.token, requestName, response);
        });
    }
    getEventPipe(eventName, target, tokenValue) {
        let eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            eventPipeList = new Array();
            this.eventMap.set(eventName, eventPipeList);
        }
        // 1、一个事件不允许多个订阅
        // let eventPipe = eventPipeList.find(item => item.examByTargetToken(target, tokenValue));
        // if (!eventPipe) {
        //   eventPipe = new EventPipe(eventName, tokenValue, target, eventPipeList);
        // }
        // 2、一个事件允许多个订阅
        const eventPipe = new EventPipe(eventName, tokenValue, target, eventPipeList);
        return eventPipe;
    }
    findExistEventPipe(eventName, target, tokenValue) {
        const eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            return null;
        }
        // return eventPipeList.find(item => item.examByTargetToken(target, tokenValue));
        for (const eventPipe of eventPipeList) {
            if (eventPipe.matchEmitterToken(target, tokenValue)) {
                return eventPipe;
            }
        }
        return null;
    }
}
EventBus.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EventBus.ctorParameters = () => [];
class EventCache {
    static setToken(key, value) {
        EventCache.tokens.set(key, value);
    }
    static getToken(key) {
        return EventCache.tokens.get(key);
    }
}
EventCache.tokens = new Map();

/*
 * @Author: aalizzwell
 * @Date: 2019-05-30 11:08:18
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-06-01 17:10:04
 */
const EXCEPTION_HANDLER = new InjectionToken('@farris/devkit ExceptionHandler');

const UserSettingsToken = new InjectionToken('@farris/devkit UserSettingsToken');

// tslint:disable-next-line: no-namespace
var Expression$1;
(function (Expression$$1) {
    /**
     * 表达式绑定字段类型（表达式绑定到实体、UIState?）
     */
    let ExpressionBindingType;
    (function (ExpressionBindingType) {
        ExpressionBindingType["State"] = "State";
        ExpressionBindingType["Field"] = "Field";
    })(ExpressionBindingType = Expression$$1.ExpressionBindingType || (Expression$$1.ExpressionBindingType = {}));
    /**
     * 表达式类型
     */
    let ExpressionType;
    (function (ExpressionType) {
        /**
         * 必填表达式
         */
        ExpressionType["Required"] = "require";
        /**
         * 只读表达式
         */
        ExpressionType["Readonly"] = "readonly";
        /**
         * 计算表达式
         */
        ExpressionType["Compute"] = "compute";
        /**
         * 依赖表达式
         */
        ExpressionType["Dependency"] = "dependency";
        /**
         * 是否可见
         */
        ExpressionType["Visible"] = "visible";
        /**
         * 关联表达式
         */
        ExpressionType["Relative"] = "relative";
        /**
         * 校验表达式
         */
        ExpressionType["Validate"] = "validate";
        /**
         * 帮助前
         */
        ExpressionType["DataPicking"] = "dataPicking";
    })(ExpressionType = Expression$$1.ExpressionType || (Expression$$1.ExpressionType = {}));
    /**
     * 事件类型
     */
    let EventType;
    (function (EventType) {
        EventType["ValueChanged"] = "VALUE_CHANGED";
        EventType["SelectionChanged"] = "SELECTION_CHANGED";
        EventType["Load"] = "Load";
        EventType["Append"] = "Append";
        EventType["Remove"] = "Remove";
        EventType["Update"] = "Update";
    })(EventType = Expression$$1.EventType || (Expression$$1.EventType = {}));
    let EventSource;
    (function (EventSource) {
        EventSource["Field"] = "Field";
        EventSource["State"] = "State";
        EventSource["BindingData"] = "BindingData";
        EventSource["Repository"] = "Repository";
    })(EventSource = Expression$$1.EventSource || (Expression$$1.EventSource = {}));
    let MessageType;
    (function (MessageType) {
        MessageType["error"] = "error";
        MessageType["info"] = "info";
        MessageType["warning"] = "warning";
    })(MessageType = Expression$$1.MessageType || (Expression$$1.MessageType = {}));
    let EffectPath;
    (function (EffectPath) {
        EffectPath[EffectPath["currentRow"] = 0] = "currentRow";
    })(EffectPath = Expression$$1.EffectPath || (Expression$$1.EffectPath = {}));
    Expression$$1.MESSAGE = {
        'zh-CHS': {
            require: `请输入'$property'`,
            validate: `'$property'校验不通过`,
            dataPicking: '帮助前表达式校验不通过'
        },
        en: {
            require: `Please input '$property'`,
            validate: `'$property' calibration failed`,
            dataPicking: 'Failed to verify the expression before help'
        },
        'zh-CHT': {
            require: `請輸入'$property'`,
            validate: `'$property'校驗不通過`,
            dataPicking: '幫助前表達式校驗不通過'
        }
    };
    Expression$$1.DEPENDENCY_SPLITER = '/';
})(Expression$1 || (Expression$1 = {}));

const FORM_MANIFEST_SERVICE_TOKEN = new InjectionToken('@farris/form_manifest_service');
const FORM_EXPRESSION_MANIFEST_SERVICE_TOKEN = new InjectionToken('@farris/form_expression_manifest_service');

class ExpressionRegistry {
    constructor(injector, formExpressionManifestService, translate) {
        this.injector = injector;
        this.formExpressionManifestService = formExpressionManifestService;
        this.translate = translate;
        this._expressions = null;
    }
    /**
     * 加载表达式文件
     */
    load() {
        return this.formExpressionManifestService.load().pipe(switchMap((describe) => {
            const expressions = [];
            const exprs = Array.from(describe);
            exprs.forEach((expr) => {
                expr.expressions.forEach((expression) => {
                    const expressionObject = {
                        id: expression.id,
                        ns: expr.ns,
                        path: expr.path,
                        bindingType: expr.type,
                        type: expression.type,
                        expression: expression.value || expression.expr || '',
                        message: expression.message || null,
                        messageType: expression.messageType || null,
                        deps: []
                    };
                    if ((expression.type === Expression$1.ExpressionType.Required || expression.type === Expression$1.ExpressionType.Validate || expression.type === Expression$1.ExpressionType.DataPicking)) {
                        if (!expression.message) {
                            expressionObject.message = this.getExpressionMessage(expression.type);
                        }
                        if (!expression.messageType) {
                            expressionObject.messageType = 'error';
                        }
                    }
                    if (expressionObject.message) {
                        this.transform(expressionObject);
                    }
                    expressions.push(expressionObject);
                });
            });
            this._expressions = expressions;
            this.cleanSpecialCharacters();
            return of(expressions);
        }), catchError((e) => {
            return of([]);
        }));
    }
    /**
     * 获取所有表达式
     */
    get expressions() {
        if (this._expressions) {
            return of(this._expressions);
        }
        return this.load();
    }
    /**
     * 根据表达式id获取对应的表达式对象
     * @param id 表达式id
     * @returns
     */
    getExpressionById(id) {
        if (!this._expressions || this._expressions.length < 1) {
            return null;
        }
        return this._expressions.find((expressionObject) => expressionObject.id === id);
    }
    getExpressionMessage(expressionType, defaultValue) {
        if (!(expressionType === Expression$1.ExpressionType.Validate || expressionType === Expression$1.ExpressionType.Required || expressionType === Expression$1.ExpressionType.DataPicking)) {
            return null;
        }
        if (!this.translate) {
            return defaultValue;
        }
        const currentLanguage = this.translate.getCurrentLanguage() || 'zh-CHS';
        return Expression$1.MESSAGE[currentLanguage][expressionType];
    }
    transform(expressionObject) {
        if (!this.translate) {
            return;
        }
        if (expressionObject.message && expressionObject.message.startsWith('{{') && expressionObject.message.endsWith('}}')) {
            expressionObject.message = this.translate.transform(expressionObject.message.substr(2, expressionObject.message.length - 4), null) || this.getExpressionMessage(expressionObject.type);
        }
    }
    cleanSpecialCharacters() {
        if (!this._expressions || this._expressions.length < 1 || !Array.isArray(this._expressions)) {
            return;
        }
        const repository = this.injector.get(Repository, null);
        if (!repository) {
            return;
        }
        const entityTypeInfo = repository.entityTypeInfo;
        const regex = new RegExp(`[\\'\\"]?\\s*(${entityTypeInfo.entityInfo.nodeCode}|${entityTypeInfo.entityInfo.originalCode})[\\.\\[\\]a-zA-Z0-9_]+\\s*[\\'\\"]?`, 'g');
        this._expressions.forEach((expressionObject) => {
            const expr = expressionObject.expression;
            const entityPropertyExpressions = expr.match(regex);
            if (Array.isArray(entityPropertyExpressions) && entityPropertyExpressions.length > 0) {
                // 解析出所有实体相关的字符串，以主实体名字开头，包含主实体属性或子表
                entityPropertyExpressions.forEach((item) => {
                    if (item.indexOf('.') === -1) {
                        return;
                    }
                    // 去数组
                    if (/\[\d\]/g.test(item)) {
                        const replacer = item.replace(/\[\d\]/g, '');
                        expressionObject.expression = this.replaceAll(expressionObject.expression, item, replacer);
                    }
                    // 去星号
                    if (/\*/g.test(item)) {
                        const replacer = item.replace(/\*/g, '');
                        expressionObject.expression = this.replaceAll(expressionObject.expression, item, replacer);
                    }
                });
            }
        });
    }
    replaceAll(originalValue, search, replacer) {
        return originalValue.split(search).join(replacer);
    }
}
ExpressionRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExpressionRegistry.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [FORM_EXPRESSION_MANIFEST_SERVICE_TOKEN,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TranslateToken,] }] }
];

const LISTENER_TOKEN = new InjectionToken('@Farris listener');

/**
 * 变更监听器
 */
class ChangeListener {
    constructor() {
        this.subject = new Subject();
    }
    get onEvent() {
        return this.subject;
    }
    /**
     * 找到元数据中所有实体路径
     * @param dataTypeInfo
     * @param results
     * @param paths
     */
    findEntityPaths(dataTypeInfo, results, paths = []) {
        const list = dataTypeInfo.getPropInfosByGroup(DataPropGroup.List);
        if (list && list.length > 0) {
            list.forEach((dataPropInfo) => {
                paths.push(dataPropInfo.name);
                const childrens = dataPropInfo.typeInfo.getPropInfosByGroup(DataPropGroup.List);
                if (childrens && childrens.length > 0) {
                    childrens.forEach((dataPropInfo) => {
                        this.findEntityPaths(dataPropInfo.typeInfo, results, paths);
                    });
                }
                else {
                    results.push(paths);
                }
            });
        }
        else if (paths && paths.length > 0) {
            results.push(paths);
        }
    }
}

class ExpressionExecutor {
    /**
     * 编译执行
     * @param expression
     * @param context
     * @returns
     */
    compile(expressionObject, context) {
        if (Object.prototype.toString.call(context) !== '[object Object]') {
            throw new Error('上下文必须为对象！');
        }
        const expressionContext = this.buildContext(context);
        if (!expressionObject.factory) {
            const expression = new Expression(expressionObject.expression, expressionContext);
            expressionObject.factory = expression.compile();
        }
        const expression = expressionObject.factory;
        return expression.eval(expressionContext);
    }
    /**
     * 解析
     * @param expression
     * @param context
     * @returns
     */
    eval(expression, context) {
        if (Object.prototype.toString.call(context) !== '[object Object]') {
            throw new Error('上下文必须为对象！');
        }
        const expressionContext = this.buildContext(context);
        const expressionEngine = new ExpressionEngine(expressionContext);
        return expressionEngine.eval(expression);
    }
    /**
     * 构造表达式上下文
     * @param context
     * @returns
     */
    buildContext(context) {
        const expressionContext = new ExpressionContext();
        if (context && Object.keys(context).length > 0) {
            Object.keys(context).forEach((key) => {
                expressionContext.set(key, context[key]);
            });
        }
        return expressionContext;
    }
}
ExpressionExecutor.decorators = [
    { type: Injectable }
];

/**
 * 表达式计算结果
 */
class ExpressionResult {
    constructor(injector) {
        this.injector = injector;
    }
    /**
     * 更新表达式的值
     * @param expressionId 表达式id
     * @param result
     */
    set(expressionId, result) {
        this[expressionId] = result;
    }
}
ExpressionResult.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExpressionResult.ctorParameters = () => [
    { type: Injector }
];

class ExpressionManager {
    constructor(injector, resolveService, expressionExecutor, expressionRegistry, expressionResult, messageService, notifyService) {
        this.injector = injector;
        this.resolveService = resolveService;
        this.expressionExecutor = expressionExecutor;
        this.expressionRegistry = expressionRegistry;
        this.expressionResult = expressionResult;
        this.messageService = messageService;
        this.notifyService = notifyService;
        this.frameContext = null;
        this.frameContext = this.injector.get(FrameContext, null);
    }
    /**
     * 根据表达式id进行计算
     * @param expressionId 表达式id
     * @param viewModel viewModel
     * @param rowData rowData
     * @returns
     */
    eval(expressionId, viewModel, rowData) {
        const expressionObject = this.expressionRegistry.getExpressionById(expressionId);
        if (expressionObject) {
            const customContext = {};
            const bindingPath = viewModel && viewModel.bindingPath || null;
            if (bindingPath && rowData) {
                const bindingPaths = bindingPath.split('/').filter(p => p);
                const bindingList = this.frameContext.bindingData.getValue(bindingPaths);
                let primaryKey = 'id';
                if (bindingList) {
                    primaryKey = bindingList.primaryKey;
                }
                const primaryValue = rowData[primaryKey] || bindingList.currentId;
                if (primaryValue) {
                    customContext.currentRows = [{ bindingPath: bindingPaths.join('/'), primaryValue }];
                }
            }
            let result = this.execute(expressionObject.expression, customContext);
            if (expressionObject.type === Expression$1.ExpressionType.Readonly || expressionObject.type === Expression$1.ExpressionType.Required || expressionObject.type === Expression$1.ExpressionType.Visible) {
                result = result === true ? true : false;
            }
            this.expressionResult.set(expressionId, result);
            return result;
        }
        return undefined;
    }
    validate(expressionId, options) {
        const expressionObject = this.expressionRegistry.getExpressionById(expressionId);
        if (expressionObject) {
            const patch = options && options.patch || null;
            const customContext = {};
            if (patch) {
                customContext.patch = patch;
            }
            const currentRow = options.currentRow || null;
            const currentRows = options.currentRows || [];
            if (currentRow) {
                customContext.currentRows = customContext.currentRows || [];
                customContext.currentRows.push(currentRow);
            }
            if (currentRows && currentRows.length > 0) {
                customContext.currentRows = customContext.currentRows || [];
                Array.prototype.push.apply(customContext.currentRows, currentRows);
            }
            const result = this.execute(expressionObject.expression, customContext);
            this.expressionResult.set(expressionId, result);
            return result;
        }
        return undefined;
    }
    /**
     * 帮助前封装
     * @param event
     */
    onDataPicking(configs) {
        const expressionId = configs && configs.expressionId || null;
        if (!expressionId) {
            return of(true);
        }
        const result = this.eval(expressionId);
        if (!result) {
            const expressionObject = this.expressionRegistry.getExpressionById(expressionId);
            if (!expressionObject) {
                return of(true);
            }
            const messageType = expressionObject.messageType || Expression$1.MessageType.warning;
            const message = expressionObject.message;
            if (message) {
                this.notifyService[messageType](message, { hideTitle: true });
            }
            return EMPTY;
        }
        return of(result);
    }
    /**
     * 执行表达式计算
     * @param expression 表达式
     * @param customContext 自定义上下文
     * @returns
     */
    execute(expression, customContext) {
        const deps = this.resolveService.resolve(expression);
        const groupDependencies = ExpressionUtil.getGroupFunctionDependency(expression, this.frameContext.repository.entityTypeInfo);
        const entityContext = this.buildEntityContext(deps, groupDependencies, customContext);
        const stateContext = this.buildStateContext();
        const data = customContext && customContext.contexts || null;
        const translate = this.injector.get(TranslateToken, null);
        const context = Object.assign({ [this.entityOriginalNodeCode]: entityContext }, stateContext, { BigNumber, frameContext: this.frameContext, bindingData: this.frameContext.bindingData, repository: this.frameContext.repository, CurrentLanguage: translate.getCurrentLanguage() || 'zh-CHS' }, data);
        if (!entityContext) {
            return undefined;
        }
        return this.expressionExecutor.eval(expression, context);
    }
    /**
     * 执行表达式（返回可观察对象）
     * @param expression 表达式
     * @param customContext 自定义上下文
     * @returns
     */
    executeAsync(expression, customContext) {
        const result = this.execute(expression, customContext);
        return of(result);
    }
    /**
     * 构造实体上下文
     * @param deps
     * @param groupDependencies
     * @param context
     * @returns
     */
    buildEntityContext(deps, groupDependencies, context) {
        const currentRows = context && context.currentRows || null;
        const index = deps.findIndex((dep) => {
            const isEntityDependency = this.isEntityDependency(dep);
            // 如果依赖的是state，无需处理，现在需要确定的是返回多少实体的问题，和state没有关系
            // 表达式依赖了实体
            if (isEntityDependency) {
                const isGroupDependency = groupDependencies.findIndex(item => item === dep) !== -1;
                // 是聚合依赖
                if (isGroupDependency) {
                    const dependencyLength = dep.split('/').filter(p => p).length - 1;
                    if (dependencyLength === 1) {
                        // 聚合了主表字段，所有主表数据都需要参与运算，此时已经确定计算的实体上下文了。
                        return true;
                    }
                    else {
                        // 聚合了子表字段，只需要传递当前实体
                        return false;
                    }
                }
                else {
                    // 当前依赖不是聚合，只需要传递当前实体
                    return false;
                }
            }
            return false;
        });
        const isGroupdMainEntity = index !== -1;
        const options = {};
        if (currentRows && currentRows.length > 0) {
            currentRows.forEach((currentRow) => {
                options[currentRow.bindingPath || '/'] = currentRow.primaryValue;
            });
        }
        const entity = this.getEntity(options);
        const patch = context && context.patch || null;
        if (!entity) {
            return {};
        }
        if (patch && Object.keys(patch).length > 0) {
            Object.keys(patch).forEach((key) => {
                const paths = key.split('/').filter(p => p);
                const value = patch[key];
                this.setValue(entity, paths, value);
            });
        }
        if (isGroupdMainEntity) {
            const collection = this.frameContext.repository.entityCollection.toJSON();
            entity['__type__'] = 'List';
            entity['__items__'] = collection;
        }
        return entity;
    }
    setValue(target, paths, value) {
        if (paths.length === 1) {
            target[paths[0]] = value;
        }
        else {
            const propertyName = paths.pop();
            const result = paths.reduce((object, path) => {
                return object && object[path];
            }, target);
            result[propertyName] = value;
        }
    }
    /**
     * 是否为实体依赖
     * @param dep
     * @returns
     */
    isEntityDependency(dep) {
        return dep.startsWith(ENTITY_TEMPLATE);
    }
    /**
     * 获取实体
     * @param options
     * @returns
     */
    getEntity(options) {
        const entityTypeInfo = this.frameContext.repository.entityTypeInfo;
        const bindingData = this.frameContext.bindingData;
        const childrenEntityPaths = [];
        let entity = null;
        if (options['/']) {
            // 修正主表
            entity = this.frameContext.bindingData.list.findById(options['/']);
            if (entity) {
                entity = entity.toJSON();
            }
        }
        else {
            entity = this.frameContext.bindingData.list.currentItem.toJSON();
        }
        if (!entity) {
            return null;
        }
        ExpressionUtil.getChildrenEntityPaths(entityTypeInfo, childrenEntityPaths);
        entity['__type__'] = 'Entity';
        if (!childrenEntityPaths || childrenEntityPaths.length < 1) {
            return entity;
        }
        // 找到所有子表
        childrenEntityPaths.forEach((paths) => {
            let row = null;
            if (options && options[paths.join('/')]) {
                const parentPaths = paths.slice(0, 1);
                if (paths.length == 2 && options[parentPaths.join('/')]) {
                    const parentRow = options[parentPaths.join('/')];
                    // 从从表
                    // 需要切换上级表
                    row = this.getPropertyValue(entity, parentPaths.concat([parentRow, paths[1], options[paths.join('/')]]));
                }
                else {
                    // 不应该使用bindingData，这样就默认使用了当前行
                    const bindingList = bindingData.getValue(paths);
                    const currentRowId = options[paths.join('/')];
                    let currentRow = null;
                    if (currentRowId !== bindingList.currentId) {
                        currentRow = bindingList.findById(currentRowId);
                    }
                    else {
                        currentRow = bindingList.currentItem;
                    }
                    if (currentRow && currentRow.primaryKeyValue) {
                        row = currentRow.toJSON();
                    }
                }
            }
            else {
                // 如果上级表已经切换了当前行，那么下级表也应该切换
                const parentTableCurrentRowChanged = options && !!Object.keys(options).find(path => {
                    const fullPath = path.split('/').join('/');
                    return paths.join('/').startsWith(fullPath);
                }) || false;
                if (parentTableCurrentRowChanged) {
                    const primaryValue = options && options['/'] || bindingData.list.currentId;
                    const entity = this.frameContext.repository.entityCollection.getEntityById(primaryValue);
                    const fullPaths = [];
                    const data = paths.reduce((object, path) => {
                        fullPaths.push(path);
                        const item = object && object[path];
                        if (item) {
                            const currentRowId = options && options[fullPaths.join('/')] || item.items[0] && item.items[0].primaryValue || null;
                            if (currentRowId) {
                                const currentRow = item.get(currentRowId);
                                return currentRow || null;
                            }
                        }
                        return null;
                    }, entity);
                    if (data) {
                        row = data.toJSON();
                    }
                    else {
                        row = {};
                    }
                }
                else {
                    row = ExpressionUtil.getCurrentRowByPaths(paths, bindingData);
                }
            }
            const propertyName = paths.pop();
            let parent = paths.reduce((object, path) => {
                return object && object[path] || null;
            }, entity);
            const list = parent[propertyName];
            const node = Object.assign({ __items__: [] }, row && row || {}, { __type__: 'List' });
            node.length = () => node.__items__.length;
            if (list && Array.isArray(list)) {
                node.__items__ = [].concat(list);
            }
            parent[propertyName] = node;
        });
        return entity;
    }
    getPropertyValue(entity, paths) {
        return paths.reduce((object, path) => {
            if (object['__type__'] === 'List') {
                return object['__items__'].find(item => item.id === path);
            }
            else if (Array.isArray(object)) {
                return object.find(item => item.id === path);
            }
            else {
                return object && object[path];
            }
        }, entity);
    }
    /**
     * 获取主实体原始字段名
     */
    get entityOriginalNodeCode() {
        const repository = this.injector.get(Repository);
        return repository && repository.entityTypeInfo && repository.entityTypeInfo.entityInfo && repository.entityTypeInfo.entityInfo.originalCode || null;
    }
    /**
     * 构造变量上下文
     * @param event
     * @returns
     */
    buildStateContext() {
        const result = {};
        if (this.frameContext) {
            const rootFrameContext = this.frameContext.getVirtualRootFrameContext();
            if (rootFrameContext) {
                const uiState = rootFrameContext.viewModel.uiState;
                const propertyNames = Object.getOwnPropertyNames(uiState) || [];
                propertyNames.forEach((prop) => {
                    if (prop.match(/^[a-zA-Z0-9_\$]+$/g) !== null) {
                        result[prop] = uiState[prop];
                    }
                });
            }
        }
        return result;
    }
}
ExpressionManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExpressionManager.ctorParameters = () => [
    { type: Injector },
    { type: ResolveService },
    { type: ExpressionExecutor },
    { type: ExpressionRegistry },
    { type: ExpressionResult },
    { type: undefined, decorators: [{ type: Inject, args: [MESSAGE_SERVICE_TOKEN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NOTIFY_SERVICE_TOKEN,] }] }
];

class ExpressionResultFactory {
    constructor(injector, expressionRegistry, expressionManager, expressionResult) {
        this.injector = injector;
        this.expressionRegistry = expressionRegistry;
        this.expressionManager = expressionManager;
        this.expressionResult = expressionResult;
        this.registeEvent();
    }
    registeEvent() {
        this.expressionRegistry.expressions.subscribe((expressionObjects) => {
            // 加载完表达式之后做一次计算
            expressionObjects.forEach((expressionObject) => {
                if (expressionObject.deps && expressionObject.deps.length > 0) {
                    return;
                }
                const result = this.expressionManager.eval(expressionObject.id);
                this.expressionResult[expressionObject.id] = result;
            });
        });
    }
}
ExpressionResultFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExpressionResultFactory.ctorParameters = () => [
    { type: Injector },
    { type: ExpressionRegistry },
    { type: ExpressionManager },
    { type: ExpressionResult }
];

const ASSIGNER_TOKEN = new InjectionToken('@Farris expression assigner');
const EVENT_HANDLER_TOKEN = new InjectionToken('@Farris_event_handler');

/**
 * 监听UIState变更
 */
class UIStateChangeListener extends ChangeListener {
    constructor(injector, uiState, namespace, frameId, bindingData) {
        super();
        this.injector = injector;
        this.uiState = uiState;
        this.namespace = namespace;
        this.frameId = frameId;
        this.bindingData = bindingData;
        this.registerEvent();
    }
    buildEventPath(change) {
        return null;
    }
    registerEvent() {
        if (this.uiState && this.uiState.changes) {
            this.uiState.changes.subscribe((change) => {
                const modification = {
                    ns: this.namespace,
                    path: [change.field],
                    type: Expression$1.EventType.ValueChanged,
                    value: change.value,
                    source: Expression$1.EventSource.State,
                    frameId: this.frameId
                };
                // console.log("UIStateChangeListener", modification);
                this.subject.next(modification);
            });
        }
    }
}
UIStateChangeListener.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UIStateChangeListener.ctorParameters = () => [
    { type: Injector },
    { type: UIState },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: String, decorators: [{ type: Inject, args: [FRAME_ID,] }] },
    { type: BindingData }
];

const EventType = Expression$1.EventType;
class RepositoryChangeListener extends ChangeListener {
    constructor(injector, repository, namespace) {
        super();
        this.injector = injector;
        this.repository = repository;
        this.namespace = namespace;
        this.bindingData = this.injector.get(BindingData, null);
        this.registerEvent();
    }
    registerEvent() {
        if (this.repository && this.repository.changes) {
            this.repository.changes.subscribe((change) => {
                let eventType = this.convertEventType(change);
                if (!eventType) {
                    return;
                }
                const path = this.buildEventPath(change);
                const modification = {
                    ns: this.namespace,
                    type: eventType,
                    path: path,
                    value: change.value,
                    source: Expression$1.EventSource.Field,
                };
                // console.log("RepositoryChangeListener", modification);
                this.subject.next(modification);
            });
        }
        // repository只监听值变化事件
        if (this.repository && this.repository.entityCollectionChange) {
            this.repository.entityCollectionChange.subscribe((change) => {
                let eventType = this.convertEventType(change);
                if (!eventType) {
                    return;
                }
                const path = this.buildEventPath(change);
                const modification = {
                    ns: this.namespace,
                    type: eventType,
                    path: path,
                    value: change.value,
                    source: Expression$1.EventSource.Repository,
                };
                this.subject.next(modification);
            });
        }
    }
    /**
     * 构建事件路径参数
     * @param event event
     * @description 构建完之后的路径类似[id,prop] or [id,从表名s,从表当前行id,从表属性] or [id,udt,udt_prop]
     * @returns
     */
    buildEventPath(event) {
        const paths = event.path;
        let result = [];
        if (!paths || paths.length < 1) {
            // 主表新增时path为空
            return result;
        }
        // 过滤掉udt的冒号，关联字段的id
        result = paths.filter((path, index) => {
            if (index % 2 === 0 && path.includes(':')) {
                if (path === ':') {
                    return false;
                }
                const primaryKey = path.split(':')[0];
                if (primaryKey !== this.repository.primaryKey) {
                    return false;
                }
            }
            return true;
        });
        // 移除路径中的id字符串
        // result = paths.map((path: string, index: number) => {
        //   if (path.includes(':') && index % 2 === 0) {
        //     return path.split(':')[1];
        //   }
        //   return path;
        // });
        // 此时result中不应该有冒号
        return result;
    }
    convertEventType(change) {
        let eventType = null;
        if (change.type === ModifyType.Add || change.type === ModifyType.AddData || change.type === ModifyType.Insert) ;
        else if (change.type === ModifyType.Remove || change.type === ModifyType.RemoveData) ;
        else if (change.type === ModifyType.Load) ;
        else if (change.type === ModifyType.ValueChange) ;
        else if (change.type === ModifyType.Update) {
            eventType = Expression$1.EventType.Update;
        }
        return eventType;
    }
}
RepositoryChangeListener.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RepositoryChangeListener.ctorParameters = () => [
    { type: Injector },
    { type: Repository },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] }
];

class ListenerRegistry {
    constructor(listeners, injector) {
        this.listeners = listeners;
        this.injector = injector;
    }
}
ListenerRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ListenerRegistry.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [LISTENER_TOKEN,] }] },
    { type: Injector, decorators: [{ type: Optional }] }
];

const EventType$1 = Expression$1.EventType;
/**
 * 监听bindingList变更
 * @description 主要用于监听行切换等事件
 */
class BindingDataChangeListener extends ChangeListener {
    constructor(injector, bindingData, namespace) {
        super();
        this.injector = injector;
        this.bindingData = bindingData;
        this.namespace = namespace;
        this.repository = null;
        this.repository = this.injector.get(Repository, null);
        this.registerEvent();
    }
    /**
     * 注册值变化事件
     */
    registerEvent() {
        if (this.bindingData && this.bindingData.changes && typeof this.bindingData.changes.subscribe === 'function') {
            this.bindingData.changes.subscribe((change) => {
                if ((change.type === ChangeType.Append && change.isCloned !== true) || change.type === ChangeType.ValueChanged || change.type === ChangeType.Remove || change.type === ChangeType.Load || change.type === ChangeType.SelectionChanged) {
                    let eventType = null;
                    if (change.type === ChangeType.Append) {
                        eventType = EventType$1.Append;
                    }
                    else if (change.type === ChangeType.ValueChanged) {
                        eventType = EventType$1.ValueChanged;
                    }
                    else if (change.type === ChangeType.Remove) {
                        eventType = EventType$1.Remove;
                    }
                    else if (change.type === ChangeType.Load) {
                        // 主表新增
                        if (change.create === true) {
                            eventType = EventType$1.Append;
                        }
                        else {
                            eventType = EventType$1.Load;
                        }
                    }
                    else if (change.type === ChangeType.SelectionChanged) {
                        eventType = EventType$1.SelectionChanged;
                    }
                    const path = this.buildEventPath(change);
                    const modification = {
                        ns: this.namespace,
                        path: path,
                        type: eventType,
                        source: Expression$1.EventSource.BindingData,
                        value: change.value,
                        id: change.id,
                        isTreeNodeLoadScene: change.isTreeNodeLoadScene
                    };
                    // console.log("BindingDataChangeListener", modification);
                    this.subject.next(modification);
                }
            });
        }
    }
    buildEventPath(change) {
        const path = change.path;
        const paths = [];
        // if (!path || path.length < 1) {
        //   return paths;
        // }
        const primaryValue = this.bindingData.list.currentItem.primaryKeyValue || change.id;
        if (primaryValue) {
            if (!(change.type === ChangeType.Load && change.path.length === 0)) {
                paths.push(`${this.bindingData.list.primaryKey}:${primaryValue}`);
            }
        }
        const currentPath = [];
        for (let index = 0; index < path.length; index++) {
            const propertyName = path[index];
            currentPath.push(propertyName);
            const item = this.bindingData.getValue(currentPath);
            paths.push(propertyName);
            if (item instanceof BindingList) {
                if (currentPath.length < path.length) {
                    const bindingList = item;
                    let currentId = bindingList.currentItem.primaryKeyValue;
                    if (index === path.length - 2 && change.id) {
                        currentId = change.id;
                    }
                    paths.push(`${this.bindingData.list.primaryKey}:${currentId}`);
                }
            }
        }
        return paths;
    }
}
BindingDataChangeListener.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BindingDataChangeListener.ctorParameters = () => [
    { type: Injector },
    { type: BindingData },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] }
];

/**
 * 监听器
 * @description 监听bindingList、UIState变更
 */
class Listeners {
    constructor(registry) {
        this.registry = registry;
        this.subject = new Subject();
        this.regist();
    }
    get onEvent() {
        return this.subject;
    }
    regist() {
        const listeners = this.registry && this.registry.listeners || [];
        if (listeners && listeners.length > 0) {
            listeners.forEach((listener) => {
                listener.onEvent.subscribe((modification) => {
                    this.subject.next(modification);
                });
            });
        }
    }
}
Listeners.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Listeners.ctorParameters = () => [
    { type: ListenerRegistry, decorators: [{ type: Optional }] }
];

/**
 * 事件监听器主要有以下几种类型的事件：
 * 1、值变化
 * 2、行切换
 *    行切换使用场景为需要为数据计算依赖当前行时
 * 3、数据加载
 */
class ExpressionEventEmitter {
    constructor(listeners) {
        this.listeners = listeners;
        this.events = new Array();
        this.listeners.onEvent.subscribe((eventArgs) => {
            if (this.onEvent && this.onEvent.observers.length > 0) {
                let events = [];
                if (this.events.length > 0) {
                    events = [...this.events];
                }
                events.push(eventArgs);
                this.onEvent.next(events);
                this.events = [];
            }
            else {
                this.events.push(eventArgs);
            }
        });
    }
    attach() {
        if (!this.onEvent) {
            this.onEvent = new BehaviorSubject(this.events);
        }
        return this.onEvent.asObservable();
    }
}
ExpressionEventEmitter.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExpressionEventEmitter.ctorParameters = () => [
    { type: Listeners }
];

const EFFECTOR_TOKEN = new InjectionToken('@farris/effector_token');

/**
 * 实体副作用器
 * @description 将表达式计算结果赋值给实体属性
 */
class RepositoryEffector {
    constructor(injector, repository, namespace, bindingData) {
        this.injector = injector;
        this.repository = repository;
        this.namespace = namespace;
        this.bindingData = bindingData;
        this.ns = namespace;
    }
    effect(path, value, options) {
        if (!options || !options.path) {
            throw new Error('repository effector 需要指定行信息。');
        }
        const propertyPath = options.path;
        const rowId = propertyPath[0] || this.bindingData.list.currentItem.primaryKeyValue;
        let entity = this.repository.entityCollection.getEntityById(rowId);
        if (rowId && !entity) {
            return;
        }
        // propertyPath like : [1, child1s, 1.1, child2s, 1.1.1,propName] or [1,udt,propName] or [1,prop]
        const propName = propertyPath.pop();
        let object = entity;
        for (let index = 1; index < propertyPath.length; index++) {
            const propertyName = propertyPath[index];
            if (object instanceof EntityList) {
                object = object.get(propertyName);
            }
            else {
                object = object[propertyName];
            }
        }
        if (object) {
            if (object[propName] !== value) {
                object[propName] = value;
            }
        }
    }
}
RepositoryEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RepositoryEffector.ctorParameters = () => [
    { type: Injector },
    { type: Repository },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: BindingData }
];

class UIStateEffector {
    constructor(injector, uiState, namespace) {
        this.injector = injector;
        this.uiState = uiState;
        this.namespace = namespace;
        this.ns = namespace;
    }
    effect(path, value, options) {
        this.uiState.setPropertyValue(path, value);
    }
}
UIStateEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
UIStateEffector.ctorParameters = () => [
    { type: Injector },
    { type: UIState },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] }
];

/**
 * 只读副作用器
 */
class ReadonlyEffector {
    constructor(injector, namespace, frameContext) {
        this.injector = injector;
        this.namespace = namespace;
        this.frameContext = frameContext;
        this.ns = namespace;
    }
    effect(path, value, options) {
        // suprise ?
    }
}
ReadonlyEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ReadonlyEffector.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: FrameContext }
];

/**
 * 依赖副作用器
 * @description 当表达式计算结果为true时，清空字段值
 * 当value==true且属性当前值不是null时，设置属性值为null
 */
class DependencyEffector {
    constructor(injector, repository, namespace, bindingData) {
        this.injector = injector;
        this.repository = repository;
        this.namespace = namespace;
        this.bindingData = bindingData;
        this.ns = namespace;
    }
    effect(path, value, options) {
        if (!options || !options.path) {
            throw new Error('DependencyEffector 需要指定行信息。');
        }
        if (typeof value !== 'boolean') {
            console.warn(`DependencyEffector 依赖表达式计算结果应该为true/false，当前值为：${value}`);
        }
        const propertyPath = options.path;
        const rowId = propertyPath[0] || this.bindingData.list.currentItem.primaryKeyValue;
        let entity = this.repository.entityCollection.getEntityById(rowId);
        if (rowId && !entity) {
            throw new Error(`找不到id：${rowId}对应的实体！`);
        }
        // propertyPath like : [1, child1s, 1.1, child2s, 1.1.1,propName] or [1,udt,propName] or [1,prop]
        const propName = propertyPath.pop();
        let object = entity;
        for (let index = 1; index < propertyPath.length; index++) {
            const propertyName = propertyPath[index];
            if (object instanceof EntityList) {
                object = object.get(propertyName);
            }
            else {
                object = object[propertyName];
            }
        }
        if (object) {
            if (object[propName] !== null && value === true) {
                object[propName] = null;
            }
        }
        else {
            throw new Error(`[DependencyEffector] 找不到实体对应的路径：${propertyPath.push(propName)}`);
        }
    }
}
DependencyEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DependencyEffector.ctorParameters = () => [
    { type: Injector },
    { type: Repository },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: BindingData }
];

class EffectorRegistry {
    constructor(injector, effectors) {
        this.injector = injector;
        this.effectors = effectors;
    }
}
EffectorRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EffectorRegistry.ctorParameters = () => [
    { type: Injector },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [EFFECTOR_TOKEN,] }] }
];

class RelativeEffector {
    constructor(injector, messageService, notifyService, namespace) {
        this.injector = injector;
        this.messageService = messageService;
        this.notifyService = notifyService;
        this.namespace = namespace;
        this.ns = namespace;
    }
    effect(path, value, options) {
        if (value === true && options.message && this.notifyService) {
            const messageType = options.messageType || 'info';
            this.notifyService[messageType](options.message, { hideTitle: true });
        }
    }
}
RelativeEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RelativeEffector.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [MESSAGE_SERVICE_TOKEN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NOTIFY_SERVICE_TOKEN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] }
];

class ValidateEffector {
    constructor(injector, messageService, notifyService, namespace, frameContext) {
        this.injector = injector;
        this.messageService = messageService;
        this.notifyService = notifyService;
        this.namespace = namespace;
        this.frameContext = frameContext;
        this.ns = namespace;
    }
    effect(path, value, options) {
        // 校验不通过时返回false
        const domInfo = this.getDomInfoByEntityPath(path);
        if (!domInfo) {
            return;
        }
        const frameContext = domInfo.frameContext;
        const rootFrameContext = frameContext && frameContext.getVirtualRootFrameContext();
        // const rootViewModel = rootFrameContext.viewModel;
        const expressionId = options.expressionId;
        const domPropertyName = domInfo.domPropertyName;
        if (expressionId) {
            // 增加校验规则
            frameContext.form.addFieldValidateRule(domPropertyName, options.message, expressionId, "validate" /* Validate */);
        }
        if (value === false && options.message) {
            // 更新form错误信息
            // 不是grid，则认为是卡片
            if (!domInfo.isGridComponent) {
                const message = options.message.replace(/\$property/g, domInfo.propertyName);
                const formErrors = this.buildFormErrors(domPropertyName, message);
                // // 只增加校验规则，不立即显示校验信息，否则页面加载后在非编辑态就会显示校验信息
                frameContext.form.updateFormErrors(formErrors);
            }
            // 不进行汇总展示
            // const verifyInformations = this.buildVerifyInformations(domInfo.id, frameContext, domInfo.domPropertyName, options.message);
            // 增加到汇总消息
            // rootViewModel.verifycationChanged.next(verifyInformations);
            // 更新汇总错误信息
        }
        else if (value === true) {
            // 移除错误消息
            // const verifyInformations = this.removeValidateVerifyInformations(domInfo.id, this.frameContext);
            // rootViewModel.verifycationChanged.next(verifyInformations);
            const currentErrors = frameContext.form.getFormControlErrors(domPropertyName) || null;
            if (currentErrors) {
                if (currentErrors.hasOwnProperty('validate')) {
                    // require合法，移除require校验提示
                    delete currentErrors.validate;
                }
                frameContext.form.updateFormErrors({ [domPropertyName]: { errors: currentErrors } });
            }
            else {
                const formErrors = this.buildFormErrors(domPropertyName, null);
                frameContext.form.updateFormErrors(formErrors);
            }
        }
    }
    /**
     * 通过实体路径获取对应的dom信息
     * @param entityPath
     * @returns
     */
    getDomInfoByEntityPath(entityPath) {
        let result = null;
        if (!entityPath) {
            return result;
        }
        entityPath = entityPath.split('/').filter(p => p).join('.');
        const frameContexts = this.frameContext && this.frameContext.appContext.frameContextManager.getFrameContextsByNamespace(this.namespace) || null;
        if (frameContexts && frameContexts.length > 0) {
            for (const frameContext of frameContexts) {
                if (result) {
                    break;
                }
                const isValidFrameContext = frameContext && frameContext.form && frameContext.form.ngFormControls && Object.keys(frameContext.form.ngFormControls).length > 0;
                if (frameContext && frameContext.form && frameContext.form.ngFormControls && Object.keys(frameContext.form.ngFormControls).length > 0) {
                    const keys = Object.keys(frameContext.form.ngFormControls);
                    for (const propertyName of keys) {
                        const ngFormControl = frameContext.form.ngFormControls[propertyName];
                        let bindingPath = frameContext.viewModel.bindingPath || '/';
                        const bindingPaths = bindingPath.split('/').filter(p => p);
                        let bindings = ngFormControl.binding.split('.');
                        bindings = bindingPaths.concat(bindings);
                        if (entityPath === bindings.join('.')) {
                            // 判断对应的组件是什么类型
                            const dgColumnNames = frameContext.viewModel['dataGridColumnsName'] || null;
                            const dgColumnInfo = frameContext.viewModel[dgColumnNames] || null;
                            if (dgColumnInfo && Array.isArray(dgColumnInfo) && dgColumnInfo.length > 0) {
                                const isEditableGrid = dgColumnInfo.find((array) => {
                                    const readonlyGroup = array.every((column) => !(column.hasOwnProperty('editor') && column.editor));
                                    if (!readonlyGroup) {
                                        return true;
                                    }
                                    else {
                                        return false;
                                    }
                                });
                                if (!isEditableGrid) {
                                    continue;
                                }
                            }
                            // 如果是farris树，则跳过
                            const isFarrisTreeTableComponent = frameContext && frameContext.frameComponent && frameContext.frameComponent.componentType === ComponentType.farrisTreeTalbeComponent;
                            if (isFarrisTreeTableComponent) {
                                continue;
                            }
                            let isGridComponent = false;
                            if (dgColumnNames) {
                                isGridComponent = true;
                            }
                            result = {
                                domPropertyName: propertyName,
                                propertyName: ngFormControl.name || ngFormControl.defaultI18nValue,
                                frameContext,
                                id: ngFormControl.id,
                                isGridComponent
                            };
                            break;
                        }
                    }
                }
            }
        }
        return result;
    }
    getVerifyInformations(frameContext) {
        const rootFrameContext = frameContext && frameContext.getVirtualRootFrameContext();
        const rootViewModel = rootFrameContext.viewModel;
        const verifyInformations = rootViewModel.verifyInformations;
        return verifyInformations;
    }
    buildFormErrors(domPropertyName, message) {
        if (message) {
            message = message.replace(/\$property/g, 'domPropertyName');
            return {
                [domPropertyName]: {
                    errors: {
                        'validate': {
                            name: message
                        }
                    }
                }
            };
        }
        else {
            return {
                [domPropertyName]: {
                    errors: {}
                }
            };
        }
    }
    buildVerifyInformations(id, frameContext, domPropertyName, message) {
        const verifyInformations = this.getVerifyInformations(frameContext);
        const index = verifyInformations.findIndex((item) => {
            return item.id === id;
        });
        if (index !== -1) {
            verifyInformations.splice(index, 1);
        }
        verifyInformations.push({
            id: id,
            namespace: frameContext.namespace,
            targetField: domPropertyName,
            index: verifyInformations.length + 1,
            title: frameContext.form.formGroupName,
            msg: message,
            type: 'error'
        });
        return verifyInformations;
    }
    removeValidateVerifyInformations(id, frameContext) {
        const verifyInformations = this.getVerifyInformations(frameContext);
        const index = verifyInformations.findIndex((item) => {
            return item.id === id;
        });
        if (index !== -1) {
            verifyInformations.splice(index, 1);
        }
        return verifyInformations;
    }
}
ValidateEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ValidateEffector.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [MESSAGE_SERVICE_TOKEN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NOTIFY_SERVICE_TOKEN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: FrameContext }
];

/**
 * 必填副作用器
 * @description 当结算结果为true时设置必填校验，否则删除必填校验
 */
class RequiredEffector {
    constructor(injector, repository, namespace, frameContext) {
        this.injector = injector;
        this.repository = repository;
        this.namespace = namespace;
        this.frameContext = frameContext;
        this.ns = namespace;
    }
    effect(path, value, options) {
        // 校验不通过时返回false
        const domInfo = this.getDomInfoByEntityPath(path);
        if (!domInfo) {
            return;
        }
        const frameContext = domInfo.frameContext;
        const rootFrameContext = frameContext && frameContext.getVirtualRootFrameContext();
        const rootViewModel = rootFrameContext.viewModel;
        const domPropertyName = domInfo.domPropertyName;
        const pathValue = this.frameContext.bindingData.getValue(path.split('/').filter(p => p));
        const expressionId = options.expressionId;
        if (expressionId) {
            // 增加校验规则
            frameContext.form.addFieldValidateRule(domPropertyName, options.message, expressionId, "require" /* Require */);
        }
        if (value === true) {
            if (options.message) {
                // 更新form错误信息
                // 不是grid，则认为是卡片
                if (!domInfo.isGridComponent) {
                    const message = options.message.replace(/\$property/g, domInfo.propertyName);
                    const formErrors = this.buildFormErrors(domPropertyName, message);
                    const isValidValue = this.isValidValue(path, pathValue);
                    if (!isValidValue) {
                        frameContext.form.updateFormErrors(formErrors);
                    }
                }
                else {
                    this.updateColumnValidators(frameContext, domInfo.binding, domInfo.datagridColumns, true);
                }
            }
        }
        else {
            // 返回非true值时认为非必填
            if (domInfo.isGridComponent) {
                this.updateColumnValidators(frameContext, domInfo.binding, domInfo.datagridColumns, false);
            }
            else {
                const currentErrors = frameContext.form.getFormControlErrors(domPropertyName) || null;
                if (currentErrors) {
                    if (currentErrors.hasOwnProperty('require')) {
                        // require合法，移除require校验提示
                        delete currentErrors.require;
                    }
                    frameContext.form.updateFormErrors({ [domPropertyName]: { errors: currentErrors } });
                }
                else {
                    const formErrors = this.buildFormErrors(domPropertyName, null);
                    frameContext.form.updateFormErrors(formErrors);
                }
            }
        }
    }
    updateColumnValidators(frameContext, field, datagridColumns, isRequired) {
        const frameId = frameContext.frameId;
        const componentRefs = frameContext.appContext.componentManager.get([frameId]);
        if (componentRefs && componentRefs.size > 0) {
            const datagrid = Array.from(componentRefs.values())[0];
            if (datagrid && typeof datagrid.updateColumn === 'function') {
                const columns = datagridColumns.find((array) => {
                    return array.find(item => item.field === field);
                });
                const column = columns && columns.find(item => item.field === field) || null;
                if (column) {
                    const validators = column.validators || [];
                    const index = validators.findIndex(item => item.type === 'required');
                    if (isRequired) {
                        if (index === -1) {
                            validators.push({ "type": "required", "message": "该字段不能为空！" });
                        }
                    }
                    else {
                        if (index !== -1) {
                            validators.splice(index, 1);
                        }
                    }
                    datagrid.updateColumn(field, { validators: [...validators] });
                    datagrid.columnsChanged(false);
                }
            }
        }
    }
    getDomInfoByEntityPath(entityPath) {
        let result = null;
        if (!entityPath) {
            return result;
        }
        entityPath = entityPath.split('/').filter(p => p).join('.');
        const frameContexts = this.frameContext && this.frameContext.appContext.frameContextManager.getFrameContextsByNamespace(this.namespace) || null;
        if (frameContexts && frameContexts.length > 0) {
            for (const frameContext of frameContexts) {
                if (result) {
                    break;
                }
                if (frameContext && frameContext.form && frameContext.form.ngFormControls && Object.keys(frameContext.form.ngFormControls).length > 0) {
                    const keys = Object.keys(frameContext.form.ngFormControls);
                    for (const propertyName of keys) {
                        const ngFormControl = frameContext.form.ngFormControls[propertyName];
                        let bindingPath = frameContext.viewModel.bindingPath || '/';
                        const bindingPaths = bindingPath.split('/').filter(p => p);
                        let bindings = ngFormControl.binding.split('.');
                        bindings = bindingPaths.concat(bindings);
                        if (entityPath === bindings.join('.')) {
                            // 判断对应的组件是什么类型
                            const dgColumnNames = frameContext.viewModel['dataGridColumnsName'] || null;
                            const dgColumnInfo = frameContext.viewModel[dgColumnNames] || null;
                            if (dgColumnInfo && Array.isArray(dgColumnInfo) && dgColumnInfo.length > 0) {
                                const isEditableGrid = dgColumnInfo.find((array) => {
                                    const readonlyGroup = array.every((column) => !(column.hasOwnProperty('editor') && column.editor));
                                    if (!readonlyGroup) {
                                        return true;
                                    }
                                    else {
                                        return false;
                                    }
                                });
                                if (!isEditableGrid) {
                                    continue;
                                }
                            }
                            // 如果是farris树，则跳过
                            const isFarrisTreeTableComponent = frameContext && frameContext.frameComponent && frameContext.frameComponent.componentType === ComponentType.farrisTreeTalbeComponent;
                            if (isFarrisTreeTableComponent) {
                                continue;
                            }
                            let isGridComponent = false;
                            if (dgColumnNames) {
                                isGridComponent = true;
                            }
                            result = {
                                domPropertyName: propertyName,
                                propertyName: ngFormControl.name || ngFormControl.defaultI18nValue,
                                frameContext,
                                id: ngFormControl.id,
                                isGridComponent,
                                binding: ngFormControl.binding,
                                datagridColumns: dgColumnInfo
                            };
                            break;
                        }
                    }
                }
            }
        }
        return result;
    }
    getDataPropInfo(path) {
        if (!path) {
            return null;
        }
        const paths = path.split('/').filter(p => p);
        return this.frameContext.repository.entityTypeInfo.getPropInfoByPath(paths);
    }
    isValidValue(path, value) {
        const dataTypeInfo = this.getDataPropInfo(path);
        if (dataTypeInfo && dataTypeInfo.metadataInfo && dataTypeInfo.metadataInfo.enableMultiLangInput === true) {
            // 多语字段
            const translate = this.injector.get(TranslateToken, null);
            const currentLanguage = translate && translate.getCurrentLanguage() || 'zh-CHS';
            if (Object.keys(value).length < 1) {
                return false;
            }
            return !!value[currentLanguage];
        }
        else if (value === null || value === '' || value === undefined) {
            return false;
        }
        return true;
    }
    buildFormErrors(domPropertyName, message) {
        if (message) {
            return {
                [domPropertyName]: {
                    errors: {
                        'require': {
                            name: message
                        }
                    }
                }
            };
        }
        else {
            return {
                [domPropertyName]: {
                    errors: {}
                }
            };
        }
    }
}
RequiredEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RequiredEffector.ctorParameters = () => [
    { type: Injector },
    { type: Repository },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: FrameContext }
];

class VisibleEffector {
    constructor(injector, namespace, frameContext, repository) {
        this.injector = injector;
        this.namespace = namespace;
        this.frameContext = frameContext;
        this.repository = repository;
        this.ns = namespace;
    }
    effect(path, value, options) {
        // 由匿名函数接管，ignore
        const paths = path.split('/').filter(p => p);
        const bindingPaths = this.getTablePaths(paths);
        const bindingPath = bindingPaths.join('/');
        // 主表显隐无需处理
        if (bindingPaths && bindingPaths.length > 0) {
            const isGridComponent = this.isGridComponent(bindingPath);
            if (isGridComponent) {
                const datagridComponent = this.getDatagridComponent(bindingPath);
                if (datagridComponent) {
                    // 更新列信息
                    // datagridComponent.columnsChanged();
                    const fieldPaths = this.getPropertyPaths(paths);
                    if (fieldPaths) {
                        const field = fieldPaths.join('.');
                        if (value) {
                            datagridComponent.showColumn(field, false);
                        }
                        else {
                            datagridComponent.hideColumn(field, false);
                        }
                    }
                }
            }
        }
        else {
            const datagridComponent = this.getDatagridComponent(bindingPath);
            if (datagridComponent) {
                datagridComponent.columnsChanged(false);
            }
        }
    }
    getTablePaths(paths) {
        const entityPaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        return entityPaths;
    }
    getDatagridComponent(bindingPath) {
        const frameContexts = this.frameContext.appContext.frameContextManager.getFrameContextsByNamespace(this.namespace) || [];
        const matchedFrameContexts = frameContexts.filter((frameContext) => frameContext.viewModel && frameContext.viewModel.bindingPath.split('/').filter(p => p).toString() === bindingPath.split('/').filter(p => p).toString());
        let result = null;
        if (matchedFrameContexts) {
            matchedFrameContexts.every((frameContext) => {
                const frameId = frameContext.frameId;
                const componentsMap = this.frameContext.appContext.componentManager.getComponentsByFrameId(frameId);
                if (!componentsMap) {
                    return true;
                }
                const datagridComponent = Array.from(componentsMap.values()).find((component) => component && component['__component_type__'] === 'DatagridComponent');
                if (datagridComponent) {
                    result = datagridComponent;
                    return false;
                }
                else {
                    return true;
                }
            });
        }
        return result;
    }
    getPropertyPaths(paths) {
        const tablePaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        return paths.slice(tablePaths.length);
    }
    isGridComponent(bindingPath) {
        const frameContexts = this.frameContext.appContext.frameContextManager.getFrameContextsByNamespace(this.namespace) || [];
        const frameContext = frameContexts.find((frameContext) => frameContext.viewModel && frameContext.viewModel.bindingPath.split('/').filter(p => p).toString() === bindingPath.split('/').filter(p => p).toString());
        if (frameContext) {
            return !!frameContext.viewModel['dataGridColumnsName'];
        }
        else {
            return false;
        }
    }
}
VisibleEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
VisibleEffector.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: FrameContext },
    { type: Repository }
];

// import { Core } from '../core/index';
class EffectorFactory {
    constructor(injector, effectorRegistry) {
        this.injector = injector;
        this.effectorRegistry = effectorRegistry;
    }
    getEffector(expressionObject) {
        const path = expressionObject.path;
        const ns = expressionObject.ns;
        const bindingType = expressionObject.bindingType;
        const type = expressionObject.type;
        const nsEffectors = this.effectorRegistry.effectors.filter((effector) => effector.ns == ns);
        // 计算表达式
        if (type === Expression$1.ExpressionType.Compute) {
            if (bindingType === Expression$1.ExpressionBindingType.Field) {
                return nsEffectors.find((effector) => effector instanceof RepositoryEffector);
            }
            else if (bindingType === Expression$1.ExpressionBindingType.State) {
                return nsEffectors.find((effector) => effector instanceof UIStateEffector);
            }
            else {
                throw new Error(`不支持的绑定字段类型：${bindingType}`);
            }
        }
        else if (type === Expression$1.ExpressionType.Readonly) {
            // 只读表达式
            return nsEffectors.find((effector) => effector instanceof ReadonlyEffector);
        }
        else if (type === Expression$1.ExpressionType.Dependency) {
            // 依赖表达式
            return nsEffectors.find((effector) => effector instanceof DependencyEffector);
        }
        else if (type === Expression$1.ExpressionType.Relative) {
            // 关联表达式
            return nsEffectors.find((effector) => effector instanceof RelativeEffector);
        }
        else if (type === Expression$1.ExpressionType.Validate) {
            // 校验表达式
            return nsEffectors.find((effector) => effector instanceof ValidateEffector);
        }
        else if (type === Expression$1.ExpressionType.Required) {
            // 必填表达式
            return nsEffectors.find((effector) => effector instanceof RequiredEffector);
        }
        else if (type === Expression$1.ExpressionType.Visible) {
            // 显隐表达式
            return nsEffectors.find((effector) => effector instanceof VisibleEffector);
        }
        else {
            // Core.warn(`EffectorFactory 没有找到对应的副作用器 ${type}`);
            return null;
        }
    }
}
EffectorFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EffectorFactory.ctorParameters = () => [
    { type: Injector },
    { type: EffectorRegistry }
];

// export * from './types';

class EventHandler {
    constructor(injector, repository, bindingData, expressionRegistry, effectorFactory, expressionExecutor, expressionResult) {
        this.injector = injector;
        this.repository = repository;
        this.bindingData = bindingData;
        this.expressionRegistry = expressionRegistry;
        this.effectorFactory = effectorFactory;
        this.expressionExecutor = expressionExecutor;
        this.expressionResult = expressionResult;
        this.frameContext = this.injector.get(FrameContext);
    }
    handleEvent(event, expressionObjects) {
        event = Object.assign({}, event);
        this.expressionObjects = expressionObjects;
        this.dispatch(event);
    }
    //#endregion
    //#region 属性
    /**
     * 主表主键值
     */
    get primaryValue() {
        return this.bindingData.list.currentItem.primaryKeyValue;
    }
    /**
     * 获取主实体原始字段名
     */
    get entityOriginalNodeCode() {
        return this.repository && this.repository.entityTypeInfo && this.repository.entityTypeInfo.entityInfo && this.repository.entityTypeInfo.entityInfo.originalCode || null;
    }
    //#endregion
    //#region 表达式核心
    /**
     * 执行表达式计算
     * @param expression 表达式
     * @param context 上下文
     * @returns any
     */
    perform(expressionObject, context) {
        return this.expressionExecutor.compile(expressionObject, context);
    }
    /**
     * 副作用
     * @param event event
     * @param expressionObject expressionObject
     */
    effect(event, expressionObject) {
        const effectTo = expressionObject.bindingType;
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            // console.warn(`EventHandler 没有对应的副作用器。${expressionObject.type}`);
            return;
        }
        if (effectTo === Expression$1.ExpressionBindingType.Field) {
            const effectPaths = expressionObject.effectPaths || [];
            if (effectPaths.length > 0) {
                effectPaths.forEach((path) => {
                    const effectPath = path.split('/');
                    const effectOptions = { path: effectPath, message: expressionObject.message, expressionId: expressionObject.id };
                    effector.effect(expressionObject.path, expressionObject.result, effectOptions);
                });
            }
            else if (expressionObject.type === Expression$1.ExpressionType.Required || expressionObject.type === Expression$1.ExpressionType.Validate || expressionObject.type === Expression$1.ExpressionType.Readonly || expressionObject.type === Expression$1.ExpressionType.Visible) {
                const effectOptions = { message: expressionObject.message, expressionId: expressionObject.id };
                effector.effect(expressionObject.path, expressionObject.result, effectOptions);
            }
        }
        else {
            throw new Error('not supported！');
        }
    }
    //#endregion
    //#region util
    isValidateOrRequiredExpression(expressionObject) {
        return expressionObject && (expressionObject.type === Expression$1.ExpressionType.Validate || expressionObject.type === Expression$1.ExpressionType.Required);
    }
    /**
     * 以事件参数为依据构建实体路径
     * @param event event
     * @returns
     */
    getEntityPathFromEvent(event) {
        event = JSON.parse(JSON.stringify(event));
        if (!event || !event.path || event.path.length < 1) {
            return [];
        }
        const paths = event.path;
        return this.getEntityPath(paths);
    }
    /**
     * 获取事件路径中的实体路径
     * @param path path
     * @returns
     */
    getEntityPath(path) {
        const paths = path.filter((value, index) => {
            if (index % 2 === 0 && value.includes(':')) {
                return false;
            }
            else {
                return true;
            }
        });
        return paths;
    }
    /**
     * 构造实体路径
     * @param path path
     * @description 删除路径中的id字段
     * @returns
     */
    buildEntityPath(path) {
        const paths = path.filter((value, index) => {
            if (index % 2 === 0 && value.includes(':')) {
                return false;
            }
            else {
                return true;
            }
        });
        return paths;
    }
    /**
     * 清理事件路径中的id主键标识
     * @param path path
     * @returns
     */
    cleanEventPath(path) {
        path = path.filter(p => {
            if (p && p !== ':') {
                return true;
            }
            else {
                return false;
            }
        });
        return path.map((item) => {
            if (item.includes(':')) {
                return item.split(':')[1];
            }
            else {
                return item;
            }
        });
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByPaths(paths) {
        let result = null;
        const bindingList = this.bindingData.getValue(paths);
        if (bindingList && bindingList.length > 0) {
            let primaryValue = bindingList.currentItem.primaryKeyValue || null;
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
    /**
     * 获取事件路径中指定子表的事件行
     * @param path
     * @param tableCode
     * @returns
     */
    getEventId(path, tableCode) {
        if (!path || path.length < 1) {
            throw new Error('invalid path!');
        }
        const propertyIndex = path.findIndex(p => p === tableCode);
        if (propertyIndex === -1) {
            return null;
        }
        const idIndex = propertyIndex + 1;
        if (idIndex > path.length - 1) {
            throw new Error('invalid propertyName or path');
        }
        const id = path[idIndex];
        if (id.indexOf(':') === -1) {
            throw new Error('compute error.');
        }
        return id.split(':')[1];
    }
    //#endregion
    //#region  构造上下文
    /**
     * 构造变量上下文
     * @param event
     * @returns
     */
    buildStateContext(event) {
        const ns = event.ns;
        const appContext = this.injector.get(AppContext, null);
        const frameContexts = appContext.frameContextManager.getFrameContextsByNamespace(ns);
        const result = {};
        if (frameContexts && frameContexts.length > 0) {
            const anonymousFrameContext = frameContexts[0];
            const rootFrameContext = anonymousFrameContext.getVirtualRootFrameContext();
            if (rootFrameContext) {
                const uiState = rootFrameContext.viewModel.uiState;
                const propertyNames = Object.getOwnPropertyNames(uiState) || [];
                propertyNames.forEach((prop) => {
                    if (prop.match(/^[a-zA-Z0-9_\$]+$/g) !== null) {
                        result[prop] = uiState[prop];
                    }
                });
            }
        }
        return result;
    }
    /**
     * 获取事件实体
     * @param event
     * @returns
     */
    buildEntityContext(event, expressionObject, currentRows) {
        const expressionBindingType = expressionObject.bindingType;
        if (expressionBindingType === Expression$1.ExpressionBindingType.Field) {
            const entityTypeInfo = this.repository.entityTypeInfo;
            const childrenEntityPaths = [];
            ExpressionUtil.getChildrenEntityPaths(entityTypeInfo, childrenEntityPaths);
            // 获取当前行
            const row = currentRows && currentRows.find(row => row.bindingPath === '' || row.bindingPath === '/') || null;
            const primaryValue = row && row.primaryValue || this.bindingData.list.currentId;
            let entity = this.bindingData.list.findById(primaryValue);
            if (!entity) {
                return {};
            }
            const object = entity.toJSON();
            object['__type__'] = 'Entity';
            if (!childrenEntityPaths || childrenEntityPaths.length < 1) {
                return object;
            }
            childrenEntityPaths.sort((v1, v2) => v1.length - v2.length);
            // 找到所有子表
            childrenEntityPaths.forEach((paths) => {
                const bindingList = this.bindingData.getValue(paths);
                let currentRowId = bindingList.currentId;
                const propertyName = paths[paths.length - 1];
                // parent 为entity或entitylist或null
                const parent = paths.slice(0, paths.length - 1).reduce((object, path) => {
                    return object && object[path] || null;
                }, object);
                if (!parent) {
                    return;
                }
                const data = parent;
                let node = null;
                if (!currentRowId) {
                    // 当前表没有数据
                    node = { __items__: [], __type__: 'List' };
                    node.length = () => node.__items__.length;
                }
                else {
                    // 纠正当前行
                    if (currentRows && currentRows.length > 0) {
                        // 是否指定了当前行
                        const userAssignCurrentRow = currentRows.find(row => {
                            const bindingPaths = row.bindingPath.split('/').filter(p => p);
                            return bindingPaths.join('/') === paths.join('/');
                        });
                        if (userAssignCurrentRow) {
                            currentRowId = userAssignCurrentRow.primaryValue;
                        }
                    }
                    // 子表当前行
                    const row = bindingList.findById(currentRowId);
                    // 找到子表当前行的上级
                    const list = parent[propertyName];
                    node = Object.assign({ __items__: [] }, row && row.toJSON() || {}, { __type__: 'List' });
                    node.length = () => node.__items__.length;
                    if (list && Array.isArray(list)) {
                        node.__items__ = [].concat(list);
                    }
                }
                data[propertyName] = node;
            });
            return object;
        }
        else if (expressionBindingType === Expression$1.ExpressionBindingType.State) ;
        else {
            return null;
        }
    }
    /**
     * 构造表达式计算上下文
     * @param expressionObject 表达式
     * @param event 事件
     * @param entityContext 实体上下文
     * @param currentRows 当前行
     * @returns
     */
    buildContext(expressionObject, event, entityContext, currentRows) {
        let context = [];
        if (entityContext) {
            context.push(entityContext);
        }
        else {
            const entity = this.buildEntityContext(event, expressionObject, currentRows);
            context.push(entity);
        }
        const stateContext = this.buildStateContext(event);
        const entityCode = this.entityOriginalNodeCode;
        let entity = null;
        if (context.length === 1) {
            entity = context.pop();
        }
        else {
            entity = context[0];
            if (!entity['__type__']) {
                entity['__type__'] = 'Entity';
            }
            entity['__items__'] = context;
        }
        const translate = this.injector.get(TranslateToken, null);
        return Object.assign({ [entityCode]: entity }, stateContext, { BigNumber, frameContext: this.frameContext, bindingData: this.bindingData, repository: this.repository, CurrentLanguage: translate.getCurrentLanguage() || 'zh-CHS' });
    }
    //#endregion
    /**
     * 构造副作用路径
     * @param event
     * @param expressionObject
     * @returns
     */
    buildEffectPath(event, expressionObject) {
        const expressionPaths = expressionObject.path.split('/').filter(p => p);
        const primaryValue = event.path[0] && event.path[0].split(':')[1];
        if (!primaryValue) {
            throw new Error('Invalid event path!');
        }
        if (expressionPaths.length === 1) {
            // 主表简单字段
            return [primaryValue, expressionPaths.pop()];
        }
        else {
            const result = [primaryValue];
            for (let index = 0; index < expressionPaths.length; index++) {
                const propertyName = expressionPaths[index];
                result.push(propertyName);
                const currentPaths = expressionPaths.slice(0, index + 1);
                const propertyInfo = this.repository.entityTypeInfo.getPropInfoByPath(currentPaths);
                if (propertyInfo.group === 'List') {
                    let id = this.getEventId(event.path, propertyInfo.name) || null;
                    // 事件和表达式不是同一个表
                    if (!id) {
                        const bindingList = this.bindingData.getValue(currentPaths);
                        if (bindingList) {
                            id = bindingList.currentId;
                        }
                    }
                    result.push(id);
                }
            }
            return result;
        }
    }
    //#region 辅助方法
    getPathInfo(path) {
        const paths = path.split('/').filter(p => p);
        // 获取最大实体层级，其余为属性（简单属性、udt、关联、关联嵌套关联）
        const entityPath = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        const propertyName = paths.slice(entityPath.length).join('/');
        return { path: entityPath.join('/'), propertyName, paths: entityPath, propertyNames: propertyName.split('/').filter(p => p) };
    }
    /**
     * get table paths from event paths
     * @param paths event paths
     * @returns
     */
    getTablePathsFromEventPaths(paths) {
        paths = this.getEntityPath(paths);
        const entityPaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        return entityPaths;
    }
    /**
     * get property paths from event paths
     * @param paths event paths
     * @returns
     */
    getPropertyPathsFromEventPaths(paths) {
        paths = this.getEntityPath(paths);
        const tablePaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        return paths.slice(tablePaths.length);
    }
    /**
     * 分析事件和表达式的关系
     */
    analysis(event, expressionObject) {
        const expressionPathInfo = this.getPathInfo(expressionObject.path);
        const eventPaths = this.getEntityPath(event.path.slice(0));
        const eventPathInfo = this.getPathInfo(eventPaths.join('/'));
        if (!expressionPathInfo || !eventPathInfo) {
            console.warn(`表达式路径或事件路径错误，获取路径信息失败。`);
            return null;
        }
        const expressionTablePaths = expressionPathInfo.path.split('/').filter(p => p);
        const expressionPropertyNames = expressionPathInfo.propertyName.split('/').filter(p => p);
        const eventTablePaths = eventPathInfo.path.split('/').filter(p => p);
        const eventPropertyNames = eventPathInfo.propertyName.split('/').filter(p => p);
        const result = {
            distance: undefined,
            eventFromChildren: undefined,
            eventFromParent: undefined,
            expressionTablePaths,
            expressionPropertyNames,
            eventTablePaths,
            eventPropertyNames,
            isSameTable: false
        };
        result.distance = Math.abs(expressionTablePaths.length - eventTablePaths.length);
        if (result.distance === 1) {
            result.eventFromChildren = eventTablePaths.length > expressionTablePaths.length && eventTablePaths.join('/').startsWith(expressionTablePaths.join('/'));
            result.eventFromParent = eventTablePaths.length < expressionTablePaths.length && expressionTablePaths.join('/').startsWith(eventTablePaths.join('/'));
        }
        result.isSameTable = expressionTablePaths.join('/') === eventTablePaths.join('/');
        return result;
    }
    buildCurrentRows(tablePaths, fullPaths) {
        const currentRows = new Array();
        if (!tablePaths || tablePaths.length < 1) {
            currentRows.push({
                bindingPath: '/',
                primaryValue: fullPaths[0]
            });
        }
        else {
            const paths = [];
            tablePaths.forEach((path, index) => {
                if (index === 0) {
                    currentRows.push({
                        bindingPath: '/',
                        primaryValue: fullPaths[0]
                    });
                }
                paths.push(path);
                const primaryValue = fullPaths[index * 2 + 2];
                currentRows.push({
                    bindingPath: paths.join('/'),
                    primaryValue: primaryValue
                });
            });
        }
        return currentRows;
    }
    convertBooleanTypeExpressionResult(expressionObject, result) {
        if (this.isBooleanTypeExpression(expressionObject)) {
            return result === true ? true : false;
        }
        else {
            return result;
        }
    }
    isBooleanTypeExpression(expressionObject) {
        return this.isReadonlyExpression(expressionObject) || this.isVisibleExpression(expressionObject) || this.isValidateExpression(expressionObject) || this.isRequiredExpression(expressionObject) || this.isDependencyExpression(expressionObject);
    }
    isReadonlyExpression(expressionObject) {
        return expressionObject && expressionObject.type === Expression$1.ExpressionType.Readonly || false;
    }
    isVisibleExpression(expressionObject) {
        return expressionObject && expressionObject.type === Expression$1.ExpressionType.Visible;
    }
    isValidateExpression(expressionObject) {
        return expressionObject && expressionObject.type === Expression$1.ExpressionType.Validate;
    }
    isRequiredExpression(expressionObject) {
        return expressionObject && expressionObject.type === Expression$1.ExpressionType.Required;
    }
    isDependencyExpression(expressionObject) {
        return expressionObject && expressionObject.type === Expression$1.ExpressionType.Dependency;
    }
}
EventHandler.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EventHandler.ctorParameters = () => [
    { type: Injector },
    { type: Repository },
    { type: BindingData },
    { type: ExpressionRegistry },
    { type: EffectorFactory },
    { type: ExpressionExecutor },
    { type: ExpressionResult }
];

/**
 * 实体值变化处理器
 */
class EntityValueChangedEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     */
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}
EntityValueChangedEventHandler.decorators = [
    { type: Injectable }
];

class EffectorManager {
    /**
     * 批量副作用
     * @param effector effector
     * @param expressionObject 表达式
     * @param paths 作用路径
     * @returns
     */
    static effect(effector, expressionObject, paths) {
        if (!paths || paths.length < 1) {
            return;
        }
        paths.forEach((path) => {
            const effectOptions = { path, message: expressionObject.message, expressionId: expressionObject.id };
            effector.effect(expressionObject.path, expressionObject.result, effectOptions);
        });
    }
}

class StateValueChangedEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     */
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            return this.expressionObjects.filter((expressionObject) => {
                const deps = expressionObject.deps;
                if (!deps || deps.length < 1 || event.ns !== expressionObject.ns) {
                    return false;
                }
                const changePaths = this.cleanEventPath(event.path);
                changePaths.splice(0, 0, STATE_TEMPLATE);
                const eventPath = changePaths.join('/');
                if (deps.includes(eventPath)) {
                    return true;
                }
                else {
                    return false;
                }
            });
        }
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                // const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, result);
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 副作用
     * @param event event
     * @param expressionObject expressionObject
     */
    effect(event, expressionObject) {
        const effector = this.effectorFactory.getEffector(expressionObject);
        const bindingType = expressionObject.bindingType;
        if (!effector) {
            return;
        }
        if (bindingType === Expression$1.ExpressionBindingType.State) {
            // 如果表达式作用于uistate
            effector.effect(expressionObject.path, expressionObject.result, { message: expressionObject.message });
        }
        else if (bindingType === Expression$1.ExpressionBindingType.Field) {
            // 表达式作用于实体属性
            const expressionPathInfo = this.getPathInfo(expressionObject.path);
            const bindingPaths = expressionPathInfo.paths;
            const entities = this.repository.entityCollection.getAllEntities();
            if (!entities || entities.length < 1 || expressionObject.type === Expression$1.ExpressionType.Visible) {
                effector.effect(expressionObject.path, expressionObject.result, { message: expressionObject.message });
            }
            else {
                this.effectRows(entities, bindingPaths, expressionPathInfo.propertyNames, (currentRows, paths) => {
                    this.output(event, expressionObject, currentRows, effector, [paths]);
                });
            }
        }
    }
    output(event, expressionObject, currentRows, effector, paths) {
        const context = this.buildContext(expressionObject, event, null, currentRows);
        const value = this.perform(expressionObject, context);
        if (value === undefined) {
            return;
        }
        expressionObject.result = value;
        if (expressionObject.id) {
            this.expressionResult.set(expressionObject.id, expressionObject.result);
        }
        EffectorManager.effect(effector, expressionObject, paths);
    }
    effectRows(entities, bindingPaths, propertyNames, callback, currentRows = [], prevPaths = [], paths = []) {
        if (!bindingPaths || bindingPaths.length < 1) {
            entities.forEach((entity) => {
                if (!entity || !entity.primaryValue) {
                    return;
                }
                const currentPaths = paths.concat([entity.primaryValue]).concat(propertyNames);
                const currentCurrentRows = currentRows.concat([{ bindingPath: prevPaths.join('/') || '/', primaryValue: entity.primaryValue }]);
                callback(currentCurrentRows, currentPaths);
            });
            currentRows.length = 0;
            paths.length = 0;
        }
        else {
            let flag = false;
            let nextPrevPaths = prevPaths;
            entities.forEach((entity) => {
                const prop = bindingPaths[0];
                const entityList = entity[prop];
                if (!entityList || entityList.count() < 1) {
                    // 下级表没有数据
                    return;
                }
                currentRows.push({ bindingPath: prevPaths.join('/') || '/', primaryValue: entity.primaryValue });
                paths.push(entity.primaryValue);
                paths.push(prop);
                if (flag === false) {
                    flag = true;
                    nextPrevPaths.push(prop);
                }
                const nextBindingPaths = bindingPaths.slice(1);
                this.effectRows(entityList.items, nextBindingPaths, propertyNames, callback, currentRows, nextPrevPaths, paths);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}
StateValueChangedEventHandler.decorators = [
    { type: Injectable }
];

class RepositoryAddEntityEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     * @description 不支持主表直接依赖子表属性的情况，只能聚合子表的字段
     */
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}
RepositoryAddEntityEventHandler.decorators = [
    { type: Injectable }
];

class RepositoryRemoveEntityEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     */
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
    }
}
RepositoryRemoveEntityEventHandler.decorators = [
    { type: Injectable }
];

class RepositoryLoadEventHandler extends EventHandler {
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}
RepositoryLoadEventHandler.decorators = [
    { type: Injectable }
];

class EntityUpdateEventHandler extends EventHandler {
    filter(event) {
        return this.expressionObjects.filter((expressionObject) => {
            // 重新加载实体时不计算计算表达式，只处理只读、必填等
            if (expressionObject.ns !== event.ns || !expressionObject.deps || expressionObject.deps.length === 0 || expressionObject.type === Expression$1.ExpressionType.Compute || expressionObject.type === Expression$1.ExpressionType.Dependency || expressionObject.type === Expression$1.ExpressionType.DataPicking) {
                return false;
            }
            const result = this.analysis(event, expressionObject);
            if (!result) {
                return false;
            }
            // 必须是主表表达式
            if (result.expressionTablePaths.length !== 0) {
                return false;
            }
            const index = expressionObject.deps.findIndex((dep) => {
                if (!dep.startsWith(ENTITY_TEMPLATE)) {
                    return false;
                }
                const deps = dep.split(Expression$1.DEPENDENCY_SPLITER).filter(p => p).slice(1);
                const depPathInfo = this.getPathInfo(deps.join('/'));
                if (!depPathInfo) {
                    return false;
                }
                if (depPathInfo.paths.length !== 0) {
                    return false;
                }
                return true;
            });
            return index === -1 ? false : true;
        });
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, result);
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    getCurrentRowByEvent(paths, event) {
        let result = null;
        const bindingList = this.bindingData.getValue(paths);
        const eventEntityPath = this.getEntityPath(event.path);
        if (bindingList && bindingList.length > 0) {
            let primaryValue = bindingList.currentItem.primaryKeyValue || null;
            // 使用事件中的主键
            const childrenPaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(eventEntityPath, this.repository.entityTypeInfo);
            if (childrenPaths && childrenPaths.toString() === paths.toString()) {
                // 发生值变化的数据位于要获取当前行的子表中，此时事件行应该是发生值变化的数据id，而不是当前行id
                primaryValue = event.id || null;
                if (!primaryValue) {
                    primaryValue = this.getEventId(event.path, paths[paths.length - 1]);
                }
            }
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
}
EntityUpdateEventHandler.decorators = [
    { type: Injectable }
];

class BindingDataAppendObjectEventHandler extends EventHandler {
    /**
     * 过滤出需要计算的表达式
     * @param event event
     * @returns
     */
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            // const fullEventPath = event.path || [];
            // event.path like ["id:7dd77e50-ebed-4639-b483-d12004603640", "formEEUR1E1s"] or undefined or []
            // eventTablePaths like [] or ["子表s"]
            // 找到聚合相关表达式(依赖新增表的表达式),聚合的前提是表达式path位于事件路径的上方
            // 给实体属性或vo变量设置了聚合相关的表达式，此时表达式依赖中路径到子表属性
            const groupExpressions = this.expressionObjects.filter((expressionObject) => {
                if (expressionObject.ns !== event.ns || !expressionObject.deps || expressionObject.deps.length < 1) {
                    return false;
                }
                const eventTablePaths = this.buildEntityPath(event.path);
                const info = this.analysis(event, expressionObject);
                if (!info) {
                    return false;
                }
                // const eventEntityPath = this.buildEntityPath(event.path);
                // 主表新增
                if (eventTablePaths.length === 0) {
                    if (expressionObject.bindingType === Expression$1.ExpressionBindingType.Field) {
                        // 认为主表新增时不需要处理聚合函数
                        return false;
                    }
                }
                // 从表或从从表新增
                eventTablePaths.splice(0, 0, ENTITY_TEMPLATE);
                // eventEntityPath like ['ENTITY~','formEEUR1E1s'] // 从表新增
                // deps like ['ENTITY~/formEEUR1E1s/udt/udt_field','ENTITY~/formEEUR1E1s/ref/ref_udt/ref_udt_field']
                // 仅处理上级表达式
                if (info.eventTablePaths.length - 1 !== info.expressionTablePaths.length) {
                    return false;
                }
                // 不支持跨表
                if (!info.eventTablePaths.join(Expression$1.DEPENDENCY_SPLITER).startsWith(info.expressionTablePaths.join(Expression$1.DEPENDENCY_SPLITER))) {
                    return false;
                }
                const index = expressionObject.deps.findIndex((dep) => {
                    // 依赖
                    if (!dep.startsWith(eventTablePaths.join(Expression$1.DEPENDENCY_SPLITER))) {
                        return false;
                    }
                    const deps = dep.split(Expression$1.DEPENDENCY_SPLITER).filter(p => p).slice(1);
                    const dependPathInfo = this.getPathInfo(deps.join(Expression$1.DEPENDENCY_SPLITER));
                    if (dependPathInfo && dependPathInfo.paths.join(Expression$1.DEPENDENCY_SPLITER) === info.eventTablePaths.join(Expression$1.DEPENDENCY_SPLITER)) {
                        return true;
                    }
                    return false;
                });
                return index === -1 ? false : true;
            });
            const eventTablePaths = this.buildEntityPath(event.path);
            // 事件表中表达式（事件表本身的表达式）
            const relativeExpressions = this.expressionObjects.filter((expressionObject) => {
                // expressionObject.bindingType !== Expression.ExpressionBindingType.Field 暂不支持State表达式
                if (expressionObject.ns !== event.ns) {
                    return false;
                }
                const expressionPathInfo = this.getPathInfo(expressionObject.path);
                // 过滤掉非当前表的表达式
                if (expressionPathInfo.paths.join(Expression$1.DEPENDENCY_SPLITER) !== eventTablePaths.join(Expression$1.DEPENDENCY_SPLITER)) {
                    return false;
                }
                // 表达式是计算或依赖表达式并且是分层加载场景，不计算，仅当依赖变化时计算
                if ((expressionObject.type === Expression$1.ExpressionType.Compute || expressionObject.type === Expression$1.ExpressionType.Dependency) && event.isTreeNodeLoadScene) {
                    return false;
                }
                // 没有依赖的表达式
                if (!expressionObject.deps || expressionObject.deps.length < 1) {
                    return true;
                }
                // 仅依赖State
                const onlyDependOnState = expressionObject.deps.every((dep) => dep.startsWith(STATE_TEMPLATE));
                // 仅依赖当前表或上级表
                // const onlyDependOnCurrentTable = expressionObject.deps.every((dep: string) => {
                //   if (!dep.startsWith(ENTITY_TEMPLATE)) {
                //     return false;
                //   }
                //   const deps = dep.split(Expression.DEPENDENCY_SPLITER).slice(1);
                //   const dependPathInfo = this.getPathInfo(deps.join(Expression.DEPENDENCY_SPLITER));
                //   return dependPathInfo.paths.join(Expression.DEPENDENCY_SPLITER) === eventTablePaths.join(Expression.DEPENDENCY_SPLITER) || eventTablePaths.join(Expression.DEPENDENCY_SPLITER).startsWith(dependPathInfo.paths.join(Expression.DEPENDENCY_SPLITER)) && dependPathInfo.paths.length + 1 == eventTablePaths.length;
                // });
                // if (onlyDependOnState || onlyDependOnCurrentTable) {
                //   return true;
                // }
                if (onlyDependOnState) {
                    return true;
                }
                const result = this.analysis(event, expressionObject);
                if (result && result.distance === 0 && result.isSameTable) {
                    return true;
                }
                // 事件表表达式，但依赖下级表的未计算
                return false;
            });
            // 依赖当前加载数据的表达式
            const depExpressions = this.expressionObjects.filter((expressionObject) => {
                if (expressionObject.ns !== event.ns || !expressionObject.deps || expressionObject.deps.length < 1 || (expressionObject.type !== Expression$1.ExpressionType.Visible && expressionObject.type !== Expression$1.ExpressionType.Required && expressionObject.type !== Expression$1.ExpressionType.Validate)) {
                    return false;
                }
                // 过滤出所有实体依赖
                const deps = expressionObject.deps.filter((dep) => dep.startsWith(ENTITY_TEMPLATE));
                if (!deps || deps.length < 1) {
                    return false;
                }
                const result = this.analysis(event, expressionObject);
                if (!result) {
                    return false;
                }
                // 表达式依赖了字段，需要确认依赖的字段所在的表是否是事件表
                // 1、计算事件表路径
                const eventPath = event.path.filter(p => p).join('/');
                // 2、获取依赖字段的表路径
                const index = deps.findIndex((dep) => {
                    // 去掉ENTITY~前缀
                    const depPath = dep.split('/').slice(1).join('/');
                    // 获取依赖字段所在的表路径
                    const { path } = this.getPathInfo(depPath);
                    return path === eventPath;
                });
                return index !== -1;
            });
            return groupExpressions.concat(relativeExpressions, depExpressions);
        }
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, result);
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
    /**
     * 新增副作用器
     * @param event event
     * @param expressionObject 表达式
     * @returns
     */
    effect(event, expressionObject) {
        const effectTo = expressionObject.bindingType;
        const eventPath = this.cleanEventPath(event.path);
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            return;
        }
        const info = this.analysis(event, expressionObject);
        if (!info) {
            return;
        }
        const expressionPaths = expressionObject.path.split('/').filter(p => p);
        if (effectTo === Expression$1.ExpressionBindingType.Field) {
            const paths = [];
            const propertyPaths = expressionPaths.slice(info.expressionTablePaths.length);
            // 新增场景需要计算事件表\事件表上面的表\下层表的可见、必填、校验
            if (info.distance === 0) {
                if (!info.isSameTable) {
                    return;
                }
                // 表达式和事件在同一个表
                const prevPaths = eventPath.slice(0);
                if (eventPath.length === 1) {
                    // 主表新增，此时事件路径中有主键，直接拼接属性就是完整路径
                    if (event.value && Array.isArray(event.value)) {
                        event.value.forEach((bindingObject) => {
                            paths.push([bindingObject.primaryKeyValue].concat(propertyPaths));
                        });
                    }
                    else {
                        const path = prevPaths.concat(propertyPaths);
                        paths.push(path);
                    }
                }
                else {
                    // 从表或从从表新增，此时事件路径中缺少最后一个层级的主键
                    if (event.value && Array.isArray(event.value)) {
                        event.value.forEach((bindingObject) => {
                            paths.push(prevPaths.concat([bindingObject.primaryKeyValue]).concat(propertyPaths));
                        });
                    }
                    else {
                        const bindingList = this.bindingData.getValue(info.eventTablePaths);
                        if (bindingList && bindingList.currentId) {
                            paths.push(prevPaths.concat(bindingList.currentId).concat(propertyPaths));
                        }
                    }
                }
            }
            else {
                // 表达式和事件不在同一个表，即下级表新增或批量新增了一批数据
                if (info.eventFromParent === true) {
                    // 仅处理下级表，跨表跳过
                    if (info.expressionTablePaths.length > 1) {
                        return;
                    }
                    // 下层表的可见、必填、校验
                    let prevPaths = eventPath.slice(0, eventPath.length);
                    // 子表新增
                    if (eventPath && eventPath.length > 0) {
                        prevPaths = eventPath.slice(0, eventPath.length);
                    }
                    else {
                        // 主表新增
                        prevPaths = [this.bindingData.list.currentId, info.expressionTablePaths[0], null];
                    }
                    const path = prevPaths.concat(propertyPaths);
                    paths.push(path);
                }
                else if (info.eventFromChildren === true) {
                    const prevPaths = eventPath.slice(0, eventPath.length - 1);
                    const path = prevPaths.concat(propertyPaths);
                    paths.push(path);
                }
                else {
                    return;
                }
            }
            paths.forEach((path) => {
                const currentRows = this.buildCurrentRows(info.expressionTablePaths, path);
                this.output(event, expressionObject, currentRows, effector, [path]);
            });
        }
        else if (effectTo === Expression$1.ExpressionBindingType.State) {
            console.error('not supported！');
        }
    }
    output(event, expressionObject, currentRows, effector, paths) {
        const context = this.buildContext(expressionObject, event, null, currentRows);
        const value = this.perform(expressionObject, context);
        if (value === undefined) {
            return;
        }
        expressionObject.result = value;
        if (expressionObject.id) {
            this.expressionResult.set(expressionObject.id, expressionObject.result);
        }
        EffectorManager.effect(effector, expressionObject, paths);
    }
}
BindingDataAppendObjectEventHandler.decorators = [
    { type: Injectable }
];

class BindingDataValueChangeEventHandler extends EventHandler {
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            return this.expressionObjects.filter((expressionObject) => {
                const deps = expressionObject.deps;
                if (!deps || deps.length < 1 || event.ns !== expressionObject.ns) {
                    return false;
                }
                const eventEntityPaths = this.getEntityPath(event.path);
                eventEntityPaths.splice(0, 0, ENTITY_TEMPLATE);
                return deps.includes(eventEntityPaths.join('/'));
            });
        }
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 输出副作用
     * @param event event
     * @param expressionObject 表达式
     * @returns
     */
    effect(event, expressionObject) {
        // 首先计算当前表达式和事件会影响那些路径
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            return;
        }
        const result = this.analysis(event, expressionObject);
        if (!result) {
            return;
        }
        const eventPaths = this.cleanEventPath(event.path);
        const paths = [];
        if (result.distance === 0) {
            // 值变化之后影响到了一个表内字段或影响到了同级表字段
            if (result.isSameTable === false) {
                // 同级表跳过
                //console.warn(`[BindingDataValueChangeEventHandler]不支持多对多关系。`);
                return;
            }
            const prevPaths = eventPaths.slice(0, eventPaths.length - result.eventPropertyNames.length);
            const path = prevPaths.concat(result.expressionPropertyNames);
            const currentRows = this.buildCurrentRows(result.eventTablePaths, path);
            paths.push(path);
            this.output(event, expressionObject, currentRows, effector, paths);
        }
        else {
            if (result.eventFromChildren === true) {
                if (result.distance > 1) {
                    return;
                }
                // 下级表值变化影响到了上级表的表达式
                const prevPaths = eventPaths.slice(0, eventPaths.length - result.eventPropertyNames.length - 2);
                const path = prevPaths.concat(result.expressionPropertyNames);
                paths.push(path);
                const currentRows = this.buildCurrentRows(result.eventTablePaths, eventPaths);
                this.output(event, expressionObject, currentRows, effector, paths);
            }
            else if (result.eventFromParent === true) {
                if (result.distance > 1) {
                    //console.warn(`[BindingDataValueChangeEventHandler]不支持多对多关系。`);
                    return;
                }
                // 上级表值变化影响到了下级表的表达式
                const prevPaths = eventPaths.slice(0, eventPaths.length - result.eventPropertyNames.length);
                // 添加下级表nodecode到路径中
                prevPaths.push(result.expressionTablePaths.slice(0).pop());
                // 遍历子表
                const bindingPaths = result.expressionTablePaths;
                const primaryKeyValue = eventPaths[0];
                if (!primaryKeyValue) {
                    return;
                }
                let object = this.frameContext.repository.entityCollection.getEntityById(primaryKeyValue);
                // prevPaths like [1,c,1.1,cc]
                for (let index = 1; index < prevPaths.length; index++) {
                    const propertyName = prevPaths[index];
                    if (object instanceof EntityList) {
                        object = object.get(propertyName);
                    }
                    else {
                        object = object[propertyName];
                    }
                }
                const list = object;
                if (list && list instanceof EntityList) {
                    if (list.count() === 0) {
                        if (expressionObject.type === Expression$1.ExpressionType.Visible || expressionObject.type === Expression$1.ExpressionType.Required) {
                            const context = this.buildContext(expressionObject, event);
                            const value = this.perform(expressionObject, context);
                            if (value === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                                return;
                            }
                            expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, value);
                            if (expressionObject.id) {
                                this.expressionResult.set(expressionObject.id, expressionObject.result);
                            }
                            super.effect(event, expressionObject);
                        }
                    }
                    else {
                        for (let entity of list) {
                            if (entity && entity.primaryValue) {
                                const path = prevPaths.concat([entity.primaryValue]).concat(result.expressionPropertyNames);
                                const currentRows = this.buildCurrentRows(result.expressionTablePaths, path);
                                this.output(event, expressionObject, currentRows, effector, [path]);
                            }
                        }
                    }
                }
            }
        }
    }
    output(event, expressionObject, currentRows, effector, paths) {
        const context = this.buildContext(expressionObject, event, null, currentRows);
        const value = this.perform(expressionObject, context);
        if (value === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
            return;
        }
        expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, value);
        if (expressionObject.id) {
            this.expressionResult.set(expressionObject.id, expressionObject.result);
        }
        EffectorManager.effect(effector, expressionObject, paths);
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        event = JSON.parse(JSON.stringify(event));
        let result = null;
        const bindingList = this.bindingData.getValue(paths);
        const eventEntityPath = this.getEntityPath(event.path);
        if (bindingList && bindingList.length > 0) {
            let primaryValue = bindingList.currentItem.primaryKeyValue || null;
            // 使用事件中的主键
            const childrenPaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(eventEntityPath, this.repository.entityTypeInfo);
            if (childrenPaths && childrenPaths.toString() === paths.toString()) {
                // 发生值变化的数据位于要获取当前行的子表中，此时事件行应该是发生值变化的数据id，而不是当前行id
                primaryValue = event.id || null;
                if (!primaryValue) {
                    primaryValue = this.getEventId(event.path, paths[paths.length - 1]);
                }
            }
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
}
BindingDataValueChangeEventHandler.decorators = [
    { type: Injectable }
];

/**
 * 删除数据时需要计算的表达式
 * 1、依赖被删除数据表的上级表达式（不考虑同表内的聚合依赖）
 */
class BindingDataRemoveObjectEventHandler extends EventHandler {
    /**
     * 过滤出需要计算的表达式
     * @param event event
     * @returns
     */
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            // 找到聚合相关表达式
            const expressions = this.expressionObjects.filter((expressionObject) => {
                if (expressionObject.ns !== event.ns || !expressionObject.deps || expressionObject.deps.length < 1) {
                    return false;
                }
                const info = this.analysis(event, expressionObject);
                if (!info) {
                    return false;
                }
                // event.path like [id:xxxx] or [id:xxxx,子表s]
                const eventTablePaths = this.buildEntityPath(event.path);
                // 主表删除
                if (eventTablePaths.length === 0) {
                    if (expressionObject.bindingType === Expression$1.ExpressionBindingType.Field) {
                        return false;
                    }
                }
                // 从表或从从表删除
                eventTablePaths.splice(0, 0, ENTITY_TEMPLATE);
                // eventEntityPath like ['ENTITY~','formEEUR1E1s'] // 从表新增
                // deps like ['ENTITY~/formEEUR1E1s/udt/udt_field','ENTITY~/formEEUR1E1s/ref/ref_udt/ref_udt_field']
                // 仅处理上级表达式
                if (info.eventTablePaths.length - 1 !== info.expressionTablePaths.length) {
                    return false;
                }
                // 不支持跨表
                if (!info.eventTablePaths.join(Expression$1.DEPENDENCY_SPLITER).startsWith(info.expressionTablePaths.join(Expression$1.DEPENDENCY_SPLITER))) {
                    return false;
                }
                const index = expressionObject.deps.findIndex((dep) => {
                    // 依赖
                    if (!dep.startsWith(eventTablePaths.join(Expression$1.DEPENDENCY_SPLITER))) {
                        return false;
                    }
                    const deps = dep.split(Expression$1.DEPENDENCY_SPLITER).filter(p => p).slice(1);
                    const dependPathInfo = this.getPathInfo(deps.join(Expression$1.DEPENDENCY_SPLITER));
                    if (dependPathInfo && dependPathInfo.paths.join(Expression$1.DEPENDENCY_SPLITER) === info.eventTablePaths.join(Expression$1.DEPENDENCY_SPLITER)) {
                        return true;
                    }
                    return false;
                });
                return index === -1 ? false : true;
            });
            return expressions;
        }
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, result);
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 删除副作用器
     * @param event event
     * @param expressionObject 表达式
     * @returns
     */
    effect(event, expressionObject) {
        const effectTo = expressionObject.bindingType;
        const eventPath = this.cleanEventPath(event.path);
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            return;
        }
        const info = this.analysis(event, expressionObject);
        if (!info) {
            return;
        }
        const expressionPaths = expressionObject.path.split('/').filter(p => p);
        if (effectTo === Expression$1.ExpressionBindingType.Field) {
            const paths = [];
            const propertyPaths = expressionPaths.slice(info.expressionTablePaths.length);
            // 删除场景仅需要计算事件表上面的表
            if (info.distance !== 0) {
                // 表达式和事件不在同一个表，即下级表删除了一批数据
                if (info.eventFromParent === true) {
                    // 在过滤时这种情况的应该就排除掉了
                    return;
                }
                else if (info.eventFromChildren === true) {
                    const prevPaths = eventPath.slice(0, eventPath.length - 1);
                    const path = prevPaths.concat(propertyPaths);
                    paths.push(path);
                }
                else {
                    return;
                }
            }
            EffectorManager.effect(effector, expressionObject, paths);
        }
        else if (effectTo === Expression$1.ExpressionBindingType.State) {
            console.error('not supported！');
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}
BindingDataRemoveObjectEventHandler.decorators = [
    { type: Injectable }
];

class BindingDataLoadEventHandler extends EventHandler {
    filter(event) {
        // 过滤第一次空load
        if ((!event.path || event.path.length === 0) && event.value && Array.isArray(event.value) && event.value.length === 0) {
            return null;
        }
        // 数据加载完成后需要计算当前绑定路径下的只读、显隐、必填、校验表达式
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            const expressions = this.expressionObjects.filter((expressionObject) => {
                if (expressionObject.ns !== event.ns || (expressionObject.type !== Expression$1.ExpressionType.Readonly && expressionObject.type !== Expression$1.ExpressionType.Visible && expressionObject.type !== Expression$1.ExpressionType.Required && expressionObject.type !== Expression$1.ExpressionType.Validate)) {
                    return false;
                }
                const result = this.analysis(event, expressionObject);
                if (!result) {
                    return false;
                }
                // 影响一个表达式是否要计算的因子有两个：表达式作用的字段、表达式的依赖
                // 以下判断的前提时数据加载场景！！
                // 1、表达式作用的字段
                //    如果加载的数据对应的表就是表达式字段所在的表，应该计算
                // 2、表达式依赖
                //    如果表达式依赖的字段加载了，应该计算
                //    如果表达式没有任何依赖，应该计算
                if (result.isSameTable) {
                    return true;
                }
                // 如果没有依赖则应该计算，保证只读、必填、显隐、校验表达式结果正确
                if (!expressionObject.deps || expressionObject.deps.length === 0) {
                    return true;
                }
                // 过滤出所有实体依赖
                const deps = expressionObject.deps.filter((dep) => dep.startsWith(ENTITY_TEMPLATE));
                // 未依赖实体，只依赖了uistate，那么绑定数据加载时不需要计算
                if (!deps || deps.length < 1) {
                    return false;
                }
                // 表达式依赖了字段，需要确认依赖的字段所在的表是否是事件表
                // 1、计算事件表路径
                const eventTablePath = this.buildEntityPath(event.path).join('/');
                // 2、获取依赖字段的表路径
                const index = deps.findIndex((dep) => {
                    // 去掉ENTITY~前缀
                    const depPath = dep.split('/').slice(1).join('/');
                    // 获取依赖字段所在的表路径
                    const { path } = this.getPathInfo(depPath);
                    return path === eventTablePath;
                });
                return index !== -1;
            });
            return expressions;
        }
        else {
            return null;
        }
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, result);
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}
BindingDataLoadEventHandler.decorators = [
    { type: Injectable }
];

class BindingDataSelectionChangedEventHandler extends EventHandler {
    /**
     * 过滤出需要计算的表达式
     * @param event event
     * @returns
     */
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            return this.expressionObjects.filter((expressionObject) => {
                const deps = expressionObject.deps;
                // 没有依赖的表达式不需要关注
                if (!deps || deps.length < 1) {
                    return false;
                }
                // 不依赖实体的表达式不需要关注
                let index = deps.findIndex(dep => dep.startsWith(ENTITY_TEMPLATE));
                if (index === -1) {
                    return false;
                }
                const result = this.analysis(event, expressionObject);
                if (!result) {
                    return false;
                }
                // 只关注从表行切换
                if (result.eventTablePaths.length !== 1) {
                    return false;
                }
                // 只关注从从表表达式
                if (result.expressionTablePaths.length !== 2) {
                    return false;
                }
                // 只关注事件直接下级的表达式，跨表的不需要关注
                if (!result.expressionTablePaths.join('/').startsWith(result.eventTablePaths.join('/'))) {
                    return false;
                }
                // 从从表表达式需要依赖上级表
                index = deps.findIndex(dep => dep.startsWith(`${ENTITY_TEMPLATE}/${result.eventTablePaths[0]}`));
                if (index === -1) {
                    return false;
                }
                return true;
            });
        }
        return null;
    }
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = this.convertBooleanTypeExpressionResult(expressionObject, result);
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
}
BindingDataSelectionChangedEventHandler.decorators = [
    { type: Injectable }
];

class EventHandlerRegistry {
    constructor(handlers) {
        this.handlers = handlers;
    }
    /**
     * 实体值变化处理器
     */
    get entityValueChangedEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof EntityValueChangedEventHandler);
    }
    /**
     * 状态值变化处理器
     */
    get stateValueChangedEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof StateValueChangedEventHandler);
    }
    get repositoryAddEntityEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof RepositoryAddEntityEventHandler);
    }
    get repositoryRemoveEntityEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof RepositoryRemoveEntityEventHandler);
    }
    get entityUpdateEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof EntityUpdateEventHandler);
    }
    get repositoryLoadEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof RepositoryLoadEventHandler);
    }
    get bindingDataAppendEntityEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataAppendObjectEventHandler);
    }
    get bindingDataValueChangeEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataValueChangeEventHandler);
    }
    get bindingDataRemoveObjectEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataRemoveObjectEventHandler);
    }
    get bindingDataLoadEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataLoadEventHandler);
    }
    get bindingDataSelectionChangedHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataSelectionChangedEventHandler);
    }
}
EventHandlerRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EventHandlerRegistry.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [EVENT_HANDLER_TOKEN,] }] }
];

class ExpressionEngineImpl {
    constructor(injector, expressionRegistry, expressionEventEmitter, resolverRegistry, eventHandlerRegistry, resolveService) {
        this.injector = injector;
        this.expressionRegistry = expressionRegistry;
        this.expressionEventEmitter = expressionEventEmitter;
        this.resolverRegistry = resolverRegistry;
        this.eventHandlerRegistry = eventHandlerRegistry;
        this.resolveService = resolveService;
        this.expressionObjects = new Array();
        this.expressionRegistry.expressions.subscribe((exprs) => {
            if (exprs && exprs.length > 0) {
                this.expressionObjects = exprs;
                // 解析表达式依赖
                this.resolveDependency();
            }
            this.attachEvent();
        });
    }
    attachEvent() {
        this.expressionEventEmitter.attach().subscribe((events) => {
            if (!events || events.length < 1 || !this.expressionObjects || this.expressionObjects.length < 1) {
                return;
            }
            events.forEach((event) => {
                const handler = this.getEventHandler(event);
                if (handler) {
                    handler.handleEvent(event, this.expressionObjects);
                }
                else {
                    Core.warn(`没有对应的事件处理器,event=${event.type}`);
                }
            });
        });
    }
    /**
     * 解析表达式依赖
     * @returns
     */
    resolveDependency() {
        if (!this.resolverRegistry || !this.resolverRegistry.resolvers || this.resolverRegistry.resolvers.length < 1 || !this.expressionObjects || this.expressionObjects.length < 1 || !Array.isArray(this.expressionObjects)) {
            return;
        }
        this.expressionObjects.forEach((expressionObject) => {
            const expression = expressionObject.expression;
            const dependencies = this.resolveService.resolve(expression);
            expressionObject.deps = dependencies;
        });
    }
    /**
     * 获取表达式事件处理器
     * @param event event
     * @returns
     */
    getEventHandler(event) {
        if (event.type === Expression$1.EventType.ValueChanged) {
            // 实体值变化
            if (event.source === Expression$1.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataValueChangeEventHandler;
            }
            else if (event.source === Expression$1.EventSource.Field) {
                return this.eventHandlerRegistry.entityValueChangedEventHandler;
            }
            else if (event.source === Expression$1.EventSource.State) {
                return this.eventHandlerRegistry.stateValueChangedEventHandler;
            }
        }
        else if (event.type === Expression$1.EventType.Append) {
            if (event.source === Expression$1.EventSource.Repository || event.source === Expression$1.EventSource.Field) {
                return this.eventHandlerRegistry.repositoryAddEntityEventHandler;
            }
            else if (event.source === Expression$1.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataAppendEntityEventHandler;
            }
        }
        else if (event.type === Expression$1.EventType.Remove) {
            if (event.source === Expression$1.EventSource.Repository || event.source === Expression$1.EventSource.Field) {
                return this.eventHandlerRegistry.repositoryRemoveEntityEventHandler;
            }
            else if (event.source === Expression$1.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataRemoveObjectEventHandler;
            }
        }
        else if (event.type === Expression$1.EventType.Update) {
            if (event.source === Expression$1.EventSource.Repository) {
                return this.eventHandlerRegistry.entityUpdateEventHandler;
            }
        }
        else if (event.type === Expression$1.EventType.Load) {
            if (event.source === Expression$1.EventSource.Repository || event.source === Expression$1.EventSource.Field) {
                return this.eventHandlerRegistry.repositoryLoadEventHandler;
            }
            else if (event.source === Expression$1.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataLoadEventHandler;
            }
        }
        else if (event.type === Expression$1.EventType.SelectionChanged) {
            if (event.source === Expression$1.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataSelectionChangedHandler;
            }
        }
        return null;
    }
}
ExpressionEngineImpl.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExpressionEngineImpl.ctorParameters = () => [
    { type: Injector },
    { type: ExpressionRegistry },
    { type: ExpressionEventEmitter },
    { type: ResolverRegistry },
    { type: EventHandlerRegistry },
    { type: ResolveService }
];

/**
 * 组件实例管理
 */
class ComponentRefManager {
    constructor() {
        this.components = new Map();
    }
    /**
     * 增加组件实例
     * @param id
     * @param component
     */
    add(id, component) {
        const components = this.components.get(id);
        if (components) {
            components.push(component);
        }
        else {
            this.components.set(id, [component]);
        }
    }
    /**
     * 删除组件实例
     * @param id
     */
    remove(id) {
        const components = this.components.get(id);
        if (components && components.length > 0) {
            components.length = 0;
            this.components.delete(id);
        }
    }
    /**
     * 通过id获取组件实例
     * @param id
     * @returns
     */
    get(id) {
        if (id) {
            const components = this.components.get(id);
            if (components && components.length > 0) {
                return components;
            }
        }
        return null;
    }
    /**
     * 是否包含id的组件
     * @param id
     * @returns
     */
    has(id) {
        return this.components.has(id);
    }
    /**
     * 清空
     */
    clear() {
        this.components.clear();
    }
    /**
     * 获取指定类型的组件
     * @param componentType
     * @returns
     */
    getComponentByType(componentType) {
        const containers = Array.from(this.components.values());
        let component = null;
        for (let containerIndex = 0; containers && containerIndex < containers.length; containerIndex++) {
            const components = containers[containerIndex];
            for (let index = 0; components && index < components.length; index++) {
                if (components[index] instanceof componentType) {
                    component = components[index];
                    break;
                }
            }
        }
        return component;
    }
}

/**
 * 组件上下文
 * @description
 * # 上下文
 * ## Overview
 *
 * 每个组件（FrameComponent）都有自己的上下文（FrameContext）,通过上下文可以获取控制器的所有属性，如常用的`frameId`、`BindingData`、`Repository`、`ViewModel`、`StateMachine`、 * `UIState`等。上下文在内存中呈树形结构，依附于FrameComponent。结构如下：
 *
 * ![image-20210806204755378](https://open.inspuronline.com/iGIX/assets/cloudplus/igix_2110/farris/devkit/guide/images/image-20210806204755378.png)
 *
 * 从上图我们可以看出每个上下文都有自己的`ViewModel`、`UIState`，那么如何确定一个命令在执行时用的是哪个上下文呢？其实无论命令在哪个地方被调用，上下文都是命令所在的组件的上下文。即，如果 * 命令挂载到了`detail-form-component`的视图模型，但命令最终被`root-component`上的按钮调用了，其上下文仍然是`detail-from-component`组件的上下文。之所以出现这种现象和Angular的依赖注 * 入密不可分，由于Angular在查找`provider`的时候总是从自己的组件开始向上找，如果在组件内部找到了则不再继续查找，如果找不到则会继续向上，如果查找到最上级依然找不到就会报`No provider  * for xx`错误。
 *
 * 既然如此，如果我们在`detail-form-component`中想要获取`root-component`中定义的变量（UIState）该如何做呢？答案是切换上下文，可以通过以下方式实现：
 *
 * ```typescript
 * // 方法1
 * const rootFrameContext = this.frameContext.root;
 * // 方法2
 * const rootFrameContext = this.frameContext.appContext.frameContextManager.getFrameContextById('root-component');
 * ```
 *
 * 通常在编写`Web构件`时先引入FrameContext，如：
 *
 * ```javascript
 * import {FrameContext,BindingData,Repository} from '@farris/devkit';
 *
 * constructor(private frameContext:FrameContext){}
 *
 * public method(){
 *     const bindingData: BindingData = this.frameContext.bindingData;
 *     const repository: Repository = this.frameContext.repository;
 * }
 * ```
 *
 * > `FrameContext`称为`ViewModelContext`更合适，可以理解为`MVVM`架构中`VM`的上下文。
 *
 * 控制器中亦存在`ViewModel`的概念。和`MVVM`架构中的的VM一致，所以也可以从`VM`访问常用的属性。如：
 *
 * ```typescript
 * import {BindingData,Repository,ViewModel} from '@farris/devkit';
 *
 * constructor(private viewModel:ViewModel){}
 *
 * public method(){
 *     const bindingData: BindingData = this.viewModel.bindingData;
 *     const repository: Repository = this.viewModel.repository;
 * }
 * ```
 *
 *
 *
 * ## 常用操作
 *
 * ### 获取当前上下文所属的组件
 *
 * ```typescript
 * this.frameContext.frameComponent;
 * ```
 *
 * ### 获取当前上下文的根上下文
 *
 * ```typescript
 * this.frameContext.root;
 * ```
 *
 * ### 获取当前上下文的appContext
 *
 * ```typescript
 * this.frameContext.appContext;
 * ```
 *
 * ### 获取指定frameId的上下文
 *
 * ```typescript
 * this.frameContext.appContext.frameContextManager.getFrameContextById('data-grid-component');
 * ```
 *
 * ### 获取表单所有上下文
 *
 * ```typescript
 * this.frameContext.appContext.frameContextManager.getFrameContexts();
 * ```
 *
 *
 *
 * ## 常用属性
 *
 * ### BindingData
 *
 * [参考]([浪潮企业云开放平台 (inspuronline.com)](https://open.inspuronline.com/iGIX/#/document/mddoc/igix-2103%2Ffarris%2Fdevkit%2Fguide%2F绑定数据.md))
 *
 * ### Repository
 *
 * [参考]([浪潮企业云开放平台 (inspuronline.com)](https://open.inspuronline.com/iGIX/#/document/mddoc/igix-2103%2Ffarris%2Fdevkit%2Fguide%2F仓库.md))
 *
 * ### ViewModel
 *
 * 控制器中ViewMode同MVVM架构中的VM，和FrameContext类似，可以通过ViewModel拿到FrameContext，同样的也可以通过FrameContext拿到ViewModel。
 *
 * ### namespace
 *
 * 命名空间，主要在组合表单场景用到，每一个表单都有自己的命名空间，被组合进来的表单其命名空间是相同的，如A表单组合了B表单，则B表单具有相同的命名空间，命名空间主要用于表单隔离。
 *
 * ### root
 *
 * 获取整个表单的根上下文
 *
 * ### uiState
 *
 * 获取当前组件的变量
 *
 * ### frameId
 *
 * 上下文标识。
 */
class FrameContext extends Context {
    /**
     * 构造函数
     * @param injector 注入器
     */
    constructor(injector, parent) {
        super();
        this.injector = injector;
        this.typeName = 'FrameContext';
        this.isDestoried = false;
        this.isDisposed = false;
        this.metadata = {
            identify: '',
            namespace: '',
            commands: null,
            form: null,
            formControls: null,
            subForms: null,
            stateMachine: null,
            uiStates: null,
            bindingTo: ''
        };
        /**
         * 组件引用管理
         */
        this.componentRefManager = new ComponentRefManager();
        /**
         * 启用后端变更检测
         */
        this.enableServerSideChangeDetection = false;
        // 在解析模式下，通过依赖注入获取不到AppContext时，返回null，在子类中进行赋值。
        this.appContext = injector.get(AppContext);
        this.destorySignal = new Subject();
        // 确定父子关系
        // 必须对appContext进行判断，原因如下：
        // 1、否则会导致动态路由表单中，被路由的表单的RootFrameContext变成主表单的RootFrameContext；
        // 2、进而导致从RootFrameContext上拿VO变量拿不到。
        if (!parent || parent.appContext !== this.appContext) { // 取消 appContext 的判断
            this.parent = null;
            this.root = this;
        }
        else {
            this.parent = parent;
            this.root = parent.root;
        }
        this.frameId = injector.get(FRAME_ID);
        if (this.appContext.contextMetadataManager.exsit(this.frameId)) {
            this.metadata = this.appContext.contextMetadataManager.getContextMetadataByName(this.frameId);
        }
        this.namespace = injector.get(NAMESPACE, null);
        this.bindingData = this.injector.get(BindingData, new BindingData());
        if (!this.appContext.useIsoluteEventBus || (this.appContext.useIsoluteEventBus && !this.appContext.isoluteEventBus)) {
            this.eventBus = this.injector.get(EventBus, null, InjectFlags.Optional);
        }
        else {
            this.eventBus = this.appContext.isoluteEventBus;
        }
        this.form = this.injector.get(Form, new Form());
        this.repository = this.injector.get(Repository, this.appContext.repository);
        // 获取变更集策略，默认只提交合法的变更
        const changeSetPolicy = this.injector.get(CHANGE_SET_POLICY_TOKEN, 'valid');
        if (this.repository) {
            this.repository.entityCollection.changeSetPolicy = changeSetPolicy;
        }
        this.enableServerSideChangeDetection = this.injector.get(ENABLE_SERVER_SIDE_CHANGE_DETECTION_TOKEN, false);
        this.uiState = this.injector.get(UIState, new UIState());
        const defaultViewModel = new ViewModel();
        defaultViewModel.setMetadata(this.metadata);
        this.viewModel = this.injector.get(ViewModel, defaultViewModel);
        this.variableParseService = injector.get(VariableParseService, new VariableParseService([
            new FrameIdVariableParser(),
            new DataVariableParser(),
            new UIStateVariableParser(),
            new StateMachineVariableParser(),
            new CommandVariableParser()
        ]));
        // 注入exceptionHandler
        this.exceptionHandler = injector.get(EXCEPTION_HANDLER, null, InjectFlags.Optional);
        // 初始化多语服务
        const translate = injector.get(TranslateToken, null);
        this.translate = translate;
        TranslateService.setTranslate(translate);
        // 初始化用户配置
        const userSettings = injector.get(UserSettingsToken, null);
        UserSettingsService.setUserSettings(userSettings);
        this.initializeRepository();
        this.appContext.regFrameContext(this);
        this.registerAppContextDestroyEvent();
    }
    dispose(options) {
        if (this.isDisposed) {
            return;
        }
        this.isDestoried = true;
        this.isDisposed = true;
        if (this.destorySignal) {
            this.destorySignal.next();
            this.destorySignal.complete();
        }
        if (this.appContext) {
            this.appContext.frameContextManager.unregFrameContext(this);
            this.appContext.frameComponentRefresher.unregFrameContext(this);
        }
        if (this.appContext && this.isRootFrameContext() === true) {
            const viewModelNames = this['viewModelNames'];
            if (viewModelNames && Array.isArray(viewModelNames)) {
                viewModelNames.forEach(name => {
                    this[name] = null;
                });
            }
            this.appContext.unregisterFromManager();
        }
        if (this.bindingData) {
            this.bindingData.dispose();
            // this.bindingData = null;
        }
        if (this.viewModel) {
            this.viewModel.dispose();
        }
        if (this.form) {
            this.form.dispose();
            this.form = null;
        }
        if (this.commandBus) {
            this.commandBus.dispose();
            this.commandBus = null;
        }
        TranslateService.dispose();
        // this.root = null;
        // this.parent = null;
        // this.uiState = null;
        this.frameComponent = null;
        this.repository = null;
        // this.stateMachine = null;
        // this.appContext = null;
        this.exceptionHandler = null;
        this.expressionManager = null;
        this.expressionEngineImpl = null;
        this.variableParseService = null;
        this.eventBus = null;
        this.translate = null;
        this.injector = null;
        this.expressionResult = null;
        UserSettingsService.setUserSettings(null);
    }
    ngOnDestroy() {
        this.dispose();
    }
    /**
     * 通过组件标识获取对应的组件实例
     * @param id 组件标识
     * @returns
     */
    getComponentById(id) {
        const components = this.componentRefManager.get(id);
        if (components && components.length > 0) {
            const component = components[0];
            return component;
        }
        return null;
    }
    /**
     * 获取指定标识的所有组件
     * @param id 组件标识
     */
    getComponentsById(id) {
        return this.componentRefManager.get(id);
    }
    bindInjector(componentInjector) {
        this.injector = componentInjector;
    }
    // #region 初始化
    /**
     * 初始化
     * @todo:
     * 1、CommandHandler中的服务可能会注入Context，所以CommandHandler创建时必须已经存在ComponentContext
     * 2、ViewModel的buildCommands中会使用CommandBus，为了保证顺序，将ViewModel的创建也放在init中。
     */
    init(frameComponent) {
        this.frameComponent = frameComponent;
        this.initializeBindingData();
        this.initializeStateMachine();
        this.initializeUiState();
        this.initializeForm();
        this.initializeCommandBus();
        this.initializeViewModel();
        this.registerExceptionHandler();
        this.initExpression();
        this.appContext.frameComponentRefresher.regFrameComponent(this.frameId, this.frameComponent);
    }
    initExpression() {
        this.expressionEngineImpl = this.injector.get(ExpressionEngineImpl, null);
        this.expressionManager = this.injector.get(ExpressionManager, null);
        const expressionResultFactory = this.injector.get(ExpressionResultFactory, null);
        this.expressionResult = this.injector.get(ExpressionResult, null);
    }
    /**
     * 订阅异常消息
     */
    registerExceptionHandler() {
        // tslint:disable: no-string-literal
        const formAppContext = this.getFormAppContext();
        const applicationId = formAppContext.ApplicationId;
        window[window.location.href] = applicationId;
        if (this.exceptionHandler !== null) {
            const applicationContext = window[applicationId] = window[applicationId] || {};
            if (this.eventBus !== null && this.isRootFrameContext()) {
                applicationContext.isExceptionHandlerExist = true;
                this.exceptionHandler.setContext(this.appContext);
                this.eventBus.on('Exception', '', 'onException', formAppContext, (error) => {
                    if (this.isDestoried === true) {
                        return;
                    }
                    if (error && error.error) {
                        try {
                            error.error.__frame_context__ = this;
                        }
                        catch (_a) { }
                    }
                    this.exceptionHandler.handle(error);
                });
            }
            this.destorySignal.subscribe(() => {
                this.eventBus.off('Exception', '', 'onException', formAppContext);
            });
        }
    }
    registerAppContextDestroyEvent() {
        if (this.appContext && this.appContext.destorySignal) {
            this.appContext.destorySignal.subscribe((options) => {
                if (this.stateMachine) {
                    // 仅当菜单关闭时销毁
                    if (!(options && options.opportunity === DestroyOpportunity.AppContextDestroy)) {
                        this.stateMachine.dispose();
                        this.stateMachine = null;
                    }
                }
                if (this.repository) {
                    this.repository.dispose();
                }
            });
        }
    }
    /**
     * 获取表单appcontext，即最上层appcontext
     */
    getFormAppContext() {
        return this.appContext;
    }
    /**
     * 获取frameId
     * @description 获取完整的FrameId，在非普通表单中该值等于frameId，在组合表单中该值为namespace_frameId
     */
    getFrameId(relativeFrameId) {
        if (!relativeFrameId) {
            return this.frameId;
        }
        if (this.namespace && this.namespace.length > 0) {
            return `${this.namespace}_${relativeFrameId}`;
        }
        else {
            return relativeFrameId;
        }
    }
    /**
     * 初始化Repository
     */
    initializeRepository() {
        this.repository.setPaginationConfig(this.repository.paginationInfo);
    }
    initializeForm() {
        // 设置Form语言服务
        // this.form.setTranslateService(translateService);
        // 初始化Form，提取FormControl定义，添加FormControl
        // this.form.init(this.bindingData, this.metadata.bindingTo, this);
        // Form
        this.form = this.injector.get(Form, null);
        if (this.form) {
            // 设置Form语言服务
            this.form.setTranslateService(this.injector.get(TranslateToken, null));
            // 初始化Form，提取FormControl定义，添加FormControl
            const bindingPath = this.viewModel.bindingPath || this.metadata.bindingTo;
            this.form.init(this.bindingData, bindingPath, this);
        }
    }
    initializeStateMachine() {
        // StateMachine 状态机需要在绑定数据之后加载
        this.stateMachine = this.injector.get(StateMachine, null);
        if (this.stateMachine) {
            this.stateMachine.initialize(this, this.variableParseService);
        }
    }
    initializeCommandBus() {
        const handlerRegistry = this.injector.get(CommandHandlerRegistry, new CommandHandlerRegistry(this.metadata.commandHandlers));
        const extendsRegistry = this.injector.get(CommandHandlerExtenderRegistry, new CommandHandlerExtenderRegistry(this.metadata.commandHandlerExtends));
        const commandHandlerFactory = new CommandHandlerFactory(handlerRegistry, extendsRegistry, this, this.variableParseService);
        this.commandBus = new CommandBus(commandHandlerFactory);
    }
    /**
     * 初始化ViewModel
     * @todo
     * 1、需要按照一定的顺序进行初始化，否则依赖无法正确处理；
     * 2、暂时使用init解决Context和其他部分的循环依赖问题，待优化；
     */
    initializeViewModel() {
        if (!this.metadata.bindingTo) {
            this.metadata.bindingTo = this.viewModel.bindingPath;
        }
        this.viewModel.init(this);
        this.regViewModel(this.viewModel);
    }
    /**
     * 初始化BindingData
     * @summary
     * 老表单：repositoryName为空，复制当前Repository里的数据；
     * 新表单：repositoryName有值，引用全局BindingData里的数据；
     */
    initializeBindingData() {
        const repositoryName = this.repository.name;
        const isRunAtHighSpeedMode = this.appContext.runMode === RunMode.highSpeed;
        if (repositoryName && isRunAtHighSpeedMode) {
            const repositoryBindingData = this.appContext.bindingDataManager.getBindingDataByName(repositoryName);
            this.bindingData.initByBindingList(repositoryBindingData.list, this.viewModel.bindingPath);
            this.bindingData.pagingInfo = repositoryBindingData.pagingInfo;
            this.bindingData.setDataTypeInfo(this.repository.entityTypeInfo);
            EntityUtil.watchReposiroty(this.repository, this.bindingData);
        }
        else {
            this.bindingData.initByRepository(this.repository, this.viewModel.bindingPath);
            EntityUtil.watchReposiroty(this.repository, this.bindingData);
            this.bindingData.changes.subscribe((change) => {
                if (change.type === ChangeType.GlobalSelectionChanged) {
                    this.appContext.handleSelectChange(change, this);
                }
            });
        }
    }
    /**
     * 初始化UIState
     * 合并路由参数到UIState中
     */
    initializeUiState() {
        const isInFramework = window.location.href.indexOf('platform') > -1;
        const paramTypeTransform = this.injector.get(PARAM_TYPE_TRANSFORM_TOKEN, false);
        // 获取UIState
        this.uiState = this.injector.get(UIState, null);
        if (!this.uiState) {
            return;
        }
        this.uiState.paramTypeTransform = paramTypeTransform;
        this.uiState.initialize(this);
        // 获取路由参数
        const url = (this.appContext && this.appContext.router && this.appContext.router.url) || '';
        const routerParamService = new RouterParamService();
        const routerParams = routerParamService.getParams(url);
        // 在UIState为路由参数创建属性
        Object.keys(routerParams).forEach((propName) => {
            Object.defineProperty(this.uiState, propName, {
                get: () => {
                    return routerParams[propName];
                }
            });
        });
    }
    /**
     * 注册子ViewModel
     * @todo
     * 1、propName写死了
     */
    regViewModel(viewModel) {
        if (this.appContext && this.appContext.viewModelManager.exsit(viewModel.name) === false) {
            this.appContext.viewModelManager.register(viewModel.name, viewModel);
        }
        const className = viewModel.constructor.name;
        const parentContext = this.parent;
        let parentViewModel = null;
        if (parentContext && parentContext.viewModel) {
            parentViewModel = parentContext.viewModel;
        }
        if (!parentViewModel) {
            return;
        }
        // 优先使用生成器生成的name
        const childViewModels = parentViewModel['childViewModels'];
        let viewModelName = null;
        if (childViewModels) {
            const name = viewModel.constructor.name;
            viewModelName = childViewModels[viewModel.name] || childViewModels[name];
        }
        else if (className.length === 1) {
            const classNameTokens = viewModel.name.split('-').map((nameToken, index) => {
                if (index > 0 && nameToken.length) {
                    const pasicalName = nameToken.charAt(0).toLocaleUpperCase() + nameToken.substr(1, nameToken.length - 1);
                    return pasicalName;
                }
                else if (index === 0 && nameToken.length) {
                    const camelName = nameToken.charAt(0).toLocaleLowerCase() + nameToken.substr(1, nameToken.length - 1);
                    return camelName;
                }
                return nameToken;
            });
            viewModelName = classNameTokens.join('');
        }
        else if (viewModel["relateChildName"]) {
            // 增加该参数的目的  是为了解析表单可以进行和生成型相同的层级结构
            viewModelName = viewModel["relateChildName"];
        }
        // 兼容产品部老表单的写法，如果需要vm name统一，应按照此规则
        if (!viewModelName) {
            viewModelName = className[0].toLowerCase() + className.substring(1, className.length);
        }
        parentViewModel['viewModelNames'] = parentViewModel['viewModelNames'] || [];
        parentViewModel[viewModelName] = viewModel;
        parentViewModel['viewModelNames'].push(viewModelName);
        viewModel.bindToParent(parentViewModel);
    }
    // #endregion
    /**
     * 检查是否为根FrameContext
     * @summary
     * 检查该FrameContext是不是所在AppContext中的根FrameContext
     */
    isRootFrameContext() {
        return this.parent === null || (this.appContext.runMode === RunMode.highSpeed && this.getVirtualRootFrameContext().frameComponent['isDialogRootComponent'] === true);
    }
    /**
     * 通过namespace获取当前表单的root-framecontext(非整个表单)
     * @description
     * 如果为组合表单，其当前表单的root-framecontext为单个表单的framecontext，而非整个表单的framecontext
     */
    getVirtualRootFrameContext() {
        let formFrameContext = this;
        let parent = this.parent;
        while (parent) {
            // 兼容没有重新编译的表单，如果判断parent.namespace存在会导致获取不到root-framecontext
            if (parent.namespace === this.namespace) {
                formFrameContext = parent;
                parent = parent.parent;
            }
            else {
                break;
            }
        }
        return formFrameContext;
    }
    getContextById(identify) {
        return this.appContext.getContextById(identify);
    }
    getViewModel(viewModelName) {
        const renderAppContext = this.appContext;
        if (renderAppContext) {
            return renderAppContext.viewModelManager.getViewModelByName(viewModelName);
        }
        return null;
    }
    attachViewComponent(viewComponent) {
        this.frameComponent = viewComponent;
        this.appContext.frameComponentRefresher.regFrameComponent(this.frameId, this.frameComponent);
    }
    invoke(actionPath, $event) {
        const actionBindingPath = actionPath.split('.');
        const actionName = actionBindingPath[actionBindingPath.length - 1];
        const bindingViewModel = actionBindingPath.length === 1 ? this.viewModel :
            this.getViewModel(actionBindingPath[actionBindingPath.length - 2]);
        if (!bindingViewModel) {
            alert(`未匹配到'${actionPath}'命令的视图模型，请检查事件是否配置正确。`);
        }
        return bindingViewModel[actionName]($event);
    }
}
FrameContext.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrameContext.ctorParameters = () => [
    { type: Injector },
    { type: FrameContext, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

/*
 * @Author: Witt
 * @Date: 2019-03-12 14:59:22
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-06-15 17:26:07
 */
class FrameComponent {
    /**
     * 框架构造函数
     * @param injector 注入器
     */
    constructor(injector) {
        this.injector = injector;
        this.initialized = false;
        this.context = this.injector.get(FrameContext, null);
        if (this.context) {
            this.initialize();
        }
        this.destorySignal = new Subject();
        // this.context.init(this);
        // this.viewModel = this.context.viewModel;
        // this.cd = this.getChangeDetectorRef();
        // // 必须先执行context的初始化，然后再初始化Subscription
        // this.initPublicEvent();
        // this.initSubscription();
        // this.restComponent();
    }
    /**
     * 是否为表格组件
     * @description 返回true/false时可以信任，但如果返回的是undefined则不应信任
     * @warning 该属性依赖了生成代码，如果非标准的生成型工程也会导致判断失败。
     */
    get isGridComponent() {
        if (this.context && this.context.viewModel) {
            const dataGridColumnsName = this.context.viewModel['dataGridColumnsName'] || null;
            return dataGridColumnsName ? true : false;
        }
        return undefined;
    }
    dispose(options) {
        if (this.eventPipes) {
            this.eventPipes.forEach((eventPipe) => {
                eventPipe.disposeByCaller(this);
            });
        }
        this.cd = null;
        // this.viewModel = null;
        this.context.dispose();
        if (this.destorySignal) {
            this.destorySignal.next();
            this.destorySignal.complete();
        }
    }
    ngOnInit() {
        this.initialize();
    }
    initialize() {
        if (!this.initialized) {
            this.context.init(this);
            this.viewModel = this.context.viewModel;
            this.cd = this.getChangeDetectorRef();
            // 必须先执行context的初始化，然后再初始化Subscription
            this.initPublicEvent();
            this.initSubscription();
            this.restComponent();
            this.onFrameComponentInit();
            this.initialized = true;
        }
    }
    /**
     * 执行组件初始化
     */
    onFrameComponentInit() {
        const frameComponentInitHandlers = this.injector.get(FRAME_COMPONENT_INIT_HANDLER_TOKEN, null);
        if (frameComponentInitHandlers && Array.isArray(frameComponentInitHandlers) && frameComponentInitHandlers.length > 0) {
            frameComponentInitHandlers.forEach((handler) => {
                handler.onComponentInit(this.context);
            });
        }
    }
    /**
     * 获取变更检测器实例
     * @todo：应该通过注入获取，但注入会引起表单编译。
     */
    getChangeDetectorRef() {
        // const cd = this.get<ChangeDetectorRef>(ChangeDetectorRef, null, InjectFlags.Optional);
        const cd = this.injector.get(ChangeDetectorRef, null);
        return cd;
    }
    /**
     * 将当前组件脱离变更检测树
     */
    detach() {
        if (this.isCdValid() === false) {
            return;
        }
        this.cd.detach();
    }
    /**
     * 将当前组件重新加入变更检测树
     */
    reattach() {
        if (this.isCdValid() === false) {
            return;
        }
        this.cd.reattach();
    }
    /**
     * 对当前组件进行一次变更检查
     */
    detectChanges() {
        if (this.isCdValid() === false) {
            return;
        }
        this.cd.detectChanges();
    }
    /**
     * 检测ChangeDetection是否有效
     * @todo: Can't be depend on the destroyed property, destroyed.
     */
    isCdValid() {
        return this.cd && this.cd['destroyed'] === false || false;
    }
    /**
     * 重置组件状态
     * @todo：AppContext是全局的，
     */
    restComponent() {
        if (this.context !== this.context.root) {
            return;
        }
        // 1、如果AppContext不是root并且父AppContext也不是root不清理;
        // 2、表单Module里注入了FARRIS_DEVKIT_APP_PROVIDERS里面有一个冗余的AppContext注入
        //    导致所有AppContext的根是该冗余的AppContext，所以要检测parent.parent。
        // 只清理根组件的session
        if (this.context.appContext.parent !== null && this.context.appContext.parent.parent !== null) {
            return;
        }
        // Repository被注册到全局了，模块依赖注入中的对象，没有重置时机，临时在根组件中进行注销。
        // @todo：应该清理全部repository，目前缺少全局管理所有Repository的地方。
        this.context.repository.reset();
        // 重置组件绑定数据
        this.context.bindingData.reset();
    }
    ngOnDestroy() {
        this.dispose();
    }
    /**
     * 初始化事件订阅
     */
    initSubscription() {
        this.subscription = this.getSubscription();
        if (!this.subscription) {
            return;
        }
        this.eventPipes = this.subscription.init(this);
    }
    /**
     * 获取component对应的订阅
     * @returns
     */
    getSubscription() {
        return this.injector.get(Subscription, null);
    }
    initPublicEvent() {
        this.declaration = this.getDeclaration();
        if (!this.declaration) {
            return;
        }
        this.declaration.init(this);
    }
    /**
     * 获取当前component对应的declaration
     * @returns
     */
    getDeclaration() {
        return this.injector.get(Declaration, null);
    }
    /**
     * 事件触发器，触发事件发布
     * @param eventName 待发布事件
     */
    trigger(eventName, params) {
        const subscription = this.context.commandBus.executingCommandCount$.subscribe((executingCommandCount) => {
            if (executingCommandCount !== 0) {
                return;
            }
            this.innerTrigger(eventName, params);
            // @todo
            // subscription存在未undefine的情况，待进一步排查。
            if (subscription) {
                subscription.unsubscribe();
            }
            else {
                setTimeout(() => {
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }, 0);
            }
        });
    }
    /**
     * 内部触发变更检测
     */
    innerTrigger(eventName, params) {
        // 根据事件名，查找对应的事件处理器
        const eventHandler = this.declaration && this.declaration[eventName];
        if (!eventHandler) {
            return;
        }
        // 执行事件
        eventHandler(params);
    }
}
FrameComponent.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrameComponent.ctorParameters = () => [
    { type: Injector }
];

/**
 * 上下文事件
 */
class FrameEvent {
}

/**
 * 框架事件总线
 */
class FrameEventBus {
    constructor() {
        /**
         * 事件流
         */
        this.events = new Subject();
    }
    /**
     * 注册事件处理
     */
    on(eventType, eventHandler, frameId) {
        this.events.pipe(filter((event) => {
            if (event.type !== eventType) {
                return false;
            }
            return !event.frameIds || event.frameIds.indexOf(frameId) > -1;
        })).subscribe(eventHandler);
    }
    /**
     * 取消事件处理
     */
    off(eventType, frameId) {
        throw new Error('暂不实现');
    }
    /**
     * 触发事件
     */
    trigger(eventType, eventData, frameIds) {
        const event = {
            type: eventType,
            data: eventData,
            frameIds: frameIds
        };
        this.events.next(event);
    }
}
FrameEventBus.decorators = [
    { type: Injectable }
];

/**
 * 命令处理器工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理器工厂
 */
class CommandHandlerFactory {
    /**
     * 构造函数
     * @param handlerRegistry  命令处理注册器
     * @param extenderRegistry 命令处理扩展注册器
     */
    constructor(handlerRegistry, extenderRegistry, frameContext, variableParseService) {
        this.handlerRegistry = handlerRegistry;
        this.extenderRegistry = extenderRegistry;
        this.frameContext = frameContext;
        this.variableParseService = variableParseService;
    }
    /**
     * 创建命令处理器
     * @param   commandName 命令名称
     * @returns 对应的命令处理器实例
     */
    create(commandName) {
        const rawHandler = this.handlerRegistry.get(commandName);
        rawHandler.init(this.frameContext, this.variableParseService);
        const extenders = this.extenderRegistry.get(commandName);
        // 遍历extenders，依次对handler进行扩展
        return extenders.reduce((handler, extender) => {
            return extender.extend(handler);
        }, rawHandler);
    }
    dispose() {
        this.handlerRegistry.dispose();
        this.extenderRegistry.dispose();
        this.frameContext = null;
        this.variableParseService = null;
    }
}
CommandHandlerFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CommandHandlerFactory.ctorParameters = () => [
    { type: CommandHandlerRegistry },
    { type: CommandHandlerExtenderRegistry },
    { type: FrameContext },
    { type: VariableParseService }
];

/**
 * CommandBus相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * CommandBus用于派发Command，它接受一个Command实例，查找对应的CommandHandler，并执行。
 */
class CommandBus {
    /**
     * 构造函数
     */
    constructor(handlerFactory) {
        this.handlerFactory = handlerFactory;
        this.executingCommands = [];
        this.executingCommandCount$ = new BehaviorSubject(this.executingCommands.length);
    }
    /**
     * 派发命令
     * @param command 要派发的命令
     */
    dispatch(command) {
        const commandResult$ = new Subject();
        this.executeCommand(command).subscribe({
            next: (lastTaskResult) => {
                commandResult$.next(lastTaskResult);
                commandResult$.complete();
            },
            complete: () => {
                commandResult$.complete();
                this.removeCommandFromExecutingQueue(command);
            },
            error: (error) => {
                commandResult$.error(error);
                this.removeCommandFromExecutingQueue(command, !this.is401Error(error));
            }
        });
        return commandResult$;
    }
    /**
     * dispose
     */
    dispose() {
        this.handlerFactory.dispose();
    }
    /**
     * 执行命令并返回最后一个任务的执行结果流
     */
    executeCommand(command) {
        this.addCommandToExecutingQueue(command);
        const commandName = command.name;
        const handler = this.handlerFactory.create(commandName);
        const lastTaskResult$ = handler.execute(command);
        return lastTaskResult$;
    }
    /**
     * 添加到执行队列
     */
    addCommandToExecutingQueue(command) {
        this.executingCommands.push(command);
        this.executingCommandCount$.next(this.executingCommands.length);
    }
    /**
     * 从执行队列中移除
     */
    removeCommandFromExecutingQueue(command, postOrNot = true) {
        this.executingCommands = this.executingCommands.filter((executingCommand) => {
            return executingCommand !== command;
        });
        if (postOrNot === true) {
            this.executingCommandCount$.next(this.executingCommands.length);
        }
    }
    is401Error(error) {
        // 如果error为空，不认为是401错误
        return error && error.status === 401;
    }
}
CommandBus.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CommandBus.ctorParameters = () => [
    { type: CommandHandlerFactory }
];

const COMMAND_PROVIDERS = [
    CommandHandlerRegistry,
    CommandHandlerExtenderRegistry,
    CommandHandlerFactory,
    CommandBus,
];

/**
 * @Injectable()
 * @NgCommandHandler({
 *     commandName: 'add1'
 * })
 * export class add1Handler extends CommandHandler {
 *     constructor(
 *         public _ListDataService1: ListDataService1,
 *         public _StateMachineService1: StateMachineService1
 *     ) {
 *         super();
 *     }
 *
 *     schedule() {
 *         this.addTask('append', (context: CommandContext) => {
 *             const args = [];
 *             return this.invoke(this._ListDataService1, 'append', args, context);
 *         });
 *
 *         this.addTask('transit', (context: CommandContext) => {
 *             const args = [
 *                 'Create'
 *                     ];
 *             return this.invoke(this._StateMachineService1, 'transit', args, context);
 *         });
 *
 *         this.addLink('append', 'transit', `1==1`);
 *     }
 * }
 */
const controllerMap = {
    imports: {}
};
class DynamicCommandHandler extends CommandHandler {
    constructor(commandName, method) {
        super();
        this.commandName = commandName;
        this.method = method;
    }
    dynamicInvoke(serviceTocken, method, args, context) {
        const serviceInstance = context.frameContext.injector.get(serviceTocken, null);
        if (serviceInstance) {
            this.setContextToServiceInstance(serviceInstance, context);
            const parsedStageParams = this.parseService.parse(args, context);
            const parsedArgs = parsedStageParams.map(param => param.expression);
            // tslint:disable-next-line: ban-types
            const serviceMethod = serviceInstance[method];
            return serviceMethod.apply(serviceInstance, parsedArgs);
        }
    }
    dynamicInvoke2(methodObject, context) {
        const { source: serviceUri, service: serviceName, method } = methodObject;
        const args = methodObject.params.map(stageParam => {
            return Object.assign({}, stageParam);
        });
        const result$ = new Subject();
        const serviceSpecifer = serviceUri && serviceUri.toLowerCase();
        if (serviceSpecifer) {
            let serviceModule = controllerMap.imports[serviceSpecifer];
            if (serviceModule) {
                // 表示缓存中存在
                setTimeout(() => {
                    this.executeWithServiceModule(serviceModule, serviceName, context, args, method, result$);
                }, 0);
            }
            else {
                //  表示不存在
                System.import(serviceSpecifer)
                    .then((serviceModule) => {
                    if (serviceModule) {
                        controllerMap.imports[serviceSpecifer] = serviceModule;
                    }
                    this.executeWithServiceModule(serviceModule, serviceName, context, args, method, result$);
                });
            }
        }
        return result$;
    }
    executeWithServiceModule(serviceModule, serviceName, context, args, method, result$) {
        const serviceConstructor = serviceModule[serviceName];
        if (serviceConstructor) {
            const originalContextInjector = context.frameContext.injector;
            let serviceInstance;
            // const resolvedReflectiveProviders = ReflectiveInjector.resolve([{ provide: serviceName, useClass: serviceConstructor }]);
            if (context.frameContext.injector.get(serviceName, null)) {
                serviceInstance = context.frameContext.injector.get(serviceName);
            }
            else {
                const resolvedReflectiveProviders = this.loadProvidersFromModule(serviceModule);
                const reflectiveInjector = ReflectiveInjector.fromResolvedProviders(resolvedReflectiveProviders, context.frameContext.injector);
                context.frameContext.injector = reflectiveInjector;
                serviceInstance = reflectiveInjector.get(serviceName, null);
            }
            if (serviceInstance) {
                this.setContextToServiceInstance(serviceInstance, context);
                const parsedStageParams = this.parseService.parse(args, context);
                const parsedArgs = parsedStageParams.map(param => param.expression);
                // tslint:disable-next-line: ban-types
                const serviceMethod = serviceInstance[method];
                if (!serviceMethod) {
                    console.error("未找到对应的命令:" + method);
                    return;
                }
                const serviceMethodResult = serviceMethod.apply(serviceInstance, parsedArgs);
                const result$$ = isObservable(serviceMethodResult) ? serviceMethodResult : of(serviceMethodResult);
                result$$.subscribe({
                    next: (result) => {
                        result$.next(result);
                    },
                    error: (error) => {
                        result$.error(error);
                    },
                    complete: () => {
                        result$.complete();
                        context.frameContext.injector = originalContextInjector;
                    },
                });
                // return serviceMethod.apply(serviceInstance, parsedArgs);
            }
        }
    }
    schedule() {
        this.scheduleStages(this.method.stages, null);
        // this.method.stages.reduce((preStage: MethodStage, currentStage: MethodStage) => {
        //   if (currentStage.type === '0') {
        //     this.addTask(currentStage.name, (context: CommandContext) => {
        //       return this.dynamicInvoke2(currentStage as ExecutingStage, context);
        //     });
        //     if (preStage) {
        //       this.addLink(preStage.name, currentStage.name, `1===1`);
        //     }
        //   } else if (currentStage.type === '2') {
        //   } else {
        //     throw new Error(`unknow method stage type, the ${currentStage.name}'s type is ${currentStage.type}`);
        //   }
        //   return currentStage;
        // }, null);
    }
    scheduleStages(stages, initialStage) {
        stages.reduce((preStage, currentStage) => {
            if (currentStage.type === 'executing') {
                this.addTask(currentStage.name, (context) => {
                    return this.dynamicInvoke2(currentStage, context);
                });
            }
            else if (currentStage.type === 'fork') {
                const forkStages = currentStage.stages;
                forkStages.forEach(forkStage => {
                    this.scheduleStages(forkStage.stages, forkStage);
                });
                this.scheduleStages(currentStage.stages, currentStage);
            }
            else if (currentStage.type === 'determing') {
                this.addTask(currentStage.name, (context) => {
                    return of(true);
                });
            }
            else {
                throw new Error(`unknow method stage type, the ${currentStage.name}'s type is ${currentStage.type}`);
            }
            if (preStage) {
                const condition = preStage.type === 'determing' ? preStage.condition : `1===1`;
                this.addLink(preStage.name, currentStage.name, condition);
            }
            return currentStage;
        }, initialStage);
    }
    loadProvidersFromModule(serviceModule) {
        const providerArray = [];
        for (const propertyName in serviceModule) {
            if (Object.prototype.hasOwnProperty.call(serviceModule, propertyName)) {
                const propertyValue = serviceModule[propertyName];
                if (this.isInjectableService(propertyValue)) {
                    // const providerName = propertyValue.name === 'e' ? propertyName : propertyValue.name;
                    const providerName = propertyName;
                    providerArray.push({ provide: providerName, useClass: propertyValue });
                    providerArray.push(propertyValue);
                }
            }
        }
        const resolvedReflectiveProviders = ReflectiveInjector.resolve(providerArray);
        return resolvedReflectiveProviders;
    }
    isInjectableService(propertyValue) {
        let hasInjectableDecorator = false;
        const isFunction = propertyValue instanceof Function;
        if (isFunction && propertyValue.hasOwnProperty('decorators')) {
            const decorators = propertyValue.decorators;
            const injectableDecorators = decorators.filter(decorator => {
                if (decorator.type && decorator.type.prototype && decorator.type.prototype.ngMetadataName === 'Injectable') {
                    return decorator;
                }
            });
            hasInjectableDecorator = injectableDecorators && injectableDecorators.length > 0;
        }
        else if (isFunction && propertyValue.hasOwnProperty('__annotations__')) {
            const decorators = propertyValue.__annotations__;
            const injectableDecorators = decorators.filter(decoratorFactory => {
                if (decoratorFactory && decoratorFactory.ngMetadataName && decoratorFactory.ngMetadataName === 'Injectable') {
                    return decoratorFactory;
                }
            });
            hasInjectableDecorator = injectableDecorators && injectableDecorators.length > 0;
        }
        return hasInjectableDecorator;
    }
}

/*
 * @Author: aalizzwell
 * @Date: 2019-05-30 11:08:18
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-06-01 17:10:04
 */
const VALIDATION_HANDLER = new InjectionToken('@farris/common-service ValidationHandler');

// --------------------------------------------------------------------------------
// Legacy
// --------------------------------------------------------------------------------
/**
 * Providers for compatibility.
 */
const FARRIS_DEVKIT_APP_PROVIDERS = [
    EventBus,
    Subscription,
    RestfulService,
    VARIABLE_PROVIDERS,
    AppContext,
    RouterParamService,
    FrameEventBus,
    AppContextManager
];
// --------------------------------------------------------------------------------
// Current
// --------------------------------------------------------------------------------
/**
 * Providers for DevkitModule.
 */
const FARRIS_DEVKIT_MODULE_PROVIDERS = [
    EventBus,
    Subscription,
    RestfulService,
    RouterParamService,
    VARIABLE_PROVIDERS,
    AppContextManager,
];
/**
 * Providers for root frame components.
 */
const FARRIS_DEVKIT_ROOT_FRAME_PROVIDERS = [
    AppContext,
];
/**
 * 表达式provider
 * @description 放置到root-component，整个表单只需要注入一次
 */
const FARRIS_DEVKIT_EXPRESSION_ROOT_FRAME_PROVIDERS = [
    ListenerRegistry,
    Listeners,
    EffectorRegistry,
    EffectorFactory,
    ExpressionRegistry,
    ExpressionEventEmitter,
    ExpressionExecutor,
    ExpressionManager,
    ExpressionResult,
    ExpressionResultFactory,
    { provide: RESOLVER_TOKEN, useClass: EntityDependencyResolver, multi: true },
    { provide: RESOLVER_TOKEN, useClass: StateDependencyResolver, multi: true },
    { provide: RESOLVER_TOKEN, useClass: CommentDependencyResolver, multi: true },
    ResolverRegistry,
    { provide: EVENT_HANDLER_TOKEN, useClass: RepositoryAddEntityEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: RepositoryRemoveEntityEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: EntityValueChangedEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: StateValueChangedEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: RepositoryLoadEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: EntityUpdateEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataAppendObjectEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataValueChangeEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataRemoveObjectEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataLoadEventHandler, multi: true },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataSelectionChangedEventHandler, multi: true },
    EventHandlerRegistry,
    ExpressionEngineImpl,
    ResolveService
];
/**
 * 表达式监听器provider
 * @description 放置到每个表单的root上，组合表单root也需要放置
 */
const FARRIS_DEVKIT_EXPRESSION_LISTENER_PROVIDERS = [
    { provide: LISTENER_TOKEN, useClass: UIStateChangeListener, multi: true },
    { provide: LISTENER_TOKEN, useClass: RepositoryChangeListener, multi: true },
    { provide: LISTENER_TOKEN, useClass: BindingDataChangeListener, multi: true }
];
const FARRIS_DEVKIT_EXPRESSION_EFFECTOR_PROVIDERS = [
    { provide: EFFECTOR_TOKEN, useClass: RepositoryEffector, multi: true },
    { provide: EFFECTOR_TOKEN, useClass: UIStateEffector, multi: true },
    { provide: EFFECTOR_TOKEN, useClass: ReadonlyEffector, multi: true },
    { provide: EFFECTOR_TOKEN, useClass: DependencyEffector, multi: true },
    { provide: EFFECTOR_TOKEN, useClass: RelativeEffector, multi: true },
    { provide: EFFECTOR_TOKEN, useClass: ValidateEffector, multi: true },
    { provide: EFFECTOR_TOKEN, useClass: RequiredEffector, multi: true },
    { provide: EFFECTOR_TOKEN, useClass: VisibleEffector, multi: true }
];
/**
 * Providers for frame components.
 */
const FARRIS_DEVKIT_FRAME_PROVIDERS = [
    COMMAND_PROVIDERS,
    FrameContext
];

/**
 * DevkitModule
 */
class DevkitModule {
}
DevkitModule.decorators = [
    { type: NgModule, args: [{
                providers: FARRIS_DEVKIT_MODULE_PROVIDERS
            },] }
];

/**
 * 监听bindingList变更
 * @description 主要用于监听行切换等事件
 * @deprecated 已废弃
 */
class DeprecatedBindingDataChangeListener extends ChangeListener {
    constructor(injector, bindingData, namespace) {
        super();
        this.injector = injector;
        this.bindingData = bindingData;
        this.namespace = namespace;
    }
    buildEventPath(change) {
        return null;
    }
}
DeprecatedBindingDataChangeListener.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DeprecatedBindingDataChangeListener.ctorParameters = () => [
    { type: Injector },
    { type: BindingData },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] }
];

var CacheReturnType;
(function (CacheReturnType) {
    CacheReturnType[CacheReturnType["Static"] = 1] = "Static";
    CacheReturnType[CacheReturnType["Promise"] = 2] = "Promise";
})(CacheReturnType || (CacheReturnType = {}));
class CacheKeyCompare {
    compare(key1, key2) {
        return key1 === key2;
    }
}

class CacheObject {
    constructor(key, content, ttl) {
        this.key = key;
        this.content = content;
        this.ttl = ttl;
        this.createAt = new Date();
    }
    isExpired() {
        if (typeof this.ttl === 'number') {
            return Date.now().valueOf() > this.createAt.valueOf() + this.ttl;
        }
        else {
            return Date.now() > this.ttl.valueOf();
        }
    }
}

/**
 * 缓存方法返回值
 * @param options ICacheOptions 缓存选项
 * @returns MethodDecorator
 */
function Cacheable(options) {
    return function (target, propertyKey, descriptor) {
        if (descriptor === undefined) {
            descriptor = Object.getOwnPropertyDescriptor(target, propertyKey);
        }
        const className = target.name || target && target.constructor && target.constructor.name;
        const method = descriptor.value;
        descriptor.value = function (...args) {
            const ttl = options && options.ttl || 0;
            const provider = options && options.provider;
            if (!provider) {
                throw new Error('cache provider is not defined.');
            }
            let key = options && options.key || undefined;
            if (key && key instanceof Function) {
                key = key(this, args);
            }
            let cacheKey = key;
            if (!cacheKey) {
                const argsString = JSON.stringify(args);
                cacheKey = `${className}#${String(propertyKey)}#${argsString}`;
            }
            const cacheObject = provider.get(cacheKey);
            if (!cacheObject || (ttl && cacheObject.isExpired() === true)) {
                const result = method.apply(this, args);
                const object = new CacheObject(cacheKey, result, ttl);
                provider.set(object);
                return result;
            }
            return cacheObject && cacheObject.content;
        };
        return descriptor;
    };
}

class CacheContainer {
    constructor(provider) {
        this.provider = provider;
        this.provider = provider;
    }
    get(key) {
        const cacheObject = this.provider.get(key);
        if (!cacheObject) {
            return undefined;
        }
        const isExpired = this.isCacheObjectExpired(cacheObject);
        return isExpired ? undefined : cacheObject.content;
    }
    set(key, value, ttl) {
        const cacheObject = new CacheObject(key, value, ttl || 0);
        this.provider.set(cacheObject);
    }
    isCacheObjectExpired(cacheObject) {
        if (typeof cacheObject.ttl === 'number') {
            return Date.now().valueOf() > cacheObject.createAt.valueOf() + cacheObject.ttl;
        }
        else {
            return Date.now() > cacheObject.ttl.valueOf();
        }
    }
}

class MemoryCacheProvider {
    constructor(cacheKeyCompare) {
        this.store = new Array();
        this.cacheKeyCompare = cacheKeyCompare || new CacheKeyCompare();
    }
    has(key) {
        if (this.store.length < 1) {
            return false;
        }
        const index = this.store.findIndex((item) => item && this.cacheKeyCompare.compare(key, item.key));
        return index !== -1;
    }
    length() {
        return this.store.length;
    }
    set(value) {
        this.store.push(value);
    }
    get(key) {
        if (this.store.length < 1) {
            return undefined;
        }
        return this.store.find((item) => this.cacheKeyCompare.compare(key, item.key));
    }
    delete(key) {
        if (this.store.length < 1) {
            return;
        }
        const index = this.store.findIndex((item) => item && this.cacheKeyCompare.compare(key, item.key));
        this.store.splice(index, 1);
    }
    clear() {
        this.store.length = 0;
    }
    keys() {
        return this.store.keys();
    }
    values() {
        return this.store.values();
    }
}

/**
 * 默认缓存
 * @description
 * 默认缓存使用Map作为缓存容器，存储速度快。但不支持自定义的key对比，对于简单类型的key使用值对比，对于引用类型的key，对比的是引用的地址。
 */
class DefaultCacheProvider {
    constructor() {
        this.buffer = new Map();
    }
    has(key) {
        return this.buffer.has(key);
    }
    length() {
        return this.buffer.size;
    }
    set(value) {
        this.buffer.set(value.key, value);
    }
    get(key) {
        return this.buffer.get(key);
    }
    delete(key) {
        this.buffer.delete(key);
    }
    clear() {
        this.buffer.clear();
    }
    keys() {
        return this.buffer.keys();
    }
    values() {
        return this.buffer.values();
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { Expression$1 as ɵb, ChangeListener as ɵc, DeprecatedBindingDataChangeListener as ɵe, FormStateVariableParser as ɵa, ANNOTATIONS, PARAMETERS, PROP_METADATA, makeDecorator, makeParamDecorator, makePropDecorator, MetadataUtil, ChangeSet, Modification, ModifyType, Entity, DynamicEntity, createEntity, createEntities, EntityFactory$1 as EntityFactory, EntityList, NG_FIELD, NgField, NG_LIST, NgList, NG_OBJECT, NgObject, NG_Dynamic, NgDynamic, NG_ENTITY, NgEntity, FieldMetadataUtil, EntityMetadataUtil, PARENT_PATH, PARENT_CLASS, ENTITY_DATA_SERVICE_TOKEN, ValidationTypes, Validator, ValidationError, entityPrototype, EntityTypeFactory, EntityTypeCreator, RestfulService, NG_REPOSITORY, NgRepository, EntityCollection, EntityManager, Repository, DefaultRepository, SortConditionManager, FilterConditionManager, BigNumberType, DataChangeType, HttpMethod, BackEndMessage, RunMode, DEVKIT_RUN_MODE, ComponentType, DestroyOpportunity, DataPathNodeType, DataPathNode, DataPath, DataPathCreator$$1 as DataPathCreator, DataPropGroup, DataPropInfo, DataTypeInfo, FORM_PATH_TOKEN, BACK_END_MESSAGE_HANDLER_TOKEN, MESSAGE_SERVICE_TOKEN, NOTIFY_SERVICE_TOKEN, CHANGE_SET_POLICY_TOKEN, ENABLE_SERVER_SIDE_CHANGE_DETECTION_TOKEN, ENABLE_EDIT_STATE_FILTER_SORTING, encodeUrl, Core, escape, NG_COMMAND_HANDLER, NgCommandHandler, NG_COMMAND_HANDLER_EXTENDER, NgCommandHandlerExtender, TaskNode, TaskLink, TaskFlow, CommandContext, CommandHandler, COMMAND_HANDLERS_TOKEN, CommandHandlerRegistry, CommandHandlerExtender, COMMAND_HANDLER_EXTENDERS_TOKEN, CommandHandlerExtenderRegistry, CommandHandlerFactory, CommandBus, COMMAND_PROVIDERS, DynamicCommandHandler, ChangeType, ViewChangeType, BaseBindingObject, BindingPropertyType, BindingObject, BindingList, BindingData, PropertyUtil, EntityUtil, BindingListFactory, BindingObjectFactory, BindingDataFactory, NG_BINDING_DATA, NgBindingData, BindingObjectTypeFactory, BindingListTypeFactory, Form, NG_VALIDATE_FORM, NgValidateForm, NG_CHILD_FORM, NgChildForm, NG_CHILD_FORM_ARRAY, NgChildFormArray, NG_FORM_CONTROL, NgFormControl, State, initialUIState, StateMachineContext, effectHandlers, StateMachine, NgState, NgRenderState, NgAction, UIState, NG_COMPONENT_STATE, NgParam, UIStateMetadataUtil, PARAM_TYPE_TRANSFORM_TOKEN, EventBus, EventCache, EventBusProxy, EventPipe, NG_DECLARATION, NgDeclaration, Declaration, EventTypeEnum, NG_SUBSCRIPTION, ParamMap, NgSubscription, getNgSubscriptionDecoratorFactory, Subscription, ViewModel, NG_COMMAND, NgCommand, Context, BindingDataManager, RepositoryManager, FrameContextManager, FrameComponentRefresher, AppContext, AppContextManager, ViewModelManager, FORM_ID, EXCEPTION_HANDLER, VALIDATION_HANDLER, VARIABLE_PARSERS, FrameIdVariableParser, DataVariableParser, UIStateVariableParser, CommandVariableParser, StateMachineVariableParser, VariableParseService, EventParamVariableParser, VARIABLE_PROVIDERS, FrameContext, FrameComponent, FrameEvent, FrameEventBus, FRAME_ID, NAMESPACE, FRAME_COMPONENT_INIT_HANDLER_TOKEN, RouterParamService, DataPathUtil, UID, Guid, RunModeService, DateUtil, BindingPathConverter, BindingPathComparer, BindingPathTraverser, EntityPathConverter, EntityPathComparer, FormPathConverter, ExpressionUtil, DataTypeInfoUtil, FARRIS_DEVKIT_APP_PROVIDERS, FARRIS_DEVKIT_MODULE_PROVIDERS, FARRIS_DEVKIT_ROOT_FRAME_PROVIDERS, FARRIS_DEVKIT_EXPRESSION_ROOT_FRAME_PROVIDERS, FARRIS_DEVKIT_EXPRESSION_LISTENER_PROVIDERS, FARRIS_DEVKIT_EXPRESSION_EFFECTOR_PROVIDERS, FARRIS_DEVKIT_FRAME_PROVIDERS, DevkitModule, TranslateToken, UserSettingsToken, ZonedTime, Schema, SchemaEntity, SchemaEntityType, SchemaEntityField, SchemaEntityFieldType, SchemaEntityFieldEditor, SchemaEntityField$Type, SchemaEntityFieldType$Type, SchemaEntityFieldTypeName, DomService, FormContent, FormContentForDB, FormMetadaDataDom, FormModule, FormOptions, LISTENER_TOKEN, UIStateChangeListener, RepositoryChangeListener, ListenerRegistry, BindingDataChangeListener, Listeners, FORM_MANIFEST_SERVICE_TOKEN, FORM_EXPRESSION_MANIFEST_SERVICE_TOKEN, Expression$1 as Expression, ExpressionEventEmitter, ExpressionRegistry, ExpressionExecutor, ExpressionEngineImpl, ExpressionManager, ExpressionResult, ExpressionResultFactory, ASSIGNER_TOKEN, EVENT_HANDLER_TOKEN, EFFECTOR_TOKEN, RepositoryEffector, UIStateEffector, ReadonlyEffector, DependencyEffector, EffectorRegistry, EffectorFactory, RelativeEffector, ValidateEffector, RequiredEffector, VisibleEffector, RESOLVER_TOKEN, ENTITY_TEMPLATE, STATE_TEMPLATE, GROUP_FUNCTIONS, ResolverRegistry, EntityDependencyResolver, StateDependencyResolver, CommentDependencyResolver, ResolveService, EntityValueChangedEventHandler, StateValueChangedEventHandler, RepositoryAddEntityEventHandler, RepositoryRemoveEntityEventHandler, RepositoryLoadEventHandler, EntityUpdateEventHandler, BindingDataAppendObjectEventHandler, BindingDataValueChangeEventHandler, BindingDataRemoveObjectEventHandler, BindingDataLoadEventHandler, BindingDataSelectionChangedEventHandler, EventHandlerRegistry, EventHandler, CacheReturnType, CacheKeyCompare, Cacheable, CacheContainer, CacheObject, MemoryCacheProvider, DefaultCacheProvider, DataFilter, Compare, FilterRelation, ExpressValueType, LeftBracket, RighttBracket, ArrayFilterConditionDataFilter, ObjectFilterConditionDataFilter };

//# sourceMappingURL=farris-devkit.js.map