import { Inject, Injectable, Injector } from '@angular/core';
import { BindingData } from '../binding-data/index';
import { EntityList } from '../entity/index';
import { NAMESPACE } from '../frame/tokens';
import { Repository } from '../repository/index';
/**
 * 实体副作用器
 * @description 将表达式计算结果赋值给实体属性
 */
export class RepositoryEffector {
    constructor(injector, repository, namespace, bindingData) {
        this.injector = injector;
        this.repository = repository;
        this.namespace = namespace;
        this.bindingData = bindingData;
        this.ns = namespace;
    }
    effect(path, value, options) {
        if (!options || !options.path) {
            throw new Error('repository effector 需要指定行信息。');
        }
        const propertyPath = options.path;
        const rowId = propertyPath[0] || this.bindingData.list.currentItem.primaryKeyValue;
        let entity = this.repository.entityCollection.getEntityById(rowId);
        if (rowId && !entity) {
            return;
        }
        // propertyPath like : [1, child1s, 1.1, child2s, 1.1.1,propName] or [1,udt,propName] or [1,prop]
        const propName = propertyPath.pop();
        let object = entity;
        for (let index = 1; index < propertyPath.length; index++) {
            const propertyName = propertyPath[index];
            if (object instanceof EntityList) {
                object = object.get(propertyName);
            }
            else {
                object = object[propertyName];
            }
        }
        if (object) {
            if (object[propName] !== value) {
                object[propName] = value;
            }
        }
        else {
            // console.error(`找不到实体对应的路径：${propertyPath.push(propName)}`);
        }
    }
}
RepositoryEffector.decorators = [
    { type: Injectable }
];
/** @nocollapse */
RepositoryEffector.ctorParameters = () => [
    { type: Injector },
    { type: Repository },
    { type: undefined, decorators: [{ type: Inject, args: [NAMESPACE,] }] },
    { type: BindingData }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVwb3NpdG9yeV9lZmZlY3Rvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvZGV2a2l0LyIsInNvdXJjZXMiOlsibGliL2VmZmVjdG9yL3JlcG9zaXRvcnlfZWZmZWN0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNwRCxPQUFPLEVBQVUsVUFBVSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFckQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNqRDs7O0dBR0c7QUFFSCxNQUFNLE9BQU8sa0JBQWtCO0lBRTdCLFlBQW9CLFFBQWtCLEVBQVUsVUFBOEIsRUFBNkIsU0FBUyxFQUFVLFdBQXdCO1FBQWxJLGFBQVEsR0FBUixRQUFRLENBQVU7UUFBVSxlQUFVLEdBQVYsVUFBVSxDQUFvQjtRQUE2QixjQUFTLEdBQVQsU0FBUyxDQUFBO1FBQVUsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDcEosSUFBSSxDQUFDLEVBQUUsR0FBRyxTQUFTLENBQUM7SUFDdEIsQ0FBQztJQUVNLE1BQU0sQ0FBQyxJQUFZLEVBQUUsS0FBVSxFQUFFLE9BQWlDO1FBQ3ZFLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFO1lBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztTQUNqRDtRQUNELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDbEMsTUFBTSxLQUFLLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUM7UUFDbkYsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbkUsSUFBSSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDcEIsT0FBTztTQUNSO1FBQ0QsaUdBQWlHO1FBQ2pHLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNwQyxJQUFJLE1BQU0sR0FBUSxNQUFNLENBQUM7UUFDekIsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDeEQsTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pDLElBQUksTUFBTSxZQUFZLFVBQVUsRUFBRTtnQkFDaEMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDbkM7aUJBQU07Z0JBQ0wsTUFBTSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUMvQjtTQUNGO1FBQ0QsSUFBSSxNQUFNLEVBQUU7WUFDVixJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxLQUFLLEVBQUU7Z0JBQzlCLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUM7YUFDMUI7U0FDRjthQUFNO1lBQ0wsOERBQThEO1NBQy9EO0lBQ0gsQ0FBQzs7O1lBbkNGLFVBQVU7Ozs7WUFWa0IsUUFBUTtZQUs1QixVQUFVOzRDQVFnRSxNQUFNLFNBQUMsU0FBUztZQVoxRixXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCaW5kaW5nRGF0YSB9IGZyb20gJy4uL2JpbmRpbmctZGF0YS9pbmRleCc7XHJcbmltcG9ydCB7IEVudGl0eSwgRW50aXR5TGlzdCB9IGZyb20gJy4uL2VudGl0eS9pbmRleCc7XHJcbmltcG9ydCB7IEV4cHJlc3Npb24gfSBmcm9tICcuLi9leHByZXNzaW9uL2luZGV4JztcclxuaW1wb3J0IHsgTkFNRVNQQUNFIH0gZnJvbSAnLi4vZnJhbWUvdG9rZW5zJztcclxuaW1wb3J0IHsgUmVwb3NpdG9yeSB9IGZyb20gJy4uL3JlcG9zaXRvcnkvaW5kZXgnO1xyXG4vKipcclxuICog5a6e5L2T5Ymv5L2c55So5ZmoXHJcbiAqIEBkZXNjcmlwdGlvbiDlsIbooajovr7lvI/orqHnrpfnu5PmnpzotYvlgLznu5nlrp7kvZPlsZ7mgKdcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFJlcG9zaXRvcnlFZmZlY3RvciBpbXBsZW1lbnRzIEV4cHJlc3Npb24uRWZmZWN0b3Ige1xyXG4gIHB1YmxpYyBuczogc3RyaW5nO1xyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLCBwcml2YXRlIHJlcG9zaXRvcnk6IFJlcG9zaXRvcnk8RW50aXR5PiwgQEluamVjdChOQU1FU1BBQ0UpIHByaXZhdGUgbmFtZXNwYWNlLCBwcml2YXRlIGJpbmRpbmdEYXRhOiBCaW5kaW5nRGF0YSkge1xyXG4gICAgdGhpcy5ucyA9IG5hbWVzcGFjZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBlZmZlY3QocGF0aDogc3RyaW5nLCB2YWx1ZTogYW55LCBvcHRpb25zOiBFeHByZXNzaW9uLkVmZmVjdE9wdGlvbnMpIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5wYXRoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVwb3NpdG9yeSBlZmZlY3RvciDpnIDopoHmjIflrprooYzkv6Hmga/jgIInKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BlcnR5UGF0aCA9IG9wdGlvbnMucGF0aDtcclxuICAgIGNvbnN0IHJvd0lkID0gcHJvcGVydHlQYXRoWzBdIHx8IHRoaXMuYmluZGluZ0RhdGEubGlzdC5jdXJyZW50SXRlbS5wcmltYXJ5S2V5VmFsdWU7XHJcbiAgICBsZXQgZW50aXR5ID0gdGhpcy5yZXBvc2l0b3J5LmVudGl0eUNvbGxlY3Rpb24uZ2V0RW50aXR5QnlJZChyb3dJZCk7XHJcbiAgICBpZiAocm93SWQgJiYgIWVudGl0eSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBwcm9wZXJ0eVBhdGggbGlrZSA6IFsxLCBjaGlsZDFzLCAxLjEsIGNoaWxkMnMsIDEuMS4xLHByb3BOYW1lXSBvciBbMSx1ZHQscHJvcE5hbWVdIG9yIFsxLHByb3BdXHJcbiAgICBjb25zdCBwcm9wTmFtZSA9IHByb3BlcnR5UGF0aC5wb3AoKTtcclxuICAgIGxldCBvYmplY3Q6IGFueSA9IGVudGl0eTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBwcm9wZXJ0eVBhdGgubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5UGF0aFtpbmRleF07XHJcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFbnRpdHlMaXN0KSB7XHJcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmdldChwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAob2JqZWN0KSB7XHJcbiAgICAgIGlmIChvYmplY3RbcHJvcE5hbWVdICE9PSB2YWx1ZSkge1xyXG4gICAgICAgIG9iamVjdFtwcm9wTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gY29uc29sZS5lcnJvcihg5om+5LiN5Yiw5a6e5L2T5a+55bqU55qE6Lev5b6E77yaJHtwcm9wZXJ0eVBhdGgucHVzaChwcm9wTmFtZSl9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59Il19