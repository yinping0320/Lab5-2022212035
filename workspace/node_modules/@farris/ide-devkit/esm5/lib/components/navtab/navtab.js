/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, ContentChildren, QueryList, Directive, TemplateRef, ContentChild, Output, EventEmitter } from '@angular/core';
import { NgbNavTabsetConfig } from './navtab-config';
/** @type {?} */
var nextId = 0;
/**
 * This directive should be used to wrap tab titles that need to contain HTML markup or other directives.
 */
var NgbNavTabTitle = /** @class */ (function () {
    function NgbNavTabTitle(templateRef) {
        this.templateRef = templateRef;
    }
    NgbNavTabTitle.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbNavTabTitle]' },] }
    ];
    /** @nocollapse */
    NgbNavTabTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbNavTabTitle;
}());
export { NgbNavTabTitle };
if (false) {
    /** @type {?} */
    NgbNavTabTitle.prototype.templateRef;
}
/**
 * This directive must be used to wrap content to be displayed in a tab.
 */
var NgbNavTabContent = /** @class */ (function () {
    function NgbNavTabContent(templateRef) {
        this.templateRef = templateRef;
    }
    NgbNavTabContent.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbNavTabContent]' },] }
    ];
    /** @nocollapse */
    NgbNavTabContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbNavTabContent;
}());
export { NgbNavTabContent };
if (false) {
    /** @type {?} */
    NgbNavTabContent.prototype.templateRef;
}
/**
 * A directive representing an individual tab.
 */
var NgbNavTab = /** @class */ (function () {
    function NgbNavTab() {
        /**
         * Unique tab identifier. Must be unique for the entire document for proper accessibility support.
         */
        this.id = "ngb-tab-" + nextId++;
        /**
         * Allows toggling disabled state of a given state. Disabled tabs can't be selected.
         */
        this.disabled = false;
    }
    NgbNavTab.decorators = [
        { type: Directive, args: [{ selector: 'ngb-navtab' },] }
    ];
    NgbNavTab.propDecorators = {
        id: [{ type: Input }],
        title: [{ type: Input }],
        disabled: [{ type: Input }],
        contentTpl: [{ type: ContentChild, args: [NgbNavTabContent,] }],
        titleTpl: [{ type: ContentChild, args: [NgbNavTabTitle,] }]
    };
    return NgbNavTab;
}());
export { NgbNavTab };
if (false) {
    /**
     * Unique tab identifier. Must be unique for the entire document for proper accessibility support.
     * @type {?}
     */
    NgbNavTab.prototype.id;
    /**
     * Simple (string only) title. Use the "NgbNavTabTitle" directive for more complex use-cases.
     * @type {?}
     */
    NgbNavTab.prototype.title;
    /**
     * Allows toggling disabled state of a given state. Disabled tabs can't be selected.
     * @type {?}
     */
    NgbNavTab.prototype.disabled;
    /** @type {?} */
    NgbNavTab.prototype.contentTpl;
    /** @type {?} */
    NgbNavTab.prototype.titleTpl;
}
/**
 * The payload of the change event fired right before the tab change
 * @record
 */
export function NgbNavTabChangeEvent() { }
if (false) {
    /**
     * Id of the currently active tab
     * @type {?}
     */
    NgbNavTabChangeEvent.prototype.activeId;
    /**
     * Id of the newly selected tab
     * @type {?}
     */
    NgbNavTabChangeEvent.prototype.nextId;
    /**
     * Function that will prevent tab switch if called
     * @type {?}
     */
    NgbNavTabChangeEvent.prototype.preventDefault;
}
/**
 * A component that makes it easy to create tabbed interface.
 */
var NgbNavTabset = /** @class */ (function () {
    function NgbNavTabset(config) {
        /**
         * Whether the closed tabs should be hidden without destroying them
         */
        this.destroyOnHide = true;
        /**
         * A tab change event fired right before the tab selection happens. See NgbNavTabChangeEvent for payload details
         */
        this.tabChange = new EventEmitter();
        this.type = config.type;
        this.justify = config.justify;
        this.orientation = config.orientation;
    }
    Object.defineProperty(NgbNavTabset.prototype, "justify", {
        /**
         * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
         * 'justified'
         * The default value is 'start'.
         */
        set: /**
         * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
         * 'justified'
         * The default value is 'start'.
         * @param {?} className
         * @return {?}
         */
        function (className) {
            if (className === 'fill' || className === 'justified') {
                this.justifyClass = "nav-" + className;
            }
            else {
                this.justifyClass = "justify-content-" + className;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     */
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    NgbNavTabset.prototype.select = /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    function (tabId) {
        /** @type {?} */
        var selectedTab = this._getTabById(tabId);
        if (selectedTab && !selectedTab.disabled && this.activeId !== selectedTab.id) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            this.tabChange.emit({ activeId: this.activeId, nextId: selectedTab.id, preventDefault: function () { defaultPrevented_1 = true; } });
            if (!defaultPrevented_1) {
                this.activeId = selectedTab.id;
            }
        }
    };
    /**
     * @return {?}
     */
    NgbNavTabset.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // auto-correct activeId that might have been set incorrectly as input
        /** @type {?} */
        var activeTab = this._getTabById(this.activeId);
        this.activeId = activeTab ? activeTab.id : (this.tabs.length ? this.tabs.first.id : null);
    };
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    NgbNavTabset.prototype._getTabById = /**
     * @private
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var tabsWithId = this.tabs.filter(function (tab) { return tab.id === id; });
        return tabsWithId.length ? tabsWithId[0] : null;
    };
    NgbNavTabset.decorators = [
        { type: Component, args: [{
                    selector: 'ngb-navtabset',
                    exportAs: 'NgbNavTabset',
                    template: "\n    <ul [class]=\"'web-ide-activity-bar nav nav-' + type + (orientation == 'horizontal'?  ' '\n      + justifyClass : ' flex-column')\" role=\"tablist\">\n      <li class=\"nav-item\" *ngFor=\"let tab of tabs\">\n        <a [id]=\"tab.id\" class=\"nav-link\" [class.active]=\"tab.id === activeId\" [class.disabled]=\"tab.disabled\"\n          href (click)=\"select(tab.id)\" role=\"tab\" [attr.tabindex]=\"(tab.disabled ? '-1': undefined)\"\n          [attr.aria-controls]=\"(!destroyOnHide || tab.id === activeId ? tab.id + '-panel' : null)\"\n          [attr.aria-expanded]=\"tab.id === activeId\" [attr.aria-disabled]=\"tab.disabled\">\n          {{tab.title}}<ng-template [ngTemplateOutlet]=\"tab.titleTpl?.templateRef\"></ng-template>\n        </a>\n      </li>\n    </ul>\n    <div class=\"web-ide-side-bar tab-content\">\n      <ng-template ngFor let-tab [ngForOf]=\"tabs\">\n        <div\n          class=\"tab-pane {{tab.id === activeId ? 'active' : null}}\"\n          *ngIf=\"!destroyOnHide || tab.id === activeId\"\n          role=\"tabpanel\"\n          [attr.aria-labelledby]=\"tab.id\" id=\"{{tab.id}}-panel\"\n          [attr.aria-expanded]=\"tab.id === activeId\">\n          <ng-template [ngTemplateOutlet]=\"tab.contentTpl.templateRef\"></ng-template>\n        </div>\n      </ng-template>\n    </div>\n  ",
                    styles: [":host{display:flex!important;flex:1}"]
                }] }
    ];
    /** @nocollapse */
    NgbNavTabset.ctorParameters = function () { return [
        { type: NgbNavTabsetConfig }
    ]; };
    NgbNavTabset.propDecorators = {
        tabs: [{ type: ContentChildren, args: [NgbNavTab,] }],
        activeId: [{ type: Input }],
        destroyOnHide: [{ type: Input }],
        justify: [{ type: Input }],
        orientation: [{ type: Input }],
        type: [{ type: Input }],
        tabChange: [{ type: Output }]
    };
    return NgbNavTabset;
}());
export { NgbNavTabset };
if (false) {
    /** @type {?} */
    NgbNavTabset.prototype.justifyClass;
    /** @type {?} */
    NgbNavTabset.prototype.tabs;
    /**
     * An identifier of an initially selected (active) tab. Use the "select" method to switch a tab programmatically.
     * @type {?}
     */
    NgbNavTabset.prototype.activeId;
    /**
     * Whether the closed tabs should be hidden without destroying them
     * @type {?}
     */
    NgbNavTabset.prototype.destroyOnHide;
    /**
     * The orientation of the nav (horizontal or vertical).
     * The default value is 'horizontal'.
     * @type {?}
     */
    NgbNavTabset.prototype.orientation;
    /**
     * Type of navigation to be used for tabs. Can be one of 'tabs' or 'pills'.
     * @type {?}
     */
    NgbNavTabset.prototype.type;
    /**
     * A tab change event fired right before the tab selection happens. See NgbNavTabChangeEvent for payload details
     * @type {?}
     */
    NgbNavTabset.prototype.tabChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2dGFiLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZhcnJpcy9pZGUtZGV2a2l0LyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvbmF2dGFiL25hdnRhYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsZUFBZSxFQUNmLFNBQVMsRUFDVCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFlBQVksRUFFWixNQUFNLEVBQ04sWUFBWSxFQUNiLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOztJQUVqRCxNQUFNLEdBQUcsQ0FBQzs7OztBQUtkO0lBR0Usd0JBQW1CLFdBQTZCO1FBQTdCLGdCQUFXLEdBQVgsV0FBVyxDQUFrQjtJQUFJLENBQUM7O2dCQUh0RCxTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsNkJBQTZCLEVBQUU7Ozs7Z0JBYnBELFdBQVc7O0lBaUJiLHFCQUFDO0NBQUEsQUFKRCxJQUlDO1NBRlksY0FBYzs7O0lBQ2IscUNBQW9DOzs7OztBQU1sRDtJQUdFLDBCQUFtQixXQUE2QjtRQUE3QixnQkFBVyxHQUFYLFdBQVcsQ0FBa0I7SUFBSSxDQUFDOztnQkFIdEQsU0FBUyxTQUFDLEVBQUUsUUFBUSxFQUFFLCtCQUErQixFQUFFOzs7O2dCQXRCdEQsV0FBVzs7SUEwQmIsdUJBQUM7Q0FBQSxBQUpELElBSUM7U0FGWSxnQkFBZ0I7OztJQUNmLHVDQUFvQzs7Ozs7QUFNbEQ7SUFBQTs7OztRQU1XLE9BQUUsR0FBRyxhQUFXLE1BQU0sRUFBSSxDQUFDOzs7O1FBUTNCLGFBQVEsR0FBRyxLQUFLLENBQUM7SUFJNUIsQ0FBQzs7Z0JBbEJBLFNBQVMsU0FBQyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUU7OztxQkFNbEMsS0FBSzt3QkFJTCxLQUFLOzJCQUlMLEtBQUs7NkJBRUwsWUFBWSxTQUFDLGdCQUFnQjsyQkFDN0IsWUFBWSxTQUFD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Z0NBS0wsS0FBSzswQkFPTCxLQUFLOzhCQWFMLEtBQUs7dUJBS0wsS0FBSzs0QkFLTCxNQUFNOztJQW9DVCxtQkFBQztDQUFBLEFBOUdELElBOEdDO1NBL0VZLFlBQVk7OztJQUN2QixvQ0FBcUI7O0lBRXJCLDRCQUF1RDs7Ozs7SUFLdkQsZ0NBQTBCOzs7OztJQUsxQixxQ0FBOEI7Ozs7OztJQW9COUIsbUNBQWdEOzs7OztJQUtoRCw0QkFBZ0M7Ozs7O0lBS2hDLGlDQUErRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ29tcG9uZW50LFxyXG4gIElucHV0LFxyXG4gIENvbnRlbnRDaGlsZHJlbixcclxuICBRdWVyeUxpc3QsXHJcbiAgRGlyZWN0aXZlLFxyXG4gIFRlbXBsYXRlUmVmLFxyXG4gIENvbnRlbnRDaGlsZCxcclxuICBBZnRlckNvbnRlbnRDaGVja2VkLFxyXG4gIE91dHB1dCxcclxuICBFdmVudEVtaXR0ZXJcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTmdiTmF2VGFic2V0Q29uZmlnIH0gZnJvbSAnLi9uYXZ0YWItY29uZmlnJztcclxuXHJcbmxldCBuZXh0SWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIHNob3VsZCBiZSB1c2VkIHRvIHdyYXAgdGFiIHRpdGxlcyB0aGF0IG5lZWQgdG8gY29udGFpbiBIVE1MIG1hcmt1cCBvciBvdGhlciBkaXJlY3RpdmVzLlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbmdiTmF2VGFiVGl0bGVdJyB9KVxyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLWNsYXNzLXN1ZmZpeFxyXG5leHBvcnQgY2xhc3MgTmdiTmF2VGFiVGl0bGUge1xyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PikgeyB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSBtdXN0IGJlIHVzZWQgdG8gd3JhcCBjb250ZW50IHRvIGJlIGRpc3BsYXllZCBpbiBhIHRhYi5cclxuICovXHJcbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ25nLXRlbXBsYXRlW25nYk5hdlRhYkNvbnRlbnRdJyB9KVxyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6ZGlyZWN0aXZlLWNsYXNzLXN1ZmZpeFxyXG5leHBvcnQgY2xhc3MgTmdiTmF2VGFiQ29udGVudCB7XHJcbiAgY29uc3RydWN0b3IocHVibGljIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgZGlyZWN0aXZlIHJlcHJlc2VudGluZyBhbiBpbmRpdmlkdWFsIHRhYi5cclxuICovXHJcbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ25nYi1uYXZ0YWInIH0pXHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtY2xhc3Mtc3VmZml4XHJcbmV4cG9ydCBjbGFzcyBOZ2JOYXZUYWIge1xyXG4gIC8qKlxyXG4gICAqIFVuaXF1ZSB0YWIgaWRlbnRpZmllci4gTXVzdCBiZSB1bmlxdWUgZm9yIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIHByb3BlciBhY2Nlc3NpYmlsaXR5IHN1cHBvcnQuXHJcbiAgICovXHJcbiAgQElucHV0KCkgaWQgPSBgbmdiLXRhYi0ke25leHRJZCsrfWA7XHJcbiAgLyoqXHJcbiAgICogU2ltcGxlIChzdHJpbmcgb25seSkgdGl0bGUuIFVzZSB0aGUgXCJOZ2JOYXZUYWJUaXRsZVwiIGRpcmVjdGl2ZSBmb3IgbW9yZSBjb21wbGV4IHVzZS1jYXNlcy5cclxuICAgKi9cclxuICBASW5wdXQoKSB0aXRsZTogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIEFsbG93cyB0b2dnbGluZyBkaXNhYmxlZCBzdGF0ZSBvZiBhIGdpdmVuIHN0YXRlLiBEaXNhYmxlZCB0YWJzIGNhbid0IGJlIHNlbGVjdGVkLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XHJcblxyXG4gIEBDb250ZW50Q2hpbGQoTmdiTmF2VGFiQ29udGVudCkgY29udGVudFRwbDogTmdiTmF2VGFiQ29udGVudDtcclxuICBAQ29udGVudENoaWxkKE5nYk5hdlRhYlRpdGxlKSB0aXRsZVRwbDogTmdiTmF2VGFiVGl0bGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgcGF5bG9hZCBvZiB0aGUgY2hhbmdlIGV2ZW50IGZpcmVkIHJpZ2h0IGJlZm9yZSB0aGUgdGFiIGNoYW5nZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ2JOYXZUYWJDaGFuZ2VFdmVudCB7XHJcbiAgLyoqXHJcbiAgICogSWQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGFiXHJcbiAgICovXHJcbiAgYWN0aXZlSWQ6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogSWQgb2YgdGhlIG5ld2x5IHNlbGVjdGVkIHRhYlxyXG4gICAqL1xyXG4gIG5leHRJZDogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgcHJldmVudCB0YWIgc3dpdGNoIGlmIGNhbGxlZFxyXG4gICAqL1xyXG4gIHByZXZlbnREZWZhdWx0OiAoKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSB0YWJiZWQgaW50ZXJmYWNlLlxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICduZ2ItbmF2dGFic2V0JyxcclxuICBleHBvcnRBczogJ05nYk5hdlRhYnNldCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDx1bCBbY2xhc3NdPVwiJ3dlYi1pZGUtYWN0aXZpdHktYmFyIG5hdiBuYXYtJyArIHR5cGUgKyAob3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnPyAgJyAnXHJcbiAgICAgICsganVzdGlmeUNsYXNzIDogJyBmbGV4LWNvbHVtbicpXCIgcm9sZT1cInRhYmxpc3RcIj5cclxuICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIiAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnNcIj5cclxuICAgICAgICA8YSBbaWRdPVwidGFiLmlkXCIgY2xhc3M9XCJuYXYtbGlua1wiIFtjbGFzcy5hY3RpdmVdPVwidGFiLmlkID09PSBhY3RpdmVJZFwiIFtjbGFzcy5kaXNhYmxlZF09XCJ0YWIuZGlzYWJsZWRcIlxyXG4gICAgICAgICAgaHJlZiAoY2xpY2spPVwic2VsZWN0KHRhYi5pZClcIiByb2xlPVwidGFiXCIgW2F0dHIudGFiaW5kZXhdPVwiKHRhYi5kaXNhYmxlZCA/ICctMSc6IHVuZGVmaW5lZClcIlxyXG4gICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCIoIWRlc3Ryb3lPbkhpZGUgfHwgdGFiLmlkID09PSBhY3RpdmVJZCA/IHRhYi5pZCArICctcGFuZWwnIDogbnVsbClcIlxyXG4gICAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJ0YWIuaWQgPT09IGFjdGl2ZUlkXCIgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJ0YWIuZGlzYWJsZWRcIj5cclxuICAgICAgICAgIHt7dGFiLnRpdGxlfX08bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwidGFiLnRpdGxlVHBsPy50ZW1wbGF0ZVJlZlwiPjwvbmctdGVtcGxhdGU+XHJcbiAgICAgICAgPC9hPlxyXG4gICAgICA8L2xpPlxyXG4gICAgPC91bD5cclxuICAgIDxkaXYgY2xhc3M9XCJ3ZWItaWRlLXNpZGUtYmFyIHRhYi1jb250ZW50XCI+XHJcbiAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtdGFiIFtuZ0Zvck9mXT1cInRhYnNcIj5cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICBjbGFzcz1cInRhYi1wYW5lIHt7dGFiLmlkID09PSBhY3RpdmVJZCA/ICdhY3RpdmUnIDogbnVsbH19XCJcclxuICAgICAgICAgICpuZ0lmPVwiIWRlc3Ryb3lPbkhpZGUgfHwgdGFiLmlkID09PSBhY3RpdmVJZFwiXHJcbiAgICAgICAgICByb2xlPVwidGFicGFuZWxcIlxyXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cInRhYi5pZFwiIGlkPVwie3t0YWIuaWR9fS1wYW5lbFwiXHJcbiAgICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cInRhYi5pZCA9PT0gYWN0aXZlSWRcIj5cclxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJ0YWIuY29udGVudFRwbC50ZW1wbGF0ZVJlZlwiPjwvbmctdGVtcGxhdGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvbmctdGVtcGxhdGU+XHJcbiAgICA8L2Rpdj5cclxuICBgLFxyXG4gIHN0eWxlVXJsczogWycuL25hdnRhYi5jc3MnXVxyXG59KVxyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LWNsYXNzLXN1ZmZpeFxyXG5leHBvcnQgY2xhc3MgTmdiTmF2VGFic2V0IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCB7XHJcbiAganVzdGlmeUNsYXNzOiBzdHJpbmc7XHJcblxyXG4gIEBDb250ZW50Q2hpbGRyZW4oTmdiTmF2VGFiKSB0YWJzOiBRdWVyeUxpc3Q8TmdiTmF2VGFiPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQW4gaWRlbnRpZmllciBvZiBhbiBpbml0aWFsbHkgc2VsZWN0ZWQgKGFjdGl2ZSkgdGFiLiBVc2UgdGhlIFwic2VsZWN0XCIgbWV0aG9kIHRvIHN3aXRjaCBhIHRhYiBwcm9ncmFtbWF0aWNhbGx5LlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpIGFjdGl2ZUlkOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGNsb3NlZCB0YWJzIHNob3VsZCBiZSBoaWRkZW4gd2l0aG91dCBkZXN0cm95aW5nIHRoZW1cclxuICAgKi9cclxuICBASW5wdXQoKSBkZXN0cm95T25IaWRlID0gdHJ1ZTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGhvcml6b250YWwgYWxpZ25tZW50IG9mIHRoZSBuYXYgd2l0aCBmbGV4Ym94IHV0aWxpdGllcy4gQ2FuIGJlIG9uZSBvZiAnc3RhcnQnLCAnY2VudGVyJywgJ2VuZCcsICdmaWxsJyBvclxyXG4gICAqICdqdXN0aWZpZWQnXHJcbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgJ3N0YXJ0Jy5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIHNldCBqdXN0aWZ5KGNsYXNzTmFtZTogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgfCAnZmlsbCcgfCAnanVzdGlmaWVkJykge1xyXG4gICAgaWYgKGNsYXNzTmFtZSA9PT0gJ2ZpbGwnIHx8IGNsYXNzTmFtZSA9PT0gJ2p1c3RpZmllZCcpIHtcclxuICAgICAgdGhpcy5qdXN0aWZ5Q2xhc3MgPSBgbmF2LSR7Y2xhc3NOYW1lfWA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmp1c3RpZnlDbGFzcyA9IGBqdXN0aWZ5LWNvbnRlbnQtJHtjbGFzc05hbWV9YDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgbmF2IChob3Jpem9udGFsIG9yIHZlcnRpY2FsKS5cclxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnaG9yaXpvbnRhbCcuXHJcbiAgICovXHJcbiAgQElucHV0KCkgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFR5cGUgb2YgbmF2aWdhdGlvbiB0byBiZSB1c2VkIGZvciB0YWJzLiBDYW4gYmUgb25lIG9mICd0YWJzJyBvciAncGlsbHMnLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpIHR5cGU6ICd0YWJzJyB8ICdwaWxscyc7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdGFiIGNoYW5nZSBldmVudCBmaXJlZCByaWdodCBiZWZvcmUgdGhlIHRhYiBzZWxlY3Rpb24gaGFwcGVucy4gU2VlIE5nYk5hdlRhYkNoYW5nZUV2ZW50IGZvciBwYXlsb2FkIGRldGFpbHNcclxuICAgKi9cclxuICBAT3V0cHV0KCkgdGFiQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxOZ2JOYXZUYWJDaGFuZ2VFdmVudD4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoY29uZmlnOiBOZ2JOYXZUYWJzZXRDb25maWcpIHtcclxuICAgIHRoaXMudHlwZSA9IGNvbmZpZy50eXBlO1xyXG4gICAgdGhpcy5qdXN0aWZ5ID0gY29uZmlnLmp1c3RpZnk7XHJcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gY29uZmlnLm9yaWVudGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VsZWN0cyB0aGUgdGFiIHdpdGggdGhlIGdpdmVuIGlkIGFuZCBzaG93cyBpdHMgYXNzb2NpYXRlZCBwYW5lLlxyXG4gICAqIEFueSBvdGhlciB0YWIgdGhhdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZCBiZWNvbWVzIHVuc2VsZWN0ZWQgYW5kIGl0cyBhc3NvY2lhdGVkIHBhbmUgaXMgaGlkZGVuLlxyXG4gICAqL1xyXG4gIHNlbGVjdCh0YWJJZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZFRhYiA9IHRoaXMuX2dldFRhYkJ5SWQodGFiSWQpO1xyXG4gICAgaWYgKHNlbGVjdGVkVGFiICYmICFzZWxlY3RlZFRhYi5kaXNhYmxlZCAmJiB0aGlzLmFjdGl2ZUlkICE9PSBzZWxlY3RlZFRhYi5pZCkge1xyXG4gICAgICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgdGhpcy50YWJDaGFuZ2UuZW1pdChcclxuICAgICAgICB7IGFjdGl2ZUlkOiB0aGlzLmFjdGl2ZUlkLCBuZXh0SWQ6IHNlbGVjdGVkVGFiLmlkLCBwcmV2ZW50RGVmYXVsdDogKCkgPT4geyBkZWZhdWx0UHJldmVudGVkID0gdHJ1ZTsgfSB9KTtcclxuXHJcbiAgICAgIGlmICghZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlSWQgPSBzZWxlY3RlZFRhYi5pZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xyXG4gICAgLy8gYXV0by1jb3JyZWN0IGFjdGl2ZUlkIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIHNldCBpbmNvcnJlY3RseSBhcyBpbnB1dFxyXG4gICAgY29uc3QgYWN0aXZlVGFiID0gdGhpcy5fZ2V0VGFiQnlJZCh0aGlzLmFjdGl2ZUlkKTtcclxuICAgIHRoaXMuYWN0aXZlSWQgPSBhY3RpdmVUYWIgPyBhY3RpdmVUYWIuaWQgOiAodGhpcy50YWJzLmxlbmd0aCA/IHRoaXMudGFicy5maXJzdC5pZCA6IG51bGwpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBfZ2V0VGFiQnlJZChpZDogc3RyaW5nKTogTmdiTmF2VGFiIHtcclxuICAgIGNvbnN0IHRhYnNXaXRoSWQ6IE5nYk5hdlRhYltdID0gdGhpcy50YWJzLmZpbHRlcih0YWIgPT4gdGFiLmlkID09PSBpZCk7XHJcbiAgICByZXR1cm4gdGFic1dpdGhJZC5sZW5ndGggPyB0YWJzV2l0aElkWzBdIDogbnVsbDtcclxuICB9XHJcbn1cclxuIl19