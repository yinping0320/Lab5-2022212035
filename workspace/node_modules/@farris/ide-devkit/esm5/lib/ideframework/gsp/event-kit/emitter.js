/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Disposable } from './disposable';
import { CompositeDisposable } from './composite-disposable';
// Essential: Utility class to be used when implementing event-based APIs that
// allows for handlers registered via `::on` to be invoked with calls to
// `::emit`. Instances of this class are intended to be used internally by
// classes that expose an event-based API.
//
// For example:
//
// ```coffee
// class User
//   constructor: ->
//     @emitter = new Emitter
//
//   onDidChangeName: (callback) ->
//     @emitter.on 'did-change-name', callback
//
//   setName: (name) ->
//     if name isnt @name
//       @name = name
//       @emitter.emit 'did-change-name', name
//     @name
// ```
var Emitter = /** @class */ (function () {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct an emitter.
    //
    // ```coffee
    // @emitter = new Emitter()
    // ```
    function Emitter() {
        this.disposed = false;
        this.clear();
    }
    /**
     * @param {?} exceptionHandler
     * @return {?}
     */
    Emitter.onEventHandlerException = /**
     * @param {?} exceptionHandler
     * @return {?}
     */
    function (exceptionHandler) {
        var _this = this;
        this.dispatch = this.simpleDispatch;
        if (this.exceptionHandlers.length === 0) {
            this.dispatch = this.exceptionHandlingDispatch;
        }
        this.exceptionHandlers.push(exceptionHandler);
        return new Disposable(function () {
            _this.exceptionHandlers.splice(_this.exceptionHandlers.indexOf(exceptionHandler), 1);
            if (_this.exceptionHandlers.length === 0) {
                return _this.dispatch = _this.simpleDispatch;
            }
        });
    };
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    Emitter.simpleDispatch = /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    function (handler, value) {
        return handler(value);
    };
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    Emitter.exceptionHandlingDispatch = /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    function (handler, value) {
        try {
            return handler(value);
        }
        catch (exception) {
            return this.exceptionHandlers.map(function (exceptionHandler) { return exceptionHandler(exception); });
        }
    };
    // Public: Clear out any existing subscribers.
    // Public: Clear out any existing subscribers.
    /**
     * @return {?}
     */
    Emitter.prototype.clear = 
    // Public: Clear out any existing subscribers.
    /**
     * @return {?}
     */
    function () {
        if (this.subscriptions) {
            this.subscriptions.dispose();
        }
        this.subscriptions = new CompositeDisposable();
        return this.handlersByEventName = {};
    };
    // Public: Unsubscribe all handlers.
    // Public: Unsubscribe all handlers.
    /**
     * @return {?}
     */
    Emitter.prototype.dispose = 
    // Public: Unsubscribe all handlers.
    /**
     * @return {?}
     */
    function () {
        this.subscriptions.dispose();
        this.handlersByEventName = null;
        this.disposed = true;
    };
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    Emitter.prototype.on = 
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    function (eventName, handler, unshift) {
        var _this = this;
        if (unshift === void 0) { unshift = false; }
        if (this.disposed) {
            throw new Error('Emitter has been disposed');
        }
        if (typeof handler !== 'function') {
            throw new Error('Handler must be a function');
        }
        /** @type {?} */
        var currentHandlers = this.handlersByEventName[eventName];
        if (currentHandlers) {
            if (unshift) {
                this.handlersByEventName[eventName] = [handler].concat(currentHandlers);
            }
            else {
                this.handlersByEventName[eventName] = currentHandlers.concat(handler);
            }
        }
        else {
            this.handlersByEventName[eventName] = [handler];
        }
        // When the emitter is disposed, we want to dispose of all subscriptions.
        // However, we also need to stop tracking disposables when they're disposed
        // from outside, otherwise this class will hold references to all the
        // disposables it created (instead of just the active ones).
        /** @type {?} */
        var cleanup = new Disposable(function () {
            _this.subscriptions.remove(cleanup);
            return _this.off(eventName, handler);
        });
        this.subscriptions.add(cleanup);
        return cleanup;
    };
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    Emitter.prototype.once = 
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    function (eventName, handler, unshift) {
        if (unshift === void 0) { unshift = false; }
        /** @type {?} */
        var disposable;
        /** @type {?} */
        var wrapped = function (value) {
            disposable.dispose();
            handler(value);
        };
        disposable = this.on(eventName, wrapped, unshift);
        return disposable;
    };
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    Emitter.prototype.preempt = 
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    function (eventName, handler) {
        this.on(eventName, handler, true);
    };
    // Private: Used by the disposable.
    // Private: Used by the disposable.
    /**
     * @param {?} eventName
     * @param {?} handlerToRemove
     * @return {?}
     */
    Emitter.prototype.off = 
    // Private: Used by the disposable.
    /**
     * @param {?} eventName
     * @param {?} handlerToRemove
     * @return {?}
     */
    function (eventName, handlerToRemove) {
        var e_1, _a;
        if (this.disposed) {
            return;
        }
        /** @type {?} */
        var oldHandlers = this.handlersByEventName[eventName];
        if (oldHandlers) {
            /** @type {?} */
            var newHandlers = [];
            try {
                for (var oldHandlers_1 = tslib_1.__values(oldHandlers), oldHandlers_1_1 = oldHandlers_1.next(); !oldHandlers_1_1.done; oldHandlers_1_1 = oldHandlers_1.next()) {
                    var handler = oldHandlers_1_1.value;
                    if (handler !== handlerToRemove) {
                        newHandlers.push(handler);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (oldHandlers_1_1 && !oldHandlers_1_1.done && (_a = oldHandlers_1.return)) _a.call(oldHandlers_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (newHandlers.length > 0) {
                this.handlersByEventName[eventName] = newHandlers;
            }
            else {
                delete this.handlersByEventName[eventName];
            }
        }
    };
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    Emitter.prototype.emit = 
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    function (eventName, value) {
        var e_2, _a;
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            var handlers = this.handlersByEventName[eventName];
            try {
                for (var handlers_1 = tslib_1.__values(handlers), handlers_1_1 = handlers_1.next(); !handlers_1_1.done; handlers_1_1 = handlers_1.next()) {
                    var handler = handlers_1_1.value;
                    Emitter.dispatch(handler, value);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (handlers_1_1 && !handlers_1_1.done && (_a = handlers_1.return)) _a.call(handlers_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    Emitter.prototype.emitAsync = /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    function (eventName, value) {
        var e_3, _a;
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            var results = [];
            try {
                for (var _b = tslib_1.__values(this.handlersByEventName[eventName]), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var handler = _c.value;
                    results.push(Emitter.dispatch(handler, value));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return Promise.all(results).then(function () { });
        }
        return Promise.resolve();
    };
    /**
     * @return {?}
     */
    Emitter.prototype.getEventNames = /**
     * @return {?}
     */
    function () {
        return Object.keys(this.handlersByEventName);
    };
    /**
     * @param {?} eventName
     * @return {?}
     */
    Emitter.prototype.listenerCountForEventName = /**
     * @param {?} eventName
     * @return {?}
     */
    function (eventName) {
        return this.handlersByEventName && this.handlersByEventName[eventName] ? this.handlersByEventName[eventName].length : 0;
    };
    /**
     * @return {?}
     */
    Emitter.prototype.getTotalListenerCount = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = 0;
        for (var eventName in this.handlersByEventName) {
            if (this.handlersByEventName.hasOwnProperty(eventName)) {
                result += this.handlersByEventName[eventName].length;
            }
        }
        return result;
    };
    Emitter.exceptionHandlers = [];
    Emitter.dispatch = Emitter.simpleDispatch;
    return Emitter;
}());
export { Emitter };
if (false) {
    /** @type {?} */
    Emitter.exceptionHandlers;
    /** @type {?} */
    Emitter.dispatch;
    /**
     * @type {?}
     * @private
     */
    Emitter.prototype.disposed;
    /**
     * @type {?}
     * @private
     */
    Emitter.prototype.subscriptions;
    /**
     * @type {?}
     * @private
     */
    Emitter.prototype.handlersByEventName;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1pdHRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvaWRlLWRldmtpdC8iLCJzb3VyY2VzIjpbImxpYi9pZGVmcmFtZXdvcmsvZ3NwL2V2ZW50LWtpdC9lbWl0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUMxQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCN0Q7SUFxQ0UsTUFBTTtJQUNOLHlDQUF5QztJQUN6QyxNQUFNO0lBRU4sZ0NBQWdDO0lBQ2hDLEVBQUU7SUFDRixZQUFZO0lBQ1osMkJBQTJCO0lBQzNCLE1BQU07SUFDTjtRQTFDUSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBMkN2QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDZixDQUFDOzs7OztJQXZDTSwrQkFBdUI7Ozs7SUFBOUIsVUFBK0IsZ0JBQWdCO1FBQS9DLGlCQWNDO1FBYkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO1FBQ3BDLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUM7U0FDaEQ7UUFFRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFOUMsT0FBTyxJQUFJLFVBQVUsQ0FBQztZQUNwQixLQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNuRixJQUFJLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUN2QyxPQUFPLEtBQUksQ0FBQyxRQUFRLEdB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LENBQUMsTUFBTSxDQUFDO2FBQ3REO1NBQ0Y7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBeE5NLHlCQUFpQixHQUFHLEVBQUUsQ0FBQztJQUN2QixnQkFBUSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7SUF3TjNDLGNBQUM7Q0FBQSxBQTFORCxJQTBOQztTQTFOWSxPQUFPOzs7SUFDbEIsMEJBQThCOztJQUM5QixpQkFBeUM7Ozs7O0lBRXpDLDJCQUF5Qjs7Ozs7SUFDekIsZ0NBQTJDOzs7OztJQUMzQyxzQ0FBaUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi9kaXNwb3NhYmxlJztcclxuaW1wb3J0IHsgQ29tcG9zaXRlRGlzcG9zYWJsZSB9IGZyb20gJy4vY29tcG9zaXRlLWRpc3Bvc2FibGUnO1xyXG5cclxuLy8gRXNzZW50aWFsOiBVdGlsaXR5IGNsYXNzIHRvIGJlIHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgZXZlbnQtYmFzZWQgQVBJcyB0aGF0XHJcbi8vIGFsbG93cyBmb3IgaGFuZGxlcnMgcmVnaXN0ZXJlZCB2aWEgYDo6b25gIHRvIGJlIGludm9rZWQgd2l0aCBjYWxscyB0b1xyXG4vLyBgOjplbWl0YC4gSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGludGVuZGVkIHRvIGJlIHVzZWQgaW50ZXJuYWxseSBieVxyXG4vLyBjbGFzc2VzIHRoYXQgZXhwb3NlIGFuIGV2ZW50LWJhc2VkIEFQSS5cclxuLy9cclxuLy8gRm9yIGV4YW1wbGU6XHJcbi8vXHJcbi8vIGBgYGNvZmZlZVxyXG4vLyBjbGFzcyBVc2VyXHJcbi8vICAgY29uc3RydWN0b3I6IC0+XHJcbi8vICAgICBAZW1pdHRlciA9IG5ldyBFbWl0dGVyXHJcbi8vXHJcbi8vICAgb25EaWRDaGFuZ2VOYW1lOiAoY2FsbGJhY2spIC0+XHJcbi8vICAgICBAZW1pdHRlci5vbiAnZGlkLWNoYW5nZS1uYW1lJywgY2FsbGJhY2tcclxuLy9cclxuLy8gICBzZXROYW1lOiAobmFtZSkgLT5cclxuLy8gICAgIGlmIG5hbWUgaXNudCBAbmFtZVxyXG4vLyAgICAgICBAbmFtZSA9IG5hbWVcclxuLy8gICAgICAgQGVtaXR0ZXIuZW1pdCAnZGlkLWNoYW5nZS1uYW1lJywgbmFtZVxyXG4vLyAgICAgQG5hbWVcclxuLy8gYGBgXHJcbmV4cG9ydCBjbGFzcyBFbWl0dGVyIHtcclxuICBzdGF0aWMgZXhjZXB0aW9uSGFuZGxlcnMgPSBbXTtcclxuICBzdGF0aWMgZGlzcGF0Y2ggPSBFbWl0dGVyLnNpbXBsZURpc3BhdGNoO1xyXG5cclxuICBwcml2YXRlIGRpc3Bvc2VkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBDb21wb3NpdGVEaXNwb3NhYmxlO1xyXG4gIHByaXZhdGUgaGFuZGxlcnNCeUV2ZW50TmFtZTogYW55O1xyXG5cclxuXHJcbiAgc3RhdGljIG9uRXZlbnRIYW5kbGVyRXhjZXB0aW9uKGV4Y2VwdGlvbkhhbmRsZXIpIHtcclxuICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLnNpbXBsZURpc3BhdGNoO1xyXG4gICAgaWYgKHRoaXMuZXhjZXB0aW9uSGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmV4Y2VwdGlvbkhhbmRsaW5nRGlzcGF0Y2g7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5leGNlcHRpb25IYW5kbGVycy5wdXNoKGV4Y2VwdGlvbkhhbmRsZXIpO1xyXG5cclxuICAgIHJldHVybiBuZXcgRGlzcG9zYWJsZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuZXhjZXB0aW9uSGFuZGxlcnMuc3BsaWNlKHRoaXMuZXhjZXB0aW9uSGFuZGxlcnMuaW5kZXhPZihleGNlcHRpb25IYW5kbGVyKSwgMSk7XHJcbiAgICAgIGlmICh0aGlzLmV4Y2VwdGlvbkhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoID0gdGhpcy5zaW1wbGVEaXNwYXRjaDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgc2ltcGxlRGlzcGF0Y2goaGFuZGxlciwgdmFsdWUpIHtcclxuICAgIHJldHVybiBoYW5kbGVyKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBleGNlcHRpb25IYW5kbGluZ0Rpc3BhdGNoKGhhbmRsZXIsIHZhbHVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gaGFuZGxlcih2YWx1ZSk7XHJcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZXhjZXB0aW9uSGFuZGxlcnMubWFwKChleGNlcHRpb25IYW5kbGVyKSA9PiBleGNlcHRpb25IYW5kbGVyKGV4Y2VwdGlvbikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8vLy8vXHJcbiAgLy8vIFNlY3Rpb246IENvbnN0cnVjdGlvbiBhbmQgRGVzdHJ1Y3Rpb25cclxuICAvLy8vLy9cclxuXHJcbiAgLy8gUHVibGljOiBDb25zdHJ1Y3QgYW4gZW1pdHRlci5cclxuICAvL1xyXG4gIC8vIGBgYGNvZmZlZVxyXG4gIC8vIEBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoKVxyXG4gIC8vIGBgYFxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jbGVhcigpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDbGVhciBvdXQgYW55IGV4aXN0aW5nIHN1YnNjcmliZXJzLlxyXG4gIGNsZWFyKCkge1xyXG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xyXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWUgPSB7fTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogVW5zdWJzY3JpYmUgYWxsIGhhbmRsZXJzLlxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGlzcG9zZSgpO1xyXG4gICAgdGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lID0gbnVsbDtcclxuICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vXHJcbiAgLy8vIFNlY3Rpb246IEV2ZW50IFN1YnNjcmlwdGlvblxyXG4gIC8vLy8vL1xyXG5cclxuICAvLyBQdWJsaWM6IFJlZ2lzdGVyIHRoZSBnaXZlbiBoYW5kbGVyIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgZXZlbnRzIGJ5XHJcbiAgLy8gdGhlIGdpdmVuIG5hbWUgYXJlIGVtaXR0ZWQgdmlhIHs6OmVtaXR9LlxyXG4gIC8vXHJcbiAgLy8gKiBgZXZlbnROYW1lYCB7U3RyaW5nfSBuYW1pbmcgdGhlIGV2ZW50IHRoYXQgeW91IHdhbnQgdG8gaW52b2tlIHRoZSBoYW5kbGVyXHJcbiAgLy8gICB3aGVuIGVtaXR0ZWQuXHJcbiAgLy8gKiBgaGFuZGxlcmAge0Z1bmN0aW9ufSB0byBpbnZva2Ugd2hlbiB7OjplbWl0fSBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cclxuICAvLyAgIGV2ZW50IG5hbWUuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Rpc3Bvc2FibGV9IG9uIHdoaWNoIGAuZGlzcG9zZSgpYCBjYW4gYmUgY2FsbGVkIHRvIHVuc3Vic2NyaWJlLlxyXG4gIG9uKGV2ZW50TmFtZSwgaGFuZGxlciwgdW5zaGlmdCA9IGZhbHNlKTogRGlzcG9zYWJsZSB7XHJcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtaXR0ZXIgaGFzIGJlZW4gZGlzcG9zZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY3VycmVudEhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lW2V2ZW50TmFtZV07XHJcbiAgICBpZiAoY3VycmVudEhhbmRsZXJzKSB7XHJcbiAgICAgIGlmICh1bnNoaWZ0KSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lW2V2ZW50TmFtZV0gPSBbaGFuZGxlcl0uY29uY2F0KGN1cnJlbnRIYW5kbGVycyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lW2V2ZW50TmFtZV0gPSBjdXJyZW50SGFuZGxlcnMuY29uY2F0KGhhbmRsZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSA9IFtoYW5kbGVyXTtcclxuICAgIH1cclxuICAgIC8vIFdoZW4gdGhlIGVtaXR0ZXIgaXMgZGlzcG9zZWQsIHdlIHdhbnQgdG8gZGlzcG9zZSBvZiBhbGwgc3Vic2NyaXB0aW9ucy5cclxuICAgIC8vIEhvd2V2ZXIsIHdlIGFsc28gbmVlZCB0byBzdG9wIHRyYWNraW5nIGRpc3Bvc2FibGVzIHdoZW4gdGhleSdyZSBkaXNwb3NlZFxyXG4gICAgLy8gZnJvbSBvdXRzaWRlLCBvdGhlcndpc2UgdGhpcyBjbGFzcyB3aWxsIGhvbGQgcmVmZXJlbmNlcyB0byBhbGwgdGhlXHJcbiAgICAvLyBkaXNwb3NhYmxlcyBpdCBjcmVhdGVkIChpbnN0ZWFkIG9mIGp1c3QgdGhlIGFjdGl2ZSBvbmVzKS5cclxuICAgIGNvbnN0IGNsZWFudXAgPSBuZXcgRGlzcG9zYWJsZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5yZW1vdmUoY2xlYW51cCk7XHJcbiAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKGNsZWFudXApO1xyXG4gICAgcmV0dXJuIGNsZWFudXA7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IFJlZ2lzdGVyIHRoZSBnaXZlbiBoYW5kbGVyIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgdGhlIG5leHQgdGltZSBhblxyXG4gIC8vIGV2ZW50cyB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzIGVtaXR0ZWQgdmlhIHs6OmVtaXR9LlxyXG4gIC8vXHJcbiAgLy8gKiBgZXZlbnROYW1lYCB7U3RyaW5nfSBuYW1pbmcgdGhlIGV2ZW50IHRoYXQgeW91IHdhbnQgdG8gaW52b2tlIHRoZSBoYW5kbGVyXHJcbiAgLy8gICB3aGVuIGVtaXR0ZWQuXHJcbiAgLy8gKiBgaGFuZGxlcmAge0Z1bmN0aW9ufSB0byBpbnZva2Ugd2hlbiB7OjplbWl0fSBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cclxuICAvLyAgIGV2ZW50IG5hbWUuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Rpc3Bvc2FibGV9IG9uIHdoaWNoIGAuZGlzcG9zZSgpYCBjYW4gYmUgY2FsbGVkIHRvIHVuc3Vic2NyaWJlLlxyXG4gIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyLCB1bnNoaWZ0ID0gZmFsc2UpOiBEaXNwb3NhYmxlIHtcclxuICAgIGxldCBkaXNwb3NhYmxlOiBEaXNwb3NhYmxlO1xyXG4gICAgY29uc3Qgd3JhcHBlZCA9ICh2YWx1ZSkgPT4ge1xyXG4gICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgaGFuZGxlcih2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgZGlzcG9zYWJsZSA9IHRoaXMub24oZXZlbnROYW1lLCB3cmFwcGVkLCB1bnNoaWZ0KTtcclxuICAgIHJldHVybiBkaXNwb3NhYmxlO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBSZWdpc3RlciB0aGUgZ2l2ZW4gaGFuZGxlciBmdW5jdGlvbiB0byBiZSBpbnZva2VkICpiZWZvcmUqIGFsbFxyXG4gIC8vIG90aGVyIGhhbmRsZXJzIGV4aXN0aW5nIGF0IHRoZSB0aW1lIG9mIHN1YnNjcmlwdGlvbiB3aGVuZXZlciBldmVudHMgYnkgdGhlXHJcbiAgLy8gZ2l2ZW4gbmFtZSBhcmUgZW1pdHRlZCB2aWEgezo6ZW1pdH0uXHJcbiAgLy9cclxuICAvLyBVc2UgdGhpcyBtZXRob2Qgd2hlbiB5b3UgbmVlZCB0byBiZSB0aGUgZmlyc3QgdG8gaGFuZGxlIGEgZ2l2ZW4gZXZlbnQuIFRoaXNcclxuICAvLyBjb3VsZCBiZSByZXF1aXJlZCB3aGVuIGEgZGF0YSBzdHJ1Y3R1cmUgaW4gYSBwYXJlbnQgb2JqZWN0IG5lZWRzIHRvIGJlXHJcbiAgLy8gdXBkYXRlZCBiZWZvcmUgdGhpcmQtcGFydHkgZXZlbnQgaGFuZGxlcnMgcmVnaXN0ZXJlZCBvbiBhIGNoaWxkIG9iamVjdCB2aWEgYVxyXG4gIC8vIHB1YmxpYyBBUEkgYXJlIGludm9rZWQuIFlvdXIgaGFuZGxlciBjb3VsZCBpdHNlbGYgYmUgcHJlZW1wdGVkIHZpYVxyXG4gIC8vIHN1YnNlcXVlbnQgY2FsbHMgdG8gdGhpcyBtZXRob2QsIGJ1dCB0aGlzIGNhbiBiZSBjb250cm9sbGVkIGJ5IGtlZXBpbmdcclxuICAvLyBtZXRob2RzIGJhc2VkIG9uIGA6OnByZWVtcHRgIHByaXZhdGUuXHJcbiAgLy9cclxuICAvLyAqIGBldmVudE5hbWVgIHtTdHJpbmd9IG5hbWluZyB0aGUgZXZlbnQgdGhhdCB5b3Ugd2FudCB0byBpbnZva2UgdGhlIGhhbmRsZXJcclxuICAvLyAgIHdoZW4gZW1pdHRlZC5cclxuICAvLyAqIGBoYW5kbGVyYCB7RnVuY3Rpb259IHRvIGludm9rZSB3aGVuIHs6OmVtaXR9IGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxyXG4gIC8vICAgZXZlbnQgbmFtZS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7RGlzcG9zYWJsZX0gb24gd2hpY2ggYC5kaXNwb3NlKClgIGNhbiBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXHJcbiAgcHJlZW1wdChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgIHRoaXMub24oZXZlbnROYW1lLCBoYW5kbGVyLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8vIFByaXZhdGU6IFVzZWQgYnkgdGhlIGRpc3Bvc2FibGUuXHJcbiAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlclRvUmVtb3ZlKSB7XHJcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb2xkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXTtcclxuXHJcbiAgICBpZiAob2xkSGFuZGxlcnMpIHtcclxuICAgICAgY29uc3QgbmV3SGFuZGxlcnMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIG9sZEhhbmRsZXJzKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZXIgIT09IGhhbmRsZXJUb1JlbW92ZSkge1xyXG4gICAgICAgICAgbmV3SGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld0hhbmRsZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSA9IG5ld0hhbmRsZXJzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8vLy8vXHJcbiAgLy8vIFNlY3Rpb246IEV2ZW50IEVtaXNzaW9uXHJcbiAgLy8vLy8vXHJcblxyXG4gIC8vIFB1YmxpYzogSW52b2tlIGhhbmRsZXJzIHJlZ2lzdGVyZWQgdmlhIHs6Om9ufSBmb3IgdGhlIGdpdmVuIGV2ZW50IG5hbWUuXHJcbiAgLy9cclxuICAvLyAqIGBldmVudE5hbWVgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0LiBIYW5kbGVycyByZWdpc3RlcmVkIHdpdGggezo6b259XHJcbiAgLy8gICBmb3IgdGhlIHNhbWUgbmFtZSB3aWxsIGJlIGludm9rZWQuXHJcbiAgLy8gKiBgdmFsdWVgIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGlzIHZhbHVlIGFzIGFuIGFyZ3VtZW50LlxyXG4gIGVtaXQoZXZlbnROYW1lLCB2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZSAmJiB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSkge1xyXG4gICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdO1xyXG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcclxuICAgICAgICBFbWl0dGVyLmRpc3BhdGNoKGhhbmRsZXIsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZW1pdEFzeW5jKGV2ZW50TmFtZSwgdmFsdWUpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgaWYgKHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZSAmJiB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSkge1xyXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSkge1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChFbWl0dGVyLmRpc3BhdGNoKGhhbmRsZXIsIHZhbHVlKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oZnVuY3Rpb24oKSB7fSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICBnZXRFdmVudE5hbWVzKCk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWUpO1xyXG4gIH1cclxuXHJcbiAgbGlzdGVuZXJDb3VudEZvckV2ZW50TmFtZShldmVudE5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWUgJiYgdGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lW2V2ZW50TmFtZV0gPyB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXS5sZW5ndGggOiAwO1xyXG4gIH1cclxuXHJcbiAgZ2V0VG90YWxMaXN0ZW5lckNvdW50KCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWUpIHtcclxuICAgICAgaWYgKHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZS5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuIl19