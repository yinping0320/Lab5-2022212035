/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Disposable } from './disposable';
import { CompositeDisposable } from './composite-disposable';
// Essential: Utility class to be used when implementing event-based APIs that
// allows for handlers registered via `::on` to be invoked with calls to
// `::emit`. Instances of this class are intended to be used internally by
// classes that expose an event-based API.
//
// For example:
//
// ```coffee
// class User
//   constructor: ->
//     @emitter = new Emitter
//
//   onDidChangeName: (callback) ->
//     @emitter.on 'did-change-name', callback
//
//   setName: (name) ->
//     if name isnt @name
//       @name = name
//       @emitter.emit 'did-change-name', name
//     @name
// ```
export class Emitter {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct an emitter.
    //
    // ```coffee
    // @emitter = new Emitter()
    // ```
    constructor() {
        this.disposed = false;
        this.clear();
    }
    /**
     * @param {?} exceptionHandler
     * @return {?}
     */
    static onEventHandlerException(exceptionHandler) {
        this.dispatch = this.simpleDispatch;
        if (this.exceptionHandlers.length === 0) {
            this.dispatch = this.exceptionHandlingDispatch;
        }
        this.exceptionHandlers.push(exceptionHandler);
        return new Disposable(() => {
            this.exceptionHandlers.splice(this.exceptionHandlers.indexOf(exceptionHandler), 1);
            if (this.exceptionHandlers.length === 0) {
                return this.dispatch = this.simpleDispatch;
            }
        });
    }
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    static simpleDispatch(handler, value) {
        return handler(value);
    }
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    static exceptionHandlingDispatch(handler, value) {
        try {
            return handler(value);
        }
        catch (exception) {
            return this.exceptionHandlers.map((exceptionHandler) => exceptionHandler(exception));
        }
    }
    // Public: Clear out any existing subscribers.
    /**
     * @return {?}
     */
    clear() {
        if (this.subscriptions) {
            this.subscriptions.dispose();
        }
        this.subscriptions = new CompositeDisposable();
        return this.handlersByEventName = {};
    }
    // Public: Unsubscribe all handlers.
    /**
     * @return {?}
     */
    dispose() {
        this.subscriptions.dispose();
        this.handlersByEventName = null;
        this.disposed = true;
    }
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    on(eventName, handler, unshift = false) {
        if (this.disposed) {
            throw new Error('Emitter has been disposed');
        }
        if (typeof handler !== 'function') {
            throw new Error('Handler must be a function');
        }
        /** @type {?} */
        const currentHandlers = this.handlersByEventName[eventName];
        if (currentHandlers) {
            if (unshift) {
                this.handlersByEventName[eventName] = [handler].concat(currentHandlers);
            }
            else {
                this.handlersByEventName[eventName] = currentHandlers.concat(handler);
            }
        }
        else {
            this.handlersByEventName[eventName] = [handler];
        }
        // When the emitter is disposed, we want to dispose of all subscriptions.
        // However, we also need to stop tracking disposables when they're disposed
        // from outside, otherwise this class will hold references to all the
        // disposables it created (instead of just the active ones).
        /** @type {?} */
        const cleanup = new Disposable(() => {
            this.subscriptions.remove(cleanup);
            return this.off(eventName, handler);
        });
        this.subscriptions.add(cleanup);
        return cleanup;
    }
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    once(eventName, handler, unshift = false) {
        /** @type {?} */
        let disposable;
        /** @type {?} */
        const wrapped = (value) => {
            disposable.dispose();
            handler(value);
        };
        disposable = this.on(eventName, wrapped, unshift);
        return disposable;
    }
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    preempt(eventName, handler) {
        this.on(eventName, handler, true);
    }
    // Private: Used by the disposable.
    /**
     * @param {?} eventName
     * @param {?} handlerToRemove
     * @return {?}
     */
    off(eventName, handlerToRemove) {
        if (this.disposed) {
            return;
        }
        /** @type {?} */
        const oldHandlers = this.handlersByEventName[eventName];
        if (oldHandlers) {
            /** @type {?} */
            const newHandlers = [];
            for (const handler of oldHandlers) {
                if (handler !== handlerToRemove) {
                    newHandlers.push(handler);
                }
            }
            if (newHandlers.length > 0) {
                this.handlersByEventName[eventName] = newHandlers;
            }
            else {
                delete this.handlersByEventName[eventName];
            }
        }
    }
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    emit(eventName, value) {
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            const handlers = this.handlersByEventName[eventName];
            for (const handler of handlers) {
                Emitter.dispatch(handler, value);
            }
        }
    }
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    emitAsync(eventName, value) {
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            const results = [];
            for (const handler of this.handlersByEventName[eventName]) {
                results.push(Emitter.dispatch(handler, value));
            }
            return Promise.all(results).then(function () { });
        }
        return Promise.resolve();
    }
    /**
     * @return {?}
     */
    getEventNames() {
        return Object.keys(this.handlersByEventName);
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    listenerCountForEventName(eventName) {
        return this.handlersByEventName && this.handlersByEventName[eventName] ? this.handlersByEventName[eventName].length : 0;
    }
    /**
     * @return {?}
     */
    getTotalListenerCount() {
        /** @type {?} */
        let result = 0;
        for (const eventName in this.handlersByEventName) {
            if (this.handlersByEventName.hasOwnProperty(eventName)) {
                result += this.handlersByEventName[eventName].length;
            }
        }
        return result;
    }
}
Emitter.exceptionHandlers = [];
Emitter.dispatch = Emitter.simpleDispatch;
if (false) {
    /** @type {?} */
    Emitter.exceptionHandlers;
    /** @type {?} */
    Emitter.dispatch;
    /**
     * @type {?}
     * @private
     */
    Emitter.prototype.disposed;
    /**
     * @type {?}
     * @private
     */
    Emitter.prototype.subscriptions;
    /**
     * @type {?}
     * @private
     */
    Emitter.prototype.handlersByEventName;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1pdHRlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvaWRlLWRldmtpdC8iLCJzb3VyY2VzIjpbImxpYi9pZGVmcmFtZXdvcmsvZ3NwL2V2ZW50LWtpdC9lbWl0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHdCQUF3QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUI3RCxNQUFNLE9BQU8sT0FBTzs7Ozs7Ozs7O0lBOENsQjtRQTFDUSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBMkN2QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDZixDQUFDOzs7OztJQXZDRCxNQUFNLENBQUMsdUJBQXVCLENBQUMsZ0JBQWdCO1FBQzdDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztRQUNwQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDO1NBQ2hEO1FBRUQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTlDLE9BQU8sSUFBSSxVQUFVLENBQUMsR0FBRyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ25GLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ3ZDLE9BQU8sSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO2FBQzVDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOzs7Ozs7SUFF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QUFHLE9BQU8sQ0FBQyxjQUFjLENBQUM7OztJQUR6QywwQkFBOEI7O0lBQzlCLGlCQUF5Qzs7Ozs7SUFFekMsMkJBQXlCOzs7OztJQUN6QixnQ0FBMkM7Ozs7O0lBQzNDLHNDQUFpQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuL2Rpc3Bvc2FibGUnO1xyXG5pbXBvcnQgeyBDb21wb3NpdGVEaXNwb3NhYmxlIH0gZnJvbSAnLi9jb21wb3NpdGUtZGlzcG9zYWJsZSc7XHJcblxyXG4vLyBFc3NlbnRpYWw6IFV0aWxpdHkgY2xhc3MgdG8gYmUgdXNlZCB3aGVuIGltcGxlbWVudGluZyBldmVudC1iYXNlZCBBUElzIHRoYXRcclxuLy8gYWxsb3dzIGZvciBoYW5kbGVycyByZWdpc3RlcmVkIHZpYSBgOjpvbmAgdG8gYmUgaW52b2tlZCB3aXRoIGNhbGxzIHRvXHJcbi8vIGA6OmVtaXRgLiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IGJ5XHJcbi8vIGNsYXNzZXMgdGhhdCBleHBvc2UgYW4gZXZlbnQtYmFzZWQgQVBJLlxyXG4vL1xyXG4vLyBGb3IgZXhhbXBsZTpcclxuLy9cclxuLy8gYGBgY29mZmVlXHJcbi8vIGNsYXNzIFVzZXJcclxuLy8gICBjb25zdHJ1Y3RvcjogLT5cclxuLy8gICAgIEBlbWl0dGVyID0gbmV3IEVtaXR0ZXJcclxuLy9cclxuLy8gICBvbkRpZENoYW5nZU5hbWU6IChjYWxsYmFjaykgLT5cclxuLy8gICAgIEBlbWl0dGVyLm9uICdkaWQtY2hhbmdlLW5hbWUnLCBjYWxsYmFja1xyXG4vL1xyXG4vLyAgIHNldE5hbWU6IChuYW1lKSAtPlxyXG4vLyAgICAgaWYgbmFtZSBpc250IEBuYW1lXHJcbi8vICAgICAgIEBuYW1lID0gbmFtZVxyXG4vLyAgICAgICBAZW1pdHRlci5lbWl0ICdkaWQtY2hhbmdlLW5hbWUnLCBuYW1lXHJcbi8vICAgICBAbmFtZVxyXG4vLyBgYGBcclxuZXhwb3J0IGNsYXNzIEVtaXR0ZXIge1xyXG4gIHN0YXRpYyBleGNlcHRpb25IYW5kbGVycyA9IFtdO1xyXG4gIHN0YXRpYyBkaXNwYXRjaCA9IEVtaXR0ZXIuc2ltcGxlRGlzcGF0Y2g7XHJcblxyXG4gIHByaXZhdGUgZGlzcG9zZWQgPSBmYWxzZTtcclxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IENvbXBvc2l0ZURpc3Bvc2FibGU7XHJcbiAgcHJpdmF0ZSBoYW5kbGVyc0J5RXZlbnROYW1lOiBhbnk7XHJcblxyXG5cclxuICBzdGF0aWMgb25FdmVudEhhbmRsZXJFeGNlcHRpb24oZXhjZXB0aW9uSGFuZGxlcikge1xyXG4gICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuc2ltcGxlRGlzcGF0Y2g7XHJcbiAgICBpZiAodGhpcy5leGNlcHRpb25IYW5kbGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZXhjZXB0aW9uSGFuZGxpbmdEaXNwYXRjaDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmV4Y2VwdGlvbkhhbmRsZXJzLnB1c2goZXhjZXB0aW9uSGFuZGxlcik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEaXNwb3NhYmxlKCgpID0+IHtcclxuICAgICAgdGhpcy5leGNlcHRpb25IYW5kbGVycy5zcGxpY2UodGhpcy5leGNlcHRpb25IYW5kbGVycy5pbmRleE9mKGV4Y2VwdGlvbkhhbmRsZXIpLCAxKTtcclxuICAgICAgaWYgKHRoaXMuZXhjZXB0aW9uSGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLnNpbXBsZURpc3BhdGNoO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBzaW1wbGVEaXNwYXRjaChoYW5kbGVyLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGhhbmRsZXIodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGV4Y2VwdGlvbkhhbmRsaW5nRGlzcGF0Y2goaGFuZGxlciwgdmFsdWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBoYW5kbGVyKHZhbHVlKTtcclxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5leGNlcHRpb25IYW5kbGVycy5tYXAoKGV4Y2VwdGlvbkhhbmRsZXIpID0+IGV4Y2VwdGlvbkhhbmRsZXIoZXhjZXB0aW9uKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLy8vLy9cclxuICAvLy8gU2VjdGlvbjogQ29uc3RydWN0aW9uIGFuZCBEZXN0cnVjdGlvblxyXG4gIC8vLy8vL1xyXG5cclxuICAvLyBQdWJsaWM6IENvbnN0cnVjdCBhbiBlbWl0dGVyLlxyXG4gIC8vXHJcbiAgLy8gYGBgY29mZmVlXHJcbiAgLy8gQGVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpXHJcbiAgLy8gYGBgXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNsZWFyKCk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENsZWFyIG91dCBhbnkgZXhpc3Rpbmcgc3Vic2NyaWJlcnMuXHJcbiAgY2xlYXIoKSB7XHJcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBVbnN1YnNjcmliZSBhbGwgaGFuZGxlcnMuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWUgPSBudWxsO1xyXG4gICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLy8vLy9cclxuICAvLy8gU2VjdGlvbjogRXZlbnQgU3Vic2NyaXB0aW9uXHJcbiAgLy8vLy8vXHJcblxyXG4gIC8vIFB1YmxpYzogUmVnaXN0ZXIgdGhlIGdpdmVuIGhhbmRsZXIgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuZXZlciBldmVudHMgYnlcclxuICAvLyB0aGUgZ2l2ZW4gbmFtZSBhcmUgZW1pdHRlZCB2aWEgezo6ZW1pdH0uXHJcbiAgLy9cclxuICAvLyAqIGBldmVudE5hbWVgIHtTdHJpbmd9IG5hbWluZyB0aGUgZXZlbnQgdGhhdCB5b3Ugd2FudCB0byBpbnZva2UgdGhlIGhhbmRsZXJcclxuICAvLyAgIHdoZW4gZW1pdHRlZC5cclxuICAvLyAqIGBoYW5kbGVyYCB7RnVuY3Rpb259IHRvIGludm9rZSB3aGVuIHs6OmVtaXR9IGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxyXG4gIC8vICAgZXZlbnQgbmFtZS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7RGlzcG9zYWJsZX0gb24gd2hpY2ggYC5kaXNwb3NlKClgIGNhbiBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXHJcbiAgb24oZXZlbnROYW1lLCBoYW5kbGVyLCB1bnNoaWZ0ID0gZmFsc2UpOiBEaXNwb3NhYmxlIHtcclxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW1pdHRlciBoYXMgYmVlbiBkaXNwb3NlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXTtcclxuICAgIGlmIChjdXJyZW50SGFuZGxlcnMpIHtcclxuICAgICAgaWYgKHVuc2hpZnQpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSA9IFtoYW5kbGVyXS5jb25jYXQoY3VycmVudEhhbmRsZXJzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSA9IGN1cnJlbnRIYW5kbGVycy5jb25jYXQoaGFuZGxlcik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdID0gW2hhbmRsZXJdO1xyXG4gICAgfVxyXG4gICAgLy8gV2hlbiB0aGUgZW1pdHRlciBpcyBkaXNwb3NlZCwgd2Ugd2FudCB0byBkaXNwb3NlIG9mIGFsbCBzdWJzY3JpcHRpb25zLlxyXG4gICAgLy8gSG93ZXZlciwgd2UgYWxzbyBuZWVkIHRvIHN0b3AgdHJhY2tpbmcgZGlzcG9zYWJsZXMgd2hlbiB0aGV5J3JlIGRpc3Bvc2VkXHJcbiAgICAvLyBmcm9tIG91dHNpZGUsIG90aGVyd2lzZSB0aGlzIGNsYXNzIHdpbGwgaG9sZCByZWZlcmVuY2VzIHRvIGFsbCB0aGVcclxuICAgIC8vIGRpc3Bvc2FibGVzIGl0IGNyZWF0ZWQgKGluc3RlYWQgb2YganVzdCB0aGUgYWN0aXZlIG9uZXMpLlxyXG4gICAgY29uc3QgY2xlYW51cCA9IG5ldyBEaXNwb3NhYmxlKCgpID0+IHtcclxuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnJlbW92ZShjbGVhbnVwKTtcclxuICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoY2xlYW51cCk7XHJcbiAgICByZXR1cm4gY2xlYW51cDtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogUmVnaXN0ZXIgdGhlIGdpdmVuIGhhbmRsZXIgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB0aGUgbmV4dCB0aW1lIGFuXHJcbiAgLy8gZXZlbnRzIHdpdGggdGhlIGdpdmVuIG5hbWUgaXMgZW1pdHRlZCB2aWEgezo6ZW1pdH0uXHJcbiAgLy9cclxuICAvLyAqIGBldmVudE5hbWVgIHtTdHJpbmd9IG5hbWluZyB0aGUgZXZlbnQgdGhhdCB5b3Ugd2FudCB0byBpbnZva2UgdGhlIGhhbmRsZXJcclxuICAvLyAgIHdoZW4gZW1pdHRlZC5cclxuICAvLyAqIGBoYW5kbGVyYCB7RnVuY3Rpb259IHRvIGludm9rZSB3aGVuIHs6OmVtaXR9IGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxyXG4gIC8vICAgZXZlbnQgbmFtZS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7RGlzcG9zYWJsZX0gb24gd2hpY2ggYC5kaXNwb3NlKClgIGNhbiBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXHJcbiAgb25jZShldmVudE5hbWUsIGhhbmRsZXIsIHVuc2hpZnQgPSBmYWxzZSk6IERpc3Bvc2FibGUge1xyXG4gICAgbGV0IGRpc3Bvc2FibGU6IERpc3Bvc2FibGU7XHJcbiAgICBjb25zdCB3cmFwcGVkID0gKHZhbHVlKSA9PiB7XHJcbiAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICBoYW5kbGVyKHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBkaXNwb3NhYmxlID0gdGhpcy5vbihldmVudE5hbWUsIHdyYXBwZWQsIHVuc2hpZnQpO1xyXG4gICAgcmV0dXJuIGRpc3Bvc2FibGU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IFJlZ2lzdGVyIHRoZSBnaXZlbiBoYW5kbGVyIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgKmJlZm9yZSogYWxsXHJcbiAgLy8gb3RoZXIgaGFuZGxlcnMgZXhpc3RpbmcgYXQgdGhlIHRpbWUgb2Ygc3Vic2NyaXB0aW9uIHdoZW5ldmVyIGV2ZW50cyBieSB0aGVcclxuICAvLyBnaXZlbiBuYW1lIGFyZSBlbWl0dGVkIHZpYSB7OjplbWl0fS5cclxuICAvL1xyXG4gIC8vIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHlvdSBuZWVkIHRvIGJlIHRoZSBmaXJzdCB0byBoYW5kbGUgYSBnaXZlbiBldmVudC4gVGhpc1xyXG4gIC8vIGNvdWxkIGJlIHJlcXVpcmVkIHdoZW4gYSBkYXRhIHN0cnVjdHVyZSBpbiBhIHBhcmVudCBvYmplY3QgbmVlZHMgdG8gYmVcclxuICAvLyB1cGRhdGVkIGJlZm9yZSB0aGlyZC1wYXJ0eSBldmVudCBoYW5kbGVycyByZWdpc3RlcmVkIG9uIGEgY2hpbGQgb2JqZWN0IHZpYSBhXHJcbiAgLy8gcHVibGljIEFQSSBhcmUgaW52b2tlZC4gWW91ciBoYW5kbGVyIGNvdWxkIGl0c2VsZiBiZSBwcmVlbXB0ZWQgdmlhXHJcbiAgLy8gc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIG1ldGhvZCwgYnV0IHRoaXMgY2FuIGJlIGNvbnRyb2xsZWQgYnkga2VlcGluZ1xyXG4gIC8vIG1ldGhvZHMgYmFzZWQgb24gYDo6cHJlZW1wdGAgcHJpdmF0ZS5cclxuICAvL1xyXG4gIC8vICogYGV2ZW50TmFtZWAge1N0cmluZ30gbmFtaW5nIHRoZSBldmVudCB0aGF0IHlvdSB3YW50IHRvIGludm9rZSB0aGUgaGFuZGxlclxyXG4gIC8vICAgd2hlbiBlbWl0dGVkLlxyXG4gIC8vICogYGhhbmRsZXJgIHtGdW5jdGlvbn0gdG8gaW52b2tlIHdoZW4gezo6ZW1pdH0gaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXHJcbiAgLy8gICBldmVudCBuYW1lLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtEaXNwb3NhYmxlfSBvbiB3aGljaCBgLmRpc3Bvc2UoKWAgY2FuIGJlIGNhbGxlZCB0byB1bnN1YnNjcmliZS5cclxuICBwcmVlbXB0KGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgdGhpcy5vbihldmVudE5hbWUsIGhhbmRsZXIsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJpdmF0ZTogVXNlZCBieSB0aGUgZGlzcG9zYWJsZS5cclxuICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyVG9SZW1vdmUpIHtcclxuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvbGRIYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdO1xyXG5cclxuICAgIGlmIChvbGRIYW5kbGVycykge1xyXG4gICAgICBjb25zdCBuZXdIYW5kbGVycyA9IFtdO1xyXG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2Ygb2xkSGFuZGxlcnMpIHtcclxuICAgICAgICBpZiAoaGFuZGxlciAhPT0gaGFuZGxlclRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICBuZXdIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobmV3SGFuZGxlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdID0gbmV3SGFuZGxlcnM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLy8vLy9cclxuICAvLy8gU2VjdGlvbjogRXZlbnQgRW1pc3Npb25cclxuICAvLy8vLy9cclxuXHJcbiAgLy8gUHVibGljOiBJbnZva2UgaGFuZGxlcnMgcmVnaXN0ZXJlZCB2aWEgezo6b259IGZvciB0aGUgZ2l2ZW4gZXZlbnQgbmFtZS5cclxuICAvL1xyXG4gIC8vICogYGV2ZW50TmFtZWAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQuIEhhbmRsZXJzIHJlZ2lzdGVyZWQgd2l0aCB7Ojpvbn1cclxuICAvLyAgIGZvciB0aGUgc2FtZSBuYW1lIHdpbGwgYmUgaW52b2tlZC5cclxuICAvLyAqIGB2YWx1ZWAgQ2FsbGJhY2tzIHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoaXMgdmFsdWUgYXMgYW4gYXJndW1lbnQuXHJcbiAgZW1pdChldmVudE5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lICYmIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdKSB7XHJcbiAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lW2V2ZW50TmFtZV07XHJcbiAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xyXG4gICAgICAgIEVtaXR0ZXIuZGlzcGF0Y2goaGFuZGxlciwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbWl0QXN5bmMoZXZlbnROYW1lLCB2YWx1ZSk6IFByb21pc2U8YW55PiB7XHJcbiAgICBpZiAodGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lICYmIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdKSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdKSB7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKEVtaXR0ZXIuZGlzcGF0Y2goaGFuZGxlciwgdmFsdWUpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbihmdW5jdGlvbigpIHt9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9XHJcblxyXG4gIGdldEV2ZW50TmFtZXMoKTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZSk7XHJcbiAgfVxyXG5cclxuICBsaXN0ZW5lckNvdW50Rm9yRXZlbnROYW1lKGV2ZW50TmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZSAmJiB0aGlzLmhhbmRsZXJzQnlFdmVudE5hbWVbZXZlbnROYW1lXSA/IHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZVtldmVudE5hbWVdLmxlbmd0aCA6IDA7XHJcbiAgfVxyXG5cclxuICBnZXRUb3RhbExpc3RlbmVyQ291bnQoKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gMDtcclxuICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIHRoaXMuaGFuZGxlcnNCeUV2ZW50TmFtZSkge1xyXG4gICAgICBpZiAodGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICByZXN1bHQgKz0gdGhpcy5oYW5kbGVyc0J5RXZlbnROYW1lW2V2ZW50TmFtZV0ubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufVxyXG4iXX0=