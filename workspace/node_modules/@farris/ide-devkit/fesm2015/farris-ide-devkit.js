import { TemplatePortal } from '@angular/cdk/portal';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { merge } from 'rxjs/observable/merge';
import { Overlay, OverlayModule } from '@angular/cdk/overlay';
import { first, last, pick, includes, assign, find, findIndex, merge as merge$1 } from 'lodash-es';
import { PerfectScrollbarModule } from '@farris/ui-perfect-scrollbar';
import { InputGroupModule } from '@farris/ui-input-group';
import { DatalistModule } from '@farris/ui-datalist';
import { NG_VALUE_ACCESSOR, FormsModule, NgControl } from '@angular/forms';
import { InputsModule } from '@progress/kendo-angular-inputs';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { NotifyService, NotifyModule } from '@farris/ui-notify';
import { ComboListModule } from '@farris/ui-combo-list';
import { BsModalService, ModalModule } from '@farris/ui-modal';
import { FarrisDatePickerModule } from '@farris/ui-datepicker';
import { NumberSpinnerModule } from '@farris/ui-number-spinner';
import { CommonModule, DOCUMENT } from '@angular/common';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { __decorate, __metadata, __awaiter } from 'tslib';
import { timer, BehaviorSubject, Subject, fromEvent as fromEvent$1, interval, forkJoin, Observable, of } from 'rxjs';
import { Injectable, ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Input, Output, NgModule, ComponentRef, ElementRef, ReflectiveInjector, TemplateRef, ContentChild, ContentChildren, Directive, QueryList, Optional, ViewContainerRef, HostListener, Renderer2, ViewChild, ComponentFactoryResolver, ViewChildren, ViewEncapsulation, Injector, Type, RendererFactory2, isDevMode, InjectionToken, forwardRef, Inject, NgZone, HostBinding, ApplicationRef, defineInjectable, inject, INJECTOR } from '@angular/core';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { filter, takeUntil, skip, debounceTime, throttle, mapTo, map } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AlertConfig {
    constructor() {
        /**
         * default alert type
         */
        this.type = 'warning';
        /**
         * is alerts are dismissible by default
         */
        this.dismissible = false;
        /**
         * default time before alert will dismiss
         */
        this.dismissOnTimeout = undefined;
    }
}
AlertConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*tslint:disable:no-invalid-this */
/**
 * @return {?}
 */
function OnChange() {
    /** @type {?} */
    const sufix = 'Change';
    return function OnChangeHandler(target, propertyKey) {
        /** @type {?} */
        const _key = ` __${propertyKey}Value`;
        Object.defineProperty(target, propertyKey, {
            /**
             * @return {?}
             */
            get() { return this[_key]; },
            /**
             * @param {?} value
             * @return {?}
             */
            set(value) {
                /** @type {?} */
                const prevValue = this[_key];
                this[_key] = value;
                if (prevValue !== value && this[propertyKey + sufix]) {
                    this[propertyKey + sufix].emit(value);
                }
            }
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AlertComponent {
    /**
     * @param {?} _config
     * @param {?} changeDetection
     */
    constructor(_config, changeDetection) {
        this.changeDetection = changeDetection;
        /**
         * Alert type.
         * Provides one of four bootstrap supported contextual classes:
         * `success`, `info`, `warning` and `danger`
         */
        this.type = 'warning';
        /**
         * If set, displays an inline "Close" button
         */
        this.dismissible = false;
        /**
         * Is alert visible
         */
        this.isOpen = true;
        /**
         * This event fires immediately after close instance method is called,
         * $event is an instance of Alert component.
         */
        this.onClose = new EventEmitter();
        /**
         * This event fires when alert closed, $event is an instance of Alert component
         */
        this.onClosed = new EventEmitter();
        this.classes = '';
        this.dismissibleChange = new EventEmitter();
        Object.assign(this, _config);
        this.dismissibleChange.subscribe((dismissible) => {
            this.classes = this.dismissible ? 'alert-dismissible' : '';
            this.changeDetection.markForCheck();
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.dismissOnTimeout) {
            // if dismissOnTimeout used as attr without binding, it will be a string
            setTimeout(() => this.close(), parseInt((/** @type {?} */ (this.dismissOnTimeout)), 10));
        }
    }
    // todo: animation ` If the .fade and .in classes are present on the element,
    // the alert will fade out before it is removed`
    /**
     * Closes an alert by removing it from the DOM.
     * @return {?}
     */
    close() {
        if (!this.isOpen) {
            return;
        }
        this.onClose.emit(this);
        this.isOpen = false;
        this.changeDetection.markForCheck();
        this.onClosed.emit(this);
    }
}
AlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'alert,bs-alert',
                template: "<ng-template [ngIf]=\"isOpen\">\r\n  <div [class]=\"'alert alert-' + type\" role=\"alert\" [ngClass]=\"classes\">\r\n    <ng-template [ngIf]=\"dismissible\">\r\n      <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"close()\">\r\n        <span aria-hidden=\"true\">&times;</span>\r\n        <span class=\"sr-only\">Close</span>\r\n      </button>\r\n    </ng-template>\r\n    <ng-content></ng-content>\r\n  </div>\r\n</ng-template>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
AlertComponent.ctorParameters = () => [
    { type: AlertConfig },
    { type: ChangeDetectorRef }
];
AlertComponent.propDecorators = {
    type: [{ type: Input }],
    dismissible: [{ type: Input }],
    dismissOnTimeout: [{ type: Input }],
    isOpen: [{ type: Input }],
    onClose: [{ type: Output }],
    onClosed: [{ type: Output }]
};
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], AlertComponent.prototype, "dismissible", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AlertModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return { ngModule: AlertModule, providers: [AlertConfig] };
    }
}
AlertModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [AlertComponent],
                exports: [AlertComponent],
                entryComponents: [AlertComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Default values provider for tooltip
 */
class TooltipConfig {
    constructor() {
        /**
         * tooltip placement, supported positions: 'top', 'bottom', 'left', 'right'
         */
        this.placement = 'top';
        /**
         * array of event names which triggers tooltip opening
         */
        this.triggers = 'hover focus';
    }
}
TooltipConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*tslint:disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * JS version of browser APIs. This library can only run in the browser.
 * @type {?}
 */
var win = (typeof window !== 'undefined' && window) || (/** @type {?} */ ({}));
/** @type {?} */
var document$1 = win.document;
/** @type {?} */
var location = win.location;
/** @type {?} */
var gc = win['gc'] ? () => win['gc']() : () => null;
/** @type {?} */
var performance = win['performance'] ? win['performance'] : null;
/** @type {?} */
const Event$1 = win['Event'];
/** @type {?} */
const MouseEvent = win['MouseEvent'];
/** @type {?} */
const KeyboardEvent = win['KeyboardEvent'];
/** @type {?} */
const EventTarget = win['EventTarget'];
/** @type {?} */
const History = win['History'];
/** @type {?} */
const Location = win['Location'];
/** @type {?} */
const EventListener = win['EventListener'];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let guessedVersion;
/**
 * @return {?}
 */
function _guessBsVersion() {
    if (typeof document === 'undefined') {
        return null;
    }
    /** @type {?} */
    const spanEl = document.createElement('span');
    spanEl.innerText = 'test bs version';
    document.body.appendChild(spanEl);
    spanEl.classList.add('d-none');
    /** @type {?} */
    const rect = spanEl.getBoundingClientRect();
    document.body.removeChild(spanEl);
    if (!rect) {
        return 'bs3';
    }
    return rect.top === 0 ? 'bs4' : 'bs3';
}
// todo: in ngx-bootstrap, bs4 will became a default one
/**
 * @return {?}
 */
function isBs3() {
    if (typeof win === 'undefined') {
        return true;
    }
    if (typeof win.__theme === 'undefined') {
        if (guessedVersion) {
            return guessedVersion === 'bs3';
        }
        guessedVersion = _guessBsVersion();
        return guessedVersion === 'bs3';
    }
    return win.__theme !== 'bs4';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TooltipContainerComponent {
    /**
     * @param {?} config
     */
    constructor(config) {
        Object.assign(this, config);
    }
    /**
     * @return {?}
     */
    get isBs3() {
        return isBs3();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.classMap = { in: false, fade: false };
        this.classMap[this.placement] = true;
        this.classMap[`tooltip-${this.placement}`] = true;
        this.classMap.in = true;
        if (this.animation) {
            this.classMap.fade = true;
        }
        if (this.containerClass) {
            this.classMap[this.containerClass] = true;
        }
    }
}
TooltipContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'bs-tooltip-container',
                changeDetection: ChangeDetectionStrategy.OnPush,
                // tslint:disable-next-line
                host: {
                    '[class]': '"tooltip in tooltip-" + placement + " " + "bs-tooltip-" + placement + " " + placement + " " + containerClass',
                    '[class.show]': '!isBs3',
                    role: 'tooltip'
                },
                template: `
    <div class="tooltip-arrow arrow"></div>
    <div class="tooltip-inner"><ng-content></ng-content></div>
    `,
                styles: [`
    :host.tooltip {
      display: block;
    }
    :host.bs-tooltip-top .arrow, :host.bs-tooltip-bottom .arrow {
      left: 50%;
      margin-left: -6px;
    }
    :host.bs-tooltip-left .arrow, :host.bs-tooltip-right .arrow {
      top: 50%;
      margin-top: -6px;
    }
  `]
            }] }
];
/** @nocollapse */
TooltipContainerComponent.ctorParameters = () => [
    { type: TooltipConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @copyright Valor Software
 * @copyright Angular ng-bootstrap team
 */
class Trigger {
    /**
     * @param {?} open
     * @param {?=} close
     */
    constructor(open, close) {
        this.open = open;
        this.close = close || open;
    }
    /**
     * @return {?}
     */
    isManual() { return this.open === 'manual' || this.close === 'manual'; }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_ALIASES = {
    hover: ['mouseover', 'mouseout'],
    focus: ['focusin', 'focusout']
};
/**
 * @param {?} triggers
 * @param {?=} aliases
 * @return {?}
 */
function parseTriggers(triggers, aliases = DEFAULT_ALIASES) {
    /** @type {?} */
    const trimmedTriggers = (triggers || '').trim();
    if (trimmedTriggers.length === 0) {
        return [];
    }
    /** @type {?} */
    const parsedTriggers = trimmedTriggers
        .split(/\s+/)
        .map((trigger) => trigger.split(':'))
        .map((triggerPair) => {
        /** @type {?} */
        const alias = aliases[triggerPair[0]] || triggerPair;
        return new Trigger(alias[0], alias[1]);
    });
    /** @type {?} */
    const manualTriggers = parsedTriggers.filter((triggerPair) => triggerPair.isManual());
    if (manualTriggers.length > 1) {
        throw new Error('Triggers parse error: only one manual trigger is allowed');
    }
    if (manualTriggers.length === 1 && parsedTriggers.length > 1) {
        throw new Error('Triggers parse error: manual trigger can\'t be mixed with other triggers');
    }
    return parsedTriggers;
}
/**
 * @param {?} renderer
 * @param {?} options
 * @return {?}
 */
function listenToTriggersV2(renderer, options) {
    /** @type {?} */
    const parsedTriggers = parseTriggers(options.triggers);
    /** @type {?} */
    const target = options.target;
    // do nothing
    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {
        return Function.prototype;
    }
    // all listeners
    /** @type {?} */
    const listeners = [];
    // lazy listeners registration
    /** @type {?} */
    const _registerHide = [];
    /** @type {?} */
    const registerHide = () => {
        // add hide listeners to unregister array
        _registerHide.forEach((fn) => listeners.push(fn()));
        // register hide events only once
        _registerHide.length = 0;
    };
    // register open\close\toggle listeners
    parsedTriggers.forEach((trigger) => {
        /** @type {?} */
        const useToggle = trigger.open === trigger.close;
        /** @type {?} */
        const showFn = useToggle ? options.toggle : options.show;
        if (!useToggle) {
            _registerHide.push(() => renderer.listen(target, trigger.close, options.hide));
        }
        listeners.push(renderer.listen(target, trigger.open, () => showFn(registerHide)));
    });
    return () => {
        listeners.forEach((unsubscribeFn) => unsubscribeFn());
    };
}
/**
 * @param {?} renderer
 * @param {?} options
 * @return {?}
 */
function registerOutsideClick(renderer, options) {
    if (!options.outsideClick) {
        return Function.prototype;
    }
    return renderer.listen('document', 'click', (event) => {
        if (options.target && options.target.contains(event.target)) {
            return;
        }
        if (options.targets &&
            options.targets.some(target => target.contains(event.target))) {
            return;
        }
        options.hide();
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @copyright Valor Software
 * @copyright Angular ng-bootstrap team
 */
class ContentRef {
    /**
     * @param {?} nodes
     * @param {?=} viewRef
     * @param {?=} componentRef
     */
    constructor(nodes, viewRef, componentRef) {
        this.nodes = nodes;
        this.viewRef = viewRef;
        this.componentRef = componentRef;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ComponentLoader {
    /**
     * Do not use this directly, it should be instanced via
     * `ComponentLoadFactory.attach`
     * \@internal
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @param {?} _elementRef
     * @param {?} _injector
     * @param {?} _componentFactoryResolver
     * @param {?} _ngZone
     * @param {?} _applicationRef
     * @param {?} _posService
     */
    // tslint:disable-next-line
    constructor(_viewContainerRef, _renderer, _elementRef, _injector, _componentFactoryResolver, _ngZone, _applicationRef, _posService) {
        this._viewContainerRef = _viewContainerRef;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._injector = _injector;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._ngZone = _ngZone;
        this._applicationRef = _applicationRef;
        this._posService = _posService;
        this.onBeforeShow = new EventEmitter();
        this.onShown = new EventEmitter();
        this.onBeforeHide = new EventEmitter();
        this.onHidden = new EventEmitter();
        this._providers = [];
        this._isHiding = false;
        this._listenOpts = {};
        this._globalListener = Function.prototype;
    }
    /**
     * @return {?}
     */
    get isShown() {
        if (this._isHiding) {
            return false;
        }
        return !!this._componentRef;
    }
    /**
     * @param {?} compType
     * @return {?}
     */
    attach(compType) {
        this._componentFactory = this._componentFactoryResolver
            .resolveComponentFactory(compType);
        return this;
    }
    // todo: add behaviour: to target element, `body`, custom element
    /**
     * @param {?=} container
     * @return {?}
     */
    to(container) {
        this.container = container || this.container;
        return this;
    }
    /**
     * @param {?=} opts
     * @return {?}
     */
    position(opts) {
        this.attachment = opts.attachment || this.attachment;
        this._elementRef = ((/** @type {?} */ (opts.target))) || this._elementRef;
        return this;
    }
    /**
     * @param {?} provider
     * @return {?}
     */
    provide(provider) {
        this._providers.push(provider);
        return this;
    }
    // todo: appendChild to element or document.querySelector(this.container)
    /**
     * @param {?=} opts
     * @return {?}
     */
    show(opts = {}) {
        this._subscribePositioning();
        this._innerComponent = null;
        if (!this._componentRef) {
            this.onBeforeShow.emit();
            this._contentRef = this._getContentRef(opts.content, opts.context, opts.initialState);
            /** @type {?} */
            const injector = ReflectiveInjector.resolveAndCreate(this._providers, this._injector);
            this._componentRef = this._componentFactory.create(injector, this._contentRef.nodes);
            this._applicationRef.attachView(this._componentRef.hostView);
            // this._componentRef = this._viewContainerRef
            //   .createComponent(this._componentFactory, 0, injector, this._contentRef.nodes);
            this.instance = this._componentRef.instance;
            Object.assign(this._componentRef.instance, opts);
            if (this.container instanceof ElementRef) {
                this.container.nativeElement.appendChild(this._componentRef.location.nativeElement);
            }
            if (this.container === 'body' && typeof document !== 'undefined') {
                document
                    .querySelector((/** @type {?} */ (this.container)))
                    .appendChild(this._componentRef.location.nativeElement);
            }
            if (!this.container &&
                this._elementRef &&
                this._elementRef.nativeElement.parentElement) {
                this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement);
            }
            // we need to manually invoke change detection since events registered
            // via
            // Renderer::listen() are not picked up by change detection with the
            // OnPush strategy
            if (this._contentRef.componentRef) {
                this._innerComponent = this._contentRef.componentRef.instance;
                this._contentRef.componentRef.changeDetectorRef.markForCheck();
                this._contentRef.componentRef.changeDetectorRef.detectChanges();
            }
            this._componentRef.changeDetectorRef.markForCheck();
            this._componentRef.changeDetectorRef.detectChanges();
            this.onShown.emit(this._componentRef.instance);
        }
        this._registerOutsideClick();
        return this._componentRef;
    }
    /**
     * @return {?}
     */
    hide() {
        if (!this._componentRef) {
            return this;
        }
        this.onBeforeHide.emit(this._componentRef.instance);
        /** @type {?} */
        const componentEl = this._componentRef.location.nativeElement;
        componentEl.parentNode.removeChild(componentEl);
        if (this._contentRef.componentRef) {
            this._contentRef.componentRef.destroy();
        }
        this._componentRef.destroy();
        if (this._viewContainerRef && this._contentRef.viewRef) {
            this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
        }
        if (this._contentRef.viewRef) {
            this._contentRef.viewRef.destroy();
        }
        // this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._componentRef.hostView));
        //
        // if (this._contentRef.viewRef && this._viewContainerRef.indexOf(this._contentRef.viewRef) !== -1) {
        //   this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
        // }
        this._contentRef = null;
        this._componentRef = null;
        this._removeGlobalListener();
        this.onHidden.emit();
        return this;
    }
    /**
     * @return {?}
     */
    toggle() {
        if (this.isShown) {
            this.hide();
            return;
        }
        this.show();
    }
    /**
     * @return {?}
     */
    dispose() {
        if (this.isShown) {
            this.hide();
        }
        this._unsubscribePositioning();
        if (this._unregisterListenersFn) {
            this._unregisterListenersFn();
        }
    }
    /**
     * @param {?} listenOpts
     * @return {?}
     */
    listen(listenOpts) {
        this.triggers = listenOpts.triggers || this.triggers;
        this._listenOpts.outsideClick = listenOpts.outsideClick;
        listenOpts.target = listenOpts.target || this._elementRef.nativeElement;
        /** @type {?} */
        const hide = (this._listenOpts.hide = () => listenOpts.hide ? listenOpts.hide() : void this.hide());
        /** @type {?} */
        const show = (this._listenOpts.show = (registerHide) => {
            listenOpts.show ? listenOpts.show(registerHide) : this.show(registerHide);
            registerHide();
        });
        /** @type {?} */
        const toggle = (registerHide) => {
            this.isShown ? hide() : show(registerHide);
        };
        this._unregisterListenersFn = listenToTriggersV2(this._renderer, {
            target: listenOpts.target,
            triggers: listenOpts.triggers,
            show,
            hide,
            toggle
        });
        return this;
    }
    /**
     * @return {?}
     */
    _removeGlobalListener() {
        if (this._globalListener) {
            this._globalListener();
            this._globalListener = null;
        }
    }
    /**
     * @param {?} vRef
     * @param {?} template
     * @return {?}
     */
    attachInline(vRef, template) {
        this._inlineViewRef = vRef.createEmbeddedView(template);
        return this;
    }
    /**
     * @return {?}
     */
    _registerOutsideClick() {
        if (!this._componentRef || !this._componentRef.location) {
            return;
        }
        // why: should run after first event bubble
        if (this._listenOpts.outsideClick) {
            /** @type {?} */
            const target = this._componentRef.location.nativeElement;
            setTimeout(() => {
                this._globalListener = registerOutsideClick(this._renderer, {
                    targets: [target, this._elementRef.nativeElement],
                    outsideClick: this._listenOpts.outsideClick,
                    hide: () => this._listenOpts.hide()
                });
            });
        }
    }
    /**
     * @return {?}
     */
    getInnerComponent() {
        return this._innerComponent;
    }
    /**
     * @private
     * @return {?}
     */
    _subscribePositioning() {
        if (this._zoneSubscription || !this.attachment) {
            return;
        }
        this._zoneSubscription = this._ngZone.onStable.subscribe(() => {
            if (!this._componentRef) {
                return;
            }
            this._posService.position({
                element: this._componentRef.location,
                target: this._elementRef,
                attachment: this.attachment,
                appendToBody: this.container === 'body'
            });
        });
    }
    /**
     * @private
     * @return {?}
     */
    _unsubscribePositioning() {
        if (!this._zoneSubscription) {
            return;
        }
        this._zoneSubscription.unsubscribe();
        this._zoneSubscription = null;
    }
    /**
     * @private
     * @param {?} content
     * @param {?=} context
     * @param {?=} initialState
     * @return {?}
     */
    _getContentRef(content, context, initialState) {
        if (!content) {
            return new ContentRef([]);
        }
        if (content instanceof TemplateRef) {
            if (this._viewContainerRef) {
                /** @type {?} */
                const _viewRef = this._viewContainerRef
                    .createEmbeddedView(content, context);
                _viewRef.markForCheck();
                return new ContentRef([_viewRef.rootNodes], _viewRef);
            }
            /** @type {?} */
            const viewRef = content.createEmbeddedView({});
            this._applicationRef.attachView(viewRef);
            return new ContentRef([viewRef.rootNodes], viewRef);
        }
        if (typeof content === 'function') {
            /** @type {?} */
            const contentCmptFactory = this._componentFactoryResolver.resolveComponentFactory(content);
            /** @type {?} */
            const modalContentInjector = ReflectiveInjector.resolveAndCreate([...this._providers], this._injector);
            /** @type {?} */
            const componentRef = contentCmptFactory.create(modalContentInjector);
            Object.assign(componentRef.instance, initialState);
            this._applicationRef.attachView(componentRef.hostView);
            return new ContentRef([[componentRef.location.nativeElement]], componentRef.hostView, componentRef);
        }
        // 支持传入的content是一个ComponentRef实例 added by liyz
        if (content instanceof ComponentRef) {
            Object.assign(content.instance, initialState);
            this._applicationRef.attachView(content.hostView);
            return new ContentRef([[content.location.nativeElement]], content.hostView, content);
        }
        return new ContentRef([[this._renderer.createText(`${content}`)]]);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @copyright Valor Software
 * @copyright Angular ng-bootstrap team
 */
// previous version:
// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js
// tslint:disable
class Positioning {
    /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    position(element, round = true) {
        /** @type {?} */
        let elPosition;
        /** @type {?} */
        let parentOffset = {
            width: 0,
            height: 0,
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        if (this.getStyle(element, 'position') === 'fixed') {
            /** @type {?} */
            const bcRect = element.getBoundingClientRect();
            elPosition = {
                width: bcRect.width,
                height: bcRect.height,
                top: bcRect.top,
                bottom: bcRect.bottom,
                left: bcRect.left,
                right: bcRect.right
            };
        }
        else {
            /** @type {?} */
            const offsetParentEl = this.offsetParent(element);
            elPosition = this.offset(element, false);
            if (offsetParentEl !== document.documentElement) {
                parentOffset = this.offset(offsetParentEl, false);
            }
            parentOffset.top += offsetParentEl.clientTop;
            parentOffset.left += offsetParentEl.clientLeft;
        }
        elPosition.top -= parentOffset.top;
        elPosition.bottom -= parentOffset.top;
        elPosition.left -= parentOffset.left;
        elPosition.right -= parentOffset.left;
        if (round) {
            elPosition.top = Math.round(elPosition.top);
            elPosition.bottom = Math.round(elPosition.bottom);
            elPosition.left = Math.round(elPosition.left);
            elPosition.right = Math.round(elPosition.right);
        }
        return elPosition;
    }
    /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    offset(element, round = true) {
        /** @type {?} */
        const elBcr = element.getBoundingClientRect();
        /** @type {?} */
        const viewportOffset = {
            top: window.pageYOffset - document.documentElement.clientTop,
            left: window.pageXOffset - document.documentElement.clientLeft
        };
        /** @type {?} */
        let elOffset = {
            height: elBcr.height || element.offsetHeight,
            width: elBcr.width || element.offsetWidth,
            top: elBcr.top + viewportOffset.top,
            bottom: elBcr.bottom + viewportOffset.top,
            left: elBcr.left + viewportOffset.left,
            right: elBcr.right + viewportOffset.left
        };
        if (round) {
            elOffset.height = Math.round(elOffset.height);
            elOffset.width = Math.round(elOffset.width);
            elOffset.top = Math.round(elOffset.top);
            elOffset.bottom = Math.round(elOffset.bottom);
            elOffset.left = Math.round(elOffset.left);
            elOffset.right = Math.round(elOffset.right);
        }
        return elOffset;
    }
    /**
     * @param {?} hostElement
     * @param {?} targetElement
     * @param {?} placement
     * @param {?=} appendToBody
     * @return {?}
     */
    positionElements(hostElement, targetElement, placement, appendToBody) {
        /** @type {?} */
        const hostElPosition = appendToBody
            ? this.offset(hostElement, false)
            : this.position(hostElement, false);
        /** @type {?} */
        const targetElStyles = this.getAllStyles(targetElement);
        /** @type {?} */
        const shiftWidth = {
            left: hostElPosition.left,
            center: hostElPosition.left +
                hostElPosition.width / 2 -
                targetElement.offsetWidth / 2,
            right: hostElPosition.left + hostElPosition.width
        };
        /** @type {?} */
        const shiftHeight = {
            top: hostElPosition.top,
            center: hostElPosition.top +
                hostElPosition.height / 2 -
                targetElement.offsetHeight / 2,
            bottom: hostElPosition.top + hostElPosition.height
        };
        /** @type {?} */
        const targetElBCR = targetElement.getBoundingClientRect();
        /** @type {?} */
        let placementPrimary = placement.split(' ')[0] || 'top';
        /** @type {?} */
        const placementSecondary = placement.split(' ')[1] || 'center';
        /** @type {?} */
        let targetElPosition = {
            height: targetElBCR.height || targetElement.offsetHeight,
            width: targetElBCR.width || targetElement.offsetWidth,
            top: 0,
            bottom: targetElBCR.height || targetElement.offsetHeight,
            left: 0,
            right: targetElBCR.width || targetElement.offsetWidth
        };
        if (placementPrimary === 'auto') {
            /** @type {?} */
            let newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement, placementSecondary);
            if (!newPlacementPrimary)
                newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement);
            if (newPlacementPrimary)
                placementPrimary = newPlacementPrimary;
            targetElement.classList.add(placementPrimary);
        }
        switch (placementPrimary) {
            case 'top':
                targetElPosition.top =
                    hostElPosition.top -
                        (targetElement.offsetHeight +
                            parseFloat(targetElStyles.marginBottom));
                targetElPosition.bottom +=
                    hostElPosition.top - targetElement.offsetHeight;
                targetElPosition.left = shiftWidth[placementSecondary];
                targetElPosition.right += shiftWidth[placementSecondary];
                break;
            case 'bottom':
                targetElPosition.top = shiftHeight[placementPrimary];
                targetElPosition.bottom += shiftHeight[placementPrimary];
                targetElPosition.left = shiftWidth[placementSecondary];
                targetElPosition.right += shiftWidth[placementSecondary];
                break;
            case 'left':
                targetElPosition.top = shiftHeight[placementSecondary];
                targetElPosition.bottom += shiftHeight[placementSecondary];
                targetElPosition.left =
                    hostElPosition.left -
                        (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));
                targetElPosition.right +=
                    hostElPosition.left - targetElement.offsetWidth;
                break;
            case 'right':
                targetElPosition.top = shiftHeight[placementSecondary];
                targetElPosition.bottom += shiftHeight[placementSecondary];
                targetElPosition.left = shiftWidth[placementPrimary];
                targetElPosition.right += shiftWidth[placementPrimary];
                break;
        }
        targetElPosition.top = Math.round(targetElPosition.top);
        targetElPosition.bottom = Math.round(targetElPosition.bottom);
        targetElPosition.left = Math.round(targetElPosition.left);
        targetElPosition.right = Math.round(targetElPosition.right);
        return targetElPosition;
    }
    /**
     * @private
     * @param {?} targetElPosition
     * @param {?} hostElPosition
     * @param {?} targetElement
     * @param {?=} preferredPosition
     * @return {?}
     */
    autoPosition(targetElPosition, hostElPosition, targetElement, preferredPosition) {
        if ((!preferredPosition || preferredPosition === 'right') &&
            targetElPosition.left + hostElPosition.left - targetElement.offsetWidth <
                0) {
            return 'right';
        }
        else if ((!preferredPosition || preferredPosition === 'top') &&
            targetElPosition.bottom +
                hostElPosition.bottom +
                targetElement.offsetHeight >
                window.innerHeight) {
            return 'top';
        }
        else if ((!preferredPosition || preferredPosition === 'bottom') &&
            targetElPosition.top + hostElPosition.top - targetElement.offsetHeight < 0) {
            return 'bottom';
        }
        else if ((!preferredPosition || preferredPosition === 'left') &&
            targetElPosition.right +
                hostElPosition.right +
                targetElement.offsetWidth >
                window.innerWidth) {
            return 'left';
        }
        return null;
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    getAllStyles(element) {
        return window.getComputedStyle(element);
    }
    /**
     * @private
     * @param {?} element
     * @param {?} prop
     * @return {?}
     */
    getStyle(element, prop) {
        return ((/** @type {?} */ (this.getAllStyles(element))))[prop];
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    isStaticPositioned(element) {
        return (this.getStyle(element, 'position') || 'static') === 'static';
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    offsetParent(element) {
        /** @type {?} */
        let offsetParentEl = (/** @type {?} */ (element.offsetParent)) || document.documentElement;
        while (offsetParentEl &&
            offsetParentEl !== document.documentElement &&
            this.isStaticPositioned(offsetParentEl)) {
            offsetParentEl = (/** @type {?} */ (offsetParentEl.offsetParent));
        }
        return offsetParentEl || document.documentElement;
    }
}
/** @type {?} */
const positionService = new Positioning();
/**
 * @param {?} hostElement
 * @param {?} targetElement
 * @param {?} placement
 * @param {?=} appendToBody
 * @return {?}
 */
function positionElements(hostElement, targetElement, placement, appendToBody) {
    /** @type {?} */
    const pos = positionService.positionElements(hostElement, targetElement, placement, appendToBody);
    targetElement.style.top = `${pos.top}px`;
    targetElement.style.left = `${pos.left}px`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PositioningService {
    /**
     * @param {?} options
     * @return {?}
     */
    position(options) {
        const { element, target, attachment, appendToBody } = options;
        positionElements(_getHtmlElement(target), _getHtmlElement(element), attachment, appendToBody);
    }
}
PositioningService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ PositioningService.ngInjectableDef = defineInjectable({ factory: function PositioningService_Factory() { return new PositioningService(); }, token: PositioningService, providedIn: "root" });
/**
 * @param {?} element
 * @return {?}
 */
function _getHtmlElement(element) {
    // it means that we got a selector
    if (typeof element === 'string') {
        return (/** @type {?} */ (document.querySelector(element)));
    }
    if (element instanceof ElementRef) {
        return element.nativeElement;
    }
    return (/** @type {?} */ (element));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ComponentLoaderFactory {
    /**
     * @param {?} _componentFactoryResolver
     * @param {?} _ngZone
     * @param {?} _injector
     * @param {?} _posService
     * @param {?} _applicationRef
     */
    constructor(_componentFactoryResolver, _ngZone, _injector, _posService, _applicationRef) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._ngZone = _ngZone;
        this._injector = _injector;
        this._posService = _posService;
        this._applicationRef = _applicationRef;
    }
    /**
     *
     * @template T
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @return {?} ComponentLoader
     */
    createLoader(_elementRef, _viewContainerRef, _renderer) {
        return new ComponentLoader(_viewContainerRef, _renderer, _elementRef, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService);
    }
}
ComponentLoaderFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ComponentLoaderFactory.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: NgZone },
    { type: Injector },
    { type: PositioningService },
    { type: ApplicationRef }
];
/** @nocollapse */ ComponentLoaderFactory.ngInjectableDef = defineInjectable({ factory: function ComponentLoaderFactory_Factory() { return new ComponentLoaderFactory(inject(ComponentFactoryResolver), inject(NgZone), inject(INJECTOR), inject(PositioningService), inject(ApplicationRef)); }, token: ComponentLoaderFactory, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const _messagesHash = {};
/** @type {?} */
const _hideMsg = typeof console === 'undefined' || !('warn' in console);
/**
 * @param {?} msg
 * @return {?}
 */
function warnOnce(msg) {
    if (!isDevMode() || _hideMsg || msg in _messagesHash) {
        return;
    }
    _messagesHash[msg] = true;
    /*tslint:disable-next-line*/
    console.warn(msg);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TooltipDirective {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @param {?} _elementRef
     * @param {?} cis
     * @param {?} config
     */
    constructor(_viewContainerRef, _renderer, _elementRef, cis, config) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        /**
         * Fired when tooltip content changes
         */
        this.tooltipChange = new EventEmitter();
        /**
         * Css class for tooltip container
         */
        this.containerClass = '';
        /**
         * @deprecated - removed, will be added to configuration
         */
        this._animation = true;
        /**
         * @deprecated
         */
        this._fadeDuration = 150;
        /**
         * @deprecated
         */
        this.tooltipStateChanged = new EventEmitter();
        this._tooltip = cis
            .createLoader(this._elementRef, _viewContainerRef, this._renderer)
            .provide({ provide: TooltipConfig, useValue: config });
        Object.assign(this, config);
        this.onShown = this._tooltip.onShown;
        this.onHidden = this._tooltip.onHidden;
    }
    /**
     * Returns whether or not the tooltip is currently being shown
     * @return {?}
     */
    get isOpen() {
        return this._tooltip.isShown;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        if (value) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    /**
     * @deprecated - please use `tooltip` instead
     * @param {?} value
     * @return {?}
     */
    set htmlContent(value) {
        warnOnce('tooltipHtml was deprecated, please use `tooltip` instead');
        this.tooltip = value;
    }
    /**
     * @deprecated - please use `placement` instead
     * @param {?} value
     * @return {?}
     */
    set _placement(value) {
        warnOnce('tooltipPlacement was deprecated, please use `placement` instead');
        this.placement = value;
    }
    /**
     * @deprecated - please use `isOpen` instead
     * @param {?} value
     * @return {?}
     */
    set _isOpen(value) {
        warnOnce('tooltipIsOpen was deprecated, please use `isOpen` instead');
        this.isOpen = value;
    }
    /**
     * @return {?}
     */
    get _isOpen() {
        warnOnce('tooltipIsOpen was deprecated, please use `isOpen` instead');
        return this.isOpen;
    }
    /**
     * @deprecated - please use `isDisabled` instead
     * @param {?} value
     * @return {?}
     */
    set _enable(value) {
        warnOnce('tooltipEnable was deprecated, please use `isDisabled` instead');
        this.isDisabled = value;
    }
    /**
     * @return {?}
     */
    get _enable() {
        warnOnce('tooltipEnable was deprecated, please use `isDisabled` instead');
        return this.isDisabled;
    }
    /**
     * @deprecated - please use `container="body"` instead
     * @param {?} value
     * @return {?}
     */
    set _appendToBody(value) {
        warnOnce('tooltipAppendToBody was deprecated, please use `container="body"` instead');
        this.container = value ? 'body' : this.container;
    }
    /**
     * @return {?}
     */
    get _appendToBody() {
        warnOnce('tooltipAppendToBody was deprecated, please use `container="body"` instead');
        return this.container === 'body';
    }
    /**
     * @deprecated - will replaced with customClass
     * @param {?} value
     * @return {?}
     */
    set _popupClass(value) {
        warnOnce('tooltipClass deprecated');
    }
    /**
     * @deprecated - removed
     * @param {?} value
     * @return {?}
     */
    set _tooltipContext(value) {
        warnOnce('tooltipContext deprecated');
    }
    /**
     * @deprecated
     * @param {?} value
     * @return {?}
     */
    set _tooltipPopupDelay(value) {
        warnOnce('tooltipPopupDelay is deprecated, use `delay` instead');
        this.delay = value;
    }
    /**
     * @deprecated -  please use `triggers` instead
     * @return {?}
     */
    get _tooltipTrigger() {
        warnOnce('tooltipTrigger was deprecated, please use `triggers` instead');
        return this.triggers;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _tooltipTrigger(value) {
        warnOnce('tooltipTrigger was deprecated, please use `triggers` instead');
        this.triggers = (value || '').toString();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._tooltip.listen({
            triggers: this.triggers,
            show: () => this.show()
        });
        this.tooltipChange.subscribe((value) => {
            if (!value) {
                this._tooltip.hide();
            }
        });
    }
    /**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    toggle() {
        if (this.isOpen) {
            return this.hide();
        }
        this.show();
    }
    /**
     * Opens an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    show() {
        if (this.isOpen ||
            this.isDisabled ||
            this._delayTimeoutId ||
            !this.tooltip) {
            return;
        }
        /** @type {?} */
        const showTooltip = () => {
            if (this._delayTimeoutId) {
                this._delayTimeoutId = undefined;
            }
            this._tooltip
                .attach(TooltipContainerComponent)
                .to(this.container)
                .position({ attachment: this.placement })
                .show({
                content: this.tooltip,
                placement: this.placement,
                containerClass: this.containerClass
            });
        };
        /** @type {?} */
        const cancelDelayedTooltipShowing = () => {
            if (this._tooltipCancelShowFn) {
                this._tooltipCancelShowFn();
            }
        };
        if (this.delay) {
            /** @type {?} */
            const tipTimer = timer(this.delay).subscribe(() => {
                showTooltip();
                cancelDelayedTooltipShowing();
            });
            if (this.triggers) {
                /** @type {?} */
                const triggers = parseTriggers(this.triggers);
                this._tooltipCancelShowFn = this._renderer.listen(this._elementRef.nativeElement, triggers[0].close, () => {
                    tipTimer.unsubscribe();
                    cancelDelayedTooltipShowing();
                });
            }
        }
        else {
            showTooltip();
        }
    }
    /**
     * Closes an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    hide() {
        if (this._delayTimeoutId) {
            clearTimeout(this._delayTimeoutId);
            this._delayTimeoutId = undefined;
        }
        if (!this._tooltip.isShown) {
            return;
        }
        this._tooltip.instance.classMap.in = false;
        setTimeout(() => {
            this._tooltip.hide();
        }, this._fadeDuration);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._tooltip.dispose();
    }
}
TooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: '[tooltip], [tooltipHtml]',
                exportAs: 'bs-tooltip'
            },] }
];
/** @nocollapse */
TooltipDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ComponentLoaderFactory },
    { type: TooltipConfig }
];
TooltipDirective.propDecorators = {
    tooltip: [{ type: Input }],
    tooltipChange: [{ type: Output }],
    placement: [{ type: Input }],
    triggers: [{ type: Input }],
    container: [{ type: Input }],
    isOpen: [{ type: Input }],
    isDisabled: [{ type: Input }],
    containerClass: [{ type: Input }],
    delay: [{ type: Input }],
    onShown: [{ type: Output }],
    onHidden: [{ type: Output }],
    htmlContent: [{ type: Input, args: ['tooltipHtml',] }],
    _placement: [{ type: Input, args: ['tooltipPlacement',] }],
    _isOpen: [{ type: Input, args: ['tooltipIsOpen',] }],
    _enable: [{ type: Input, args: ['tooltipEnable',] }],
    _appendToBody: [{ type: Input, args: ['tooltipAppendToBody',] }],
    _animation: [{ type: Input, args: ['tooltipAnimation',] }],
    _popupClass: [{ type: Input, args: ['tooltipClass',] }],
    _tooltipContext: [{ type: Input, args: ['tooltipContext',] }],
    _tooltipPopupDelay: [{ type: Input, args: ['tooltipPopupDelay',] }],
    _fadeDuration: [{ type: Input, args: ['tooltipFadeDuration',] }],
    _tooltipTrigger: [{ type: Input, args: ['tooltipTrigger',] }],
    tooltipStateChanged: [{ type: Output }]
};
__decorate([
    OnChange(),
    __metadata("design:type", Object)
], TooltipDirective.prototype, "tooltip", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TooltipModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: TooltipModule,
            providers: [TooltipConfig, ComponentLoaderFactory, PositioningService]
        };
    }
}
TooltipModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [TooltipDirective, TooltipContainerComponent],
                exports: [TooltipDirective],
                entryComponents: [TooltipContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsModalRef {
    constructor() {
        /**
         * Hides the modal
         */
        this.hide = Function;
    }
}
BsModalRef.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalBackdropOptions {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.animate = true;
        Object.assign(this, options);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalOptions {
}
ModalOptions.decorators = [
    { type: Injectable }
];
/** @type {?} */
const modalConfigDefaults = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: false,
    ignoreBackdropClick: false,
    class: '',
    animated: true,
    initialState: {}
};
/** @type {?} */
const CLASS_NAME = {
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    IN: 'in',
    // bs3
    SHOW: 'show' // bs4
};
/** @type {?} */
const TRANSITION_DURATIONS = {
    MODAL: 300,
    BACKDROP: 150
};
/** @type {?} */
const DISMISS_REASONS = {
    BACKRDOP: 'backdrop-click',
    ESC: 'esc'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalContainerComponent {
    /**
     * @param {?} options
     * @param {?} _element
     * @param {?} _renderer
     */
    constructor(options, _element, _renderer) {
        this._element = _element;
        this._renderer = _renderer;
        this.isShown = false;
        this.isModalHiding = false;
        this.config = Object.assign({}, options);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isAnimated) {
            this._renderer.addClass(this._element.nativeElement, CLASS_NAME.FADE);
        }
        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');
        setTimeout(() => {
            this.isShown = true;
            this._renderer.addClass(this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
        }, this.isAnimated ? TRANSITION_DURATIONS.BACKDROP : 0);
        if (document && document.body) {
            if (this.bsModalService.getModalsCount() === 1) {
                this.bsModalService.checkScrollbar();
                this.bsModalService.setScrollbar();
            }
            this._renderer.addClass(document.body, CLASS_NAME.OPEN);
        }
        if (this._element.nativeElement) {
            this._element.nativeElement.focus();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.config.ignoreBackdropClick ||
            this.config.backdrop === 'static' ||
            event.target !== this._element.nativeElement) {
            return;
        }
        this.bsModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEsc(event) {
        if (!this.isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        if (this.config.keyboard &&
            this.level === this.bsModalService.getModalsCount()) {
            this.bsModalService.setDismissReason(DISMISS_REASONS.ESC);
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.isShown) {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    hide() {
        if (this.isModalHiding || !this.isShown) {
            return;
        }
        this.isModalHiding = true;
        this._renderer.removeClass(this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
        setTimeout(() => {
            this.isShown = false;
            if (document &&
                document.body &&
                this.bsModalService.getModalsCount() === 1) {
                this._renderer.removeClass(document.body, CLASS_NAME.OPEN);
            }
            this.bsModalService.hide(this.level);
            this.isModalHiding = false;
        }, this.isAnimated ? TRANSITION_DURATIONS.MODAL : 0);
    }
}
ModalContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'modal-container',
                template: `
    <div [class]="'modal-dialog' + (config.class ? ' ' + config.class : '')" role="document">
      <div class="modal-content">
        <ng-content></ng-content>
      </div>
    </div>
  `,
                host: {
                    class: 'modal',
                    role: 'dialog',
                    tabindex: '-1',
                    '[attr.aria-modal]': 'true'
                }
            }] }
];
/** @nocollapse */
ModalContainerComponent.ctorParameters = () => [
    { type: ModalOptions },
    { type: ElementRef },
    { type: Renderer2 }
];
ModalContainerComponent.propDecorators = {
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onEsc: [{ type: HostListener, args: ['window:keydown.esc', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Utils {
    /**
     * @param {?} element
     * @return {?}
     */
    static reflow(element) {
        ((bs) => bs)(element.offsetHeight);
    }
    // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js
    /**
     * @param {?} elem
     * @return {?}
     */
    static getStyles(elem) {
        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        /** @type {?} */
        let view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = win;
        }
        return view.getComputedStyle(elem);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component will be added as background layout for modals if enabled
 */
class ModalBackdropComponent {
    /**
     * @param {?} element
     * @param {?} renderer
     */
    constructor(element, renderer) {
        this._isShown = false;
        this.element = element;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    get isAnimated() {
        return this._isAnimated;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isAnimated(value) {
        this._isAnimated = value;
        // this.renderer.setElementClass(this.element.nativeElement, `${ClassName.FADE}`, value);
    }
    /**
     * @return {?}
     */
    get isShown() {
        return this._isShown;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isShown(value) {
        this._isShown = value;
        if (value) {
            this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.IN}`);
        }
        else {
            this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.IN}`);
        }
        if (!isBs3()) {
            if (value) {
                this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);
            }
            else {
                this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isAnimated) {
            this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.FADE}`);
            Utils.reflow(this.element.nativeElement);
        }
        this.isShown = true;
    }
}
ModalBackdropComponent.decorators = [
    { type: Component, args: [{
                selector: 'bs-modal-backdrop',
                template: ' ',
                host: { class: CLASS_NAME.BACKDROP }
            }] }
];
/** @nocollapse */
ModalBackdropComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TRANSITION_DURATION = 300;
/** @type {?} */
const BACKDROP_TRANSITION_DURATION = 150;
/**
 * Mark any code with directive to show it's content in modal
 */
class ModalDirective {
    /**
     * @param {?} _element
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @param {?} clf
     */
    constructor(_element, _viewContainerRef, _renderer, clf) {
        this._element = _element;
        this._renderer = _renderer;
        /**
         * This event fires immediately when the `show` instance method is called.
         */
        this.onShow = new EventEmitter();
        /**
         * This event is fired when the modal has been made visible to the user
         * (will wait for CSS transitions to complete)
         */
        this.onShown = new EventEmitter();
        /**
         * This event is fired immediately when
         * the hide instance method has been called.
         */
        this.onHide = new EventEmitter();
        /**
         * This event is fired when the modal has finished being
         * hidden from the user (will wait for CSS transitions to complete).
         */
        this.onHidden = new EventEmitter();
        this._isShown = false;
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        this.timerHideModal = 0;
        this.timerRmBackDrop = 0;
        this.isNested = false;
        this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);
    }
    /**
     * allows to set modal configuration via element property
     * @param {?} conf
     * @return {?}
     */
    set config(conf) {
        this._config = this.getConfig(conf);
    }
    /**
     * @return {?}
     */
    get config() {
        return this._config;
    }
    /**
     * @return {?}
     */
    get isShown() {
        return this._isShown;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.config.ignoreBackdropClick ||
            this.config.backdrop === 'static' ||
            event.target !== this._element.nativeElement) {
            return;
        }
        this.dismissReason = DISMISS_REASONS.BACKRDOP;
        this.hide(event);
    }
    // todo: consider preventing default and stopping propagation
    /**
     * @param {?} event
     * @return {?}
     */
    onEsc(event) {
        if (!this._isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        if (this.config.keyboard) {
            this.dismissReason = DISMISS_REASONS.ESC;
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.config = void 0;
        if (this._isShown) {
            this._isShown = false;
            this.hideModal();
            this._backdrop.dispose();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._config = this._config || this.getConfig();
        setTimeout(() => {
            if (this._config.show) {
                this.show();
            }
        }, 0);
    }
    /* Public methods */
    /**
     * Allows to manually toggle modal visibility
     * @return {?}
     */
    toggle() {
        return this._isShown ? this.hide() : this.show();
    }
    /**
     * Allows to manually open modal
     * @return {?}
     */
    show() {
        this.dismissReason = null;
        this.onShow.emit(this);
        if (this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        this._isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        if (document$1 && document$1.body) {
            if (document$1.body.classList.contains(CLASS_NAME.OPEN)) {
                this.isNested = true;
            }
            else {
                this._renderer.addClass(document$1.body, CLASS_NAME.OPEN);
            }
        }
        this.showBackdrop(() => {
            this.showElement();
        });
    }
    /**
     * Allows to manually close modal
     * @param {?=} event
     * @return {?}
     */
    hide(event) {
        if (event) {
            event.preventDefault();
        }
        this.onHide.emit(this);
        // todo: add an option to prevent hiding
        if (!this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        this._isShown = false;
        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);
        if (!isBs3()) {
            this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);
        }
        // this._addClassIn = false;
        if (this._config.animated) {
            this.timerHideModal = setTimeout(() => this.hideModal(), TRANSITION_DURATION);
        }
        else {
            this.hideModal();
        }
    }
    /**
     * Private methods \@internal
     * @protected
     * @param {?=} config
     * @return {?}
     */
    getConfig(config) {
        return Object.assign({}, modalConfigDefaults, config);
    }
    /**
     *  Show dialog
     * \@internal
     * @protected
     * @return {?}
     */
    showElement() {
        // todo: replace this with component loader usage
        if (!this._element.nativeElement.parentNode ||
            this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {
            // don't move modals dom position
            if (document$1 && document$1.body) {
                document$1.body.appendChild(this._element.nativeElement);
            }
        }
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');
        this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');
        this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);
        if (this._config.animated) {
            Utils.reflow(this._element.nativeElement);
        }
        // this._addClassIn = true;
        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);
        if (!isBs3()) {
            this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);
        }
        /** @type {?} */
        const transitionComplete = () => {
            if (this._config.focus) {
                this._element.nativeElement.focus();
            }
            this.onShown.emit(this);
        };
        if (this._config.animated) {
            setTimeout(transitionComplete, TRANSITION_DURATION);
        }
        else {
            transitionComplete();
        }
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    hideModal() {
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'none');
        this.showBackdrop(() => {
            if (!this.isNested) {
                if (document$1 && document$1.body) {
                    this._renderer.removeClass(document$1.body, CLASS_NAME.OPEN);
                }
                this.resetScrollbar();
            }
            this.resetAdjustments();
            this.focusOtherModal();
            this.onHidden.emit(this);
        });
    }
    // todo: original show was calling a callback when done, but we can use
    // promise
    /**
     * \@internal
     * @protected
     * @param {?=} callback
     * @return {?}
     */
    showBackdrop(callback) {
        if (this._isShown &&
            this.config.backdrop &&
            (!this.backdrop || !this.backdrop.instance.isShown)) {
            this.removeBackdrop();
            this._backdrop
                .attach(ModalBackdropComponent)
                .to('body')
                .show({ isAnimated: this._config.animated });
            this.backdrop = this._backdrop._componentRef;
            if (!callback) {
                return;
            }
            if (!this._config.animated) {
                callback();
                return;
            }
            setTimeout(callback, BACKDROP_TRANSITION_DURATION);
        }
        else if (!this._isShown && this.backdrop) {
            this.backdrop.instance.isShown = false;
            /** @type {?} */
            const callbackRemove = () => {
                this.removeBackdrop();
                if (callback) {
                    callback();
                }
            };
            if (this.backdrop.instance.isAnimated) {
                this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);
            }
            else {
                callbackRemove();
            }
        }
        else if (callback) {
            callback();
        }
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    removeBackdrop() {
        this._backdrop.hide();
    }
    /**
     * Events tricks
     * @protected
     * @return {?}
     */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    focusOtherModal() {
        if (this._element.nativeElement.parentElement == null)
            return;
        /** @type {?} */
        const otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');
        if (!otherOpenedModals.length) {
            return;
        }
        otherOpenedModals[otherOpenedModals.length - 1].focus();
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    resetAdjustments() {
        this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');
        this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');
    }
    /** Scroll bar tricks */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    checkScrollbar() {
        this.isBodyOverflowing = document$1.body.clientWidth < win.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    }
    /**
     * @protected
     * @return {?}
     */
    setScrollbar() {
        if (!document$1) {
            return;
        }
        this.originalBodyPadding = parseInt(win
            .getComputedStyle(document$1.body)
            .getPropertyValue('padding-right') || 0, 10);
        if (this.isBodyOverflowing) {
            document$1.body.style.paddingRight = `${this.originalBodyPadding +
                this.scrollbarWidth}px`;
        }
    }
    /**
     * @protected
     * @return {?}
     */
    resetScrollbar() {
        document$1.body.style.paddingRight = this.originalBodyPadding + 'px';
    }
    // thx d.walsh
    /**
     * @protected
     * @return {?}
     */
    getScrollbarWidth() {
        /** @type {?} */
        const scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document$1.body, scrollDiv);
        /** @type {?} */
        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document$1.body, scrollDiv);
        return scrollbarWidth;
    }
}
ModalDirective.decorators = [
    { type: Directive, args: [{
                selector: '[bsModal]',
                exportAs: 'bs-modal'
            },] }
];
/** @nocollapse */
ModalDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: ComponentLoaderFactory }
];
ModalDirective.propDecorators = {
    config: [{ type: Input }],
    onShow: [{ type: Output }],
    onShown: [{ type: Output }],
    onHide: [{ type: Output }],
    onHidden: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onEsc: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsModalService$1 {
    /**
     * @param {?} rendererFactory
     * @param {?} clf
     */
    constructor(rendererFactory, clf) {
        this.clf = clf;
        // constructor props
        this.config = modalConfigDefaults;
        this.onShow = new EventEmitter();
        this.onShown = new EventEmitter();
        this.onHide = new EventEmitter();
        this.onHidden = new EventEmitter();
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        this.modalsCount = 0;
        this.lastDismissReason = '';
        this.loaders = [];
        this._backdropLoader = this.clf.createLoader(null, null, null);
        this._renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * Shows a modal
     * @param {?} content
     * @param {?=} config
     * @return {?}
     */
    show(content, config) {
        this.modalsCount++;
        this._createLoaders();
        this.config = Object.assign({}, modalConfigDefaults, config);
        this._showBackdrop();
        this.lastDismissReason = null;
        return this._showModal(content);
    }
    /**
     * @param {?} level
     * @return {?}
     */
    hide(level) {
        if (this.modalsCount === 1) {
            this._hideBackdrop();
            this.resetScrollbar();
        }
        this.modalsCount = this.modalsCount >= 1 ? this.modalsCount - 1 : 0;
        setTimeout(() => {
            this._hideModal(level);
            this.removeLoaders(level);
        }, this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0);
    }
    /**
     * @return {?}
     */
    _showBackdrop() {
        /** @type {?} */
        const isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';
        /** @type {?} */
        const isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;
        if (this.modalsCount === 1) {
            this.removeBackdrop();
            if (isBackdropEnabled && isBackdropInDOM) {
                this._backdropLoader
                    .attach(ModalBackdropComponent)
                    .to('body')
                    .show({ isAnimated: this.config.animated });
                this.backdropRef = this._backdropLoader._componentRef;
            }
        }
    }
    /**
     * @return {?}
     */
    _hideBackdrop() {
        if (!this.backdropRef) {
            return;
        }
        this.backdropRef.instance.isShown = false;
        /** @type {?} */
        const duration = this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0;
        setTimeout(() => this.removeBackdrop(), duration);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    _showModal(content) {
        /** @type {?} */
        const modalLoader = this.loaders[this.loaders.length - 1];
        /** @type {?} */
        const bsModalRef = new BsModalRef();
        /** @type {?} */
        const modalContainerRef = modalLoader
            .provide({ provide: ModalOptions, useValue: this.config })
            .provide({ provide: BsModalRef, useValue: bsModalRef })
            .attach(ModalContainerComponent)
            .to('body')
            .show({ content, isAnimated: this.config.animated, initialState: this.config.initialState, bsModalService: this });
        modalContainerRef.instance.level = this.getModalsCount();
        bsModalRef.hide = () => {
            modalContainerRef.instance.hide();
        };
        bsModalRef.content = modalLoader.getInnerComponent() || null;
        return bsModalRef;
    }
    /**
     * @param {?} level
     * @return {?}
     */
    _hideModal(level) {
        /** @type {?} */
        const modalLoader = this.loaders[level - 1];
        if (modalLoader) {
            modalLoader.hide();
        }
    }
    /**
     * @return {?}
     */
    getModalsCount() {
        return this.modalsCount;
    }
    /**
     * @param {?} reason
     * @return {?}
     */
    setDismissReason(reason) {
        this.lastDismissReason = reason;
    }
    /**
     * @return {?}
     */
    removeBackdrop() {
        this._backdropLoader.hide();
        this.backdropRef = null;
    }
    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @return {?}
     */
    checkScrollbar() {
        this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    }
    /**
     * @return {?}
     */
    setScrollbar() {
        if (!document) {
            return;
        }
        this.originalBodyPadding = parseInt(window
            .getComputedStyle(document.body)
            .getPropertyValue('padding-right') || '0', 10);
        if (this.isBodyOverflowing) {
            document.body.style.paddingRight = `${this.originalBodyPadding +
                this.scrollbarWidth}px`;
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetScrollbar() {
        document.body.style.paddingRight = `${this.originalBodyPadding}px`;
    }
    // thx d.walsh
    /**
     * @private
     * @return {?}
     */
    getScrollbarWidth() {
        /** @type {?} */
        const scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document.body, scrollDiv);
        /** @type {?} */
        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document.body, scrollDiv);
        return scrollbarWidth;
    }
    /**
     * @private
     * @return {?}
     */
    _createLoaders() {
        /** @type {?} */
        const loader = this.clf.createLoader(null, null, null);
        this.copyEvent(loader.onBeforeShow, this.onShow);
        this.copyEvent(loader.onShown, this.onShown);
        this.copyEvent(loader.onBeforeHide, this.onHide);
        this.copyEvent(loader.onHidden, this.onHidden);
        this.loaders.push(loader);
    }
    /**
     * @private
     * @param {?} level
     * @return {?}
     */
    removeLoaders(level) {
        this.loaders.splice(level - 1, 1);
        this.loaders.forEach((loader, i) => {
            loader.instance.level = i + 1;
        });
    }
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    copyEvent(from, to) {
        from.subscribe(() => {
            to.emit(this.lastDismissReason);
        });
    }
}
BsModalService$1.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BsModalService$1.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: ComponentLoaderFactory }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalModule$1 {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ModalModule$1,
            providers: [BsModalService$1, ComponentLoaderFactory, PositioningService]
        };
    }
}
ModalModule$1.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ModalBackdropComponent,
                    ModalDirective,
                    ModalContainerComponent
                ],
                exports: [ModalBackdropComponent, ModalDirective],
                entryComponents: [ModalBackdropComponent, ModalContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavbarState {
    constructor() {
        this.dropdownInstances = [];
        this.menuItems = [];
        this.subscriptions = [];
        // 当前下拉菜单的子菜单
        this.onItemClick = new EventEmitter();
    }
    /**
     * @param {?} dropdown
     * @return {?}
     */
    addDropdown(dropdown) {
        if (!this.dropdownInstances.find((item) => item === dropdown)) {
            this.dropdownInstances.push(dropdown);
            this.subscribeDropdown(dropdown);
            dropdown.onShown.subscribe(() => setTimeout(() => {
                dropdown.childDropdowns.forEach((item) => this.addDropdown(item));
            }));
        }
    }
    /**
     * @param {?} menuItem
     * @return {?}
     */
    addMenuItem(menuItem) {
        if (!this.menuItems.find((item) => item === menuItem)) {
            this.menuItems.push(menuItem);
            this.subscribeMenuItem(menuItem);
        }
    }
    /**
     * @private
     * @param {?} dropdown
     * @return {?}
     */
    subscribeDropdown(dropdown) {
        // 在下拉菜单显示、隐藏时，记录下显示状态。
        // this.subscriptions.push(
        //   dropdown.onShown.subscribe((value) => {
        //     debugger;
        //     if(dropdown.isSubMenu) {
        //
        //     }
        //   })
        // );
        //
        // this.subscriptions.push(
        //   dropdown.onHidden.subscribe((value) => {
        //
        //   })
        // );
        this.subscriptions.push(dropdown.state.onClick.subscribe((event) => {
            if (dropdown.level === 1) {
                if (dropdown.isOpen && this.level1Dropdown === dropdown) {
                    this.innerHideL1Dropdown();
                }
                else {
                    this.innerShowL1Dropdown(dropdown);
                }
            }
            else if (dropdown.level === 2) {
                if (!dropdown.isOpen || this.level2Dropdown !== dropdown) {
                    this.innerShowL2Dropdown(dropdown);
                }
            }
            event.stopPropagation();
        }));
        this.subscriptions.push(dropdown.state.onHover.subscribe(() => {
            if (!this.level1Dropdown) {
                // 菜单没展开，鼠标悬停没有效果
                return;
            }
            this.show(dropdown);
        }));
    }
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    subscribeMenuItem(menuItem) {
        this.subscriptions.push(menuItem.onHover.subscribe(() => {
            if (!this.level1Dropdown) {
                return;
            }
            if (this.level1Dropdown.containsItem(menuItem)) {
                this.innerHideL2Dropdown();
            }
        }));
        this.subscriptions.push(menuItem.onClick.subscribe((command) => {
            this.onItemClick.emit(command);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((sub) => {
            sub.unsubscribe();
        });
    }
    /**
     * @return {?}
     */
    hideCurrentDropdown() {
        if (this.level2Dropdown) {
            this.innerHideL2Dropdown();
        }
        else {
            this.innerHideL1Dropdown();
        }
    }
    /**
     * @return {?}
     */
    hideAllDropdown() {
        this.innerHideL2Dropdown();
        this.innerHideL1Dropdown();
    }
    /**
     * @param {?} dropdown
     * @return {?}
     */
    show(dropdown) {
        if (dropdown.level === 1) {
            if (dropdown !== this.level1Dropdown) {
                this.innerShowL1Dropdown(dropdown);
            }
            this.innerHideL2Dropdown();
        }
        else if (dropdown.level === 2) {
            if (dropdown !== this.level2Dropdown) {
                this.innerShowL2Dropdown(dropdown);
            }
        }
        ///////////////////////////////
        /*if (this.isMenuShown && this.isSubMenuShown && this.parentDropdown && this.parentDropdown.containsItem(dropdown)) {
          // 要显示的是子菜单，不是当前子菜单
          if (this.currentDropdown && this.currentDropdown !== dropdown) {
            this.currentDropdown.hide();
          }
          dropdown.show();
          this.currentDropdown = dropdown;
          this.isSubMenuShown = true;
        } else if (this.isMenuShown && !this.isSubMenuShown && this.currentDropdown && this.currentDropdown.containsItem(dropdown)) {
    
        } else {
          // 主菜单
          if (this.isSubMenuShown && this.currentDropdown && this.parentDropdown) {
            this.currentDropdown.hide();
            this.currentDropdown = null;
            this.isSubMenuShown = false;
          }
          if (this.isMenuShown && this.currentDropdown && this.currentDropdown !== dropdown) {
            this.currentDropdown.hide();
          }
          dropdown.show();
          this.currentDropdown = dropdown;
          this.isMenuShown = true;
        }*/
    }
    /**
     * @param {?} dropdown
     * @return {?}
     */
    hide(dropdown) {
        // if
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    innerShowL1Dropdown(target) {
        if (this.level1Dropdown) {
            this.level1Dropdown.hide();
        }
        target.show();
        this.level1Dropdown = target;
    }
    /**
     * @private
     * @return {?}
     */
    innerHideL1Dropdown() {
        if (this.level1Dropdown) {
            this.level1Dropdown.hide();
            this.level1Dropdown = null;
        }
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    innerShowL2Dropdown(target) {
        if (this.level2Dropdown) {
            this.level2Dropdown.hide();
        }
        target.show();
        this.level2Dropdown = target;
    }
    /**
     * @private
     * @return {?}
     */
    innerHideL2Dropdown() {
        if (this.level2Dropdown) {
            this.level2Dropdown.hide();
            this.level2Dropdown = null;
        }
    }
}
NavbarState.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NavbarState.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Default dropdown configuration
 */
class BsDropdownConfig {
    constructor() {
        /**
         * default dropdown auto closing behavior
         */
        this.autoClose = true;
    }
}
BsDropdownConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsDropdownState {
    constructor() {
        this.direction = 'down';
        this.isOpenChange = new EventEmitter();
        this.isDisabledChange = new EventEmitter();
        this.toggleClick = new EventEmitter();
        this.onHover = new EventEmitter();
        this.onClick = new EventEmitter();
        this.dropdownMenu = new Promise((resolve) => {
            this.resolveDropdownMenu = resolve;
        });
    }
}
BsDropdownState.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BsDropdownState.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function isBs3$1() {
    return win.__theme === 'bs4';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsDropdownContainerComponent {
    /**
     * @param {?} _state
     * @param {?} cd
     * @param {?} _renderer
     * @param {?} _element
     */
    constructor(_state, cd, _renderer, _element) {
        this._state = _state;
        this.cd = cd;
        this._renderer = _renderer;
        this.isOpen = false;
        this.display = 'block';
        this.position = 'absolute';
        this._subscription = _state.isOpenChange.subscribe((value) => {
            this.isOpen = value;
            /** @type {?} */
            const dropdown = _element.nativeElement.querySelector('.dropdown-menu');
            if (dropdown && !isBs3$1()) {
                this._renderer.addClass(dropdown, 'show');
                if (dropdown.classList.contains('dropdown-menu-right')) {
                    this._renderer.setStyle(dropdown, 'left', 'auto');
                    this._renderer.setStyle(dropdown, 'right', '0');
                }
                if (this.direction === 'up') {
                    this._renderer.setStyle(dropdown, 'top', 'auto');
                    this._renderer.setStyle(dropdown, 'transform', 'translateY(-101%)');
                }
            }
        });
    }
    /**
     * @return {?}
     */
    get direction() {
        return this._state.direction;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
BsDropdownContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'mdb-dropdown-container',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
  <div [class.dropup]="direction === 'up'"
  [class.dropdown]="direction === 'down'"
  [class.show]="isOpen"
  [class.open]="isOpen">
    <ng-content></ng-content>
  </div>
  `
            }] }
];
/** @nocollapse */
BsDropdownContainerComponent.ctorParameters = () => [
    { type: BsDropdownState },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];
BsDropdownContainerComponent.propDecorators = {
    display: [{ type: HostBinding, args: ['style.display',] }],
    position: [{ type: HostBinding, args: ['style.position',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsDropdownDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} _viewContainerRef
     * @param {?} _cis
     * @param {?} _config
     * @param {?} _state
     */
    constructor(_elementRef, _renderer, _viewContainerRef, _cis, _config, _state) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._viewContainerRef = _viewContainerRef;
        this._cis = _cis;
        this._config = _config;
        this._state = _state;
        // todo: move to component loader
        this._isInlineOpen = false;
        this._subscriptions = [];
        this._isInited = false;
        // set initial dropdown state from config
        this._state.autoClose = this._config.autoClose;
        // create dropdown component loader
        this._dropdown = this._cis
            .createLoader(this._elementRef, this._viewContainerRef, this._renderer)
            .provide({ provide: BsDropdownState, useValue: this._state });
        this.onShown = this._dropdown.onShown;
        this.onHidden = this._dropdown.onHidden;
        this.isOpenChange = this._state.isOpenChange;
        // this.onToggleHover = this._state.onHover;
        // barState.addDropdown(this);
    }
    /**
     * Indicates that dropdown will be closed on item or document click,
     * and after pressing ESC
     * @param {?} value
     * @return {?}
     */
    set autoClose(value) {
        this._state.autoClose = value;
    }
    /**
     * @return {?}
     */
    get autoClose() {
        return this._state.autoClose;
    }
    /**
     * Disables dropdown toggle and hides dropdown menu if opened
     * @param {?} value
     * @return {?}
     */
    set isDisabled(value) {
        this._isDisabled = value;
        this._state.isDisabledChange.emit(value);
        if (value) {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        return this._isDisabled;
    }
    /**
     * Returns whether or not the popover is currently being shown
     * @return {?}
     */
    get isOpen() {
        if (this._showInline) {
            return this._isInlineOpen;
        }
        return this._dropdown.isShown;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        if (value) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    get state() {
        return this._state;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set level(value) {
        this._level = value;
    }
    /**
     * @return {?}
     */
    get level() {
        return this._level || 1;
    }
    /**
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    get isBs4() {
        return !isBs3$1();
    }
    /**
     * @private
     * @return {?}
     */
    get _showInline() {
        return !this.container;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // fix: seems there are an issue with `routerLinkActive`
        // which result in duplicated call ngOnInit without call to ngOnDestroy
        // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
        if (this._isInited) {
            return;
        }
        this._isInited = true;
        // attach DOM listeners
        this._dropdown.listen({
            // because of dropdown inline mode
            outsideClick: false,
            triggers: this.triggers,
            show: () => this.show(), toggle: (value) => this.toggle(value)
        });
        // toggle visibility on toggle element click
        this._subscriptions.push(this._state.toggleClick.subscribe((value) => this.toggle(value)));
        // hide dropdown if set disabled while opened
        this._subscriptions.push(this._state.isDisabledChange.pipe(filter((value) => value))
            .subscribe((value) => this.hide()));
    }
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    show() {
        if (this.isOpen || this.isDisabled) {
            return;
        }
        if (this._showInline) {
            if (!this._inlinedMenu) {
                this._state.dropdownMenu.then((dropdownMenu) => {
                    /** @type {?} */
                    const _placement = this.placement || 'bottom left';
                    this._dropdown.attachInline(dropdownMenu.viewContainer, dropdownMenu.templateRef);
                    this._inlinedMenu = this._dropdown._inlineViewRef;
                    this.addBs4Polyfills();
                })
                    // swallow errors
                    .catch();
            }
            this.addBs4Polyfills();
            this._isInlineOpen = true;
            this.onShown.emit(true);
            this._state.isOpenChange.emit(true);
            return;
        }
        this._state.dropdownMenu.then(dropdownMenu => {
            // check direction in which dropdown should be opened
            /** @type {?} */
            const _dropup = this.dropup ||
                (typeof this.dropup !== 'undefined' && this.dropup);
            this._state.direction = _dropup ? 'up' : 'down';
            /** @type {?} */
            const _placement = this.placement || (_dropup ? 'top left' : 'bottom left');
            // show dropdown
            this._dropdown
                .attach(BsDropdownContainerComponent)
                .to(this.container)
                .position({ attachment: _placement })
                .show({
                content: dropdownMenu.templateRef,
                placement: _placement
            });
            this._state.isOpenChange.emit(true);
        })
            // swallow error
            .catch();
    }
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    hide() {
        if (!this.isOpen) {
            return;
        }
        if (this._showInline) {
            this.removeShowClass();
            this.removeDropupStyles();
            this._isInlineOpen = false;
            this.onHidden.emit(true);
        }
        else {
            this._dropdown.hide();
        }
        this._state.isOpenChange.emit(false);
    }
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover. With parameter <code>true</code> allows toggling, with parameter <code>false</code>
     * only hides opened dropdown. Parameter usage will be removed in ngx-bootstrap v3
     * @param {?=} value
     * @return {?}
     */
    toggle(value) {
        if (this.isOpen || !value) {
            return this.hide();
        }
        return this.show();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    containsItem(item) {
        return this._elementRef.nativeElement.contains(item.elementRef.nativeElement);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // clean up subscriptions and destroy dropdown
        for (const sub of this._subscriptions) {
            sub.unsubscribe();
        }
        this._dropdown.dispose();
    }
    /**
     * @private
     * @return {?}
     */
    addBs4Polyfills() {
        if (!isBs3$1()) {
            this.addShowClass();
            this.checkRightAlignment();
            this.addDropupStyles();
        }
    }
    /**
     * @private
     * @return {?}
     */
    addShowClass() {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            this._renderer.addClass(this._inlinedMenu.rootNodes[0], 'show');
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeShowClass() {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            this._renderer.removeClass(this._inlinedMenu.rootNodes[0], 'show');
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkRightAlignment() {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            /** @type {?} */
            const isRightAligned = this._inlinedMenu.rootNodes[0].classList.contains('dropdown-menu-right');
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'left', isRightAligned ? 'auto' : '0');
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'right', isRightAligned ? '0' : 'auto');
        }
    }
    /**
     * @private
     * @return {?}
     */
    addDropupStyles() {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            // a little hack to not break support of bootstrap 4 beta
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'top', this.dropup ? 'auto' : '100%');
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'transform', this.dropup ? 'translateY(-101%)' : 'translateY(0)');
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeDropupStyles() {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], 'top');
            this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], 'transform');
        }
    }
}
BsDropdownDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mdbDropdown],[dropdown]',
                exportAs: 'bs-dropdown',
                providers: [BsDropdownState],
                host: {
                    '[class.dropup]': 'dropup',
                    '[class.open]': 'isOpen',
                    '[class.show]': 'isOpen && isBs4'
                }
            },] }
];
/** @nocollapse */
BsDropdownDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: ComponentLoaderFactory },
    { type: BsDropdownConfig },
    { type: BsDropdownState }
];
BsDropdownDirective.propDecorators = {
    placement: [{ type: Input }],
    triggers: [{ type: Input }],
    container: [{ type: Input }],
    dropup: [{ type: Input }],
    autoClose: [{ type: Input }],
    isDisabled: [{ type: Input }],
    isOpen: [{ type: Input }],
    level: [{ type: Input, args: ['dropdown',] }],
    isOpenChange: [{ type: Output }],
    onShown: [{ type: Output }],
    onHidden: [{ type: Output }],
    childDropdowns: [{ type: ContentChildren, args: [BsDropdownDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsDropdownMenuDirective {
    /**
     * @param {?} _state
     * @param {?} _viewContainer
     * @param {?} _templateRef
     */
    constructor(_state, _viewContainer, _templateRef) {
        _state.resolveDropdownMenu({
            templateRef: _templateRef,
            viewContainer: _viewContainer
        });
    }
}
BsDropdownMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mdbDropdownMenu],[dropdownMenu]',
                exportAs: 'bs-dropdown-menu'
            },] }
];
/** @nocollapse */
BsDropdownMenuDirective.ctorParameters = () => [
    { type: BsDropdownState },
    { type: ViewContainerRef },
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsDropdownToggleDirective {
    /**
     * @param {?} _state
     * @param {?} _element
     */
    constructor(_state, _element) {
        this._state = _state;
        this._element = _element;
        this.ariaHaspopup = true;
        this.isDisabled = null;
        this._subscriptions = [];
        // sync is open value with state
        this._subscriptions.push(this._state.isOpenChange.subscribe((value) => (this.isOpen = value)));
        // populate disabled state
        this._subscriptions.push(this._state.isDisabledChange.subscribe((value) => (this.isDisabled = value || null)));
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.isDisabled) {
            return;
        }
        this._state.toggleClick.emit(true);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDocumentClick(event) {
        if (this._state.autoClose &&
            event.button !== 2 &&
            !this._element.nativeElement.contains(event.target)) {
            this._state.toggleClick.emit(false);
        }
    }
    /**
     * @return {?}
     */
    onEsc() {
        if (this._state.autoClose) {
            this._state.toggleClick.emit(false);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        for (const sub of this._subscriptions) {
            sub.unsubscribe();
        }
    }
}
BsDropdownToggleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mdbDropdownToggle],[dropdownToggle]',
                exportAs: 'bs-dropdown-toggle'
            },] }
];
/** @nocollapse */
BsDropdownToggleDirective.ctorParameters = () => [
    { type: BsDropdownState },
    { type: ElementRef }
];
BsDropdownToggleDirective.propDecorators = {
    ariaHaspopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    isDisabled: [{ type: HostBinding, args: ['attr.disabled',] }],
    isOpen: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    onClick: [{ type: HostListener, args: ['click', [],] }],
    onDocumentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }],
    onEsc: [{ type: HostListener, args: ['keyup.esc',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownButtonDirective {
    /**
     * @param {?} _state
     * @param {?} _element
     */
    constructor(_state, _element) {
        this._state = _state;
        this._element = _element;
        this._subscriptions = [];
        this.isDisabled = null;
        // 同步菜单的打开状态
        this._subscriptions.push(this._state.isOpenChange
            .subscribe((value) => this.isOpen = value));
        // 同步菜单的禁用状态
        this._subscriptions.push(this._state.isDisabledChange
            .subscribe((value) => this.isDisabled = value || null));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.isDisabled) {
            return;
        }
        this._state.onClick.emit(event);
    }
    /**
     * @return {?}
     */
    onHover() {
        if (this.isDisabled) {
            return;
        }
        this._state.onHover.emit();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        for (const sub of this._subscriptions) {
            sub.unsubscribe();
        }
    }
}
DropdownButtonDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dropdownButton]'
            },] }
];
/** @nocollapse */
DropdownButtonDirective.ctorParameters = () => [
    { type: BsDropdownState },
    { type: ElementRef }
];
DropdownButtonDirective.propDecorators = {
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    isOpen: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onHover: [{ type: HostListener, args: ['mouseover',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DropdownItemDirective {
    /**
     * @param {?} _elementRef
     * @param {?} barState
     */
    constructor(_elementRef, barState) {
        this._elementRef = _elementRef;
        this.barState = barState;
        this.isDisabled = null;
        this.onHover = new EventEmitter();
        this.onClick = new EventEmitter();
        this.barState.addMenuItem(this);
    }
    /**
     * @return {?}
     */
    get elementRef() {
        return this._elementRef;
    }
    /**
     * @return {?}
     */
    onMouseOver() {
        this.onHover.emit();
    }
    /**
     * @return {?}
     */
    onItemClick() {
        if (this.isDisabled) {
            return;
        }
        this.onClick.emit(this.command);
    }
}
DropdownItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dropdownItem]',
                exportAs: 'dropdownItem'
            },] }
];
/** @nocollapse */
DropdownItemDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NavbarState }
];
DropdownItemDirective.propDecorators = {
    isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
    command: [{ type: Input, args: ['dropdownItem',] }],
    onMouseOver: [{ type: HostListener, args: ['mouseover',] }],
    onItemClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsDropdownModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: BsDropdownModule, providers: [
                ComponentLoaderFactory,
                PositioningService,
                BsDropdownState,
                { provide: BsDropdownConfig, useValue: config ? config : { autoClose: true } }
            ]
        };
    }
}
BsDropdownModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    BsDropdownMenuDirective,
                    BsDropdownToggleDirective,
                    BsDropdownContainerComponent,
                    BsDropdownDirective,
                    DropdownButtonDirective,
                    DropdownItemDirective
                ],
                exports: [
                    BsDropdownMenuDirective,
                    BsDropdownToggleDirective,
                    BsDropdownDirective,
                    DropdownButtonDirective,
                    DropdownItemDirective
                ],
                entryComponents: [BsDropdownContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavbarDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _config
     * @param {?} _state
     */
    constructor(_elementRef, _config, _state) {
        this._elementRef = _elementRef;
        this._config = _config;
        this._state = _state;
        this._state.autoClose = this._config.autoClose;
        this.onItemClick = this._state.onItemClick;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDocumentClick(event) {
        this._state.hideAllDropdown();
    }
    /**
     * @return {?}
     */
    onEsc() {
        if (this._state.autoClose) {
            this._state.hideCurrentDropdown();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.childDropdowns.forEach((item) => this._state.addDropdown(item));
    }
}
NavbarDirective.decorators = [
    { type: Directive, args: [{
                selector: '[navbar]',
                exportAs: 'navbar',
                providers: [NavbarState]
            },] }
];
/** @nocollapse */
NavbarDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: BsDropdownConfig },
    { type: NavbarState }
];
NavbarDirective.propDecorators = {
    childDropdowns: [{ type: ContentChildren, args: [BsDropdownDirective,] }],
    childDropdowns2: [{ type: ViewChildren, args: [BsDropdownDirective,] }],
    onDocumentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }],
    onEsc: [{ type: HostListener, args: ['keyup.esc',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavbarModule {
}
NavbarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NavbarDirective],
                providers: [NavbarState],
                exports: [NavbarDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TREE_EVENTS = {
    onToggle: 'onToggle',
    onActiveChanged: 'onActiveChanged',
    onActivate: 'onActivate',
    onDeactivate: 'onDeactivate',
    onFocus: 'onFocus',
    onBlur: 'onBlur',
    onDoubleClick: 'onDoubleClick',
    onContextMenu: 'onContextMenu',
    onInitialized: 'onInitialized',
    onUpdateData: 'onUpdateData',
    onMoveNode: 'onMoveNode',
    onAddNode: 'onAddNode',
    onRemoveNode: 'onRemoveNode',
    onRightMenuClicked: 'onRightMenuClicked'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNode {
    /**
     * @param {?} data
     * @param {?=} parent
     * @param {?=} treeModel
     */
    constructor(data, parent = null, treeModel) {
        this.data = data;
        this.isVirtualRoot = false;
        this._isActive = false;
        // 变更树节点展示字段，由外部触发
        this.changeDisplayField = new EventEmitter();
        Object.assign(this, data, { parent, treeModel });
        this.treeModel = treeModel;
        this.parent = parent;
        this.level = this.parent ? this.parent.level + 1 : 0;
        if (this.isExpandedField) {
            this.isExpanded = true;
        }
        // 验证字段添加
        // console.log(this.idField);
        // console.log(this.typeField);
        this.childrenField = this.childrenField.map(child => new TreeNode(child, this, treeModel));
        // bug修复：TreeModel.canMoveNode使用parentNode，会出现undefined。这里做兼容
        this.parentNode = this.parent;
    }
    /**
     * @return {?}
     */
    get isExpanded() { return this._isExpanded; }
    /**
     * @param {?} value
     * @return {?}
     */
    set isExpanded(value) { this._isExpanded = value; }
    /**
     * @return {?}
     */
    get isCollapsed() { return !this._isExpanded; }
    /**
     * @return {?}
     */
    get isActive() {
        return this._isActive;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isActive(value) {
        this._isActive = value;
    }
    // Proxy of treeModel
    /**
     * @return {?}
     */
    get options() {
        return this.treeModel.options;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) {
        this.treeModel.fireEvent(event);
    }
    // 表现的更像一个字段，将其封装成属性，并根据开放的读写权限，设置get/set
    /**
     * @return {?}
     */
    get idField() {
        return this[this.options.idField];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set idField(value) {
        this[this.options.idField] = value;
    }
    /**
     * @return {?}
     */
    get childrenField() {
        return this[this.options.childrenField] || [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set childrenField(value) {
        this[this.options.childrenField] = value;
    }
    /**
     * @return {?}
     */
    get displayField() {
        return this[this.options.displayField];
    }
    /**
     * @return {?}
     */
    get typeField() {
        return this[this.options.typeField];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set typeField(value) {
        this[this.options.typeField] = value;
    }
    /**
     * @return {?}
     */
    get isExpandedField() {
        return this[this.options.isExpandedField];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isExpandedField(value) {
        this[this.options.isExpandedField] = value;
    }
    /**
     * @return {?}
     */
    allowDrag() {
        return this.options.allowDrag;
    }
    /**
     * @return {?}
     */
    enableCustomContextMenu() {
        return this.options.enableCustomContextMenu;
    }
    /**
     * @return {?}
     */
    get isRoot() { return this.parent.isVirtualRoot; } // 父节点为空，表示这个一个根节点
    // 父节点为空，表示这个一个根节点
    /**
     * @return {?}
     */
    get realParent() { return this.isRoot ? null : this.parent; }
    /**
     * @return {?}
     */
    get isLeaf() { return !this.childrenField.length; }
    /**
     * @return {?}
     */
    get hasChildren() { return !this.isLeaf; }
    /**
     * @return {?}
     */
    get isFocused() { return this.treeModel.focusedNode == this; }
    /**
     * @return {?}
     */
    getFirstChild() {
        return this.childrenField && this.childrenField[0];
    }
    /**
     * @return {?}
     */
    getLastChild() {
        return this.childrenField && this.childrenField[this.childrenField.length - 1];
    }
    /**
     * @private
     * @return {?}
     */
    _getIndexInParent() {
        return this.parent && this.parent.childrenField.indexOf(this);
    }
    /**
     * @param {?} steps
     * @return {?}
     */
    findAdjacentSibling(steps) {
        /** @type {?} */
        const index = this._getIndexInParent();
        return this.parent && this.parent.childrenField[index + steps];
    }
    /**
     * @return {?}
     */
    findNextSibling() {
        return this.findAdjacentSibling(+1);
    }
    /**
     * @return {?}
     */
    findPreviousSibling() {
        return this.findAdjacentSibling(-1);
    }
    /**
     * @param {?=} goInside
     * @return {?}
     */
    findNextNode(goInside = true) {
        return goInside && this.isExpanded && this.getFirstChild() ||
            this.findNextSibling() ||
            this.parent && this.parent.findNextNode(false);
    }
    /**
     * @return {?}
     */
    findPreviousNode() {
        /** @type {?} */
        const previousSibling = this.findPreviousSibling();
        if (!previousSibling) {
            return this.realParent;
        }
        return previousSibling.isCollapsed
            ? previousSibling
            : previousSibling.getLastChild();
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isDescendantOf(node) {
        if (this === node) {
            return true;
        }
        else {
            return this.parent && this.parent.isDescendantOf(node);
        }
    }
    // 切换方法
    // 切换节点的折叠（Collapsed）与扩展（Expanded）状态
    /**
     * @return {?}
     */
    toggle() {
        this.isExpanded = !this.isExpanded;
        this.fireEvent({ eventName: TREE_EVENTS.onToggle, node: this, isExpanded: this.isExpanded });
    }
    /**
     * @private
     * @return {?}
     */
    _activate() {
        this._isActive = true;
        this.fireEvent({ eventName: TREE_EVENTS.onActivate, node: this });
        this.focus();
    }
    /**
     * @private
     * @return {?}
     */
    _deactivate() {
        this._isActive = false;
        this.fireEvent({ eventName: TREE_EVENTS.onDeactivate, node: this });
    }
    /**
     * @return {?}
     */
    toggleActivated() {
        if (this.isActive) {
            this._deactivate();
            this.treeModel.activeNode = null;
        }
        else {
            if (this.treeModel.activeNode) {
                this.treeModel.activeNode._deactivate();
            }
            this._activate();
            this.treeModel.activeNode = this;
        }
        this.fireEvent({ eventName: TREE_EVENTS.onActiveChanged, node: this, isActive: this.isActive });
    }
    /**
     * @return {?}
     */
    focus() {
        /** @type {?} */
        const previousNode = this.treeModel.focusedNode;
        this.treeModel.focusedNode = this;
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.onBlur, node: previousNode });
        }
        this.fireEvent({ eventName: TREE_EVENTS.onFocus, node: this });
    }
    /**
     * @return {?}
     */
    blur() {
        /** @type {?} */
        const previousNode = this.treeModel.focusedNode;
        this.treeModel.focusedNode = null;
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.onBlur, node: this });
        }
    }
    // 双击事件
    /**
     * @param {?} rawEvent
     * @return {?}
     */
    doublClick(rawEvent) {
        this.fireEvent({ eventName: TREE_EVENTS.onDoubleClick, node: this, rawEvent });
    }
    // 右键快捷菜单
    /**
     * @param {?} rawEvent
     * @return {?}
     */
    contextMenu(rawEvent) {
        if (this.enableCustomContextMenu()) { // 启用右键菜单功能后，禁用默认的右键菜单
            rawEvent.preventDefault();
        }
        this.fireEvent({ eventName: TREE_EVENTS.onContextMenu, node: this, rawEvent });
    }
    /**
     * @param {?} $event
     * @param {?=} data
     * @return {?}
     */
    dropMouseAction($event, data = null) {
        // 1.设置focus
        this.treeModel.setFocus(true);
        // 2.执行事件处理器
        this._dropEventHandler(this.treeModel, this, $event, data);
        // 3.完成drop操作后，重置drag状态
        this.treeModel.cancelDrag();
    }
    /**
     * @private
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @param {?} to
     * @return {?}
     */
    _dropEventHandler(tree, node, $event, to) {
        tree.moveNode({ from: tree.getDragNode(), to });
        // console.log("dropEventHandler:"+tree.roots);
    }
    // 点击右键菜单项
    /**
     * @param {?} event
     * @return {?}
     */
    rightMenuClicked(event) {
        this.fireEvent({ eventName: TREE_EVENTS.onRightMenuClicked, node: this, rawEvent: event });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeOptions {
    //是否启用快捷菜单
    /**
     * @param {?=} options
     */
    constructor(options = {}) {
        this.options = options;
        // nothing need to do
    }
    // 字段不应直接暴露
    /**
     * @return {?}
     */
    get idField() { return this.options.childrenField || 'id'; }
    /**
     * @return {?}
     */
    get displayField() { return this.options.displayField || 'name'; }
    /**
     * @return {?}
     */
    get typeField() { return this.options.typeField || 'type'; }
    /**
     * @return {?}
     */
    get childrenField() { return this.options.childrenField || 'children'; }
    /**
     * @return {?}
     */
    get isExpandedField() { return this.options.isExpandedField || 'isExpanded'; }
    /**
     * @return {?}
     */
    get treeNodeTemplate() { return this.options.treeNodeTemplate || '{{ node.displayField }}'; } //插值表达式
    //插值表达式
    /**
     * @return {?}
     */
    get allowDrag() { return this.options.allowDrag; } //是否启用拖拽功能
    //是否启用拖拽功能
    /**
     * @return {?}
     */
    get enableCustomContextMenu() { return this.options.enableCustomContextMenu; } //是否启用快捷菜单
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeModel {
    constructor() {
        this.options = new TreeOptions();
        // focused Node may be not actived 
        // actived Node must be focused
        this.focusedNode = null; // be chosen node
        // be chosen node
        this.activeNode = null; // be chosen and actived node
        this.eventNames = Object.keys(TREE_EVENTS);
        this.firstUpdate = true;
        this._dragNode = null;
        this._dropLocation = null;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    setData({ nodes, options, events }) {
        this.options = new TreeOptions(options);
        this.events = events;
        this.update(nodes);
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    update(nodes) {
        // Update the tree:
        this.virtualRoot = new TreeNode({ isVirtualRoot: true }, null, this);
        this.roots = nodes && nodes.map(child => new TreeNode(child, this.virtualRoot, this));
        this.virtualRoot[this.options.childrenField] = this.roots;
        this._loadTreeNodeContentComponent();
        // Fire event:
        if (this.firstUpdate) {
            if (this.roots) {
                this.fireEvent({ eventName: TREE_EVENTS.onInitialized });
                this.firstUpdate = false;
            }
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.onUpdateData });
        }
    }
    //Used for code test
    /**
     * @return {?}
     */
    addStaticTreeNode() {
        this.createAndAddTreeNode({
            id: 1,
            name: 'root1',
            subTitle: 'the root',
            type: 'type1'
        }, this.focusedNode);
    }
    /**
     * @param {?} data
     * @param {?} parentNode
     * @param {?=} index
     * @return {?}
     */
    createAndAddTreeNode(data, parentNode, index) {
        /** @type {?} */
        const createdNode = this.createTreeNode(data, parentNode);
        this.addTreeNode(createdNode, parentNode, index);
    }
    /**
     * @param {?} data
     * @param {?} parent
     * @return {?}
     */
    createTreeNode(data, parent) {
        /** @type {?} */
        let createdNode = new TreeNode(data, parent, this);
        return createdNode;
    }
    /**
     * @param {?} addedNode
     * @param {?} parentNode
     * @param {?=} index
     * @return {?}
     */
    addTreeNode(addedNode, parentNode, index) {
        if (addedNode == null) {
            return;
        }
        if (parentNode == null) { // 增加顶级树节点（没有父节点的树节点）
            this.roots.push(addedNode);
        }
        else {
            if (index === null || index === undefined) {
                parentNode.childrenField.push(addedNode);
            }
            else {
                parentNode.childrenField.splice(index, 0, addedNode);
            }
        }
        this.update(this.roots);
        this.fireEvent({ eventName: TREE_EVENTS.onAddNode, addedNode, parentNode });
    }
    /**
     * @return {?}
     */
    removeFocusedTreeNode() {
        this.removeTreeNode(this.focusedNode);
    }
    //移除选中的已知节点
    /**
     * @param {?} selectedTreeNode
     * @return {?}
     */
    removeTreeNode(selectedTreeNode) {
        if (selectedTreeNode == null) {
            return;
        }
        /** @type {?} */
        const parent = selectedTreeNode.parent;
        if (parent == null) { //移除顶级树节点（没有父节点的树节点）
            //移除顶级树节点（没有父节点的树节点）
            /** @type {?} */
            let index = this.roots.indexOf(selectedTreeNode);
            this.roots.splice(index, 1); //移除数组中某一指定节点
        }
        else {
            if (parent.childrenField.length <= 0) {
                console.log("RemoveTreeNode Warning: it is impossible to remove element from an empty array");
                return;
            }
            //移除数组中某一指定节点
            /** @type {?} */
            let index = parent.childrenField.indexOf(selectedTreeNode);
            parent.childrenField.splice(index, 1);
        }
        this.update(this.roots);
        this.fireEvent({ eventName: TREE_EVENTS.onRemoveNode, selectedTreeNode, parent });
    }
    /**
     * 定位指定树节点
     * @param {?} needLocatedNode 待定位节点
     * @return {?}
     */
    locateTreeNode(needLocatedNode) {
        if (needLocatedNode == null) {
            return;
        }
        /** @type {?} */
        let parentNode = needLocatedNode.parent;
        while (parentNode != null) {
            parentNode.isExpanded = true;
            parentNode = parentNode.parent;
        }
        needLocatedNode.isActive = false;
        needLocatedNode.toggleActivated();
    }
    /**
     * 通过ID定位树节点
     * @param {?} nodeID 待查找并定位节点的ID
     * @return {?}
     */
    locateNodeByID(nodeID) {
        /** @type {?} */
        let node = this.searchTreeNodeByID(nodeID);
        if (node == null) {
            return false;
        }
        this.locateTreeNode(node);
        return true;
    }
    /**
     * 查找指定树节点
     * @param {?} nodeID 待查找节点ID
     * @return {?}
     */
    searchTreeNodeByID(nodeID) {
        return this.searchTreeNode(this.roots, nodeID);
    }
    /**
     * 在指定集合中，根据ID查找树节点
     * @param {?} nodes 树集合
     * @param {?} nodeID 待查找节点ID
     * @return {?}
     */
    searchTreeNode(nodes, nodeID) {
        if (nodes == null || nodes.length <= 0) {
            return null;
        }
        if (nodeID == null || nodeID.length < 0) {
            return null;
        }
        /** @type {?} */
        let searchedTreeNode = null;
        nodes.forEach(node => {
            if (node.idField == nodeID) { //回归
                searchedTreeNode = node;
                return;
            }
            if (node.childrenField == null || node.childrenField.length < 0) { //回归
                return;
            }
            /** @type {?} */
            const searchedNodeInChildren = this.searchTreeNode(node.childrenField, nodeID);
            if (searchedNodeInChildren != null) {
                searchedTreeNode = searchedNodeInChildren;
            }
            return; //回归
        });
        return searchedTreeNode; //返回
    }
    /**
     * @return {?}
     */
    get treeNodeContentComponent() { return this._treeNodeContentComponent; }
    ;
    // if treeNodeTemplate is a component - use it,
    // otherwise - it's a template, so wrap it with an AdHoc component
    /**
     * @return {?}
     */
    _loadTreeNodeContentComponent() {
        this._treeNodeContentComponent = this.options.treeNodeTemplate;
        if (typeof this._treeNodeContentComponent === 'string') ;
    }
    // _createAdHocComponent(templateStr) {
    //     @Component({
    //         selector: 'TreeNodeTemplate',
    //         template: templateStr
    //     })
    //     class AdHocTreeNodeTemplateComponent {
    //         @Input() node: TreeNode;
    //     }
    //     return AdHocTreeNodeTemplateComponent;
    // }
    /**
     * @return {?}
     */
    get isFocused() {
        return TreeModel.focusedTree === this;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setFocus(value) {
        TreeModel.focusedTree = value ? this : null;
    }
    /**
     * @return {?}
     */
    getFirstRoot() {
        return first(this.roots);
    }
    /**
     * @return {?}
     */
    getLastRoot() {
        return last(this.roots);
    }
    /**
     * @return {?}
     */
    focusNextNode() {
        /** @type {?} */
        let previousNode = this.focusedNode;
        /** @type {?} */
        let nextNode = previousNode ? previousNode.findNextNode() : this.getFirstRoot();
        nextNode && nextNode.focus(); // Short-circuit evaluation
    }
    /**
     * @return {?}
     */
    focusPreviousNode() {
        /** @type {?} */
        let previousNode = this.focusedNode;
        /** @type {?} */
        let nextNode = previousNode ? previousNode.findPreviousNode() : this.getLastRoot();
        nextNode && nextNode.focus();
    }
    /**
     * @return {?}
     */
    focusDrillUp() {
        /** @type {?} */
        let previousNode = this.focusedNode;
        /** @type {?} */
        let nextNode = previousNode && previousNode.realParent;
        nextNode && nextNode.focus();
    }
    /**
     * @return {?}
     */
    focusDrillDown() {
        /** @type {?} */
        let previousNode = this.focusedNode;
        /** @type {?} */
        let nextNode = previousNode && previousNode.getFirstChild();
        nextNode && nextNode.focus();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) {
        // https://stackoverflow.com/questions/35840576/differencse-between-eventemitter-next-and-eventemitter-emit-in-angular-2
        //  abandon next() function, begin to use emit() function
        // this.events[event.eventName].next(event);
        // this.events[event.eventName].emit(event,alert(event.eventName));//发射事件，并传递事件的对象
        this.events[event.eventName].emit(event);
    }
    /**
     * 判断是否执行移动节点操作，可以移动返回true，否则返回false
     * @param {?} __0
     * @return {?}
     */
    canMoveNode({ from, to }) {
        // same node
        if (from.parentNode === to.parentNode && from.index === to.index) {
            return false;
        }
        /** @type {?} */
        const fromChildren = from.parentNode.children;
        /** @type {?} */
        const fromNode = fromChildren[from.index];
        return !to.parentNode.isDescendantOf(fromNode);
    }
    /**
     * 移动节点
     * @param {?} __0
     * @return {?}
     */
    moveNode({ from, to }) {
        if (!this.canMoveNode({ from, to }))
            return;
        /** @type {?} */
        const fromChildren = from.parentNode.childrenField;
        // If node doesn't have children - create children array
        if (!to.parentNode.childrenField) {
            to.parentNode.childrenField = [];
        }
        /** @type {?} */
        const toChildren = to.parentNode.childrenField;
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
        // The splice() method changes the contents of an array by removing existing elements and/or adding new elements.
        /** @type {?} */
        const node = fromChildren.splice(from.index, 1)[0];
        // Compensate for index if already removed from parent:
        /** @type {?} */
        let toIndex = (from.parentNode === to.parentNode && to.index > from.index) ? to.index - 1 : to.index;
        toChildren.splice(toIndex, 0, node);
        // console.log("toChildren:" + toChildren);
        // console.log("AfterMoveNode:" + this.roots);
        this.update(this.roots); // 实现node moved后，重新刷新这棵树
        this.fireEvent({ eventName: TREE_EVENTS.onMoveNode, node, to });
    }
    // TODO: move to a different service:
    /**
     * @param {?} dragNode
     * @return {?}
     */
    setDragNode(dragNode) {
        this._dragNode = dragNode;
    }
    /**
     * @return {?}
     */
    getDragNode() {
        return this._dragNode || { parentNode: null, index: null };
    }
    /**
     * @return {?}
     */
    isDragging() {
        return this.getDragNode().parentNode;
    }
    /**
     * @param {?} dropLocation
     * @return {?}
     */
    setDropLocation(dropLocation) {
        this._dropLocation = dropLocation;
    }
    /**
     * @return {?}
     */
    getDropLocation() {
        return this._dropLocation || { component: null, parentNode: null, index: null };
    }
    /**
     * @param {?} component
     * @return {?}
     */
    isDraggingOver(component) {
        return this.getDropLocation().component === component;
    }
    /**
     * @return {?}
     */
    cancelDrag() {
        this.setDropLocation(null);
        this.setDragNode(null);
    }
}
TreeModel.focusedTree = null;
TreeModel.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// keys used in the angular tree component
/** @type {?} */
const KEYS = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    SPACE: 32
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//约定使用下划线表示lodash，就像用$表示jQuery一样
//1.require关键字不被识别：
// https://stackoverflow.com/questions/31173738/typescript-getting-error-ts2304-cannot-find-name-require
// declare var require: any
// const _ = require('lodash');
//2.安装lodash的es版本：
// (1) $>npm i lodash-es
// (2) $>npm install --save @types/lodash
class TreeComponent {
    /**
     * @param {?} treeModel
     */
    constructor(treeModel) {
        this.treeModel = treeModel;
        treeModel.eventNames.forEach((name) => this[name] = new EventEmitter()); //customEventName -> new EventEmitter()
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    set nodes(nodes) { }
    ;
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) { }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set focused(value) {
        this.treeModel.setFocus(value);
        // alert('focused on the tree');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.treeModel.setData({
            nodes: changes.nodes && changes.nodes.currentValue,
            options: changes.options && changes.options.currentValue,
            events: pick(this, this.treeModel.eventNames)
        });
    }
    // 优先使用HostListener装饰器绑定事件，而不是使用Directive或Component的host元数据
    // When binding events to Directive or Component, Angular suggests to prefer to HostListener decorator, 
    // rather than host metadata.
    /**
     * @param {?} $event
     * @return {?}
     */
    onKeydown($event) {
        // alert('Pressed a key');
        /** @type {?} */
        let focusedNode = this.treeModel.focusedNode;
        if (!this.treeModel.isFocused) {
            return;
        }
        if (includes([KEYS.DOWN, KEYS.UP, KEYS.LEFT,
            KEYS.RIGHT, KEYS.ENTER, KEYS.SPACE], $event.keyCode)) {
            $event.preventDefault(); //取消事件的默认动作，实现仅对includes键响应
        }
        switch ($event.keyCode) {
            case KEYS.DOWN:
                return this.treeModel.focusNextNode();
            case KEYS.UP:
                return this.treeModel.focusPreviousNode();
            case KEYS.LEFT:
                // alert('Focus Drill Up');
                if (focusedNode.isExpanded) {
                    focusedNode.toggle();
                }
                else {
                    this.treeModel.focusDrillUp();
                }
                return;
            case KEYS.RIGHT:
                // alert('Focus Drill Down');
                if (focusedNode.isCollapsed) {
                    focusedNode.toggle();
                }
                else {
                    this.treeModel.focusDrillDown();
                }
                return;
            case KEYS.ENTER:
            case KEYS.SPACE:
                // alert('Enter or Space key.');
                return focusedNode && focusedNode.toggleActivated();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMousedown($event) {
        // alert('click');
        /** @type {?} */
        let insideClick = $event.target.closest('ng2tree');
        if (!insideClick) {
            this.treeModel.setFocus(false);
        }
    }
    /**
     * @param {?} elementId
     * @return {?}
     */
    searchAndLocationNodeById(elementId) {
        // console.log('succeeded to search and location Node By Id in treeComponent:', elementId);
        this.treeModel.locateNodeByID(elementId);
    }
    /**
     * @param {?} elementId
     * @return {?}
     */
    searchNodeById(elementId) {
        // console.log('succeeded to search and location Node By Id in treeComponent:', elementId);
        return this.treeModel.searchTreeNodeByID(elementId);
    }
}
TreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng2tree',
                template: "<div class=\"tree\">\r\n    <!-- <div class=\"localFileTreeOperateTest\">\r\n      <button (click)=\"treeModel.addStaticTreeNode()\">\u65B0\u589E</button>\r\n      <button (click)=\"treeModel.removeFocusedTreeNode()\">\u5220\u9664</button>\r\n    </div> -->\r\n    <ng2tree-node\r\n      (click)=\"treeModel.setFocus(true)\"\r\n      *ngFor=\"let child of treeModel.roots; let i = index\"\r\n      [node]=\"child\"\r\n      [nodeIndex]=\"i\">\r\n    </ng2tree-node>\r\n</div>",
                providers: [
                    TreeModel
                ],
                styles: [".tree-children{padding-left:20px}.tree{display:inline-block;cursor:pointer;-webkit-user-select:none;-ms-user-select:none;-moz-user-select:none;user-select:none}"]
            }] }
];
/** @nocollapse */
TreeComponent.ctorParameters = () => [
    { type: TreeModel }
];
TreeComponent.propDecorators = {
    nodes: [{ type: Input }],
    options: [{ type: Input }],
    focused: [{ type: Input }],
    onToggle: [{ type: Output }],
    onActiveChanged: [{ type: Output }],
    onActivate: [{ type: Output }],
    onDeactivate: [{ type: Output }],
    onFocus: [{ type: Output }],
    onBlur: [{ type: Output }],
    onDoubleClick: [{ type: Output }],
    onContextMenu: [{ type: Output }],
    onRightMenuClicked: [{ type: Output }],
    onKeydown: [{ type: HostListener, args: ['body: keydown', ['$event'],] }],
    onMousedown: [{ type: HostListener, args: ['body: mousedown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 定义辅助指令TreeNodeContent，用来在模板中标记插入点
class TreeNodeContentDirective {
    // 依赖注入ViewContainerRef，获取对容器视图的访问权限
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
TreeNodeContentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[treeNodeContent-host]'
            },] }
];
/** @nocollapse */
TreeNodeContentDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeContentItem {
    /**
     * @param {?} component
     * @param {?} displayData
     */
    constructor(component, displayData) {
        this.component = component;
        this.displayData = displayData;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeContentComponent {
    /**
     * @param {?} componentFactoryResolver
     */
    constructor(componentFactoryResolver) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rightMenuClicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // 右键菜单相关
        this.rightMenuContainer.clear();
        if (this.originData.hasRightClickMenu) {
            /** @type {?} */
            const componentFactory = this.componentFactoryResolver.resolveComponentFactory(this.originData.rightClickMenuComponent);
            /** @type {?} */
            const componentRef = this.rightMenuContainer.createComponent(componentFactory);
            componentRef.instance['nodeData'] = this.originData;
            componentRef.instance['rightMenuClicked'].subscribe((event) => {
                this.rightMenuClicked.emit(event);
            });
        }
    }
}
TreeNodeContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng2tree-node-content',
                template: "<div class='tree-node-content' *ngIf=\"!originData.hasRightClickMenu\">\r\n  <span>{{ displayData }}</span>\r\n</div>\r\n<ng-container #rightMenuContainer>\r\n</ng-container>",
                styles: [".tree-node-content:hover{background:#a8daa7}"]
            }] }
];
/** @nocollapse */
TreeNodeContentComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];
TreeNodeContentComponent.propDecorators = {
    displayData: [{ type: Input }],
    originData: [{ type: Input }],
    rightMenuClicked: [{ type: Output }],
    rightMenuContainer: [{ type: ViewChild, args: ['rightMenuContainer', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeComponent {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} viewContainerRef
     */
    constructor(componentFactoryResolver, viewContainerRef) {
        this.componentFactoryResolver = componentFactoryResolver;
    }
    // TODO: move to draggable directive
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragStart($event) {
        // 设置DragNode: 选择dragNode的父节点作为DragNode，通过index定位到指定的节点
        setTimeout(() => this.node.treeModel.setDragNode({ parentNode: this.node.parent, index: this.nodeIndex }), 30);
    }
    /**
     * @return {?}
     */
    onDragEnd() {
        this.node.treeModel.setDragNode(null);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragOver($event) {
        $event.preventDefault();
        this.node.treeModel.setDropLocation({ component: this, parentNode: this.node, index: 0 });
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        $event.preventDefault();
        // this.node.mouseAction('drop', $event, { node: this.node, index: 0 });
        this.node.treeModel.setFocus(true);
        this.node.dropMouseAction($event, { parentNode: this.node, index: 0 });
        console.log("onDrop: tree-node-component");
    }
    /**
     * @param {?} nodeContentWrapper
     * @param {?} $event
     * @return {?}
     */
    onDragLeave(nodeContentWrapper, $event) {
        if (!this.node.treeModel.isDraggingOver(this)) {
            return;
        }
        /** @type {?} */
        const rect = nodeContentWrapper.getBoundingClientRect();
        // If outside the element
        if ($event.clientX < rect.left || $event.clientX > rect.right ||
            $event.clientY < rect.top || $event.clientY > rect.bottom) {
            this.node.treeModel.setDropLocation(null);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._loadTreeNodeContent();
        // 触发变更树节点展示文本
        this.node.changeDisplayField.subscribe(name => {
            if (this.componentRef) {
                this.componentRef.instance.displayData = name;
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
    }
    // 解决使用动态组件出现ExpressionChangedAfterItHasBeenCheckedError问题：
    // https://github.com/angular/angular/issues/17572
    /**
     * @return {?}
     */
    _loadTreeNodeContent() {
        // 使用Item从逻辑上将TreeNodeContentComponent和data关联起来
        /** @type {?} */
        let treeNodeContentItem = new TreeNodeContentItem(TreeNodeContentComponent, this.node.displayField);
        // 使用 ComponentFactoryResolver 来为每个具体的组件解析出一个 ComponentFactory 
        // 然后 ComponentFactory 会为每一个组件创建一个实例
        /** @type {?} */
        let componentFactory = this.componentFactoryResolver.resolveComponentFactory(treeNodeContentItem.component);
        /** @type {?} */
        let viewContainerRef = this.treeNodeContentHost.viewContainerRef;
        viewContainerRef.clear();
        this.componentRef = viewContainerRef.createComponent(componentFactory);
        this.componentRef.instance.displayData = treeNodeContentItem.displayData; // 传入数据
        this.componentRef.instance.originData = this.node.data;
        this.componentRef.instance.rightMenuClicked.subscribe(event => {
            this.node.rightMenuClicked(event);
        });
    }
}
TreeNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng2tree-node',
                template: "<div class=\"tree-node tree-node-level-{{ node.level }}\"\r\n[class.tree-node-expanded]=\"node.isExpanded && node.hasChildren\"\r\n[class.tree-node-collapsed]=\"node.isCollapsed && node.hasChildren\"\r\n[class.tree-node-leaf]=\"node.isLeaf\"\r\n[class.tree-node-active]=\"node.isActive\"\r\n[class.tree-node-focused]=\"node.isFocused\">\r\n\r\n<ng2tree-node-drop-slot\r\n  *ngIf=\"nodeIndex === 0\"\r\n  [dropIndex]=\"nodeIndex\"\r\n  [node]=\"node.parent\"\r\n></ng2tree-node-drop-slot>\r\n\r\n<span\r\n  *ngIf=\"node.hasChildren\"\r\n  class=\"toggle-children\"\r\n  (click)=\"node.toggleActivated()\"\r\n  (click)=\"node.toggle()\"\r\n  >\r\n</span>\r\n<span\r\n  *ngIf=\"!node.hasChildren\"\r\n  class=\"toggle-children-placeholder\">\r\n</span>\r\n\r\n<!-- \u8BBE\u7F6Eclick\u4E8B\u4EF6\u7684\u5904\u7406\u5668 -->\r\n<!-- [draggable]=\"node.allowDrag()\"\r\n(dragstart)=\"onDragStart($event)\"\r\n(drop)=\"onDrop($event)\"\r\n(dragend)=\"onDragEnd()\"\r\n(dragover)=\"onDragOver($event)\"\r\n(dragleave)=\"onDragLeave(nodeContentWrapper, $event)\" -->\r\n<div class=\"node-content-wrapper\"\r\n  #nodeContentWrapper\r\n  (click)=\"node.toggleActivated()\"\r\n  (dblclick)=\"node.doublClick($event)\"\r\n  (contextmenu)=\"node.contextMenu($event)\"\r\n\r\n  >\r\n  <!-- \u8BBE\u7F6E\u52A8\u6001\u7EC4\u4EF6\u7684\u951A\u70B9 -->\r\n  <ng-template treeNodeContent-host></ng-template> \r\n</div>\r\n\r\n<div class=\"tree-children\" [hidden]=\"node.isCollapsed\">\r\n  <ng2tree-node\r\n    *ngFor=\"let child of node.childrenField; let i = index\"\r\n    [node]=\"child\"\r\n    [nodeIndex]=\"i\">\r\n  </ng2tree-node>\r\n</div>\r\n\r\n<ng2tree-node-drop-slot\r\n  [dropIndex]=\"nodeIndex + 1\"\r\n  [node]=\"node.parent\"\r\n></ng2tree-node-drop-slot>\r\n\r\n</div>",
                styles: [".tree-children{padding-left:20px}.node-content-wrapper{display:inline-block;padding:2px 5px;border-radius:2px;transition:background-color .15s,box-shadow .15s;white-space:nowrap}.tree-node-active>.node-content-wrapper{background:#beebff}.tree-node-active.tree-node-focused>.node-content-wrapper{background:#5db0e7}.tree-node-focused>.node-content-wrapper{background:#e7f4f9}.node-content-wrapper:hover{background:#f7fbff}.node-content-wrapper:hover,.tree-node-active>.node-content-wrapper,.tree-node-focused>.node-content-wrapper{box-shadow:inset 0 0 1px #999}.tree-node-expanded .toggle-children{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='%23646465' d='M11 10H5.344L11 4.414V10z'/%3E%3C/svg%3E\")}.tree-node-collapsed .toggle-children{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='%23646465' d='M6 4v8l4-4-4-4zm1 2.414L8.586 8 7 9.586V6.414z'/%3E%3C/svg%3E\")}.toggle-children{height:16px;width:16px;background-size:16px;display:inline-block;position:relative;background-repeat:no-repeat;background-position:center;right:-6px;top:4px;overflow:hidden}.toggle-children-placeholder{display:inline-block;height:10px;width:10px;position:relative;top:1px}.tree-node-icon{width:1rem}.tree-node{white-space:nowrap}"]
            }] }
];
/** @nocollapse */
TreeNodeComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef }
];
TreeNodeComponent.propDecorators = {
    node: [{ type: Input }],
    nodeIndex: [{ type: Input }],
    treeNodeContentHost: [{ type: ViewChild, args: [TreeNodeContentDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeDropSlotComponent {
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragOver($event) {
        $event.preventDefault();
        this.node.treeModel.setDropLocation({ component: this, parentNode: this.node, index: this.dropIndex });
    }
    /**
     * @return {?}
     */
    onDragLeave() {
        if (this.node.treeModel.isDraggingOver(this)) {
            this.node.treeModel.setDropLocation(null);
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        $event.preventDefault();
        // this.node.mouseAction('drop', $event, { node: this.node, index: this.dropIndex });
        console.log('onDropEvent: tree-node-drop-slot');
        this.node.dropMouseAction($event, { parentNode: this.node, index: this.dropIndex });
    }
}
TreeNodeDropSlotComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng2tree-node-drop-slot',
                template: "<div\r\n  class=\"node-drop-slot\"\r\n  [class.is-dragging-over]=\"node.treeModel.isDraggingOver(this)\"\r\n  (drop)=\"onDrop($event)\"\r\n  (dragover)=\"onDragOver($event)\"\r\n  (dragleave)=\"onDragLeave()\"\r\n>\r\n</div>",
                styles: [".node-drop-slot{display:block;height:2px;width:100%}.node-drop-slot.is-dragging-over{background:#dfe;height:20px;border:2px dotted #888}"]
            }] }
];
TreeNodeDropSlotComponent.propDecorators = {
    node: [{ type: Input }],
    dropIndex: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeModule {
}
TreeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    TreeComponent,
                    TreeNodeComponent,
                    TreeNodeContentComponent,
                    TreeNodeContentDirective,
                    TreeNodeDropSlotComponent
                ],
                imports: [
                    CommonModule
                ],
                providers: [],
                entryComponents: [
                    TreeNodeContentComponent
                ],
                exports: [
                    TreeComponent,
                    TreeNodeComponent,
                    TreeNodeContentComponent,
                    TreeNodeContentDirective,
                    TreeNodeDropSlotComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// injectionToken作用说明
// https://segmentfault.com/a/1190000008626348
/** @type {?} */
const ANGULAR_MONACO_EDITOR_CONFIG = new InjectionToken('ANGULAR_MONACO_EDITOR_CONFIG');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CODE_EDITOR_EVENTS = {
    onInit: 'onInit'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CodeEditorEventService {
    constructor() {
        this.eventNames = Object.keys(CODE_EDITOR_EVENTS);
        this._events = {}; // 使用事件
    }
    // 使用事件
    /**
     * 设置启用事件
     * @param {?} event
     * @return {?}
     */
    addEvent(event) {
        assign(this._events, event);
        // console.log(this.events);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) {
        this._events[event.eventName].emit(event);
        // console.log("Emit Event:" + event);
    }
}
CodeEditorEventService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let loadedMonaco = false;
/** @type {?} */
let loadPromise;
/**
 * @abstract
 */
class BaseMonacoEditor {
    /**
     * @param {?} codeEditorEventService
     * @param {?} config
     */
    constructor(codeEditorEventService, config) {
        this.codeEditorEventService = codeEditorEventService;
        this.config = config;
        // 初始化自定义事件
        /** @type {?} */
        const self = this;
        codeEditorEventService.eventNames.forEach((name) => {
            // 创建自定义事件，此处作用等效于: @Output() onInit = new EventEmitter<any>()
            self[name] = new EventEmitter();
            /** @type {?} */
            const eventPair = pick(self, name);
            codeEditorEventService.addEvent(eventPair);
        });
    }
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
        // 默认options(this.config.defaultOptions) + 自定义options(options)
        this._options = Object.assign({}, this.config.defaultOptions, options);
        if (this._editor) {
            this._editor.dispose();
            this.initMonaco(options);
        }
    }
    /**
     * @return {?}
     */
    get options() {
        return this._options;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (loadedMonaco) {
            // Wait until monaco editor is available
            loadPromise.then(() => {
                this.initMonaco(this.options);
            });
        }
        else {
            loadedMonaco = true;
            loadPromise = new Promise((resolve) => {
                /** @type {?} */
                const baseUrl = this.config.baseUrl || '/assets';
                // if (typeof((<any>window).monaco) === 'object') {
                //   resolve();
                //   return;
                // }
                /** @type {?} */
                const onGotAmdLoader = () => {
                    // Load monaco
                    ((/** @type {?} */ (window))).require.config({ paths: { 'vs': `${baseUrl}/monaco/vs` } });
                    ((/** @type {?} */ (window))).require(['vs/editor/editor.main'], () => {
                        if (typeof this.config.onMonacoLoad === 'function') {
                            this.config.onMonacoLoad();
                        }
                        this.initMonaco(this.options);
                        resolve();
                    });
                };
                // Load AMD loader if necessary
                if (!((/** @type {?} */ (window))).require) {
                    /** @type {?} */
                    const loaderScript = document.createElement('script');
                    loaderScript.type = 'text/javascript';
                    loaderScript.src = `${baseUrl}/monaco/vs/loader.js`;
                    loaderScript.addEventListener('load', onGotAmdLoader);
                    document.body.appendChild(loaderScript);
                }
                else {
                    onGotAmdLoader();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._windowResizeSubscription) {
            this._windowResizeSubscription.unsubscribe();
        }
        if (this._editor) {
            this._editor.dispose();
            this._editor = undefined;
        }
    }
}
BaseMonacoEditor.propDecorators = {
    _editorComponent: [{ type: ViewChild, args: ['codeEditor',] }],
    onInit: [{ type: Output }],
    options: [{ type: Input, args: ['options',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Angular Monaco Editor Component Variables
// 汇总Angular monaco editor component 组件暴露的变量
class AngularMonacoEditorService {
    constructor() {
        this._existError = false; //默认没有错误
    }
    //默认没有错误
    /**
     * @return {?}
     */
    get existError() {
        return this._existError;
    }
    /**
     * @return {?}
     */
    handleModelMarkers() {
        /** @type {?} */
        var self = this;
        // https://github.com/Microsoft/monaco-editor/issues/30
        /** @type {?} */
        const setModelMarkers = monaco.editor.setModelMarkers;
        monaco.editor.setModelMarkers = function (model, owner, markers) {
            setModelMarkers.call(monaco.editor, model, owner, markers);
            if (markers.length === 0) ;
            else {
                // there are errors
                self._existError = true;
            }
        };
    }
}
AngularMonacoEditorService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 自定义输入控件:1.封装ControlValueAccessor
// https://code-examples.net/zh-CN/q/2154761
/** @type {?} */
const CODE_EDITOR_INPUT_VALUE_ACCESSOR = {
    // https://blog.csdn.net/wangdan_2013/article/details/81314959
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AngularMonacoEditorComponent),
    multi: true
};
// 自定义输入控件 <-> Monaco Edtor
// 自定义输入控件:3.1 implements ControlValueAccessor
class AngularMonacoEditorComponent extends BaseMonacoEditor {
    // tslint:disable-next-line:max-line-length
    /**
     * @param {?} angularMonacoEditorService
     * @param {?} zone
     * @param {?} editorEventService
     * @param {?} angularEditorconfig
     */
    constructor(angularMonacoEditorService, zone, editorEventService, angularEditorconfig) {
        super(editorEventService, angularEditorconfig);
        this.angularMonacoEditorService = angularMonacoEditorService;
        this.zone = zone;
        this.editorEventService = editorEventService;
        this.angularEditorconfig = angularEditorconfig;
        this._value = '';
        // ControlValueAccessor提供的事件回调
        this.onControlValueChange = (_) => {
        };
        // ControlValueAccessor提供的事件回调
        this.onControlTouched = () => {
        };
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this.options.model = model;
        if (this._editor) {
            this._editor.dispose();
            this.initMonaco(this.options);
        }
    }
    // todo: 提取options公共类
    /**
     * @protected
     * @param {?} options
     * @return {?}
     */
    initMonaco(options) {
        /** @type {?} */
        const enableModel = !!options.model;
        if (enableModel) {
            /** @type {?} */
            const searchedModel = monaco.editor.getModel(options.model.uri);
            if (null !== searchedModel) {
                searchedModel.dispose();
            }
            options.model = monaco.editor.createModel(options.model.value, options.model.language, options.model.uri);
        }
        this._editor = monaco.editor.create(this._editorComponent.nativeElement, options);
        if (!enableModel) {
            this._editor.setValue(this._value);
        }
        if (enableModel) {
            this.angularMonacoEditorService.handleModelMarkers();
        }
        // monaco editor -> outside component
        this._editor.onDidChangeModelContent((e) => this.onChangeModelContentHandler(e));
        this._editor.onDidBlurEditorText((e) => this.onBlurEditorTextHandler(e));
        this._editor.onDidLayoutChange((e) => this.onLayoutChangeHandler(e));
        // refresh layout on resize event.
        this.refreshLayoutWhenWindowResize();
        this.editorEventService.fireEvent({
            eventName: CODE_EDITOR_EVENTS.onInit,
            target: this,
            editor: this._editor
        });
    }
    /**
     * refresh layout when resized the window
     * @return {?}
     */
    refreshLayoutWhenWindowResize() {
        if (this._windowResizeSubscription) {
            this._windowResizeSubscription.unsubscribe();
        }
        // fromEvent用于兼听事件，事件触发时，将事件event转成可流动的Observable进行传输
        // https://www.jianshu.com/p/46894deb870a
        this._windowResizeSubscription = fromEvent(window, 'resize').subscribe(() => this._editor.layout());
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onChangeModelContentHandler(e) {
        /** @type {?} */
        const _value = this._editor.getValue();
        // monaco editor -> outside component
        // https://github.com/JTangming/tm/issues/4 ngZone详解
        this.zone.run(() => this.value = _value); // value is not propagated to parent when executing outside zone.
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onBlurEditorTextHandler(e) {
        this.onControlTouched();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onLayoutChangeHandler(e) {
        console.log('Layout changed:\n' + e);
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.value) { // 注意这种写法，值得学习
            this._value = v;
        }
        this.onControlValueChange(this.value); // 在属性修饰器里调用onControlValueChange方法
    }
    // 自定义输入控件:3.2 implements ControlValueAccesso
    // outside component -> monaco editor
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        /** @type {?} */
        const self = this;
        self.value = value || '';
        // Fix for value change while dispose in process.
        setTimeout(() => {
            if (self._editor /*&& !this.options.model*/) {
                self._editor.setValue(self._value);
            }
        });
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onControlValueChange = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
}
AngularMonacoEditorComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'angular-monaco-editor',
                template: "<div class=\"editor\" #codeEditor></div>",
                // 自定义输入控件:2.引入依赖服务ControlValueAccessor
                providers: [
                    CODE_EDITOR_INPUT_VALUE_ACCESSOR,
                    CodeEditorEventService,
                    AngularMonacoEditorService
                ],
                styles: [":host{display:block;min-height:200px}.editor{width:100%;height:100%}"]
            }] }
];
/** @nocollapse */
AngularMonacoEditorComponent.ctorParameters = () => [
    { type: AngularMonacoEditorService },
    { type: NgZone },
    { type: CodeEditorEventService },
    { type: undefined, decorators: [{ type: Inject, args: [ANGULAR_MONACO_EDITOR_CONFIG,] }] }
];
AngularMonacoEditorComponent.propDecorators = {
    model: [{ type: Input, args: ['model',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AngularMonacoEditorModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = {}) {
        return {
            ngModule: AngularMonacoEditorModule,
            providers: [
                { provide: ANGULAR_MONACO_EDITOR_CONFIG, useValue: config }
            ]
        };
    }
}
AngularMonacoEditorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    AngularMonacoEditorComponent
                ],
                exports: [
                    AngularMonacoEditorComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MenuItemContext {
    constructor() {
        this.$implicit = {};
    }
}
class ShContextMenuItemDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
        this.closeOnClick = true;
        this.click = new EventEmitter();
        this.context = new MenuItemContext();
    }
    /**
     * @return {?}
     */
    setNotActive() {
        this._active = false;
        if (this.subMenu) {
            this.subMenu.setNotActive();
        }
    }
    /**
     * @return {?}
     */
    setActive() {
        this._active = true;
    }
}
ShContextMenuItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[shContextMenuItem]'
            },] }
];
/** @nocollapse */
ShContextMenuItemDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
ShContextMenuItemDirective.propDecorators = {
    subMenu: [{ type: Input }],
    divider: [{ type: Input }],
    visible: [{ type: Input }],
    disabled: [{ type: Input }],
    closeOnClick: [{ type: Input }],
    click: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShContextMenuService {
    /**
     * @param {?} overlay
     */
    constructor(overlay) {
        this.overlay = overlay;
        this.activeOverlays = [];
    }
    /**
     * @param {?} ctxEvent
     * @return {?}
     */
    openMenu(ctxEvent) {
        this.closeCurrentOverlays();
        const { menu, mouseEvent, targetElement, data } = ctxEvent;
        this.activeMenu = menu;
        mouseEvent.preventDefault();
        mouseEvent.stopPropagation();
        this.overrideGetBoundingClientRect(targetElement, mouseEvent);
        /** @type {?} */
        const scrollStrategy = this.buildCloseScrollStrategy();
        /** @type {?} */
        const positionStrategy = this.buildConnectedPositionStrategy(targetElement);
        this.attachContextToItems(menu, data);
        /** @type {?} */
        const overlayRef = this.createAndAttachOverlay(positionStrategy, scrollStrategy, menu, true);
        this.attachOverlayRef(menu, overlayRef);
        this.registerBackdropEvents(overlayRef);
    }
    /**
     * @param {?} ctxEvent
     * @return {?}
     */
    openSubMenu(ctxEvent) {
        const { menu, mouseEvent, targetElement, data, parentMenu } = ctxEvent;
        mouseEvent.preventDefault();
        mouseEvent.stopPropagation();
        /** @type {?} */
        const scrollStrategy = this.buildCloseScrollStrategy();
        /** @type {?} */
        const positionStrategy = this.buildConnectedPositionStrategyForSubMenu(targetElement);
        /** @type {?} */
        const overlayRef = this.createAndAttachOverlay(positionStrategy, scrollStrategy, menu, false);
        this.attachContextToItems(menu, data);
        this.attachThisContext(menu, parentMenu);
        this.attachOverlayRef(menu, overlayRef);
    }
    /**
     * @return {?}
     */
    destroy() {
        this.closeCurrentOverlays();
        this.backDropSub.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @param {?} menu
     * @return {?}
     */
    closeSubMenus(menu) {
        /** @type {?} */
        const itemsWithSubMenus = menu
            .menuItems
            .filter(i => !!i.subMenu && !!i.subMenu.overlayRef);
        if (itemsWithSubMenus.length) {
            itemsWithSubMenus.forEach(sm => this.closeSubMenus(sm.subMenu));
            /** @type {?} */
            const overlayRefs = itemsWithSubMenus
                .map(i => i.subMenu.overlayRef);
            overlayRefs.forEach(r => r.dispose());
        }
    }
    /**
     * @private
     * @param {?} overlayRef
     * @return {?}
     */
    registerBackdropEvents(overlayRef) {
        /** @type {?} */
        const elm = overlayRef.backdropElement;
        this.backDropSub = fromEvent(elm, 'mousedown')
            .subscribe(this.closeCurrentOverlays.bind(this));
    }
    /**
     * @private
     * @param {?} positionStrategy
     * @param {?} scrollStrategy
     * @param {?} menu
     * @param {?=} hasBackdrop
     * @return {?}
     */
    createAndAttachOverlay(positionStrategy, scrollStrategy, menu, hasBackdrop = true) {
        /** @type {?} */
        const overlayRef = this.overlay.create({
            positionStrategy,
            scrollStrategy,
            hasBackdrop: hasBackdrop,
            backdropClass: 'sh-backdrop'
        });
        /*
             TODO: try passing the TemplatePortal context (data)
             and then injecting it to the *ngTemplateOutlet in the component template
            */
        /** @type {?} */
        const menuPortal = new TemplatePortal(menu.menuTemplate, menu.menuContainer);
        overlayRef.attach(menuPortal);
        this.activeOverlays.push(overlayRef);
        return overlayRef;
    }
    /**
     * @private
     * @return {?}
     */
    buildCloseScrollStrategy() {
        return this.overlay.scrollStrategies.close();
    }
    /**
     * @private
     * @param {?} elm
     * @return {?}
     */
    buildConnectedPositionStrategy(elm) {
        return this
            .overlay
            .position()
            .connectedTo(elm, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
            .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
    }
    /**
     * @private
     * @param {?} elm
     * @return {?}
     */
    buildConnectedPositionStrategyForSubMenu(elm) {
        return this
            .overlay
            .position()
            .connectedTo(elm, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });
    }
    /*
        we need to override getBoundingClientRect() to return the position of the menu.
        this is done because @angular/cdk use this function internally to determine where the overlay should be positioned
        https://github.com/angular/material2/blob/master/src/cdk/overlay/position/connected-position-strategy.ts#L288
       */
    /**
     * @private
     * @param {?} elm
     * @param {?} event
     * @return {?}
     */
    overrideGetBoundingClientRect(elm, event) {
        const { clientX, clientY } = event;
        elm.nativeElement.getBoundingClientRect = () => {
            return {
                bottom: clientY,
                height: 0,
                left: clientX,
                right: clientX,
                top: clientY,
                width: 0
            };
        };
    }
    /**
     * @private
     * @return {?}
     */
    closeCurrentOverlays() {
        this.activeOverlays.forEach((o) => {
            o.detach();
            o.dispose();
        });
        this.activeOverlays = [];
        // TODO: create close subject and emit.
        // subscribe in component
        if (this.activeMenu) {
            this.activeMenu.close();
        }
    }
    /**
     * @private
     * @param {?} menu
     * @param {?} data
     * @return {?}
     */
    attachContextToItems(menu, data) {
        menu.menuItems.forEach(i => i.context.$implicit = data);
    }
    /**
     * @private
     * @param {?} menu
     * @param {?} parentMenu
     * @return {?}
     */
    attachThisContext(menu, parentMenu) {
        menu.thisContext = parentMenu.thisContext;
    }
    /**
     * @private
     * @param {?} menu
     * @param {?} overlayRef
     * @return {?}
     */
    attachOverlayRef(menu, overlayRef) {
        menu.overlayRef = overlayRef;
    }
}
ShContextMenuService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ShContextMenuService.ctorParameters = () => [
    { type: Overlay }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShContextMenuComponent {
    /**
     * @param {?} ctxService
     */
    constructor(ctxService) {
        this.ctxService = ctxService;
        this.contentChildrenItems = new QueryList();
        this.viewChildrenItems = new QueryList();
    }
    /**
     * @return {?}
     */
    get menuItems() {
        // when using the ShContextMenuComponent as menu, the ContentChildren is the source
        if (this.contentChildrenItems.length) {
            return this.contentChildrenItems;
        }
        // when using a custom component as menu the ViewChildren is the source
        return this.viewChildrenItems;
    }
    /**
     * @param {?} $event
     * @param {?} item
     * @param {?} elm
     * @return {?}
     */
    onEnter($event, item, elm) {
        this.ctxService.closeSubMenus(this);
        this.setNotActive();
        if (!item.subMenu || !item.visible) {
            return;
        }
        this.setActive(item);
        this.ctxService.openSubMenu({
            data: item.context.$implicit,
            targetElement: new ElementRef(elm),
            menu: item.subMenu,
            mouseEvent: $event,
            parentMenu: this
        });
    }
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    setActive(item) {
        item.setActive();
        this.subActive = true;
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    onClick(event, item) {
        // TODO: move click handling to service
        if (item.divider) {
            return;
        }
        if (!item.subMenu && item.closeOnClick) {
            this.ctxService.destroy();
            item.click.emit({
                data: item.context.$implicit,
                event
            });
        }
    }
    /**
     * @private
     * @param {?} fn
     * @param {?} fallbackContext
     * @param {?} data
     * @param {?} event
     * @return {?}
     */
    callWithContext(fn, fallbackContext, data, event) {
        return fn.call(this.thisContext ? this.thisContext : fallbackContext, { data, event });
    }
    /**
     * @return {?}
     */
    close() {
        this.setNotActive();
        this.menuContainer.detach();
        if (this.overlayRef) {
            this.overlayRef.detach();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.close();
    }
    /**
     * @return {?}
     */
    setNotActive() {
        this.subActive = false;
        this.menuItems.forEach(i => i.setNotActive());
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isVisible(item) {
        if (!item.visible) {
            return true;
        }
        return this.callWithContext(item.visible, this, item.context.$implicit, null);
    }
}
ShContextMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'sh-context-menu',
                encapsulation: ViewEncapsulation.None,
                template: `
    <ng-container #menuContainer></ng-container>
    <ng-template #menuTemplate>
      <div class="sh-context-menu">
        <div
          *ngFor="let menuItem of menuItems"
          #itemElement
          [ngClass]="{'sh-sub-anchor': menuItem.subMenu && menuItem.visible,
           'sh-context-menu--item__disable': !menuItem.visible,
           'sh-context-menu--item__divider': menuItem.divider,
           'sh-context-menu--item__sub-active': subActive && menuItem.active}"
          class="sh-context-menu--item"
          (mouseenter)="onEnter($event, menuItem, itemElement)"
          (click)="onClick($event, menuItem)">
          <ng-container *ngIf="!menuItem.divider || !isVisible(menuItem)">
            <ng-content *ngTemplateOutlet="menuItem.template; context: menuItem.context"></ng-content>
          </ng-container>
        </div>
      </div>
    </ng-template>
  `,
                styles: [".sh-backdrop{background-color:transparent}.sh-context-menu{background:#fff;min-width:150px;border:1px solid rgba(0,0,0,.2);border-radius:3px;box-shadow:0 0 10px 2px rgba(0,0,0,.1);color:#656565;margin:0}.sh-context-menu--item{padding:7px 10px 7px 15px;transition:.15s}.sh-context-menu--item:hover,.sh-context-menu--item__sub-active{background-color:#ededed;cursor:pointer}.sh-context-menu--item.sh-context-menu--item__divider:hover{background-color:#ececec;color:#000;cursor:default}.sh-context-menu--item__divider{height:1px;padding:0;overflow:hidden;border-bottom:1px solid #d0d0d0}.sh-context-menu--item.sh-sub-anchor{position:relative;min-width:140px}.sh-sub-anchor:after{content:\"\";top:50%;right:6px;-webkit-transform:translateY(-50%);transform:translateY(-50%);position:absolute;border-top:4px solid transparent;border-bottom:4px solid transparent;border-left:5px solid #000}.sh-context-menu--item__disable{color:#a6a2a2}"]
            }] }
];
/** @nocollapse */
ShContextMenuComponent.ctorParameters = () => [
    { type: ShContextMenuService }
];
ShContextMenuComponent.propDecorators = {
    thisContext: [{ type: Input, args: ['this',] }],
    contentChildrenItems: [{ type: ContentChildren, args: [ShContextMenuItemDirective, { read: ShContextMenuItemDirective },] }],
    viewChildrenItems: [{ type: ViewChildren, args: [ShContextMenuItemDirective, { read: ShContextMenuItemDirective },] }],
    menuTemplate: [{ type: ViewChild, args: ['menuTemplate', { read: TemplateRef },] }],
    menuContainer: [{ type: ViewChild, args: ['menuContainer', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShAttachMenuDirective {
    /**
     * @param {?} ctxService
     * @param {?} elm
     */
    constructor(ctxService, elm) {
        this.ctxService = ctxService;
        this.elm = elm;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setupEvents();
    }
    /**
     * @private
     * @return {?}
     */
    setupEvents() {
        /** @type {?} */
        const observables = [];
        if (!this.triggers) {
            observables.push(fromEvent(this.elm.nativeElement, 'contextmenu'));
        }
        else {
            this.triggers.forEach((t) => {
                observables.push(fromEvent(this.elm.nativeElement, t));
            });
        }
        this.sub = merge(...observables).subscribe(this.openMenu.bind(this));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    openMenu(event) {
        this.ctxService.openMenu({
            menu: this.menu,
            mouseEvent: event,
            targetElement: this.elm,
            data: this.data
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
}
ShAttachMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[shAttachMenu]'
            },] }
];
/** @nocollapse */
ShAttachMenuDirective.ctorParameters = () => [
    { type: ShContextMenuService },
    { type: ElementRef }
];
ShAttachMenuDirective.propDecorators = {
    menu: [{ type: Input, args: ['shAttachMenu',] }],
    triggers: [{ type: Input, args: ['shMenuTriggers',] }],
    data: [{ type: Input, args: ['shMenuData',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShContextMenuModule {
}
ShContextMenuModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ShAttachMenuDirective,
                    ShContextMenuComponent,
                    ShContextMenuItemDirective
                ],
                exports: [
                    ShAttachMenuDirective,
                    ShContextMenuComponent,
                    ShContextMenuItemDirective
                ],
                providers: [
                    ShContextMenuService
                ],
                imports: [
                    CommonModule,
                    OverlayModule
                ],
                entryComponents: [
                    ShContextMenuComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WizardComponent {
    /**
     * @param {?} viewContainerRef
     * @param {?} componentFactoryResolver
     */
    constructor(viewContainerRef, componentFactoryResolver) {
        this.viewContainerRef = viewContainerRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.clickCancelBtn = new EventEmitter();
        this.clickFinishBtn = new EventEmitter();
        this.title = '';
        this.steps = [];
        this.curStepIndex = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.steps && this.steps.length > 0) {
            this.curStep = this.steps[this.curStepIndex];
            this.createStepComponent(this.steps[this.curStepIndex]);
        }
    }
    /**
     * @param {?} step
     * @return {?}
     */
    createStepComponent(step) {
        this.stepContainer.clear();
        /** @type {?} */
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(step.component);
        this.curComponentRef = this.stepContainer.createComponent(componentFactory);
        this.curComponentRef.instance.data = step.data;
        // 新增步骤
        if (this.curComponentRef.instance.addStep) {
            this.curComponentRef.instance.addStep.subscribe((stepList) => {
                /** @type {?} */
                const curIndex = findIndex(this.steps, this.curStep);
                this.steps.splice(curIndex + 1, 0, ...stepList);
                this.curStep.nextStep = stepList[0].stepId;
                this.curStep.showFinishBtn = false;
                this.curStep.showNextStepBtn = true;
            });
        }
        // 删除步骤
        if (this.curComponentRef.instance.removeStep) {
            this.curComponentRef.instance.removeStep.subscribe((data) => {
                merge$1(this.curStep, data.curStep);
                data.removeSteps.forEach(removeStep => {
                    /** @type {?} */
                    const index = findIndex(this.steps, removeStep);
                    this.steps.splice(index, 1);
                });
            });
        }
        // 变更步骤
        if (this.curComponentRef.instance.changeStep) {
            this.curComponentRef.instance.changeStep.subscribe((stepList) => {
                stepList.forEach(changeStep => {
                    /** @type {?} */
                    const oldStep = find(this.steps, function (s) { return s.stepId === changeStep.stepId; });
                    merge$1(oldStep, changeStep);
                });
            });
        }
    }
    /**
     * @param {?} nextStep
     * @return {?}
     */
    jumpStep(nextStep) {
        // 判断跳转方向
        if (nextStep === this.curStep) {
            return;
        }
        /** @type {?} */
        const nextIndex = findIndex(this.steps, function (s) { return s.stepId === nextStep.stepId; });
        if (nextIndex === this.curStepIndex) {
            return;
        }
        if (nextIndex < this.curStepIndex) { // 向前跳
            this.curStep = nextStep;
            this.curStepIndex = nextIndex;
            this.createStepComponent(nextStep);
            return;
        }
        if (nextStep.stepId === this.curStep.nextStep) { // 下一步
            this.nextStep();
            return;
        }
        //  else if (this.finishedSteps.indexOf(nextStep.stepId) > -1) { // 已完成的后续步骤
        //   this.curStep = nextStep;
        //   this.curStepIndex = nextIndex;
        //   this.createStepComponent(nextStep);
        // }
    }
    /**
     * 点击上一步
     * @return {?}
     */
    lastStep() {
        /** @type {?} */
        const self = this;
        this.curStepIndex = findIndex(this.steps, function (s) { return s.nextStep === self.curStep.stepId; });
        this.curStep = this.steps[this.curStepIndex];
        this.createStepComponent(this.curStep);
    }
    /**
     * 点击下一步
     * @return {?}
     */
    nextStep() {
        // 校验
        /** @type {?} */
        const validationFunc = this.curComponentRef.instance.validation;
        if (validationFunc && typeof (validationFunc) === 'function') {
            /** @type {?} */
            const result = validationFunc();
            if (!result) {
                return;
            }
        }
        // 执行各Component定义的nextStepClick事件
        /** @type {?} */
        const clickNextStep = this.curComponentRef.instance.clickNextStep;
        if (clickNextStep && typeof (clickNextStep) === 'function') {
            /** @type {?} */
            const result = clickNextStep();
            if (typeof (result) === 'boolean') {
                this.moveToNextStep(result);
            }
            else {
                result.subscribe(data => {
                    this.moveToNextStep(data);
                });
            }
        }
        else {
            this.moveToNextStep(true);
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    moveToNextStep(data) {
        if (!data) {
            return;
        }
        /** @type {?} */
        const curStep = this.curStep;
        if (curStep.nextStep === '') {
            return;
        }
        // this.finishedSteps.push(curStep.stepId);
        this.curStepIndex = findIndex(this.steps, function (s) { return s.stepId === curStep.nextStep; });
        if (this.curStepIndex > -1) {
            this.curStep = this.steps[this.curStepIndex];
            this.createStepComponent(this.curStep);
        }
    }
    /**
     * 取消
     * @return {?}
     */
    clickCancel() {
        this.clickCancelBtn.emit();
    }
    /**
     * 完成
     * @return {?}
     */
    finishWizard() {
        /** @type {?} */
        const validationFunc = this.curComponentRef.instance.validation;
        if (validationFunc && typeof (validationFunc) === 'function') {
            /** @type {?} */
            const result = validationFunc();
            if (!result) {
                return;
            }
        }
        /** @type {?} */
        const beforeFinish = this.curComponentRef.instance.beforeFinish;
        if (beforeFinish && typeof (beforeFinish) === 'function') {
            /** @type {?} */
            const result = beforeFinish();
            if (!result) {
                return;
            }
        }
        this.clickFinishBtn.emit();
    }
}
WizardComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-wizard',
                template: "<div class=\"stepWizard\">\r\n  <div class=\"createNav d-flex flex-wrap\" *ngIf=\"steps.length>1\">\r\n    <div *ngFor=\"let step of steps\" class=\"d-flex step\" [class.active]=\"curStep.stepId===step.stepId\">\r\n      <div class=\"d-flex\" *ngIf=\"step.show\" (click)=\"jumpStep(step)\">\r\n        <div class=\"stepTitle\">{{step.title}}</div>\r\n        <div class=\"triangle_border_right\">\r\n          <span></span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"content\">\r\n    <perfect-scrollbar [config]=\"{suppressScrollX: true}\">\r\n      <ng-container #stepContainer></ng-container>\r\n    </perfect-scrollbar>\r\n  </div>\r\n\r\n\r\n\r\n  <div class=\"footBtns\">\r\n    <button type=\"button\" class=\"btn btn-outline-secondary btn-sm px-3 mx-2\" *ngIf=\"curStep.showCancelBtn\" (click)=\"clickCancel()\">\u53D6\u6D88</button>\r\n    <button type=\"button\" class=\"btn btn-outline-primary btn-sm px-3 mx-2\" *ngIf=\"curStep.showLastStepBtn\" (click)=\"lastStep()\"\r\n      type=\"submit\">\u4E0A\u4E00\u6B65</button>\r\n    <button type=\"button\" class=\"btn btn-outline-primary btn-sm px-3 mx-2\" *ngIf=\"curStep.showNextStepBtn\" (click)=\"nextStep()\"\r\n      type=\"submit\">\u4E0B\u4E00\u6B65</button>\r\n    <button type=\"button\" class=\"btn btn-outline-primary btn-sm px-3 mx-2\" *ngIf=\"curStep.showFinishBtn\" (click)=\"finishWizard()\">\u5B8C\u6210</button>\r\n  </div>\r\n</div>",
                styles: [":host{position:absolute;top:0;bottom:0;left:0;right:0}.stepWizard{height:100%;display:flex;flex-direction:column}.stepWizard .createNav{background:#e8edf2;height:40px;overflow:hidden}.stepWizard .createNav .stepTitle{padding:0 10px;color:#666;line-height:40px;cursor:pointer;font-size:.875rem}.stepWizard .createNav .step.active .stepTitle{color:#fff;background-color:#346180!important}.stepWizard .createNav .step:not(:first-child).active .stepTitle{margin-left:-17px;padding-left:25px}.stepWizard .createNav .stepTitle.disable{color:#cdcdcf}.stepWizard .createNav .step .triangle_border_right{width:0;height:0;border-width:20px 0 20px 18px;border-style:solid;border-color:transparent transparent transparent #ccc;position:relative}.stepWizard .createNav .step .triangle_border_right span{display:block;width:0;height:0;border-width:20px 0 20px 18px;border-style:solid;border-color:transparent transparent transparent #e8edf2;position:absolute;top:-20px;left:-20px}.stepWizard .createNav .step.active .triangle_border_right{width:0;height:0;border-width:20px 0 20px 20px;border-color:transparent transparent transparent #e8edf2}.stepWizard .createNav .step.active .triangle_border_right span{border-width:20px 0 20px 20px;border-color:transparent transparent transparent #346180!important}.stepWizard .content{flex:1;overflow:auto;font-size:.875rem}.stepWizard .content .ps-content{width:inherit;height:inherit}.stepWizard .footBtns{width:100%;display:flex;align-items:center;justify-content:flex-end;padding:10px 1rem;background:#f4f4f4;border-top:1px solid #ddd}"]
            }] }
];
/** @nocollapse */
WizardComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
WizardComponent.propDecorators = {
    clickCancelBtn: [{ type: Output }],
    clickFinishBtn: [{ type: Output }],
    title: [{ type: Input }],
    steps: [{ type: Input }],
    stepContainer: [{ type: ViewChild, args: ['stepContainer', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WizardModule {
    constructor() { }
}
WizardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    WizardComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    PerfectScrollbarModule
                ],
                exports: [WizardComponent]
            },] }
];
/** @nocollapse */
WizardModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ComboService {
    constructor() {
        this.innerData = [];
        this.selected$ = new Subject();
        this.isOpen$ = new BehaviorSubject(false);
        this.data$ = new BehaviorSubject('');
        // initData() {
        //     // this.loadDataTable(this.data || []);
        //     // switch (this.displayType) {
        //     //     case 'TreeList': {
        //     //         this.getData().subscribe(data => this.loadDataTree(data));
        //     //         break;
        //     //     }
        //     //     case 'LIST': {
        //     //         // List
        //     //         this.getData().subscribe(data => this.loadDataTable(data));
        //     //         break;
        //     //     }
        //     //     // case 'LOOKUPLIST': {
        //     //     //     // List
        //     //     //     this.getData().subscribe(data =>
        //     //     //         this.loadLookUpDataTable(data)
        //     //     //     );
        //     //     //     break;
        //     //     // }
        //     //     // case 'LOOKUPTREELIST': {
        //     //     //     // List
        //     //     //     this.getData().subscribe(data => this.loadLookUpDataTree(data));
        //     //     //     break;
        //     //     // }
        //     // }
        // }
        // getData(): Observable<any> {
        //     // if (this.uri) {
        //     //     const params = {};
        //     //     this.showLoading();
        //     //     if (this.comboHttp) {
        //     //         return this.comboHttp.getData(this.uri);
        //     //     } else {
        //     //         return this.http.get(this.uri);
        //     //     }
        //     // } else {
        //         if (this.data) {
        //             return of(this.data);
        //         } else {
        //             return of([]);
        //         }
        //     // }
        // }
        // loadDataTable(data: any) {
        //     if (data instanceof Array) {
        //         this.data = data;
        //     } else {
        //         this.data = data.returnValue;
        //     }
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         // tslint:disable-next-line:triple-equals
        //         return dataArr.find(d => d[this.idField] + '' == val);
        //     });
        //     // this.closeLoading();
        // }
        // loadDataTree(data: any) {
        //     if (data instanceof Array) {
        //         this.data = data;
        //     } else {
        //         this.data = data.returnValue;
        //     }
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         return eachData(dataArr, val, this.idField);
        //         function eachData(paramData, paramVal, idField) {
        //             let rtnData: any = '';
        //             paramData.find(d => {
        //                 // tslint:disable-next-line:triple-equals
        //                 if (d.data[idField] == paramVal) {
        //                     rtnData = d.data;
        //                     return true;
        //                 } else if (d.children && d.children.length) {
        //                     rtnData = eachData(d.children, paramVal, idField);
        //                 } else {
        //                     return false;
        //                 }
        //             });
        //             return rtnData;
        //         }
        //     });
        //     // this.closeLoading();
        // }
        // loadLookUpDataTable(resData: any) {
        //     if (resData.returnValue) {
        //         resData = resData.returnValue;
        //     }
        //     this.columns = resData.columns;
        //     this.pageInfo = resData.pageInfo;
        //     this.data = resData.items;
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         // tslint:disable-next-line: triple-equals
        //         return dataArr.find(d => d[this.idField] + '' == val);
        //     });
        //     this.closeLoading();
        // }
        // loadLookUpDataTree(resData: any) {
        //     if (resData.returnValue) {
        //         resData = resData.returnValue;
        //     }
        //     this.columns = resData.columns;
        //     const treeInfo = resData.treeInfo;
        //     // tslint:disable-next-line: no-string-literal
        //     if (!treeInfo['treeDataIsInit']) {
        //         if (treeInfo.layerType.toLowerCase() === 'pathcode') {
        //             this.data = this.lookupUtils.makeTree(resData.items, treeInfo);
        //         } else {
        //             this.data = this.lookupUtils.makeTreeWithParentID(
        //                 resData.items,
        //                 '',
        //                 `${treeInfo.dataField}.${treeInfo.parentField}`,
        //                 this.idField
        //             );
        //         }
        //     }
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         return eachData(dataArr, val, this.idField);
        //         function eachData(paramData, paramVal, idField) {
        //             let rtnData: any = '';
        //             paramData.find(d => {
        //                 // tslint:disable-next-line:triple-equals
        //                 if (d.data[idField] == paramVal) {
        //                     rtnData = d.data;
        //                     return true;
        //                 } else if (d.children && d.children.length) {
        //                     rtnData = eachData(d.children, paramVal, idField);
        //                 } else {
        //                     return false;
        //                 }
        //             });
        //             return rtnData;
        //         }
        //     });
        //     this.closeLoading();
        // }
        // private showLoading() {
        //     this.loading = this.loadingService.show();
        // }
        // closeLoading() {
        //     if (this.loading) {
        //         this.loading.close();
        //         this.loading = null;
        //     }
        // }
    }
    /**
     * @return {?}
     */
    get data() {
        return this.innerData;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set data(val) {
        this.innerData = val;
        this.data$.next(val);
    }
    // columns: any;
    // injectService() {
    //     if (this.injector && !this.comboHttp) {
    //         this.lookupUtils = this.injector.get(LookupUtils, null);
    //         if (this.displayType.indexOf('LOOKUP') > -1) {
    //             this.comboHttp = this.injector.get(ServerSideToken, null);
    //         } else {
    //             this.comboHttp = this.injector.get(ComboServerSideToken, null);
    //         }
    //     }
    // }
    /**
     * @param {?} value
     * @return {?}
     */
    toBoolean(value) {
        return value != null && `${value}` !== 'false';
    }
    /**
     * @param {?} data
     * @param {?=} index
     * @return {?}
     */
    selectItem(data, index) {
        this.isOpen$.next(false);
        this.selectedValue = data;
        this.selected$.next(this.selectedValue);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    unSelectItem(data) {
        this.selectedValue = null;
        this.selected$.next(null);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    isSelect(id) {
        return false;
    }
    // loadData(data: any, selectValues: string = '', callback) {
    //     if (data) {
    //         if (selectValues) {
    //             if (selectValues.split) {
    //                 // key 是字符串，可能是拼起来的
    //                 const selectedItems = selectValues.split(',').map(val => {
    //                     return callback(data, val);
    //                 });
    //
    //                 this.selections = selectedItems;
    //             } else {
    //                 // key不可split
    //                 this.selections = [selectValues];
    //             }
    //         } else {
    //             this.selections = [];
    //         }
    //         // this.selections$.next(this.selections);
    //         // const _data = this.initData(data);
    //         // this.updateState({...this._state, data: _data});
    //     } else {
    //         // this.updateState({ data: [], selections: [] });
    //     }
    // }
    // filterData(val: string, filed: any = 'text') {
    //     if (val) {
    //         const data = this.data
    //             ? this.data.filter(item => {
    //                 if (item[filed]) {
    //                     return String(item[filed]).indexOf(val) > -1;
    //                 } else if (item.data && item.data[filed]) {
    //                     return String(item.data[filed]).indexOf(val) > -1;
    //                 }
    //               })
    //             : [];
    //         this.data$.next(data);
    //     }
    // }
    /**
     * @return {?}
     */
    getSelected() {
        return this.selectedValue;
    }
    // filterSelections(displayText: string) {
    //     if (displayText && this.selections) {
    //         const selections = displayText
    //             .split(',')
    //             .map(val => {
    //                 return this.selections.find(d => d[this.textField] === val);
    //             })
    //             .filter(val => !!val);
    //         this.selectedValues = this.getValue(this.valueField, selections);
    //         this.selections = selections;
    //     }
    // }
    // clearSelections() {
    //     this.selections = [];
    // }
    /**
     * @param {?} prop
     * @param {?=} selections
     * @return {?}
     */
    getValue(prop, selections) {
        // selections = selections ? selections : this.selections;
        // if (selections && selections.length) {
        //     // if (this.mapFields) {
        //     //     const helpFields = Object.keys(this.mapFields);
        //     //     helpFields.forEach( (f: any) => {
        //     //         if (this.mapFields[f] === prop) {
        //     //             prop = f;
        //     //             return;
        //     //         }
        //     //     });
        //     // }
        //
        //     // if (selections.length === 1) {
        //     //     return this.getValueByObj(prop, selections[0]);
        //     // }
        //
        //     const tmp = selections
        //         .map(item => {
        //             return this.getValueByObj(prop, item);
        //         })
        //         .join(',');
        //     return tmp;
        // }
        if (this.selectedValue) {
            return this.getValueByObj(prop, this.selectedValue);
        }
        return '';
    }
    /**
     * @param {?} field
     * @param {?} data
     * @return {?}
     */
    getValueByObj(field, data) {
        if (!data) {
            return '';
        }
        /** @type {?} */
        let resultVal = '';
        if (field.indexOf('.') === -1) {
            resultVal = data[field];
        }
        else {
            resultVal = field.split('.').reduce((obj, key) => {
                if (obj) {
                    return obj[key];
                }
                else {
                    return null;
                }
            }, data);
        }
        return resultVal;
    }
}
ComboService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextUniqueId = 0;
class ComboListComponent {
    /**
     * @param {?} el
     * @param {?} cdr
     * @param {?} document
     * @param {?} render
     * @param {?} comboService
     * @param {?} injector
     */
    constructor(el, cdr, document, render, comboService, injector) {
        this.el = el;
        this.cdr = cdr;
        this.document = document;
        this.render = render;
        this.comboService = comboService;
        this.injector = injector;
        this.disabled = false;
        this.readonly = false;
        this.editable = true;
        this.placeholder = '请选择';
        this.panelWidth = 300;
        this.panelHeight = 300;
        this.autoWidth = true;
        this.enableClear = true;
        this.showPanel = new EventEmitter();
        this.hidePanel = new EventEmitter();
        this.clear = new EventEmitter();
        this.valueChange = new EventEmitter();
        this.selectChange = new EventEmitter();
        // tslint:disable-next-line:variable-name
        this._cmbPanel = null;
        this.isOpen = false;
        this.groupIcon = '<span class="f-icon f-icon-arrow-60-down"></span>';
        this.comboPanelCreated$ = new Subject();
        this.destroy$ = new Subject();
        this.ngControl = null;
        this.displayText = '';
        this.onChange = () => null;
        this.onTouched = () => null;
        /** @type {?} */
        const container = this.creatContainer();
        /** @type {?} */
        const panel = this.creatPanel(container);
        this.comboPanelCreated$
            .pipe(takeUntil(this.destroy$), filter(v => !!v))
            .subscribe((cmp) => {
            panel.appendChild(cmp.nativeElement);
            this.updatePosition();
        });
        this.destroy$.subscribe(() => {
            // this.render.removeChild('body', container);
            if (document.body.contains(container) && container.contains(panel)) {
                container.removeChild(panel);
            }
            nextUniqueId = 0;
        });
        this.comboService.isOpen$
            .pipe(takeUntil(this.destroy$), skip(1))
            .subscribe(val => {
            if (val) {
                this.documentClickEvent = this.render.listen('document', 'click', (event) => {
                    if (!this.el.nativeElement.contains(event.target) &&
                        (this._cmbPanel && !this.contains(this._cmbPanel, event))) {
                        this.isOpen = false;
                        this.removeDocumentListener();
                        this.cdr.markForCheck();
                    }
                });
            }
            else {
                this.removeDocumentListener();
            }
            this.isOpen = !!val;
            this.cdr.markForCheck();
        });
        this.comboService.selected$.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.displayText = this.comboService.getValue(this.textField);
            this.value = this.comboService.getValue(this.idField);
            if (this.data && this.data.length > 0) {
                this.onChange(this.value);
                this.valueChange.emit(this.value);
            }
            else {
                this.updateMappingFieldValue();
                this.onChange(this.displayText);
                this.valueChange.emit(this.displayText);
            }
            this.cdr.detectChanges();
            // this.focus();
            // this.blur();
        });
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set idField(val) {
        this.comboService.idField = val;
    }
    /**
     * @return {?}
     */
    get idField() {
        return this.comboService.idField;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set valueField(val) {
        this.comboService.valueField = val;
    }
    /**
     * @return {?}
     */
    get valueField() {
        return this.comboService.valueField;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set textField(val) {
        this.comboService.textField = val;
    }
    /**
     * @return {?}
     */
    get textField() {
        return this.comboService.textField;
    }
    /**
     * @param {?} cmp
     * @return {?}
     */
    set cmbPanel(cmp) {
        this._cmbPanel = cmp;
        this.comboPanelCreated$.next(cmp);
    }
    /**
     * @return {?}
     */
    onClick() {
        this.comboService.isOpen$.next(!this.isOpen);
    }
    /**
     * @private
     * @return {?}
     */
    removeDocumentListener() {
        if (this.documentClickEvent) {
            this.documentClickEvent();
            this.documentClickEvent = null;
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onBlur(e) {
        this.onTouched();
    }
    /**
     * @return {?}
     */
    blur() {
        this.input.textbox.nativeElement.blur();
    }
    /**
     * @return {?}
     */
    focus() {
        this.input.textbox.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    onClear() {
        this.value = '';
        this.comboService.selectedValue = null;
        this.comboService.isOpen$.next(false);
        this.comboService.selected$.next([]);
        // this.updateMappingFieldValue();
        // this.onChange('');
        // this.onTouched();
        this.clear.emit();
    }
    /**
     * @return {?}
     */
    updateMappingFieldValue() {
        if (this.ngControl &&
            this.ngControl.formDirective &&
            this.ngControl.formDirective.form &&
            this.ngControl.formDirective.form.bindingData) {
            /** @type {?} */
            const bindingData = this.ngControl.formDirective.form.bindingData;
            /** @type {?} */
            const bindingPath = this.ngControl.formDirective.form.bindingPath;
            /** @type {?} */
            let pathArr = [];
            if (bindingPath) {
                pathArr = bindingPath.split('/').filter(n => n !== '');
            }
            this.mappingField = this.mappingField ? this.mappingField : '';
            bindingData.setValue(pathArr.concat(this.mappingField.split('.')), this.value, true, true);
        }
    }
    /**
     * @return {?}
     */
    updateSelectedValues() {
        if (this.ngControl &&
            this.ngControl.formDirective &&
            this.ngControl.formDirective.form &&
            this.ngControl.formDirective.form.bindingData) {
            /** @type {?} */
            const bindingData = this.ngControl.formDirective.form.bindingData;
            /** @type {?} */
            const bindingPath = this.ngControl.formDirective.form.bindingPath;
            /** @type {?} */
            let pathArr = [];
            if (bindingPath) {
                pathArr = bindingPath.split('/').filter(n => n !== '');
            }
            this.mappingField = this.mappingField ? this.mappingField : '';
            this.value = bindingData.getValue(pathArr.concat(this.mappingField.split('.')));
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    onValueChange(val) {
        this.value = val;
        this.onChange(val);
        this.valueChange.emit(val);
        // if (!this.multiSelect) {
        //     this.comboService.serachValue$.next(val);
        // }
        // this.comboService.filterSelections(val);
        // this.valueChange.emit(val);
        // if (!this.uri && this.data && this.data.length > 0) {
        //     this.onChange(this.selectedValues);
        // } else {
        //     this.onChange(this.displayText);
        // }
        // this.updateMappingFieldValue();
    }
    /**
     * @return {?}
     */
    updatePosition() {
        if (this.autoWidth) {
            const { width } = this.input.el.nativeElement.getBoundingClientRect();
            this.panelWidth = width ? width : this.panelWidth;
        }
        let { left, top } = this.el.nativeElement.getBoundingClientRect();
        if (top + this.panelHeight > window.innerHeight && top - this.panelHeight > 0) {
            top = top - this.panelHeight - 27;
        }
        return {
            left: left + 'px',
            top: top + 27 + 'px',
            width: this.panelWidth + 'px',
            height: this.panelHeight + 'px'
        };
    }
    /**
     * @param {?} el
     * @param {?} event
     * @return {?}
     */
    contains(el, event) {
        return el.nativeElement.contains(event.target);
    }
    /**
     * @return {?}
     */
    creatContainer() {
        /** @type {?} */
        let container = this.document.querySelector('.overlay-container');
        if (!container) {
            container = this.document.createElement('div');
            container.classList.add('overlay-container');
        }
        this.document.body.appendChild(container);
        return container;
    }
    /**
     * @param {?} host
     * @return {?}
     */
    creatPanel(host) {
        /** @type {?} */
        const pane = this.document.createElement('div');
        pane.id = `overlay-${nextUniqueId++}`;
        pane.classList.add('overlay-pane');
        host.appendChild(pane);
        return pane;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.displayText = value;
        this.cdr.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // tslint:disable-next-line: deprecation
        this.ngControl = this.injector.get(NgControl, null);
        if (!this.valueField && this.idField) {
            this.valueField = this.idField;
        }
        fromEvent$1(window, 'resize')
            .pipe(debounceTime(100), throttle(ev => interval(100)), takeUntil(this.destroy$))
            .subscribe(() => {
            const { width } = this.input.el.nativeElement.getBoundingClientRect();
            this.panelWidth = width;
            this.comboService.isOpen$.next(false);
        });
        // this.comboService.injectService();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onSelect(value) {
        const { data, index } = Object.assign({}, value);
        this.comboService.selectItem(data, index);
        this.selectChange.emit({ data, index });
        this.focus();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onUnSelected(value) {
        const { data } = Object.assign({}, value);
        this.comboService.unSelectItem(data);
        // console.log(data);
        this.focus();
    }
}
ComboListComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'farris-editable-combo-list',
                template: "<input-group\r\n    #input\r\n    [class.actived]=\"isOpen\"\r\n    [(value)]=\"displayText\"\r\n    [disabled]=\"disabled\"\r\n    [readonly]=\"readonly\"\r\n    [editable]=\"editable\"\r\n    [groupText]=\"groupIcon\"\r\n    [placeholder]=\"placeholder\"\r\n    [enableClear] = \"false\"\r\n    (clickHandle)=\"onClick()\"\r\n    (blurHandle)=\"onBlur($event)\"\r\n    (valueChange)=\"onValueChange($event)\"\r\n    (clear)=\"onClear()\"\r\n    style=\"display: block;\"\r\n>\r\n</input-group>\r\n<div class=\"comboPanel\" *ngIf=\"isOpen\" [ngStyle]=\"updatePosition()\" #comboPanel>\r\n    <farris-datalist\r\n        #dl\r\n        [data]=\"data\"\r\n        [idField]=\"idField\"\r\n        [valueField]=\"valueField\"\r\n        [textField]=\"textField\"\r\n        (selected)=\"onSelect($event)\"\r\n        (unSelected)=\"onUnSelected($event)\"\r\n    >\r\n<!--        <ng-template list-item-tmp let-item=\"data.data\" let-idx=\"index\" *ngIf=\"itemTemplate\">-->\r\n<!--            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: idx }\"> </ng-container>-->\r\n<!--        </ng-template>-->\r\n    </farris-datalist>\r\n</div>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => ComboListComponent),
                        multi: true
                    },
                    ComboService
                ],
                styles: [".overlay-container{position:fixed;z-index:9999;pointer-events:none;top:0;left:0;height:100%;width:100%}.overlay-pane{position:absolute;pointer-events:auto}.overlay-pane .comboPanel{position:absolute;overflow:auto;background:#fff;z-index:9;margin-top:-1px;box-shadow:0 2px 8px 0 rgba(0,0,0,.15);border-radius:2px}.overlay-pane .comboPanel combo2-list{position:absolute;width:100%;height:100%}"]
            }] }
];
/** @nocollapse */
ComboListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: ComboService },
    { type: Injector }
];
ComboListComponent.propDecorators = {
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    editable: [{ type: Input }],
    placeholder: [{ type: Input }],
    panelWidth: [{ type: Input }],
    panelHeight: [{ type: Input }],
    autoWidth: [{ type: Input }],
    enableClear: [{ type: Input }],
    mappingField: [{ type: Input }],
    data: [{ type: Input }],
    idField: [{ type: Input }],
    valueField: [{ type: Input }],
    textField: [{ type: Input }],
    showPanel: [{ type: Output }],
    hidePanel: [{ type: Output }],
    clear: [{ type: Output }],
    valueChange: [{ type: Output }],
    selectChange: [{ type: Output }],
    cmbPanel: [{ type: ViewChild, args: ['comboPanel',] }],
    input: [{ type: ViewChild, args: ['input',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ComboListModule$1 {
}
ComboListModule$1.decorators = [
    { type: NgModule, args: [{
                declarations: [ComboListComponent],
                imports: [CommonModule, FormsModule, InputGroupModule, DatalistModule],
                exports: [ComboListComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the Popover directive.
 * You can inject this service, typically in your root component, and customize
 * the values of its properties in order to provide default values for all the
 * popovers used in the application.
 */
class PopoverConfig {
    constructor() {
        /**
         * Placement of a popover. Accepts: "top", "bottom", "left", "right", "auto"
         */
        this.placement = 'top';
        /**
         * Specifies events that should trigger. Supports a space separated list of
         * event names.
         */
        this.triggers = 'click';
        this.outsideClick = false;
    }
}
PopoverConfig.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ PopoverConfig.ngInjectableDef = defineInjectable({ factory: function PopoverConfig_Factory() { return new PopoverConfig(); }, token: PopoverConfig, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverContainerComponent {
    /**
     * @param {?} config
     */
    constructor(config) {
        Object.assign(this, config);
    }
    /**
     * @return {?}
     */
    get isBs3() {
        return isBs3();
    }
}
PopoverContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'popover-container',
                changeDetection: ChangeDetectionStrategy.OnPush,
                // tslint:disable-next-line
                host: {
                    '[class]': '"popover in popover-" + placement + " " + "bs-popover-" + placement + " " + placement + " " + containerClass',
                    '[class.show]': '!isBs3',
                    role: 'tooltip',
                    style: 'display:block;'
                },
                template: "<div class=\"popover-arrow arrow\"></div>\r\n<div class=\"popover-title popover-header\" *ngIf=\"title\" style=\"padding: 8px;line-height: 16px;\">{{ title }}</div>\r\n<div class=\"popover-content popover-body\">\r\n  <ng-content></ng-content>\r\n</div>",
                styles: [`
    :host.bs-popover-top .arrow, :host.bs-popover-bottom .arrow {
      left: 50%;
      margin-left: -8px;
    }
    :host.bs-popover-left .arrow, :host.bs-popover-right .arrow {
      top: 50%;
      margin-top: -8px;
    }
  `]
            }] }
];
/** @nocollapse */
PopoverContainerComponent.ctorParameters = () => [
    { type: PopoverConfig }
];
PopoverContainerComponent.propDecorators = {
    placement: [{ type: Input }],
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A lightweight, extensible directive for fancy popover creation.
 */
class PopoverDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} _viewContainerRef
     * @param {?} _config
     * @param {?} cis
     */
    constructor(_elementRef, _renderer, _viewContainerRef, _config, cis) {
        /**
         * Close popover on outside click
         */
        this.outsideClick = false;
        /**
         * Css class for popover container
         */
        this.containerClass = '';
        this._isInited = false;
        this._popover = cis
            .createLoader(_elementRef, _viewContainerRef, _renderer)
            .provide({ provide: PopoverConfig, useValue: _config });
        Object.assign(this, _config);
        this.onShown = this._popover.onShown;
        this.onHidden = this._popover.onHidden;
        // fix: no focus on button on Mac OS #1795
        if (typeof window !== 'undefined') {
            _elementRef.nativeElement.addEventListener('click', function () {
                try {
                    _elementRef.nativeElement.focus();
                }
                catch (err) {
                    return;
                }
            });
        }
    }
    /**
     * Returns whether or not the popover is currently being shown
     * @return {?}
     */
    get isOpen() {
        return this._popover.isShown;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        if (value) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    show() {
        if (this._popover.isShown || !this.popover) {
            return;
        }
        this._popover
            .attach(PopoverContainerComponent)
            .to(this.container)
            .position({ attachment: this.placement })
            .show({
            content: this.popover,
            context: this.popoverContext,
            placement: this.placement,
            title: this.popoverTitle,
            containerClass: this.containerClass
        });
        this.isOpen = true;
    }
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    hide() {
        if (this.isOpen) {
            this._popover.hide();
            this.isOpen = false;
        }
    }
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    toggle() {
        if (this.isOpen) {
            return this.hide();
        }
        this.show();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // fix: seems there are an issue with `routerLinkActive`
        // which result in duplicated call ngOnInit without call to ngOnDestroy
        // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
        if (this._isInited) {
            return;
        }
        this._isInited = true;
        this._popover.listen({
            triggers: this.triggers,
            outsideClick: this.outsideClick,
            show: () => this.show()
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._popover.dispose();
    }
}
PopoverDirective.decorators = [
    { type: Directive, args: [{ selector: '[popover]', exportAs: 'bs-popover' },] }
];
/** @nocollapse */
PopoverDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: PopoverConfig },
    { type: ComponentLoaderFactory }
];
PopoverDirective.propDecorators = {
    popover: [{ type: Input }],
    popoverContext: [{ type: Input }],
    popoverTitle: [{ type: Input }],
    placement: [{ type: Input }],
    outsideClick: [{ type: Input }],
    triggers: [{ type: Input }],
    container: [{ type: Input }],
    containerClass: [{ type: Input }],
    isOpen: [{ type: Input }],
    onShown: [{ type: Output }],
    onHidden: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: PopoverModule,
            providers: [PopoverConfig]
        };
    }
}
PopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [PopoverDirective, PopoverContainerComponent],
                exports: [PopoverDirective],
                // providers: [PopoverConfig, ComponentLoaderFactory, PositioningService],
                entryComponents: [PopoverContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const PropertyType = {
    string: 'string',
    boolean: 'boolean',
    number: 'number',
    select: 'select',
    boolOrExp: 'boolOrExp',
    multiSelect: 'multiSelect',
    date: 'date',
    datetime: 'datetime',
    modal: 'modal',
    cascade: 'cascade',
};
/**
 * 属性分类实体
 */
class ElementPropertyConfig {
    constructor() {
        /**
         * 分类是否隐藏，默认false
         */
        this.hide = false;
        /**
         * 是否隐藏分类标题
         */
        this.hideTitle = false;
        /**
         * 是否启用级联特性，默认false
         */
        this.enableCascade = false;
    }
}
/**
 * 属性实体
 */
class PropertyEntity {
    constructor() {
        /**
         * 是否只读，默认false
         */
        this.readonly = false;
        /**
         * 是否可见，默认true
         */
        this.visible = true;
        /**
         * 是否大数字
         */
        this.isBigNumber = false;
        /**
         * 属性改变后是否需要刷新整个面板：用于更改其他分类下的属性
         */
        this.refreshPanelAfterChanged = false;
        /**
         * 下拉多选类型：属性值的类型：string(多值以逗号分隔)/array(多值组装成数组)
         */
        this.multiSelectDataType = 'string';
        /**
         * 级联属性是否默认收起
         */
        this.isExpand = false;
        /**
         * 是否隐藏级联属性的头部
         */
        this.hideCascadeTitle = false;
        /**
         * 模态框属性是否展示清除图标
         */
        this.showClearButton = false;
    }
    /**
     * 打开模态框前的方法，一般用于校验逻辑，返回值中result=true，则进一步打开模态框，result=false则提示message内容，并不再打开模态框。
     * @return {?}
     */
    beforeOpenModal() {
        return new BeforeOpenModalResult();
    }
}
/**
 * 打开模态框前的方法返回值，result=true，则进一步打开模态框，result=false则提示message内容，并不再打开模态框。
 */
class BeforeOpenModalResult {
}
/**
 * 属性变更集
 */
class PropertyChangeObject {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyItemComponent {
    /**
     * @param {?} resolver
     * @param {?} modalService
     * @param {?} injector
     * @param {?} notifyServ
     * @param {?} el
     */
    constructor(resolver, modalService, injector, notifyServ, el) {
        this.resolver = resolver;
        this.modalService = modalService;
        this.injector = injector;
        this.notifyServ = notifyServ;
        this.el = el;
        this.valueChanged = new EventEmitter();
        this.submitModal = new EventEmitter();
        // 向上触发整体面板刷新
        this.triggerRefreshPanel = new EventEmitter();
        // 下拉框的枚举项
        this.selectOptions = [];
        // 控件类型
        this.itemType = 'string';
        // 数字控件精度
        this.precision = 2;
        // 已废弃
        this.showClearButton = false;
        // 默认值
        this.showDefaultValue = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.refresh();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // this.refresh();
    }
    /**
     * @return {?}
     */
    refresh() {
        /** @type {?} */
        let tmpl;
        // 显示格式
        /** @type {?} */
        const propertyType = this.itemType = this.elementConfig.propertyType;
        switch (propertyType) {
            case 'boolean': {
                this.itemType = 'select';
                this.selectOptions = [{ key: true, value: 'true' }, { key: false, value: 'false' }];
                tmpl = this.selectTmpl;
                break;
            }
            case 'select': {
                this.selectOptions = this.elementConfig.iterator || [];
                tmpl = this.selectTmpl;
                break;
            }
            case 'multiSelect': {
                this.selectOptions = this.elementConfig.iterator || [];
                if (this.elementConfig.multiSelectDataType === 'array') {
                    this.elementValue = this.elementValue ? this.elementValue.toString() : '';
                }
                tmpl = this.multiSelectTmpl;
                break;
            }
            case 'modal': {
                this._convertModalShowValue(this.elementValue);
                tmpl = this.modalTmpl;
                break;
            }
            case 'number': {
                this.precision = this.elementConfig.decimals === undefined ? 2 : this.elementConfig.decimals;
                tmpl = this.numberTmpl;
                break;
            }
            case 'string': {
                if (this.elementConfig.readonly) {
                    this._convertModalShowValue(this.elementValue);
                }
                tmpl = this.stringTmpl;
                break;
            }
            case 'boolOrExp': {
                this.selectOptions = [{ key: true, value: 'true' }, { key: false, value: 'false' }];
                tmpl = this.boolOrExpTmpl;
                break;
            }
            case 'date': {
                tmpl = this.dateTmpl;
                break;
            }
            case 'datetime': {
                tmpl = this.datetimeTmpl;
                break;
            }
        }
        // 默认值
        if (Object.keys(this.elementConfig).indexOf('defaultValue') > -1) {
            if (this.elementValue === undefined || this.elementValue === null) {
                this.elementValue = this.elementConfig.defaultValue;
            }
            this.showDefaultValue = true;
        }
        // 是否显示
        if (Object.keys(this.elementConfig).indexOf('visible') < 0) {
            this.elementConfig.visible = true;
        }
        // 创建模板
        if (tmpl && (this.propItem.length === 0 || this.propertyOldType !== this.itemType)) {
            this.propItem.clear();
            this.propItem.createEmbeddedView(tmpl);
            this.propertyOldType = this.itemType;
        }
    }
    /**
     * 鼠标移入 --已废弃
     * @return {?}
     */
    onmouseover() {
        if (!this.elementConfig.showClearButton) {
            return;
        }
        if (!this.showClearButton) {
            this.showClearButton = true;
        }
    }
    /**
     * 鼠标离开 --已废弃
     * @return {?}
     */
    onmouseleave() {
        if (!this.elementConfig.showClearButton) {
            return;
        }
        this.showClearButton = false;
    }
    /**
     * 清除模态框内容
     * @return {?}
     */
    modalClear() {
        // 数据转换
        this._convertModalShowValue(null);
        // 若有清除后事件，先执行方法
        if (Object.keys(this.elementConfig).indexOf('afterClickClearButton') > -1 &&
            typeof (this.elementConfig.afterClickClearButton) === 'function') {
            this.elementConfig.afterClickClearButton(this.elementValue);
        }
        /** @type {?} */
        const changeObject = {
            propertyID: this.elementConfig.propertyID,
            propertyValue: null
        };
        this.submitModal.emit({ changeObject, parameters: null });
    }
    /**
     * 变更属性值
     * @param {?} e
     * @return {?}
     */
    changeValue(e) {
        /** @type {?} */
        let value = this.elementValue;
        // 文本控件限制输入字符
        if (value && this.elementConfig.propertyType === 'string' && !this.elementConfig.readonly &&
            this.elementConfig.notAllowedChars && this.elementConfig.notAllowedChars.length) {
            this.elementConfig.notAllowedChars.forEach((c) => {
                if (typeof (c) === 'object') {
                    value = value.replace(c, '');
                }
                else if (typeof (c) === 'string') {
                    value = value.replace(new RegExp(c, 'g'), '');
                }
            });
            this.elementValue = value;
        }
        // 多选控件返回数组格式的数据
        if (this.itemType === 'multiSelect' && this.elementConfig.multiSelectDataType === 'array') {
            value = this.elementValue ? this.elementValue.split(',') : '';
        }
        /** @type {?} */
        const changeObject = {
            propertyID: this.elementConfig.propertyID,
            propertyValue: value
        };
        this.valueChanged.emit({ changeObject });
        if (this.elementConfig.refreshPanelAfterChanged) {
            this.triggerRefreshPanel.emit();
        }
    }
    /**
     * farris 日期控件的变更事件
     * @param {?} e e
     * @return {?}
     */
    changeDateValue(e) {
        /** @type {?} */
        const value = e.formatted;
        /** @type {?} */
        const changeObject = {
            propertyID: this.elementConfig.propertyID,
            propertyValue: value
        };
        this.valueChanged.emit({ changeObject });
        if (this.elementConfig.refreshPanelAfterChanged) {
            this.triggerRefreshPanel.emit();
        }
    }
    /**
     * 自定义编辑器使用模态框打开
     * @return {?}
     */
    openModal() {
        if (this.elementConfig.readonly) {
            return;
        }
        if (Object.keys(this.elementConfig).indexOf('beforeOpenModal') > -1 && typeof (this.elementConfig.beforeOpenModal) === 'function') {
            /** @type {?} */
            const result = this.elementConfig.beforeOpenModal();
            if (result && !result.result) {
                this.notifyServ.warning((/** @type {?} */ ({
                    title: '系统提示', msg: result.message, timeout: 3000
                })));
                return;
            }
        }
        this.createEditorComponent();
    }
    /**
     * 创建自定义编辑器
     * @private
     * @return {?}
     */
    createEditorComponent() {
        /** @type {?} */
        const editor = this.elementConfig.editor;
        if (!editor) {
            return;
        }
        // 创建模态框组件
        /** @type {?} */
        const compFactory = this.resolver.resolveComponentFactory(editor);
        /** @type {?} */
        const compRef = compFactory.create(this.injector);
        compRef.instance.value = this.elementValue;
        if (this.elementConfig.editorParams) { // 编辑器需要的额外参数
            compRef.instance.editorParams = this.elementConfig.editorParams;
        }
        /** @type {?} */
        let modalConfig = compRef.instance.modalConfig;
        if (!modalConfig) {
            modalConfig = {
                title: '属性配置',
                width: 800,
                height: 400,
                showButtons: false
            };
        }
        else if (modalConfig.showButtons) {
            modalConfig.buttons = compRef.instance.modalFooter;
        }
        /** @type {?} */
        const dialog = this.modalService.show(compRef, modalConfig);
        // 监听关闭模态框
        if (compRef.instance.closeModal && compRef.instance.closeModal instanceof EventEmitter) {
            compRef.instance.closeModal.subscribe((data) => {
                // 数据转换
                if (data) {
                    this._convertModalShowValue(data);
                    /** @type {?} */
                    const changeObject = {
                        propertyID: this.elementConfig.propertyID,
                        propertyValue: data
                    };
                    this.valueChanged.emit({ changeObject });
                }
                dialog.close();
            });
        }
        // 弹出框关闭事件，带参数，格式为{ value, parameters }
        if (compRef.instance.submitModal && compRef.instance.submitModal instanceof EventEmitter) {
            compRef.instance.submitModal.subscribe(data => {
                if (!data) {
                    dialog.close();
                    return;
                }
                const { value, parameters } = data;
                // 数据转换
                this._convertModalShowValue(value);
                /** @type {?} */
                const changeObject = {
                    propertyID: this.elementConfig.propertyID,
                    propertyValue: value
                };
                this.submitModal.emit({ changeObject, parameters });
                dialog.close();
            });
        }
    }
    /**
     * 模态框场景下将属性值转换为输入框中显示的值
     * @private
     * @param {?} value
     * @return {?}
     */
    _convertModalShowValue(value) {
        if (this.elementConfig.converter) {
            this.elementShowValue = this.elementConfig.converter.convertTo(value);
            return;
        }
        if (value && value instanceof Object) {
            this.elementShowValue = JSON.stringify(value);
            return;
        }
        this.elementShowValue = value;
    }
}
PropertyItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'webide-property-item',
                template: "<div class=\"farris-group-wrap property-item\" [hidden]=\"!elementConfig.visible\">\r\n  <div class=\"form-group farris-form-group\">\r\n    <label class=\"col-form-label\">\r\n      <span class=\"farris-label-text\" [popover]=\"popTemplate\" [popoverTitle]=\"elementConfig.propertyName\"\r\n        container=\"body\" placement=\"left\" triggers=\"hover\">{{elementConfig.propertyName}}</span>\r\n    </label>\r\n    <!-- <label class=\"col-form-label\">\r\n      <span class=\"farris-label-text\" farrisPopover [popover]=\"popTemplate\" container=\"body\"\r\n        triggers=\"hover\">{{elementConfig.propertyName}}</span>\r\n    </label> -->\r\n    <!-- <label class=\"col-form-label\">\r\n      <span class=\"farris-label-text\">{{elementConfig.propertyName}}</span>\r\n    </label> -->\r\n\r\n\r\n    <ng-container #propItem> </ng-container>\r\n\r\n    <!--\u6587\u672C-->\r\n    <ng-template #stringTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <input type=\"input\" class=\"form-control form-control-sm\" [(ngModel)]=\"elementValue\" (blur)=\"changeValue($event)\"\r\n          *ngIf=\"!elementConfig.readonly\">\r\n        <input type=\"input\" class=\"form-control form-control-sm\" [(ngModel)]=\"elementShowValue\" [readonly]=\"'readonly'\"\r\n          *ngIf=\"elementConfig.readonly\">\r\n      </div>\r\n    </ng-template>\r\n\r\n    <ng-template #numberTmpl>\r\n      <!-- \u6570\u5B57-->\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-number-spinner [(ngModel)]=\"elementValue\" [readonly]=\"elementConfig.readonly\" [precision]=\"precision\"\r\n          [autoDecimal]=\"true\" [min]=\"elementConfig.min\" [max]=\"elementConfig.max\" [canNull]=\"true\"\r\n          [bigNumber]=\"elementConfig.isBigNumber\" (ngModelChange)=\"changeValue($event)\">\r\n        </farris-number-spinner>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u4E0B\u62C9\u5217\u8868-->\r\n    <ng-template #selectTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-combo-list [(ngModel)]=\"elementValue\" [idField]=\"'key'\" [textField]=\"'value'\" [data]=\"selectOptions\"\r\n          [readonly]=\"elementConfig.readonly\" [editable]=\"false\" [enableClear]=\"false\" [enableCancelSelected]=\"false\"\r\n          (valueChange)=\"changeValue($event)\">\r\n        </farris-combo-list>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u53EF\u7F16\u8F91\u7684\u4E0B\u62C9\u5217\u8868\uFF08\u6B64\u5904\u662F\u6539\u52A8\u540E\u7684farris combolist\uFF0Cfarris combolist\uFF09-->\r\n    <ng-template #boolOrExpTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-editable-combo-list [data]=\"selectOptions\" textField=\"value\" idField=\"key\" [(ngModel)]=\"elementValue\"\r\n          (valueChange)=\"changeValue($event)\" [editable]=\"true\" [readonly]=\"elementConfig.readonly?true:false\">\r\n        </farris-editable-combo-list>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u4E0B\u62C9\u591A\u9009-->\r\n    <ng-template #multiSelectTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-combo-list [(ngModel)]=\"elementValue\" [idField]=\"'key'\" [textField]=\"'value'\" [data]=\"selectOptions\"\r\n          [readonly]=\"elementConfig.readonly\" [editable]=\"false\" [multiSelect]=\"true\" [enableClear]=\"false\"\r\n          (ngModelChange)=\"changeValue($event)\">\r\n        </farris-combo-list>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u65E5\u671F-->\r\n    <ng-template #dateTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-datepicker [(ngModel)]=\"elementValue\" [editable]=\"false\" [showTime]=\"false\" [dateFormat]=\"'yyyy-MM-dd'\"\r\n          [readonly]=\"elementConfig.readonly\" (valueChange)=\"changeDateValue($event)\" [returnType]=\"'string'\"\r\n          [maxDate]=\"elementConfig.max\" [minDate]=\"elementConfig.min\">\r\n        </farris-datepicker>\r\n      </div>\r\n    </ng-template>\r\n\r\n\r\n    <!-- \u65E5\u671F\u65F6\u95F4 -->\r\n    <ng-template #datetimeTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-datepicker [(ngModel)]=\"elementValue\" [editable]=\"false\" [showTime]=\"true\"\r\n          [dateFormat]=\"'yyyy-MM-dd HH:mm:ss'\" [readonly]=\"elementConfig.readonly\"\r\n          (valueChange)=\"changeDateValue($event)\" [returnType]=\"'string'\" [maxDate]=\"elementConfig.max\"\r\n          [minDate]=\"elementConfig.min\">\r\n        </farris-datepicker>\r\n      </div>\r\n    </ng-template>\r\n\r\n\r\n    <!-- \u6A21\u6001\u6846 -->\r\n    <ng-template #modalTmpl>\r\n      <div class=\"farris-input-wrap modalIcon\">\r\n        <input type=\"input\" class=\"form-control form-control-sm\" [(ngModel)]=\"elementShowValue\" readonly>\r\n        <span *ngIf=\"elementConfig.showClearButton && !elementConfig.readonly\" class=\"showClearButton\"\r\n          (click)=\"modalClear()\">\r\n          <i class=\"material-icons clearIcon\">close</i>\r\n        </span>\r\n        <i class=\"material-icons moreIcon\" (click)=\"openModal()\">filter_none</i>\r\n      </div>\r\n    </ng-template>\r\n\r\n  </div>\r\n</div>\r\n\r\n\r\n<ng-template #popTemplate>\r\n  <div *ngIf=\"elementConfig.propertyID\">\r\n    <span>\u7F16\u53F7\uFF1A </span> {{elementConfig.propertyID}}</div>\r\n  <div *ngIf=\"elementConfig.description\">\r\n    <span>\u63CF\u8FF0\uFF1A </span> {{elementConfig.description}}</div>\r\n</ng-template>",
                styles: [".property-item .form-group{margin-bottom:2px}.property-item .modalIcon .showClearButton{display:none}.property-item .modalIcon:hover .showClearButton{display:block}.property-item .modalIcon input{padding-right:30px}.property-item .modalIcon .moreIcon{position:absolute;top:6px;right:6px;cursor:pointer;font-size:16px;color:#758a96}.property-item .modalIcon .clearIcon{position:absolute;top:5px;right:30px;cursor:pointer;font-size:19px;color:#758a96}.property-item .form-control[readonly]{background-color:#fff}.property-item .form-control:disabled,.property-item .form-control[readonly]{color:#4b4c4c}"]
            }] }
];
/** @nocollapse */
PropertyItemComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: BsModalService },
    { type: Injector },
    { type: NotifyService },
    { type: ElementRef }
];
PropertyItemComponent.propDecorators = {
    elementConfig: [{ type: Input }],
    elementValue: [{ type: Input }],
    valueChanged: [{ type: Output }],
    submitModal: [{ type: Output }],
    triggerRefreshPanel: [{ type: Output }],
    propItem: [{ type: ViewChild, args: ['propItem', { read: ViewContainerRef },] }],
    stringTmpl: [{ type: ViewChild, args: ['stringTmpl',] }],
    numberTmpl: [{ type: ViewChild, args: ['numberTmpl',] }],
    selectTmpl: [{ type: ViewChild, args: ['selectTmpl',] }],
    boolOrExpTmpl: [{ type: ViewChild, args: ['boolOrExpTmpl',] }],
    multiSelectTmpl: [{ type: ViewChild, args: ['multiSelectTmpl',] }],
    dateTmpl: [{ type: ViewChild, args: ['dateTmpl',] }],
    datetimeTmpl: [{ type: ViewChild, args: ['datetimeTmpl',] }],
    modalTmpl: [{ type: ViewChild, args: ['modalTmpl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyItemListComponent {
    constructor() {
        // 属性值
        this.valueChanged = new EventEmitter();
        this.submitModal = new EventEmitter();
        this.triggerRefreshPanel = new EventEmitter();
    }
    /**
     * @param {?} simpleChanges
     * @return {?}
     */
    ngOnChanges(simpleChanges) {
        // 若分类下有propertyData，则取分类下的propertyData；否则取整体的propertyData
        if (this.category.propertyData && this.category.enableCascade) {
            this.data = this.category.propertyData;
        }
        else {
            this.data = this.propertyData;
        }
        this.adaptProperties();
    }
    /**
     * 适配属性
     * @private
     * @return {?}
     */
    adaptProperties() {
        this.category.properties.forEach(propItem => {
            if (propItem.propertyType === 'cascade') {
                this.cascadeValueStringify(propItem, this.data[propItem.propertyID]);
                if (Object.keys(propItem).indexOf('visible') < 0) {
                    propItem.visible = true;
                }
            }
        });
    }
    /**
     * @return {?}
     */
    refresh() {
        // 若分类下有propertyData，则取分类下的propertyData；否则取整体的propertyData
        if (this.category.propertyData && this.category.enableCascade) {
            this.data = this.category.propertyData;
        }
        else {
            this.data = this.propertyData;
        }
        this.items.forEach(item => item.refresh());
    }
    /**
     * 一般属性变更
     * @param {?} $event
     * @return {?}
     */
    _itemChanged($event) {
        const { changeObject } = $event;
        this.data[changeObject.propertyID] = changeObject.propertyValue;
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data);
            this.items.forEach(item => item.refresh());
        }
        changeObject.categoryId = this.category.categoryId;
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID;
        }
        this.valueChanged.emit(changeObject);
    }
    /**
     * 模态框数据变更（TODO:待优化，合并valueChange事件）
     * @param {?} $event
     * @return {?}
     */
    _submitModal($event) {
        const { changeObject, parameters } = $event;
        this.data[changeObject.propertyID] = changeObject.propertyValue;
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data, parameters);
            this.items.forEach(item => item.refresh());
        }
        changeObject.categoryId = this.category.categoryId;
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID;
        }
        this.submitModal.emit($event);
    }
    /**
     * 级联属性变更
     * @param {?} $event
     * @param {?} propItem
     * @return {?}
     */
    _cascadeitemChanged($event, propItem) {
        /** @type {?} */
        const parentPropertyID = propItem.propertyID;
        if (!parentPropertyID) {
            return;
        }
        const { changeObject } = $event;
        if (!this.data[parentPropertyID]) {
            this.data[parentPropertyID] = {};
        }
        this.data[parentPropertyID][changeObject.propertyID] = changeObject.propertyValue;
        changeObject.categoryId = this.category.categoryId;
        changeObject.parentPropertyID = changeObject.propertyPath = parentPropertyID;
        // 分类启用了级联，并且分类下有级联属性
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID + '.' + changeObject.parentPropertyID;
        }
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data);
            this.items.forEach(item => item.refresh());
        }
        this.cascadeValueStringify(propItem, this.data[parentPropertyID]);
        this.valueChanged.emit(changeObject);
    }
    /**
     * 级联模态框属性变更
     * @param {?} $event
     * @param {?} propItem
     * @return {?}
     */
    __cascadeitemSubmitModal($event, propItem) {
        /** @type {?} */
        const parentPropertyID = propItem.propertyID;
        if (!parentPropertyID) {
            return;
        }
        const { changeObject, parameters } = $event;
        if (!this.data[parentPropertyID]) {
            this.data[parentPropertyID] = {};
        }
        this.data[parentPropertyID][changeObject.propertyID] = changeObject.propertyValue;
        changeObject.categoryId = this.category.categoryId;
        changeObject.parentPropertyID = changeObject.propertyPath = parentPropertyID;
        // 分类启用了级联，并且分类下有级联属性
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID + '.' + changeObject.parentPropertyID;
        }
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data, parameters);
            this.items.forEach(item => item.refresh());
        }
        this.cascadeValueStringify(propItem, this.data[parentPropertyID]);
        this.submitModal.emit($event);
    }
    /**
     * 级联属性的汇总信息
     * @param {?} propItem
     * @param {?} valueObject
     * @return {?}
     */
    cascadeValueStringify(propItem, valueObject) {
        if (!propItem || !propItem.cascadeConfig) {
            return;
        }
        if (!valueObject) {
            propItem.cascadeSummary = '';
            return;
        }
        if (!propItem.cascadeConverter || !propItem.cascadeConverter.convertTo) {
            propItem.cascadeSummary = JSON.stringify(valueObject);
        }
        else {
            propItem.cascadeSummary = propItem.cascadeConverter.convertTo(valueObject, propItem.cascadeConfig);
        }
    }
    /**
     *  已废弃
     * @param {?} propItem
     * @return {?}
     */
    _checkCascadeVisible(propItem) {
        if (Object.keys(propItem).indexOf('visible') < 0) {
            return true;
        }
        else {
            return propItem.visible;
        }
    }
    /**
     * @return {?}
     */
    refreshPanel() {
        this.triggerRefreshPanel.emit();
    }
    /**
     * @param {?} index
     * @param {?} PropItem
     * @return {?}
     */
    trackByPropId(index, PropItem) {
        return PropItem.propertyID;
    }
}
PropertyItemListComponent.decorators = [
    { type: Component, args: [{
                selector: 'webide-property-item-list',
                template: "<div *ngFor=\"let propItem of category.properties; trackBy:trackByPropId\">\r\n    <div *ngIf=\"propItem.propertyType != 'cascade'\" class=\"px-2\">\r\n        <webide-property-item (valueChanged)=\"_itemChanged($event)\" (submitModal)=\"_submitModal($event)\"\r\n            [elementValue]=\"data[propItem.propertyID]\" [elementConfig]=\"propItem\"\r\n            (triggerRefreshPanel)=\"refreshPanel()\"></webide-property-item>\r\n    </div>\r\n\r\n    <div class=\"farris-panel\" *ngIf=\"propItem.propertyType == 'cascade' && propItem.visible\">\r\n        <div class=\"propertyCascadeItem farris-panel-item card\">\r\n            <div class=\"card-header\" (click)=\"propItem.isExpand=!propItem.isExpand\">\r\n                <div class=\"panel-item-title\">\r\n                    <div class=\"form-group farris-form-group\">\r\n                        <div class=\"f-section-formgroup-legend\">\r\n                            <div class=\"f-header px-0  col-form-label\" style=\"font-size: inherit;\">\r\n                                <div class=\"f-title f-utils-fill\">{{propItem.propertyName}}</div>\r\n                                <div class=\"f-toolbar\">\r\n                                    <button class=\"btn f-btn-collapse-expand f-btn-mx\"\r\n                                        [class.f-state-expand]=\"propItem.isExpand\"><span></span></button>\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        <div class=\"farris-input-wrap\" *ngIf=\"!propItem.hideCascadeTitle\">\r\n                            <input type=\"input\" class=\"form-control form-control-sm\" readonly\r\n                                [value]=\"propItem.cascadeSummary\">\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"card-body\" [style.display]=\"propItem.isExpand?'block':'none'\">\r\n                <div *ngFor=\"let cascadeItem of propItem.cascadeConfig\" class=\"px-2\">\r\n                    <webide-property-item (valueChanged)=\"_cascadeitemChanged($event,propItem)\"\r\n                        (submitModal)=\"__cascadeitemSubmitModal($event, propItem)\"\r\n                        [elementValue]=\"data[propItem.propertyID]?data[propItem.propertyID][cascadeItem.propertyID]:''\"\r\n                        [elementConfig]=\"cascadeItem\" (triggerRefreshPanel)=\"refreshPanel()\">\r\n                    </webide-property-item>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n\r\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [".propertyCascadeItem{background-color:transparent!important;border:none!important}.propertyCascadeItem .card-header{background-color:transparent!important;padding:4px 12px!important;color:inherit!important}.propertyCascadeItem .card-header .panel-item-title{width:100%;position:relative;font-size:inherit!important}.propertyCascadeItem .card-header .panel-item-title .farris-input-wrap{margin-left:-5px;margin-right:-5px}.propertyCascadeItem .f-accordion-collapse,.propertyCascadeItem .f-accordion-expand{right:0;left:auto!important;top:6px;color:#6b94ec!important;position:absolute}.propertyCascadeItem .card-body{padding:3px 12px!important;background:rgba(255,255,255,.8);border-radius:8px;margin:4px 8px}"]
            }] }
];
/** @nocollapse */
PropertyItemListComponent.ctorParameters = () => [];
PropertyItemListComponent.propDecorators = {
    category: [{ type: Input }],
    propertyData: [{ type: Input }],
    valueChanged: [{ type: Output }],
    submitModal: [{ type: Output }],
    triggerRefreshPanel: [{ type: Output }],
    items: [{ type: ViewChildren, args: [PropertyItemComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyPanelComponent {
    constructor() {
        /**
         * 是否持有面板的隐藏显示状态
         */
        this.isPersitOpenState = false;
        /**
         * isPersitOpenState=true时，控制面板是否隐藏显示
         */
        this.isShowPanel = false;
        /**
         * isPersitOpenState=true时，抛出面板的关闭事件
         */
        this.closePropertyPanel = new EventEmitter();
        /**
         * 属性值
         */
        this.propertyData = {};
        /**
         * 属性变更事件
         */
        this.propertyChanged = new EventEmitter();
        /**
         * 模态框属性变更事件
         */
        this.submitModal = new EventEmitter();
        /**
         * 是否展示关闭按钮
         */
        this.showCloseBtn = true;
        /**
         * 当前展示状态
         */
        this.isOpen = true;
        /**
         * 外层分类，以标签页形式展示
         */
        this.categoryTabs = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.width) {
            this.eastDiv.nativeElement.style.width = this.width + 'px';
        }
        else {
            this.eastDiv.nativeElement.style.width = 'inherit';
        }
        if (this.height) {
            this.eastDiv.nativeElement.style.height = this.height + 'px';
        }
        else {
            this.eastDiv.nativeElement.style.height = '100%';
        }
        if (this.isPersitOpenState) {
            this.isOpen = this.isShowPanel;
        }
        this.checkShowTabCategory();
    }
    /**
     *  更改面板的隐藏显示状态，只有在isPersitOpenState=true时生效
     * @param {?} simpleChanges
     * @return {?}
     */
    ngOnChanges(simpleChanges) {
        if (simpleChanges.isShowPanel && this.isPersitOpenState) {
            this.isOpen = this.isShowPanel;
        }
        this.checkShowTabCategory();
    }
    /**
     * @return {?}
     */
    refreshPanel() {
        this.checkShowTabCategory();
        this.itemLists.forEach(item => item.refresh());
    }
    /**
     * @param {?} item
     * @return {?}
     */
    changeStatus(item) {
        if (this.propertyConfig.length < 2) {
            return;
        }
        if (!item.status || item.status === 'open') {
            item.status = 'closed';
        }
        else {
            item.status = 'open';
        }
    }
    /**
     *  隐藏面板
     * @return {?}
     */
    collapse() {
        // isPersitOpenState=true时,由外部确定状态
        if (!this.isPersitOpenState) {
            this.isOpen = false;
        }
        this.closePropertyPanel.emit();
    }
    /**
     * 抛出属性变更事件
     * @param {?} changeObject
     * @return {?}
     */
    _valueChanged(changeObject) {
        this.propertyChanged.emit(changeObject);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    _submitModal($event) {
        this.submitModal.emit($event);
    }
    /**
     * 将属性分类按照标签页进行归类
     * @private
     * @return {?}
     */
    checkShowTabCategory() {
        this.categoryTabs = [];
        if (!this.propertyConfig || this.propertyConfig.length === 0) {
            this.categoryTabs = [{
                    tabId: 'default',
                    tabName: '属性',
                    categoryList: []
                }];
            this.selectedTab = null;
            return;
        }
        this.propertyConfig.forEach(config => {
            if (config.tabId) {
                /** @type {?} */
                const propTab = this.categoryTabs.find(t => t.tabId === config.tabId);
                if (!propTab) {
                    this.categoryTabs.push({
                        tabId: config.tabId,
                        tabName: config.tabName,
                        categoryList: [config],
                        hide: config.hide || config.properties.length === 0
                    });
                }
                else {
                    propTab.categoryList.push(config);
                    if (propTab.hide) {
                        propTab.hide = config.hide || config.properties.length === 0;
                    }
                }
            }
            else {
                /** @type {?} */
                const defaultTab = this.categoryTabs.find(t => t.tabId === 'default');
                if (!defaultTab) {
                    this.categoryTabs.push({
                        tabId: 'default',
                        tabName: '属性',
                        categoryList: [config]
                    });
                }
                else {
                    defaultTab.categoryList.push(config);
                }
            }
        });
        this.selectedTab = this.categoryTabs[0];
    }
}
PropertyPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-property-panel',
                template: "<div #east [style.display]=\"isOpen?'block':'none'\">\r\n    <div class=\"propertyPanel panel d-flex flex-column\">\r\n\r\n\r\n        <div class=\"title d-flex\">\r\n            <div class=\"title-label\" *ngFor=\"let tab of categoryTabs\" (click)=\"selectedTab=tab\" [hidden]=\"tab.hide\"\r\n                [class.active]=\"selectedTab && selectedTab.tabId===tab.tabId && categoryTabs.length>1\">\r\n                <span>{{tab.tabName}}</span>\r\n            </div>\r\n            <div class=\"title-actions\">\r\n                <div class=\"monaco-toolbar\">\r\n                    <div class=\"monaco-action-bar animated\">\r\n                        <ul class=\"actions-container\" role=\"toolbar\">\r\n                            <li class=\"action-item\" (click)=\"collapse()\" *ngIf=\"showCloseBtn\">\r\n                                <a class=\"hide-panel\" title=\"\u5173\u95ED\"></a>\r\n                            </li>\r\n                        </ul>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n\r\n        <div #propertyPanel class=\"panel-body\" [style.height]=\"(height - 35) + 'px'\" *ngIf=\"selectedTab\">\r\n            <ul class=\"property-grid\">\r\n                <li *ngFor=\"let category of selectedTab.categoryList\">\r\n                    <ng-container *ngIf=\"!category.hide\">\r\n                        <span *ngIf=\"!category.hideTitle\"\r\n                            [class]=\"category.status === 'closed' ? 'group-label collapse': 'group-label expand' \"\r\n                            (click)=\"changeStatus(category)\">{{ category.categoryName }}</span>\r\n                        <div [style.display]=\"!category.status || category.status === 'open'?'block':'none'\"\r\n                            class=\"py-1 \">\r\n                            <webide-property-item-list [category]=\"category\" [propertyData]=\"propertyData\"\r\n                                (valueChanged)=\"_valueChanged($event)\" (submitModal)=\"_submitModal($event)\"\r\n                                (triggerRefreshPanel)=\"refreshPanel()\"></webide-property-item-list>\r\n                        </div>\r\n                    </ng-container>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n</div>",
                styles: [":host{width:inherit;height:inherit}.propertyPanel{width:100%;height:100%;color:rgba(0,0,0,.75);background:#f3f8ff!important;border-color:#d8dbe2!important}.propertyPanel .title{position:relative;background:#d0d8e9!important;padding-right:40px;flex-wrap:wrap}.propertyPanel .title>.title-label{line-height:34px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-left:12px;padding-right:12px;color:#333;font-size:14px;font-weight:600;cursor:pointer}.propertyPanel .title>.title-label.active{background:#8fb1df!important}.propertyPanel .title .title-actions{padding-left:35px;height:35px;flex:1;box-sizing:border-box;position:absolute;right:10px;top:0}.propertyPanel .property-grid .group-label{line-height:30px;display:block;padding-left:12px;cursor:pointer;background:#e2e9f6!important;color:#34495e!important;font-weight:600!important}.propertyPanel .panel-body{overflow:auto;height:100%}.propertyPanel .property-grid{list-style:none;margin:0;padding:0}.propertyPanel .action-item{cursor:pointer;display:inline-block;transition:transform 50ms;transition:transform 50ms,-webkit-transform 50ms;position:relative;padding:0}.propertyPanel .action-item .hide-panel{height:35px;display:block;line-height:35px;min-width:28px;color:rgba(66,66,66,.75);background-color:transparent!important;outline:0!important;background:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M9.784 8L13 11.217 11.215 13 8.001 9.786 4.785 13 3 11.216l3.214-3.215L3 4.785 4.784 3 8 6.216 11.216 3 13 4.785 9.784 8.001z' fill='%23424242'/%3E%3C/svg%3E\") 50% 50% no-repeat}"]
            }] }
];
/** @nocollapse */
PropertyPanelComponent.ctorParameters = () => [];
PropertyPanelComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    isPersitOpenState: [{ type: Input }],
    isShowPanel: [{ type: Input }],
    closePropertyPanel: [{ type: Output }],
    propertyConfig: [{ type: Input }],
    propertyData: [{ type: Input }],
    propertyChanged: [{ type: Output }],
    submitModal: [{ type: Output }],
    showCloseBtn: [{ type: Input }],
    eastDiv: [{ type: ViewChild, args: ['east',] }],
    itemLists: [{ type: ViewChildren, args: [PropertyItemListComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyPanelModule {
    constructor() { }
}
PropertyPanelModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PropertyPanelComponent,
                    PropertyItemListComponent,
                    PropertyItemComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    PopoverModule,
                    // PopoverModule.forRoot(),
                    InputsModule,
                    DropDownsModule,
                    ComboListModule$1,
                    NotifyModule.forRoot(),
                    ModalModule.forRoot(),
                    FarrisDatePickerModule,
                    ComboListModule,
                    NumberSpinnerModule
                ],
                exports: [PropertyPanelComponent],
                entryComponents: [PropertyPanelComponent, PropertyItemComponent]
            },] }
];
/** @nocollapse */
PropertyPanelModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbTabset component.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the tabsets used in the application.
 */
class NgbTabsetConfig {
    constructor() {
        this.justify = 'start';
        this.orientation = 'horizontal';
        this.type = 'tabs';
    }
}
NgbTabsetConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
/**
 * This directive should be used to wrap tab titles that need to contain HTML markup or other directives.
 */
// tslint:disable-next-line:directive-class-suffix
class NgbTabTitle {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgbTabTitle.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[ngbTabTitle]' },] }
];
/** @nocollapse */
NgbTabTitle.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * This directive must be used to wrap content to be displayed in a tab.
 */
// tslint:disable-next-line:directive-class-suffix
class NgbTabContent {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgbTabContent.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[ngbTabContent]' },] }
];
/** @nocollapse */
NgbTabContent.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * A directive representing an individual tab.
 */
// tslint:disable-next-line:directive-class-suffix
class NgbTab {
    constructor() {
        /**
         * Unique tab identifier. Must be unique for the entire document for proper accessibility support.
         */
        this.id = `ngb-tab-${nextId++}`;
        /**
         * Allows toggling disabled state of a given state. Disabled tabs can't be selected.
         */
        this.disabled = false;
    }
}
NgbTab.decorators = [
    { type: Directive, args: [{ selector: 'ngb-tab' },] }
];
NgbTab.propDecorators = {
    id: [{ type: Input }],
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    contentTpl: [{ type: ContentChild, args: [NgbTabContent,] }],
    titleTpl: [{ type: ContentChild, args: [NgbTabTitle,] }]
};
/**
 * A component that makes it easy to create tabbed interface.
 */
// tslint:disable-next-line:component-class-suffix
class NgbTabset {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * Whether the closed tabs should be hidden without destroying them
         */
        this.destroyOnHide = true;
        /**
         * A tab change event fired right before the tab selection happens. See NgbTabChangeEvent for payload details
         */
        this.tabChange = new EventEmitter();
        this.type = config.type;
        this.justify = config.justify;
        this.orientation = config.orientation;
    }
    /**
     * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
     * 'justified'
     * The default value is 'start'.
     * @param {?} className
     * @return {?}
     */
    set justify(className) {
        if (className === 'fill' || className === 'justified') {
            this.justifyClass = `nav-${className}`;
        }
        else {
            this.justifyClass = `justify-content-${className}`;
        }
    }
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    select(tabId) {
        /** @type {?} */
        const selectedTab = this._getTabById(tabId);
        if (selectedTab && !selectedTab.disabled && this.activeId !== selectedTab.id) {
            /** @type {?} */
            let defaultPrevented = false;
            this.tabChange.emit({ activeId: this.activeId, nextId: selectedTab.id, preventDefault: () => { defaultPrevented = true; } });
            if (!defaultPrevented) {
                this.activeId = selectedTab.id;
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        // auto-correct activeId that might have been set incorrectly as input
        /** @type {?} */
        const activeTab = this._getTabById(this.activeId);
        this.activeId = activeTab ? activeTab.id : (this.tabs.length ? this.tabs.first.id : null);
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    _getTabById(id) {
        /** @type {?} */
        const tabsWithId = this.tabs.filter(tab => tab.id === id);
        return tabsWithId.length ? tabsWithId[0] : null;
    }
}
NgbTabset.decorators = [
    { type: Component, args: [{
                selector: 'ngb-tabset',
                exportAs: 'ngbTabset',
                template: `
    <ul [class]="'web-ide-content-tab-header nav nav-' + type + (orientation == 'horizontal'?  ' '
      + justifyClass : ' flex-column')" role="tablist">
      <li class="nav-item" *ngFor="let tab of tabs">
        <a [id]="tab.id" class="nav-link" [class.active]="tab.id === activeId" [class.disabled]="tab.disabled"
          href (click)="select(tab.id)" role="tab" [attr.tabindex]="(tab.disabled ? '-1': undefined)"
          [attr.aria-controls]="((!destroyOnHide || tab.id === activeId) ? tab.id + '-panel' : null)"
          [attr.aria-expanded]="tab.id === activeId" [attr.aria-disabled]="tab.disabled">
          {{tab.title}}<ng-template [ngTemplateOutlet]="tab.titleTpl?.templateRef"></ng-template>
        </a>
      </li>
    </ul>
    <div class="web-ide-content tab-content d-flex">
      <ng-template ngFor let-tab [ngForOf]="tabs">
        <div
          class="tab-pane {{tab.id === activeId ? 'active' : null}}"
          *ngIf="!destroyOnHide || tab.id === activeId"
          role="tabpanel"
          [attr.aria-labelledby]="tab.id" id="{{tab.id}}-panel"
          [attr.aria-expanded]="tab.id === activeId">
          <ng-template [ngTemplateOutlet]="tab.contentTpl.templateRef"></ng-template>
        </div>
      </ng-template>
    </div>
  `,
                styles: [":host{display:flex!important;flex:1;flex-direction:column}"]
            }] }
];
/** @nocollapse */
NgbTabset.ctorParameters = () => [
    { type: NgbTabsetConfig }
];
NgbTabset.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NgbTab,] }],
    activeId: [{ type: Input }],
    destroyOnHide: [{ type: Input }],
    justify: [{ type: Input }],
    orientation: [{ type: Input }],
    type: [{ type: Input }],
    tabChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGB_TABSET_DIRECTIVES = [NgbTabset, NgbTab, NgbTabContent, NgbTabTitle];
class NgbTabsetModule {
    /**
     * @return {?}
     */
    static forRoot() { return { ngModule: NgbTabsetModule, providers: [NgbTabsetConfig] }; }
}
NgbTabsetModule.decorators = [
    { type: NgModule, args: [{ declarations: NGB_TABSET_DIRECTIVES, exports: NGB_TABSET_DIRECTIVES, imports: [CommonModule] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbNavTabset component.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the tabsets used in the application.
 */
class NgbNavTabsetConfig {
    constructor() {
        this.justify = 'start';
        this.orientation = 'horizontal';
        this.type = 'tabs';
    }
}
NgbNavTabsetConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$1 = 0;
/**
 * This directive should be used to wrap tab titles that need to contain HTML markup or other directives.
 */
// tslint:disable-next-line:directive-class-suffix
class NgbNavTabTitle {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgbNavTabTitle.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[ngbNavTabTitle]' },] }
];
/** @nocollapse */
NgbNavTabTitle.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * This directive must be used to wrap content to be displayed in a tab.
 */
// tslint:disable-next-line:directive-class-suffix
class NgbNavTabContent {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgbNavTabContent.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[ngbNavTabContent]' },] }
];
/** @nocollapse */
NgbNavTabContent.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * A directive representing an individual tab.
 */
// tslint:disable-next-line:directive-class-suffix
class NgbNavTab {
    constructor() {
        /**
         * Unique tab identifier. Must be unique for the entire document for proper accessibility support.
         */
        this.id = `ngb-tab-${nextId$1++}`;
        /**
         * Allows toggling disabled state of a given state. Disabled tabs can't be selected.
         */
        this.disabled = false;
    }
}
NgbNavTab.decorators = [
    { type: Directive, args: [{ selector: 'ngb-navtab' },] }
];
NgbNavTab.propDecorators = {
    id: [{ type: Input }],
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    contentTpl: [{ type: ContentChild, args: [NgbNavTabContent,] }],
    titleTpl: [{ type: ContentChild, args: [NgbNavTabTitle,] }]
};
/**
 * A component that makes it easy to create tabbed interface.
 */
// tslint:disable-next-line:component-class-suffix
class NgbNavTabset {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * Whether the closed tabs should be hidden without destroying them
         */
        this.destroyOnHide = true;
        /**
         * A tab change event fired right before the tab selection happens. See NgbNavTabChangeEvent for payload details
         */
        this.tabChange = new EventEmitter();
        this.type = config.type;
        this.justify = config.justify;
        this.orientation = config.orientation;
    }
    /**
     * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
     * 'justified'
     * The default value is 'start'.
     * @param {?} className
     * @return {?}
     */
    set justify(className) {
        if (className === 'fill' || className === 'justified') {
            this.justifyClass = `nav-${className}`;
        }
        else {
            this.justifyClass = `justify-content-${className}`;
        }
    }
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    select(tabId) {
        /** @type {?} */
        const selectedTab = this._getTabById(tabId);
        if (selectedTab && !selectedTab.disabled && this.activeId !== selectedTab.id) {
            /** @type {?} */
            let defaultPrevented = false;
            this.tabChange.emit({ activeId: this.activeId, nextId: selectedTab.id, preventDefault: () => { defaultPrevented = true; } });
            if (!defaultPrevented) {
                this.activeId = selectedTab.id;
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        // auto-correct activeId that might have been set incorrectly as input
        /** @type {?} */
        const activeTab = this._getTabById(this.activeId);
        this.activeId = activeTab ? activeTab.id : (this.tabs.length ? this.tabs.first.id : null);
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    _getTabById(id) {
        /** @type {?} */
        const tabsWithId = this.tabs.filter(tab => tab.id === id);
        return tabsWithId.length ? tabsWithId[0] : null;
    }
}
NgbNavTabset.decorators = [
    { type: Component, args: [{
                selector: 'ngb-navtabset',
                exportAs: 'NgbNavTabset',
                template: `
    <ul [class]="'web-ide-activity-bar nav nav-' + type + (orientation == 'horizontal'?  ' '
      + justifyClass : ' flex-column')" role="tablist">
      <li class="nav-item" *ngFor="let tab of tabs">
        <a [id]="tab.id" class="nav-link" [class.active]="tab.id === activeId" [class.disabled]="tab.disabled"
          href (click)="select(tab.id)" role="tab" [attr.tabindex]="(tab.disabled ? '-1': undefined)"
          [attr.aria-controls]="(!destroyOnHide || tab.id === activeId ? tab.id + '-panel' : null)"
          [attr.aria-expanded]="tab.id === activeId" [attr.aria-disabled]="tab.disabled">
          {{tab.title}}<ng-template [ngTemplateOutlet]="tab.titleTpl?.templateRef"></ng-template>
        </a>
      </li>
    </ul>
    <div class="web-ide-side-bar tab-content">
      <ng-template ngFor let-tab [ngForOf]="tabs">
        <div
          class="tab-pane {{tab.id === activeId ? 'active' : null}}"
          *ngIf="!destroyOnHide || tab.id === activeId"
          role="tabpanel"
          [attr.aria-labelledby]="tab.id" id="{{tab.id}}-panel"
          [attr.aria-expanded]="tab.id === activeId">
          <ng-template [ngTemplateOutlet]="tab.contentTpl.templateRef"></ng-template>
        </div>
      </ng-template>
    </div>
  `,
                styles: [":host{display:flex!important;flex:1}"]
            }] }
];
/** @nocollapse */
NgbNavTabset.ctorParameters = () => [
    { type: NgbNavTabsetConfig }
];
NgbNavTabset.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NgbNavTab,] }],
    activeId: [{ type: Input }],
    destroyOnHide: [{ type: Input }],
    justify: [{ type: Input }],
    orientation: [{ type: Input }],
    type: [{ type: Input }],
    tabChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGB_TABSET_DIRECTIVES$1 = [NgbNavTabset, NgbNavTab, NgbNavTabContent, NgbNavTabTitle];
class NgbNavTabsetModule {
    /**
     * @return {?}
     */
    static forRoot() { return { ngModule: NgbNavTabsetModule, providers: [NgbNavTabsetConfig] }; }
}
NgbNavTabsetModule.decorators = [
    { type: NgModule, args: [{ declarations: NGB_TABSET_DIRECTIVES$1, exports: NGB_TABSET_DIRECTIVES$1, imports: [CommonModule] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbAccordion component.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the accordions used in the application.
 */
class NgbAccordionConfig {
    constructor() {
        this.closeOthers = false;
    }
}
NgbAccordionConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId$2 = 0;
/**
 * This directive should be used to wrap accordion panel titles that need to contain HTML markup or other directives.
 */
class NgbPanelTitle {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgbPanelTitle.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[ngbPanelTitle]' },] }
];
/** @nocollapse */
NgbPanelTitle.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * This directive must be used to wrap accordion panel content.
 */
class NgbPanelContent {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NgbPanelContent.decorators = [
    { type: Directive, args: [{ selector: 'ng-template[ngbPanelContent]' },] }
];
/** @nocollapse */
NgbPanelContent.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * The NgbPanel directive represents an individual panel with the title and collapsible
 * content
 */
class NgbPanel {
    constructor() {
        /**
         *  A flag determining whether the panel is disabled or not.
         *  When disabled, the panel cannot be toggled.
         */
        this.disabled = false;
        /**
         *  An optional id for the panel. The id should be unique.
         *  If not provided, it will be auto-generated.
         */
        this.id = `ngb-panel-${nextId$2++}`;
        /**
         * A flag telling if the panel is currently open
         */
        this.isOpen = false;
    }
}
NgbPanel.decorators = [
    { type: Directive, args: [{ selector: 'ngb-panel' },] }
];
NgbPanel.propDecorators = {
    disabled: [{ type: Input }],
    id: [{ type: Input }],
    title: [{ type: Input }],
    type: [{ type: Input }],
    contentTpl: [{ type: ContentChild, args: [NgbPanelContent,] }],
    titleTpl: [{ type: ContentChild, args: [NgbPanelTitle,] }]
};
/**
 * The NgbAccordion directive is a collection of panels.
 * It can assure that only one panel can be opened at a time.
 */
class NgbAccordion {
    /**
     * @param {?} config
     */
    constructor(config) {
        /**
         * An array or comma separated strings of panel identifiers that should be opened
         */
        this.activeIds = [];
        /**
         * Whether the closed panels should be hidden without destroying them
         */
        this.destroyOnHide = true;
        /**
         * A panel change event fired right before the panel toggle happens. See NgbPanelChangeEvent for payload details
         */
        this.panelChange = new EventEmitter();
        this.type = config.type;
        this.closeOtherPanels = config.closeOthers;
    }
    /**
     * Programmatically toggle a panel with a given id.
     * @param {?} panelId
     * @return {?}
     */
    toggle(panelId) {
        /** @type {?} */
        const panel = this.panels.find(p => p.id === panelId);
        if (panel && !panel.disabled) {
            /** @type {?} */
            let defaultPrevented = false;
            this.panelChange.emit({ panelId: panelId, nextState: !panel.isOpen, preventDefault: () => { defaultPrevented = true; } });
            if (!defaultPrevented) {
                panel.isOpen = !panel.isOpen;
                if (this.closeOtherPanels) {
                    this._closeOthers(panelId);
                }
                this._updateActiveIds();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        // active id updates
        if (isString(this.activeIds)) {
            this.activeIds = ((/** @type {?} */ (this.activeIds))).split(/\s*,\s*/);
        }
        // update panels open states
        this.panels.forEach(panel => panel.isOpen = !panel.disabled && this.activeIds.indexOf(panel.id) > -1);
        // closeOthers updates
        if (this.activeIds.length > 1 && this.closeOtherPanels) {
            this._closeOthers(this.activeIds[0]);
            this._updateActiveIds();
        }
    }
    /**
     * @private
     * @param {?} panelId
     * @return {?}
     */
    _closeOthers(panelId) {
        this.panels.forEach(panel => {
            if (panel.id !== panelId) {
                panel.isOpen = false;
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    _updateActiveIds() {
        this.activeIds = this.panels.filter(panel => panel.isOpen && !panel.disabled).map(panel => panel.id);
    }
}
NgbAccordion.decorators = [
    { type: Component, args: [{
                selector: 'ngb-accordion',
                exportAs: 'ngbAccordion',
                // host: { 'role': 'tablist', '[attr.aria-multiselectable]': '!closeOtherPanels' },
                template: `
    <ng-template ngFor let-panel [ngForOf]="panels">
      <div class="card">
        <div role="tab" id="{{panel.id}}-header"
          [class]="'card-header ' + (panel.type ? 'card-'+panel.type: type ? 'card-'+type : '')" [class.active]="panel.isOpen">
          <a href (click)="toggle(panel.id)" [class.text-muted]="panel.disabled" [attr.tabindex]="(panel.disabled ? '-1' : null)"
            [attr.aria-expanded]="panel.isOpen" [attr.aria-controls]="(panel.isOpen ? panel.id : null)"
            [attr.aria-disabled]="panel.disabled">
            {{panel.title}}<ng-template [ngTemplateOutlet]="panel.titleTpl?.templateRef"></ng-template>
          </a>
        </div>
        <div id="{{panel.id}}" role="tabpanel" [attr.aria-labelledby]="panel.id + '-header'"
             class="card-body collapse {{panel.isOpen ? 'show' : null}}" *ngIf="!destroyOnHide || panel.isOpen">
             <ng-template [ngTemplateOutlet]="panel.contentTpl.templateRef"></ng-template>
        </div>
      </div>
    </ng-template>
  `
            }] }
];
/** @nocollapse */
NgbAccordion.ctorParameters = () => [
    { type: NgbAccordionConfig }
];
NgbAccordion.propDecorators = {
    panels: [{ type: ContentChildren, args: [NgbPanel,] }],
    activeIds: [{ type: Input }],
    closeOtherPanels: [{ type: Input, args: ['closeOthers',] }],
    destroyOnHide: [{ type: Input }],
    type: [{ type: Input }],
    panelChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGB_ACCORDION_DIRECTIVES = [NgbAccordion, NgbPanel, NgbPanelTitle, NgbPanelContent];
class NgbAccordionModule {
    /**
     * @return {?}
     */
    static forRoot() { return { ngModule: NgbAccordionModule, providers: [NgbAccordionConfig] }; }
}
NgbAccordionModule.decorators = [
    { type: NgModule, args: [{ declarations: NGB_ACCORDION_DIRECTIVES, exports: NGB_ACCORDION_DIRECTIVES, imports: [CommonModule] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SashDirective {
    /**
     * @param {?} _elementRef
     * @param {?} renderer
     * @param {?} _viewContainerRef
     */
    constructor(_elementRef, renderer, _viewContainerRef) {
        this._elementRef = _elementRef;
        this.renderer = renderer;
        this._viewContainerRef = _viewContainerRef;
        this.widthChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    onMouseDown() {
        console.log('mousedown');
        this.bindDocumentClickListener();
    }
    /**
     * @return {?}
     */
    onMouseUp() {
        console.log('mouseup');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'mouseup', (event) => {
                console.log('mouseup');
                console.log(event);
                this.unbindDocumentMoveListener();
                this.unbindDocumentClickListener();
            });
            if (!this.documentMoveListener) {
                this.bindDocumentClickListener = this.renderer.listen('document', 'mousemove', (event) => {
                    this.panelWidth = event.clientX;
                    /** @type {?} */
                    const newWidth = (/** @type {?} */ (event.clientX));
                    this.widthChanged.emit(newWidth);
                });
            }
        }
    }
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    }
    /**
     * @return {?}
     */
    unbindDocumentMoveListener() {
        if (this.bindDocumentClickListener) {
            this.bindDocumentClickListener();
            this.bindDocumentClickListener = null;
        }
    }
}
SashDirective.decorators = [
    { type: Directive, args: [{
                selector: '[sash]',
                exportAs: 'sash'
            },] }
];
/** @nocollapse */
SashDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef }
];
SashDirective.propDecorators = {
    panelWidth: [{ type: Input }],
    widthChanged: [{ type: Output }],
    onMouseDown: [{ type: HostListener, args: ['mousedown',] }],
    onMouseUp: [{ type: HostListener, args: ['mouseup',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PanelModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: PanelModule
        };
    }
}
PanelModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SashDirective
                ],
                exports: [
                    SashDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGB_MODULES = [
    NgbTabsetModule,
    NgbNavTabsetModule,
    NgbAccordionModule
];
// @NgModule({
//   imports: [
//     BsDropdownModule.forRoot()
//   ],
//   exports: [BsDropdownModule],
//   schemas: [NO_ERRORS_SCHEMA]
// })
// export class MDBRootModule {
// }
// @NgModule({ exports: [BsDropdownModule] })
// export class MDBBootstrapModule {
//   public static forRoot(): ModuleWithProviders {
//     return { ngModule: MDBRootModule };
//   }
// }
class NgbRootModule {
}
NgbRootModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    NgbTabsetModule.forRoot(),
                    NgbNavTabsetModule.forRoot(),
                    NgbAccordionModule.forRoot()
                ],
                exports: [
                    NGB_MODULES
                ]
            },] }
];
class NgbModule {
    /**
     * @return {?}
     */
    static forRoot() { return { ngModule: NgbRootModule }; }
}
NgbModule.decorators = [
    { type: NgModule, args: [{},] }
];
class IDERootModule {
}
IDERootModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    PanelModule.forRoot()
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class LinkedList {
    constructor() {
        this.length = 0;
        this.asArray = [];
        // Array methods overriding END
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    getNode(position) {
        if (this.length === 0 || position < 0 || position >= this.length) {
            throw new Error('Position is out of the list');
        }
        /** @type {?} */
        let current = this.head;
        for (let index = 0; index < position; index++) {
            current = current.next;
        }
        return current;
    }
    /**
     * @protected
     * @return {?}
     */
    createInternalArrayRepresentation() {
        /** @type {?} */
        const outArray = [];
        /** @type {?} */
        let current = this.head;
        while (current) {
            outArray.push(current.value);
            current = current.next;
        }
        this.asArray = outArray;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    get(position) {
        if (this.length === 0 || position < 0 || position >= this.length) {
            return void 0;
        }
        /** @type {?} */
        let current = this.head;
        for (let index = 0; index < position; index++) {
            current = current.next;
        }
        return current.value;
    }
    /**
     * @param {?} value
     * @param {?=} position
     * @return {?}
     */
    add(value, position = this.length) {
        if (position < 0 || position > this.length) {
            throw new Error('Position is out of the list');
        }
        /** @type {?} */
        const node = {
            value: (/** @type {?} */ (value)),
            next: (/** @type {?} */ (undefined)),
            previous: (/** @type {?} */ (undefined))
        };
        if (this.length === 0) {
            this.head = node;
            this.tail = node;
            this.current = node;
        }
        else {
            if (position === 0) {
                // first node
                node.next = this.head;
                this.head.previous = node;
                this.head = node;
            }
            else if (position === this.length) {
                // last node
                this.tail.next = node;
                node.previous = this.tail;
                this.tail = node;
            }
            else {
                // node in middle
                /** @type {?} */
                const currentPreviousNode = this.getNode(position - 1);
                /** @type {?} */
                const currentNextNode = currentPreviousNode.next;
                currentPreviousNode.next = node;
                currentNextNode.previous = node;
                node.previous = currentPreviousNode;
                node.next = currentNextNode;
            }
        }
        this.length++;
        this.createInternalArrayRepresentation();
    }
    /**
     * @param {?=} position
     * @return {?}
     */
    remove(position = 0) {
        if (this.length === 0 || position < 0 || position >= this.length) {
            throw new Error('Position is out of the list');
        }
        if (position === 0) {
            // first node
            this.head = this.head.next;
            if (this.head) {
                // there is no second node
                this.head.previous = undefined;
            }
            else {
                // there is no second node
                this.tail = undefined;
            }
        }
        else if (position === this.length - 1) {
            // last node
            this.tail = this.tail.previous;
            this.tail.next = undefined;
        }
        else {
            // middle node
            /** @type {?} */
            const removedNode = this.getNode(position);
            removedNode.next.previous = removedNode.previous;
            removedNode.previous.next = removedNode.next;
        }
        this.length--;
        this.createInternalArrayRepresentation();
    }
    /**
     * @param {?} position
     * @param {?} value
     * @return {?}
     */
    set(position, value) {
        if (this.length === 0 || position < 0 || position >= this.length) {
            throw new Error('Position is out of the list');
        }
        /** @type {?} */
        const node = this.getNode(position);
        node.value = value;
        this.createInternalArrayRepresentation();
    }
    /**
     * @return {?}
     */
    toArray() {
        return this.asArray;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    findAll(fn) {
        /** @type {?} */
        let current = this.head;
        /** @type {?} */
        const result = [];
        for (let index = 0; index < this.length; index++) {
            if (fn(current.value, index)) {
                result.push({ index, value: current.value });
            }
            current = current.next;
        }
        return result;
    }
    // Array methods overriding start
    /**
     * @param {...?} args
     * @return {?}
     */
    push(...args) {
        args.forEach((arg) => {
            this.add(arg);
        });
        return this.length;
    }
    /**
     * @return {?}
     */
    pop() {
        if (this.length === 0) {
            return undefined;
        }
        /** @type {?} */
        const last$$1 = this.tail;
        this.remove(this.length - 1);
        return last$$1.value;
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    unshift(...args) {
        args.reverse();
        args.forEach((arg) => {
            this.add(arg, 0);
        });
        return this.length;
    }
    /**
     * @return {?}
     */
    shift() {
        if (this.length === 0) {
            return undefined;
        }
        /** @type {?} */
        const lastItem = this.head.value;
        this.remove();
        return lastItem;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    forEach(fn) {
        /** @type {?} */
        let current = this.head;
        for (let index = 0; index < this.length; index++) {
            fn(current.value, index);
            current = current.next;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    indexOf(value) {
        /** @type {?} */
        let current = this.head;
        /** @type {?} */
        let position = 0;
        for (let index = 0; index < this.length; index++) {
            if (current.value === value) {
                position = index;
                break;
            }
            current = current.next;
        }
        return position;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    some(fn) {
        /** @type {?} */
        let current = this.head;
        /** @type {?} */
        let result = false;
        while (current && !result) {
            if (fn(current.value)) {
                result = true;
                break;
            }
            current = current.next;
        }
        return result;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    every(fn) {
        /** @type {?} */
        let current = this.head;
        /** @type {?} */
        let result = true;
        while (current && result) {
            if (!fn(current.value)) {
                result = false;
            }
            current = current.next;
        }
        return result;
    }
    /**
     * @return {?}
     */
    toString() {
        return '[Linked List]';
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    find(fn) {
        /** @type {?} */
        let current = this.head;
        /** @type {?} */
        let result;
        for (let index = 0; index < this.length; index++) {
            if (fn(current.value, index)) {
                result = current.value;
                break;
            }
            current = current.next;
        }
        return result;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    findIndex(fn) {
        /** @type {?} */
        let current = this.head;
        /** @type {?} */
        let result;
        for (let index = 0; index < this.length; index++) {
            if (fn(current.value, index)) {
                result = index;
                break;
            }
            current = current.next;
        }
        return result;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EventBusProxy {
    /**
     * @param {?} eventBus
     * @param {?} hostType
     * @param {?} eventTokenValueProvider
     */
    constructor(eventBus, hostType, eventTokenValueProvider) {
        this.eventBus = eventBus;
        this.hostType = hostType;
        this.eventTokenValueProvider = eventTokenValueProvider;
    }
    /**
     * @param {?} eventName
     * @param {?} data
     * @return {?}
     */
    post(eventName, data) {
        this.eventBus.post(this.hostType, this.eventTokenValueProvider(), eventName, data);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EventPipe {
    /**
     * @param {?} name
     * @param {?} tokenValue
     * @param {?} emitter
     * @param {?} parentEventPipeList
     */
    constructor(name, tokenValue, emitter, parentEventPipeList) {
        this.name = name;
        this.tokenValue = tokenValue;
        this.emitter = emitter;
        this.parentEventPipeList = parentEventPipeList;
        this.eventSubject = new Subject$1();
        this.subscriptionMap = new Map();
        this.onceSubscriptionMap = new Map();
        if (this.parentEventPipeList) {
            this.parentEventPipeList.push(this);
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    post(data) {
        this.eventSubject.next(data);
    }
    /**
     * @param {?} eventHandler
     * @param {?} caller
     * @return {?}
     */
    subscribe(eventHandler, caller) {
        /** @type {?} */
        const subscription = this.eventSubject.subscribe((value) => eventHandler.call(caller, value));
        this.subscriptionMap.set(caller, subscription);
        return this;
    }
    /**
     * @param {?} eventHandler
     * @param {?} caller
     * @return {?}
     */
    subscribeOnce(eventHandler, caller) {
        /** @type {?} */
        const subscription = this.eventSubject.subscribe((value) => eventHandler.call(caller, value));
        this.onceSubscriptionMap.set(caller, subscription);
        return this;
    }
    /**
     * @param {?} subscriber
     * @return {?}
     */
    unSubscribe(subscriber) {
        /** @type {?} */
        let subscription = this.subscriptionMap.get(subscriber);
        if (subscription) {
            subscription.unsubscribe();
            subscription = null;
            this.subscriptionMap.delete(subscriber);
        }
        else {
            subscription = this.onceSubscriptionMap.get(subscriber);
            if (subscription) {
                subscription.unsubscribe();
                subscription = null;
                this.onceSubscriptionMap.delete(subscriber);
            }
        }
    }
    // 注销使用once方法注册的订阅。
    /**
     * @return {?}
     */
    unSubscribeForOnce() {
        for (const subscriber of Array.from(this.onceSubscriptionMap.keys())) {
            this.unSubscribe(subscriber);
        }
    }
    /**
     * @param {?} emitter
     * @param {?} tokenValue
     * @return {?}
     */
    matchEmitterToken(emitter, tokenValue) {
        if (this.emitter && emitter && this.emitter !== emitter) {
            return false;
        }
        if (this.tokenValue && tokenValue && this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    }
    /**
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    examByTargetToken(target, tokenValue) {
        if (this.emitter !== target) {
            return false;
        }
        if (this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    }
    /**
     * @param {?} subscriber
     * @return {?}
     */
    dispose(subscriber) {
        this.unSubscribe(subscriber);
        if (this.subscriptionMap.size === 0 && this.parentEventPipeList) {
            /** @type {?} */
            const location = this.parentEventPipeList.findIndex(item => item === this);
            if (location !== -1) {
                this.parentEventPipeList.splice(location, 1);
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DuplexEventPipe {
    /**
     * @param {?} eventName
     */
    constructor(eventName) {
        this.listenerResults = new Map();
        this.subject = new Subject();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    notify(value) {
        /** @type {?} */
        let thenFn = () => { };
        /** @type {?} */
        let catchFn = () => { };
        /** @type {?} */
        const timestamp = Date.now().toString();
        this.subject.next({ value, timestamp });
        // fooObservable无意义，有两个作用：
        // 1. 没有实际observable时能够让forkJoin输出值，进入subscriber.next
        // 2. 建立延迟的observable（跳出当前micro task），避免subscription未返回和thenFn未被设置。
        /** @type {?} */
        const fooObservable = timer(0).pipe(mapTo(true));
        /** @type {?} */
        let listenerResultArray = this.listenerResults.get(timestamp);
        if (!listenerResultArray) {
            listenerResultArray = [fooObservable];
        }
        else {
            listenerResultArray = listenerResultArray.concat(fooObservable);
            this.listenerResults.delete(timestamp);
        }
        /** @type {?} */
        const subscription = forkJoin(listenerResultArray).subscribe({ next: (results) => {
                /** @type {?} */
                const success = results.reduce((previous, current) => previous && current);
                if (success) {
                    thenFn();
                }
                else {
                    catchFn();
                }
                subscription.unsubscribe();
            }, error: () => {
                subscription.unsubscribe();
            } });
        return {
            /**
             * @param {?} callback
             * @return {?}
             */
            then(callback) {
                thenFn = callback;
                return this;
            },
            /**
             * @param {?} callback
             * @return {?}
             */
            catch(callback) {
                catchFn = callback;
                return this;
            }
        };
    }
    /**
     * @param {?} callback
     * @param {?=} caller
     * @return {?}
     */
    listen(callback, caller) {
        /** @type {?} */
        const listener = caller ? callback.bind(caller) : callback;
        this.subject.subscribe(({ value, timestamp }) => {
            /** @type {?} */
            let listenerResult;
            /** @type {?} */
            const invokeResult = listener(value);
            if (invokeResult instanceof Observable) {
                listenerResult = invokeResult;
            }
            else if (typeof invokeResult === 'boolean') {
                listenerResult = of(invokeResult);
            }
            else {
                listenerResult = of(true);
            }
            /** @type {?} */
            let listenerResultArray = this.listenerResults.get(timestamp);
            if (!listenerResultArray) {
                listenerResultArray = [];
                this.listenerResults.set(timestamp, listenerResultArray);
            }
            listenerResultArray.push(listenerResult);
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EventBus {
    constructor() {
        this.proxyMap = new Map();
        this.eventMap = new Map();
        this.notificationMap = new Map();
    }
    /**
     * @param {?} ownerType
     * @param {?} eventTokenValueProvider
     * @return {?}
     */
    getProxy(ownerType, eventTokenValueProvider) {
        /** @type {?} */
        const ownerName = ownerType.constructor.name;
        if (!this.proxyMap.has(ownerName)) {
            this.proxyMap.set(ownerName, new EventBusProxy(this, ownerType, eventTokenValueProvider));
        }
        return this.proxyMap.get(ownerName);
    }
    /**
     * 发送事件，通知订阅者接收消息。
     * @param {?} emitterType
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    post(emitterType, tokenValue, eventName, eventArgs) {
        /** @type {?} */
        const eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            return;
        }
        if (!emitterType) {
            console.error('post方法的参数emitterType不能为空。');
            return;
        }
        /** @type {?} */
        let emitter;
        if (emitterType instanceof Type) {
            emitter = emitterType.name;
        }
        else {
            emitter = emitterType;
        }
        for (const eventPipe of eventPipeList) {
            if (eventPipe.matchEmitterToken(emitter, tokenValue)) {
                eventPipe.post(eventArgs);
                eventPipe.unSubscribeForOnce();
            }
        }
    }
    /**
     * 订阅事件
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    on(target, tokenValue, eventName, caller, handler) {
        return this.getEventPipe(eventName, target, tokenValue).subscribe(handler, caller);
    }
    /**
     * 订阅一次。接收到一次消息之后自动取消订阅
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    once(target, tokenValue, eventName, caller, handler) {
        return this.getEventPipe(eventName, target, tokenValue).subscribeOnce(handler, caller);
    }
    /**
     * 发送一个请求事件，获取监听者的响应并处理
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} requestName
     * @param {?} requestValue
     * @param {?} success
     * @param {?=} fail
     * @return {?}
     */
    requestFor(target, tokenValue, requestName, requestValue, success, fail) {
        /** @type {?} */
        const eventPipe = this.findExistEventPipe(requestName, 'RequestSubject', tokenValue);
        if (eventPipe) {
            this.once(target, tokenValue, requestName, this, (response) => {
                if (response.status === 'success') {
                    success(response.data);
                }
                else {
                    if (fail) {
                        fail('No target responser listening');
                    }
                }
            });
            eventPipe.post({ target, token: tokenValue, data: requestValue });
        }
        else {
            if (fail) {
                fail('No target responser listening.');
            }
        }
    }
    /**
     * 监听一个请求事件，给出响应
     * @param {?} responseSubject
     * @param {?} requestName
     * @param {?} callback
     * @return {?}
     */
    responseOn(responseSubject, requestName, callback) {
        this.on('RequestSubject', null, requestName, this, (requestObj) => {
            /** @type {?} */
            const response = { status: 'fail', data: null };
            if (responseSubject === requestObj.target) {
                response.data = callback(requestObj.data);
                response.status = 'success';
            }
            this.post(requestObj.target, requestObj.token, requestName, response);
        });
    }
    /**
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    notify(eventName, eventArgs) {
        /** @type {?} */
        let notification = this.notificationMap.get(eventName);
        if (!notification) {
            notification = new DuplexEventPipe(eventName);
            this.notificationMap.set(eventName, notification);
        }
        return notification.notify(eventArgs);
    }
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} caller
     * @return {?}
     */
    listen(eventName, handler, caller) {
        /** @type {?} */
        let notification = this.notificationMap.get(eventName);
        if (!notification) {
            notification = new DuplexEventPipe(eventName);
            this.notificationMap.set(eventName, notification);
        }
        return notification.listen(handler, caller);
    }
    /**
     * @private
     * @param {?} eventName
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    getEventPipe(eventName, target, tokenValue) {
        /** @type {?} */
        let eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            eventPipeList = new Array();
            this.eventMap.set(eventName, eventPipeList);
        }
        /** @type {?} */
        let eventPipe = eventPipeList.find(item => item.examByTargetToken(target, tokenValue));
        if (!eventPipe) {
            eventPipe = new EventPipe(eventName, tokenValue, target, eventPipeList);
        }
        return eventPipe;
    }
    /**
     * @private
     * @param {?} eventName
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    findExistEventPipe(eventName, target, tokenValue) {
        /** @type {?} */
        const eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            return null;
        }
        // return eventPipeList.find(item => item.examByTargetToken(target, tokenValue));
        for (const eventPipe of eventPipeList) {
            if (eventPipe.matchEmitterToken(target, tokenValue)) {
                return eventPipe;
            }
        }
        return null;
    }
}
EventBus.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EventBus.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Model {
    /**
     * @param {?} params
     */
    constructor(params) {
        this.alive = true;
    }
    /**
     * @return {?}
     */
    get isAlive() { return this.alive; }
    /**
     * @return {?}
     */
    get isDestroyed() { return !this.alive; }
    /**
     * @param {?} id
     * @return {?}
     */
    assignId(id) {
    }
    /**
     * @return {?}
     */
    destroy() {
    }
    /**
     * @return {?}
     */
    resetNextInstanceId() {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaneAxis extends Model {
    /**
     * @return {?}
     */
    deserialize() {
    }
    /**
     * @param {?=} params
     * @param {?=} viewRegistry
     */
    constructor(params, viewRegistry) {
        super({});
    }
    /**
     * @return {?}
     */
    getElement() { }
    /**
     * @return {?}
     */
    addChild() { }
    /**
     * @return {?}
     */
    removeChidl() { }
    /**
     * @return {?}
     */
    insertChildBefore() { }
    /**
     * @return {?}
     */
    subscribeToChild() { }
    /**
     * @return {?}
     */
    unsubscribeFromChild() { }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: A handle to a resource that can be disposed. For example,
// {Emitter::on} returns disposables representing subscriptions.
class Disposable {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct a Disposable
    //
    // * `disposalAction` A {Function} to call when {::dispose} is called for the
    //   first time.
    /**
     * @param {?} disposalAction
     */
    constructor(disposalAction) {
        this.disposalAction = disposalAction;
        this.disposed = false;
    }
    // Public: Ensure that `object` correctly implements the `Disposable`
    // contract.
    //
    // * `object` An {Object} you want to perform the check against.
    //
    // Returns a {Boolean} indicating whether `object` is a valid `Disposable`.
    /**
     * @param {?} object
     * @return {?}
     */
    static isDisposable(object) {
        if (object && object.dispose && typeof (object.dispose) === 'function') {
            return true;
        }
        return false;
    }
    // Public: Perform the disposal action, indicating that the resource associated
    // with this disposable is no longer needed.
    //
    // You can call this method more than once, but the disposal action will only
    // be performed the first time.
    /**
     * @return {?}
     */
    dispose() {
        if (!this.disposed) {
            this.disposed = true;
            if (this.disposalAction) {
                this.disposalAction();
            }
            this.disposalAction = null;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: An object that aggregates multiple {Disposable} instances together
// into a single disposable, so they can all be disposed as a group.
//
// These are very useful when subscribing to multiple events.
//
// ## Examples
//
// ```coffee
// {CompositeDisposable} = require 'atom'
//
// class Something
//   constructor: ->
//     @disposables = new CompositeDisposable
//     editor = atom.workspace.getActiveTextEditor()
//     @disposables.add editor.onDidChange ->
//     @disposables.add editor.onDidChangePath ->
//
//   destroy: ->
//     @disposables.dispose()
// ```
class CompositeDisposable {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct an instance, optionally with one or more disposables
    /**
     * @param {...?} disposables
     */
    constructor(...disposables) {
        this.disposed = false;
        this.disposables = new Set();
        this.add(...disposables);
    }
    // Public: Dispose all disposables added to this composite disposable.
    //
    // If this object has already been disposed, this method has no effect.
    /**
     * @return {?}
     */
    dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this.disposables.forEach((disposable) => disposable.dispose());
            this.disposables = null;
        }
    }
    //////
    /// Section: Managing Disposables
    //////
    // Public: Add disposables to be disposed when the composite is disposed.
    //
    // If this object has already been disposed, this method has no effect.
    //
    // * `...disposables` {Disposable} instances or any objects with `.dispose()`
    //   methods.
    /**
     * @param {...?} disposables
     * @return {?}
     */
    add(...disposables) {
        if (!this.disposed) {
            for (const disposable of disposables) {
                if (this.assertDisposable(disposable)) {
                    this.disposables.add(disposable);
                }
            }
        }
    }
    // Public: Remove a previously added disposable.
    //
    // * `disposable` {Disposable} instance or any object with a `.dispose()`
    //   method.
    /**
     * @param {?} disposable
     * @return {?}
     */
    remove(disposable) {
        if (!this.disposed) {
            this.disposables.delete(disposable);
        }
    }
    // Public: Alias to {CompositeDisposable::remove}
    /**
     * @param {?} disposable
     * @return {?}
     */
    delete(disposable) {
        this.remove(disposable);
    }
    // Public: Clear all disposables. They will not be disposed by the next call
    // to dispose.
    /**
     * @return {?}
     */
    clear() {
        if (!this.disposed) {
            this.disposables.clear();
        }
    }
    /**
     * @param {?} disposable
     * @return {?}
     */
    assertDisposable(disposable) {
        if (!Disposable.isDisposable(disposable)) {
            throw new TypeError('Arguments to CompositeDisposable.add must have a .dispose() method');
        }
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: Utility class to be used when implementing event-based APIs that
// allows for handlers registered via `::on` to be invoked with calls to
// `::emit`. Instances of this class are intended to be used internally by
// classes that expose an event-based API.
//
// For example:
//
// ```coffee
// class User
//   constructor: ->
//     @emitter = new Emitter
//
//   onDidChangeName: (callback) ->
//     @emitter.on 'did-change-name', callback
//
//   setName: (name) ->
//     if name isnt @name
//       @name = name
//       @emitter.emit 'did-change-name', name
//     @name
// ```
class Emitter {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct an emitter.
    //
    // ```coffee
    // @emitter = new Emitter()
    // ```
    constructor() {
        this.disposed = false;
        this.clear();
    }
    /**
     * @param {?} exceptionHandler
     * @return {?}
     */
    static onEventHandlerException(exceptionHandler) {
        this.dispatch = this.simpleDispatch;
        if (this.exceptionHandlers.length === 0) {
            this.dispatch = this.exceptionHandlingDispatch;
        }
        this.exceptionHandlers.push(exceptionHandler);
        return new Disposable(() => {
            this.exceptionHandlers.splice(this.exceptionHandlers.indexOf(exceptionHandler), 1);
            if (this.exceptionHandlers.length === 0) {
                return this.dispatch = this.simpleDispatch;
            }
        });
    }
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    static simpleDispatch(handler, value) {
        return handler(value);
    }
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    static exceptionHandlingDispatch(handler, value) {
        try {
            return handler(value);
        }
        catch (exception) {
            return this.exceptionHandlers.map((exceptionHandler) => exceptionHandler(exception));
        }
    }
    // Public: Clear out any existing subscribers.
    /**
     * @return {?}
     */
    clear() {
        if (this.subscriptions) {
            this.subscriptions.dispose();
        }
        this.subscriptions = new CompositeDisposable();
        return this.handlersByEventName = {};
    }
    // Public: Unsubscribe all handlers.
    /**
     * @return {?}
     */
    dispose() {
        this.subscriptions.dispose();
        this.handlersByEventName = null;
        this.disposed = true;
    }
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    on(eventName, handler, unshift = false) {
        if (this.disposed) {
            throw new Error('Emitter has been disposed');
        }
        if (typeof handler !== 'function') {
            throw new Error('Handler must be a function');
        }
        /** @type {?} */
        const currentHandlers = this.handlersByEventName[eventName];
        if (currentHandlers) {
            if (unshift) {
                this.handlersByEventName[eventName] = [handler].concat(currentHandlers);
            }
            else {
                this.handlersByEventName[eventName] = currentHandlers.concat(handler);
            }
        }
        else {
            this.handlersByEventName[eventName] = [handler];
        }
        // When the emitter is disposed, we want to dispose of all subscriptions.
        // However, we also need to stop tracking disposables when they're disposed
        // from outside, otherwise this class will hold references to all the
        // disposables it created (instead of just the active ones).
        /** @type {?} */
        const cleanup = new Disposable(() => {
            this.subscriptions.remove(cleanup);
            return this.off(eventName, handler);
        });
        this.subscriptions.add(cleanup);
        return cleanup;
    }
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    once(eventName, handler, unshift = false) {
        /** @type {?} */
        let disposable;
        /** @type {?} */
        const wrapped = (value) => {
            disposable.dispose();
            handler(value);
        };
        disposable = this.on(eventName, wrapped, unshift);
        return disposable;
    }
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    preempt(eventName, handler) {
        this.on(eventName, handler, true);
    }
    // Private: Used by the disposable.
    /**
     * @param {?} eventName
     * @param {?} handlerToRemove
     * @return {?}
     */
    off(eventName, handlerToRemove) {
        if (this.disposed) {
            return;
        }
        /** @type {?} */
        const oldHandlers = this.handlersByEventName[eventName];
        if (oldHandlers) {
            /** @type {?} */
            const newHandlers = [];
            for (const handler of oldHandlers) {
                if (handler !== handlerToRemove) {
                    newHandlers.push(handler);
                }
            }
            if (newHandlers.length > 0) {
                this.handlersByEventName[eventName] = newHandlers;
            }
            else {
                delete this.handlersByEventName[eventName];
            }
        }
    }
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    emit(eventName, value) {
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            const handlers = this.handlersByEventName[eventName];
            for (const handler of handlers) {
                Emitter.dispatch(handler, value);
            }
        }
    }
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    emitAsync(eventName, value) {
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            const results = [];
            for (const handler of this.handlersByEventName[eventName]) {
                results.push(Emitter.dispatch(handler, value));
            }
            return Promise.all(results).then(function () { });
        }
        return Promise.resolve();
    }
    /**
     * @return {?}
     */
    getEventNames() {
        return Object.keys(this.handlersByEventName);
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    listenerCountForEventName(eventName) {
        return this.handlersByEventName && this.handlersByEventName[eventName] ? this.handlersByEventName[eventName].length : 0;
    }
    /**
     * @return {?}
     */
    getTotalListenerCount() {
        /** @type {?} */
        let result = 0;
        for (const eventName in this.handlersByEventName) {
            if (this.handlersByEventName.hasOwnProperty(eventName)) {
                result += this.handlersByEventName[eventName].length;
            }
        }
        return result;
    }
}
Emitter.exceptionHandlers = [];
Emitter.dispatch = Emitter.simpleDispatch;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// const Grim = require('grim')
// const {CompositeDisposable, Emitter} = require('event-kit')
// const PaneAxis = require('./pane-axis')
// const TextEditor = require('./text-editor')
// const PaneElement = require('./pane-element')
/** @type {?} */
let nextInstanceId$1 = 1;
class SaveCancelledError extends Error {
}
// Extended: A container for presenting content in the center of the workspace.
// Panes can contain multiple items, one of which is *active* at a given time.
// The view corresponding to the active item is displayed in the interface. In
// the default configuration, tabs are also displayed for each item.
//
// Each pane may also contain one *pending* item. When a pending item is added
// to a pane, it will replace the currently pending item, if any, instead of
// simply being added. In the default configuration, the text in the tab for
// pending items is shown in italics.
class Pane {
    /**
     * @param {?} params
     */
    constructor(params) {
        this.alive = true;
        this.subscriptionsPerItem = new WeakMap();
        this.items = [];
        this.itemStack = [];
        this.container = null;
        this.setPendingItem = this.setPendingItem.bind(this);
        this.getPendingItem = this.getPendingItem.bind(this);
        this.clearPendingItem = this.clearPendingItem.bind(this);
        this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this);
        this.saveItem = this.saveItem.bind(this);
        this.saveItemAs = this.saveItemAs.bind(this);
        this.id = params.id;
        if (this.id != null) {
            nextInstanceId$1 = Math.max(nextInstanceId$1, this.id + 1);
        }
        else {
            this.id = nextInstanceId$1++;
        }
        this.activeItem = params.activeItem;
        this.focused = params.focused != null ? params.focused : false;
        this.applicationDelegate = params.applicationDelegate;
        this.notificationManager = params.notificationManager;
        this.config = params.config;
        this.deserializerManager = params.deserializerManager;
        this.viewRegistry = params.viewRegistry;
        this.emitter = new Emitter();
        this.alive = true;
        this.subscriptionsPerItem = new WeakMap();
        this.items = [];
        this.itemStack = [];
        this.container = null;
        this.addItems((params.items || []).filter(item => item));
        if (!this.getActiveItem()) {
            this.setActiveItem(this.items[0]);
        }
        this.addItemsToStack(params.itemStackIndices || []);
        this.setFlexScale(params.flexScale || 1);
    }
    /**
     * @param {?} state
     * @param {?} __1
     * @return {?}
     */
    static deserialize(state, { deserializers, applicationDelegate, config, notifications, views }) {
        const { activeItemIndex } = state;
        /** @type {?} */
        const activeItemURI = state.activeItemURI || state.activeItemUri;
        /** @type {?} */
        const items = [];
        for (const itemState of state.items) {
            /** @type {?} */
            const item = deserializers.deserialize(itemState);
            if (item) {
                items.push(item);
            }
        }
        state.items = items;
        state.activeItem = items[activeItemIndex];
        if (!state.activeItem && activeItemURI) {
            state.activeItem = state.items.find((item) => typeof item.getURI === 'function' && item.getURI() === activeItemURI);
        }
        return new Pane(Object.assign(state, {
            deserializerManager: deserializers,
            notificationManager: notifications,
            viewRegistry: views,
            config,
            applicationDelegate
        }));
    }
    /**
     * @return {?}
     */
    inspect() {
        return `Pane ${this.id}`;
    }
    /**
     * @return {?}
     */
    getElement() {
    }
    /**
     * @return {?}
     */
    serialize() {
        /** @type {?} */
        const itemsToBeSerialized = this.items.filter(item => item && typeof item.serialize === 'function');
        /** @type {?} */
        const itemStackIndices = [];
        for (const item of this.itemStack) {
            if (typeof item.serialize === 'function') {
                itemStackIndices.push(itemsToBeSerialized.indexOf(item));
            }
        }
        /** @type {?} */
        const activeItemIndex = itemsToBeSerialized.indexOf(this.activeItem);
        return {
            deserializer: 'Pane',
            id: this.id,
            items: itemsToBeSerialized.map(item => item.serialize()),
            itemStackIndices,
            activeItemIndex,
            focused: this.focused,
            flexScale: this.flexScale
        };
    }
    /**
     * @return {?}
     */
    getParent() { return this.parent; }
    /**
     * @param {?} parent
     * @return {?}
     */
    setParent(parent) {
        this.parent = parent;
    }
    /**
     * @return {?}
     */
    getContainer() { return this.container; }
    /**
     * @param {?} container
     * @return {?}
     */
    setContainer(container) {
        if (container && container !== this.container) {
            this.container = container;
            container.didAddPane({ pane: this });
        }
    }
    // Private: Determine whether the given item is allowed to exist in this pane.
    //
    // * `item` the Item
    //
    // Returns a {Boolean}.
    /**
     * @param {?} item
     * @return {?}
     */
    isItemAllowed(item) {
        if (typeof item.getAllowedLocations !== 'function') {
            return true;
        }
        else {
            return item.getAllowedLocations().includes(this.getContainer().getLocation());
        }
    }
    /**
     * @param {?} flexScale
     * @return {?}
     */
    setFlexScale(flexScale) {
        this.flexScale = flexScale;
        return this.flexScale;
    }
    /**
     * @return {?}
     */
    getFlexScale() { return this.flexScale; }
    /**
     * @return {?}
     */
    increaseSize() { this.setFlexScale(this.getFlexScale() * 1.1); }
    /**
     * @return {?}
     */
    decreaseSize() { this.setFlexScale(this.getFlexScale() / 1.1); }
    /*
      Section: Event Subscription
      */
    // Public: Invoke the given callback when the pane resizes
    //
    // The callback will be invoked when pane's flexScale property changes.
    // Use {::getFlexScale} to get the current value.
    //
    // * `callback` {Function} to be called when the pane is resized
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which '.dispose()' can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeFlexScale(callback) {
    }
    // Public: Invoke the given callback with the current and future values of
    // {::getFlexScale}.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::getFlexScale} property.
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeFlexScale(callback) {
        callback(this.flexScale);
        return this.onDidChangeFlexScale(callback);
    }
    // Public: Invoke the given callback when the pane is activated.
    //
    // The given callback will be invoked whenever {::activate} is called on the
    // pane, even if it is already active at the time.
    //
    // * `callback` {Function} to be called when the pane is activated.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidActivate(callback) {
    }
    // Public: Invoke the given callback before the pane is destroyed.
    //
    // * `callback` {Function} to be called before the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillDestroy(callback) {
    }
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDestroy(callback) {
    }
    // Public: Invoke the given callback when the value of the {::isActive}
    // property changes.
    //
    // * `callback` {Function} to be called when the value of the {::isActive}
    //   property changes.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeActive(callback) {
        return this.container.onDidChangeActivePane(activePane => {
            /** @type {?} */
            const isActive = this === activePane;
            callback(isActive);
        });
    }
    // Public: Invoke the given callback with the current and future values of the
    // {::isActive} property.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::isActive} property.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeActive(callback) {
        callback(this.isActive());
        return this.onDidChangeActive(callback);
    }
    // Public: Invoke the given callback when an item is added to the pane.
    //
    // * `callback` {Function} to be called with when items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `index` {Number} indicating where the item is located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidAddItem(callback) {
        return this.emitter.on('did-add-item', callback);
    }
    // Public: Invoke the given callback when an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `index` {Number} indicating where the item was located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidRemoveItem(callback) {
        return this.emitter.on('did-remove-item', callback);
    }
    // Public: Invoke the given callback before an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The pane item to be removed.
    //     * `index` {Number} indicating where the item is located.
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillRemoveItem(callback) {
    }
    // Public: Invoke the given callback when an item is moved within the pane.
    //
    // * `callback` {Function} to be called with when items are moved.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `oldIndex` {Number} indicating where the item was located.
    //     * `newIndex` {Number} indicating where the item is now located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidMoveItem(callback) {
    }
    // Public: Invoke the given callback with all current and future items.
    //
    // * `callback` {Function} to be called with current and future items.
    //   * `item` An item that is present in {::getItems} at the time of
    //     subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeItems(callback) {
        for (const item of this.getItems()) {
            callback(item);
        }
        return this.onDidAddItem(({ item }) => callback(item));
    }
    // 公有方法： 当{::getActiveItem}值变换前调用。
    /**
     * @param {?} callback
     * @return {?}
     */
    onDoingChangeActiveItem(callback) {
        return this.emitter.on('doing-change-active-item', callback);
    }
    // Public: Invoke the given callback when the value of {::getActiveItem}
    // changes.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeActiveItem(callback) {
        return this.emitter.on('did-change-active-item', callback);
    }
    // Public: Invoke the given callback when {::activateNextRecentlyUsedItem}
    // has been called, either initiating or continuing a forward MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `nextRecentlyUsedItem` The next MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onChooseNextMRUItem(callback) {
    }
    // Public: Invoke the given callback when {::activatePreviousRecentlyUsedItem}
    // has been called, either initiating or continuing a reverse MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `previousRecentlyUsedItem` The previous MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onChooseLastMRUItem(callback) {
    }
    // Public: Invoke the given callback when {::moveActiveItemToTopOfStack}
    // has been called, terminating an MRU traversal of pane items and moving the
    // current active item to the top of the stack. Typically bound to a modifier
    // (e.g. CTRL) key up event.
    //
    // * `callback` {Function} to be called with when the MRU traversal is done.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDoneChoosingMRUItem(callback) {
    }
    // Public: Invoke the given callback with the current and future values of
    // {::getActiveItem}.
    //
    // * `callback` {Function} to be called with the current and future active
    //   items.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeActiveItem(callback) {
        callback(this.getActiveItem());
        return this.onDidChangeActiveItem(callback);
    }
    // Public: Invoke the given callback before items are destroyed.
    //
    // * `callback` {Function} to be called before items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item that will be destroyed.
    //     * `index` The location of the item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to
    // unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillDestroyItem(callback) {
    }
    // Called by the view layer to indicate that the pane has gained focus.
    /**
     * @return {?}
     */
    focus() {
        this.focused = true;
        return this.activate();
    }
    // Called by the view layer to indicate that the pane has lost focus.
    /**
     * @return {?}
     */
    blur() {
        this.focused = false;
        return true; // if this is called from an event handler, don't cancel it
    }
    /**
     * @return {?}
     */
    isFocused() { return this.focused; }
    /**
     * @return {?}
     */
    getPanes() { return [this]; }
    /**
     * @param {?} item
     * @return {?}
     */
    unsubscribeFromItem(item) {
        /** @type {?} */
        const subscription = this.subscriptionsPerItem.get(item);
        if (subscription) {
            subscription.dispose();
            this.subscriptionsPerItem.delete(item);
        }
    }
    /*
      Section: Items
      */
    // Public: Get the items in this pane.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    getItems() {
        return this.items.slice();
    }
    // Public: Get the active pane item in this pane.
    //
    // Returns a pane item.
    /**
     * @return {?}
     */
    getActiveItem() { return this.activeItem; }
    /**
     * @param {?=} activeItem
     * @param {?=} options
     * @return {?}
     */
    setActiveItem(activeItem, options) {
        /** @type {?} */
        const modifyStack = options && options.modifyStack;
        if (activeItem !== this.activeItem) {
            if (modifyStack !== false) {
                this.addItemToStack(activeItem);
            }
            this.emitter.emit('doing-change-active-item', this.activeItem);
            this.activeItem = activeItem;
            this.emitter.emit('did-change-active-item', this.activeItem);
            if (this.container) {
                this.container.didChangeActiveItemOnPane(this, this.activeItem);
            }
        }
        return this.activeItem;
    }
    // Build the itemStack after deserializing
    /**
     * @param {?} itemStackIndices
     * @return {?}
     */
    addItemsToStack(itemStackIndices) {
        if (this.items.length > 0) {
            if (itemStackIndices.length !== this.items.length || itemStackIndices.includes(-1)) {
                itemStackIndices = this.items.map((item, i) => i);
            }
            for (const itemIndex of itemStackIndices) {
                this.addItemToStack(this.items[itemIndex]);
            }
        }
    }
    // Add item (or move item) to the end of the itemStack
    /**
     * @param {?} newItem
     * @return {?}
     */
    addItemToStack(newItem) {
        if (newItem == null) {
            return;
        }
        /** @type {?} */
        const index = this.itemStack.indexOf(newItem);
        if (index !== -1) {
            this.itemStack.splice(index, 1);
        }
        return this.itemStack.push(newItem);
    }
    // Public: Return the item at the given index.
    //
    // * `index` {Number}
    //
    // Returns an item or `null` if no item exists at the given index.
    /**
     * @param {?} index
     * @return {?}
     */
    itemAtIndex(index) {
        return this.items[index];
    }
    // Makes the next item in the itemStack active.
    /**
     * @return {?}
     */
    activateNextRecentlyUsedItem() {
        if (this.items.length > 1) {
            if (this.itemStackIndex == null) {
                this.itemStackIndex = this.itemStack.length - 1;
            }
            if (this.itemStackIndex === 0) {
                this.itemStackIndex = this.itemStack.length;
            }
            this.itemStackIndex--;
            /** @type {?} */
            const nextRecentlyUsedItem = this.itemStack[this.itemStackIndex];
            this.setActiveItem(nextRecentlyUsedItem, { modifyStack: false });
        }
    }
    // Makes the previous item in the itemStack active.
    /**
     * @return {?}
     */
    activatePreviousRecentlyUsedItem() {
        if (this.items.length > 1) {
            if (this.itemStackIndex + 1 === this.itemStack.length || this.itemStackIndex == null) {
                this.itemStackIndex = -1;
            }
            this.itemStackIndex++;
            /** @type {?} */
            const previousRecentlyUsedItem = this.itemStack[this.itemStackIndex];
            this.setActiveItem(previousRecentlyUsedItem, { modifyStack: false });
        }
    }
    // Moves the active item to the end of the itemStack once the ctrl key is lifted
    /**
     * @return {?}
     */
    moveActiveItemToTopOfStack() {
        delete this.itemStackIndex;
        this.addItemToStack(this.activeItem);
    }
    // Public: Makes the next item active.
    /**
     * @return {?}
     */
    activateNextItem() {
        /** @type {?} */
        const index = this.getActiveItemIndex();
        if (index < (this.items.length - 1)) {
            this.activateItemAtIndex(index + 1);
        }
        else {
            this.activateItemAtIndex(0);
        }
    }
    // Public: Makes the previous item active.
    /**
     * @return {?}
     */
    activatePreviousItem() {
        /** @type {?} */
        const index = this.getActiveItemIndex();
        if (index > 0) {
            this.activateItemAtIndex(index - 1);
        }
        else {
            this.activateItemAtIndex(this.items.length - 1);
        }
    }
    /**
     * @return {?}
     */
    activateLastItem() {
        this.activateItemAtIndex(this.items.length - 1);
    }
    // Public: Move the active tab to the right.
    /**
     * @return {?}
     */
    moveItemRight() {
        /** @type {?} */
        const index = this.getActiveItemIndex();
        /** @type {?} */
        const rightItemIndex = index + 1;
        if (rightItemIndex <= this.items.length - 1) {
            this.moveItem(this.getActiveItem(), rightItemIndex);
        }
    }
    // Public: Move the active tab to the left
    /**
     * @return {?}
     */
    moveItemLeft() {
        /** @type {?} */
        const index = this.getActiveItemIndex();
        /** @type {?} */
        const leftItemIndex = index - 1;
        if (leftItemIndex >= 0) {
            return this.moveItem(this.getActiveItem(), leftItemIndex);
        }
    }
    // Public: Get the index of the active item.
    //
    // Returns a {Number}.
    /**
     * @return {?}
     */
    getActiveItemIndex() {
        return this.items.indexOf(this.activeItem);
    }
    // Public: Activate the item at the given index.
    //
    // * `index` {Number}
    /**
     * @param {?} index
     * @return {?}
     */
    activateItemAtIndex(index) {
        /** @type {?} */
        const item = this.itemAtIndex(index) || this.getActiveItem();
        return this.setActiveItem(item);
    }
    // Public: Make the given item *active*, causing it to be displayed by
    // the pane's view.
    //
    // * `item` The item to activate
    // * `options` (optional) {Object}
    //   * `pending` (optional) {Boolean} indicating that the item should be added
    //     in a pending state if it does not yet exist in the pane. Existing pending
    //     items in a pane are replaced with new pending items when they are opened.
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    activateItem(item, options = {}) {
        if (item) {
            /** @type {?} */
            const index = (this.getPendingItem() === this.activeItem)
                ? this.getActiveItemIndex()
                : this.getActiveItemIndex() + 1;
            this.addItem(item, Object.assign({}, options, { index }));
            this.setActiveItem(item);
        }
    }
    // Public: Add the given item to the pane.
    //
    // * `item` The item to add. It can be a model with an associated view or a
    //   view.
    // * `options` (optional) {Object}
    //   * `index` (optional) {Number} indicating the index at which to add the item.
    //     If omitted, the item is added after the current active item.
    //   * `pending` (optional) {Boolean} indicating that the item should be
    //     added in a pending state. Existing pending items in a pane are replaced with
    //     new pending items when they are opened.
    //
    // Returns the added item.
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    addItem(item, options = {}) {
        // Backward compat with old API:
        //   addItem(item, index=@getActiveItemIndex() + 1)
        if (typeof options === 'number') {
            options = { index: options };
        }
        /** @type {?} */
        const index = options.index != null ? options.index : this.getActiveItemIndex() + 1;
        /** @type {?} */
        const moved = options.moved != null ? options.moved : false;
        /** @type {?} */
        const pending = options.pending != null ? options.pending : false;
        if (!item || typeof item !== 'object') {
            throw new Error(`Pane items must be objects. Attempted to add item ${item}.`);
        }
        if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {
            throw new Error(`Adding a pane item with URI
      '${typeof item.getURI === 'function' && item.getURI()}' that has already been destroyed`);
        }
        if (this.items.find(it => it === item)) {
            return;
        }
        if (typeof item.onDidDestroy === 'function') ;
        this.items.splice(index, 0, item);
        /** @type {?} */
        const lastPendingItem = this.getPendingItem();
        /** @type {?} */
        const replacingPendingItem = lastPendingItem != null && !moved;
        if (replacingPendingItem) {
            this.pendingItem = null;
        }
        if (pending) {
            this.setPendingItem(item);
        }
        this.emitter.emit('did-add-item', { item, index, moved });
        if (!moved) {
            if (this.container) {
                this.container.didAddPaneItem(item, this, index);
            }
        }
        if (replacingPendingItem) {
            this.destroyItem(lastPendingItem);
        }
        if (!this.getActiveItem()) {
            this.setActiveItem(item);
        }
        return item;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    setPendingItem(item) {
        if (this.pendingItem !== item) {
            /** @type {?} */
            const mostRecentPendingItem = this.pendingItem;
            this.pendingItem = item;
        }
    }
    /**
     * @return {?}
     */
    getPendingItem() {
        return this.pendingItem || null;
    }
    /**
     * @return {?}
     */
    clearPendingItem() {
        this.setPendingItem(null);
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onItemDidTerminatePendingState(callback) {
    }
    // Public: Add the given items to the pane.
    //
    // * `items` An {Array} of items to add. Items can be views or models with
    //   associated views. Any objects that are already present in the pane's
    //   current items will not be added again.
    // * `index` (optional) {Number} index at which to add the items. If omitted,
    //   the item is #   added after the current active item.
    //
    // Returns an {Array} of added items.
    /**
     * @param {?} items
     * @param {?=} index
     * @return {?}
     */
    addItems(items, index = this.getActiveItemIndex() + 1) {
        items = items.filter(item => !this.items.find(it => it === item));
        for (let i = 0; i < items.length; i++) {
            /** @type {?} */
            const item = items[i];
            this.addItem(item, { index: index + i });
        }
        return items;
    }
    /**
     * @param {?} item
     * @param {?=} moved
     * @return {?}
     */
    removeItem(item, moved = false) {
        /** @type {?} */
        const index = this.items.indexOf(item);
        if (index === -1) {
            return;
        }
        if (this.getPendingItem() === item) {
            this.pendingItem = null;
        }
        this.removeItemFromStack(item);
        // this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved});
        this.unsubscribeFromItem(item);
        if (item === this.activeItem) {
            if (this.items.length === 1) {
                this.setActiveItem(undefined);
            }
            else if (index === 0) {
                this.activateNextItem();
            }
            else {
                this.activatePreviousItem();
            }
        }
        this.items.splice(index, 1);
        this.emitter.emit('did-remove-item', { item, index, destroyed: !moved, moved });
        if (!moved && this.container) {
            this.container.didDestroyPaneItem({ item, index, pane: this });
        }
        if (this.items.length === 0 && this.config && this.config.get && this.config.get('core.destroyEmptyPanes')) {
            this.destroy();
        }
    }
    // Remove the given item from the itemStack.
    //
    // * `item` The item to remove.
    // * `index` {Number} indicating the index to which to remove the item from the itemStack.
    /**
     * @param {?} item
     * @return {?}
     */
    removeItemFromStack(item) {
        /** @type {?} */
        const index = this.itemStack.indexOf(item);
        if (index !== -1) {
            this.itemStack.splice(index, 1);
        }
    }
    // Public: Move the given item to the given index.
    //
    // * `item` The item to move.
    // * `index` {Number} indicating the index to which to move the item.
    /**
     * @param {?} item
     * @param {?} newIndex
     * @return {?}
     */
    moveItem(item, newIndex) {
        /** @type {?} */
        const oldIndex = this.items.indexOf(item);
        this.items.splice(oldIndex, 1);
        this.items.splice(newIndex, 0, item);
    }
    // Public: Move the given item to the given index on another pane.
    //
    // * `item` The item to move.
    // * `pane` {Pane} to which to move the item.
    // * `index` {Number} indicating the index to which to move the item in the
    //   given pane.
    /**
     * @param {?=} item
     * @param {?=} pane
     * @param {?=} index
     * @return {?}
     */
    moveItemToPane(item, pane, index) {
        this.removeItem(item, true);
        return pane.addItem(item, { index, moved: true });
    }
    // Public: Destroy the active item and activate the next item.
    //
    // Returns a {Promise} that resolves when the item is destroyed.
    /**
     * @return {?}
     */
    destroyActiveItem() {
        return this.destroyItem(this.activeItem);
    }
    // Public: Destroy the given item.
    //
    // If the item is active, the next item will be activated. If the item is the
    // last item, the pane will be destroyed if the `core.destroyEmptyPanes` config
    // setting is `true`.
    //
    // * `item` Item to destroy
    // * `force` (optional) {Boolean} Destroy the item without prompting to save
    //    it, even if the item's `isPermanentDockItem` method returns true.
    //
    // Returns a {Promise} that resolves with a {Boolean} indicating whether or not
    // the item was destroyed.
    /**
     * @param {?=} item
     * @param {?=} force
     * @return {?}
     */
    destroyItem(item, force) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const index = this.items.indexOf(item);
            if (index === -1) {
                return false;
            }
            if (!force &&
                typeof item.isPermanentDockItem === 'function' && item.isPermanentDockItem() &&
                (!this.container || this.container.getLocation() !== 'center')) {
                return false;
            }
            // In the case where there are no `onWillDestroyPaneItem` listeners, preserve the old behavior
            // where `Pane.destroyItem` and callers such as `Pane.close` take effect synchronously.
            this.removeItem(item, false);
            if (typeof item.destroy === 'function') {
                item.destroy();
            }
            return true;
        });
    }
    // Public: Destroy all items.
    /**
     * @return {?}
     */
    destroyItems() {
        return Promise.all(this.getItems().map(item => this.destroyItem(item)));
    }
    // Public: Destroy all items except for the active item.
    /**
     * @return {?}
     */
    destroyInactiveItems() {
        return Promise.all(this.getItems()
            .filter(item => item !== this.activeItem)
            .map(item => this.destroyItem(item)));
    }
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    promptToSaveItem(item, options = {}) {
        if (typeof item.shouldPromptToSave !== 'function' || !item.shouldPromptToSave(options)) {
            return Promise.resolve(true);
        }
        /** @type {?} */
        let uri;
        if (typeof item.getURI === 'function') {
            uri = item.getURI();
        }
        else if (typeof item.getUri === 'function') {
            uri = item.getUri();
        }
        else {
            return Promise.resolve(true);
        }
        /** @type {?} */
        const title = (typeof item.getTitle === 'function' && item.getTitle()) || uri;
        /** @type {?} */
        const saveDialog = (saveButtonText, saveFn, message) => {
            /** @type {?} */
            const chosen = this.applicationDelegate.confirm({
                message,
                detailedMessage: 'Your changes will be lost if you close this item without saving.',
                buttons: [saveButtonText, 'Cancel', '&Don\'t Save']
            });
            switch (chosen) {
                case 0:
                    return new Promise(resolve => {
                        return saveFn(item, error => {
                            if (error instanceof SaveCancelledError) {
                                resolve(false);
                            }
                            else if (error) {
                                saveDialog('Save as', this.saveItemAs, `'${title}' could not be saved.\nError: ${this.getMessageForErrorCode(error.code)}`).then(resolve);
                            }
                            else {
                                resolve(true);
                            }
                        });
                    });
                case 1:
                    return Promise.resolve(false);
                case 2:
                    return Promise.resolve(true);
            }
        };
        return saveDialog('Save', this.saveItem, `'${title}' has changes, do you want to save them?`);
    }
    // Public: Save the active item.
    /**
     * @param {?=} nextAction
     * @return {?}
     */
    saveActiveItem(nextAction) {
        return this.saveItem(this.getActiveItem(), nextAction);
    }
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `nextAction` (optional) {Function} which will be called after the item is
    //   successfully saved.
    //
    // Returns a {Promise} that resolves when the save is complete
    /**
     * @param {?=} nextAction
     * @return {?}
     */
    saveActiveItemAs(nextAction) {
        return this.saveItemAs(this.getActiveItem(), nextAction);
    }
    // Public: Save the given item.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    //
    // Returns a {Promise} that resolves when the save is complete
    /**
     * @param {?} item
     * @param {?} nextAction
     * @return {?}
     */
    saveItem(item, nextAction) {
        if (!item) {
            return Promise.resolve();
        }
        /** @type {?} */
        let itemURI;
        if (typeof item.getURI === 'function') {
            itemURI = item.getURI();
        }
        else if (typeof item.getUri === 'function') {
            itemURI = item.getUri();
        }
        if (itemURI != null) {
            if (typeof item.save === 'function') {
                return promisify(() => item.save())
                    .then(() => {
                    if (nextAction) {
                        nextAction();
                    }
                })
                    .catch(error => {
                    if (nextAction) {
                        nextAction(error);
                    }
                    else {
                        this.handleSaveError(error, item);
                    }
                });
            }
            else if (nextAction) {
                nextAction();
                return Promise.resolve();
            }
        }
        else {
            return this.saveItemAs(item, nextAction);
        }
    }
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    /**
     * @param {?} item
     * @param {?} nextAction
     * @return {?}
     */
    saveItemAs(item, nextAction) {
    }
    // Public: Save all items.
    /**
     * @return {?}
     */
    saveItems() {
    }
    // Public: Return the first item that matches the given URI or undefined if
    // none exists.
    //
    // * `uri` {String} containing a URI.
    /**
     * @param {?} uri
     * @return {?}
     */
    itemForURI(uri) {
        return this.items.find(item => {
            if (typeof item.getURI === 'function') {
                return item.getURI() === uri;
            }
            else if (typeof item.getUri === 'function') {
                return item.getUri() === uri;
            }
        });
    }
    // Public: Activate the first item that matches the given URI.
    //
    // * `uri` {String} containing a URI.
    //
    // Returns a {Boolean} indicating whether an item matching the URI was found.
    /**
     * @param {?} uri
     * @return {?}
     */
    activateItemForURI(uri) {
        /** @type {?} */
        const item = this.itemForURI(uri);
        if (item) {
            this.activateItem(item);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    copyActiveItem() {
        if (this.activeItem && typeof this.activeItem.copy === 'function') {
            return this.activeItem.copy();
        }
    }
    /*
      Section: Lifecycle
      */
    // Public: Determine whether the pane is active.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    isActive() {
        return this.container && this.container.getActivePane() === this;
    }
    // Public: Makes this pane the *active* pane, causing it to gain focus.
    /**
     * @return {?}
     */
    activate() {
    }
    // Public: Close the pane and destroy all its items.
    //
    // If this is the last pane, all the items will be destroyed but the pane
    // itself will not be destroyed.
    /**
     * @return {?}
     */
    destroy() {
    }
    /**
     * @return {?}
     */
    isAlive() { return this.alive; }
    // Public: Determine whether this pane has been destroyed.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    isDestroyed() { return !this.isAlive(); }
    /*
      Section: Splitting
      */
    // Public: Create a new pane to the left of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    splitLeft(params) {
        return this.split('horizontal', 'before', params);
    }
    // Public: Create a new pane to the right of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    splitRight(params) {
        return this.split('horizontal', 'after', params);
    }
    // Public: Creates a new pane above the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    splitUp(params) {
        return this.split('vertical', 'before', params);
    }
    // Public: Creates a new pane below the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    splitDown(params) {
        return this.split('vertical', 'after', params);
    }
    /**
     * @param {?} orientation
     * @param {?} side
     * @param {?} params
     * @return {?}
     */
    split(orientation, side, params) {
        if (params && params.copyActiveItem) {
            if (!params.items) {
                params.items = [];
            }
            params.items.push(this.copyActiveItem());
        }
        if (this.parent.orientation !== orientation) {
            this.parent.replaceChild(this, new PaneAxis({
                container: this.container,
                orientation,
                children: [this],
                flexScale: this.flexScale
            }, this.viewRegistry));
            this.setFlexScale(1);
        }
        /** @type {?} */
        const newPane = new Pane(Object.assign({
            applicationDelegate: this.applicationDelegate,
            notificationManager: this.notificationManager,
            deserializerManager: this.deserializerManager,
            config: this.config,
            viewRegistry: this.viewRegistry
        }, params));
        switch (side) {
            case 'before':
                this.parent.insertChildBefore(this, newPane);
                break;
            case 'after':
                this.parent.insertChildAfter(this, newPane);
                break;
        }
        if (params && params.moveActiveItem && this.activeItem) {
            this.moveItemToPane(this.activeItem, newPane);
        }
        newPane.activate();
        return newPane;
    }
    // If the parent is a horizontal axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    /**
     * @return {?}
     */
    findLeftmostSibling() {
        if (this.parent.orientation === 'horizontal') {
            const [leftmostSibling] = this.parent.children;
            if (leftmostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return leftmostSibling;
            }
        }
        else {
            return this;
        }
    }
    /**
     * @return {?}
     */
    findRightmostSibling() {
        if (this.parent.orientation === 'horizontal') {
            /** @type {?} */
            const rightmostSibling = this.parent.children[this.parent.children.length - 1];
            if (rightmostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return rightmostSibling;
            }
        }
        else {
            return this;
        }
    }
    // If the parent is a horizontal axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane rightward.
    /**
     * @return {?}
     */
    findOrCreateRightmostSibling() {
        /** @type {?} */
        const rightmostSibling = this.findRightmostSibling();
        if (rightmostSibling === this) {
            return this.splitRight({});
        }
        else {
            return rightmostSibling;
        }
    }
    // If the parent is a vertical axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    /**
     * @return {?}
     */
    findTopmostSibling() {
        if (this.parent.orientation === 'vertical') {
            const [topmostSibling] = this.parent.children;
            if (topmostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return topmostSibling;
            }
        }
        else {
            return this;
        }
    }
    /**
     * @return {?}
     */
    findBottommostSibling() {
        if (this.parent.orientation === 'vertical') {
            /** @type {?} */
            const bottommostSibling = this.parent.children[this.parent.children.length - 1];
            if (bottommostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return bottommostSibling;
            }
        }
        else {
            return this;
        }
    }
    // If the parent is a vertical axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane bottomward.
    /**
     * @return {?}
     */
    findOrCreateBottommostSibling() {
        /** @type {?} */
        const bottommostSibling = this.findBottommostSibling();
        if (bottommostSibling === this) {
            return this.splitDown({});
        }
        else {
            return bottommostSibling;
        }
    }
    // Private: Close the pane unless the user cancels the action via a dialog.
    //
    // Returns a {Promise} that resolves once the pane is either closed, or the
    // closing has been cancelled.
    /**
     * @return {?}
     */
    close() {
        return Promise.all(this.getItems().map(item => this.promptToSaveItem(item)))
            .then(results => {
            if (!results.find(item => item === false)) {
                return this.destroy();
            }
        });
    }
    /**
     * @param {?} error
     * @param {?} item
     * @return {?}
     */
    handleSaveError(error, item) {
    }
    /**
     * @param {?} errorCode
     * @return {?}
     */
    getMessageForErrorCode(errorCode) {
        switch (errorCode) {
            case 'EACCES': return 'Permission denied';
            case 'ECONNRESET': return 'Connection reset';
            case 'EINTR': return 'Interrupted system call';
            case 'EIO': return 'I/O error writing file';
            case 'ENOSPC': return 'No space left on device';
            case 'ENOTSUP': return 'Operation not supported on socket';
            case 'ENXIO': return 'No such device or address';
            case 'EROFS': return 'Read-only file system';
            case 'ESPIPE': return 'Invalid seek';
            case 'ETIMEDOUT': return 'Connection timed out';
        }
    }
}
/**
 * @param {?} callback
 * @return {?}
 */
function promisify(callback) {
    try {
        return Promise.resolve(callback());
    }
    catch (error) {
        return Promise.reject(error);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ItemRegistry {
    constructor() {
        this.items = new WeakSet();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    addItem(item) {
        if (this.hasItem(item)) {
            throw new Error(`The workspace can only contain one instance of item ${item}`);
        }
        this.items.add(item);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    removeItem(item) {
        this.items.delete(item);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    hasItem(item) {
        return this.items.has(item);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SERIALIZATION_VERSION = 1;
class PaneContainer {
    /**
     * @param {?} params
     */
    constructor(params) {
        /** @type {?} */
        let applicationDelegate;
        /** @type {?} */
        let deserializerManager;
        /** @type {?} */
        let notificationManager;
        ({
            config: this.config,
            applicationDelegate,
            notificationManager,
            deserializerManager,
            viewRegistry: this.viewRegistry,
            location: this.location
        } = params);
        this.itemRegistry = new ItemRegistry();
        this.alive = true;
        this.setRoot(new Pane({
            container: this,
            config: this.config,
            applicationDelegate,
            notificationManager,
            deserializerManager,
            viewRegistry: this.viewRegistry
        }));
        this.didActivatePane(this.getRoot());
    }
    /**
     * @return {?}
     */
    getLocation() { return this.location; }
    /**
     * @return {?}
     */
    getElement() {
    }
    /**
     * @return {?}
     */
    destroy() {
        this.alive = false;
        for (const pane of this.getRoot().getPanes()) {
            pane.destroy();
        }
    }
    /**
     * @return {?}
     */
    isAlive() { return this.alive; }
    /**
     * @return {?}
     */
    isDestroyed() { return !this.isAlive(); }
    /**
     * @param {...?} params
     * @return {?}
     */
    serialize(...params) {
        return {
            deserializer: 'PaneContainer',
            version: SERIALIZATION_VERSION,
            root: this.root ? this.root.serialize() : null,
            activePaneId: this.activePane.id
        };
    }
    /**
     * @param {?} state
     * @param {?} deserializerManager
     * @return {?}
     */
    deserialize(state, deserializerManager) {
        if (state.version !== SERIALIZATION_VERSION) {
            return;
        }
        this.setRoot(deserializerManager.deserialize(state.root));
        this.activePane = this.getRoot().getPanes().find(pane => pane.id === state.activePaneId) || this.getPanes()[0];
        if (this.config && this.config.get && this.config.get('core.destroyEmptyPanes')) {
            this.destroyEmptyPanes();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidChangeRoot(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    observeRoot(fn) {
        fn(this.getRoot());
        return this.onDidChangeRoot(fn);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidAddPane(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    observePanes(fn) {
        for (const pane of this.getPanes()) {
            fn(pane);
        }
        return this.onDidAddPane(({ pane }) => fn(pane));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidDestroyPane(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onWillDestroyPane(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidChangeActivePane(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidActivatePane(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    observeActivePane(fn) {
        fn(this.getActivePane());
        return this.onDidChangeActivePane(fn);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidAddPaneItem(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    observePaneItems(fn) {
        for (const item of this.getPaneItems()) {
            fn(item);
        }
        return this.onDidAddPaneItem(({ item }) => fn(item));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidChangeActivePaneItem(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidStopChangingActivePaneItem(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    observeActivePaneItem(fn) {
        fn(this.getActivePaneItem());
        return this.onDidChangeActivePaneItem(fn);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onWillDestroyPaneItem(fn) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDidDestroyPaneItem(fn) {
    }
    /**
     * @return {?}
     */
    getRoot() { return this.root; }
    /**
     * @param {?} root
     * @return {?}
     */
    setRoot(root) {
        this.root = root;
        this.root.setParent(this);
        this.root.setContainer(this);
        if ((this.getActivePane() == null) && this.root instanceof Pane) {
            this.didActivatePane(this.root);
        }
    }
    /**
     * @param {?} oldChild
     * @param {?} newChild
     * @return {?}
     */
    replaceChild(oldChild, newChild) {
        if (oldChild !== this.root) {
            throw new Error('Replacing non-existent child');
        }
        this.setRoot(newChild);
    }
    /**
     * @return {?}
     */
    getPanes() {
        if (this.alive) {
            return this.getRoot().getPanes();
        }
        else {
            return [];
        }
    }
    /**
     * @return {?}
     */
    getPaneItems() {
        return this.getRoot().getItems();
    }
    /**
     * @return {?}
     */
    getActivePane() {
        return this.activePane;
    }
    /**
     * @return {?}
     */
    getActivePaneItem() {
        return this.getActivePane().getActiveItem();
    }
    /**
     * @param {?} uri
     * @return {?}
     */
    paneForURI(uri) {
        return this.getPanes().find(pane => pane.itemForURI(uri) != null);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    paneForItem(item) {
        return this.getPanes().find(pane => pane.getItems().find(it => it === item));
    }
    /**
     * @return {?}
     */
    saveAll() {
        for (const pane of this.getPanes()) {
            pane.saveItems();
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    confirmClose(options) {
        /** @type {?} */
        const promises = [];
        for (const pane of this.getPanes()) {
            for (const item of pane.getItems()) {
                promises.push(pane.promptToSaveItem(item, options));
            }
        }
        return Promise.all(promises).then((results) => !results.find(item => item === false));
    }
    /**
     * @return {?}
     */
    activateNextPane() {
        /** @type {?} */
        const panes = this.getPanes();
        if (panes.length > 1) {
            /** @type {?} */
            const currentIndex = panes.indexOf(this.activePane);
            /** @type {?} */
            const nextIndex = (currentIndex + 1) % panes.length;
            panes[nextIndex].activate();
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    activatePreviousPane() {
        /** @type {?} */
        const panes = this.getPanes();
        if (panes.length > 1) {
            /** @type {?} */
            const currentIndex = panes.indexOf(this.activePane);
            /** @type {?} */
            let previousIndex = currentIndex - 1;
            if (previousIndex < 0) {
                previousIndex = panes.length - 1;
            }
            panes[previousIndex].activate();
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} destPane
     * @return {?}
     */
    moveActiveItemToPane(destPane) {
        /** @type {?} */
        const item = this.activePane.getActiveItem();
        if (!destPane.isItemAllowed(item)) {
            return;
        }
        this.activePane.moveItemToPane(item, destPane);
        destPane.setActiveItem(item);
    }
    /**
     * @param {?} destPane
     * @return {?}
     */
    copyActiveItemToPane(destPane) {
        /** @type {?} */
        const item = this.activePane.copyActiveItem();
        if (item && destPane.isItemAllowed(item)) {
            destPane.activateItem(item);
        }
    }
    /**
     * @return {?}
     */
    destroyEmptyPanes() {
        for (const pane of this.getPanes()) {
            if (pane.items.length === 0) {
                pane.destroy();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    didAddPane(event) {
        /** @type {?} */
        const items = event.pane.getItems();
        for (let i = 0, length = items.length; i < length; i++) {
            /** @type {?} */
            const item = items[i];
            this.didAddPaneItem(item, event.pane, i);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    willDestroyPane(event) {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    didDestroyPane(event) {
    }
    /**
     * @param {?} activePane
     * @return {?}
     */
    didActivatePane(activePane) {
        if (activePane !== this.activePane) {
            if (!this.getPanes().find(item => item === activePane)) {
                throw new Error('Setting active pane that is not present in pane container');
            }
            this.activePane = activePane;
            this.didChangeActiveItemOnPane(this.activePane, this.activePane.getActiveItem());
        }
        return this.activePane;
    }
    /**
     * @param {?} item
     * @param {?} pane
     * @param {?} index
     * @return {?}
     */
    didAddPaneItem(item, pane, index) {
        this.itemRegistry.addItem(item);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    willDestroyPaneItem(event) {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    didDestroyPaneItem(event) {
        this.itemRegistry.removeItem(event.item);
        // this.emitter.emit('did-destroy-pane-item', event);
    }
    /**
     * @param {?} pane
     * @param {?} activeItem
     * @return {?}
     */
    didChangeActiveItemOnPane(pane, activeItem) {
        if (pane === this.getActivePane()) {
            this.cancelStoppedChangingActivePaneItemTimeout();
            // `setTimeout()` isn't available during the snapshotting phase, but that's okay.
        }
    }
    /**
     * @return {?}
     */
    cancelStoppedChangingActivePaneItemTimeout() {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const DockStyle = {
    none: 0,
    left: 1,
    right: 2,
    top: 3,
    bottom: 4,
};
DockStyle[DockStyle.none] = 'none';
DockStyle[DockStyle.left] = 'left';
DockStyle[DockStyle.right] = 'right';
DockStyle[DockStyle.top] = 'top';
DockStyle[DockStyle.bottom] = 'bottom';
class Dock {
    /**
     * @param {?} params
     */
    constructor(params) {
        this.handleResizeHandleDragStart = this.handleResizeHandleDragStart.bind(this);
        this.handleResizeToFit = this.handleResizeToFit.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.location = params.location;
        this.widthOrHeight = getWidthOrHeight(this.location);
        this.viewRegistry = params.viewRegistry;
        this.didActivate = params.didActivate;
        this.emitter = new Emitter();
        this.paneContainer = new PaneContainer({
            location: this.location,
            viewRegistry: this.viewRegistry
        });
        this.state = {
            size: null,
            visible: false,
            shouldAnimate: false
        };
    }
    // This method is called explicitly by the object which adds the Dock to the document.
    /**
     * @return {?}
     */
    elementAttached() {
        // Re-render when the dock is attached to make sure we remeasure sizes defined in CSS.
        this.render(this.state);
    }
    /**
     * @return {?}
     */
    getElement() {
    }
    /**
     * @return {?}
     */
    getLocation() {
        return this.location;
    }
    /**
     * @return {?}
     */
    destroy() {
        this.paneContainer.destroy();
        // window.removeEventListener('mousemove', this.handleMouseMove);
        // window.removeEventListener('mouseup', this.handleMouseUp);
        // window.removeEventListener('drag', this.handleDrag);
        // window.removeEventListener('dragend', this.handleDragEnd);
    }
    /**
     * @param {?} hovered
     * @return {?}
     */
    setHovered(hovered) {
        if (hovered === this.state.hovered) {
            return;
        }
        this.setState({ hovered });
    }
    /**
     * @param {?} draggingItem
     * @return {?}
     */
    setDraggingItem(draggingItem) {
        if (draggingItem === this.state.draggingItem) {
            return;
        }
        this.setState({ draggingItem });
    }
    // Extended: Show the dock and focus its active {Pane}.
    /**
     * @return {?}
     */
    activate() {
        this.getActivePane().activate();
    }
    // Extended: Show the dock without focusing it.
    /**
     * @return {?}
     */
    show() {
        this.setState({ visible: true });
    }
    // Extended: Hide the dock and activate the {WorkspaceCenter} if the dock was
    // was previously focused.
    /**
     * @return {?}
     */
    hide() {
        this.setState({ visible: false });
    }
    // Extended: Toggle the dock's visibility without changing the {Workspace}'s
    // active pane container.
    /**
     * @return {?}
     */
    toggle() {
        // const state = { visible: !this.state.visible };
        // if (!state.visible) { state.hovered = false; }
        // this.setState(state);
    }
    // Extended: Check if the dock is visible.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    isVisible() {
        return this.state.visible;
    }
    /**
     * @param {?} newState
     * @return {?}
     */
    setState(newState) {
        /** @type {?} */
        const prevState = this.state;
        /** @type {?} */
        const nextState = Object.assign({}, prevState, newState);
        // Update the `shouldAnimate` state. This needs to be written to the DOM before updating the
        // class that changes the animated property. Normally we'd have to defer the class change a
        // frame to ensure the property is animated (or not) appropriately, however we luck out in this
        // case because the drag start always happens before the item is dragged into the toggle button.
        if (nextState.visible !== prevState.visible) {
            // Never animate toggling visibility...
            nextState.shouldAnimate = false;
        }
        else if (!nextState.visible && nextState.draggingItem && !prevState.draggingItem) {
            // ...but do animate if you start dragging while the panel is hidden.
            nextState.shouldAnimate = true;
        }
        this.state = nextState;
        this.render(this.state);
        const { visible } = this.state;
        // if (visible !== prevState.visible) {
        //   this.emitter.emit('did-change-visible', visible);
        // }
    }
    /**
     * @param {?} state
     * @return {?}
     */
    render(state) {
    }
    /**
     * @return {?}
     */
    handleDidAddPaneItem() {
        if (this.state.size == null) {
            this.setState({ size: this.getInitialSize() });
        }
    }
    /**
     * @return {?}
     */
    handleDidRemovePaneItem() {
        // Hide the dock if you remove the last item.
        if (this.paneContainer.getPaneItems().length === 0) {
            this.setState({ visible: false, hovered: false, size: null });
        }
    }
    /**
     * @return {?}
     */
    handleResizeHandleDragStart() {
        window.addEventListener('mousemove', this.handleMouseMove);
        window.addEventListener('mouseup', this.handleMouseUp);
        this.setState({ resizing: true });
    }
    /**
     * @return {?}
     */
    handleResizeToFit() {
        /** @type {?} */
        const item = this.getActivePaneItem();
        if (item) {
            /** @type {?} */
            const size = getPreferredSize(item, this.getLocation());
            if (size != null) {
                this.setState({ size });
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleMouseMove(event) {
        if (event.buttons === 0) { // We missed the mouseup event. For some reason it happens on Windows
            this.handleMouseUp(event);
            return;
        }
        /** @type {?} */
        const size = 0;
        // switch (this.location) {
        //   case 'left':
        //     size = event.pageX - this.element.getBoundingClientRect().left;
        //     break;
        //   case 'bottom':
        //     size = this.element.getBoundingClientRect().bottom - event.pageY;
        //     break;
        //   case 'right':
        //     size = this.element.getBoundingClientRect().right - event.pageX;
        //     break;
        // }
        this.setState({ size });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleMouseUp(event) {
        window.removeEventListener('mousemove', this.handleMouseMove);
        window.removeEventListener('mouseup', this.handleMouseUp);
        this.setState({ resizing: false });
    }
    // Determine whether the cursor is within the dock hover area. This isn't as simple as just using
    // mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is
    // over the footer, we want to show the bottom dock's toggle button. Also note that our criteria
    // for detecting entry are different than detecting exit but, in order for us to avoid jitter, the
    // area considered when detecting exit MUST fully encompass the area considered when detecting
    // entry.
    /**
     * @param {?} point
     * @param {?} detectingExit
     * @return {?}
     */
    pointWithinHoverArea(point, detectingExit) {
    }
    /**
     * @return {?}
     */
    getInitialSize() {
        // The item may not have been activated yet. If that's the case, just use the first item.
        /** @type {?} */
        const activePaneItem = this.paneContainer.getActivePaneItem() || this.paneContainer.getPaneItems()[0];
        // If there are items, we should have an explicit width; if not, we shouldn't.
        return activePaneItem
            ? getPreferredSize(activePaneItem, this.location)
            : null;
    }
    /**
     * @return {?}
     */
    serialize() {
        return {
            deserializer: 'Dock',
            size: this.state.size,
            paneContainer: this.paneContainer.serialize({}),
            visible: this.state.visible
        };
    }
    /**
     * @param {?} serialized
     * @param {?} deserializerManager
     * @return {?}
     */
    deserialize(serialized, deserializerManager) {
        this.paneContainer.deserialize(serialized.paneContainer, deserializerManager);
        this.setState({
            size: serialized.size || this.getInitialSize(),
            // If no items could be deserialized, we don't want to show the dock (even if it was visible last time)
            visible: serialized.visible && (this.paneContainer.getPaneItems().length > 0)
        });
    }
    /*
      Section: Event Subscription
      */
    // Essential: Invoke the given callback when the visibility of the dock changes.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeVisible(callback) {
    }
    // Essential: Invoke the given callback with the current and all future visibilities of the dock.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeVisible(callback) {
        callback(this.isVisible());
        return this.onDidChangeVisible(callback);
    }
    // Essential: Invoke the given callback with all current and future panes items
    // in the dock.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observePaneItems(callback) {
        return this.paneContainer.observePaneItems(callback);
    }
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeActivePaneItem(callback) {
        return this.paneContainer.onDidChangeActivePaneItem(callback);
    }
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidStopChangingActivePaneItem(callback) {
        return this.paneContainer.onDidStopChangingActivePaneItem(callback);
    }
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the dock.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeActivePaneItem(callback) {
        return this.paneContainer.observeActivePaneItem(callback);
    }
    // Extended: Invoke the given callback when a pane is added to the dock.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidAddPane(callback) {
        return this.paneContainer.onDidAddPane(callback);
    }
    // Extended: Invoke the given callback before a pane is destroyed in the
    // dock.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillDestroyPane(callback) {
        return this.paneContainer.onWillDestroyPane(callback);
    }
    // Extended: Invoke the given callback when a pane is destroyed in the dock.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDestroyPane(callback) {
        return this.paneContainer.onDidDestroyPane(callback);
    }
    // Extended: Invoke the given callback with all current and future panes in the
    // dock.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observePanes(callback) {
        return this.paneContainer.observePanes(callback);
    }
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeActivePane(callback) {
        return this.paneContainer.onDidChangeActivePane(callback);
    }
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeActivePane(callback) {
        return this.paneContainer.observeActivePane(callback);
    }
    // Extended: Invoke the given callback when a pane item is added to the dock.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidAddPaneItem(callback) {
        return this.paneContainer.onDidAddPaneItem(callback);
    }
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillDestroyPaneItem(callback) {
        return this.paneContainer.onWillDestroyPaneItem(callback);
    }
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDestroyPaneItem(callback) {
        return this.paneContainer.onDidDestroyPaneItem(callback);
    }
    // Extended: Invoke the given callback when the hovered state of the dock changes.
    //
    // * `callback` {Function} to be called when the hovered state changes.
    //   * `hovered` {Boolean} Is the dock now hovered?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeHovered(callback) {
        return this.emitter.on('did-change-hovered', callback);
    }
    /*
      Section: Pane Items
      */
    // Essential: Get all pane items in the dock.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    getPaneItems() {
        return this.paneContainer.getPaneItems();
    }
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    /**
     * @return {?}
     */
    getActivePaneItem() {
        return this.paneContainer.getActivePaneItem();
    }
    // Save all pane items.
    /**
     * @return {?}
     */
    saveAll() {
        this.paneContainer.saveAll();
    }
    /**
     * @param {?} options
     * @return {?}
     */
    confirmClose(options) {
        return this.paneContainer.confirmClose(options);
    }
    /*
      Section: Panes
      */
    // Extended: Get all panes in the dock.
    //
    // Returns an {Array} of {Pane}s.
    /**
     * @return {?}
     */
    getPanes() {
        return this.paneContainer.getPanes();
    }
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    /**
     * @return {?}
     */
    getActivePane() {
        return this.paneContainer.getActivePane();
    }
    // Extended: Make the next pane active.
    /**
     * @return {?}
     */
    activateNextPane() {
        return this.paneContainer.activateNextPane();
    }
    // Extended: Make the previous pane active.
    /**
     * @return {?}
     */
    activatePreviousPane() {
        return this.paneContainer.activatePreviousPane();
    }
    /**
     * @param {?} uri
     * @return {?}
     */
    paneForURI(uri) {
        return this.paneContainer.paneForURI(uri);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    paneForItem(item) {
        return this.paneContainer.paneForItem(item);
    }
    // Destroy (close) the active pane.
    /**
     * @return {?}
     */
    destroyActivePane() {
        /** @type {?} */
        const activePane = this.getActivePane();
        if (activePane != null) {
            activePane.destroy();
        }
    }
}
/**
 * @param {?} location
 * @return {?}
 */
function getWidthOrHeight(location) {
    return location === 'left' || location === 'right' ? 'width' : 'height';
}
/**
 * @param {?} item
 * @param {?} location
 * @return {?}
 */
function getPreferredSize(item, location) {
    switch (location) {
        case 'left':
        case 'right':
            return typeof item.getPreferredWidth === 'function'
                ? item.getPreferredWidth()
                : null;
        default:
            return typeof item.getPreferredHeight === 'function'
                ? item.getPreferredHeight()
                : null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract cache storage
 * @abstract
 */
class CacheStorageAbstract {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in session storage
 */
class CacheSessionStorage extends CacheStorageAbstract {
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        /** @type {?} */
        const value = sessionStorage.getItem(key);
        return value ? JSON.parse(value) : null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setItem(key, value) {
        try {
            sessionStorage.setItem(key, JSON.stringify(value));
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        sessionStorage.removeItem(key);
    }
    /**
     * @return {?}
     */
    clear() {
        sessionStorage.clear();
    }
    /**
     * @return {?}
     */
    type() {
        return 1 /* SESSION_STORAGE */;
    }
    /**
     * @return {?}
     */
    isEnabled() {
        try {
            sessionStorage.setItem('test', 'test');
            sessionStorage.removeItem('test');
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
CacheSessionStorage.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in local storage
 */
class CacheLocalStorage extends CacheStorageAbstract {
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        /** @type {?} */
        const value = localStorage.getItem(key);
        return value ? JSON.parse(value) : null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setItem(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        localStorage.removeItem(key);
    }
    /**
     * @return {?}
     */
    clear() {
        localStorage.clear();
    }
    /**
     * @return {?}
     */
    type() {
        return 0 /* LOCAL_STORAGE */;
    }
    /**
     * @return {?}
     */
    isEnabled() {
        try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
CacheLocalStorage.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in local storage
 */
class CacheMemoryStorage extends CacheStorageAbstract {
    constructor() {
        super(...arguments);
        this._data = {};
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getItem(key) {
        return this._data[key] ? this._data[key] : null;
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setItem(key, value) {
        this._data[key] = value;
        return true;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    removeItem(key) {
        delete this._data[key];
    }
    /**
     * @return {?}
     */
    clear() {
        this._data = [];
    }
    /**
     * @return {?}
     */
    type() {
        return 2 /* MEMORY */;
    }
    /**
     * @return {?}
     */
    isEnabled() {
        return true;
    }
}
CacheMemoryStorage.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CACHE_PREFIX = 'CacheService';
/** @type {?} */
const DEFAULT_STORAGE = 2 /* MEMORY */;
/** @type {?} */
const DEFAULT_ENABLED_STORAGE = 1 /* SESSION_STORAGE */;
class CacheService {
    /**
     * @param {?} _storage
     */
    constructor(_storage) {
        this._storage = _storage;
        /**
         * Default cache options
         */
        this._defaultOptions = {
            expires: Number.MAX_VALUE,
            maxAge: Number.MAX_VALUE
        };
        /**
         * Cache prefix
         */
        this._prefix = CACHE_PREFIX;
        this._validateStorage();
    }
    /**
     * Set data to cache
     * @param {?} key key
     * @param {?} value value
     * @param {?=} options options
     * @return {?}
     */
    set(key, value, options) {
        /** @type {?} */
        const storageKey = this._toStorageKey(key);
        options = options ? options : this._defaultOptions;
        if (this._storage.setItem(storageKey, this._toStorageValue(value, options))) {
            if (!this._isSystemKey(key) && options.tag) {
                this._saveTag(options.tag, storageKey);
            }
            return true;
        }
        return false;
    }
    /**
     * Get data from cache
     * @param {?} key key
     * @return {?} result
     */
    get(key) {
        /** @type {?} */
        const storageValue = this._storage.getItem(this._toStorageKey(key));
        /** @type {?} */
        let value = null;
        if (storageValue) {
            if (this._validateStorageValue(storageValue)) {
                value = storageValue.value;
            }
            else {
                this.remove(key);
            }
        }
        return value;
    }
    /**
     * Check if value exists
     * @param {?} key key
     * @return {?} result
     */
    exists(key) {
        return !!this.get(key);
    }
    /**
     * Remove item from cache
     * @param {?} key key
     * @return {?}
     */
    remove(key) {
        this._storage.removeItem(this._toStorageKey(key));
        this._removeFromTag(this._toStorageKey(key));
    }
    /**
     * Remove all from cache
     * @return {?}
     */
    removeAll() {
        this._storage.clear();
    }
    /**
     * Get all tag data
     * @param {?} tag tag
     * @return {?} result
     */
    getTagData(tag) {
        /** @type {?} */
        const tags = this.get(this._tagsStorageKey()) || {};
        /** @type {?} */
        const result = {};
        if (tags[tag]) {
            tags[tag].forEach((key) => {
                /** @type {?} */
                const data = this.get(this._fromStorageKey(key));
                if (data) {
                    result[this._fromStorageKey(key)] = data;
                }
            });
        }
        return result;
    }
    /**
     * Create a new instance of cache with needed storage
     * @param {?} type type
     * @return {?} result
     */
    useStorage(type) {
        /** @type {?} */
        const service = new CacheService(this._initStorage(type));
        service.setGlobalPrefix(this._getCachePrefix());
        return service;
    }
    /**
     * Remove all by tag
     * @param {?} tag tag
     * @return {?}
     */
    removeTag(tag) {
        /** @type {?} */
        const tags = this.get(this._tagsStorageKey()) || {};
        if (tags[tag]) {
            tags[tag].forEach((key) => {
                this._storage.removeItem(key);
            });
            delete tags[tag];
            this.set(this._tagsStorageKey(), tags);
        }
    }
    /**
     * Set global cache key prefix
     * @param {?} prefix prefix
     * @return {?}
     */
    setGlobalPrefix(prefix) {
        this._prefix = prefix;
    }
    /**
     * Validate cache storage
     * @private
     * @return {?}
     */
    _validateStorage() {
        if (!this._storage) {
            this._storage = this._initStorage(DEFAULT_STORAGE);
        }
        if (!this._storage.isEnabled()) {
            this._storage = this._initStorage(DEFAULT_ENABLED_STORAGE);
        }
    }
    /**
     * Remove key from tags keys list
     * @private
     * @param {?} key key
     * @return {?}
     */
    _removeFromTag(key) {
        // tslint:disable-next-line:prefer-const
        /** @type {?} */
        let tags = this.get(this._tagsStorageKey()) || {};
        /** @type {?} */
        let index;
        // tslint:disable-next-line:forin
        for (const tag in tags) {
            index = tags[tag].indexOf(key);
            if (index !== -1) {
                tags[tag].splice(index, 1);
                this.set(this._tagsStorageKey(), tags);
                break;
            }
        }
    }
    /**
     * Init storage by type
     * @private
     * @param {?} type type
     * @return {?}
     */
    _initStorage(type) {
        /** @type {?} */
        let storage;
        switch (type) {
            case 1 /* SESSION_STORAGE */:
                storage = new CacheSessionStorage();
                break;
            case 0 /* LOCAL_STORAGE */:
                storage = new CacheLocalStorage();
                break;
            default: storage = new CacheMemoryStorage();
        }
        return storage;
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    _toStorageKey(key) {
        return this._getCachePrefix() + key;
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    _fromStorageKey(key) {
        return key.replace(this._getCachePrefix(), '');
    }
    /**
     * Prepare value to set to storage
     * @private
     * @param {?} value value
     * @param {?} options options
     * @return {?} result
     */
    _toStorageValue(value, options) {
        return {
            value,
            options: this._toStorageOptions(options)
        };
    }
    /**
     * Prepare options to set to storage
     * @private
     * @param {?} options options
     * @return {?} result
     */
    _toStorageOptions(options) {
        /** @type {?} */
        const storageOptions = {};
        storageOptions.expires = options.expires ? options.expires :
            (options.maxAge ? Date.now() + (options.maxAge * 1000) : this._defaultOptions.expires);
        storageOptions.maxAge = options.maxAge ? options.maxAge : this._defaultOptions.maxAge;
        return storageOptions;
    }
    /**
     * Validate storage value
     * @private
     * @param {?} value value
     * @return {?} result
     */
    _validateStorageValue(value) {
        return !!value.options.expires && value.options.expires > Date.now();
    }
    /**
     * check if its system cache key
     * @private
     * @param {?} key key
     * @return {?} result
     */
    _isSystemKey(key) {
        return [this._tagsStorageKey()].indexOf(key) !== -1;
    }
    /**
     * Save tag to list of tags
     * @private
     * @param {?} tag tag
     * @param {?} key key
     * @return {?}
     */
    _saveTag(tag, key) {
        /** @type {?} */
        const tags = this.get(this._tagsStorageKey()) || {};
        if (!tags[tag]) {
            tags[tag] = [key];
        }
        else {
            tags[tag].push(key);
        }
        this.set(this._tagsStorageKey(), tags);
    }
    /**
     * Get global cache prefix
     * @private
     * @return {?} result
     */
    _getCachePrefix() {
        return this._prefix;
    }
    /**
     * @private
     * @return {?}
     */
    _tagsStorageKey() {
        return 'CacheService_tags';
    }
}
CacheService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CacheService.ctorParameters = () => [
    { type: CacheStorageAbstract, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import { calculateSpecificity, validateSelector } from 'clear-cut';
// const _ = require('underscore-plus')
/** @type {?} */
let SequenceCount = 0;
// Public: Associates listener functions with commands in a
// context-sensitive way using CSS selectors. You can access a global instance of
// this class via `atom.commands`, and commands registered there will be
// presented in the command palette.
//
// The global command registry facilitates a style of event handling known as
// *event delegation* that was popularized by jQuery. Atom commands are expressed
// as custom DOM events that can be invoked on the currently focused element via
// a key binding or manually via the command palette. Rather than binding
// listeners for command events directly to DOM nodes, you instead register
// command event listeners globally on `atom.commands` and constrain them to
// specific kinds of elements with CSS selectors.
//
// Command names must follow the `namespace:action` pattern, where `namespace`
// will typically be the name of your package, and `action` describes the
// behavior of your command. If either part consists of multiple words, these
// must be separated by hyphens. E.g. `awesome-package:turn-it-up-to-eleven`.
// All words should be lowercased.
//
// As the event bubbles upward through the DOM, all registered event listeners
// with matching selectors are invoked in order of specificity. In the event of a
// specificity tie, the most recently registered listener is invoked first. This
// mirrors the "cascade" semantics of CSS. Event listeners are invoked in the
// context of the current DOM node, meaning `this` always points at
// `event.currentTarget`. As is normally the case with DOM events,
// `stopPropagation` and `stopImmediatePropagation` can be used to terminate the
// bubbling process and prevent invocation of additional listeners.
//
// ## Example
//
// Here is a command that inserts the current date in an editor:
//
// ```coffee
// atom.commands.add 'atom-text-editor',
//   'user:insert-date': (event) ->
//     editor = @getModel()
//     editor.insertText(new Date().toLocaleString())
// ```
class CommandRegistry {
    constructor() {
        this.handleCommandEvent = this.handleCommandEvent.bind(this);
        this.rootNode = null;
        this.clear();
    }
    /**
     * @return {?}
     */
    clear() {
        this.registeredCommands = {};
        this.selectorBasedListenersByCommandName = {};
        this.inlineListenersByCommandName = {};
        this.emitter = new Emitter();
    }
    /**
     * @param {?} rootNode
     * @return {?}
     */
    attach(rootNode) {
        this.rootNode = rootNode;
        for (const command in this.selectorBasedListenersByCommandName) {
            this.commandRegistered(command);
        }
        for (const command in this.inlineListenersByCommandName) {
            this.commandRegistered(command);
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        for (const commandName in this.registeredCommands) {
            this.rootNode.removeEventListener(commandName, this.handleCommandEvent, true);
        }
    }
    // Public: Add one or more command listeners associated with a selector.
    //
    // ## Arguments: Registering One Command
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the command will be globally associated with all matching
    //   elements. The `,` combinator is not currently supported. If you pass a
    //   DOM element, the command will be associated with just that element.
    // * `commandName` A {String} containing the name of a command you want to
    //   handle such as `user:insert-date`.
    // * `listener` A listener which handles the event.  Either a {Function} to
    //   call when the given command is invoked on an element matching the
    //   selector, or an {Object} with a `didDispatch` property which is such a
    //   function.
    //
    //   The function (`listener` itself if it is a function, or the `didDispatch`
    //   method if `listener` is an object) will be called with `this` referencing
    //   the matching DOM node and the following argument:
    //     * `event`: A standard DOM event instance. Call `stopPropagation` or
    //       `stopImmediatePropagation` to terminate bubbling early.
    //
    //   Additionally, `listener` may have additional properties which are returned
    //   to those who query using `atom.commands.findCommands`, as well as several
    //   meaningful metadata properties:
    //     * `displayName`: Overrides any generated `displayName` that would
    //       otherwise be generated from the event name.
    //     * `description`: Used by consumers to display detailed information about
    //       the command.
    //     * `hiddenInCommandPalette`: If `true`, this command will not appear in
    //       the bundled command palette by default, but can still be shown with.
    //       the `Command Palette: Show Hidden Commands` command. This is a good
    //       option when you need to register large numbers of commands that don't
    //       make sense to be executed from the command palette. Please use this
    //       option conservatively, as it could reduce the discoverability of your
    //       package's commands.
    //
    // ## Arguments: Registering Multiple Commands
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the commands will be globally associated with all
    //   matching elements. The `,` combinator is not currently supported.
    //   If you pass a DOM element, the command will be associated with just that
    //   element.
    // * `commands` An {Object} mapping command names like `user:insert-date` to
    //   listener {Function}s.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added command handler(s).
    /**
     * @param {?} target
     * @param {?} commandName
     * @param {?} listener
     * @param {?=} throwOnInvalidSelector
     * @return {?}
     */
    add(target, commandName, listener, throwOnInvalidSelector = true) {
        if (typeof commandName === 'object') {
            /** @type {?} */
            const commands = commandName;
            throwOnInvalidSelector = listener;
            /** @type {?} */
            const disposable = new CompositeDisposable();
            for (commandName in commands) {
                listener = commands[commandName];
                disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector));
            }
            return disposable;
        }
        if (listener == null) {
            throw new Error('Cannot register a command with a null listener.');
        }
        // type Listener = ((e: CustomEvent) => void) | {
        //   displayName?: string,
        //   description?: string,
        //   didDispatch(e: CustomEvent): void,
        // }
        if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {
            throw new Error('Listener must be a callback function or an object with a didDispatch method.');
        }
        if (typeof target === 'string') {
            if (throwOnInvalidSelector) {
                validateSelector(target);
            }
            return this.addSelectorBasedListener(target, commandName, listener);
        }
        else {
            return this.addInlineListener(target, commandName, listener);
        }
    }
    /**
     * @param {?} selector
     * @param {?} commandName
     * @param {?} listener
     * @return {?}
     */
    addSelectorBasedListener(selector, commandName, listener) {
        if (this.selectorBasedListenersByCommandName[commandName] == null) {
            this.selectorBasedListenersByCommandName[commandName] = [];
        }
        /** @type {?} */
        const listenersForCommand = this.selectorBasedListenersByCommandName[commandName];
        /** @type {?} */
        const selectorListener = new SelectorBasedListener(selector, commandName, listener);
        listenersForCommand.push(selectorListener);
        this.commandRegistered(commandName);
        return new Disposable(() => {
            listenersForCommand.splice(listenersForCommand.indexOf(selectorListener), 1);
            if (listenersForCommand.length === 0) {
                delete this.selectorBasedListenersByCommandName[commandName];
            }
        });
    }
    /**
     * @param {?} element
     * @param {?} commandName
     * @param {?} listener
     * @return {?}
     */
    addInlineListener(element, commandName, listener) {
        if (this.inlineListenersByCommandName[commandName] == null) {
            this.inlineListenersByCommandName[commandName] = new WeakMap();
        }
        /** @type {?} */
        const listenersForCommand = this.inlineListenersByCommandName[commandName];
        /** @type {?} */
        let listenersForElement = listenersForCommand.get(element);
        if (!listenersForElement) {
            listenersForElement = [];
            listenersForCommand.set(element, listenersForElement);
        }
        /** @type {?} */
        const inlineListener = new InlineListener(commandName, listener);
        listenersForElement.push(inlineListener);
        this.commandRegistered(commandName);
        return new Disposable(() => {
            listenersForElement.splice(listenersForElement.indexOf(inlineListener), 1);
            if (listenersForElement.length === 0) {
                listenersForCommand.delete(element);
            }
        });
    }
    // Public: Find all registered commands matching a query.
    //
    // * `params` An {Object} containing one or more of the following keys:
    //   * `target` A DOM node that is the hypothetical target of a given command.
    //
    // Returns an {Array} of `CommandDescriptor` {Object}s containing the following keys:
    //  * `name` The name of the command. For example, `user:insert-date`.
    //  * `displayName` The display name of the command. For example,
    //    `User: Insert Date`.
    // Additional metadata may also be present in the returned descriptor:
    //  * `description` a {String} describing the function of the command in more
    //    detail than the title
    //  * `tags` an {Array} of {String}s that describe keywords related to the
    //    command
    //  Any additional nonstandard metadata provided when the command was `add`ed
    //  may also be present in the returned descriptor.
    /**
     * @param {?} __0
     * @return {?}
     */
    findCommands({ target }) {
        /** @type {?} */
        const commandNames = new Set();
        /** @type {?} */
        const commands = [];
        /** @type {?} */
        let currentTarget = target;
        while (true) {
            /** @type {?} */
            let listeners;
            for (const name in this.inlineListenersByCommandName) {
                listeners = this.inlineListenersByCommandName[name];
                if (listeners.has(currentTarget) && !commandNames.has(name)) {
                    commandNames.add(name);
                    /** @type {?} */
                    const targetListeners = listeners.get(currentTarget);
                    commands.push(...targetListeners.map(listener => listener.descriptor));
                }
            }
            for (const commandName in this.selectorBasedListenersByCommandName) {
                listeners = this.selectorBasedListenersByCommandName[commandName];
                for (const listener of listeners) {
                    if (listener.matchesTarget(currentTarget)) {
                        if (!commandNames.has(commandName)) {
                            commandNames.add(commandName);
                            commands.push(listener.descriptor);
                        }
                    }
                }
            }
            if (currentTarget === window) {
                break;
            }
            currentTarget = currentTarget.parentNode || window;
        }
        return commands;
    }
    // Public: Simulate the dispatch of a command on a DOM node.
    //
    // This can be useful for testing when you want to simulate the invocation of a
    // command on a detached DOM node. Otherwise, the DOM node in question needs to
    // be attached to the document so the event bubbles up to the root node to be
    // processed.
    //
    // * `target` The DOM node at which to start bubbling the command event.
    // * `commandName` {String} indicating the name of the command to dispatch.
    /**
     * @param {?} target
     * @param {?} commandName
     * @param {?} detail
     * @return {?}
     */
    dispatch(target, commandName, detail) {
        /** @type {?} */
        const event = new CustomEvent(commandName, { bubbles: true, detail });
        Object.defineProperty(event, 'target', { value: target });
        return this.handleCommandEvent(event);
    }
    // Public: Invoke the given callback before dispatching a command event.
    //
    // * `callback` {Function} to be called before dispatching each command
    //   * `event` The Event that will be dispatched
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillDispatch(callback) {
        return this.emitter.on('will-dispatch', callback);
    }
    // Public: Invoke the given callback after dispatching a command event.
    //
    // * `callback` {Function} to be called after dispatching each command
    //   * `event` The Event that was dispatched
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDispatch(callback) {
        return this.emitter.on('did-dispatch', callback);
    }
    /**
     * @return {?}
     */
    getSnapshot() {
        /** @type {?} */
        const snapshot = {};
        for (const commandName in this.selectorBasedListenersByCommandName) {
            /** @type {?} */
            const listeners = this.selectorBasedListenersByCommandName[commandName];
            snapshot[commandName] = listeners.slice();
        }
        return snapshot;
    }
    /**
     * @param {?} snapshot
     * @return {?}
     */
    restoreSnapshot(snapshot) {
        this.selectorBasedListenersByCommandName = {};
        for (const commandName in snapshot) {
            /** @type {?} */
            const listeners = snapshot[commandName];
            this.selectorBasedListenersByCommandName[commandName] = listeners.slice();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleCommandEvent(event) {
        /** @type {?} */
        let propagationStopped = false;
        /** @type {?} */
        let immediatePropagationStopped = false;
        /** @type {?} */
        const matched = [];
        /** @type {?} */
        let currentTarget = event.target;
        /** @type {?} */
        const dispatchedEvent = new CustomEvent(event.type, {
            bubbles: true,
            detail: event.detail
        });
        Object.defineProperty(dispatchedEvent, 'eventPhase', {
            value: Event.BUBBLING_PHASE
        });
        Object.defineProperty(dispatchedEvent, 'currentTarget', {
            /**
             * @return {?}
             */
            get() {
                return currentTarget;
            }
        });
        Object.defineProperty(dispatchedEvent, 'target', { value: currentTarget });
        Object.defineProperty(dispatchedEvent, 'preventDefault', {
            /**
             * @return {?}
             */
            value() {
                return event.preventDefault();
            }
        });
        Object.defineProperty(dispatchedEvent, 'stopPropagation', {
            /**
             * @return {?}
             */
            value() {
                event.stopPropagation();
                propagationStopped = true;
            }
        });
        Object.defineProperty(dispatchedEvent, 'stopImmediatePropagation', {
            /**
             * @return {?}
             */
            value() {
                event.stopImmediatePropagation();
                propagationStopped = true;
                immediatePropagationStopped = true;
            }
        });
        Object.defineProperty(dispatchedEvent, 'abortKeyBinding', {
            /**
             * @return {?}
             */
            value() {
                if (typeof event.abortKeyBinding === 'function') {
                    event.abortKeyBinding();
                }
            }
        });
        for (const key of Object.keys(event)) {
            if (!(key in dispatchedEvent)) {
                dispatchedEvent[key] = event[key];
            }
        }
        this.emitter.emit('will-dispatch', dispatchedEvent);
        while (true) {
            /** @type {?} */
            const commandInlineListeners = this.inlineListenersByCommandName[event.type]
                ? this.inlineListenersByCommandName[event.type].get(currentTarget)
                : null;
            /** @type {?} */
            let listeners = commandInlineListeners || [];
            if (currentTarget.webkitMatchesSelector != null) {
                /** @type {?} */
                const selectorBasedListeners = (this.selectorBasedListenersByCommandName[event.type] || [])
                    .filter(listener => listener.matchesTarget(currentTarget))
                    .sort((a, b) => a.compare(b));
                listeners = selectorBasedListeners.concat(listeners);
            }
            // Call inline listeners first in reverse registration order,
            // and selector-based listeners by specificity and reverse
            // registration order.
            for (let i = listeners.length - 1; i >= 0; i--) {
                /** @type {?} */
                const listener = listeners[i];
                if (immediatePropagationStopped) {
                    break;
                }
                matched.push(listener.didDispatch.call(currentTarget, dispatchedEvent));
            }
            if (currentTarget === window) {
                break;
            }
            if (propagationStopped) {
                break;
            }
            currentTarget = currentTarget.parentNode || window;
        }
        this.emitter.emit('did-dispatch', dispatchedEvent);
        return (matched.length > 0 ? Promise.all(matched) : null);
    }
    /**
     * @param {?} commandName
     * @return {?}
     */
    commandRegistered(commandName) {
        if (this.rootNode != null && !this.registeredCommands[commandName]) {
            this.rootNode.addEventListener(commandName, this.handleCommandEvent, true);
            return (this.registeredCommands[commandName] = true);
        }
    }
}
// type Listener = {
//   descriptor: CommandDescriptor,
//   extractDidDispatch: (e: CustomEvent) => void,
// };
class SelectorBasedListener {
    /**
     * @param {?} selector
     * @param {?} commandName
     * @param {?} listener
     */
    constructor(selector, commandName, listener) {
        this.selector = selector;
        this.didDispatch = extractDidDispatch(listener);
        this.descriptor = extractDescriptor(commandName, listener);
        this.specificity = calculateSpecificity(this.selector);
        this.sequenceNumber = SequenceCount++;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    compare(other) {
        return (this.specificity - other.specificity ||
            this.sequenceNumber - other.sequenceNumber);
    }
    /**
     * @param {?} target
     * @return {?}
     */
    matchesTarget(target) {
        return target.webkitMatchesSelector && target.webkitMatchesSelector(this.selector);
    }
}
class InlineListener {
    /**
     * @param {?} commandName
     * @param {?} listener
     */
    constructor(commandName, listener) {
        this.didDispatch = extractDidDispatch(listener);
        this.descriptor = extractDescriptor(commandName, listener);
    }
}
// type CommandDescriptor = {
//   name: string,
//   displayName: string,
// };
/**
 * @param {?} name
 * @param {?} listener
 * @return {?}
 */
function extractDescriptor(name, listener) {
    return Object.assign(omit(listener, 'didDispatch'), {
        name,
        displayName: listener.displayName ? listener.displayName : humanizeEventName(name)
    });
}
/**
 * @param {?} listener
 * @return {?}
 */
function extractDidDispatch(listener) {
    return typeof listener === 'function' ? listener : listener.didDispatch;
}
/**
 * @param {?} selector
 * @return {?}
 */
function validateSelector(selector) {
    if (!isSelectorValid(selector)) {
        /** @type {?} */
        const error = new SyntaxError(selector + ' is not a valid selector');
        // error.code = 'EBADSELECTOR';
        throw error;
    }
}
/**
 * @param {?} selector
 * @return {?}
 */
function isSelectorValid(selector) {
    /** @type {?} */
    let valid;
    try {
        document.querySelector(selector);
        valid = true;
    }
    catch (error) {
        valid = false;
    }
    return valid;
}
/**
 * @param {?} selector
 * @return {?}
 */
function calculateSpecificity(selector) {
    /** @type {?} */
    const specificity = calculate(selector);
    return specificity;
}
/**
 * @param {?} selector
 * @return {?}
 */
function calculate(selector) {
    /** @type {?} */
    const commaIndex = selector.indexOf(',');
    if (commaIndex !== -1) {
        selector = selector.substring(0, commaIndex);
    }
    /** @type {?} */
    const types = {
        a: 0,
        b: 0,
        c: 0
    };
    // The following regular expressions assume that selectors matching the preceding regular expressions have been removed
    /** @type {?} */
    const attributeRegex = /(\[[^\]]+\])/g;
    /** @type {?} */
    const idRegex = /(#[^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    const classRegex = /(\.[^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    const pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
    /** @type {?} */
    const pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    const elementRegex = /([^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    const notRegex = /:not\(([^\)]*)\)/g;
    /** @type {?} */
    const ruleRegex = /\{[^]*/gm;
    /** @type {?} */
    const separatorRegex = /[\*\s\+>~]/g;
    /** @type {?} */
    const straysRegex = /[#\.]/g;
    // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
    selector = selector.replace(notRegex, ' $1 ');
    // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
    selector = selector.replace(ruleRegex, ' ');
    // Add attribute selectors to parts collection (type b)
    selector = findMatch(attributeRegex, 'b', types, selector);
    // Add ID selectors to parts collection (type a)
    selector = findMatch(idRegex, 'a', types, selector);
    // Add class selectors to parts collection (type b)
    selector = findMatch(classRegex, 'b', types, selector);
    // Add pseudo-element selectors to parts collection (type c)
    selector = findMatch(pseudoElementRegex, 'c', types, selector);
    // Add pseudo-class selectors to parts collection (type b)
    selector = findMatch(pseudoClassRegex, 'b', types, selector);
    // Remove universal selector and separator characters
    selector = selector.replace(separatorRegex, ' ');
    // Remove any stray dots or hashes which aren't attached to words
    // These may be present if the user is live-editing this selector
    selector = selector.replace(straysRegex, ' ');
    // The only things left should be element selectors (type c)
    findMatch(elementRegex, 'c', types, selector);
    return (types.a * 100) + (types.b * 10) + (types.c * 1);
}
/**
 * @param {?} regex
 * @param {?} type
 * @param {?} types
 * @param {?} selector
 * @return {?}
 */
function findMatch(regex, type, types, selector) {
    /** @type {?} */
    const matches = selector.match(regex);
    if (matches) {
        for (const match of matches) {
            types[type]++;
            // Replace this simple selector with whitespace so it won't be counted in further simple selectors
            selector = selector.replace(match, ' ');
        }
    }
    return selector;
}
/**
 * @param {?} obj
 * @param {...?} props
 * @return {?}
 */
function omit(obj, ...props) {
    // const iteratee = (value, key) => !props.find(key);
    // const iteratee = (value, key) => !props.find(key);
    /** @type {?} */
    const result = {};
    if (!obj) {
        return result;
    }
    Object.keys(obj).forEach(key => {
        if (!props.find(prop => prop === key)) {
            return;
        }
        result[key] = obj[key];
    });
    return result;
}
/**
 * @param {?} eventName
 * @param {?=} eventDoc
 * @return {?}
 */
function humanizeEventName(eventName, eventDoc = null) {
    /** @type {?} */
    const ref = eventName.split(':');
    const [namespace, event] = ref;
    if (event == null) {
        return undash(namespace);
    }
    /** @type {?} */
    const namespaceDoc = undash(namespace);
    if (eventDoc == null) {
        eventDoc = undash(event);
    }
    return '' + namespaceDoc + ': ' + eventDoc;
}
/**
 * @param {?} str
 * @return {?}
 */
function undash(str) {
    if (str) {
        return str.split('-').join(' ');
    }
    else {
        return '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Util {
    /**
     * @return {?}
     */
    newGuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            // tslint:disable: no-bitwise
            /** @type {?} */
            const r = Math.random() * 16 | 0;
            /** @type {?} */
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    /**
     * 向url添加QueryParam
     * @param {?} url 原始url
     * @param {?} paramName 参数名
     * @param {?} paramValue 参数值
     * @param {?=} override 是否覆盖。为True时，如果参数已存在，将覆盖已有参数，否则放弃处理。默认为False。
     * @return {?}
     */
    setUrlParam(url, paramName, paramValue, override) {
        const [path, search] = url.split('?');
        /** @type {?} */
        const params = new URLSearchParams(search);
        if (params.has(paramName) && !override) {
            return url;
        }
        params.set(paramName, paramValue);
        return path + '?' + params.toString();
    }
}
Util.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: `ViewRegistry` handles the association between model and view
// types in Atom. We call this association a View Provider. As in, for a given
// model, this class can provide a view via {::getView}, as long as the
// model/view association was registered via {::addViewProvider}
//
// If you're adding your own kind of pane item, a good strategy for all but the
// simplest items is to separate the model and the view. The model handles
// application logic and is the primary point of API interaction. The view
// just handles presentation.
//
// Note: Models can be any object, but must implement a `getTitle()` function
// if they are to be displayed in a {Pane}
//
// View providers inform the workspace how your model objects should be
// presented in the DOM. A view provider must always return a DOM node, which
// makes [HTML 5 custom elements](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/)
// an ideal tool for implementing views in Atom.
//
// You can access the `ViewRegistry` object via `atom.views`.
class ViewRegistry {
    // private documentWriters: any;
    // private documentReaders: any;
    // private nextUpdatePromise: any;
    // private resolveNextUpdatePromise: (value?: {} | PromiseLike<{}>) => void;
    /**
     * @param {?} gspEnvironment
     */
    constructor(gspEnvironment) {
        // this.animationFrameRequest = null
        // this.documentReadInProgress = false
        // this.performDocumentUpdate = this.performDocumentUpdate.bind(this);
        this.gspEnvironment = gspEnvironment;
        this.clear();
    }
    /**
     * @return {?}
     */
    clear() {
        this.views = new WeakMap();
        this.providers = [];
        this.clearDocumentRequests();
    }
    // Essential: Add a provider that will be used to construct views in the
    // workspace's view layer based on model objects in its model layer.
    //
    // ## Examples
    //
    // Text editors are divided into a model and a view layer, so when you interact
    // with methods like `atom.workspace.getActiveTextEditor()` you're only going
    // to get the model object. We display text editors on screen by teaching the
    // workspace what view constructor it should use to represent them:
    //
    // ```coffee
    // atom.views.addViewProvider TextEditor, (textEditor) ->
    //   textEditorElement = new TextEditorElement
    //   textEditorElement.initialize(textEditor)
    //   textEditorElement
    // ```
    //
    // * `modelConstructor` (optional) Constructor {Function} for your model. If
    //   a constructor is given, the `createView` function will only be used
    //   for model objects inheriting from that constructor. Otherwise, it will
    //   will be called for any object.
    // * `createView` Factory {Function} that is passed an instance of your model
    //   and must return a subclass of `HTMLElement` or `undefined`. If it returns
    //   `undefined`, then the registry will continue to search for other view
    //   providers.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added provider.
    /**
     * @param {?} modelConstructor
     * @param {?} createView
     * @return {?}
     */
    addViewProvider(modelConstructor, createView) {
        /** @type {?} */
        let provider;
        if (arguments.length === 1) {
            switch (typeof modelConstructor) {
                case 'function':
                    provider = { createView: modelConstructor, modelConstructor: null };
                    break;
                case 'object':
                    provider = modelConstructor;
                    break;
                default:
                    throw new TypeError('Arguments to addViewProvider must be functions');
            }
        }
        else {
            provider = { modelConstructor, createView };
        }
        this.providers.push(provider);
        return new Disposable(() => {
            this.providers = this.providers.filter(p => p !== provider);
        });
    }
    /**
     * @return {?}
     */
    getViewProviderCount() {
        return this.providers.length;
    }
    // Essential: Get the view associated with an object in the workspace.
    //
    // If you're just *using* the workspace, you shouldn't need to access the view
    // layer, but view layer access may be necessary if you want to perform DOM
    // manipulation that isn't supported via the model API.
    //
    // ## View Resolution Algorithm
    //
    // The view associated with the object is resolved using the following
    // sequence
    //
    //  1. Is the object an instance of `HTMLElement`? If true, return the object.
    //  2. Does the object have a method named `getElement` that returns an
    //     instance of `HTMLElement`? If true, return that value.
    //  3. Does the object have a property named `element` with a value which is
    //     an instance of `HTMLElement`? If true, return the property value.
    //  4. Is the object a jQuery object, indicated by the presence of a `jquery`
    //     property? If true, return the root DOM element (i.e. `object[0]`).
    //  5. Has a view provider been registered for the object? If true, use the
    //     provider to create a view associated with the object, and return the
    //     view.
    //
    // If no associated view is returned by the sequence an error is thrown.
    //
    // Returns a DOM element.
    /**
     * @param {?} object
     * @return {?}
     */
    getView(object) {
        if (object == null) {
            return;
        }
        /** @type {?} */
        let view = this.views.get(object);
        if (!view) {
            view = this.createView(object);
            this.views.set(object, view);
        }
        return view;
    }
    /**
     * @param {?} object
     * @return {?}
     */
    createView(object) {
        if (object instanceof ComponentRef) {
            return object;
        }
        /** @type {?} */
        let element;
        if (object && (typeof object.getElement === 'function')) {
            element = object.getElement();
            if (element instanceof ComponentRef) {
                return element;
            }
        }
        if (object && object.element instanceof ComponentRef) {
            return object.element;
        }
        // if (object && object.jquery) {
        //   return object[0];
        // }
        for (const provider of this.providers) {
            if (provider.modelConstructor === null) {
                element = provider.createView(object, this.gspEnvironment);
                if (element) {
                    return element;
                }
                continue;
            }
            if (object instanceof provider.modelConstructor) {
                element = provider.createView && provider.createView(object, this.gspEnvironment);
                if (element) {
                    return element;
                }
                /** @type {?} */
                const ViewConstructor = provider.viewConstructor;
                if (ViewConstructor) {
                    element = new ViewConstructor();
                    if (element.initialize) {
                        element.initialize(object);
                    }
                    else if (element.setModel) {
                        element.setModel(object);
                    }
                    return element;
                }
            }
        }
        if (object && object.getViewClass) {
            /** @type {?} */
            const ViewConstructor = object.getViewClass();
            if (ViewConstructor) {
                /** @type {?} */
                const view = new ViewConstructor(object);
                return view;
            }
        }
        throw new Error(`Can't create a view for ${object.constructor.name} instance. Please register a view provider.`);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    updateDocument(fn) {
        // this.documentWriters.push(fn)
        // if (!this.documentReadInProgress) { this.requestDocumentUpdate() }
        // return new Disposable(() => {
        //   this.documentWriters = this.documentWriters.filter(writer => writer !== fn)
        // })
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    readDocument(fn) {
        // this.documentReaders.push(fn)
        // this.requestDocumentUpdate()
        // return new Disposable(() => {
        //   this.documentReaders = this.documentReaders.filter(reader => reader !== fn)
        // })
    }
    /**
     * @return {?}
     */
    getNextUpdatePromise() {
        // if (this.nextUpdatePromise == null) {
        //   this.nextUpdatePromise = new Promise(resolve => {
        //     this.resolveNextUpdatePromise = resolve
        //   })
        // }
        // return this.nextUpdatePromise
    }
    /**
     * @return {?}
     */
    clearDocumentRequests() {
        // this.documentReaders = []
        // this.documentWriters = []
        // this.nextUpdatePromise = null
        // this.resolveNextUpdatePromise = null
        // if (this.animationFrameRequest != null) {
        //   cancelAnimationFrame(this.animationFrameRequest)
        //   this.animationFrameRequest = null
        // }
    }
    /**
     * @return {?}
     */
    requestDocumentUpdate() {
        // if (this.animationFrameRequest == null) {
        //   this.animationFrameRequest = requestAnimationFrame(this.performDocumentUpdate)
        // }
    }
    /**
     * @return {?}
     */
    performDocumentUpdate() {
        // const { resolveNextUpdatePromise } = this
        // this.animationFrameRequest = null
        // this.nextUpdatePromise = null
        // this.resolveNextUpdatePromise = null
        // var writer = this.documentWriters.shift()
        // while (writer) {
        //   writer()
        //   writer = this.documentWriters.shift()
        // }
        // var reader = this.documentReaders.shift()
        // this.documentReadInProgress = true
        // while (reader) {
        //   reader()
        //   reader = this.documentReaders.shift()
        // }
        // this.documentReadInProgress = false
        // // process updates requested as a result of reads
        // writer = this.documentWriters.shift()
        // while (writer) {
        //   writer()
        //   writer = this.documentWriters.shift()
        // }
        // if (resolveNextUpdatePromise) { resolveNextUpdatePromise() }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PanelContainer {
    /**
     * @param {?} viewRegistry
     * @param {?} location
     * @param {?=} dock
     */
    constructor(viewRegistry, location, dock = null) {
        this.viewRegistry = viewRegistry;
        this.location = location;
        this.dock = dock;
        this.panels = [];
        this.emitter = new Emitter();
        this.subscriptions = new CompositeDisposable();
    }
    /**
     * @return {?}
     */
    destroy() {
        for (const panel of this.getPanels()) {
            panel.destroy();
        }
    }
    /**
     * @return {?}
     */
    getElement() {
    }
    /*
      Section: Event Subscription
      */
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidAddPanel(callback) {
        return this.emitter.on('did-add-panel', callback);
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidRemovePanel(callback) {
        return this.emitter.on('did-remove-panel', callback);
    }
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDestroy(callback) {
        return this.emitter.once('did-destroy', callback);
    }
    /**
     * @return {?}
     */
    getLocation() {
        return this.location;
    }
    /**
     * @return {?}
     */
    isModal() { return this.location === 'modal'; }
    /**
     * @return {?}
     */
    getPanels() { return this.panels.slice(); }
    /**
     * @param {?} panel
     * @return {?}
     */
    addPanel(panel) {
        this.subscriptions.add(panel.onDidDestroy(this.panelDestroyed.bind(this)));
        /** @type {?} */
        const index = this.getPanelIndex(panel);
        if (index === this.panels.length) {
            this.panels.push(panel);
        }
        else {
            this.panels.splice(index, 0, panel);
        }
        this.emitter.emit('did-add-panel', { panel, index });
        return panel;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    panelForItem(item) {
        for (const panel of this.panels) {
            if (panel.getItem() === item) {
                return panel;
            }
        }
        return null;
    }
    /**
     * @param {?} panel
     * @return {?}
     */
    panelDestroyed(panel) {
        /** @type {?} */
        const index = this.panels.indexOf(panel);
        if (index > -1) {
            this.panels.splice(index, 1);
            this.emitter.emit('did-remove-panel', { panel, index });
        }
    }
    /**
     * @param {?} panel
     * @return {?}
     */
    getPanelIndex(panel) {
        /** @type {?} */
        const priority = panel.getPriority();
        if (['bottom', 'right'].find(item => item === this.location)) {
            for (let i = this.panels.length - 1; i >= 0; i--) {
                /** @type {?} */
                const p = this.panels[i];
                if (priority < p.getPriority()) {
                    return i + 1;
                }
            }
            return 0;
        }
        else {
            for (let i = 0; i < this.panels.length; i++) {
                /** @type {?} */
                const p = this.panels[i];
                if (priority < p.getPriority()) {
                    return i;
                }
            }
            return this.panels.length;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Panel {
    /**
     * @param {?} options
     * @param {?} viewRegistry
     */
    constructor(options, viewRegistry) {
        this.destroyed = false;
        this.item = options.item;
        this.autoFocus = options.autoFocus == null ? false : options.autoFocus;
        this.visible = options.visible == null ? true : options.visible;
        this.priority = options.priority == null ? 100 : options.priority;
        this.className = options.className;
        this.viewRegistry = viewRegistry;
        this.emitter = new Emitter();
    }
    // Public: Destroy and remove this panel from the UI.
    /**
     * @return {?}
     */
    destroy() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        this.hide();
        this.emitter.emit('did-destroy', this);
        return this.emitter.dispose();
    }
    /**
     * @return {?}
     */
    getElement() {
        return this.item.getElement(); // 直接返回item的视图，不再包装一层Panel
    }
    /*
      Section: Event Subscription
      */
    // Public: Invoke the given callback when the pane hidden or shown.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `visible` {Boolean} true when the panel has been shown
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeVisible(callback) {
        return this.emitter.on('did-change-visible', callback);
    }
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `panel` {Panel} this panel
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDestroy(callback) {
        return this.emitter.once('did-destroy', callback);
    }
    /*
      Section: Panel Details
      */
    // Public: Returns the panel's item.
    /**
     * @return {?}
     */
    getItem() {
        return this.item;
    }
    // Public: Returns a {Number} indicating this panel's priority.
    /**
     * @return {?}
     */
    getPriority() {
        return this.priority;
    }
    /**
     * @return {?}
     */
    getClassName() {
        return this.className;
    }
    // Public: Returns a {Boolean} true when the panel is visible.
    /**
     * @return {?}
     */
    isVisible() {
        return this.visible;
    }
    // Public: Hide this panel
    /**
     * @return {?}
     */
    hide() {
        /** @type {?} */
        const wasVisible = this.visible;
        this.visible = false;
        if (wasVisible) {
            this.emitter.emit('did-change-visible', this.visible);
        }
    }
    // Public: Show this panel
    /**
     * @return {?}
     */
    show() {
        /** @type {?} */
        const wasVisible = this.visible;
        this.visible = true;
        if (!wasVisible) {
            this.emitter.emit('did-change-visible', this.visible);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: Represents the workspace at the center of the entire window.
class WorkspaceCenter {
    /**
     * @param {?} params
     */
    constructor(params) {
        params.location = 'center';
        this.paneContainer = new PaneContainer(params);
        this.didActivate = params.didActivate;
        this.paneContainer.onDidActivatePane(() => this.didActivate(this));
        this.paneContainer.onDidChangeActivePane((pane) => {
            params.didChangeActivePane(this, pane);
        });
        this.paneContainer.onDidChangeActivePaneItem((item) => {
            params.didChangeActivePaneItem(this, item);
        });
        this.paneContainer.onDidDestroyPaneItem((item) => params.didDestroyPaneItem(item));
    }
    /**
     * @return {?}
     */
    destroy() {
        this.paneContainer.destroy();
    }
    /**
     * @return {?}
     */
    serialize() {
        return this.paneContainer.serialize();
    }
    /**
     * @param {?} state
     * @param {?} deserializerManager
     * @return {?}
     */
    deserialize(state, deserializerManager) {
        this.paneContainer.deserialize(state, deserializerManager);
    }
    /**
     * @return {?}
     */
    activate() {
        this.getActivePane().activate();
    }
    /**
     * @return {?}
     */
    getLocation() {
        return 'center';
    }
    /**
     * @return {?}
     */
    setDraggingItem() {
        // No-op
    }
    // Essential: Invoke the given callback with all current and future panes items
    // in the workspace center.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observePaneItems(callback) { return this.paneContainer.observePaneItems(callback); }
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeActivePaneItem(callback) {
        return this.paneContainer.onDidChangeActivePaneItem(callback);
    }
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidStopChangingActivePaneItem(callback) {
        return this.paneContainer.onDidStopChangingActivePaneItem(callback);
    }
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the workspace center.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeActivePaneItem(callback) {
        return this.paneContainer.observeActivePaneItem(callback);
    }
    // Extended: Invoke the given callback when a pane is added to the workspace
    // center.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidAddPane(callback) {
        return this.paneContainer.onDidAddPane(callback);
    }
    // Extended: Invoke the given callback before a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillDestroyPane(callback) {
        return this.paneContainer.onWillDestroyPane(callback);
    }
    // Extended: Invoke the given callback when a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDestroyPane(callback) {
        return this.paneContainer.onDidDestroyPane(callback);
    }
    // Extended: Invoke the given callback with all current and future panes in the
    // workspace center.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observePanes(callback) {
        return this.paneContainer.observePanes(callback);
    }
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidChangeActivePane(callback) {
        return this.paneContainer.onDidChangeActivePane(callback);
    }
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    observeActivePane(callback) {
        return this.paneContainer.observeActivePane(callback);
    }
    // Extended: Invoke the given callback when a pane item is added to the
    // workspace center.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidAddPaneItem(callback) {
        return this.paneContainer.onDidAddPaneItem(callback);
    }
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onWillDestroyPaneItem(callback) {
        return this.paneContainer.onWillDestroyPaneItem(callback);
    }
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    onDidDestroyPaneItem(callback) {
        return this.paneContainer.onDidDestroyPaneItem(callback);
    }
    /*
      Section: Pane Items
      */
    // Essential: Get all pane items in the workspace center.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    getPaneItems() {
        return this.paneContainer.getPaneItems();
    }
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    /**
     * @return {?}
     */
    getActivePaneItem() {
        return this.paneContainer.getActivePaneItem();
    }
    // Save all pane items.
    /**
     * @return {?}
     */
    saveAll() {
        this.paneContainer.saveAll();
    }
    /**
     * @param {?} options
     * @return {?}
     */
    confirmClose(options) {
        return this.paneContainer.confirmClose(options);
    }
    /*
      Section: Panes
      */
    // Extended: Get all panes in the workspace center.
    //
    // Returns an {Array} of {Pane}s.
    /**
     * @return {?}
     */
    getPanes() {
        return this.paneContainer.getPanes();
    }
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    /**
     * @return {?}
     */
    getActivePane() {
        return this.paneContainer.getActivePane();
    }
    // Extended: Make the next pane active.
    /**
     * @return {?}
     */
    activateNextPane() {
        return this.paneContainer.activateNextPane();
    }
    // Extended: Make the previous pane active.
    /**
     * @return {?}
     */
    activatePreviousPane() {
        return this.paneContainer.activatePreviousPane();
    }
    /**
     * @param {?} uri
     * @return {?}
     */
    paneForURI(uri) {
        return this.paneContainer.paneForURI(uri);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    paneForItem(item) {
        return this.paneContainer.paneForItem(item);
    }
    // Destroy (close) the active pane.
    /**
     * @return {?}
     */
    destroyActivePane() {
        /** @type {?} */
        const activePane = this.getActivePane();
        if (activePane != null) {
            activePane.destroy();
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ALL_LOCATIONS = ['center', 'left', 'right', 'bottom'];
class Workspace {
    /**
     * @param {?} params
     */
    constructor(params) {
        this.initOptions(params);
        this.initWorkspace();
        this.openers = [];
        this.frmOpeners = [];
        this.useFrmOpener = false;
        this.viewRegistry = params.viewRegistry;
        // this.subscribeToEvents();
    }
    /**
     * @private
     * @param {?} params
     * @return {?}
     */
    initOptions(params) {
        this.config = params.config || {};
    }
    /**
     * @private
     * @return {?}
     */
    initWorkspace() {
        // 创建工作区停靠面板容器。
        this.paneContainers = {
            // 创建主区域。
            center: this.createCenter(),
            // 创建左侧面板。
            left: this.createDock('left'),
            // 创建右侧面板。
            right: this.createDock('right'),
            // 创建底部面板。
            bottom: this.createDock('bottom')
        };
        this.activePaneContainer = this.paneContainers.center;
        // 创建面板容器
        this.panelContainers = {
            top: new PanelContainer(this.viewRegistry, 'top'),
            left: new PanelContainer(this.viewRegistry, 'left', this.paneContainers.left),
            right: new PanelContainer(this.viewRegistry, 'right', this.paneContainers.right),
            bottom: new PanelContainer(this.viewRegistry, 'bottom', this.paneContainers.bottom),
            header: new PanelContainer(this.viewRegistry, 'header'),
            footer: new PanelContainer(this.viewRegistry, 'footer'),
            modal: new PanelContainer(this.viewRegistry, 'modal')
        };
    }
    /**
     * @return {?}
     */
    get paneContainer() {
        return this.paneContainers.center.paneContainer;
    }
    /**
     * 返回工作区元素
     * @return {?}
     */
    getElement() {
    }
    /**
     * 创建主面板
     * @return {?}
     */
    createCenter() {
        return new WorkspaceCenter({ viewRegistry: this.viewRegistry });
    }
    /**
     * 创建停靠面板
     * @param {?} location 停靠面板位置
     * @return {?}
     */
    createDock(location) {
        return new Dock({
            location,
            viewRegistry: this.viewRegistry
        });
    }
    /**
     * 重置工作区
     * @param {?} packageManager 包管理器
     * @return {?}
     */
    reset(packageManager) {
        this.packageManager = packageManager;
        this.destroyed();
        this.initWorkspace();
    }
    // Called by the Serializable mixin during serialization.
    /**
     * 序列化工作区配置
     * @return {?}
     */
    serialize() {
    }
    /**
     * 反序列化工作区配置
     * @param {?} state state
     * @param {?} deserializerManager dm
     * @return {?}
     */
    deserialize(state, deserializerManager) {
    }
    // Updates the application's title and proxy icon based on whichever file is
    // open.
    /**
     * @return {?}
     */
    updateWindowTitle() {
    }
    /**
     * @param {?} itemOrURI
     * @param {?=} options
     * @return {?}
     */
    open(itemOrURI, options = {}) {
        /** @type {?} */
        let uri;
        /** @type {?} */
        let item;
        if (typeof itemOrURI === 'string') {
            uri = itemOrURI; // this.project.resolvePath(itemOrURI);
        }
        else if (itemOrURI) {
            item = itemOrURI;
            if (typeof item.getURI === 'function') {
                uri = item.getURI();
            }
        }
        if (!this.config.get('core.allowPendingPaneItems')) {
            options.pending = false;
        }
        // Avoid adding URLs as recent documents to work-around this Spotlight crash:
        // https://github.com/atom/atom/issues/10071
        // if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {
        //   this.applicationDelegate.addRecentDocument(uri);
        // }
        /** @type {?} */
        let pane;
        /** @type {?} */
        let itemExistsInWorkspace;
        // Try to find an existing item in the workspace.
        if (item || uri) {
            if (options.pane) {
                pane = options.pane;
            }
            else if (options.searchAllPanes) {
                pane = item ? this.paneForItem(item) : this.paneForURI(uri);
            }
            else {
                // If an item with the given URI is already in the workspace, assume
                // that item's pane container is the preferred location for that URI.
                /** @type {?} */
                let container;
                if (uri) {
                    container = this.paneContainerForURI(uri);
                }
                if (!container) {
                    container = this.getActivePaneContainer();
                }
                // The `split` option affects where we search for the item.
                pane = container.getActivePane();
                switch (options.split) {
                    case 'left':
                        pane = pane.findLeftmostSibling();
                        break;
                    case 'right':
                        pane = pane.findRightmostSibling();
                        break;
                    case 'up':
                        pane = pane.findTopmostSibling();
                        break;
                    case 'down':
                        pane = pane.findBottommostSibling();
                        break;
                }
            }
            if (pane) {
                if (item) {
                    itemExistsInWorkspace = pane.getItems().includes(item);
                }
                else {
                    item = pane.itemForURI(uri);
                    itemExistsInWorkspace = item != null;
                }
            }
        }
        if (!itemExistsInWorkspace) {
            item = item || this.createItemForURI(uri, options);
            if (!item) {
                return;
            }
            if (options.pane) {
                pane = options.pane;
            }
            else {
                /** @type {?} */
                let location = options.location;
                // if (!location && !options.split && uri && this.enablePersistence) {
                //   // location = await;
                //   this.itemLocationStore.load(uri);
                // }
                if (!location && typeof item.getDefaultLocation === 'function') {
                    location = item.getDefaultLocation();
                }
                /** @type {?} */
                const allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS;
                location = allowedLocations.includes(location) ? location : allowedLocations[0];
                /** @type {?} */
                const container = this.paneContainers[location] || this.getCenter();
                pane = container.getActivePane();
                switch (options.split) {
                    case 'left':
                        pane = pane.findLeftmostSibling();
                        break;
                    case 'right':
                        pane = pane.findOrCreateRightmostSibling();
                        break;
                    case 'up':
                        pane = pane.findTopmostSibling();
                        break;
                    case 'down':
                        pane = pane.findOrCreateBottommostSibling();
                        break;
                }
            }
        }
        if (!options.pending && (pane.getPendingItem() === item)) {
            pane.clearPendingItem();
        }
        this.itemOpened(item);
        if (options.activateItem === false) {
            pane.addItem(item, { pending: options.pending });
        }
        else {
            pane.activateItem(item, { pending: options.pending });
        }
        if (options.activatePane !== false) {
            pane.activate();
        }
        /** @type {?} */
        let initialColumn = 0;
        /** @type {?} */
        let initialLine = 0;
        if (!Number.isNaN(options.initialLine)) {
            initialLine = options.initialLine;
        }
        if (!Number.isNaN(options.initialColumn)) {
            initialColumn = options.initialColumn;
        }
        if (initialLine >= 0 || initialColumn >= 0) {
            if (typeof item.setCursorBufferPosition === 'function') {
                item.setCursorBufferPosition([initialLine, initialColumn]);
            }
        }
        /** @type {?} */
        const index = pane.getActiveItemIndex();
        return item;
    }
    /**
     * @param {?} itemOrURI
     * @return {?}
     */
    hide(itemOrURI) {
        /** @type {?} */
        let foundItems = false;
        // If any visible item has the given URI, hide it
        for (const container of this.getPaneContainers()) {
            /** @type {?} */
            const isCenter = container === this.getCenter();
            if (isCenter || ((/** @type {?} */ (container))).isVisible()) {
                for (const pane of container.getPanes()) {
                    /** @type {?} */
                    const activeItem = pane.getActiveItem();
                    /** @type {?} */
                    const foundItem = (activeItem != null && (activeItem === itemOrURI ||
                        typeof activeItem.getURI === 'function' && activeItem.getURI() === itemOrURI));
                    if (foundItem) {
                        foundItems = true;
                        // We can't really hide the center so we just destroy the item.
                        if (isCenter) {
                            pane.destroyItem(activeItem);
                        }
                        else {
                            ((/** @type {?} */ (container))).hide();
                        }
                    }
                }
            }
        }
        return foundItems;
    }
    /**
     * @param {?} itemOrURI
     * @return {?}
     */
    toggle(itemOrURI) {
        if (this.hide(itemOrURI)) {
            return Promise.resolve();
        }
        else {
            return this.open(itemOrURI, { searchAllPanes: true });
        }
    }
    /**
     * @param {?=} fileUri
     * @param {?=} options
     * @return {?}
     */
    openSync(fileUri = '', options = { initialColumn: '', initialLine: '', activateItem: '', activatePane: '' }) {
        const { initialLine, initialColumn } = options;
        /** @type {?} */
        const activatePane = options.activatePane != null ? options.activatePane : true;
        /** @type {?} */
        const activateItem = options.activateItem != null ? options.activateItem : true;
        /** @type {?} */
        const uri = fileUri;
        // this.project.resolvePath(uri_);
        /** @type {?} */
        let item = this.getActivePane().itemForURI(uri);
        if (uri && (item == null)) {
            for (const opener of this.getOpeners()) {
                item = opener(uri, options);
                if (item) {
                    break;
                }
            }
        }
        if (item == null) {
            item = this.project.openSync(uri, { initialLine, initialColumn });
        }
        if (activateItem) {
            this.getActivePane().activateItem(item);
        }
        this.itemOpened(item);
        if (activatePane) {
            this.getActivePane().activate();
        }
        return item;
    }
    /**
     * @param {?} uri
     * @param {?} pane
     * @return {?}
     */
    openURIInPane(uri, pane) {
        return this.open(uri, { pane });
    }
    /**
     * @param {?} uri
     * @param {?} options
     * @return {?}
     */
    createItemForURI(uri, options) {
        if (uri != null) {
            for (const opener of this.getOpeners()) {
                /** @type {?} */
                const item = opener(uri, options);
                if (item != null) {
                    if (!item.getURI || typeof item.getURI !== 'function' || !item.getUri || typeof item.getURI !== 'function') {
                        item.getUri = () => uri;
                    }
                    return item;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    reopenItem() {
        /** @type {?} */
        const uri = this.destroyedItemURIs.pop();
        if (uri) {
            return this.open(uri);
        }
        else {
            return Promise.resolve();
        }
    }
    /**
     * @param {?} opener
     * @return {?}
     */
    addOpener(opener) {
        this.openers.push(opener);
        // return new Disposable(() => { _.remove(this.openers, opener); });
    }
    /**
     * @param {?} opener
     * @return {?}
     */
    addFrmOpener(opener) {
        if (!this.useFrmOpener) {
            this.useFrmOpener = true;
        }
        this.frmOpeners.push(opener);
    }
    /**
     * @return {?}
     */
    getOpeners() {
        return this.useFrmOpener ? this.frmOpeners : this.openers;
    }
    /**
     * @return {?}
     */
    getPaneItems() {
        return new Array().concat(this.getPaneContainers().map(container => container.getPaneItems()));
    }
    /**
     * @return {?}
     */
    getActivePaneItem() {
        return this.getActivePaneContainer().getActivePaneItem();
    }
    /**
     * @return {?}
     */
    saveAll() {
        this.getPaneContainers().forEach(container => {
            container.saveAll();
        });
    }
    /**
     * @param {?} options
     * @return {?}
     */
    confirmClose(options) {
        return Promise.all(this.getPaneContainers().map(container => container.confirmClose(options))).then((results) => !results.find(item => item === false));
    }
    /**
     * @return {?}
     */
    saveActivePaneItem() {
        return this.getCenter().getActivePane().saveActiveItem();
    }
    /**
     * @return {?}
     */
    saveActivePaneItemAs() {
        this.getCenter().getActivePane().saveActiveItemAs();
    }
    /**
     * @return {?}
     */
    destroyActivePaneItem() {
        return this.getActivePane().destroyActiveItem();
    }
    /**
     * @return {?}
     */
    getActivePaneContainer() {
        return this.activePaneContainer;
    }
    /**
     * @return {?}
     */
    getPanes() {
        return new Array().concat(this.getPaneContainers().map(container => container.getPanes()));
    }
    /**
     * @return {?}
     */
    getVisiblePanes() {
        return new Array().concat(this.getVisiblePaneContainers().map(container => container.getPanes()));
    }
    /**
     * @return {?}
     */
    getActivePane() {
        return this.getActivePaneContainer().getActivePane();
    }
    /**
     * @return {?}
     */
    activateNextPane() {
        return this.getActivePaneContainer().activateNextPane();
    }
    /**
     * @return {?}
     */
    activatePreviousPane() {
        return this.getActivePaneContainer().activatePreviousPane();
    }
    /**
     * @param {?} uri
     * @return {?}
     */
    paneContainerForURI(uri) {
        return this.getPaneContainers().find(container => !!container.paneForURI(uri));
    }
    /**
     * @param {?} uri
     * @return {?}
     */
    paneContainerForItem(uri) {
        return this.getPaneContainers().find(container => !!container.paneForItem(uri));
    }
    /**
     * @param {?} uri
     * @return {?}
     */
    paneForURI(uri) {
        for (const location of this.getPaneContainers()) {
            /** @type {?} */
            const pane = location.paneForURI(uri);
            if (pane != null) {
                return pane;
            }
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    paneForItem(item) {
        for (const location of this.getPaneContainers()) {
            /** @type {?} */
            const pane = location.paneForItem(item);
            if (pane != null) {
                return pane;
            }
        }
    }
    /**
     * @return {?}
     */
    destroyActivePane() {
        /** @type {?} */
        const activePane = this.getActivePane();
        if (activePane != null) {
            activePane.destroy();
        }
    }
    /**
     * @return {?}
     */
    closeActivePaneItemOrEmptyPaneOrWindow() {
        if (this.getCenter().getActivePaneItem() != null) {
            this.getCenter().getActivePane().destroyActiveItem();
        }
        else if (this.getCenter().getPanes().length > 1) {
            this.getCenter().destroyActivePane();
        }
        else if (this.config.get('core.closeEmptyWindows')) ;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    itemOpened(item) {
    }
    /**
     * @return {?}
     */
    destroyed() {
        this.paneContainers.center.destroy();
        this.paneContainers.left.destroy();
        this.paneContainers.right.destroy();
        this.paneContainers.bottom.destroy();
        for (const panelLocation in this.panelContainers) {
            if (this.panelContainers.hasOwnProperty(panelLocation)) {
                /** @type {?} */
                const panelContainer = this.panelContainers[panelLocation];
                this.paneContainer.destroy();
            }
        }
    }
    /**
     * @return {?}
     */
    getCenter() {
        return this.paneContainers.center;
    }
    /**
     * @return {?}
     */
    getLeftDock() {
        return this.paneContainers.left;
    }
    /**
     * @return {?}
     */
    getRightDock() {
        return this.paneContainers.right;
    }
    /**
     * @return {?}
     */
    getBottomDock() {
        return this.paneContainers.bottom;
    }
    /**
     * @return {?}
     */
    getPaneContainers() {
        return [
            this.paneContainers.center,
            this.paneContainers.left,
            this.paneContainers.right,
            this.paneContainers.bottom
        ];
    }
    /**
     * @return {?}
     */
    getVisiblePaneContainers() {
        /** @type {?} */
        const center = this.getCenter();
        return this.getPaneContainers()
            .filter(container => container === center || ((/** @type {?} */ (container))).isVisible());
    }
    /**
     * @return {?}
     */
    getBottomPanels() {
        return this.getPanels('bottom');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addBottomPanel(options) {
        return this.addPanel('bottom', options);
    }
    /**
     * @return {?}
     */
    getLeftPanels() {
        return this.getPanels('left');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addLeftPanel(options) {
        return this.addPanel('left', options);
    }
    /**
     * @return {?}
     */
    getRightPanels() {
        return this.getPanels('right');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addRightPanel(options) {
        return this.addPanel('right', options);
    }
    /**
     * @return {?}
     */
    getTopPanels() {
        return this.getPanels('top');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addTopPanel(options) {
        return this.addPanel('top', options);
    }
    /**
     * @return {?}
     */
    getHeaderPanels() {
        return this.getPanels('header');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addHeaderPanel(options) {
        return this.addPanel('header', options);
    }
    /**
     * @return {?}
     */
    getFooterPanels() {
        return this.getPanels('footer');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addFooterPanel(options) {
        return this.addPanel('footer', options);
    }
    /**
     * @return {?}
     */
    getModalPanels() {
        return this.getPanels('modal');
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addModalPanel(options) {
        return this.addPanel('modal', options);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    panelForItem(item) {
        for (const location in this.panelContainers) {
            if (this.panelContainers.hasOwnProperty(location)) {
                /** @type {?} */
                const panel = this.panelContainers[location].panelForItem(item);
                if (panel != null) {
                    return panel;
                }
            }
        }
        return null;
    }
    /**
     * @param {?} location
     * @return {?}
     */
    getPanelContainer(location) {
        return this.panelContainers[location];
    }
    /**
     * @param {?} location
     * @return {?}
     */
    getPanels(location) {
        return this.panelContainers[location].getPanels();
    }
    /**
     * @param {?} location
     * @param {?} options
     * @return {?}
     */
    addPanel(location, options) {
        /** @type {?} */
        const panel = new Panel(options, this.viewRegistry);
        return this.panelContainers[location].addPanel(panel);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GspEventBus extends EventBus {
    constructor() {
        super(...arguments);
        this.commands = [];
    }
    /**
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    on(target, tokenValue, eventName, caller, handler) {
        // 如果有对应激活命令，监听事件时立即执行回调函数
        /** @type {?} */
        const command = this.commands.find(item => item.name === eventName);
        if (command) {
            handler.call(caller, command.eventeParams);
        }
        return super.on(target, tokenValue, eventName, caller, handler);
    }
    /**
     * @param {?} emitterType
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    post(emitterType, tokenValue, eventName, eventArgs) {
        this.dispatchCommand(eventName, eventArgs);
        super.post(emitterType, tokenValue, eventName, eventArgs);
    }
    /**
     * @param {?} commandName
     * @param {?} plugin
     * @param {?} activateFn
     * @return {?}
     */
    registryActivateCommand(commandName, plugin, activateFn) {
        this.commands.push({
            name: commandName,
            plugin,
            activateFn
        });
    }
    /**
     * @private
     * @param {?} commandName
     * @param {?} args
     * @return {?}
     */
    dispatchCommand(commandName, args) {
        /** @type {?} */
        const command = this.commands.find(item => item.name === commandName);
        if (command) {
            command.activateFn(command.plugin);
            command.eventParams = args;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalFrm {
    /**
     * @param {?} options
     * @return {?}
     */
    add(options) {
    }
    /**
     * @param {?} id
     * @return {?}
     */
    show(id) {
    }
    /**
     * @param {?} id
     * @return {?}
     */
    hide(id) {
    }
    /**
     * @param {?} id
     * @return {?}
     */
    close(id) {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 提供ide运行所需的方法，供插件使用
 */
class Ide {
    /**
     * @private
     * @return {?}
     */
    get isTop() {
        return window.top === window;
    }
    /**
     * @private
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    get parentInstance() {
        /** @type {?} */
        let instance = (/** @type {?} */ (this));
        /** @type {?} */
        const top = window.top;
        if (top && top['gsp']) {
            instance = top['gsp'].ide;
        }
        return instance;
    }
    /**
     * @return {?}
     */
    get messager() {
        return this.msgr;
    }
    /**
     * @param {?=} parent
     */
    constructor(parent) {
        this.events = new Map();
        this.modal = new ModalFrm();
        this.frameId = this.getParam('frameID');
        if (this.isTop) {
            this.commandData = new Map();
        }
        if (parent) {
            this.msgr = parent.messager;
        }
    }
    /* #region  frame util */
    /**
     * @param {?} key
     * @return {?}
     */
    getParam(key) {
        /** @type {?} */
        const params = new URLSearchParams(window.location.search);
        return unescape(params.get(key));
    }
    /**
     * @param {?=} frameId
     * @return {?}
     */
    getInitCommandData(frameId) {
        if (!this.isTop) {
            frameId = frameId || this.frameId;
            return this.parentInstance.getInitCommandData(frameId);
        }
        else {
            return this.commandData.get(frameId);
        }
    }
    /**
     * @param {?} frameId
     * @param {?} data
     * @return {?}
     */
    setInitCommandData(frameId, data) {
        if (!this.isTop) {
            this.parentInstance.setInitCommandData(frameId, data);
        }
        else {
            this.commandData.set(frameId, data);
        }
    }
    /**
     * @param {?} messager
     * @return {?}
     */
    setMessager(messager) {
        this.msgr = messager;
    }
    /* #endregion */
    /* #region  event */
    /**
     * @param {?} cb
     * @return {?}
     */
    onPanelAdded(cb) {
        this.on('panel-added', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onPanelRemoved(cb) {
        this.on('panel-removed', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onPanelShown(cb) {
        this.on('panel-shown', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onPanelHidden(cb) {
        this.on('panel-hidden', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onModalConfirming(cb) {
        if (this.parentInstance !== this) {
            this.parentInstance.onModalConfirming(cb);
        }
        else {
            this.on('confirm-modal', cb);
        }
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onModalCancelling(cb) {
        this.on('cancel-modal', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onLeftActivated(cb) {
        if (this.isTop) {
            this.on('activate-left', cb);
        }
        else {
            this.parentInstance.onLeftActivated(cb);
        }
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onNotifyShown(cb) {
        this.on('show-notify', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onLoadingShown(cb) {
        this.on('show-loading', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onLoadingHidden(cb) {
        this.on('hide-loading', cb);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    onDesignerStatusSet(cb) {
        this.on('set-designer-status', cb);
    }
    // onBeforeClose(id: string, cb: () => boolean) {
    //   this.on('on-before-close', ({metadataId}) => {
    //     if (id === metadataId) {
    //       return cb();
    //     }
    //     return true;
    //   });
    // }
    /**
     * @param {?} id
     * @param {?} cb
     * @return {?}
     */
    onCloseTab(id, cb) {
        if (!this.isTop) {
            return this.parentInstance.onCloseTab(id, cb);
        }
        this.on('close-tab', tabId => {
            if (id === tabId) {
                return cb();
            }
            return true;
        });
    }
    /* #endregion */
    /* #region  panel */
    /**
     * @param {?} options
     * @return {?}
     */
    addPanel(options) {
        this.emit('panel-added', options);
    }
    /* #endregion */
    /* #region  modal */
    /**
     * @param {?} options
     * @return {?}
     */
    addModal(options) {
        this.emit('panel-added', options, 'modal');
    }
    /**
     * @param {?=} id
     * @return {?}
     */
    closeModal(id) {
        if (this.parentInstance !== this) {
            this.parentInstance.closeModal(id);
        }
        this.emit('panel-removed', id, 'modal');
    }
    /**
     * @param {?} id
     * @return {?}
     */
    confirmModal(id) {
        /** @type {?} */
        let result = true;
        // if (this.parentInstance !== this) {
        //   result = this.parentInstance.confirmModal(id);
        // }
        result = result && (/** @type {?} */ (this.emit('confirm-modal', id)));
        return result;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    cancelModal(id) {
        /** @type {?} */
        let result = true;
        if (this.parentInstance !== this) {
            result = this.parentInstance.cancelModal(id);
        }
        result = result && (/** @type {?} */ (this.emit('cancel-modal', id)));
        return result;
    }
    // addLeft    registryOpener....
    /* #endregion */
    /* #region  left rigion */
    /**
     * @param {?=} frameId
     * @return {?}
     */
    activateLeft(frameId) {
        frameId = frameId || this.frameId;
        if (this.isTop) {
            this.emit('activate-left', frameId);
        }
        else {
            this.parentInstance.activateLeft(frameId);
        }
    }
    /* #endregion */
    /**
     * @param {?} level
     * @param {?} content
     * @return {?}
     */
    notify(level, content) {
        if (this.isTop) {
            this.emit('show-notify', level, content);
        }
        else {
            this.parentInstance.notify(level, content);
        }
    }
    /**
     * @param {?=} message
     * @return {?}
     */
    loading(message) {
        if (this.isTop) {
            this.emit('show-loading', message);
        }
        else {
            this.parentInstance.loading(message);
        }
    }
    /**
     * @return {?}
     */
    loaded() {
        if (this.isTop) {
            this.emit('hide-loading');
        }
        else {
            this.parentInstance.loaded();
        }
    }
    /**
     * @param {?} metadataId
     * @param {?} isDirty
     * @return {?}
     */
    setDesignerStatus(metadataId, isDirty) {
        if (this.isTop) {
            this.emit('set-designer-status', { id: metadataId, isDirty });
        }
        else {
            this.parentInstance.setDesignerStatus(metadataId, isDirty);
        }
    }
    // closeDesigner(metadataId: string) {
    //   if (this.isTop) {
    //     this.emit('close-designer', {id: metadataId});
    //   } else {
    //     this.parentInstance.closeDesigner(metadataId);
    //   }
    // }
    /**
     * @param {?} id
     * @return {?}
     */
    notifyCloseTab(id) {
        if (!this.isTop) {
            return this.parentInstance.notifyCloseTab(id);
        }
        /** @type {?} */
        const result = this.emit('close-tab', id);
        if (result == null) {
            return of(true);
        }
        else if (typeof result === 'boolean') {
            return of(result);
        }
        else {
            return result;
        }
    }
    /**
     * @param {?} workspace
     * @return {?}
     */
    registerIDE(workspace) {
        // 用来把ide view实例与gsp对象绑定。
        // TODO： view实例监听gsp对象的操作放在这里。
        if (typeof workspace.onCloseDesigner === 'function') {
            this.on('close-designer', workspace.onCloseDesigner.bind(workspace));
        }
    }
    /* #region  private method */
    /**
     * @private
     * @param {?} name
     * @param {?} cb
     * @return {?}
     */
    on(name, cb) {
        /** @type {?} */
        let callbacks = this.events.get(name);
        if (!callbacks) {
            callbacks = [cb];
            this.events.set(name, callbacks);
        }
        else {
            callbacks.push(cb);
        }
    }
    /**
     * @private
     * @param {?} name
     * @param {...?} params
     * @return {?}
     */
    emit(name, ...params) {
        /** @type {?} */
        const callbacks = this.events.get(name);
        if (!callbacks || !callbacks.length) {
            return;
        }
        /** @type {?} */
        let result = true;
        /** @type {?} */
        const observableResult = new Array();
        for (const cb of callbacks) {
            /** @type {?} */
            const cbResult = cb(...params);
            if (cbResult == null) {
                continue;
            }
            if (typeof cbResult === 'boolean') {
                result = result && cbResult;
            }
            else if (typeof cbResult.subscribe === 'function' && cbResult.constructor.name === Observable.name) {
                // 判断条件不能使用cbResult instanceof Observable,因为cb可能是来自于不同的iframe环境，导致跟这里的Observable构造函数不一样。
                observableResult.push(cbResult);
            }
        }
        if (observableResult.length) {
            return forkJoin([...observableResult, of(result)]).pipe(map(results => {
                return results.reduce((previous, current) => previous && current);
            }));
        }
        else {
            return result;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GSP {
    /**
     * @return {?}
     */
    get eventBus() { return this.pEventBus; }
    /**
     * @return {?}
     */
    get util() { return this.pUtil; }
    /**
     * @return {?}
     */
    get workspace() { return this.pWorkspace; }
    /**
     * @return {?}
     */
    get views() { return this.pViews; }
    /**
     * @return {?}
     */
    get commands() { return this.pCommands; }
    /**
     * @return {?}
     */
    get ide() { return this.pIde; }
    /**
     * @return {?}
     */
    get cache() { return this.pCache; }
    /**
     * @return {?}
     */
    get context() { return this.pContext; }
    /**
     * @param {?=} parent
     */
    constructor(parent) {
        this.pConfig = {
            /**
             * @param {?} key
             * @return {?}
             */
            get(key) {
                return this[key];
            }
        };
        /** @type {?} */
        let ide;
        if (parent) {
            this.pViews = parent.views;
            this.pCommands = parent.commands;
            this.pEventBus = parent.eventBus;
            this.pUtil = parent.util;
            this.pWorkspace = parent.workspace;
            this.pCache = parent.cache;
            ide = parent.ide;
            /** @type {?} */
            const ctor = parent.context.constructor;
            this.pContext = new ctor();
        }
        else {
            this.pViews = new ViewRegistry(this);
            this.pCommands = new CommandRegistry();
            this.pEventBus = new GspEventBus();
            this.pUtil = new Util();
            this.pWorkspace = new Workspace({
                config: this.pConfig,
                viewRegistry: this.pViews
            });
            this.pCache = new CacheService(null);
        }
        this.pIde = new Ide(ide);
    }
    /**
     * @deprecated 由子模块独自创建gsp实例，传入父实例作为参数。
     * 每个iframe持有一个独有的gsp实例，其中eventbus共享，ide不共享
     * @return {?}
     */
    createChild() {
        /** @type {?} */
        const child = new GSP(this);
        // child.pEventBus = this.pEventBus;
        // child.pViews = this.pViews;
        // child.pWorkspace = this.pWorkspace;
        return child;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// export enum Location {
//   top,
//   left,
//   right,
//   bottom,
//   header,
//   footer,
//   modal
// }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Messager {
    /**
     * @param {?} message
     * @param {?=} callback
     * @return {?}
     */
    info(message, callback) {
    }
    /**
     * @param {?} message
     * @param {?} okCallback
     * @param {?=} cancelCallback
     * @return {?}
     */
    question(message, okCallback, cancelCallback) {
    }
    /**
     * @param {?} message
     * @return {?}
     */
    confirm(message) {
        return null;
    }
    /**
     * @param {?} message
     * @return {?}
     */
    error(message) {
    }
    /**
     * @param {?} message
     * @return {?}
     */
    warning(message) {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PackageView {
    /**
     * @param {?} serializedState
     */
    constructor(serializedState) {
    }
    /**
     * @return {?}
     */
    getElement() {
        return this.element;
    }
    /**
     * Returns an object that can be retrieved when package is activated.
     * @return {?}
     */
    serialize() { }
    /**
     * @return {?}
     */
    destroy() {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Package {
    /**
     * @param {?} gsp
     */
    constructor(gsp) {
        this.gsp = gsp;
        // leftPanel: any;
        // modelPanel: any;
        this.subscriptions = [];
        this.packageId = gsp.util.newGuid();
    }
    /**
     * @return {?}
     */
    get id() {
        return this.packageId;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this.packageId = value;
    }
    /**
     * @return {?}
     */
    get view() {
        return this.packageView;
    }
    /**
     * @param {?} state
     * @return {?}
     */
    activate(state) {
        this.packageView = new PackageView(state.sagipackageViewState);
        // /*this.leftPanel = */this.ws.addLeftPanel({
        //   title: 'test',
        //   item: this.packageView.getComponent(),
        //   visible: false
        // });
    }
    /**
     * @return {?}
     */
    initialize() { }
    /**
     * @return {?}
     */
    deactivate() {
        this.packageView.destroy();
    }
    /**
     * @return {?}
     */
    serialize() {
        return {
            sagipackageViewState: this.packageView.serialize()
        };
    }
    /**
     * @return {?}
     */
    toggle() {
        // return (
        //   this.modelPanel.isVisible() ?
        //     this.modelPanel.hide() :
        //     this.modelPanel.show()
        // );
    }
    /**
     * @return {?}
     */
    getComponent() {
        return null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PackageModule {
    constructor() {
    }
    /**
     * @param {?} gsp
     * @return {?}
     */
    getPackage(gsp) {
        if (!this.package) {
            this.initPackage(gsp);
            // ng7升级后，插件包是iframe的形式，初始化方式改变。
            if (this.package) {
                this.package.initialize();
            }
        }
        return this.package;
    }
    /**
     * @protected
     * @param {?} gsp
     * @return {?}
     */
    initPackage(gsp) {
        this.package = new Package(gsp);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CacheModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: CacheModule,
            providers: [
                CacheLocalStorage,
                CacheMemoryStorage,
                CacheSessionStorage,
                CacheService
            ]
        };
    }
}
CacheModule.decorators = [
    { type: NgModule, args: [{
                declarations: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpService {
    /**
     * @param {?} http
     * @param {?} cache
     */
    constructor(http, cache) {
        this.http = http;
        this.cache = cache;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    get(url) {
        return this.request('Get', url, this.setHeader({}));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    post(url, body) {
        return this.request('Post', url, this.setHeader({ body }));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    put(url, body) {
        return this.request('Put', url, this.setHeader({ body }));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    delete(url, body) {
        return this.request('Delete', url, this.setHeader({ body }));
    }
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    patch(url, body) {
        return this.request('Patch', url, this.setHeader({ body }));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    setHeader(options) {
        options.headers = {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        };
        if (this.cache.exists('sessionId') && this.cache.get('sessionId')) {
            options.headers['SessionId'] = this.cache.get('sessionId');
        }
        return options;
    }
    /**
     * @param {?} method
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    request(method, url, options) {
        if (options.body) {
            if (typeof options.body !== 'string') {
                options.body = JSON.stringify(options.body);
            }
        }
        return this.http.request(method, url, options)
            .pipe(map((data) => {
            console.log(data);
            return data;
        }));
    }
}
HttpService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HttpService.ctorParameters = () => [
    { type: HttpClient },
    { type: CacheService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GSPHttpModule {
}
GSPHttpModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule
                ],
                providers: [HttpService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BsDropdownConfig, BsDropdownContainerComponent, BsDropdownDirective, BsDropdownMenuDirective, BsDropdownModule, BsDropdownState, BsDropdownToggleDirective, DropdownButtonDirective, DropdownItemDirective, PanelModule, NgbAccordionModule, NgbTabsetModule, NgbTabsetConfig, NgbTabset, NgbTab, NgbTabContent, NgbTabTitle, NgbNavTabsetModule, NgbNavTabsetConfig, NgbNavTabset, NgbNavTab, NgbNavTabContent, NgbNavTabTitle, AlertComponent, AlertModule, AlertConfig, TooltipContainerComponent, TooltipDirective, TooltipModule, TooltipConfig, BsModalRef, ModalBackdropOptions, ModalContainerComponent, ModalBackdropComponent, ModalOptions, ModalDirective, ModalModule$1 as ModalModule, BsModalService$1 as BsModalService, NavbarDirective, NavbarState, NavbarModule, TreeModule, TreeComponent, TreeNode, AngularMonacoEditorModule, CODE_EDITOR_INPUT_VALUE_ACCESSOR, AngularMonacoEditorComponent, ANGULAR_MONACO_EDITOR_CONFIG, CODE_EDITOR_EVENTS, CodeEditorEventService, AngularMonacoEditorService, ShContextMenuModule, ShContextMenuComponent, ShAttachMenuDirective, ShContextMenuItemDirective, ShContextMenuService, WizardComponent, WizardModule, ComboListModule$1 as ComboListModule, ComboService, ComboListComponent, PropertyPanelModule, PropertyType, ElementPropertyConfig, PropertyEntity, BeforeOpenModalResult, PropertyChangeObject, PropertyPanelComponent, NgbRootModule, NgbModule, IDERootModule, PopoverDirective, PopoverModule, PopoverConfig, PopoverContainerComponent, OnChange, LinkedList, isBs3$1 as isBs3, Trigger, Utils, warnOnce, positionElements, Positioning, PositioningService, ComponentLoader, ComponentLoaderFactory, ContentRef, win as window, document$1 as document, location, gc, performance, Event$1 as Event, MouseEvent, KeyboardEvent, EventTarget, History, Location, EventListener, EventBus, EventBusProxy, EventPipe, Package, PackageModule, PackageView, Util, DockStyle, Dock, GSP, GspEventBus, ItemRegistry, Model, PaneAxis, PaneContainer, Panel, ViewRegistry, WorkspaceCenter, Workspace, Ide, Messager, CacheService, CacheStorageAbstract, CacheLocalStorage, CacheMemoryStorage, CacheSessionStorage, CacheModule, GSPHttpModule, HttpService, NgbAccordion as ɵf, NgbPanel as ɵe, NgbPanelContent as ɵd, NgbPanelTitle as ɵc, NgbAccordionConfig as ɵg, BaseMonacoEditor as ɵm, CLASS_NAME as ɵa, MenuItemContext as ɵb, TreeNodeContentComponent as ɵk, TreeNodeDropSlotComponent as ɵl, TreeNodeComponent as ɵi, TreeNodeContentDirective as ɵj, TreeModel as ɵh, SashDirective as ɵp, PropertyItemListComponent as ɵn, PropertyItemComponent as ɵo, EventBus as ɵq };

//# sourceMappingURL=farris-ide-devkit.js.map