import { TemplatePortal } from '@angular/cdk/portal';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { merge } from 'rxjs/observable/merge';
import { Overlay, OverlayModule } from '@angular/cdk/overlay';
import { first, last, pick, includes, assign, find, findIndex, merge as merge$1 } from 'lodash-es';
import { PerfectScrollbarModule } from '@farris/ui-perfect-scrollbar';
import { InputGroupModule } from '@farris/ui-input-group';
import { DatalistModule } from '@farris/ui-datalist';
import { NG_VALUE_ACCESSOR, FormsModule, NgControl } from '@angular/forms';
import { InputsModule } from '@progress/kendo-angular-inputs';
import { DropDownsModule } from '@progress/kendo-angular-dropdowns';
import { NotifyService, NotifyModule } from '@farris/ui-notify';
import { ComboListModule } from '@farris/ui-combo-list';
import { BsModalService, ModalModule } from '@farris/ui-modal';
import { FarrisDatePickerModule } from '@farris/ui-datepicker';
import { NumberSpinnerModule } from '@farris/ui-number-spinner';
import { CommonModule, DOCUMENT } from '@angular/common';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { __values, __spread, __extends, __decorate, __metadata, __assign, __read, __awaiter, __generator } from 'tslib';
import { timer, BehaviorSubject, Subject, fromEvent as fromEvent$1, interval, forkJoin, Observable, of } from 'rxjs';
import { Injectable, ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Input, Output, NgModule, ComponentRef, ElementRef, ReflectiveInjector, TemplateRef, ContentChild, ContentChildren, Directive, QueryList, Optional, ViewContainerRef, HostListener, Renderer2, ViewChild, ComponentFactoryResolver, Injector, ViewChildren, ViewEncapsulation, RendererFactory2, InjectionToken, isDevMode, HostBinding, ApplicationRef, NgZone, Type, forwardRef, Inject, defineInjectable, inject, INJECTOR } from '@angular/core';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { filter, takeUntil, skip, debounceTime, throttle, mapTo, map } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AlertConfig = /** @class */ (function () {
    function AlertConfig() {
        /**
         * default alert type
         */
        this.type = 'warning';
        /**
         * is alerts are dismissible by default
         */
        this.dismissible = false;
        /**
         * default time before alert will dismiss
         */
        this.dismissOnTimeout = undefined;
    }
    AlertConfig.decorators = [
        { type: Injectable }
    ];
    return AlertConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*tslint:disable:no-invalid-this */
/**
 * @return {?}
 */
function OnChange() {
    /** @type {?} */
    var sufix = 'Change';
    return function OnChangeHandler(target, propertyKey) {
        /** @type {?} */
        var _key = " __" + propertyKey + "Value";
        Object.defineProperty(target, propertyKey, {
            get: /**
             * @return {?}
             */
            function () { return this[_key]; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var prevValue = this[_key];
                this[_key] = value;
                if (prevValue !== value && this[propertyKey + sufix]) {
                    this[propertyKey + sufix].emit(value);
                }
            }
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AlertComponent = /** @class */ (function () {
    function AlertComponent(_config, changeDetection) {
        var _this = this;
        this.changeDetection = changeDetection;
        /**
         * Alert type.
         * Provides one of four bootstrap supported contextual classes:
         * `success`, `info`, `warning` and `danger`
         */
        this.type = 'warning';
        /**
         * If set, displays an inline "Close" button
         */
        this.dismissible = false;
        /**
         * Is alert visible
         */
        this.isOpen = true;
        /**
         * This event fires immediately after close instance method is called,
         * $event is an instance of Alert component.
         */
        this.onClose = new EventEmitter();
        /**
         * This event fires when alert closed, $event is an instance of Alert component
         */
        this.onClosed = new EventEmitter();
        this.classes = '';
        this.dismissibleChange = new EventEmitter();
        Object.assign(this, _config);
        this.dismissibleChange.subscribe(function (dismissible) {
            _this.classes = _this.dismissible ? 'alert-dismissible' : '';
            _this.changeDetection.markForCheck();
        });
    }
    /**
     * @return {?}
     */
    AlertComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.dismissOnTimeout) {
            // if dismissOnTimeout used as attr without binding, it will be a string
            setTimeout(function () { return _this.close(); }, parseInt((/** @type {?} */ (this.dismissOnTimeout)), 10));
        }
    };
    // todo: animation ` If the .fade and .in classes are present on the element,
    // the alert will fade out before it is removed`
    /**
     * Closes an alert by removing it from the DOM.
     */
    // todo: animation ` If the .fade and .in classes are present on the element,
    // the alert will fade out before it is removed`
    /**
     * Closes an alert by removing it from the DOM.
     * @return {?}
     */
    AlertComponent.prototype.close = 
    // todo: animation ` If the .fade and .in classes are present on the element,
    // the alert will fade out before it is removed`
    /**
     * Closes an alert by removing it from the DOM.
     * @return {?}
     */
    function () {
        if (!this.isOpen) {
            return;
        }
        this.onClose.emit(this);
        this.isOpen = false;
        this.changeDetection.markForCheck();
        this.onClosed.emit(this);
    };
    AlertComponent.decorators = [
        { type: Component, args: [{
                    selector: 'alert,bs-alert',
                    template: "<ng-template [ngIf]=\"isOpen\">\r\n  <div [class]=\"'alert alert-' + type\" role=\"alert\" [ngClass]=\"classes\">\r\n    <ng-template [ngIf]=\"dismissible\">\r\n      <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"close()\">\r\n        <span aria-hidden=\"true\">&times;</span>\r\n        <span class=\"sr-only\">Close</span>\r\n      </button>\r\n    </ng-template>\r\n    <ng-content></ng-content>\r\n  </div>\r\n</ng-template>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    AlertComponent.ctorParameters = function () { return [
        { type: AlertConfig },
        { type: ChangeDetectorRef }
    ]; };
    AlertComponent.propDecorators = {
        type: [{ type: Input }],
        dismissible: [{ type: Input }],
        dismissOnTimeout: [{ type: Input }],
        isOpen: [{ type: Input }],
        onClose: [{ type: Output }],
        onClosed: [{ type: Output }]
    };
    __decorate([
        OnChange(),
        __metadata("design:type", Object)
    ], AlertComponent.prototype, "dismissible", void 0);
    return AlertComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AlertModule = /** @class */ (function () {
    function AlertModule() {
    }
    /**
     * @return {?}
     */
    AlertModule.forRoot = /**
     * @return {?}
     */
    function () {
        return { ngModule: AlertModule, providers: [AlertConfig] };
    };
    AlertModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [AlertComponent],
                    exports: [AlertComponent],
                    entryComponents: [AlertComponent]
                },] }
    ];
    return AlertModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Default values provider for tooltip
 */
var TooltipConfig = /** @class */ (function () {
    function TooltipConfig() {
        /**
         * tooltip placement, supported positions: 'top', 'bottom', 'left', 'right'
         */
        this.placement = 'top';
        /**
         * array of event names which triggers tooltip opening
         */
        this.triggers = 'hover focus';
    }
    TooltipConfig.decorators = [
        { type: Injectable }
    ];
    return TooltipConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*tslint:disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * JS version of browser APIs. This library can only run in the browser.
 * @type {?}
 */
var win = (typeof window !== 'undefined' && window) || (/** @type {?} */ ({}));
/** @type {?} */
var document$1 = win.document;
/** @type {?} */
var location = win.location;
/** @type {?} */
var gc = win['gc'] ? function () { return win['gc'](); } : function () { return null; };
/** @type {?} */
var performance = win['performance'] ? win['performance'] : null;
/** @type {?} */
var Event$1 = win['Event'];
/** @type {?} */
var MouseEvent = win['MouseEvent'];
/** @type {?} */
var KeyboardEvent = win['KeyboardEvent'];
/** @type {?} */
var EventTarget = win['EventTarget'];
/** @type {?} */
var History = win['History'];
/** @type {?} */
var Location = win['Location'];
/** @type {?} */
var EventListener = win['EventListener'];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var guessedVersion;
/**
 * @return {?}
 */
function _guessBsVersion() {
    if (typeof document === 'undefined') {
        return null;
    }
    /** @type {?} */
    var spanEl = document.createElement('span');
    spanEl.innerText = 'test bs version';
    document.body.appendChild(spanEl);
    spanEl.classList.add('d-none');
    /** @type {?} */
    var rect = spanEl.getBoundingClientRect();
    document.body.removeChild(spanEl);
    if (!rect) {
        return 'bs3';
    }
    return rect.top === 0 ? 'bs4' : 'bs3';
}
// todo: in ngx-bootstrap, bs4 will became a default one
/**
 * @return {?}
 */
function isBs3() {
    if (typeof win === 'undefined') {
        return true;
    }
    if (typeof win.__theme === 'undefined') {
        if (guessedVersion) {
            return guessedVersion === 'bs3';
        }
        guessedVersion = _guessBsVersion();
        return guessedVersion === 'bs3';
    }
    return win.__theme !== 'bs4';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TooltipContainerComponent = /** @class */ (function () {
    function TooltipContainerComponent(config) {
        Object.assign(this, config);
    }
    Object.defineProperty(TooltipContainerComponent.prototype, "isBs3", {
        get: /**
         * @return {?}
         */
        function () {
            return isBs3();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TooltipContainerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.classMap = { in: false, fade: false };
        this.classMap[this.placement] = true;
        this.classMap["tooltip-" + this.placement] = true;
        this.classMap.in = true;
        if (this.animation) {
            this.classMap.fade = true;
        }
        if (this.containerClass) {
            this.classMap[this.containerClass] = true;
        }
    };
    TooltipContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'bs-tooltip-container',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    // tslint:disable-next-line
                    host: {
                        '[class]': '"tooltip in tooltip-" + placement + " " + "bs-tooltip-" + placement + " " + placement + " " + containerClass',
                        '[class.show]': '!isBs3',
                        role: 'tooltip'
                    },
                    template: "\n    <div class=\"tooltip-arrow arrow\"></div>\n    <div class=\"tooltip-inner\"><ng-content></ng-content></div>\n    ",
                    styles: ["\n    :host.tooltip {\n      display: block;\n    }\n    :host.bs-tooltip-top .arrow, :host.bs-tooltip-bottom .arrow {\n      left: 50%;\n      margin-left: -6px;\n    }\n    :host.bs-tooltip-left .arrow, :host.bs-tooltip-right .arrow {\n      top: 50%;\n      margin-top: -6px;\n    }\n  "]
                }] }
    ];
    /** @nocollapse */
    TooltipContainerComponent.ctorParameters = function () { return [
        { type: TooltipConfig }
    ]; };
    return TooltipContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @copyright Valor Software
 * @copyright Angular ng-bootstrap team
 */
var Trigger = /** @class */ (function () {
    function Trigger(open, close) {
        this.open = open;
        this.close = close || open;
    }
    /**
     * @return {?}
     */
    Trigger.prototype.isManual = /**
     * @return {?}
     */
    function () { return this.open === 'manual' || this.close === 'manual'; };
    return Trigger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_ALIASES = {
    hover: ['mouseover', 'mouseout'],
    focus: ['focusin', 'focusout']
};
/**
 * @param {?} triggers
 * @param {?=} aliases
 * @return {?}
 */
function parseTriggers(triggers, aliases) {
    if (aliases === void 0) { aliases = DEFAULT_ALIASES; }
    /** @type {?} */
    var trimmedTriggers = (triggers || '').trim();
    if (trimmedTriggers.length === 0) {
        return [];
    }
    /** @type {?} */
    var parsedTriggers = trimmedTriggers
        .split(/\s+/)
        .map(function (trigger) { return trigger.split(':'); })
        .map(function (triggerPair) {
        /** @type {?} */
        var alias = aliases[triggerPair[0]] || triggerPair;
        return new Trigger(alias[0], alias[1]);
    });
    /** @type {?} */
    var manualTriggers = parsedTriggers.filter(function (triggerPair) {
        return triggerPair.isManual();
    });
    if (manualTriggers.length > 1) {
        throw new Error('Triggers parse error: only one manual trigger is allowed');
    }
    if (manualTriggers.length === 1 && parsedTriggers.length > 1) {
        throw new Error('Triggers parse error: manual trigger can\'t be mixed with other triggers');
    }
    return parsedTriggers;
}
/**
 * @param {?} renderer
 * @param {?} options
 * @return {?}
 */
function listenToTriggersV2(renderer, options) {
    /** @type {?} */
    var parsedTriggers = parseTriggers(options.triggers);
    /** @type {?} */
    var target = options.target;
    // do nothing
    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {
        return Function.prototype;
    }
    // all listeners
    /** @type {?} */
    var listeners = [];
    // lazy listeners registration
    /** @type {?} */
    var _registerHide = [];
    /** @type {?} */
    var registerHide = function () {
        // add hide listeners to unregister array
        _registerHide.forEach(function (fn) { return listeners.push(fn()); });
        // register hide events only once
        _registerHide.length = 0;
    };
    // register open\close\toggle listeners
    parsedTriggers.forEach(function (trigger) {
        /** @type {?} */
        var useToggle = trigger.open === trigger.close;
        /** @type {?} */
        var showFn = useToggle ? options.toggle : options.show;
        if (!useToggle) {
            _registerHide.push(function () {
                return renderer.listen(target, trigger.close, options.hide);
            });
        }
        listeners.push(renderer.listen(target, trigger.open, function () { return showFn(registerHide); }));
    });
    return function () {
        listeners.forEach(function (unsubscribeFn) { return unsubscribeFn(); });
    };
}
/**
 * @param {?} renderer
 * @param {?} options
 * @return {?}
 */
function registerOutsideClick(renderer, options) {
    if (!options.outsideClick) {
        return Function.prototype;
    }
    return renderer.listen('document', 'click', function (event) {
        if (options.target && options.target.contains(event.target)) {
            return;
        }
        if (options.targets &&
            options.targets.some(function (target) { return target.contains(event.target); })) {
            return;
        }
        options.hide();
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @copyright Valor Software
 * @copyright Angular ng-bootstrap team
 */
var ContentRef = /** @class */ (function () {
    function ContentRef(nodes, viewRef, componentRef) {
        this.nodes = nodes;
        this.viewRef = viewRef;
        this.componentRef = componentRef;
    }
    return ContentRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
ComponentLoader = /** @class */ (function () {
    /**
     * Do not use this directly, it should be instanced via
     * `ComponentLoadFactory.attach`
     * @internal
     */
    // tslint:disable-next-line
    function ComponentLoader(_viewContainerRef, _renderer, _elementRef, _injector, _componentFactoryResolver, _ngZone, _applicationRef, _posService) {
        this._viewContainerRef = _viewContainerRef;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._injector = _injector;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._ngZone = _ngZone;
        this._applicationRef = _applicationRef;
        this._posService = _posService;
        this.onBeforeShow = new EventEmitter();
        this.onShown = new EventEmitter();
        this.onBeforeHide = new EventEmitter();
        this.onHidden = new EventEmitter();
        this._providers = [];
        this._isHiding = false;
        this._listenOpts = {};
        this._globalListener = Function.prototype;
    }
    Object.defineProperty(ComponentLoader.prototype, "isShown", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._isHiding) {
                return false;
            }
            return !!this._componentRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} compType
     * @return {?}
     */
    ComponentLoader.prototype.attach = /**
     * @param {?} compType
     * @return {?}
     */
    function (compType) {
        this._componentFactory = this._componentFactoryResolver
            .resolveComponentFactory(compType);
        return this;
    };
    // todo: add behaviour: to target element, `body`, custom element
    // todo: add behaviour: to target element, `body`, custom element
    /**
     * @param {?=} container
     * @return {?}
     */
    ComponentLoader.prototype.to = 
    // todo: add behaviour: to target element, `body`, custom element
    /**
     * @param {?=} container
     * @return {?}
     */
    function (container) {
        this.container = container || this.container;
        return this;
    };
    /**
     * @param {?=} opts
     * @return {?}
     */
    ComponentLoader.prototype.position = /**
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        this.attachment = opts.attachment || this.attachment;
        this._elementRef = ((/** @type {?} */ (opts.target))) || this._elementRef;
        return this;
    };
    /**
     * @param {?} provider
     * @return {?}
     */
    ComponentLoader.prototype.provide = /**
     * @param {?} provider
     * @return {?}
     */
    function (provider) {
        this._providers.push(provider);
        return this;
    };
    // todo: appendChild to element or document.querySelector(this.container)
    // todo: appendChild to element or document.querySelector(this.container)
    /**
     * @param {?=} opts
     * @return {?}
     */
    ComponentLoader.prototype.show = 
    // todo: appendChild to element or document.querySelector(this.container)
    /**
     * @param {?=} opts
     * @return {?}
     */
    function (opts) {
        if (opts === void 0) { opts = {}; }
        this._subscribePositioning();
        this._innerComponent = null;
        if (!this._componentRef) {
            this.onBeforeShow.emit();
            this._contentRef = this._getContentRef(opts.content, opts.context, opts.initialState);
            /** @type {?} */
            var injector = ReflectiveInjector.resolveAndCreate(this._providers, this._injector);
            this._componentRef = this._componentFactory.create(injector, this._contentRef.nodes);
            this._applicationRef.attachView(this._componentRef.hostView);
            // this._componentRef = this._viewContainerRef
            //   .createComponent(this._componentFactory, 0, injector, this._contentRef.nodes);
            this.instance = this._componentRef.instance;
            Object.assign(this._componentRef.instance, opts);
            if (this.container instanceof ElementRef) {
                this.container.nativeElement.appendChild(this._componentRef.location.nativeElement);
            }
            if (this.container === 'body' && typeof document !== 'undefined') {
                document
                    .querySelector((/** @type {?} */ (this.container)))
                    .appendChild(this._componentRef.location.nativeElement);
            }
            if (!this.container &&
                this._elementRef &&
                this._elementRef.nativeElement.parentElement) {
                this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement);
            }
            // we need to manually invoke change detection since events registered
            // via
            // Renderer::listen() are not picked up by change detection with the
            // OnPush strategy
            if (this._contentRef.componentRef) {
                this._innerComponent = this._contentRef.componentRef.instance;
                this._contentRef.componentRef.changeDetectorRef.markForCheck();
                this._contentRef.componentRef.changeDetectorRef.detectChanges();
            }
            this._componentRef.changeDetectorRef.markForCheck();
            this._componentRef.changeDetectorRef.detectChanges();
            this.onShown.emit(this._componentRef.instance);
        }
        this._registerOutsideClick();
        return this._componentRef;
    };
    /**
     * @return {?}
     */
    ComponentLoader.prototype.hide = /**
     * @return {?}
     */
    function () {
        if (!this._componentRef) {
            return this;
        }
        this.onBeforeHide.emit(this._componentRef.instance);
        /** @type {?} */
        var componentEl = this._componentRef.location.nativeElement;
        componentEl.parentNode.removeChild(componentEl);
        if (this._contentRef.componentRef) {
            this._contentRef.componentRef.destroy();
        }
        this._componentRef.destroy();
        if (this._viewContainerRef && this._contentRef.viewRef) {
            this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
        }
        if (this._contentRef.viewRef) {
            this._contentRef.viewRef.destroy();
        }
        // this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._componentRef.hostView));
        //
        // if (this._contentRef.viewRef && this._viewContainerRef.indexOf(this._contentRef.viewRef) !== -1) {
        //   this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
        // }
        this._contentRef = null;
        this._componentRef = null;
        this._removeGlobalListener();
        this.onHidden.emit();
        return this;
    };
    /**
     * @return {?}
     */
    ComponentLoader.prototype.toggle = /**
     * @return {?}
     */
    function () {
        if (this.isShown) {
            this.hide();
            return;
        }
        this.show();
    };
    /**
     * @return {?}
     */
    ComponentLoader.prototype.dispose = /**
     * @return {?}
     */
    function () {
        if (this.isShown) {
            this.hide();
        }
        this._unsubscribePositioning();
        if (this._unregisterListenersFn) {
            this._unregisterListenersFn();
        }
    };
    /**
     * @param {?} listenOpts
     * @return {?}
     */
    ComponentLoader.prototype.listen = /**
     * @param {?} listenOpts
     * @return {?}
     */
    function (listenOpts) {
        var _this = this;
        this.triggers = listenOpts.triggers || this.triggers;
        this._listenOpts.outsideClick = listenOpts.outsideClick;
        listenOpts.target = listenOpts.target || this._elementRef.nativeElement;
        /** @type {?} */
        var hide = (this._listenOpts.hide = function () {
            return listenOpts.hide ? listenOpts.hide() : void _this.hide();
        });
        /** @type {?} */
        var show = (this._listenOpts.show = function (registerHide) {
            listenOpts.show ? listenOpts.show(registerHide) : _this.show(registerHide);
            registerHide();
        });
        /** @type {?} */
        var toggle = function (registerHide) {
            _this.isShown ? hide() : show(registerHide);
        };
        this._unregisterListenersFn = listenToTriggersV2(this._renderer, {
            target: listenOpts.target,
            triggers: listenOpts.triggers,
            show: show,
            hide: hide,
            toggle: toggle
        });
        return this;
    };
    /**
     * @return {?}
     */
    ComponentLoader.prototype._removeGlobalListener = /**
     * @return {?}
     */
    function () {
        if (this._globalListener) {
            this._globalListener();
            this._globalListener = null;
        }
    };
    /**
     * @param {?} vRef
     * @param {?} template
     * @return {?}
     */
    ComponentLoader.prototype.attachInline = /**
     * @param {?} vRef
     * @param {?} template
     * @return {?}
     */
    function (vRef, template) {
        this._inlineViewRef = vRef.createEmbeddedView(template);
        return this;
    };
    /**
     * @return {?}
     */
    ComponentLoader.prototype._registerOutsideClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this._componentRef || !this._componentRef.location) {
            return;
        }
        // why: should run after first event bubble
        if (this._listenOpts.outsideClick) {
            /** @type {?} */
            var target_1 = this._componentRef.location.nativeElement;
            setTimeout(function () {
                _this._globalListener = registerOutsideClick(_this._renderer, {
                    targets: [target_1, _this._elementRef.nativeElement],
                    outsideClick: _this._listenOpts.outsideClick,
                    hide: function () { return _this._listenOpts.hide(); }
                });
            });
        }
    };
    /**
     * @return {?}
     */
    ComponentLoader.prototype.getInnerComponent = /**
     * @return {?}
     */
    function () {
        return this._innerComponent;
    };
    /**
     * @private
     * @return {?}
     */
    ComponentLoader.prototype._subscribePositioning = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._zoneSubscription || !this.attachment) {
            return;
        }
        this._zoneSubscription = this._ngZone.onStable.subscribe(function () {
            if (!_this._componentRef) {
                return;
            }
            _this._posService.position({
                element: _this._componentRef.location,
                target: _this._elementRef,
                attachment: _this.attachment,
                appendToBody: _this.container === 'body'
            });
        });
    };
    /**
     * @private
     * @return {?}
     */
    ComponentLoader.prototype._unsubscribePositioning = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this._zoneSubscription) {
            return;
        }
        this._zoneSubscription.unsubscribe();
        this._zoneSubscription = null;
    };
    /**
     * @private
     * @param {?} content
     * @param {?=} context
     * @param {?=} initialState
     * @return {?}
     */
    ComponentLoader.prototype._getContentRef = /**
     * @private
     * @param {?} content
     * @param {?=} context
     * @param {?=} initialState
     * @return {?}
     */
    function (content, context, initialState) {
        if (!content) {
            return new ContentRef([]);
        }
        if (content instanceof TemplateRef) {
            if (this._viewContainerRef) {
                /** @type {?} */
                var _viewRef = this._viewContainerRef
                    .createEmbeddedView(content, context);
                _viewRef.markForCheck();
                return new ContentRef([_viewRef.rootNodes], _viewRef);
            }
            /** @type {?} */
            var viewRef = content.createEmbeddedView({});
            this._applicationRef.attachView(viewRef);
            return new ContentRef([viewRef.rootNodes], viewRef);
        }
        if (typeof content === 'function') {
            /** @type {?} */
            var contentCmptFactory = this._componentFactoryResolver.resolveComponentFactory(content);
            /** @type {?} */
            var modalContentInjector = ReflectiveInjector.resolveAndCreate(__spread(this._providers), this._injector);
            /** @type {?} */
            var componentRef = contentCmptFactory.create(modalContentInjector);
            Object.assign(componentRef.instance, initialState);
            this._applicationRef.attachView(componentRef.hostView);
            return new ContentRef([[componentRef.location.nativeElement]], componentRef.hostView, componentRef);
        }
        // 支持传入的content是一个ComponentRef实例 added by liyz
        if (content instanceof ComponentRef) {
            Object.assign(content.instance, initialState);
            this._applicationRef.attachView(content.hostView);
            return new ContentRef([[content.location.nativeElement]], content.hostView, content);
        }
        return new ContentRef([[this._renderer.createText("" + content)]]);
    };
    return ComponentLoader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @copyright Valor Software
 * @copyright Angular ng-bootstrap team
 */
// previous version:
// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js
// tslint:disable
var  
// previous version:
// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js
// tslint:disable
Positioning = /** @class */ (function () {
    function Positioning() {
    }
    /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    Positioning.prototype.position = /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    function (element, round) {
        if (round === void 0) { round = true; }
        /** @type {?} */
        var elPosition;
        /** @type {?} */
        var parentOffset = {
            width: 0,
            height: 0,
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        if (this.getStyle(element, 'position') === 'fixed') {
            /** @type {?} */
            var bcRect = element.getBoundingClientRect();
            elPosition = {
                width: bcRect.width,
                height: bcRect.height,
                top: bcRect.top,
                bottom: bcRect.bottom,
                left: bcRect.left,
                right: bcRect.right
            };
        }
        else {
            /** @type {?} */
            var offsetParentEl = this.offsetParent(element);
            elPosition = this.offset(element, false);
            if (offsetParentEl !== document.documentElement) {
                parentOffset = this.offset(offsetParentEl, false);
            }
            parentOffset.top += offsetParentEl.clientTop;
            parentOffset.left += offsetParentEl.clientLeft;
        }
        elPosition.top -= parentOffset.top;
        elPosition.bottom -= parentOffset.top;
        elPosition.left -= parentOffset.left;
        elPosition.right -= parentOffset.left;
        if (round) {
            elPosition.top = Math.round(elPosition.top);
            elPosition.bottom = Math.round(elPosition.bottom);
            elPosition.left = Math.round(elPosition.left);
            elPosition.right = Math.round(elPosition.right);
        }
        return elPosition;
    };
    /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    Positioning.prototype.offset = /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    function (element, round) {
        if (round === void 0) { round = true; }
        /** @type {?} */
        var elBcr = element.getBoundingClientRect();
        /** @type {?} */
        var viewportOffset = {
            top: window.pageYOffset - document.documentElement.clientTop,
            left: window.pageXOffset - document.documentElement.clientLeft
        };
        /** @type {?} */
        var elOffset = {
            height: elBcr.height || element.offsetHeight,
            width: elBcr.width || element.offsetWidth,
            top: elBcr.top + viewportOffset.top,
            bottom: elBcr.bottom + viewportOffset.top,
            left: elBcr.left + viewportOffset.left,
            right: elBcr.right + viewportOffset.left
        };
        if (round) {
            elOffset.height = Math.round(elOffset.height);
            elOffset.width = Math.round(elOffset.width);
            elOffset.top = Math.round(elOffset.top);
            elOffset.bottom = Math.round(elOffset.bottom);
            elOffset.left = Math.round(elOffset.left);
            elOffset.right = Math.round(elOffset.right);
        }
        return elOffset;
    };
    /**
     * @param {?} hostElement
     * @param {?} targetElement
     * @param {?} placement
     * @param {?=} appendToBody
     * @return {?}
     */
    Positioning.prototype.positionElements = /**
     * @param {?} hostElement
     * @param {?} targetElement
     * @param {?} placement
     * @param {?=} appendToBody
     * @return {?}
     */
    function (hostElement, targetElement, placement, appendToBody) {
        /** @type {?} */
        var hostElPosition = appendToBody
            ? this.offset(hostElement, false)
            : this.position(hostElement, false);
        /** @type {?} */
        var targetElStyles = this.getAllStyles(targetElement);
        /** @type {?} */
        var shiftWidth = {
            left: hostElPosition.left,
            center: hostElPosition.left +
                hostElPosition.width / 2 -
                targetElement.offsetWidth / 2,
            right: hostElPosition.left + hostElPosition.width
        };
        /** @type {?} */
        var shiftHeight = {
            top: hostElPosition.top,
            center: hostElPosition.top +
                hostElPosition.height / 2 -
                targetElement.offsetHeight / 2,
            bottom: hostElPosition.top + hostElPosition.height
        };
        /** @type {?} */
        var targetElBCR = targetElement.getBoundingClientRect();
        /** @type {?} */
        var placementPrimary = placement.split(' ')[0] || 'top';
        /** @type {?} */
        var placementSecondary = placement.split(' ')[1] || 'center';
        /** @type {?} */
        var targetElPosition = {
            height: targetElBCR.height || targetElement.offsetHeight,
            width: targetElBCR.width || targetElement.offsetWidth,
            top: 0,
            bottom: targetElBCR.height || targetElement.offsetHeight,
            left: 0,
            right: targetElBCR.width || targetElement.offsetWidth
        };
        if (placementPrimary === 'auto') {
            /** @type {?} */
            var newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement, placementSecondary);
            if (!newPlacementPrimary)
                newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement);
            if (newPlacementPrimary)
                placementPrimary = newPlacementPrimary;
            targetElement.classList.add(placementPrimary);
        }
        switch (placementPrimary) {
            case 'top':
                targetElPosition.top =
                    hostElPosition.top -
                        (targetElement.offsetHeight +
                            parseFloat(targetElStyles.marginBottom));
                targetElPosition.bottom +=
                    hostElPosition.top - targetElement.offsetHeight;
                targetElPosition.left = shiftWidth[placementSecondary];
                targetElPosition.right += shiftWidth[placementSecondary];
                break;
            case 'bottom':
                targetElPosition.top = shiftHeight[placementPrimary];
                targetElPosition.bottom += shiftHeight[placementPrimary];
                targetElPosition.left = shiftWidth[placementSecondary];
                targetElPosition.right += shiftWidth[placementSecondary];
                break;
            case 'left':
                targetElPosition.top = shiftHeight[placementSecondary];
                targetElPosition.bottom += shiftHeight[placementSecondary];
                targetElPosition.left =
                    hostElPosition.left -
                        (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));
                targetElPosition.right +=
                    hostElPosition.left - targetElement.offsetWidth;
                break;
            case 'right':
                targetElPosition.top = shiftHeight[placementSecondary];
                targetElPosition.bottom += shiftHeight[placementSecondary];
                targetElPosition.left = shiftWidth[placementPrimary];
                targetElPosition.right += shiftWidth[placementPrimary];
                break;
        }
        targetElPosition.top = Math.round(targetElPosition.top);
        targetElPosition.bottom = Math.round(targetElPosition.bottom);
        targetElPosition.left = Math.round(targetElPosition.left);
        targetElPosition.right = Math.round(targetElPosition.right);
        return targetElPosition;
    };
    /**
     * @private
     * @param {?} targetElPosition
     * @param {?} hostElPosition
     * @param {?} targetElement
     * @param {?=} preferredPosition
     * @return {?}
     */
    Positioning.prototype.autoPosition = /**
     * @private
     * @param {?} targetElPosition
     * @param {?} hostElPosition
     * @param {?} targetElement
     * @param {?=} preferredPosition
     * @return {?}
     */
    function (targetElPosition, hostElPosition, targetElement, preferredPosition) {
        if ((!preferredPosition || preferredPosition === 'right') &&
            targetElPosition.left + hostElPosition.left - targetElement.offsetWidth <
                0) {
            return 'right';
        }
        else if ((!preferredPosition || preferredPosition === 'top') &&
            targetElPosition.bottom +
                hostElPosition.bottom +
                targetElement.offsetHeight >
                window.innerHeight) {
            return 'top';
        }
        else if ((!preferredPosition || preferredPosition === 'bottom') &&
            targetElPosition.top + hostElPosition.top - targetElement.offsetHeight < 0) {
            return 'bottom';
        }
        else if ((!preferredPosition || preferredPosition === 'left') &&
            targetElPosition.right +
                hostElPosition.right +
                targetElement.offsetWidth >
                window.innerWidth) {
            return 'left';
        }
        return null;
    };
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    Positioning.prototype.getAllStyles = /**
     * @private
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return window.getComputedStyle(element);
    };
    /**
     * @private
     * @param {?} element
     * @param {?} prop
     * @return {?}
     */
    Positioning.prototype.getStyle = /**
     * @private
     * @param {?} element
     * @param {?} prop
     * @return {?}
     */
    function (element, prop) {
        return ((/** @type {?} */ (this.getAllStyles(element))))[prop];
    };
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    Positioning.prototype.isStaticPositioned = /**
     * @private
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return (this.getStyle(element, 'position') || 'static') === 'static';
    };
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    Positioning.prototype.offsetParent = /**
     * @private
     * @param {?} element
     * @return {?}
     */
    function (element) {
        /** @type {?} */
        var offsetParentEl = (/** @type {?} */ (element.offsetParent)) || document.documentElement;
        while (offsetParentEl &&
            offsetParentEl !== document.documentElement &&
            this.isStaticPositioned(offsetParentEl)) {
            offsetParentEl = (/** @type {?} */ (offsetParentEl.offsetParent));
        }
        return offsetParentEl || document.documentElement;
    };
    return Positioning;
}());
/** @type {?} */
var positionService = new Positioning();
/**
 * @param {?} hostElement
 * @param {?} targetElement
 * @param {?} placement
 * @param {?=} appendToBody
 * @return {?}
 */
function positionElements(hostElement, targetElement, placement, appendToBody) {
    /** @type {?} */
    var pos = positionService.positionElements(hostElement, targetElement, placement, appendToBody);
    targetElement.style.top = pos.top + "px";
    targetElement.style.left = pos.left + "px";
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PositioningService = /** @class */ (function () {
    function PositioningService() {
    }
    /**
     * @param {?} options
     * @return {?}
     */
    PositioningService.prototype.position = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var element = options.element, target = options.target, attachment = options.attachment, appendToBody = options.appendToBody;
        positionElements(_getHtmlElement(target), _getHtmlElement(element), attachment, appendToBody);
    };
    PositioningService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ PositioningService.ngInjectableDef = defineInjectable({ factory: function PositioningService_Factory() { return new PositioningService(); }, token: PositioningService, providedIn: "root" });
    return PositioningService;
}());
/**
 * @param {?} element
 * @return {?}
 */
function _getHtmlElement(element) {
    // it means that we got a selector
    if (typeof element === 'string') {
        return (/** @type {?} */ (document.querySelector(element)));
    }
    if (element instanceof ElementRef) {
        return element.nativeElement;
    }
    return (/** @type {?} */ (element));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ComponentLoaderFactory = /** @class */ (function () {
    function ComponentLoaderFactory(_componentFactoryResolver, _ngZone, _injector, _posService, _applicationRef) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._ngZone = _ngZone;
        this._injector = _injector;
        this._posService = _posService;
        this._applicationRef = _applicationRef;
    }
    /**
     *
     * @param _elementRef
     * @param _viewContainerRef
     * @param _renderer
     * @returns ComponentLoader
     */
    /**
     *
     * @template T
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @return {?} ComponentLoader
     */
    ComponentLoaderFactory.prototype.createLoader = /**
     *
     * @template T
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @return {?} ComponentLoader
     */
    function (_elementRef, _viewContainerRef, _renderer) {
        return new ComponentLoader(_viewContainerRef, _renderer, _elementRef, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService);
    };
    ComponentLoaderFactory.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    ComponentLoaderFactory.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: NgZone },
        { type: Injector },
        { type: PositioningService },
        { type: ApplicationRef }
    ]; };
    /** @nocollapse */ ComponentLoaderFactory.ngInjectableDef = defineInjectable({ factory: function ComponentLoaderFactory_Factory() { return new ComponentLoaderFactory(inject(ComponentFactoryResolver), inject(NgZone), inject(INJECTOR), inject(PositioningService), inject(ApplicationRef)); }, token: ComponentLoaderFactory, providedIn: "root" });
    return ComponentLoaderFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var _messagesHash = {};
/** @type {?} */
var _hideMsg = typeof console === 'undefined' || !('warn' in console);
/**
 * @param {?} msg
 * @return {?}
 */
function warnOnce(msg) {
    if (!isDevMode() || _hideMsg || msg in _messagesHash) {
        return;
    }
    _messagesHash[msg] = true;
    /*tslint:disable-next-line*/
    console.warn(msg);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TooltipDirective = /** @class */ (function () {
    function TooltipDirective(_viewContainerRef, _renderer, _elementRef, cis, config) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        /**
         * Fired when tooltip content changes
         */
        this.tooltipChange = new EventEmitter();
        /**
         * Css class for tooltip container
         */
        this.containerClass = '';
        /**
         * @deprecated - removed, will be added to configuration
         */
        this._animation = true;
        /**
         * @deprecated
         */
        this._fadeDuration = 150;
        /**
         * @deprecated
         */
        this.tooltipStateChanged = new EventEmitter();
        this._tooltip = cis
            .createLoader(this._elementRef, _viewContainerRef, this._renderer)
            .provide({ provide: TooltipConfig, useValue: config });
        Object.assign(this, config);
        this.onShown = this._tooltip.onShown;
        this.onHidden = this._tooltip.onHidden;
    }
    Object.defineProperty(TooltipDirective.prototype, "isOpen", {
        /**
         * Returns whether or not the tooltip is currently being shown
         */
        get: /**
         * Returns whether or not the tooltip is currently being shown
         * @return {?}
         */
        function () {
            return this._tooltip.isShown;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.show();
            }
            else {
                this.hide();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "htmlContent", {
        /** @deprecated - please use `tooltip` instead */
        set: /**
         * @deprecated - please use `tooltip` instead
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipHtml was deprecated, please use `tooltip` instead');
            this.tooltip = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_placement", {
        /** @deprecated - please use `placement` instead */
        set: /**
         * @deprecated - please use `placement` instead
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipPlacement was deprecated, please use `placement` instead');
            this.placement = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_isOpen", {
        get: /**
         * @return {?}
         */
        function () {
            warnOnce('tooltipIsOpen was deprecated, please use `isOpen` instead');
            return this.isOpen;
        },
        /** @deprecated - please use `isOpen` instead*/
        set: /**
         * @deprecated - please use `isOpen` instead
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipIsOpen was deprecated, please use `isOpen` instead');
            this.isOpen = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_enable", {
        get: /**
         * @return {?}
         */
        function () {
            warnOnce('tooltipEnable was deprecated, please use `isDisabled` instead');
            return this.isDisabled;
        },
        /** @deprecated - please use `isDisabled` instead */
        set: /**
         * @deprecated - please use `isDisabled` instead
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipEnable was deprecated, please use `isDisabled` instead');
            this.isDisabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_appendToBody", {
        get: /**
         * @return {?}
         */
        function () {
            warnOnce('tooltipAppendToBody was deprecated, please use `container="body"` instead');
            return this.container === 'body';
        },
        /** @deprecated - please use `container="body"` instead */
        set: /**
         * @deprecated - please use `container="body"` instead
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipAppendToBody was deprecated, please use `container="body"` instead');
            this.container = value ? 'body' : this.container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_popupClass", {
        /** @deprecated - will replaced with customClass */
        set: /**
         * @deprecated - will replaced with customClass
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipClass deprecated');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_tooltipContext", {
        /** @deprecated - removed */
        set: /**
         * @deprecated - removed
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipContext deprecated');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_tooltipPopupDelay", {
        /** @deprecated */
        set: /**
         * @deprecated
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipPopupDelay is deprecated, use `delay` instead');
            this.delay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "_tooltipTrigger", {
        /** @deprecated -  please use `triggers` instead */
        get: /**
         * @deprecated -  please use `triggers` instead
         * @return {?}
         */
        function () {
            warnOnce('tooltipTrigger was deprecated, please use `triggers` instead');
            return this.triggers;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            warnOnce('tooltipTrigger was deprecated, please use `triggers` instead');
            this.triggers = (value || '').toString();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TooltipDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._tooltip.listen({
            triggers: this.triggers,
            show: function () { return _this.show(); }
        });
        this.tooltipChange.subscribe(function (value) {
            if (!value) {
                _this._tooltip.hide();
            }
        });
    };
    /**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     */
    /**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    TooltipDirective.prototype.toggle = /**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            return this.hide();
        }
        this.show();
    };
    /**
     * Opens an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     */
    /**
     * Opens an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    TooltipDirective.prototype.show = /**
     * Opens an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isOpen ||
            this.isDisabled ||
            this._delayTimeoutId ||
            !this.tooltip) {
            return;
        }
        /** @type {?} */
        var showTooltip = function () {
            if (_this._delayTimeoutId) {
                _this._delayTimeoutId = undefined;
            }
            _this._tooltip
                .attach(TooltipContainerComponent)
                .to(_this.container)
                .position({ attachment: _this.placement })
                .show({
                content: _this.tooltip,
                placement: _this.placement,
                containerClass: _this.containerClass
            });
        };
        /** @type {?} */
        var cancelDelayedTooltipShowing = function () {
            if (_this._tooltipCancelShowFn) {
                _this._tooltipCancelShowFn();
            }
        };
        if (this.delay) {
            /** @type {?} */
            var tipTimer_1 = timer(this.delay).subscribe(function () {
                showTooltip();
                cancelDelayedTooltipShowing();
            });
            if (this.triggers) {
                /** @type {?} */
                var triggers = parseTriggers(this.triggers);
                this._tooltipCancelShowFn = this._renderer.listen(this._elementRef.nativeElement, triggers[0].close, function () {
                    tipTimer_1.unsubscribe();
                    cancelDelayedTooltipShowing();
                });
            }
        }
        else {
            showTooltip();
        }
    };
    /**
     * Closes an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     */
    /**
     * Closes an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    TooltipDirective.prototype.hide = /**
     * Closes an element’s tooltip. This is considered a “manual” triggering of
     * the tooltip.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._delayTimeoutId) {
            clearTimeout(this._delayTimeoutId);
            this._delayTimeoutId = undefined;
        }
        if (!this._tooltip.isShown) {
            return;
        }
        this._tooltip.instance.classMap.in = false;
        setTimeout(function () {
            _this._tooltip.hide();
        }, this._fadeDuration);
    };
    /**
     * @return {?}
     */
    TooltipDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._tooltip.dispose();
    };
    TooltipDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[tooltip], [tooltipHtml]',
                    exportAs: 'bs-tooltip'
                },] }
    ];
    /** @nocollapse */
    TooltipDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Renderer2 },
        { type: ElementRef },
        { type: ComponentLoaderFactory },
        { type: TooltipConfig }
    ]; };
    TooltipDirective.propDecorators = {
        tooltip: [{ type: Input }],
        tooltipChange: [{ type: Output }],
        placement: [{ type: Input }],
        triggers: [{ type: Input }],
        container: [{ type: Input }],
        isOpen: [{ type: Input }],
        isDisabled: [{ type: Input }],
        containerClass: [{ type: Input }],
        delay: [{ type: Input }],
        onShown: [{ type: Output }],
        onHidden: [{ type: Output }],
        htmlContent: [{ type: Input, args: ['tooltipHtml',] }],
        _placement: [{ type: Input, args: ['tooltipPlacement',] }],
        _isOpen: [{ type: Input, args: ['tooltipIsOpen',] }],
        _enable: [{ type: Input, args: ['tooltipEnable',] }],
        _appendToBody: [{ type: Input, args: ['tooltipAppendToBody',] }],
        _animation: [{ type: Input, args: ['tooltipAnimation',] }],
        _popupClass: [{ type: Input, args: ['tooltipClass',] }],
        _tooltipContext: [{ type: Input, args: ['tooltipContext',] }],
        _tooltipPopupDelay: [{ type: Input, args: ['tooltipPopupDelay',] }],
        _fadeDuration: [{ type: Input, args: ['tooltipFadeDuration',] }],
        _tooltipTrigger: [{ type: Input, args: ['tooltipTrigger',] }],
        tooltipStateChanged: [{ type: Output }]
    };
    __decorate([
        OnChange(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "tooltip", void 0);
    return TooltipDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TooltipModule = /** @class */ (function () {
    function TooltipModule() {
    }
    /**
     * @return {?}
     */
    TooltipModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: TooltipModule,
            providers: [TooltipConfig, ComponentLoaderFactory, PositioningService]
        };
    };
    TooltipModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [TooltipDirective, TooltipContainerComponent],
                    exports: [TooltipDirective],
                    entryComponents: [TooltipContainerComponent]
                },] }
    ];
    return TooltipModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsModalRef = /** @class */ (function () {
    function BsModalRef() {
        /**
         * Hides the modal
         */
        this.hide = Function;
    }
    BsModalRef.decorators = [
        { type: Injectable }
    ];
    return BsModalRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalBackdropOptions = /** @class */ (function () {
    function ModalBackdropOptions(options) {
        this.animate = true;
        Object.assign(this, options);
    }
    return ModalBackdropOptions;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalOptions = /** @class */ (function () {
    function ModalOptions() {
    }
    ModalOptions.decorators = [
        { type: Injectable }
    ];
    return ModalOptions;
}());
/** @type {?} */
var modalConfigDefaults = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: false,
    ignoreBackdropClick: false,
    class: '',
    animated: true,
    initialState: {}
};
/** @type {?} */
var CLASS_NAME = {
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    IN: 'in',
    // bs3
    SHOW: 'show' // bs4
};
/** @type {?} */
var TRANSITION_DURATIONS = {
    MODAL: 300,
    BACKDROP: 150
};
/** @type {?} */
var DISMISS_REASONS = {
    BACKRDOP: 'backdrop-click',
    ESC: 'esc'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalContainerComponent = /** @class */ (function () {
    function ModalContainerComponent(options, _element, _renderer) {
        this._element = _element;
        this._renderer = _renderer;
        this.isShown = false;
        this.isModalHiding = false;
        this.config = Object.assign({}, options);
    }
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isAnimated) {
            this._renderer.addClass(this._element.nativeElement, CLASS_NAME.FADE);
        }
        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');
        setTimeout(function () {
            _this.isShown = true;
            _this._renderer.addClass(_this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
        }, this.isAnimated ? TRANSITION_DURATIONS.BACKDROP : 0);
        if (document && document.body) {
            if (this.bsModalService.getModalsCount() === 1) {
                this.bsModalService.checkScrollbar();
                this.bsModalService.setScrollbar();
            }
            this._renderer.addClass(document.body, CLASS_NAME.OPEN);
        }
        if (this._element.nativeElement) {
            this._element.nativeElement.focus();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ModalContainerComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.config.ignoreBackdropClick ||
            this.config.backdrop === 'static' ||
            event.target !== this._element.nativeElement) {
            return;
        }
        this.bsModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);
        this.hide();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ModalContainerComponent.prototype.onEsc = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        if (this.config.keyboard &&
            this.level === this.bsModalService.getModalsCount()) {
            this.bsModalService.setDismissReason(DISMISS_REASONS.ESC);
            this.hide();
        }
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.isShown) {
            this.hide();
        }
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.hide = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isModalHiding || !this.isShown) {
            return;
        }
        this.isModalHiding = true;
        this._renderer.removeClass(this._element.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
        setTimeout(function () {
            _this.isShown = false;
            if (document &&
                document.body &&
                _this.bsModalService.getModalsCount() === 1) {
                _this._renderer.removeClass(document.body, CLASS_NAME.OPEN);
            }
            _this.bsModalService.hide(_this.level);
            _this.isModalHiding = false;
        }, this.isAnimated ? TRANSITION_DURATIONS.MODAL : 0);
    };
    ModalContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'modal-container',
                    template: "\n    <div [class]=\"'modal-dialog' + (config.class ? ' ' + config.class : '')\" role=\"document\">\n      <div class=\"modal-content\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  ",
                    host: {
                        class: 'modal',
                        role: 'dialog',
                        tabindex: '-1',
                        '[attr.aria-modal]': 'true'
                    }
                }] }
    ];
    /** @nocollapse */
    ModalContainerComponent.ctorParameters = function () { return [
        { type: ModalOptions },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    ModalContainerComponent.propDecorators = {
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onEsc: [{ type: HostListener, args: ['window:keydown.esc', ['$event'],] }]
    };
    return ModalContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * @param {?} element
     * @return {?}
     */
    Utils.reflow = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        (function (bs) { return bs; })(element.offsetHeight);
    };
    // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js
    // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js
    /**
     * @param {?} elem
     * @return {?}
     */
    Utils.getStyles = 
    // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js
    /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        /** @type {?} */
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = win;
        }
        return view.getComputedStyle(elem);
    };
    return Utils;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component will be added as background layout for modals if enabled
 */
var ModalBackdropComponent = /** @class */ (function () {
    function ModalBackdropComponent(element, renderer) {
        this._isShown = false;
        this.element = element;
        this.renderer = renderer;
    }
    Object.defineProperty(ModalBackdropComponent.prototype, "isAnimated", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isAnimated;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isAnimated = value;
            // this.renderer.setElementClass(this.element.nativeElement, `${ClassName.FADE}`, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalBackdropComponent.prototype, "isShown", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isShown;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isShown = value;
            if (value) {
                this.renderer.addClass(this.element.nativeElement, "" + CLASS_NAME.IN);
            }
            else {
                this.renderer.removeClass(this.element.nativeElement, "" + CLASS_NAME.IN);
            }
            if (!isBs3()) {
                if (value) {
                    this.renderer.addClass(this.element.nativeElement, "" + CLASS_NAME.SHOW);
                }
                else {
                    this.renderer.removeClass(this.element.nativeElement, "" + CLASS_NAME.SHOW);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ModalBackdropComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.isAnimated) {
            this.renderer.addClass(this.element.nativeElement, "" + CLASS_NAME.FADE);
            Utils.reflow(this.element.nativeElement);
        }
        this.isShown = true;
    };
    ModalBackdropComponent.decorators = [
        { type: Component, args: [{
                    selector: 'bs-modal-backdrop',
                    template: ' ',
                    host: { class: CLASS_NAME.BACKDROP }
                }] }
    ];
    /** @nocollapse */
    ModalBackdropComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    return ModalBackdropComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var TRANSITION_DURATION = 300;
/** @type {?} */
var BACKDROP_TRANSITION_DURATION = 150;
/**
 * Mark any code with directive to show it's content in modal
 */
var ModalDirective = /** @class */ (function () {
    function ModalDirective(_element, _viewContainerRef, _renderer, clf) {
        this._element = _element;
        this._renderer = _renderer;
        /**
         * This event fires immediately when the `show` instance method is called.
         */
        this.onShow = new EventEmitter();
        /**
         * This event is fired when the modal has been made visible to the user
         * (will wait for CSS transitions to complete)
         */
        this.onShown = new EventEmitter();
        /**
         * This event is fired immediately when
         * the hide instance method has been called.
         */
        this.onHide = new EventEmitter();
        /**
         * This event is fired when the modal has finished being
         * hidden from the user (will wait for CSS transitions to complete).
         */
        this.onHidden = new EventEmitter();
        this._isShown = false;
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        this.timerHideModal = 0;
        this.timerRmBackDrop = 0;
        this.isNested = false;
        this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);
    }
    Object.defineProperty(ModalDirective.prototype, "config", {
        get: /**
         * @return {?}
         */
        function () {
            return this._config;
        },
        /** allows to set modal configuration via element property */
        set: /**
         * allows to set modal configuration via element property
         * @param {?} conf
         * @return {?}
         */
        function (conf) {
            this._config = this.getConfig(conf);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalDirective.prototype, "isShown", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isShown;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    ModalDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.config.ignoreBackdropClick ||
            this.config.backdrop === 'static' ||
            event.target !== this._element.nativeElement) {
            return;
        }
        this.dismissReason = DISMISS_REASONS.BACKRDOP;
        this.hide(event);
    };
    // todo: consider preventing default and stopping propagation
    // todo: consider preventing default and stopping propagation
    /**
     * @param {?} event
     * @return {?}
     */
    ModalDirective.prototype.onEsc = 
    // todo: consider preventing default and stopping propagation
    /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this._isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        if (this.config.keyboard) {
            this.dismissReason = DISMISS_REASONS.ESC;
            this.hide();
        }
    };
    /**
     * @return {?}
     */
    ModalDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.config = void 0;
        if (this._isShown) {
            this._isShown = false;
            this.hideModal();
            this._backdrop.dispose();
        }
    };
    /**
     * @return {?}
     */
    ModalDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._config = this._config || this.getConfig();
        setTimeout(function () {
            if (_this._config.show) {
                _this.show();
            }
        }, 0);
    };
    /* Public methods */
    /** Allows to manually toggle modal visibility */
    /* Public methods */
    /**
     * Allows to manually toggle modal visibility
     * @return {?}
     */
    ModalDirective.prototype.toggle = /* Public methods */
    /**
     * Allows to manually toggle modal visibility
     * @return {?}
     */
    function () {
        return this._isShown ? this.hide() : this.show();
    };
    /** Allows to manually open modal */
    /**
     * Allows to manually open modal
     * @return {?}
     */
    ModalDirective.prototype.show = /**
     * Allows to manually open modal
     * @return {?}
     */
    function () {
        var _this = this;
        this.dismissReason = null;
        this.onShow.emit(this);
        if (this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        this._isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        if (document$1 && document$1.body) {
            if (document$1.body.classList.contains(CLASS_NAME.OPEN)) {
                this.isNested = true;
            }
            else {
                this._renderer.addClass(document$1.body, CLASS_NAME.OPEN);
            }
        }
        this.showBackdrop(function () {
            _this.showElement();
        });
    };
    /** Allows to manually close modal */
    /**
     * Allows to manually close modal
     * @param {?=} event
     * @return {?}
     */
    ModalDirective.prototype.hide = /**
     * Allows to manually close modal
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (event) {
            event.preventDefault();
        }
        this.onHide.emit(this);
        // todo: add an option to prevent hiding
        if (!this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        this._isShown = false;
        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);
        if (!isBs3()) {
            this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);
        }
        // this._addClassIn = false;
        if (this._config.animated) {
            this.timerHideModal = setTimeout(function () { return _this.hideModal(); }, TRANSITION_DURATION);
        }
        else {
            this.hideModal();
        }
    };
    /** Private methods @internal */
    /**
     * Private methods \@internal
     * @protected
     * @param {?=} config
     * @return {?}
     */
    ModalDirective.prototype.getConfig = /**
     * Private methods \@internal
     * @protected
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return Object.assign({}, modalConfigDefaults, config);
    };
    /**
     *  Show dialog
     *  @internal
     */
    /**
     *  Show dialog
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.showElement = /**
     *  Show dialog
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        // todo: replace this with component loader usage
        if (!this._element.nativeElement.parentNode ||
            this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {
            // don't move modals dom position
            if (document$1 && document$1.body) {
                document$1.body.appendChild(this._element.nativeElement);
            }
        }
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');
        this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');
        this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);
        if (this._config.animated) {
            Utils.reflow(this._element.nativeElement);
        }
        // this._addClassIn = true;
        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);
        if (!isBs3()) {
            this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);
        }
        /** @type {?} */
        var transitionComplete = function () {
            if (_this._config.focus) {
                _this._element.nativeElement.focus();
            }
            _this.onShown.emit(_this);
        };
        if (this._config.animated) {
            setTimeout(transitionComplete, TRANSITION_DURATION);
        }
        else {
            transitionComplete();
        }
    };
    /** @internal */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.hideModal = /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'none');
        this.showBackdrop(function () {
            if (!_this.isNested) {
                if (document$1 && document$1.body) {
                    _this._renderer.removeClass(document$1.body, CLASS_NAME.OPEN);
                }
                _this.resetScrollbar();
            }
            _this.resetAdjustments();
            _this.focusOtherModal();
            _this.onHidden.emit(_this);
        });
    };
    // todo: original show was calling a callback when done, but we can use
    // promise
    /** @internal */
    // todo: original show was calling a callback when done, but we can use
    // promise
    /**
     * \@internal
     * @protected
     * @param {?=} callback
     * @return {?}
     */
    ModalDirective.prototype.showBackdrop = 
    // todo: original show was calling a callback when done, but we can use
    // promise
    /**
     * \@internal
     * @protected
     * @param {?=} callback
     * @return {?}
     */
    function (callback) {
        var _this = this;
        if (this._isShown &&
            this.config.backdrop &&
            (!this.backdrop || !this.backdrop.instance.isShown)) {
            this.removeBackdrop();
            this._backdrop
                .attach(ModalBackdropComponent)
                .to('body')
                .show({ isAnimated: this._config.animated });
            this.backdrop = this._backdrop._componentRef;
            if (!callback) {
                return;
            }
            if (!this._config.animated) {
                callback();
                return;
            }
            setTimeout(callback, BACKDROP_TRANSITION_DURATION);
        }
        else if (!this._isShown && this.backdrop) {
            this.backdrop.instance.isShown = false;
            /** @type {?} */
            var callbackRemove = function () {
                _this.removeBackdrop();
                if (callback) {
                    callback();
                }
            };
            if (this.backdrop.instance.isAnimated) {
                this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);
            }
            else {
                callbackRemove();
            }
        }
        else if (callback) {
            callback();
        }
    };
    /** @internal */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.removeBackdrop = /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this._backdrop.hide();
    };
    /** Events tricks */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    /**
     * Events tricks
     * @protected
     * @return {?}
     */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    ModalDirective.prototype.focusOtherModal = /**
     * Events tricks
     * @protected
     * @return {?}
     */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    function () {
        if (this._element.nativeElement.parentElement == null)
            return;
        /** @type {?} */
        var otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');
        if (!otherOpenedModals.length) {
            return;
        }
        otherOpenedModals[otherOpenedModals.length - 1].focus();
    };
    /** @internal */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.resetAdjustments = /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');
        this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');
    };
    /** Scroll bar tricks */
    /** @internal */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.checkScrollbar = /** Scroll bar tricks */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this.isBodyOverflowing = document$1.body.clientWidth < win.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    };
    /**
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.setScrollbar = /**
     * @protected
     * @return {?}
     */
    function () {
        if (!document$1) {
            return;
        }
        this.originalBodyPadding = parseInt(win
            .getComputedStyle(document$1.body)
            .getPropertyValue('padding-right') || 0, 10);
        if (this.isBodyOverflowing) {
            document$1.body.style.paddingRight = this.originalBodyPadding +
                this.scrollbarWidth + "px";
        }
    };
    /**
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.resetScrollbar = /**
     * @protected
     * @return {?}
     */
    function () {
        document$1.body.style.paddingRight = this.originalBodyPadding + 'px';
    };
    // thx d.walsh
    // thx d.walsh
    /**
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.getScrollbarWidth = 
    // thx d.walsh
    /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document$1.body, scrollDiv);
        /** @type {?} */
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document$1.body, scrollDiv);
        return scrollbarWidth;
    };
    ModalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[bsModal]',
                    exportAs: 'bs-modal'
                },] }
    ];
    /** @nocollapse */
    ModalDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: Renderer2 },
        { type: ComponentLoaderFactory }
    ]; };
    ModalDirective.propDecorators = {
        config: [{ type: Input }],
        onShow: [{ type: Output }],
        onShown: [{ type: Output }],
        onHide: [{ type: Output }],
        onHidden: [{ type: Output }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onEsc: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }]
    };
    return ModalDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsModalService$1 = /** @class */ (function () {
    function BsModalService$$1(rendererFactory, clf) {
        this.clf = clf;
        // constructor props
        this.config = modalConfigDefaults;
        this.onShow = new EventEmitter();
        this.onShown = new EventEmitter();
        this.onHide = new EventEmitter();
        this.onHidden = new EventEmitter();
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        this.modalsCount = 0;
        this.lastDismissReason = '';
        this.loaders = [];
        this._backdropLoader = this.clf.createLoader(null, null, null);
        this._renderer = rendererFactory.createRenderer(null, null);
    }
    /** Shows a modal */
    /**
     * Shows a modal
     * @param {?} content
     * @param {?=} config
     * @return {?}
     */
    BsModalService$$1.prototype.show = /**
     * Shows a modal
     * @param {?} content
     * @param {?=} config
     * @return {?}
     */
    function (content, config) {
        this.modalsCount++;
        this._createLoaders();
        this.config = Object.assign({}, modalConfigDefaults, config);
        this._showBackdrop();
        this.lastDismissReason = null;
        return this._showModal(content);
    };
    /**
     * @param {?} level
     * @return {?}
     */
    BsModalService$$1.prototype.hide = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        var _this = this;
        if (this.modalsCount === 1) {
            this._hideBackdrop();
            this.resetScrollbar();
        }
        this.modalsCount = this.modalsCount >= 1 ? this.modalsCount - 1 : 0;
        setTimeout(function () {
            _this._hideModal(level);
            _this.removeLoaders(level);
        }, this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0);
    };
    /**
     * @return {?}
     */
    BsModalService$$1.prototype._showBackdrop = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';
        /** @type {?} */
        var isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;
        if (this.modalsCount === 1) {
            this.removeBackdrop();
            if (isBackdropEnabled && isBackdropInDOM) {
                this._backdropLoader
                    .attach(ModalBackdropComponent)
                    .to('body')
                    .show({ isAnimated: this.config.animated });
                this.backdropRef = this._backdropLoader._componentRef;
            }
        }
    };
    /**
     * @return {?}
     */
    BsModalService$$1.prototype._hideBackdrop = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.backdropRef) {
            return;
        }
        this.backdropRef.instance.isShown = false;
        /** @type {?} */
        var duration = this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0;
        setTimeout(function () { return _this.removeBackdrop(); }, duration);
    };
    /**
     * @param {?} content
     * @return {?}
     */
    BsModalService$$1.prototype._showModal = /**
     * @param {?} content
     * @return {?}
     */
    function (content) {
        /** @type {?} */
        var modalLoader = this.loaders[this.loaders.length - 1];
        /** @type {?} */
        var bsModalRef = new BsModalRef();
        /** @type {?} */
        var modalContainerRef = modalLoader
            .provide({ provide: ModalOptions, useValue: this.config })
            .provide({ provide: BsModalRef, useValue: bsModalRef })
            .attach(ModalContainerComponent)
            .to('body')
            .show({ content: content, isAnimated: this.config.animated, initialState: this.config.initialState, bsModalService: this });
        modalContainerRef.instance.level = this.getModalsCount();
        bsModalRef.hide = function () {
            modalContainerRef.instance.hide();
        };
        bsModalRef.content = modalLoader.getInnerComponent() || null;
        return bsModalRef;
    };
    /**
     * @param {?} level
     * @return {?}
     */
    BsModalService$$1.prototype._hideModal = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        /** @type {?} */
        var modalLoader = this.loaders[level - 1];
        if (modalLoader) {
            modalLoader.hide();
        }
    };
    /**
     * @return {?}
     */
    BsModalService$$1.prototype.getModalsCount = /**
     * @return {?}
     */
    function () {
        return this.modalsCount;
    };
    /**
     * @param {?} reason
     * @return {?}
     */
    BsModalService$$1.prototype.setDismissReason = /**
     * @param {?} reason
     * @return {?}
     */
    function (reason) {
        this.lastDismissReason = reason;
    };
    /**
     * @return {?}
     */
    BsModalService$$1.prototype.removeBackdrop = /**
     * @return {?}
     */
    function () {
        this._backdropLoader.hide();
        this.backdropRef = null;
    };
    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /** @internal */
    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @return {?}
     */
    BsModalService$$1.prototype.checkScrollbar = /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @return {?}
     */
    function () {
        this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    };
    /**
     * @return {?}
     */
    BsModalService$$1.prototype.setScrollbar = /**
     * @return {?}
     */
    function () {
        if (!document) {
            return;
        }
        this.originalBodyPadding = parseInt(window
            .getComputedStyle(document.body)
            .getPropertyValue('padding-right') || '0', 10);
        if (this.isBodyOverflowing) {
            document.body.style.paddingRight = this.originalBodyPadding +
                this.scrollbarWidth + "px";
        }
    };
    /**
     * @private
     * @return {?}
     */
    BsModalService$$1.prototype.resetScrollbar = /**
     * @private
     * @return {?}
     */
    function () {
        document.body.style.paddingRight = this.originalBodyPadding + "px";
    };
    // thx d.walsh
    // thx d.walsh
    /**
     * @private
     * @return {?}
     */
    BsModalService$$1.prototype.getScrollbarWidth = 
    // thx d.walsh
    /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document.body, scrollDiv);
        /** @type {?} */
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document.body, scrollDiv);
        return scrollbarWidth;
    };
    /**
     * @private
     * @return {?}
     */
    BsModalService$$1.prototype._createLoaders = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loader = this.clf.createLoader(null, null, null);
        this.copyEvent(loader.onBeforeShow, this.onShow);
        this.copyEvent(loader.onShown, this.onShown);
        this.copyEvent(loader.onBeforeHide, this.onHide);
        this.copyEvent(loader.onHidden, this.onHidden);
        this.loaders.push(loader);
    };
    /**
     * @private
     * @param {?} level
     * @return {?}
     */
    BsModalService$$1.prototype.removeLoaders = /**
     * @private
     * @param {?} level
     * @return {?}
     */
    function (level) {
        this.loaders.splice(level - 1, 1);
        this.loaders.forEach(function (loader, i) {
            loader.instance.level = i + 1;
        });
    };
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    BsModalService$$1.prototype.copyEvent = /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    function (from, to) {
        var _this = this;
        from.subscribe(function () {
            to.emit(_this.lastDismissReason);
        });
    };
    BsModalService$$1.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    BsModalService$$1.ctorParameters = function () { return [
        { type: RendererFactory2 },
        { type: ComponentLoaderFactory }
    ]; };
    return BsModalService$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalModule$1 = /** @class */ (function () {
    function ModalModule$$1() {
    }
    /**
     * @return {?}
     */
    ModalModule$$1.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: ModalModule$$1,
            providers: [BsModalService$1, ComponentLoaderFactory, PositioningService]
        };
    };
    ModalModule$$1.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ModalBackdropComponent,
                        ModalDirective,
                        ModalContainerComponent
                    ],
                    exports: [ModalBackdropComponent, ModalDirective],
                    entryComponents: [ModalBackdropComponent, ModalContainerComponent]
                },] }
    ];
    return ModalModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavbarState = /** @class */ (function () {
    function NavbarState() {
        this.dropdownInstances = [];
        this.menuItems = [];
        this.subscriptions = [];
        // 当前下拉菜单的子菜单
        this.onItemClick = new EventEmitter();
    }
    /**
     * @param {?} dropdown
     * @return {?}
     */
    NavbarState.prototype.addDropdown = /**
     * @param {?} dropdown
     * @return {?}
     */
    function (dropdown) {
        var _this = this;
        if (!this.dropdownInstances.find(function (item) { return item === dropdown; })) {
            this.dropdownInstances.push(dropdown);
            this.subscribeDropdown(dropdown);
            dropdown.onShown.subscribe(function () { return setTimeout(function () {
                dropdown.childDropdowns.forEach(function (item) { return _this.addDropdown(item); });
            }); });
        }
    };
    /**
     * @param {?} menuItem
     * @return {?}
     */
    NavbarState.prototype.addMenuItem = /**
     * @param {?} menuItem
     * @return {?}
     */
    function (menuItem) {
        if (!this.menuItems.find(function (item) { return item === menuItem; })) {
            this.menuItems.push(menuItem);
            this.subscribeMenuItem(menuItem);
        }
    };
    /**
     * @private
     * @param {?} dropdown
     * @return {?}
     */
    NavbarState.prototype.subscribeDropdown = /**
     * @private
     * @param {?} dropdown
     * @return {?}
     */
    function (dropdown) {
        // 在下拉菜单显示、隐藏时，记录下显示状态。
        // this.subscriptions.push(
        //   dropdown.onShown.subscribe((value) => {
        //     debugger;
        //     if(dropdown.isSubMenu) {
        //
        //     }
        //   })
        // );
        //
        // this.subscriptions.push(
        //   dropdown.onHidden.subscribe((value) => {
        //
        //   })
        // );
        var _this = this;
        this.subscriptions.push(dropdown.state.onClick.subscribe(function (event) {
            if (dropdown.level === 1) {
                if (dropdown.isOpen && _this.level1Dropdown === dropdown) {
                    _this.innerHideL1Dropdown();
                }
                else {
                    _this.innerShowL1Dropdown(dropdown);
                }
            }
            else if (dropdown.level === 2) {
                if (!dropdown.isOpen || _this.level2Dropdown !== dropdown) {
                    _this.innerShowL2Dropdown(dropdown);
                }
            }
            event.stopPropagation();
        }));
        this.subscriptions.push(dropdown.state.onHover.subscribe(function () {
            if (!_this.level1Dropdown) {
                // 菜单没展开，鼠标悬停没有效果
                return;
            }
            _this.show(dropdown);
        }));
    };
    /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    NavbarState.prototype.subscribeMenuItem = /**
     * @private
     * @param {?} menuItem
     * @return {?}
     */
    function (menuItem) {
        var _this = this;
        this.subscriptions.push(menuItem.onHover.subscribe(function () {
            if (!_this.level1Dropdown) {
                return;
            }
            if (_this.level1Dropdown.containsItem(menuItem)) {
                _this.innerHideL2Dropdown();
            }
        }));
        this.subscriptions.push(menuItem.onClick.subscribe(function (command) {
            _this.onItemClick.emit(command);
        }));
    };
    /**
     * @return {?}
     */
    NavbarState.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) {
            sub.unsubscribe();
        });
    };
    /**
     * @return {?}
     */
    NavbarState.prototype.hideCurrentDropdown = /**
     * @return {?}
     */
    function () {
        if (this.level2Dropdown) {
            this.innerHideL2Dropdown();
        }
        else {
            this.innerHideL1Dropdown();
        }
    };
    /**
     * @return {?}
     */
    NavbarState.prototype.hideAllDropdown = /**
     * @return {?}
     */
    function () {
        this.innerHideL2Dropdown();
        this.innerHideL1Dropdown();
    };
    /**
     * @param {?} dropdown
     * @return {?}
     */
    NavbarState.prototype.show = /**
     * @param {?} dropdown
     * @return {?}
     */
    function (dropdown) {
        if (dropdown.level === 1) {
            if (dropdown !== this.level1Dropdown) {
                this.innerShowL1Dropdown(dropdown);
            }
            this.innerHideL2Dropdown();
        }
        else if (dropdown.level === 2) {
            if (dropdown !== this.level2Dropdown) {
                this.innerShowL2Dropdown(dropdown);
            }
        }
        ///////////////////////////////
        /*if (this.isMenuShown && this.isSubMenuShown && this.parentDropdown && this.parentDropdown.containsItem(dropdown)) {
          // 要显示的是子菜单，不是当前子菜单
          if (this.currentDropdown && this.currentDropdown !== dropdown) {
            this.currentDropdown.hide();
          }
          dropdown.show();
          this.currentDropdown = dropdown;
          this.isSubMenuShown = true;
        } else if (this.isMenuShown && !this.isSubMenuShown && this.currentDropdown && this.currentDropdown.containsItem(dropdown)) {
    
        } else {
          // 主菜单
          if (this.isSubMenuShown && this.currentDropdown && this.parentDropdown) {
            this.currentDropdown.hide();
            this.currentDropdown = null;
            this.isSubMenuShown = false;
          }
          if (this.isMenuShown && this.currentDropdown && this.currentDropdown !== dropdown) {
            this.currentDropdown.hide();
          }
          dropdown.show();
          this.currentDropdown = dropdown;
          this.isMenuShown = true;
        }*/
    };
    /**
     * @param {?} dropdown
     * @return {?}
     */
    NavbarState.prototype.hide = /**
     * @param {?} dropdown
     * @return {?}
     */
    function (dropdown) {
        // if
    };
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    NavbarState.prototype.innerShowL1Dropdown = /**
     * @private
     * @param {?} target
     * @return {?}
     */
    function (target) {
        if (this.level1Dropdown) {
            this.level1Dropdown.hide();
        }
        target.show();
        this.level1Dropdown = target;
    };
    /**
     * @private
     * @return {?}
     */
    NavbarState.prototype.innerHideL1Dropdown = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.level1Dropdown) {
            this.level1Dropdown.hide();
            this.level1Dropdown = null;
        }
    };
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    NavbarState.prototype.innerShowL2Dropdown = /**
     * @private
     * @param {?} target
     * @return {?}
     */
    function (target) {
        if (this.level2Dropdown) {
            this.level2Dropdown.hide();
        }
        target.show();
        this.level2Dropdown = target;
    };
    /**
     * @private
     * @return {?}
     */
    NavbarState.prototype.innerHideL2Dropdown = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.level2Dropdown) {
            this.level2Dropdown.hide();
            this.level2Dropdown = null;
        }
    };
    NavbarState.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NavbarState.ctorParameters = function () { return []; };
    return NavbarState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Default dropdown configuration
 */
var BsDropdownConfig = /** @class */ (function () {
    function BsDropdownConfig() {
        /**
         * default dropdown auto closing behavior
         */
        this.autoClose = true;
    }
    BsDropdownConfig.decorators = [
        { type: Injectable }
    ];
    return BsDropdownConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsDropdownState = /** @class */ (function () {
    function BsDropdownState() {
        var _this = this;
        this.direction = 'down';
        this.isOpenChange = new EventEmitter();
        this.isDisabledChange = new EventEmitter();
        this.toggleClick = new EventEmitter();
        this.onHover = new EventEmitter();
        this.onClick = new EventEmitter();
        this.dropdownMenu = new Promise(function (resolve) {
            _this.resolveDropdownMenu = resolve;
        });
    }
    BsDropdownState.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    BsDropdownState.ctorParameters = function () { return []; };
    return BsDropdownState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function isBs3$1() {
    return win.__theme === 'bs4';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsDropdownContainerComponent = /** @class */ (function () {
    function BsDropdownContainerComponent(_state, cd, _renderer, _element) {
        var _this = this;
        this._state = _state;
        this.cd = cd;
        this._renderer = _renderer;
        this.isOpen = false;
        this.display = 'block';
        this.position = 'absolute';
        this._subscription = _state.isOpenChange.subscribe(function (value) {
            _this.isOpen = value;
            /** @type {?} */
            var dropdown = _element.nativeElement.querySelector('.dropdown-menu');
            if (dropdown && !isBs3$1()) {
                _this._renderer.addClass(dropdown, 'show');
                if (dropdown.classList.contains('dropdown-menu-right')) {
                    _this._renderer.setStyle(dropdown, 'left', 'auto');
                    _this._renderer.setStyle(dropdown, 'right', '0');
                }
                if (_this.direction === 'up') {
                    _this._renderer.setStyle(dropdown, 'top', 'auto');
                    _this._renderer.setStyle(dropdown, 'transform', 'translateY(-101%)');
                }
            }
        });
    }
    Object.defineProperty(BsDropdownContainerComponent.prototype, "direction", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state.direction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BsDropdownContainerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    BsDropdownContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'mdb-dropdown-container',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: "\n  <div [class.dropup]=\"direction === 'up'\"\n  [class.dropdown]=\"direction === 'down'\"\n  [class.show]=\"isOpen\"\n  [class.open]=\"isOpen\">\n    <ng-content></ng-content>\n  </div>\n  "
                }] }
    ];
    /** @nocollapse */
    BsDropdownContainerComponent.ctorParameters = function () { return [
        { type: BsDropdownState },
        { type: ChangeDetectorRef },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    BsDropdownContainerComponent.propDecorators = {
        display: [{ type: HostBinding, args: ['style.display',] }],
        position: [{ type: HostBinding, args: ['style.position',] }]
    };
    return BsDropdownContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsDropdownDirective = /** @class */ (function () {
    function BsDropdownDirective(_elementRef, _renderer, _viewContainerRef, _cis, _config, _state) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._viewContainerRef = _viewContainerRef;
        this._cis = _cis;
        this._config = _config;
        this._state = _state;
        // todo: move to component loader
        this._isInlineOpen = false;
        this._subscriptions = [];
        this._isInited = false;
        // set initial dropdown state from config
        this._state.autoClose = this._config.autoClose;
        // create dropdown component loader
        this._dropdown = this._cis
            .createLoader(this._elementRef, this._viewContainerRef, this._renderer)
            .provide({ provide: BsDropdownState, useValue: this._state });
        this.onShown = this._dropdown.onShown;
        this.onHidden = this._dropdown.onHidden;
        this.isOpenChange = this._state.isOpenChange;
        // this.onToggleHover = this._state.onHover;
        // barState.addDropdown(this);
    }
    Object.defineProperty(BsDropdownDirective.prototype, "autoClose", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state.autoClose;
        },
        /**
         * Indicates that dropdown will be closed on item or document click,
         * and after pressing ESC
         */
        set: /**
         * Indicates that dropdown will be closed on item or document click,
         * and after pressing ESC
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._state.autoClose = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BsDropdownDirective.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isDisabled;
        },
        /**
         * Disables dropdown toggle and hides dropdown menu if opened
         */
        set: /**
         * Disables dropdown toggle and hides dropdown menu if opened
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isDisabled = value;
            this._state.isDisabledChange.emit(value);
            if (value) {
                this.hide();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BsDropdownDirective.prototype, "isOpen", {
        /**
         * Returns whether or not the popover is currently being shown
         */
        get: /**
         * Returns whether or not the popover is currently being shown
         * @return {?}
         */
        function () {
            if (this._showInline) {
                return this._isInlineOpen;
            }
            return this._dropdown.isShown;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.show();
            }
            else {
                this.hide();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BsDropdownDirective.prototype, "state", {
        get: /**
         * @return {?}
         */
        function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BsDropdownDirective.prototype, "level", {
        get: /**
         * @return {?}
         */
        function () {
            return this._level || 1;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._level = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BsDropdownDirective.prototype, "elementRef", {
        get: /**
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BsDropdownDirective.prototype, "isBs4", {
        get: /**
         * @return {?}
         */
        function () {
            return !isBs3$1();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BsDropdownDirective.prototype, "_showInline", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return !this.container;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BsDropdownDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // fix: seems there are an issue with `routerLinkActive`
        // which result in duplicated call ngOnInit without call to ngOnDestroy
        // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
        if (this._isInited) {
            return;
        }
        this._isInited = true;
        // attach DOM listeners
        this._dropdown.listen({
            // because of dropdown inline mode
            outsideClick: false,
            triggers: this.triggers,
            show: function () { return _this.show(); }, toggle: function (value) { return _this.toggle(value); }
        });
        // toggle visibility on toggle element click
        this._subscriptions.push(this._state.toggleClick.subscribe(function (value) { return _this.toggle(value); }));
        // hide dropdown if set disabled while opened
        this._subscriptions.push(this._state.isDisabledChange.pipe(filter(function (value) { return value; }))
            .subscribe(function (value) { return _this.hide(); }));
    };
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    BsDropdownDirective.prototype.show = /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isOpen || this.isDisabled) {
            return;
        }
        if (this._showInline) {
            if (!this._inlinedMenu) {
                this._state.dropdownMenu.then(function (dropdownMenu) {
                    /** @type {?} */
                    var _placement = _this.placement || 'bottom left';
                    _this._dropdown.attachInline(dropdownMenu.viewContainer, dropdownMenu.templateRef);
                    _this._inlinedMenu = _this._dropdown._inlineViewRef;
                    _this.addBs4Polyfills();
                })
                    // swallow errors
                    .catch();
            }
            this.addBs4Polyfills();
            this._isInlineOpen = true;
            this.onShown.emit(true);
            this._state.isOpenChange.emit(true);
            return;
        }
        this._state.dropdownMenu.then(function (dropdownMenu) {
            // check direction in which dropdown should be opened
            /** @type {?} */
            var _dropup = _this.dropup ||
                (typeof _this.dropup !== 'undefined' && _this.dropup);
            _this._state.direction = _dropup ? 'up' : 'down';
            /** @type {?} */
            var _placement = _this.placement || (_dropup ? 'top left' : 'bottom left');
            // show dropdown
            _this._dropdown
                .attach(BsDropdownContainerComponent)
                .to(_this.container)
                .position({ attachment: _placement })
                .show({
                content: dropdownMenu.templateRef,
                placement: _placement
            });
            _this._state.isOpenChange.emit(true);
        })
            // swallow error
            .catch();
    };
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    BsDropdownDirective.prototype.hide = /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        if (!this.isOpen) {
            return;
        }
        if (this._showInline) {
            this.removeShowClass();
            this.removeDropupStyles();
            this._isInlineOpen = false;
            this.onHidden.emit(true);
        }
        else {
            this._dropdown.hide();
        }
        this._state.isOpenChange.emit(false);
    };
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover. With parameter <code>true</code> allows toggling, with parameter <code>false</code>
     * only hides opened dropdown. Parameter usage will be removed in ngx-bootstrap v3
     */
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover. With parameter <code>true</code> allows toggling, with parameter <code>false</code>
     * only hides opened dropdown. Parameter usage will be removed in ngx-bootstrap v3
     * @param {?=} value
     * @return {?}
     */
    BsDropdownDirective.prototype.toggle = /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover. With parameter <code>true</code> allows toggling, with parameter <code>false</code>
     * only hides opened dropdown. Parameter usage will be removed in ngx-bootstrap v3
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this.isOpen || !value) {
            return this.hide();
        }
        return this.show();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    BsDropdownDirective.prototype.containsItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this._elementRef.nativeElement.contains(item.elementRef.nativeElement);
    };
    /**
     * @return {?}
     */
    BsDropdownDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            // clean up subscriptions and destroy dropdown
            for (var _b = __values(this._subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sub = _c.value;
                sub.unsubscribe();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this._dropdown.dispose();
    };
    /**
     * @private
     * @return {?}
     */
    BsDropdownDirective.prototype.addBs4Polyfills = /**
     * @private
     * @return {?}
     */
    function () {
        if (!isBs3$1()) {
            this.addShowClass();
            this.checkRightAlignment();
            this.addDropupStyles();
        }
    };
    /**
     * @private
     * @return {?}
     */
    BsDropdownDirective.prototype.addShowClass = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            this._renderer.addClass(this._inlinedMenu.rootNodes[0], 'show');
        }
    };
    /**
     * @private
     * @return {?}
     */
    BsDropdownDirective.prototype.removeShowClass = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            this._renderer.removeClass(this._inlinedMenu.rootNodes[0], 'show');
        }
    };
    /**
     * @private
     * @return {?}
     */
    BsDropdownDirective.prototype.checkRightAlignment = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            /** @type {?} */
            var isRightAligned = this._inlinedMenu.rootNodes[0].classList.contains('dropdown-menu-right');
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'left', isRightAligned ? 'auto' : '0');
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'right', isRightAligned ? '0' : 'auto');
        }
    };
    /**
     * @private
     * @return {?}
     */
    BsDropdownDirective.prototype.addDropupStyles = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            // a little hack to not break support of bootstrap 4 beta
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'top', this.dropup ? 'auto' : '100%');
            this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'transform', this.dropup ? 'translateY(-101%)' : 'translateY(0)');
        }
    };
    /**
     * @private
     * @return {?}
     */
    BsDropdownDirective.prototype.removeDropupStyles = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
            this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], 'top');
            this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], 'transform');
        }
    };
    BsDropdownDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[mdbDropdown],[dropdown]',
                    exportAs: 'bs-dropdown',
                    providers: [BsDropdownState],
                    host: {
                        '[class.dropup]': 'dropup',
                        '[class.open]': 'isOpen',
                        '[class.show]': 'isOpen && isBs4'
                    }
                },] }
    ];
    /** @nocollapse */
    BsDropdownDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ViewContainerRef },
        { type: ComponentLoaderFactory },
        { type: BsDropdownConfig },
        { type: BsDropdownState }
    ]; };
    BsDropdownDirective.propDecorators = {
        placement: [{ type: Input }],
        triggers: [{ type: Input }],
        container: [{ type: Input }],
        dropup: [{ type: Input }],
        autoClose: [{ type: Input }],
        isDisabled: [{ type: Input }],
        isOpen: [{ type: Input }],
        level: [{ type: Input, args: ['dropdown',] }],
        isOpenChange: [{ type: Output }],
        onShown: [{ type: Output }],
        onHidden: [{ type: Output }],
        childDropdowns: [{ type: ContentChildren, args: [BsDropdownDirective,] }]
    };
    return BsDropdownDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsDropdownMenuDirective = /** @class */ (function () {
    function BsDropdownMenuDirective(_state, _viewContainer, _templateRef) {
        _state.resolveDropdownMenu({
            templateRef: _templateRef,
            viewContainer: _viewContainer
        });
    }
    BsDropdownMenuDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[mdbDropdownMenu],[dropdownMenu]',
                    exportAs: 'bs-dropdown-menu'
                },] }
    ];
    /** @nocollapse */
    BsDropdownMenuDirective.ctorParameters = function () { return [
        { type: BsDropdownState },
        { type: ViewContainerRef },
        { type: TemplateRef }
    ]; };
    return BsDropdownMenuDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsDropdownToggleDirective = /** @class */ (function () {
    function BsDropdownToggleDirective(_state, _element) {
        var _this = this;
        this._state = _state;
        this._element = _element;
        this.ariaHaspopup = true;
        this.isDisabled = null;
        this._subscriptions = [];
        // sync is open value with state
        this._subscriptions.push(this._state.isOpenChange.subscribe(function (value) { return (_this.isOpen = value); }));
        // populate disabled state
        this._subscriptions.push(this._state.isDisabledChange.subscribe(function (value) { return (_this.isDisabled = value || null); }));
    }
    /**
     * @return {?}
     */
    BsDropdownToggleDirective.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.isDisabled) {
            return;
        }
        this._state.toggleClick.emit(true);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    BsDropdownToggleDirective.prototype.onDocumentClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._state.autoClose &&
            event.button !== 2 &&
            !this._element.nativeElement.contains(event.target)) {
            this._state.toggleClick.emit(false);
        }
    };
    /**
     * @return {?}
     */
    BsDropdownToggleDirective.prototype.onEsc = /**
     * @return {?}
     */
    function () {
        if (this._state.autoClose) {
            this._state.toggleClick.emit(false);
        }
    };
    /**
     * @return {?}
     */
    BsDropdownToggleDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this._subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sub = _c.value;
                sub.unsubscribe();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    BsDropdownToggleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[mdbDropdownToggle],[dropdownToggle]',
                    exportAs: 'bs-dropdown-toggle'
                },] }
    ];
    /** @nocollapse */
    BsDropdownToggleDirective.ctorParameters = function () { return [
        { type: BsDropdownState },
        { type: ElementRef }
    ]; };
    BsDropdownToggleDirective.propDecorators = {
        ariaHaspopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
        isDisabled: [{ type: HostBinding, args: ['attr.disabled',] }],
        isOpen: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
        onClick: [{ type: HostListener, args: ['click', [],] }],
        onDocumentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }],
        onEsc: [{ type: HostListener, args: ['keyup.esc',] }]
    };
    return BsDropdownToggleDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DropdownButtonDirective = /** @class */ (function () {
    function DropdownButtonDirective(_state, _element) {
        var _this = this;
        this._state = _state;
        this._element = _element;
        this._subscriptions = [];
        this.isDisabled = null;
        // 同步菜单的打开状态
        this._subscriptions.push(this._state.isOpenChange
            .subscribe(function (value) { return _this.isOpen = value; }));
        // 同步菜单的禁用状态
        this._subscriptions.push(this._state.isDisabledChange
            .subscribe(function (value) { return _this.isDisabled = value || null; }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    DropdownButtonDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isDisabled) {
            return;
        }
        this._state.onClick.emit(event);
    };
    /**
     * @return {?}
     */
    DropdownButtonDirective.prototype.onHover = /**
     * @return {?}
     */
    function () {
        if (this.isDisabled) {
            return;
        }
        this._state.onHover.emit();
    };
    /**
     * @return {?}
     */
    DropdownButtonDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this._subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sub = _c.value;
                sub.unsubscribe();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    DropdownButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[dropdownButton]'
                },] }
    ];
    /** @nocollapse */
    DropdownButtonDirective.ctorParameters = function () { return [
        { type: BsDropdownState },
        { type: ElementRef }
    ]; };
    DropdownButtonDirective.propDecorators = {
        isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
        isOpen: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onHover: [{ type: HostListener, args: ['mouseover',] }]
    };
    return DropdownButtonDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DropdownItemDirective = /** @class */ (function () {
    function DropdownItemDirective(_elementRef, barState) {
        this._elementRef = _elementRef;
        this.barState = barState;
        this.isDisabled = null;
        this.onHover = new EventEmitter();
        this.onClick = new EventEmitter();
        this.barState.addMenuItem(this);
    }
    Object.defineProperty(DropdownItemDirective.prototype, "elementRef", {
        get: /**
         * @return {?}
         */
        function () {
            return this._elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DropdownItemDirective.prototype.onMouseOver = /**
     * @return {?}
     */
    function () {
        this.onHover.emit();
    };
    /**
     * @return {?}
     */
    DropdownItemDirective.prototype.onItemClick = /**
     * @return {?}
     */
    function () {
        if (this.isDisabled) {
            return;
        }
        this.onClick.emit(this.command);
    };
    DropdownItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[dropdownItem]',
                    exportAs: 'dropdownItem'
                },] }
    ];
    /** @nocollapse */
    DropdownItemDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NavbarState }
    ]; };
    DropdownItemDirective.propDecorators = {
        isDisabled: [{ type: HostBinding, args: ['class.disabled',] }, { type: Input }],
        command: [{ type: Input, args: ['dropdownItem',] }],
        onMouseOver: [{ type: HostListener, args: ['mouseover',] }],
        onItemClick: [{ type: HostListener, args: ['click',] }]
    };
    return DropdownItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsDropdownModule = /** @class */ (function () {
    function BsDropdownModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    BsDropdownModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: BsDropdownModule, providers: [
                ComponentLoaderFactory,
                PositioningService,
                BsDropdownState,
                { provide: BsDropdownConfig, useValue: config ? config : { autoClose: true } }
            ]
        };
    };
    BsDropdownModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        BsDropdownMenuDirective,
                        BsDropdownToggleDirective,
                        BsDropdownContainerComponent,
                        BsDropdownDirective,
                        DropdownButtonDirective,
                        DropdownItemDirective
                    ],
                    exports: [
                        BsDropdownMenuDirective,
                        BsDropdownToggleDirective,
                        BsDropdownDirective,
                        DropdownButtonDirective,
                        DropdownItemDirective
                    ],
                    entryComponents: [BsDropdownContainerComponent]
                },] }
    ];
    return BsDropdownModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavbarDirective = /** @class */ (function () {
    function NavbarDirective(_elementRef, _config, _state) {
        this._elementRef = _elementRef;
        this._config = _config;
        this._state = _state;
        this._state.autoClose = this._config.autoClose;
        this.onItemClick = this._state.onItemClick;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    NavbarDirective.prototype.onDocumentClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._state.hideAllDropdown();
    };
    /**
     * @return {?}
     */
    NavbarDirective.prototype.onEsc = /**
     * @return {?}
     */
    function () {
        if (this._state.autoClose) {
            this._state.hideCurrentDropdown();
        }
    };
    /**
     * @return {?}
     */
    NavbarDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    NavbarDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.childDropdowns.forEach(function (item) { return _this._state.addDropdown(item); });
    };
    NavbarDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[navbar]',
                    exportAs: 'navbar',
                    providers: [NavbarState]
                },] }
    ];
    /** @nocollapse */
    NavbarDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: BsDropdownConfig },
        { type: NavbarState }
    ]; };
    NavbarDirective.propDecorators = {
        childDropdowns: [{ type: ContentChildren, args: [BsDropdownDirective,] }],
        childDropdowns2: [{ type: ViewChildren, args: [BsDropdownDirective,] }],
        onDocumentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }],
        onEsc: [{ type: HostListener, args: ['keyup.esc',] }]
    };
    return NavbarDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavbarModule = /** @class */ (function () {
    function NavbarModule() {
    }
    NavbarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [NavbarDirective],
                    providers: [NavbarState],
                    exports: [NavbarDirective]
                },] }
    ];
    return NavbarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var TREE_EVENTS = {
    onToggle: 'onToggle',
    onActiveChanged: 'onActiveChanged',
    onActivate: 'onActivate',
    onDeactivate: 'onDeactivate',
    onFocus: 'onFocus',
    onBlur: 'onBlur',
    onDoubleClick: 'onDoubleClick',
    onContextMenu: 'onContextMenu',
    onInitialized: 'onInitialized',
    onUpdateData: 'onUpdateData',
    onMoveNode: 'onMoveNode',
    onAddNode: 'onAddNode',
    onRemoveNode: 'onRemoveNode',
    onRightMenuClicked: 'onRightMenuClicked'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeNode = /** @class */ (function () {
    function TreeNode(data, parent, treeModel) {
        if (parent === void 0) { parent = null; }
        var _this = this;
        this.data = data;
        this.isVirtualRoot = false;
        this._isActive = false;
        // 变更树节点展示字段，由外部触发
        this.changeDisplayField = new EventEmitter();
        Object.assign(this, data, { parent: parent, treeModel: treeModel });
        this.treeModel = treeModel;
        this.parent = parent;
        this.level = this.parent ? this.parent.level + 1 : 0;
        if (this.isExpandedField) {
            this.isExpanded = true;
        }
        // 验证字段添加
        // console.log(this.idField);
        // console.log(this.typeField);
        this.childrenField = this.childrenField.map(function (child) { return new TreeNode(child, _this, treeModel); });
        // bug修复：TreeModel.canMoveNode使用parentNode，会出现undefined。这里做兼容
        this.parentNode = this.parent;
    }
    Object.defineProperty(TreeNode.prototype, "isExpanded", {
        get: /**
         * @return {?}
         */
        function () { return this._isExpanded; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._isExpanded = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isCollapsed", {
        get: /**
         * @return {?}
         */
        function () { return !this._isExpanded; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isActive", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isActive;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isActive = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "options", {
        // Proxy of treeModel
        get: 
        // Proxy of treeModel
        /**
         * @return {?}
         */
        function () {
            return this.treeModel.options;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    TreeNode.prototype.fireEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.treeModel.fireEvent(event);
    };
    Object.defineProperty(TreeNode.prototype, "idField", {
        // 表现的更像一个字段，将其封装成属性，并根据开放的读写权限，设置get/set
        get: 
        // 表现的更像一个字段，将其封装成属性，并根据开放的读写权限，设置get/set
        /**
         * @return {?}
         */
        function () {
            return this[this.options.idField];
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this[this.options.idField] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "childrenField", {
        get: /**
         * @return {?}
         */
        function () {
            return this[this.options.childrenField] || [];
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this[this.options.childrenField] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "displayField", {
        get: /**
         * @return {?}
         */
        function () {
            return this[this.options.displayField];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "typeField", {
        get: /**
         * @return {?}
         */
        function () {
            return this[this.options.typeField];
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this[this.options.typeField] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isExpandedField", {
        get: /**
         * @return {?}
         */
        function () {
            return this[this.options.isExpandedField];
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this[this.options.isExpandedField] = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TreeNode.prototype.allowDrag = /**
     * @return {?}
     */
    function () {
        return this.options.allowDrag;
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.enableCustomContextMenu = /**
     * @return {?}
     */
    function () {
        return this.options.enableCustomContextMenu;
    };
    Object.defineProperty(TreeNode.prototype, "isRoot", {
        get: /**
         * @return {?}
         */
        function () { return this.parent.isVirtualRoot; } // 父节点为空，表示这个一个根节点
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "realParent", {
        get: 
        // 父节点为空，表示这个一个根节点
        /**
         * @return {?}
         */
        function () { return this.isRoot ? null : this.parent; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isLeaf", {
        get: /**
         * @return {?}
         */
        function () { return !this.childrenField.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "hasChildren", {
        get: /**
         * @return {?}
         */
        function () { return !this.isLeaf; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isFocused", {
        get: /**
         * @return {?}
         */
        function () { return this.treeModel.focusedNode == this; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TreeNode.prototype.getFirstChild = /**
     * @return {?}
     */
    function () {
        return this.childrenField && this.childrenField[0];
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.getLastChild = /**
     * @return {?}
     */
    function () {
        return this.childrenField && this.childrenField[this.childrenField.length - 1];
    };
    /**
     * @private
     * @return {?}
     */
    TreeNode.prototype._getIndexInParent = /**
     * @private
     * @return {?}
     */
    function () {
        return this.parent && this.parent.childrenField.indexOf(this);
    };
    /**
     * @param {?} steps
     * @return {?}
     */
    TreeNode.prototype.findAdjacentSibling = /**
     * @param {?} steps
     * @return {?}
     */
    function (steps) {
        /** @type {?} */
        var index = this._getIndexInParent();
        return this.parent && this.parent.childrenField[index + steps];
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.findNextSibling = /**
     * @return {?}
     */
    function () {
        return this.findAdjacentSibling(+1);
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.findPreviousSibling = /**
     * @return {?}
     */
    function () {
        return this.findAdjacentSibling(-1);
    };
    /**
     * @param {?=} goInside
     * @return {?}
     */
    TreeNode.prototype.findNextNode = /**
     * @param {?=} goInside
     * @return {?}
     */
    function (goInside) {
        if (goInside === void 0) { goInside = true; }
        return goInside && this.isExpanded && this.getFirstChild() ||
            this.findNextSibling() ||
            this.parent && this.parent.findNextNode(false);
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.findPreviousNode = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousSibling = this.findPreviousSibling();
        if (!previousSibling) {
            return this.realParent;
        }
        return previousSibling.isCollapsed
            ? previousSibling
            : previousSibling.getLastChild();
    };
    /**
     * @param {?} node
     * @return {?}
     */
    TreeNode.prototype.isDescendantOf = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (this === node) {
            return true;
        }
        else {
            return this.parent && this.parent.isDescendantOf(node);
        }
    };
    // 切换方法
    // 切换节点的折叠（Collapsed）与扩展（Expanded）状态
    // 切换方法
    // 切换节点的折叠（Collapsed）与扩展（Expanded）状态
    /**
     * @return {?}
     */
    TreeNode.prototype.toggle = 
    // 切换方法
    // 切换节点的折叠（Collapsed）与扩展（Expanded）状态
    /**
     * @return {?}
     */
    function () {
        this.isExpanded = !this.isExpanded;
        this.fireEvent({ eventName: TREE_EVENTS.onToggle, node: this, isExpanded: this.isExpanded });
    };
    /**
     * @private
     * @return {?}
     */
    TreeNode.prototype._activate = /**
     * @private
     * @return {?}
     */
    function () {
        this._isActive = true;
        this.fireEvent({ eventName: TREE_EVENTS.onActivate, node: this });
        this.focus();
    };
    /**
     * @private
     * @return {?}
     */
    TreeNode.prototype._deactivate = /**
     * @private
     * @return {?}
     */
    function () {
        this._isActive = false;
        this.fireEvent({ eventName: TREE_EVENTS.onDeactivate, node: this });
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.toggleActivated = /**
     * @return {?}
     */
    function () {
        if (this.isActive) {
            this._deactivate();
            this.treeModel.activeNode = null;
        }
        else {
            if (this.treeModel.activeNode) {
                this.treeModel.activeNode._deactivate();
            }
            this._activate();
            this.treeModel.activeNode = this;
        }
        this.fireEvent({ eventName: TREE_EVENTS.onActiveChanged, node: this, isActive: this.isActive });
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.focus = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousNode = this.treeModel.focusedNode;
        this.treeModel.focusedNode = this;
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.onBlur, node: previousNode });
        }
        this.fireEvent({ eventName: TREE_EVENTS.onFocus, node: this });
    };
    /**
     * @return {?}
     */
    TreeNode.prototype.blur = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousNode = this.treeModel.focusedNode;
        this.treeModel.focusedNode = null;
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.onBlur, node: this });
        }
    };
    // 双击事件
    // 双击事件
    /**
     * @param {?} rawEvent
     * @return {?}
     */
    TreeNode.prototype.doublClick = 
    // 双击事件
    /**
     * @param {?} rawEvent
     * @return {?}
     */
    function (rawEvent) {
        this.fireEvent({ eventName: TREE_EVENTS.onDoubleClick, node: this, rawEvent: rawEvent });
    };
    // 右键快捷菜单
    // 右键快捷菜单
    /**
     * @param {?} rawEvent
     * @return {?}
     */
    TreeNode.prototype.contextMenu = 
    // 右键快捷菜单
    /**
     * @param {?} rawEvent
     * @return {?}
     */
    function (rawEvent) {
        if (this.enableCustomContextMenu()) { // 启用右键菜单功能后，禁用默认的右键菜单
            rawEvent.preventDefault();
        }
        this.fireEvent({ eventName: TREE_EVENTS.onContextMenu, node: this, rawEvent: rawEvent });
    };
    /**
     * @param {?} $event
     * @param {?=} data
     * @return {?}
     */
    TreeNode.prototype.dropMouseAction = /**
     * @param {?} $event
     * @param {?=} data
     * @return {?}
     */
    function ($event, data) {
        if (data === void 0) { data = null; }
        // 1.设置focus
        this.treeModel.setFocus(true);
        // 2.执行事件处理器
        this._dropEventHandler(this.treeModel, this, $event, data);
        // 3.完成drop操作后，重置drag状态
        this.treeModel.cancelDrag();
    };
    /**
     * @private
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @param {?} to
     * @return {?}
     */
    TreeNode.prototype._dropEventHandler = /**
     * @private
     * @param {?} tree
     * @param {?} node
     * @param {?} $event
     * @param {?} to
     * @return {?}
     */
    function (tree, node, $event, to) {
        tree.moveNode({ from: tree.getDragNode(), to: to });
        // console.log("dropEventHandler:"+tree.roots);
    };
    // 点击右键菜单项
    // 点击右键菜单项
    /**
     * @param {?} event
     * @return {?}
     */
    TreeNode.prototype.rightMenuClicked = 
    // 点击右键菜单项
    /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.fireEvent({ eventName: TREE_EVENTS.onRightMenuClicked, node: this, rawEvent: event });
    };
    return TreeNode;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeOptions = /** @class */ (function () {
    function TreeOptions(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        // nothing need to do
    }
    Object.defineProperty(TreeOptions.prototype, "idField", {
        // 字段不应直接暴露
        get: 
        // 字段不应直接暴露
        /**
         * @return {?}
         */
        function () { return this.options.childrenField || 'id'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeOptions.prototype, "displayField", {
        get: /**
         * @return {?}
         */
        function () { return this.options.displayField || 'name'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeOptions.prototype, "typeField", {
        get: /**
         * @return {?}
         */
        function () { return this.options.typeField || 'type'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeOptions.prototype, "childrenField", {
        get: /**
         * @return {?}
         */
        function () { return this.options.childrenField || 'children'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeOptions.prototype, "isExpandedField", {
        get: /**
         * @return {?}
         */
        function () { return this.options.isExpandedField || 'isExpanded'; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeOptions.prototype, "treeNodeTemplate", {
        get: /**
         * @return {?}
         */
        function () { return this.options.treeNodeTemplate || '{{ node.displayField }}'; } //插值表达式
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeOptions.prototype, "allowDrag", {
        get: 
        //插值表达式
        /**
         * @return {?}
         */
        function () { return this.options.allowDrag; } //是否启用拖拽功能
        ,
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeOptions.prototype, "enableCustomContextMenu", {
        get: 
        //是否启用拖拽功能
        /**
         * @return {?}
         */
        function () { return this.options.enableCustomContextMenu; } //是否启用快捷菜单
        ,
        enumerable: true,
        configurable: true
    });
    return TreeOptions;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeModel = /** @class */ (function () {
    function TreeModel() {
        this.options = new TreeOptions();
        // focused Node may be not actived 
        // actived Node must be focused
        this.focusedNode = null; // be chosen node
        // be chosen node
        this.activeNode = null; // be chosen and actived node
        this.eventNames = Object.keys(TREE_EVENTS);
        this.firstUpdate = true;
        this._dragNode = null;
        this._dropLocation = null;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    TreeModel.prototype.setData = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var nodes = _a.nodes, options = _a.options, events = _a.events;
        this.options = new TreeOptions(options);
        this.events = events;
        this.update(nodes);
    };
    /**
     * @param {?} nodes
     * @return {?}
     */
    TreeModel.prototype.update = /**
     * @param {?} nodes
     * @return {?}
     */
    function (nodes) {
        // Update the tree:
        var _this = this;
        this.virtualRoot = new TreeNode({ isVirtualRoot: true }, null, this);
        this.roots = nodes && nodes.map(function (child) { return new TreeNode(child, _this.virtualRoot, _this); });
        this.virtualRoot[this.options.childrenField] = this.roots;
        this._loadTreeNodeContentComponent();
        // Fire event:
        if (this.firstUpdate) {
            if (this.roots) {
                this.fireEvent({ eventName: TREE_EVENTS.onInitialized });
                this.firstUpdate = false;
            }
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.onUpdateData });
        }
    };
    //Used for code test
    //Used for code test
    /**
     * @return {?}
     */
    TreeModel.prototype.addStaticTreeNode = 
    //Used for code test
    /**
     * @return {?}
     */
    function () {
        this.createAndAddTreeNode({
            id: 1,
            name: 'root1',
            subTitle: 'the root',
            type: 'type1'
        }, this.focusedNode);
    };
    /**
     * @param {?} data
     * @param {?} parentNode
     * @param {?=} index
     * @return {?}
     */
    TreeModel.prototype.createAndAddTreeNode = /**
     * @param {?} data
     * @param {?} parentNode
     * @param {?=} index
     * @return {?}
     */
    function (data, parentNode, index) {
        /** @type {?} */
        var createdNode = this.createTreeNode(data, parentNode);
        this.addTreeNode(createdNode, parentNode, index);
    };
    /**
     * @param {?} data
     * @param {?} parent
     * @return {?}
     */
    TreeModel.prototype.createTreeNode = /**
     * @param {?} data
     * @param {?} parent
     * @return {?}
     */
    function (data, parent) {
        /** @type {?} */
        var createdNode = new TreeNode(data, parent, this);
        return createdNode;
    };
    /**
     * @param {?} addedNode
     * @param {?} parentNode
     * @param {?=} index
     * @return {?}
     */
    TreeModel.prototype.addTreeNode = /**
     * @param {?} addedNode
     * @param {?} parentNode
     * @param {?=} index
     * @return {?}
     */
    function (addedNode, parentNode, index) {
        if (addedNode == null) {
            return;
        }
        if (parentNode == null) { // 增加顶级树节点（没有父节点的树节点）
            this.roots.push(addedNode);
        }
        else {
            if (index === null || index === undefined) {
                parentNode.childrenField.push(addedNode);
            }
            else {
                parentNode.childrenField.splice(index, 0, addedNode);
            }
        }
        this.update(this.roots);
        this.fireEvent({ eventName: TREE_EVENTS.onAddNode, addedNode: addedNode, parentNode: parentNode });
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.removeFocusedTreeNode = /**
     * @return {?}
     */
    function () {
        this.removeTreeNode(this.focusedNode);
    };
    //移除选中的已知节点
    //移除选中的已知节点
    /**
     * @param {?} selectedTreeNode
     * @return {?}
     */
    TreeModel.prototype.removeTreeNode = 
    //移除选中的已知节点
    /**
     * @param {?} selectedTreeNode
     * @return {?}
     */
    function (selectedTreeNode) {
        if (selectedTreeNode == null) {
            return;
        }
        /** @type {?} */
        var parent = selectedTreeNode.parent;
        if (parent == null) { //移除顶级树节点（没有父节点的树节点）
            //移除顶级树节点（没有父节点的树节点）
            /** @type {?} */
            var index = this.roots.indexOf(selectedTreeNode);
            this.roots.splice(index, 1); //移除数组中某一指定节点
        }
        else {
            if (parent.childrenField.length <= 0) {
                console.log("RemoveTreeNode Warning: it is impossible to remove element from an empty array");
                return;
            }
            //移除数组中某一指定节点
            /** @type {?} */
            var index = parent.childrenField.indexOf(selectedTreeNode);
            parent.childrenField.splice(index, 1);
        }
        this.update(this.roots);
        this.fireEvent({ eventName: TREE_EVENTS.onRemoveNode, selectedTreeNode: selectedTreeNode, parent: parent });
    };
    /**
     * 定位指定树节点
     * @param needLocatedNode 待定位节点
     */
    /**
     * 定位指定树节点
     * @param {?} needLocatedNode 待定位节点
     * @return {?}
     */
    TreeModel.prototype.locateTreeNode = /**
     * 定位指定树节点
     * @param {?} needLocatedNode 待定位节点
     * @return {?}
     */
    function (needLocatedNode) {
        if (needLocatedNode == null) {
            return;
        }
        /** @type {?} */
        var parentNode = needLocatedNode.parent;
        while (parentNode != null) {
            parentNode.isExpanded = true;
            parentNode = parentNode.parent;
        }
        needLocatedNode.isActive = false;
        needLocatedNode.toggleActivated();
    };
    /**
     * 通过ID定位树节点
     * @param nodeID 待查找并定位节点的ID
     */
    /**
     * 通过ID定位树节点
     * @param {?} nodeID 待查找并定位节点的ID
     * @return {?}
     */
    TreeModel.prototype.locateNodeByID = /**
     * 通过ID定位树节点
     * @param {?} nodeID 待查找并定位节点的ID
     * @return {?}
     */
    function (nodeID) {
        /** @type {?} */
        var node = this.searchTreeNodeByID(nodeID);
        if (node == null) {
            return false;
        }
        this.locateTreeNode(node);
        return true;
    };
    /**
     * 查找指定树节点
     * @param nodeID 待查找节点ID
     */
    /**
     * 查找指定树节点
     * @param {?} nodeID 待查找节点ID
     * @return {?}
     */
    TreeModel.prototype.searchTreeNodeByID = /**
     * 查找指定树节点
     * @param {?} nodeID 待查找节点ID
     * @return {?}
     */
    function (nodeID) {
        return this.searchTreeNode(this.roots, nodeID);
    };
    /**
     * 在指定集合中，根据ID查找树节点
     * @param nodes 树集合
     * @param nodeID 待查找节点ID
     */
    /**
     * 在指定集合中，根据ID查找树节点
     * @param {?} nodes 树集合
     * @param {?} nodeID 待查找节点ID
     * @return {?}
     */
    TreeModel.prototype.searchTreeNode = /**
     * 在指定集合中，根据ID查找树节点
     * @param {?} nodes 树集合
     * @param {?} nodeID 待查找节点ID
     * @return {?}
     */
    function (nodes, nodeID) {
        var _this = this;
        if (nodes == null || nodes.length <= 0) {
            return null;
        }
        if (nodeID == null || nodeID.length < 0) {
            return null;
        }
        /** @type {?} */
        var searchedTreeNode = null;
        nodes.forEach(function (node) {
            if (node.idField == nodeID) { //回归
                searchedTreeNode = node;
                return;
            }
            if (node.childrenField == null || node.childrenField.length < 0) { //回归
                return;
            }
            /** @type {?} */
            var searchedNodeInChildren = _this.searchTreeNode(node.childrenField, nodeID);
            if (searchedNodeInChildren != null) {
                searchedTreeNode = searchedNodeInChildren;
            }
            return; //回归
        });
        return searchedTreeNode; //返回
    };
    Object.defineProperty(TreeModel.prototype, "treeNodeContentComponent", {
        get: /**
         * @return {?}
         */
        function () { return this._treeNodeContentComponent; },
        enumerable: true,
        configurable: true
    });
    // if treeNodeTemplate is a component - use it,
    // otherwise - it's a template, so wrap it with an AdHoc component
    // if treeNodeTemplate is a component - use it,
    // otherwise - it's a template, so wrap it with an AdHoc component
    /**
     * @return {?}
     */
    TreeModel.prototype._loadTreeNodeContentComponent = 
    // if treeNodeTemplate is a component - use it,
    // otherwise - it's a template, so wrap it with an AdHoc component
    /**
     * @return {?}
     */
    function () {
        this._treeNodeContentComponent = this.options.treeNodeTemplate;
        if (typeof this._treeNodeContentComponent === 'string') ;
    };
    Object.defineProperty(TreeModel.prototype, "isFocused", {
        // _createAdHocComponent(templateStr) {
        //     @Component({
        //         selector: 'TreeNodeTemplate',
        //         template: templateStr
        //     })
        //     class AdHocTreeNodeTemplateComponent {
        //         @Input() node: TreeNode;
        //     }
        //     return AdHocTreeNodeTemplateComponent;
        // }
        get: 
        // _createAdHocComponent(templateStr) {
        //     @Component({
        //         selector: 'TreeNodeTemplate',
        //         template: templateStr
        //     })
        //     class AdHocTreeNodeTemplateComponent {
        //         @Input() node: TreeNode;
        //     }
        //     return AdHocTreeNodeTemplateComponent;
        // }
        /**
         * @return {?}
         */
        function () {
            return TreeModel.focusedTree === this;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    TreeModel.prototype.setFocus = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        TreeModel.focusedTree = value ? this : null;
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.getFirstRoot = /**
     * @return {?}
     */
    function () {
        return first(this.roots);
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.getLastRoot = /**
     * @return {?}
     */
    function () {
        return last(this.roots);
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.focusNextNode = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousNode = this.focusedNode;
        /** @type {?} */
        var nextNode = previousNode ? previousNode.findNextNode() : this.getFirstRoot();
        nextNode && nextNode.focus(); // Short-circuit evaluation
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.focusPreviousNode = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousNode = this.focusedNode;
        /** @type {?} */
        var nextNode = previousNode ? previousNode.findPreviousNode() : this.getLastRoot();
        nextNode && nextNode.focus();
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.focusDrillUp = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousNode = this.focusedNode;
        /** @type {?} */
        var nextNode = previousNode && previousNode.realParent;
        nextNode && nextNode.focus();
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.focusDrillDown = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousNode = this.focusedNode;
        /** @type {?} */
        var nextNode = previousNode && previousNode.getFirstChild();
        nextNode && nextNode.focus();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TreeModel.prototype.fireEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // https://stackoverflow.com/questions/35840576/differencse-between-eventemitter-next-and-eventemitter-emit-in-angular-2
        //  abandon next() function, begin to use emit() function
        // this.events[event.eventName].next(event);
        // this.events[event.eventName].emit(event,alert(event.eventName));//发射事件，并传递事件的对象
        this.events[event.eventName].emit(event);
    };
    /**
     * 判断是否执行移动节点操作，可以移动返回true，否则返回false
     * @param param0 param0.from 待移动节点的原有父节点
     *               param0.to 待移动节点的新父节点
     */
    /**
     * 判断是否执行移动节点操作，可以移动返回true，否则返回false
     * @param {?} __0
     * @return {?}
     */
    TreeModel.prototype.canMoveNode = /**
     * 判断是否执行移动节点操作，可以移动返回true，否则返回false
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var from = _a.from, to = _a.to;
        // same node
        if (from.parentNode === to.parentNode && from.index === to.index) {
            return false;
        }
        /** @type {?} */
        var fromChildren = from.parentNode.children;
        /** @type {?} */
        var fromNode = fromChildren[from.index];
        return !to.parentNode.isDescendantOf(fromNode);
    };
    /**
     * 移动节点
     * @param param0 param0.from 待移动节点的原有父节点
     *               param0.to 待移动节点的新父节点
     */
    /**
     * 移动节点
     * @param {?} __0
     * @return {?}
     */
    TreeModel.prototype.moveNode = /**
     * 移动节点
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var from = _a.from, to = _a.to;
        if (!this.canMoveNode({ from: from, to: to }))
            return;
        /** @type {?} */
        var fromChildren = from.parentNode.childrenField;
        // If node doesn't have children - create children array
        if (!to.parentNode.childrenField) {
            to.parentNode.childrenField = [];
        }
        /** @type {?} */
        var toChildren = to.parentNode.childrenField;
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
        // The splice() method changes the contents of an array by removing existing elements and/or adding new elements.
        /** @type {?} */
        var node = fromChildren.splice(from.index, 1)[0];
        // Compensate for index if already removed from parent:
        /** @type {?} */
        var toIndex = (from.parentNode === to.parentNode && to.index > from.index) ? to.index - 1 : to.index;
        toChildren.splice(toIndex, 0, node);
        // console.log("toChildren:" + toChildren);
        // console.log("AfterMoveNode:" + this.roots);
        this.update(this.roots); // 实现node moved后，重新刷新这棵树
        this.fireEvent({ eventName: TREE_EVENTS.onMoveNode, node: node, to: to });
    };
    // TODO: move to a different service:
    // TODO: move to a different service:
    /**
     * @param {?} dragNode
     * @return {?}
     */
    TreeModel.prototype.setDragNode = 
    // TODO: move to a different service:
    /**
     * @param {?} dragNode
     * @return {?}
     */
    function (dragNode) {
        this._dragNode = dragNode;
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.getDragNode = /**
     * @return {?}
     */
    function () {
        return this._dragNode || { parentNode: null, index: null };
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.isDragging = /**
     * @return {?}
     */
    function () {
        return this.getDragNode().parentNode;
    };
    /**
     * @param {?} dropLocation
     * @return {?}
     */
    TreeModel.prototype.setDropLocation = /**
     * @param {?} dropLocation
     * @return {?}
     */
    function (dropLocation) {
        this._dropLocation = dropLocation;
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.getDropLocation = /**
     * @return {?}
     */
    function () {
        return this._dropLocation || { component: null, parentNode: null, index: null };
    };
    /**
     * @param {?} component
     * @return {?}
     */
    TreeModel.prototype.isDraggingOver = /**
     * @param {?} component
     * @return {?}
     */
    function (component) {
        return this.getDropLocation().component === component;
    };
    /**
     * @return {?}
     */
    TreeModel.prototype.cancelDrag = /**
     * @return {?}
     */
    function () {
        this.setDropLocation(null);
        this.setDragNode(null);
    };
    TreeModel.focusedTree = null;
    TreeModel.decorators = [
        { type: Injectable }
    ];
    return TreeModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// keys used in the angular tree component
/** @type {?} */
var KEYS = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    SPACE: 32
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//约定使用下划线表示lodash，就像用$表示jQuery一样
//1.require关键字不被识别：
// https://stackoverflow.com/questions/31173738/typescript-getting-error-ts2304-cannot-find-name-require
// declare var require: any
// const _ = require('lodash');
//2.安装lodash的es版本：
// (1) $>npm i lodash-es
// (2) $>npm install --save @types/lodash
var TreeComponent = /** @class */ (function () {
    function TreeComponent(treeModel) {
        var _this = this;
        this.treeModel = treeModel;
        treeModel.eventNames.forEach(function (name) { return _this[name] = new EventEmitter(); }); //customEventName -> new EventEmitter()
    }
    Object.defineProperty(TreeComponent.prototype, "nodes", {
        set: /**
         * @param {?} nodes
         * @return {?}
         */
        function (nodes) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeComponent.prototype, "options", {
        set: /**
         * @param {?} options
         * @return {?}
         */
        function (options) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeComponent.prototype, "focused", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.treeModel.setFocus(value);
            // alert('focused on the tree');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    TreeComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.treeModel.setData({
            nodes: changes.nodes && changes.nodes.currentValue,
            options: changes.options && changes.options.currentValue,
            events: pick(this, this.treeModel.eventNames)
        });
    };
    // 优先使用HostListener装饰器绑定事件，而不是使用Directive或Component的host元数据
    // When binding events to Directive or Component, Angular suggests to prefer to HostListener decorator, 
    // rather than host metadata.
    // 优先使用HostListener装饰器绑定事件，而不是使用Directive或Component的host元数据
    // When binding events to Directive or Component, Angular suggests to prefer to HostListener decorator, 
    // rather than host metadata.
    /**
     * @param {?} $event
     * @return {?}
     */
    TreeComponent.prototype.onKeydown = 
    // 优先使用HostListener装饰器绑定事件，而不是使用Directive或Component的host元数据
    // When binding events to Directive or Component, Angular suggests to prefer to HostListener decorator, 
    // rather than host metadata.
    /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        // alert('Pressed a key');
        /** @type {?} */
        var focusedNode = this.treeModel.focusedNode;
        if (!this.treeModel.isFocused) {
            return;
        }
        if (includes([KEYS.DOWN, KEYS.UP, KEYS.LEFT,
            KEYS.RIGHT, KEYS.ENTER, KEYS.SPACE], $event.keyCode)) {
            $event.preventDefault(); //取消事件的默认动作，实现仅对includes键响应
        }
        switch ($event.keyCode) {
            case KEYS.DOWN:
                return this.treeModel.focusNextNode();
            case KEYS.UP:
                return this.treeModel.focusPreviousNode();
            case KEYS.LEFT:
                // alert('Focus Drill Up');
                if (focusedNode.isExpanded) {
                    focusedNode.toggle();
                }
                else {
                    this.treeModel.focusDrillUp();
                }
                return;
            case KEYS.RIGHT:
                // alert('Focus Drill Down');
                if (focusedNode.isCollapsed) {
                    focusedNode.toggle();
                }
                else {
                    this.treeModel.focusDrillDown();
                }
                return;
            case KEYS.ENTER:
            case KEYS.SPACE:
                // alert('Enter or Space key.');
                return focusedNode && focusedNode.toggleActivated();
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    TreeComponent.prototype.onMousedown = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        // alert('click');
        /** @type {?} */
        var insideClick = $event.target.closest('ng2tree');
        if (!insideClick) {
            this.treeModel.setFocus(false);
        }
    };
    /**
     * @param {?} elementId
     * @return {?}
     */
    TreeComponent.prototype.searchAndLocationNodeById = /**
     * @param {?} elementId
     * @return {?}
     */
    function (elementId) {
        // console.log('succeeded to search and location Node By Id in treeComponent:', elementId);
        this.treeModel.locateNodeByID(elementId);
    };
    /**
     * @param {?} elementId
     * @return {?}
     */
    TreeComponent.prototype.searchNodeById = /**
     * @param {?} elementId
     * @return {?}
     */
    function (elementId) {
        // console.log('succeeded to search and location Node By Id in treeComponent:', elementId);
        return this.treeModel.searchTreeNodeByID(elementId);
    };
    TreeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng2tree',
                    template: "<div class=\"tree\">\r\n    <!-- <div class=\"localFileTreeOperateTest\">\r\n      <button (click)=\"treeModel.addStaticTreeNode()\">\u65B0\u589E</button>\r\n      <button (click)=\"treeModel.removeFocusedTreeNode()\">\u5220\u9664</button>\r\n    </div> -->\r\n    <ng2tree-node\r\n      (click)=\"treeModel.setFocus(true)\"\r\n      *ngFor=\"let child of treeModel.roots; let i = index\"\r\n      [node]=\"child\"\r\n      [nodeIndex]=\"i\">\r\n    </ng2tree-node>\r\n</div>",
                    providers: [
                        TreeModel
                    ],
                    styles: [".tree-children{padding-left:20px}.tree{display:inline-block;cursor:pointer;-webkit-user-select:none;-ms-user-select:none;-moz-user-select:none;user-select:none}"]
                }] }
    ];
    /** @nocollapse */
    TreeComponent.ctorParameters = function () { return [
        { type: TreeModel }
    ]; };
    TreeComponent.propDecorators = {
        nodes: [{ type: Input }],
        options: [{ type: Input }],
        focused: [{ type: Input }],
        onToggle: [{ type: Output }],
        onActiveChanged: [{ type: Output }],
        onActivate: [{ type: Output }],
        onDeactivate: [{ type: Output }],
        onFocus: [{ type: Output }],
        onBlur: [{ type: Output }],
        onDoubleClick: [{ type: Output }],
        onContextMenu: [{ type: Output }],
        onRightMenuClicked: [{ type: Output }],
        onKeydown: [{ type: HostListener, args: ['body: keydown', ['$event'],] }],
        onMousedown: [{ type: HostListener, args: ['body: mousedown', ['$event'],] }]
    };
    return TreeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 定义辅助指令TreeNodeContent，用来在模板中标记插入点
var TreeNodeContentDirective = /** @class */ (function () {
    // 依赖注入ViewContainerRef，获取对容器视图的访问权限
    function TreeNodeContentDirective(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    TreeNodeContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[treeNodeContent-host]'
                },] }
    ];
    /** @nocollapse */
    TreeNodeContentDirective.ctorParameters = function () { return [
        { type: ViewContainerRef }
    ]; };
    return TreeNodeContentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeNodeContentItem = /** @class */ (function () {
    function TreeNodeContentItem(component, displayData) {
        this.component = component;
        this.displayData = displayData;
    }
    return TreeNodeContentItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeNodeContentComponent = /** @class */ (function () {
    function TreeNodeContentComponent(componentFactoryResolver) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.rightMenuClicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    TreeNodeContentComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // 右键菜单相关
        this.rightMenuContainer.clear();
        if (this.originData.hasRightClickMenu) {
            /** @type {?} */
            var componentFactory = this.componentFactoryResolver.resolveComponentFactory(this.originData.rightClickMenuComponent);
            /** @type {?} */
            var componentRef = this.rightMenuContainer.createComponent(componentFactory);
            componentRef.instance['nodeData'] = this.originData;
            componentRef.instance['rightMenuClicked'].subscribe(function (event) {
                _this.rightMenuClicked.emit(event);
            });
        }
    };
    TreeNodeContentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng2tree-node-content',
                    template: "<div class='tree-node-content' *ngIf=\"!originData.hasRightClickMenu\">\r\n  <span>{{ displayData }}</span>\r\n</div>\r\n<ng-container #rightMenuContainer>\r\n</ng-container>",
                    styles: [".tree-node-content:hover{background:#a8daa7}"]
                }] }
    ];
    /** @nocollapse */
    TreeNodeContentComponent.ctorParameters = function () { return [
        { type: ComponentFactoryResolver }
    ]; };
    TreeNodeContentComponent.propDecorators = {
        displayData: [{ type: Input }],
        originData: [{ type: Input }],
        rightMenuClicked: [{ type: Output }],
        rightMenuContainer: [{ type: ViewChild, args: ['rightMenuContainer', { read: ViewContainerRef },] }]
    };
    return TreeNodeContentComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeNodeComponent = /** @class */ (function () {
    function TreeNodeComponent(componentFactoryResolver, viewContainerRef) {
        this.componentFactoryResolver = componentFactoryResolver;
    }
    // TODO: move to draggable directive
    // TODO: move to draggable directive
    /**
     * @param {?} $event
     * @return {?}
     */
    TreeNodeComponent.prototype.onDragStart = 
    // TODO: move to draggable directive
    /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        var _this = this;
        // 设置DragNode: 选择dragNode的父节点作为DragNode，通过index定位到指定的节点
        setTimeout(function () { return _this.node.treeModel.setDragNode({ parentNode: _this.node.parent, index: _this.nodeIndex }); }, 30);
    };
    /**
     * @return {?}
     */
    TreeNodeComponent.prototype.onDragEnd = /**
     * @return {?}
     */
    function () {
        this.node.treeModel.setDragNode(null);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    TreeNodeComponent.prototype.onDragOver = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        $event.preventDefault();
        this.node.treeModel.setDropLocation({ component: this, parentNode: this.node, index: 0 });
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    TreeNodeComponent.prototype.onDrop = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        $event.preventDefault();
        // this.node.mouseAction('drop', $event, { node: this.node, index: 0 });
        this.node.treeModel.setFocus(true);
        this.node.dropMouseAction($event, { parentNode: this.node, index: 0 });
        console.log("onDrop: tree-node-component");
    };
    /**
     * @param {?} nodeContentWrapper
     * @param {?} $event
     * @return {?}
     */
    TreeNodeComponent.prototype.onDragLeave = /**
     * @param {?} nodeContentWrapper
     * @param {?} $event
     * @return {?}
     */
    function (nodeContentWrapper, $event) {
        if (!this.node.treeModel.isDraggingOver(this)) {
            return;
        }
        /** @type {?} */
        var rect = nodeContentWrapper.getBoundingClientRect();
        // If outside the element
        if ($event.clientX < rect.left || $event.clientX > rect.right ||
            $event.clientY < rect.top || $event.clientY > rect.bottom) {
            this.node.treeModel.setDropLocation(null);
        }
    };
    /**
     * @return {?}
     */
    TreeNodeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._loadTreeNodeContent();
        // 触发变更树节点展示文本
        this.node.changeDisplayField.subscribe(function (name) {
            if (_this.componentRef) {
                _this.componentRef.instance.displayData = name;
            }
        });
    };
    /**
     * @return {?}
     */
    TreeNodeComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
    };
    // 解决使用动态组件出现ExpressionChangedAfterItHasBeenCheckedError问题：
    // https://github.com/angular/angular/issues/17572
    // 解决使用动态组件出现ExpressionChangedAfterItHasBeenCheckedError问题：
    // https://github.com/angular/angular/issues/17572
    /**
     * @return {?}
     */
    TreeNodeComponent.prototype._loadTreeNodeContent = 
    // 解决使用动态组件出现ExpressionChangedAfterItHasBeenCheckedError问题：
    // https://github.com/angular/angular/issues/17572
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        // 使用Item从逻辑上将TreeNodeContentComponent和data关联起来
        /** @type {?} */
        var treeNodeContentItem = new TreeNodeContentItem(TreeNodeContentComponent, this.node.displayField);
        // 使用 ComponentFactoryResolver 来为每个具体的组件解析出一个 ComponentFactory 
        // 然后 ComponentFactory 会为每一个组件创建一个实例
        /** @type {?} */
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(treeNodeContentItem.component);
        /** @type {?} */
        var viewContainerRef = this.treeNodeContentHost.viewContainerRef;
        viewContainerRef.clear();
        this.componentRef = viewContainerRef.createComponent(componentFactory);
        this.componentRef.instance.displayData = treeNodeContentItem.displayData; // 传入数据
        this.componentRef.instance.originData = this.node.data;
        this.componentRef.instance.rightMenuClicked.subscribe(function (event) {
            _this.node.rightMenuClicked(event);
        });
    };
    TreeNodeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng2tree-node',
                    template: "<div class=\"tree-node tree-node-level-{{ node.level }}\"\r\n[class.tree-node-expanded]=\"node.isExpanded && node.hasChildren\"\r\n[class.tree-node-collapsed]=\"node.isCollapsed && node.hasChildren\"\r\n[class.tree-node-leaf]=\"node.isLeaf\"\r\n[class.tree-node-active]=\"node.isActive\"\r\n[class.tree-node-focused]=\"node.isFocused\">\r\n\r\n<ng2tree-node-drop-slot\r\n  *ngIf=\"nodeIndex === 0\"\r\n  [dropIndex]=\"nodeIndex\"\r\n  [node]=\"node.parent\"\r\n></ng2tree-node-drop-slot>\r\n\r\n<span\r\n  *ngIf=\"node.hasChildren\"\r\n  class=\"toggle-children\"\r\n  (click)=\"node.toggleActivated()\"\r\n  (click)=\"node.toggle()\"\r\n  >\r\n</span>\r\n<span\r\n  *ngIf=\"!node.hasChildren\"\r\n  class=\"toggle-children-placeholder\">\r\n</span>\r\n\r\n<!-- \u8BBE\u7F6Eclick\u4E8B\u4EF6\u7684\u5904\u7406\u5668 -->\r\n<!-- [draggable]=\"node.allowDrag()\"\r\n(dragstart)=\"onDragStart($event)\"\r\n(drop)=\"onDrop($event)\"\r\n(dragend)=\"onDragEnd()\"\r\n(dragover)=\"onDragOver($event)\"\r\n(dragleave)=\"onDragLeave(nodeContentWrapper, $event)\" -->\r\n<div class=\"node-content-wrapper\"\r\n  #nodeContentWrapper\r\n  (click)=\"node.toggleActivated()\"\r\n  (dblclick)=\"node.doublClick($event)\"\r\n  (contextmenu)=\"node.contextMenu($event)\"\r\n\r\n  >\r\n  <!-- \u8BBE\u7F6E\u52A8\u6001\u7EC4\u4EF6\u7684\u951A\u70B9 -->\r\n  <ng-template treeNodeContent-host></ng-template> \r\n</div>\r\n\r\n<div class=\"tree-children\" [hidden]=\"node.isCollapsed\">\r\n  <ng2tree-node\r\n    *ngFor=\"let child of node.childrenField; let i = index\"\r\n    [node]=\"child\"\r\n    [nodeIndex]=\"i\">\r\n  </ng2tree-node>\r\n</div>\r\n\r\n<ng2tree-node-drop-slot\r\n  [dropIndex]=\"nodeIndex + 1\"\r\n  [node]=\"node.parent\"\r\n></ng2tree-node-drop-slot>\r\n\r\n</div>",
                    styles: [".tree-children{padding-left:20px}.node-content-wrapper{display:inline-block;padding:2px 5px;border-radius:2px;transition:background-color .15s,box-shadow .15s;white-space:nowrap}.tree-node-active>.node-content-wrapper{background:#beebff}.tree-node-active.tree-node-focused>.node-content-wrapper{background:#5db0e7}.tree-node-focused>.node-content-wrapper{background:#e7f4f9}.node-content-wrapper:hover{background:#f7fbff}.node-content-wrapper:hover,.tree-node-active>.node-content-wrapper,.tree-node-focused>.node-content-wrapper{box-shadow:inset 0 0 1px #999}.tree-node-expanded .toggle-children{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='%23646465' d='M11 10H5.344L11 4.414V10z'/%3E%3C/svg%3E\")}.tree-node-collapsed .toggle-children{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='%23646465' d='M6 4v8l4-4-4-4zm1 2.414L8.586 8 7 9.586V6.414z'/%3E%3C/svg%3E\")}.toggle-children{height:16px;width:16px;background-size:16px;display:inline-block;position:relative;background-repeat:no-repeat;background-position:center;right:-6px;top:4px;overflow:hidden}.toggle-children-placeholder{display:inline-block;height:10px;width:10px;position:relative;top:1px}.tree-node-icon{width:1rem}.tree-node{white-space:nowrap}"]
                }] }
    ];
    /** @nocollapse */
    TreeNodeComponent.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: ViewContainerRef }
    ]; };
    TreeNodeComponent.propDecorators = {
        node: [{ type: Input }],
        nodeIndex: [{ type: Input }],
        treeNodeContentHost: [{ type: ViewChild, args: [TreeNodeContentDirective,] }]
    };
    return TreeNodeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeNodeDropSlotComponent = /** @class */ (function () {
    function TreeNodeDropSlotComponent() {
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    TreeNodeDropSlotComponent.prototype.onDragOver = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        $event.preventDefault();
        this.node.treeModel.setDropLocation({ component: this, parentNode: this.node, index: this.dropIndex });
    };
    /**
     * @return {?}
     */
    TreeNodeDropSlotComponent.prototype.onDragLeave = /**
     * @return {?}
     */
    function () {
        if (this.node.treeModel.isDraggingOver(this)) {
            this.node.treeModel.setDropLocation(null);
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    TreeNodeDropSlotComponent.prototype.onDrop = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        $event.preventDefault();
        // this.node.mouseAction('drop', $event, { node: this.node, index: this.dropIndex });
        console.log('onDropEvent: tree-node-drop-slot');
        this.node.dropMouseAction($event, { parentNode: this.node, index: this.dropIndex });
    };
    TreeNodeDropSlotComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ng2tree-node-drop-slot',
                    template: "<div\r\n  class=\"node-drop-slot\"\r\n  [class.is-dragging-over]=\"node.treeModel.isDraggingOver(this)\"\r\n  (drop)=\"onDrop($event)\"\r\n  (dragover)=\"onDragOver($event)\"\r\n  (dragleave)=\"onDragLeave()\"\r\n>\r\n</div>",
                    styles: [".node-drop-slot{display:block;height:2px;width:100%}.node-drop-slot.is-dragging-over{background:#dfe;height:20px;border:2px dotted #888}"]
                }] }
    ];
    TreeNodeDropSlotComponent.propDecorators = {
        node: [{ type: Input }],
        dropIndex: [{ type: Input }]
    };
    return TreeNodeDropSlotComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TreeModule = /** @class */ (function () {
    function TreeModule() {
    }
    TreeModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        TreeComponent,
                        TreeNodeComponent,
                        TreeNodeContentComponent,
                        TreeNodeContentDirective,
                        TreeNodeDropSlotComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    providers: [],
                    entryComponents: [
                        TreeNodeContentComponent
                    ],
                    exports: [
                        TreeComponent,
                        TreeNodeComponent,
                        TreeNodeContentComponent,
                        TreeNodeContentDirective,
                        TreeNodeDropSlotComponent
                    ]
                },] }
    ];
    return TreeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// injectionToken作用说明
// https://segmentfault.com/a/1190000008626348
/** @type {?} */
var ANGULAR_MONACO_EDITOR_CONFIG = new InjectionToken('ANGULAR_MONACO_EDITOR_CONFIG');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CODE_EDITOR_EVENTS = {
    onInit: 'onInit'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CodeEditorEventService = /** @class */ (function () {
    function CodeEditorEventService() {
        this.eventNames = Object.keys(CODE_EDITOR_EVENTS);
        this._events = {}; // 使用事件
    }
    /**
     * 设置启用事件
     * @param  事件
     */
    // 使用事件
    /**
     * 设置启用事件
     * @param {?} event
     * @return {?}
     */
    CodeEditorEventService.prototype.addEvent = 
    // 使用事件
    /**
     * 设置启用事件
     * @param {?} event
     * @return {?}
     */
    function (event) {
        assign(this._events, event);
        // console.log(this.events);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CodeEditorEventService.prototype.fireEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._events[event.eventName].emit(event);
        // console.log("Emit Event:" + event);
    };
    CodeEditorEventService.decorators = [
        { type: Injectable }
    ];
    return CodeEditorEventService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var loadedMonaco = false;
/** @type {?} */
var loadPromise;
/**
 * @abstract
 */
var BaseMonacoEditor = /** @class */ (function () {
    function BaseMonacoEditor(codeEditorEventService, config) {
        this.codeEditorEventService = codeEditorEventService;
        this.config = config;
        // 初始化自定义事件
        /** @type {?} */
        var self = this;
        codeEditorEventService.eventNames.forEach(function (name) {
            // 创建自定义事件，此处作用等效于: @Output() onInit = new EventEmitter<any>()
            self[name] = new EventEmitter();
            /** @type {?} */
            var eventPair = pick(self, name);
            codeEditorEventService.addEvent(eventPair);
        });
    }
    Object.defineProperty(BaseMonacoEditor.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            return this._options;
        },
        set: /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            // 默认options(this.config.defaultOptions) + 自定义options(options)
            this._options = Object.assign({}, this.config.defaultOptions, options);
            if (this._editor) {
                this._editor.dispose();
                this.initMonaco(options);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BaseMonacoEditor.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (loadedMonaco) {
            // Wait until monaco editor is available
            loadPromise.then(function () {
                _this.initMonaco(_this.options);
            });
        }
        else {
            loadedMonaco = true;
            loadPromise = new Promise(function (resolve) {
                /** @type {?} */
                var baseUrl = _this.config.baseUrl || '/assets';
                // if (typeof((<any>window).monaco) === 'object') {
                //   resolve();
                //   return;
                // }
                /** @type {?} */
                var onGotAmdLoader = function () {
                    // Load monaco
                    ((/** @type {?} */ (window))).require.config({ paths: { 'vs': baseUrl + "/monaco/vs" } });
                    ((/** @type {?} */ (window))).require(['vs/editor/editor.main'], function () {
                        if (typeof _this.config.onMonacoLoad === 'function') {
                            _this.config.onMonacoLoad();
                        }
                        _this.initMonaco(_this.options);
                        resolve();
                    });
                };
                // Load AMD loader if necessary
                if (!((/** @type {?} */ (window))).require) {
                    /** @type {?} */
                    var loaderScript = document.createElement('script');
                    loaderScript.type = 'text/javascript';
                    loaderScript.src = baseUrl + "/monaco/vs/loader.js";
                    loaderScript.addEventListener('load', onGotAmdLoader);
                    document.body.appendChild(loaderScript);
                }
                else {
                    onGotAmdLoader();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    BaseMonacoEditor.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._windowResizeSubscription) {
            this._windowResizeSubscription.unsubscribe();
        }
        if (this._editor) {
            this._editor.dispose();
            this._editor = undefined;
        }
    };
    BaseMonacoEditor.propDecorators = {
        _editorComponent: [{ type: ViewChild, args: ['codeEditor',] }],
        onInit: [{ type: Output }],
        options: [{ type: Input, args: ['options',] }]
    };
    return BaseMonacoEditor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Angular Monaco Editor Component Variables
// 汇总Angular monaco editor component 组件暴露的变量
var AngularMonacoEditorService = /** @class */ (function () {
    function AngularMonacoEditorService() {
        this._existError = false; //默认没有错误
    }
    Object.defineProperty(AngularMonacoEditorService.prototype, "existError", {
        get: 
        //默认没有错误
        /**
         * @return {?}
         */
        function () {
            return this._existError;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AngularMonacoEditorService.prototype.handleModelMarkers = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        // https://github.com/Microsoft/monaco-editor/issues/30
        /** @type {?} */
        var setModelMarkers = monaco.editor.setModelMarkers;
        monaco.editor.setModelMarkers = function (model, owner, markers) {
            setModelMarkers.call(monaco.editor, model, owner, markers);
            if (markers.length === 0) ;
            else {
                // there are errors
                self._existError = true;
            }
        };
    };
    AngularMonacoEditorService.decorators = [
        { type: Injectable }
    ];
    return AngularMonacoEditorService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 自定义输入控件:1.封装ControlValueAccessor
// https://code-examples.net/zh-CN/q/2154761
/** @type {?} */
var CODE_EDITOR_INPUT_VALUE_ACCESSOR = {
    // https://blog.csdn.net/wangdan_2013/article/details/81314959
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return AngularMonacoEditorComponent; }),
    multi: true
};
var AngularMonacoEditorComponent = /** @class */ (function (_super) {
    __extends(AngularMonacoEditorComponent, _super);
    // tslint:disable-next-line:max-line-length
    function AngularMonacoEditorComponent(angularMonacoEditorService, zone, editorEventService, angularEditorconfig) {
        var _this = _super.call(this, editorEventService, angularEditorconfig) || this;
        _this.angularMonacoEditorService = angularMonacoEditorService;
        _this.zone = zone;
        _this.editorEventService = editorEventService;
        _this.angularEditorconfig = angularEditorconfig;
        _this._value = '';
        // ControlValueAccessor提供的事件回调
        _this.onControlValueChange = function (_) {
        };
        // ControlValueAccessor提供的事件回调
        _this.onControlTouched = function () {
        };
        return _this;
    }
    Object.defineProperty(AngularMonacoEditorComponent.prototype, "model", {
        set: /**
         * @param {?} model
         * @return {?}
         */
        function (model) {
            this.options.model = model;
            if (this._editor) {
                this._editor.dispose();
                this.initMonaco(this.options);
            }
        },
        enumerable: true,
        configurable: true
    });
    // todo: 提取options公共类
    // todo: 提取options公共类
    /**
     * @protected
     * @param {?} options
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.initMonaco = 
    // todo: 提取options公共类
    /**
     * @protected
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var _this = this;
        /** @type {?} */
        var enableModel = !!options.model;
        if (enableModel) {
            /** @type {?} */
            var searchedModel = monaco.editor.getModel(options.model.uri);
            if (null !== searchedModel) {
                searchedModel.dispose();
            }
            options.model = monaco.editor.createModel(options.model.value, options.model.language, options.model.uri);
        }
        this._editor = monaco.editor.create(this._editorComponent.nativeElement, options);
        if (!enableModel) {
            this._editor.setValue(this._value);
        }
        if (enableModel) {
            this.angularMonacoEditorService.handleModelMarkers();
        }
        // monaco editor -> outside component
        this._editor.onDidChangeModelContent(function (e) { return _this.onChangeModelContentHandler(e); });
        this._editor.onDidBlurEditorText(function (e) { return _this.onBlurEditorTextHandler(e); });
        this._editor.onDidLayoutChange(function (e) { return _this.onLayoutChangeHandler(e); });
        // refresh layout on resize event.
        this.refreshLayoutWhenWindowResize();
        this.editorEventService.fireEvent({
            eventName: CODE_EDITOR_EVENTS.onInit,
            target: this,
            editor: this._editor
        });
    };
    /**
     * refresh layout when resized the window
     */
    /**
     * refresh layout when resized the window
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.refreshLayoutWhenWindowResize = /**
     * refresh layout when resized the window
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._windowResizeSubscription) {
            this._windowResizeSubscription.unsubscribe();
        }
        // fromEvent用于兼听事件，事件触发时，将事件event转成可流动的Observable进行传输
        // https://www.jianshu.com/p/46894deb870a
        this._windowResizeSubscription = fromEvent(window, 'resize').subscribe(function () { return _this._editor.layout(); });
    };
    /**
     * @param {?} e
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.onChangeModelContentHandler = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        var _this = this;
        /** @type {?} */
        var _value = this._editor.getValue();
        // monaco editor -> outside component
        // https://github.com/JTangming/tm/issues/4 ngZone详解
        this.zone.run(function () { return _this.value = _value; }); // value is not propagated to parent when executing outside zone.
    };
    /**
     * @param {?} e
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.onBlurEditorTextHandler = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.onControlTouched();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.onLayoutChangeHandler = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        console.log('Layout changed:\n' + e);
    };
    Object.defineProperty(AngularMonacoEditorComponent.prototype, "value", {
        // get accessor
        get: 
        // get accessor
        /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        // set accessor including call the onchange callback
        set: 
        // set accessor including call the onchange callback
        /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.value) { // 注意这种写法，值得学习
                this._value = v;
            }
            this.onControlValueChange(this.value); // 在属性修饰器里调用onControlValueChange方法
        },
        enumerable: true,
        configurable: true
    });
    // 自定义输入控件:3.2 implements ControlValueAccesso
    // outside component -> monaco editor
    // From ControlValueAccessor interface
    // 自定义输入控件:3.2 implements ControlValueAccesso
    // outside component -> monaco editor
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.writeValue = 
    // 自定义输入控件:3.2 implements ControlValueAccesso
    // outside component -> monaco editor
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var self = this;
        self.value = value || '';
        // Fix for value change while dispose in process.
        setTimeout(function () {
            if (self._editor /*&& !this.options.model*/) {
                self._editor.setValue(self._value);
            }
        });
    };
    // From ControlValueAccessor interface
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.registerOnChange = 
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onControlValueChange = fn;
    };
    // From ControlValueAccessor interface
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AngularMonacoEditorComponent.prototype.registerOnTouched = 
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onControlTouched = fn;
    };
    AngularMonacoEditorComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'angular-monaco-editor',
                    template: "<div class=\"editor\" #codeEditor></div>",
                    // 自定义输入控件:2.引入依赖服务ControlValueAccessor
                    providers: [
                        CODE_EDITOR_INPUT_VALUE_ACCESSOR,
                        CodeEditorEventService,
                        AngularMonacoEditorService
                    ],
                    styles: [":host{display:block;min-height:200px}.editor{width:100%;height:100%}"]
                }] }
    ];
    /** @nocollapse */
    AngularMonacoEditorComponent.ctorParameters = function () { return [
        { type: AngularMonacoEditorService },
        { type: NgZone },
        { type: CodeEditorEventService },
        { type: undefined, decorators: [{ type: Inject, args: [ANGULAR_MONACO_EDITOR_CONFIG,] }] }
    ]; };
    AngularMonacoEditorComponent.propDecorators = {
        model: [{ type: Input, args: ['model',] }]
    };
    return AngularMonacoEditorComponent;
}(BaseMonacoEditor));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AngularMonacoEditorModule = /** @class */ (function () {
    function AngularMonacoEditorModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    AngularMonacoEditorModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: AngularMonacoEditorModule,
            providers: [
                { provide: ANGULAR_MONACO_EDITOR_CONFIG, useValue: config }
            ]
        };
    };
    AngularMonacoEditorModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        AngularMonacoEditorComponent
                    ],
                    exports: [
                        AngularMonacoEditorComponent
                    ],
                    providers: []
                },] }
    ];
    return AngularMonacoEditorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MenuItemContext = /** @class */ (function () {
    function MenuItemContext() {
        this.$implicit = {};
    }
    return MenuItemContext;
}());
var ShContextMenuItemDirective = /** @class */ (function () {
    function ShContextMenuItemDirective(template) {
        this.template = template;
        this.closeOnClick = true;
        this.click = new EventEmitter();
        this.context = new MenuItemContext();
    }
    /**
     * @return {?}
     */
    ShContextMenuItemDirective.prototype.setNotActive = /**
     * @return {?}
     */
    function () {
        this._active = false;
        if (this.subMenu) {
            this.subMenu.setNotActive();
        }
    };
    /**
     * @return {?}
     */
    ShContextMenuItemDirective.prototype.setActive = /**
     * @return {?}
     */
    function () {
        this._active = true;
    };
    ShContextMenuItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[shContextMenuItem]'
                },] }
    ];
    /** @nocollapse */
    ShContextMenuItemDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] }
    ]; };
    ShContextMenuItemDirective.propDecorators = {
        subMenu: [{ type: Input }],
        divider: [{ type: Input }],
        visible: [{ type: Input }],
        disabled: [{ type: Input }],
        closeOnClick: [{ type: Input }],
        click: [{ type: Output }]
    };
    return ShContextMenuItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShContextMenuService = /** @class */ (function () {
    function ShContextMenuService(overlay) {
        this.overlay = overlay;
        this.activeOverlays = [];
    }
    /**
     * @param {?} ctxEvent
     * @return {?}
     */
    ShContextMenuService.prototype.openMenu = /**
     * @param {?} ctxEvent
     * @return {?}
     */
    function (ctxEvent) {
        this.closeCurrentOverlays();
        var menu = ctxEvent.menu, mouseEvent = ctxEvent.mouseEvent, targetElement = ctxEvent.targetElement, data = ctxEvent.data;
        this.activeMenu = menu;
        mouseEvent.preventDefault();
        mouseEvent.stopPropagation();
        this.overrideGetBoundingClientRect(targetElement, mouseEvent);
        /** @type {?} */
        var scrollStrategy = this.buildCloseScrollStrategy();
        /** @type {?} */
        var positionStrategy = this.buildConnectedPositionStrategy(targetElement);
        this.attachContextToItems(menu, data);
        /** @type {?} */
        var overlayRef = this.createAndAttachOverlay(positionStrategy, scrollStrategy, menu, true);
        this.attachOverlayRef(menu, overlayRef);
        this.registerBackdropEvents(overlayRef);
    };
    /**
     * @param {?} ctxEvent
     * @return {?}
     */
    ShContextMenuService.prototype.openSubMenu = /**
     * @param {?} ctxEvent
     * @return {?}
     */
    function (ctxEvent) {
        var menu = ctxEvent.menu, mouseEvent = ctxEvent.mouseEvent, targetElement = ctxEvent.targetElement, data = ctxEvent.data, parentMenu = ctxEvent.parentMenu;
        mouseEvent.preventDefault();
        mouseEvent.stopPropagation();
        /** @type {?} */
        var scrollStrategy = this.buildCloseScrollStrategy();
        /** @type {?} */
        var positionStrategy = this.buildConnectedPositionStrategyForSubMenu(targetElement);
        /** @type {?} */
        var overlayRef = this.createAndAttachOverlay(positionStrategy, scrollStrategy, menu, false);
        this.attachContextToItems(menu, data);
        this.attachThisContext(menu, parentMenu);
        this.attachOverlayRef(menu, overlayRef);
    };
    /**
     * @return {?}
     */
    ShContextMenuService.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.closeCurrentOverlays();
        this.backDropSub.unsubscribe();
    };
    /**
     * @return {?}
     */
    ShContextMenuService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @param {?} menu
     * @return {?}
     */
    ShContextMenuService.prototype.closeSubMenus = /**
     * @param {?} menu
     * @return {?}
     */
    function (menu) {
        var _this = this;
        /** @type {?} */
        var itemsWithSubMenus = menu
            .menuItems
            .filter(function (i) { return !!i.subMenu && !!i.subMenu.overlayRef; });
        if (itemsWithSubMenus.length) {
            itemsWithSubMenus.forEach(function (sm) { return _this.closeSubMenus(sm.subMenu); });
            /** @type {?} */
            var overlayRefs = itemsWithSubMenus
                .map(function (i) { return i.subMenu.overlayRef; });
            overlayRefs.forEach(function (r) { return r.dispose(); });
        }
    };
    /**
     * @private
     * @param {?} overlayRef
     * @return {?}
     */
    ShContextMenuService.prototype.registerBackdropEvents = /**
     * @private
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        /** @type {?} */
        var elm = overlayRef.backdropElement;
        this.backDropSub = fromEvent(elm, 'mousedown')
            .subscribe(this.closeCurrentOverlays.bind(this));
    };
    /**
     * @private
     * @param {?} positionStrategy
     * @param {?} scrollStrategy
     * @param {?} menu
     * @param {?=} hasBackdrop
     * @return {?}
     */
    ShContextMenuService.prototype.createAndAttachOverlay = /**
     * @private
     * @param {?} positionStrategy
     * @param {?} scrollStrategy
     * @param {?} menu
     * @param {?=} hasBackdrop
     * @return {?}
     */
    function (positionStrategy, scrollStrategy, menu, hasBackdrop) {
        if (hasBackdrop === void 0) { hasBackdrop = true; }
        /** @type {?} */
        var overlayRef = this.overlay.create({
            positionStrategy: positionStrategy,
            scrollStrategy: scrollStrategy,
            hasBackdrop: hasBackdrop,
            backdropClass: 'sh-backdrop'
        });
        /*
             TODO: try passing the TemplatePortal context (data)
             and then injecting it to the *ngTemplateOutlet in the component template
            */
        /** @type {?} */
        var menuPortal = new TemplatePortal(menu.menuTemplate, menu.menuContainer);
        overlayRef.attach(menuPortal);
        this.activeOverlays.push(overlayRef);
        return overlayRef;
    };
    /**
     * @private
     * @return {?}
     */
    ShContextMenuService.prototype.buildCloseScrollStrategy = /**
     * @private
     * @return {?}
     */
    function () {
        return this.overlay.scrollStrategies.close();
    };
    /**
     * @private
     * @param {?} elm
     * @return {?}
     */
    ShContextMenuService.prototype.buildConnectedPositionStrategy = /**
     * @private
     * @param {?} elm
     * @return {?}
     */
    function (elm) {
        return this
            .overlay
            .position()
            .connectedTo(elm, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
            .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
    };
    /**
     * @private
     * @param {?} elm
     * @return {?}
     */
    ShContextMenuService.prototype.buildConnectedPositionStrategyForSubMenu = /**
     * @private
     * @param {?} elm
     * @return {?}
     */
    function (elm) {
        return this
            .overlay
            .position()
            .connectedTo(elm, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });
    };
    /*
      we need to override getBoundingClientRect() to return the position of the menu.
      this is done because @angular/cdk use this function internally to determine where the overlay should be positioned
      https://github.com/angular/material2/blob/master/src/cdk/overlay/position/connected-position-strategy.ts#L288
     */
    /*
        we need to override getBoundingClientRect() to return the position of the menu.
        this is done because @angular/cdk use this function internally to determine where the overlay should be positioned
        https://github.com/angular/material2/blob/master/src/cdk/overlay/position/connected-position-strategy.ts#L288
       */
    /**
     * @private
     * @param {?} elm
     * @param {?} event
     * @return {?}
     */
    ShContextMenuService.prototype.overrideGetBoundingClientRect = /*
        we need to override getBoundingClientRect() to return the position of the menu.
        this is done because @angular/cdk use this function internally to determine where the overlay should be positioned
        https://github.com/angular/material2/blob/master/src/cdk/overlay/position/connected-position-strategy.ts#L288
       */
    /**
     * @private
     * @param {?} elm
     * @param {?} event
     * @return {?}
     */
    function (elm, event) {
        var clientX = event.clientX, clientY = event.clientY;
        elm.nativeElement.getBoundingClientRect = function () {
            return {
                bottom: clientY,
                height: 0,
                left: clientX,
                right: clientX,
                top: clientY,
                width: 0
            };
        };
    };
    /**
     * @private
     * @return {?}
     */
    ShContextMenuService.prototype.closeCurrentOverlays = /**
     * @private
     * @return {?}
     */
    function () {
        this.activeOverlays.forEach(function (o) {
            o.detach();
            o.dispose();
        });
        this.activeOverlays = [];
        // TODO: create close subject and emit.
        // subscribe in component
        if (this.activeMenu) {
            this.activeMenu.close();
        }
    };
    /**
     * @private
     * @param {?} menu
     * @param {?} data
     * @return {?}
     */
    ShContextMenuService.prototype.attachContextToItems = /**
     * @private
     * @param {?} menu
     * @param {?} data
     * @return {?}
     */
    function (menu, data) {
        menu.menuItems.forEach(function (i) { return i.context.$implicit = data; });
    };
    /**
     * @private
     * @param {?} menu
     * @param {?} parentMenu
     * @return {?}
     */
    ShContextMenuService.prototype.attachThisContext = /**
     * @private
     * @param {?} menu
     * @param {?} parentMenu
     * @return {?}
     */
    function (menu, parentMenu) {
        menu.thisContext = parentMenu.thisContext;
    };
    /**
     * @private
     * @param {?} menu
     * @param {?} overlayRef
     * @return {?}
     */
    ShContextMenuService.prototype.attachOverlayRef = /**
     * @private
     * @param {?} menu
     * @param {?} overlayRef
     * @return {?}
     */
    function (menu, overlayRef) {
        menu.overlayRef = overlayRef;
    };
    ShContextMenuService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ShContextMenuService.ctorParameters = function () { return [
        { type: Overlay }
    ]; };
    return ShContextMenuService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShContextMenuComponent = /** @class */ (function () {
    function ShContextMenuComponent(ctxService) {
        this.ctxService = ctxService;
        this.contentChildrenItems = new QueryList();
        this.viewChildrenItems = new QueryList();
    }
    Object.defineProperty(ShContextMenuComponent.prototype, "menuItems", {
        get: /**
         * @return {?}
         */
        function () {
            // when using the ShContextMenuComponent as menu, the ContentChildren is the source
            if (this.contentChildrenItems.length) {
                return this.contentChildrenItems;
            }
            // when using a custom component as menu the ViewChildren is the source
            return this.viewChildrenItems;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} $event
     * @param {?} item
     * @param {?} elm
     * @return {?}
     */
    ShContextMenuComponent.prototype.onEnter = /**
     * @param {?} $event
     * @param {?} item
     * @param {?} elm
     * @return {?}
     */
    function ($event, item, elm) {
        this.ctxService.closeSubMenus(this);
        this.setNotActive();
        if (!item.subMenu || !item.visible) {
            return;
        }
        this.setActive(item);
        this.ctxService.openSubMenu({
            data: item.context.$implicit,
            targetElement: new ElementRef(elm),
            menu: item.subMenu,
            mouseEvent: $event,
            parentMenu: this
        });
    };
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    ShContextMenuComponent.prototype.setActive = /**
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        item.setActive();
        this.subActive = true;
    };
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    ShContextMenuComponent.prototype.onClick = /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    function (event, item) {
        // TODO: move click handling to service
        if (item.divider) {
            return;
        }
        if (!item.subMenu && item.closeOnClick) {
            this.ctxService.destroy();
            item.click.emit({
                data: item.context.$implicit,
                event: event
            });
        }
    };
    /**
     * @private
     * @param {?} fn
     * @param {?} fallbackContext
     * @param {?} data
     * @param {?} event
     * @return {?}
     */
    ShContextMenuComponent.prototype.callWithContext = /**
     * @private
     * @param {?} fn
     * @param {?} fallbackContext
     * @param {?} data
     * @param {?} event
     * @return {?}
     */
    function (fn, fallbackContext, data, event) {
        return fn.call(this.thisContext ? this.thisContext : fallbackContext, { data: data, event: event });
    };
    /**
     * @return {?}
     */
    ShContextMenuComponent.prototype.close = /**
     * @return {?}
     */
    function () {
        this.setNotActive();
        this.menuContainer.detach();
        if (this.overlayRef) {
            this.overlayRef.detach();
        }
    };
    /**
     * @return {?}
     */
    ShContextMenuComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.close();
    };
    /**
     * @return {?}
     */
    ShContextMenuComponent.prototype.setNotActive = /**
     * @return {?}
     */
    function () {
        this.subActive = false;
        this.menuItems.forEach(function (i) { return i.setNotActive(); });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ShContextMenuComponent.prototype.isVisible = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (!item.visible) {
            return true;
        }
        return this.callWithContext(item.visible, this, item.context.$implicit, null);
    };
    ShContextMenuComponent.decorators = [
        { type: Component, args: [{
                    selector: 'sh-context-menu',
                    encapsulation: ViewEncapsulation.None,
                    template: "\n    <ng-container #menuContainer></ng-container>\n    <ng-template #menuTemplate>\n      <div class=\"sh-context-menu\">\n        <div\n          *ngFor=\"let menuItem of menuItems\"\n          #itemElement\n          [ngClass]=\"{'sh-sub-anchor': menuItem.subMenu && menuItem.visible,\n           'sh-context-menu--item__disable': !menuItem.visible,\n           'sh-context-menu--item__divider': menuItem.divider,\n           'sh-context-menu--item__sub-active': subActive && menuItem.active}\"\n          class=\"sh-context-menu--item\"\n          (mouseenter)=\"onEnter($event, menuItem, itemElement)\"\n          (click)=\"onClick($event, menuItem)\">\n          <ng-container *ngIf=\"!menuItem.divider || !isVisible(menuItem)\">\n            <ng-content *ngTemplateOutlet=\"menuItem.template; context: menuItem.context\"></ng-content>\n          </ng-container>\n        </div>\n      </div>\n    </ng-template>\n  ",
                    styles: [".sh-backdrop{background-color:transparent}.sh-context-menu{background:#fff;min-width:150px;border:1px solid rgba(0,0,0,.2);border-radius:3px;box-shadow:0 0 10px 2px rgba(0,0,0,.1);color:#656565;margin:0}.sh-context-menu--item{padding:7px 10px 7px 15px;transition:.15s}.sh-context-menu--item:hover,.sh-context-menu--item__sub-active{background-color:#ededed;cursor:pointer}.sh-context-menu--item.sh-context-menu--item__divider:hover{background-color:#ececec;color:#000;cursor:default}.sh-context-menu--item__divider{height:1px;padding:0;overflow:hidden;border-bottom:1px solid #d0d0d0}.sh-context-menu--item.sh-sub-anchor{position:relative;min-width:140px}.sh-sub-anchor:after{content:\"\";top:50%;right:6px;-webkit-transform:translateY(-50%);transform:translateY(-50%);position:absolute;border-top:4px solid transparent;border-bottom:4px solid transparent;border-left:5px solid #000}.sh-context-menu--item__disable{color:#a6a2a2}"]
                }] }
    ];
    /** @nocollapse */
    ShContextMenuComponent.ctorParameters = function () { return [
        { type: ShContextMenuService }
    ]; };
    ShContextMenuComponent.propDecorators = {
        thisContext: [{ type: Input, args: ['this',] }],
        contentChildrenItems: [{ type: ContentChildren, args: [ShContextMenuItemDirective, { read: ShContextMenuItemDirective },] }],
        viewChildrenItems: [{ type: ViewChildren, args: [ShContextMenuItemDirective, { read: ShContextMenuItemDirective },] }],
        menuTemplate: [{ type: ViewChild, args: ['menuTemplate', { read: TemplateRef },] }],
        menuContainer: [{ type: ViewChild, args: ['menuContainer', { read: ViewContainerRef },] }]
    };
    return ShContextMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShAttachMenuDirective = /** @class */ (function () {
    function ShAttachMenuDirective(ctxService, elm) {
        this.ctxService = ctxService;
        this.elm = elm;
    }
    /**
     * @return {?}
     */
    ShAttachMenuDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setupEvents();
    };
    /**
     * @private
     * @return {?}
     */
    ShAttachMenuDirective.prototype.setupEvents = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var observables = [];
        if (!this.triggers) {
            observables.push(fromEvent(this.elm.nativeElement, 'contextmenu'));
        }
        else {
            this.triggers.forEach(function (t) {
                observables.push(fromEvent(_this.elm.nativeElement, t));
            });
        }
        this.sub = merge.apply(void 0, __spread(observables)).subscribe(this.openMenu.bind(this));
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ShAttachMenuDirective.prototype.openMenu = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.ctxService.openMenu({
            menu: this.menu,
            mouseEvent: event,
            targetElement: this.elm,
            data: this.data
        });
    };
    /**
     * @return {?}
     */
    ShAttachMenuDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.sub.unsubscribe();
    };
    ShAttachMenuDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[shAttachMenu]'
                },] }
    ];
    /** @nocollapse */
    ShAttachMenuDirective.ctorParameters = function () { return [
        { type: ShContextMenuService },
        { type: ElementRef }
    ]; };
    ShAttachMenuDirective.propDecorators = {
        menu: [{ type: Input, args: ['shAttachMenu',] }],
        triggers: [{ type: Input, args: ['shMenuTriggers',] }],
        data: [{ type: Input, args: ['shMenuData',] }]
    };
    return ShAttachMenuDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShContextMenuModule = /** @class */ (function () {
    function ShContextMenuModule() {
    }
    ShContextMenuModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ShAttachMenuDirective,
                        ShContextMenuComponent,
                        ShContextMenuItemDirective
                    ],
                    exports: [
                        ShAttachMenuDirective,
                        ShContextMenuComponent,
                        ShContextMenuItemDirective
                    ],
                    providers: [
                        ShContextMenuService
                    ],
                    imports: [
                        CommonModule,
                        OverlayModule
                    ],
                    entryComponents: [
                        ShContextMenuComponent
                    ]
                },] }
    ];
    return ShContextMenuModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WizardComponent = /** @class */ (function () {
    function WizardComponent(viewContainerRef, componentFactoryResolver) {
        this.viewContainerRef = viewContainerRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.clickCancelBtn = new EventEmitter();
        this.clickFinishBtn = new EventEmitter();
        this.title = '';
        this.steps = [];
        this.curStepIndex = 0;
    }
    /**
     * @return {?}
     */
    WizardComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.steps && this.steps.length > 0) {
            this.curStep = this.steps[this.curStepIndex];
            this.createStepComponent(this.steps[this.curStepIndex]);
        }
    };
    /**
     * @param {?} step
     * @return {?}
     */
    WizardComponent.prototype.createStepComponent = /**
     * @param {?} step
     * @return {?}
     */
    function (step) {
        var _this = this;
        this.stepContainer.clear();
        /** @type {?} */
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(step.component);
        this.curComponentRef = this.stepContainer.createComponent(componentFactory);
        this.curComponentRef.instance.data = step.data;
        // 新增步骤
        if (this.curComponentRef.instance.addStep) {
            this.curComponentRef.instance.addStep.subscribe(function (stepList) {
                var _a;
                /** @type {?} */
                var curIndex = findIndex(_this.steps, _this.curStep);
                (_a = _this.steps).splice.apply(_a, __spread([curIndex + 1, 0], stepList));
                _this.curStep.nextStep = stepList[0].stepId;
                _this.curStep.showFinishBtn = false;
                _this.curStep.showNextStepBtn = true;
            });
        }
        // 删除步骤
        if (this.curComponentRef.instance.removeStep) {
            this.curComponentRef.instance.removeStep.subscribe(function (data) {
                merge$1(_this.curStep, data.curStep);
                data.removeSteps.forEach(function (removeStep) {
                    /** @type {?} */
                    var index = findIndex(_this.steps, removeStep);
                    _this.steps.splice(index, 1);
                });
            });
        }
        // 变更步骤
        if (this.curComponentRef.instance.changeStep) {
            this.curComponentRef.instance.changeStep.subscribe(function (stepList) {
                stepList.forEach(function (changeStep) {
                    /** @type {?} */
                    var oldStep = find(_this.steps, function (s) { return s.stepId === changeStep.stepId; });
                    merge$1(oldStep, changeStep);
                });
            });
        }
    };
    /**
     * @param {?} nextStep
     * @return {?}
     */
    WizardComponent.prototype.jumpStep = /**
     * @param {?} nextStep
     * @return {?}
     */
    function (nextStep) {
        // 判断跳转方向
        if (nextStep === this.curStep) {
            return;
        }
        /** @type {?} */
        var nextIndex = findIndex(this.steps, function (s) { return s.stepId === nextStep.stepId; });
        if (nextIndex === this.curStepIndex) {
            return;
        }
        if (nextIndex < this.curStepIndex) { // 向前跳
            this.curStep = nextStep;
            this.curStepIndex = nextIndex;
            this.createStepComponent(nextStep);
            return;
        }
        if (nextStep.stepId === this.curStep.nextStep) { // 下一步
            this.nextStep();
            return;
        }
        //  else if (this.finishedSteps.indexOf(nextStep.stepId) > -1) { // 已完成的后续步骤
        //   this.curStep = nextStep;
        //   this.curStepIndex = nextIndex;
        //   this.createStepComponent(nextStep);
        // }
    };
    /**
      * 点击上一步
      */
    /**
     * 点击上一步
     * @return {?}
     */
    WizardComponent.prototype.lastStep = /**
     * 点击上一步
     * @return {?}
     */
    function () {
        /** @type {?} */
        var self = this;
        this.curStepIndex = findIndex(this.steps, function (s) { return s.nextStep === self.curStep.stepId; });
        this.curStep = this.steps[this.curStepIndex];
        this.createStepComponent(this.curStep);
    };
    /**
     * 点击下一步
     */
    /**
     * 点击下一步
     * @return {?}
     */
    WizardComponent.prototype.nextStep = /**
     * 点击下一步
     * @return {?}
     */
    function () {
        var _this = this;
        // 校验
        /** @type {?} */
        var validationFunc = this.curComponentRef.instance.validation;
        if (validationFunc && typeof (validationFunc) === 'function') {
            /** @type {?} */
            var result = validationFunc();
            if (!result) {
                return;
            }
        }
        // 执行各Component定义的nextStepClick事件
        /** @type {?} */
        var clickNextStep = this.curComponentRef.instance.clickNextStep;
        if (clickNextStep && typeof (clickNextStep) === 'function') {
            /** @type {?} */
            var result = clickNextStep();
            if (typeof (result) === 'boolean') {
                this.moveToNextStep(result);
            }
            else {
                result.subscribe(function (data) {
                    _this.moveToNextStep(data);
                });
            }
        }
        else {
            this.moveToNextStep(true);
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    WizardComponent.prototype.moveToNextStep = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!data) {
            return;
        }
        /** @type {?} */
        var curStep = this.curStep;
        if (curStep.nextStep === '') {
            return;
        }
        // this.finishedSteps.push(curStep.stepId);
        this.curStepIndex = findIndex(this.steps, function (s) { return s.stepId === curStep.nextStep; });
        if (this.curStepIndex > -1) {
            this.curStep = this.steps[this.curStepIndex];
            this.createStepComponent(this.curStep);
        }
    };
    /**
     * 取消
     */
    /**
     * 取消
     * @return {?}
     */
    WizardComponent.prototype.clickCancel = /**
     * 取消
     * @return {?}
     */
    function () {
        this.clickCancelBtn.emit();
    };
    /**
     * 完成
     */
    /**
     * 完成
     * @return {?}
     */
    WizardComponent.prototype.finishWizard = /**
     * 完成
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validationFunc = this.curComponentRef.instance.validation;
        if (validationFunc && typeof (validationFunc) === 'function') {
            /** @type {?} */
            var result = validationFunc();
            if (!result) {
                return;
            }
        }
        /** @type {?} */
        var beforeFinish = this.curComponentRef.instance.beforeFinish;
        if (beforeFinish && typeof (beforeFinish) === 'function') {
            /** @type {?} */
            var result = beforeFinish();
            if (!result) {
                return;
            }
        }
        this.clickFinishBtn.emit();
    };
    WizardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'app-wizard',
                    template: "<div class=\"stepWizard\">\r\n  <div class=\"createNav d-flex flex-wrap\" *ngIf=\"steps.length>1\">\r\n    <div *ngFor=\"let step of steps\" class=\"d-flex step\" [class.active]=\"curStep.stepId===step.stepId\">\r\n      <div class=\"d-flex\" *ngIf=\"step.show\" (click)=\"jumpStep(step)\">\r\n        <div class=\"stepTitle\">{{step.title}}</div>\r\n        <div class=\"triangle_border_right\">\r\n          <span></span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"content\">\r\n    <perfect-scrollbar [config]=\"{suppressScrollX: true}\">\r\n      <ng-container #stepContainer></ng-container>\r\n    </perfect-scrollbar>\r\n  </div>\r\n\r\n\r\n\r\n  <div class=\"footBtns\">\r\n    <button type=\"button\" class=\"btn btn-outline-secondary btn-sm px-3 mx-2\" *ngIf=\"curStep.showCancelBtn\" (click)=\"clickCancel()\">\u53D6\u6D88</button>\r\n    <button type=\"button\" class=\"btn btn-outline-primary btn-sm px-3 mx-2\" *ngIf=\"curStep.showLastStepBtn\" (click)=\"lastStep()\"\r\n      type=\"submit\">\u4E0A\u4E00\u6B65</button>\r\n    <button type=\"button\" class=\"btn btn-outline-primary btn-sm px-3 mx-2\" *ngIf=\"curStep.showNextStepBtn\" (click)=\"nextStep()\"\r\n      type=\"submit\">\u4E0B\u4E00\u6B65</button>\r\n    <button type=\"button\" class=\"btn btn-outline-primary btn-sm px-3 mx-2\" *ngIf=\"curStep.showFinishBtn\" (click)=\"finishWizard()\">\u5B8C\u6210</button>\r\n  </div>\r\n</div>",
                    styles: [":host{position:absolute;top:0;bottom:0;left:0;right:0}.stepWizard{height:100%;display:flex;flex-direction:column}.stepWizard .createNav{background:#e8edf2;height:40px;overflow:hidden}.stepWizard .createNav .stepTitle{padding:0 10px;color:#666;line-height:40px;cursor:pointer;font-size:.875rem}.stepWizard .createNav .step.active .stepTitle{color:#fff;background-color:#346180!important}.stepWizard .createNav .step:not(:first-child).active .stepTitle{margin-left:-17px;padding-left:25px}.stepWizard .createNav .stepTitle.disable{color:#cdcdcf}.stepWizard .createNav .step .triangle_border_right{width:0;height:0;border-width:20px 0 20px 18px;border-style:solid;border-color:transparent transparent transparent #ccc;position:relative}.stepWizard .createNav .step .triangle_border_right span{display:block;width:0;height:0;border-width:20px 0 20px 18px;border-style:solid;border-color:transparent transparent transparent #e8edf2;position:absolute;top:-20px;left:-20px}.stepWizard .createNav .step.active .triangle_border_right{width:0;height:0;border-width:20px 0 20px 20px;border-color:transparent transparent transparent #e8edf2}.stepWizard .createNav .step.active .triangle_border_right span{border-width:20px 0 20px 20px;border-color:transparent transparent transparent #346180!important}.stepWizard .content{flex:1;overflow:auto;font-size:.875rem}.stepWizard .content .ps-content{width:inherit;height:inherit}.stepWizard .footBtns{width:100%;display:flex;align-items:center;justify-content:flex-end;padding:10px 1rem;background:#f4f4f4;border-top:1px solid #ddd}"]
                }] }
    ];
    /** @nocollapse */
    WizardComponent.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver }
    ]; };
    WizardComponent.propDecorators = {
        clickCancelBtn: [{ type: Output }],
        clickFinishBtn: [{ type: Output }],
        title: [{ type: Input }],
        steps: [{ type: Input }],
        stepContainer: [{ type: ViewChild, args: ['stepContainer', { read: ViewContainerRef },] }]
    };
    return WizardComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var WizardModule = /** @class */ (function () {
    function WizardModule() {
    }
    WizardModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        WizardComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        PerfectScrollbarModule
                    ],
                    exports: [WizardComponent]
                },] }
    ];
    /** @nocollapse */
    WizardModule.ctorParameters = function () { return []; };
    return WizardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ComboService = /** @class */ (function () {
    function ComboService() {
        this.innerData = [];
        this.selected$ = new Subject();
        this.isOpen$ = new BehaviorSubject(false);
        this.data$ = new BehaviorSubject('');
        // initData() {
        //     // this.loadDataTable(this.data || []);
        //     // switch (this.displayType) {
        //     //     case 'TreeList': {
        //     //         this.getData().subscribe(data => this.loadDataTree(data));
        //     //         break;
        //     //     }
        //     //     case 'LIST': {
        //     //         // List
        //     //         this.getData().subscribe(data => this.loadDataTable(data));
        //     //         break;
        //     //     }
        //     //     // case 'LOOKUPLIST': {
        //     //     //     // List
        //     //     //     this.getData().subscribe(data =>
        //     //     //         this.loadLookUpDataTable(data)
        //     //     //     );
        //     //     //     break;
        //     //     // }
        //     //     // case 'LOOKUPTREELIST': {
        //     //     //     // List
        //     //     //     this.getData().subscribe(data => this.loadLookUpDataTree(data));
        //     //     //     break;
        //     //     // }
        //     // }
        // }
        // getData(): Observable<any> {
        //     // if (this.uri) {
        //     //     const params = {};
        //     //     this.showLoading();
        //     //     if (this.comboHttp) {
        //     //         return this.comboHttp.getData(this.uri);
        //     //     } else {
        //     //         return this.http.get(this.uri);
        //     //     }
        //     // } else {
        //         if (this.data) {
        //             return of(this.data);
        //         } else {
        //             return of([]);
        //         }
        //     // }
        // }
        // loadDataTable(data: any) {
        //     if (data instanceof Array) {
        //         this.data = data;
        //     } else {
        //         this.data = data.returnValue;
        //     }
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         // tslint:disable-next-line:triple-equals
        //         return dataArr.find(d => d[this.idField] + '' == val);
        //     });
        //     // this.closeLoading();
        // }
        // loadDataTree(data: any) {
        //     if (data instanceof Array) {
        //         this.data = data;
        //     } else {
        //         this.data = data.returnValue;
        //     }
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         return eachData(dataArr, val, this.idField);
        //         function eachData(paramData, paramVal, idField) {
        //             let rtnData: any = '';
        //             paramData.find(d => {
        //                 // tslint:disable-next-line:triple-equals
        //                 if (d.data[idField] == paramVal) {
        //                     rtnData = d.data;
        //                     return true;
        //                 } else if (d.children && d.children.length) {
        //                     rtnData = eachData(d.children, paramVal, idField);
        //                 } else {
        //                     return false;
        //                 }
        //             });
        //             return rtnData;
        //         }
        //     });
        //     // this.closeLoading();
        // }
        // loadLookUpDataTable(resData: any) {
        //     if (resData.returnValue) {
        //         resData = resData.returnValue;
        //     }
        //     this.columns = resData.columns;
        //     this.pageInfo = resData.pageInfo;
        //     this.data = resData.items;
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         // tslint:disable-next-line: triple-equals
        //         return dataArr.find(d => d[this.idField] + '' == val);
        //     });
        //     this.closeLoading();
        // }
        // loadLookUpDataTree(resData: any) {
        //     if (resData.returnValue) {
        //         resData = resData.returnValue;
        //     }
        //     this.columns = resData.columns;
        //     const treeInfo = resData.treeInfo;
        //     // tslint:disable-next-line: no-string-literal
        //     if (!treeInfo['treeDataIsInit']) {
        //         if (treeInfo.layerType.toLowerCase() === 'pathcode') {
        //             this.data = this.lookupUtils.makeTree(resData.items, treeInfo);
        //         } else {
        //             this.data = this.lookupUtils.makeTreeWithParentID(
        //                 resData.items,
        //                 '',
        //                 `${treeInfo.dataField}.${treeInfo.parentField}`,
        //                 this.idField
        //             );
        //         }
        //     }
        //     this.loadData(this.data, this.selectedValues, (dataArr, val) => {
        //         return eachData(dataArr, val, this.idField);
        //         function eachData(paramData, paramVal, idField) {
        //             let rtnData: any = '';
        //             paramData.find(d => {
        //                 // tslint:disable-next-line:triple-equals
        //                 if (d.data[idField] == paramVal) {
        //                     rtnData = d.data;
        //                     return true;
        //                 } else if (d.children && d.children.length) {
        //                     rtnData = eachData(d.children, paramVal, idField);
        //                 } else {
        //                     return false;
        //                 }
        //             });
        //             return rtnData;
        //         }
        //     });
        //     this.closeLoading();
        // }
        // private showLoading() {
        //     this.loading = this.loadingService.show();
        // }
        // closeLoading() {
        //     if (this.loading) {
        //         this.loading.close();
        //         this.loading = null;
        //     }
        // }
    }
    Object.defineProperty(ComboService.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this.innerData;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.innerData = val;
            this.data$.next(val);
        },
        enumerable: true,
        configurable: true
    });
    // columns: any;
    // injectService() {
    //     if (this.injector && !this.comboHttp) {
    //         this.lookupUtils = this.injector.get(LookupUtils, null);
    //         if (this.displayType.indexOf('LOOKUP') > -1) {
    //             this.comboHttp = this.injector.get(ServerSideToken, null);
    //         } else {
    //             this.comboHttp = this.injector.get(ComboServerSideToken, null);
    //         }
    //     }
    // }
    // columns: any;
    // injectService() {
    //     if (this.injector && !this.comboHttp) {
    //         this.lookupUtils = this.injector.get(LookupUtils, null);
    //         if (this.displayType.indexOf('LOOKUP') > -1) {
    //             this.comboHttp = this.injector.get(ServerSideToken, null);
    //         } else {
    //             this.comboHttp = this.injector.get(ComboServerSideToken, null);
    //         }
    //     }
    // }
    /**
     * @param {?} value
     * @return {?}
     */
    ComboService.prototype.toBoolean = 
    // columns: any;
    // injectService() {
    //     if (this.injector && !this.comboHttp) {
    //         this.lookupUtils = this.injector.get(LookupUtils, null);
    //         if (this.displayType.indexOf('LOOKUP') > -1) {
    //             this.comboHttp = this.injector.get(ServerSideToken, null);
    //         } else {
    //             this.comboHttp = this.injector.get(ComboServerSideToken, null);
    //         }
    //     }
    // }
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value != null && "" + value !== 'false';
    };
    /**
     * @param {?} data
     * @param {?=} index
     * @return {?}
     */
    ComboService.prototype.selectItem = /**
     * @param {?} data
     * @param {?=} index
     * @return {?}
     */
    function (data, index) {
        this.isOpen$.next(false);
        this.selectedValue = data;
        this.selected$.next(this.selectedValue);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    ComboService.prototype.unSelectItem = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.selectedValue = null;
        this.selected$.next(null);
    };
    /**
     * @param {?} id
     * @return {?}
     */
    ComboService.prototype.isSelect = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return false;
    };
    // loadData(data: any, selectValues: string = '', callback) {
    //     if (data) {
    //         if (selectValues) {
    //             if (selectValues.split) {
    //                 // key 是字符串，可能是拼起来的
    //                 const selectedItems = selectValues.split(',').map(val => {
    //                     return callback(data, val);
    //                 });
    //
    //                 this.selections = selectedItems;
    //             } else {
    //                 // key不可split
    //                 this.selections = [selectValues];
    //             }
    //         } else {
    //             this.selections = [];
    //         }
    //         // this.selections$.next(this.selections);
    //         // const _data = this.initData(data);
    //         // this.updateState({...this._state, data: _data});
    //     } else {
    //         // this.updateState({ data: [], selections: [] });
    //     }
    // }
    // filterData(val: string, filed: any = 'text') {
    //     if (val) {
    //         const data = this.data
    //             ? this.data.filter(item => {
    //                 if (item[filed]) {
    //                     return String(item[filed]).indexOf(val) > -1;
    //                 } else if (item.data && item.data[filed]) {
    //                     return String(item.data[filed]).indexOf(val) > -1;
    //                 }
    //               })
    //             : [];
    //         this.data$.next(data);
    //     }
    // }
    // loadData(data: any, selectValues: string = '', callback) {
    //     if (data) {
    //         if (selectValues) {
    //             if (selectValues.split) {
    //                 // key 是字符串，可能是拼起来的
    //                 const selectedItems = selectValues.split(',').map(val => {
    //                     return callback(data, val);
    //                 });
    //
    //                 this.selections = selectedItems;
    //             } else {
    //                 // key不可split
    //                 this.selections = [selectValues];
    //             }
    //         } else {
    //             this.selections = [];
    //         }
    //         // this.selections$.next(this.selections);
    //         // const _data = this.initData(data);
    //         // this.updateState({...this._state, data: _data});
    //     } else {
    //         // this.updateState({ data: [], selections: [] });
    //     }
    // }
    // filterData(val: string, filed: any = 'text') {
    //     if (val) {
    //         const data = this.data
    //             ? this.data.filter(item => {
    //                 if (item[filed]) {
    //                     return String(item[filed]).indexOf(val) > -1;
    //                 } else if (item.data && item.data[filed]) {
    //                     return String(item.data[filed]).indexOf(val) > -1;
    //                 }
    //               })
    //             : [];
    //         this.data$.next(data);
    //     }
    // }
    /**
     * @return {?}
     */
    ComboService.prototype.getSelected = 
    // loadData(data: any, selectValues: string = '', callback) {
    //     if (data) {
    //         if (selectValues) {
    //             if (selectValues.split) {
    //                 // key 是字符串，可能是拼起来的
    //                 const selectedItems = selectValues.split(',').map(val => {
    //                     return callback(data, val);
    //                 });
    //
    //                 this.selections = selectedItems;
    //             } else {
    //                 // key不可split
    //                 this.selections = [selectValues];
    //             }
    //         } else {
    //             this.selections = [];
    //         }
    //         // this.selections$.next(this.selections);
    //         // const _data = this.initData(data);
    //         // this.updateState({...this._state, data: _data});
    //     } else {
    //         // this.updateState({ data: [], selections: [] });
    //     }
    // }
    // filterData(val: string, filed: any = 'text') {
    //     if (val) {
    //         const data = this.data
    //             ? this.data.filter(item => {
    //                 if (item[filed]) {
    //                     return String(item[filed]).indexOf(val) > -1;
    //                 } else if (item.data && item.data[filed]) {
    //                     return String(item.data[filed]).indexOf(val) > -1;
    //                 }
    //               })
    //             : [];
    //         this.data$.next(data);
    //     }
    // }
    /**
     * @return {?}
     */
    function () {
        return this.selectedValue;
    };
    // filterSelections(displayText: string) {
    //     if (displayText && this.selections) {
    //         const selections = displayText
    //             .split(',')
    //             .map(val => {
    //                 return this.selections.find(d => d[this.textField] === val);
    //             })
    //             .filter(val => !!val);
    //         this.selectedValues = this.getValue(this.valueField, selections);
    //         this.selections = selections;
    //     }
    // }
    // clearSelections() {
    //     this.selections = [];
    // }
    // filterSelections(displayText: string) {
    //     if (displayText && this.selections) {
    //         const selections = displayText
    //             .split(',')
    //             .map(val => {
    //                 return this.selections.find(d => d[this.textField] === val);
    //             })
    //             .filter(val => !!val);
    //         this.selectedValues = this.getValue(this.valueField, selections);
    //         this.selections = selections;
    //     }
    // }
    // clearSelections() {
    //     this.selections = [];
    // }
    /**
     * @param {?} prop
     * @param {?=} selections
     * @return {?}
     */
    ComboService.prototype.getValue = 
    // filterSelections(displayText: string) {
    //     if (displayText && this.selections) {
    //         const selections = displayText
    //             .split(',')
    //             .map(val => {
    //                 return this.selections.find(d => d[this.textField] === val);
    //             })
    //             .filter(val => !!val);
    //         this.selectedValues = this.getValue(this.valueField, selections);
    //         this.selections = selections;
    //     }
    // }
    // clearSelections() {
    //     this.selections = [];
    // }
    /**
     * @param {?} prop
     * @param {?=} selections
     * @return {?}
     */
    function (prop, selections) {
        // selections = selections ? selections : this.selections;
        // if (selections && selections.length) {
        //     // if (this.mapFields) {
        //     //     const helpFields = Object.keys(this.mapFields);
        //     //     helpFields.forEach( (f: any) => {
        //     //         if (this.mapFields[f] === prop) {
        //     //             prop = f;
        //     //             return;
        //     //         }
        //     //     });
        //     // }
        //
        //     // if (selections.length === 1) {
        //     //     return this.getValueByObj(prop, selections[0]);
        //     // }
        //
        //     const tmp = selections
        //         .map(item => {
        //             return this.getValueByObj(prop, item);
        //         })
        //         .join(',');
        //     return tmp;
        // }
        if (this.selectedValue) {
            return this.getValueByObj(prop, this.selectedValue);
        }
        return '';
    };
    /**
     * @param {?} field
     * @param {?} data
     * @return {?}
     */
    ComboService.prototype.getValueByObj = /**
     * @param {?} field
     * @param {?} data
     * @return {?}
     */
    function (field, data) {
        if (!data) {
            return '';
        }
        /** @type {?} */
        var resultVal = '';
        if (field.indexOf('.') === -1) {
            resultVal = data[field];
        }
        else {
            resultVal = field.split('.').reduce(function (obj, key) {
                if (obj) {
                    return obj[key];
                }
                else {
                    return null;
                }
            }, data);
        }
        return resultVal;
    };
    ComboService.decorators = [
        { type: Injectable }
    ];
    return ComboService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var nextUniqueId = 0;
var ComboListComponent = /** @class */ (function () {
    function ComboListComponent(el, cdr, document, render, comboService, injector) {
        var _this = this;
        this.el = el;
        this.cdr = cdr;
        this.document = document;
        this.render = render;
        this.comboService = comboService;
        this.injector = injector;
        this.disabled = false;
        this.readonly = false;
        this.editable = true;
        this.placeholder = '请选择';
        this.panelWidth = 300;
        this.panelHeight = 300;
        this.autoWidth = true;
        this.enableClear = true;
        this.showPanel = new EventEmitter();
        this.hidePanel = new EventEmitter();
        this.clear = new EventEmitter();
        this.valueChange = new EventEmitter();
        this.selectChange = new EventEmitter();
        // tslint:disable-next-line:variable-name
        this._cmbPanel = null;
        this.isOpen = false;
        this.groupIcon = '<span class="f-icon f-icon-arrow-60-down"></span>';
        this.comboPanelCreated$ = new Subject();
        this.destroy$ = new Subject();
        this.ngControl = null;
        this.displayText = '';
        this.onChange = function () { return null; };
        this.onTouched = function () { return null; };
        /** @type {?} */
        var container = this.creatContainer();
        /** @type {?} */
        var panel = this.creatPanel(container);
        this.comboPanelCreated$
            .pipe(takeUntil(this.destroy$), filter(function (v) { return !!v; }))
            .subscribe(function (cmp) {
            panel.appendChild(cmp.nativeElement);
            _this.updatePosition();
        });
        this.destroy$.subscribe(function () {
            // this.render.removeChild('body', container);
            if (document.body.contains(container) && container.contains(panel)) {
                container.removeChild(panel);
            }
            nextUniqueId = 0;
        });
        this.comboService.isOpen$
            .pipe(takeUntil(this.destroy$), skip(1))
            .subscribe(function (val) {
            if (val) {
                _this.documentClickEvent = _this.render.listen('document', 'click', function (event) {
                    if (!_this.el.nativeElement.contains(event.target) &&
                        (_this._cmbPanel && !_this.contains(_this._cmbPanel, event))) {
                        _this.isOpen = false;
                        _this.removeDocumentListener();
                        _this.cdr.markForCheck();
                    }
                });
            }
            else {
                _this.removeDocumentListener();
            }
            _this.isOpen = !!val;
            _this.cdr.markForCheck();
        });
        this.comboService.selected$.pipe(takeUntil(this.destroy$)).subscribe(function () {
            _this.displayText = _this.comboService.getValue(_this.textField);
            _this.value = _this.comboService.getValue(_this.idField);
            if (_this.data && _this.data.length > 0) {
                _this.onChange(_this.value);
                _this.valueChange.emit(_this.value);
            }
            else {
                _this.updateMappingFieldValue();
                _this.onChange(_this.displayText);
                _this.valueChange.emit(_this.displayText);
            }
            _this.cdr.detectChanges();
            // this.focus();
            // this.blur();
        });
    }
    Object.defineProperty(ComboListComponent.prototype, "idField", {
        get: /**
         * @return {?}
         */
        function () {
            return this.comboService.idField;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.comboService.idField = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboListComponent.prototype, "valueField", {
        get: /**
         * @return {?}
         */
        function () {
            return this.comboService.valueField;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.comboService.valueField = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboListComponent.prototype, "textField", {
        get: /**
         * @return {?}
         */
        function () {
            return this.comboService.textField;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.comboService.textField = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComboListComponent.prototype, "cmbPanel", {
        set: /**
         * @param {?} cmp
         * @return {?}
         */
        function (cmp) {
            this._cmbPanel = cmp;
            this.comboPanelCreated$.next(cmp);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ComboListComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.comboService.isOpen$.next(!this.isOpen);
    };
    /**
     * @private
     * @return {?}
     */
    ComboListComponent.prototype.removeDocumentListener = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.documentClickEvent) {
            this.documentClickEvent();
            this.documentClickEvent = null;
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ComboListComponent.prototype.onBlur = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.onTouched();
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.blur = /**
     * @return {?}
     */
    function () {
        this.input.textbox.nativeElement.blur();
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.focus = /**
     * @return {?}
     */
    function () {
        this.input.textbox.nativeElement.focus();
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.onClear = /**
     * @return {?}
     */
    function () {
        this.value = '';
        this.comboService.selectedValue = null;
        this.comboService.isOpen$.next(false);
        this.comboService.selected$.next([]);
        // this.updateMappingFieldValue();
        // this.onChange('');
        // this.onTouched();
        this.clear.emit();
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.updateMappingFieldValue = /**
     * @return {?}
     */
    function () {
        if (this.ngControl &&
            this.ngControl.formDirective &&
            this.ngControl.formDirective.form &&
            this.ngControl.formDirective.form.bindingData) {
            /** @type {?} */
            var bindingData = this.ngControl.formDirective.form.bindingData;
            /** @type {?} */
            var bindingPath = this.ngControl.formDirective.form.bindingPath;
            /** @type {?} */
            var pathArr = [];
            if (bindingPath) {
                pathArr = bindingPath.split('/').filter(function (n) { return n !== ''; });
            }
            this.mappingField = this.mappingField ? this.mappingField : '';
            bindingData.setValue(pathArr.concat(this.mappingField.split('.')), this.value, true, true);
        }
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.updateSelectedValues = /**
     * @return {?}
     */
    function () {
        if (this.ngControl &&
            this.ngControl.formDirective &&
            this.ngControl.formDirective.form &&
            this.ngControl.formDirective.form.bindingData) {
            /** @type {?} */
            var bindingData = this.ngControl.formDirective.form.bindingData;
            /** @type {?} */
            var bindingPath = this.ngControl.formDirective.form.bindingPath;
            /** @type {?} */
            var pathArr = [];
            if (bindingPath) {
                pathArr = bindingPath.split('/').filter(function (n) { return n !== ''; });
            }
            this.mappingField = this.mappingField ? this.mappingField : '';
            this.value = bindingData.getValue(pathArr.concat(this.mappingField.split('.')));
        }
    };
    /**
     * @param {?} val
     * @return {?}
     */
    ComboListComponent.prototype.onValueChange = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.value = val;
        this.onChange(val);
        this.valueChange.emit(val);
        // if (!this.multiSelect) {
        //     this.comboService.serachValue$.next(val);
        // }
        // this.comboService.filterSelections(val);
        // this.valueChange.emit(val);
        // if (!this.uri && this.data && this.data.length > 0) {
        //     this.onChange(this.selectedValues);
        // } else {
        //     this.onChange(this.displayText);
        // }
        // this.updateMappingFieldValue();
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.updatePosition = /**
     * @return {?}
     */
    function () {
        if (this.autoWidth) {
            var width = this.input.el.nativeElement.getBoundingClientRect().width;
            this.panelWidth = width ? width : this.panelWidth;
        }
        var _a = this.el.nativeElement.getBoundingClientRect(), left = _a.left, top = _a.top;
        if (top + this.panelHeight > window.innerHeight && top - this.panelHeight > 0) {
            top = top - this.panelHeight - 27;
        }
        return {
            left: left + 'px',
            top: top + 27 + 'px',
            width: this.panelWidth + 'px',
            height: this.panelHeight + 'px'
        };
    };
    /**
     * @param {?} el
     * @param {?} event
     * @return {?}
     */
    ComboListComponent.prototype.contains = /**
     * @param {?} el
     * @param {?} event
     * @return {?}
     */
    function (el, event) {
        return el.nativeElement.contains(event.target);
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.creatContainer = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var container = this.document.querySelector('.overlay-container');
        if (!container) {
            container = this.document.createElement('div');
            container.classList.add('overlay-container');
        }
        this.document.body.appendChild(container);
        return container;
    };
    /**
     * @param {?} host
     * @return {?}
     */
    ComboListComponent.prototype.creatPanel = /**
     * @param {?} host
     * @return {?}
     */
    function (host) {
        /** @type {?} */
        var pane = this.document.createElement('div');
        pane.id = "overlay-" + nextUniqueId++;
        pane.classList.add('overlay-pane');
        host.appendChild(pane);
        return pane;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ComboListComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.displayText = value;
        this.cdr.markForCheck();
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ComboListComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ComboListComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    ComboListComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // tslint:disable-next-line: deprecation
        this.ngControl = this.injector.get(NgControl, null);
        if (!this.valueField && this.idField) {
            this.valueField = this.idField;
        }
        fromEvent$1(window, 'resize')
            .pipe(debounceTime(100), throttle(function (ev) { return interval(100); }), takeUntil(this.destroy$))
            .subscribe(function () {
            var width = _this.input.el.nativeElement.getBoundingClientRect().width;
            _this.panelWidth = width;
            _this.comboService.isOpen$.next(false);
        });
        // this.comboService.injectService();
    };
    /**
     * @return {?}
     */
    ComboListComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy$.next();
        this.destroy$.complete();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ComboListComponent.prototype.onSelect = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _a = __assign({}, value), data = _a.data, index = _a.index;
        this.comboService.selectItem(data, index);
        this.selectChange.emit({ data: data, index: index });
        this.focus();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ComboListComponent.prototype.onUnSelected = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var data = __assign({}, value).data;
        this.comboService.unSelectItem(data);
        // console.log(data);
        this.focus();
    };
    ComboListComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'farris-editable-combo-list',
                    template: "<input-group\r\n    #input\r\n    [class.actived]=\"isOpen\"\r\n    [(value)]=\"displayText\"\r\n    [disabled]=\"disabled\"\r\n    [readonly]=\"readonly\"\r\n    [editable]=\"editable\"\r\n    [groupText]=\"groupIcon\"\r\n    [placeholder]=\"placeholder\"\r\n    [enableClear] = \"false\"\r\n    (clickHandle)=\"onClick()\"\r\n    (blurHandle)=\"onBlur($event)\"\r\n    (valueChange)=\"onValueChange($event)\"\r\n    (clear)=\"onClear()\"\r\n    style=\"display: block;\"\r\n>\r\n</input-group>\r\n<div class=\"comboPanel\" *ngIf=\"isOpen\" [ngStyle]=\"updatePosition()\" #comboPanel>\r\n    <farris-datalist\r\n        #dl\r\n        [data]=\"data\"\r\n        [idField]=\"idField\"\r\n        [valueField]=\"valueField\"\r\n        [textField]=\"textField\"\r\n        (selected)=\"onSelect($event)\"\r\n        (unSelected)=\"onUnSelected($event)\"\r\n    >\r\n<!--        <ng-template list-item-tmp let-item=\"data.data\" let-idx=\"index\" *ngIf=\"itemTemplate\">-->\r\n<!--            <ng-container *ngTemplateOutlet=\"itemTemplate; context: { $implicit: item, index: idx }\"> </ng-container>-->\r\n<!--        </ng-template>-->\r\n    </farris-datalist>\r\n</div>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return ComboListComponent; }),
                            multi: true
                        },
                        ComboService
                    ],
                    styles: [".overlay-container{position:fixed;z-index:9999;pointer-events:none;top:0;left:0;height:100%;width:100%}.overlay-pane{position:absolute;pointer-events:auto}.overlay-pane .comboPanel{position:absolute;overflow:auto;background:#fff;z-index:9;margin-top:-1px;box-shadow:0 2px 8px 0 rgba(0,0,0,.15);border-radius:2px}.overlay-pane .comboPanel combo2-list{position:absolute;width:100%;height:100%}"]
                }] }
    ];
    /** @nocollapse */
    ComboListComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Renderer2 },
        { type: ComboService },
        { type: Injector }
    ]; };
    ComboListComponent.propDecorators = {
        disabled: [{ type: Input }],
        readonly: [{ type: Input }],
        editable: [{ type: Input }],
        placeholder: [{ type: Input }],
        panelWidth: [{ type: Input }],
        panelHeight: [{ type: Input }],
        autoWidth: [{ type: Input }],
        enableClear: [{ type: Input }],
        mappingField: [{ type: Input }],
        data: [{ type: Input }],
        idField: [{ type: Input }],
        valueField: [{ type: Input }],
        textField: [{ type: Input }],
        showPanel: [{ type: Output }],
        hidePanel: [{ type: Output }],
        clear: [{ type: Output }],
        valueChange: [{ type: Output }],
        selectChange: [{ type: Output }],
        cmbPanel: [{ type: ViewChild, args: ['comboPanel',] }],
        input: [{ type: ViewChild, args: ['input',] }]
    };
    return ComboListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ComboListModule$1 = /** @class */ (function () {
    function ComboListModule$$1() {
    }
    ComboListModule$$1.decorators = [
        { type: NgModule, args: [{
                    declarations: [ComboListComponent],
                    imports: [CommonModule, FormsModule, InputGroupModule, DatalistModule],
                    exports: [ComboListComponent]
                },] }
    ];
    return ComboListModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the Popover directive.
 * You can inject this service, typically in your root component, and customize
 * the values of its properties in order to provide default values for all the
 * popovers used in the application.
 */
var PopoverConfig = /** @class */ (function () {
    function PopoverConfig() {
        /**
         * Placement of a popover. Accepts: "top", "bottom", "left", "right", "auto"
         */
        this.placement = 'top';
        /**
         * Specifies events that should trigger. Supports a space separated list of
         * event names.
         */
        this.triggers = 'click';
        this.outsideClick = false;
    }
    PopoverConfig.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ PopoverConfig.ngInjectableDef = defineInjectable({ factory: function PopoverConfig_Factory() { return new PopoverConfig(); }, token: PopoverConfig, providedIn: "root" });
    return PopoverConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PopoverContainerComponent = /** @class */ (function () {
    function PopoverContainerComponent(config) {
        Object.assign(this, config);
    }
    Object.defineProperty(PopoverContainerComponent.prototype, "isBs3", {
        get: /**
         * @return {?}
         */
        function () {
            return isBs3();
        },
        enumerable: true,
        configurable: true
    });
    PopoverContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'popover-container',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    // tslint:disable-next-line
                    host: {
                        '[class]': '"popover in popover-" + placement + " " + "bs-popover-" + placement + " " + placement + " " + containerClass',
                        '[class.show]': '!isBs3',
                        role: 'tooltip',
                        style: 'display:block;'
                    },
                    template: "<div class=\"popover-arrow arrow\"></div>\r\n<div class=\"popover-title popover-header\" *ngIf=\"title\" style=\"padding: 8px;line-height: 16px;\">{{ title }}</div>\r\n<div class=\"popover-content popover-body\">\r\n  <ng-content></ng-content>\r\n</div>",
                    styles: ["\n    :host.bs-popover-top .arrow, :host.bs-popover-bottom .arrow {\n      left: 50%;\n      margin-left: -8px;\n    }\n    :host.bs-popover-left .arrow, :host.bs-popover-right .arrow {\n      top: 50%;\n      margin-top: -8px;\n    }\n  "]
                }] }
    ];
    /** @nocollapse */
    PopoverContainerComponent.ctorParameters = function () { return [
        { type: PopoverConfig }
    ]; };
    PopoverContainerComponent.propDecorators = {
        placement: [{ type: Input }],
        title: [{ type: Input }]
    };
    return PopoverContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A lightweight, extensible directive for fancy popover creation.
 */
var PopoverDirective = /** @class */ (function () {
    function PopoverDirective(_elementRef, _renderer, _viewContainerRef, _config, cis) {
        /**
         * Close popover on outside click
         */
        this.outsideClick = false;
        /**
         * Css class for popover container
         */
        this.containerClass = '';
        this._isInited = false;
        this._popover = cis
            .createLoader(_elementRef, _viewContainerRef, _renderer)
            .provide({ provide: PopoverConfig, useValue: _config });
        Object.assign(this, _config);
        this.onShown = this._popover.onShown;
        this.onHidden = this._popover.onHidden;
        // fix: no focus on button on Mac OS #1795
        if (typeof window !== 'undefined') {
            _elementRef.nativeElement.addEventListener('click', function () {
                try {
                    _elementRef.nativeElement.focus();
                }
                catch (err) {
                    return;
                }
            });
        }
    }
    Object.defineProperty(PopoverDirective.prototype, "isOpen", {
        /**
         * Returns whether or not the popover is currently being shown
         */
        get: /**
         * Returns whether or not the popover is currently being shown
         * @return {?}
         */
        function () {
            return this._popover.isShown;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.show();
            }
            else {
                this.hide();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    PopoverDirective.prototype.show = /**
     * Opens an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        if (this._popover.isShown || !this.popover) {
            return;
        }
        this._popover
            .attach(PopoverContainerComponent)
            .to(this.container)
            .position({ attachment: this.placement })
            .show({
            content: this.popover,
            context: this.popoverContext,
            placement: this.placement,
            title: this.popoverTitle,
            containerClass: this.containerClass
        });
        this.isOpen = true;
    };
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    PopoverDirective.prototype.hide = /**
     * Closes an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            this._popover.hide();
            this.isOpen = false;
        }
    };
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     */
    /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    PopoverDirective.prototype.toggle = /**
     * Toggles an element’s popover. This is considered a “manual” triggering of
     * the popover.
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            return this.hide();
        }
        this.show();
    };
    /**
     * @return {?}
     */
    PopoverDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // fix: seems there are an issue with `routerLinkActive`
        // which result in duplicated call ngOnInit without call to ngOnDestroy
        // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
        if (this._isInited) {
            return;
        }
        this._isInited = true;
        this._popover.listen({
            triggers: this.triggers,
            outsideClick: this.outsideClick,
            show: function () { return _this.show(); }
        });
    };
    /**
     * @return {?}
     */
    PopoverDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._popover.dispose();
    };
    PopoverDirective.decorators = [
        { type: Directive, args: [{ selector: '[popover]', exportAs: 'bs-popover' },] }
    ];
    /** @nocollapse */
    PopoverDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ViewContainerRef },
        { type: PopoverConfig },
        { type: ComponentLoaderFactory }
    ]; };
    PopoverDirective.propDecorators = {
        popover: [{ type: Input }],
        popoverContext: [{ type: Input }],
        popoverTitle: [{ type: Input }],
        placement: [{ type: Input }],
        outsideClick: [{ type: Input }],
        triggers: [{ type: Input }],
        container: [{ type: Input }],
        containerClass: [{ type: Input }],
        isOpen: [{ type: Input }],
        onShown: [{ type: Output }],
        onHidden: [{ type: Output }]
    };
    return PopoverDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PopoverModule = /** @class */ (function () {
    function PopoverModule() {
    }
    /**
     * @return {?}
     */
    PopoverModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: PopoverModule,
            providers: [PopoverConfig]
        };
    };
    PopoverModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [PopoverDirective, PopoverContainerComponent],
                    exports: [PopoverDirective],
                    // providers: [PopoverConfig, ComponentLoaderFactory, PositioningService],
                    entryComponents: [PopoverContainerComponent]
                },] }
    ];
    return PopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var PropertyType = {
    string: 'string',
    boolean: 'boolean',
    number: 'number',
    select: 'select',
    boolOrExp: 'boolOrExp',
    multiSelect: 'multiSelect',
    date: 'date',
    datetime: 'datetime',
    modal: 'modal',
    cascade: 'cascade',
};
/**
 * 属性分类实体
 */
var  /**
 * 属性分类实体
 */
ElementPropertyConfig = /** @class */ (function () {
    function ElementPropertyConfig() {
        /**
         * 分类是否隐藏，默认false
         */
        this.hide = false;
        /**
         * 是否隐藏分类标题
         */
        this.hideTitle = false;
        /**
         * 是否启用级联特性，默认false
         */
        this.enableCascade = false;
    }
    return ElementPropertyConfig;
}());
/**
 * 属性实体
 */
var  /**
 * 属性实体
 */
PropertyEntity = /** @class */ (function () {
    function PropertyEntity() {
        /**
         * 是否只读，默认false
         */
        this.readonly = false;
        /**
         * 是否可见，默认true
         */
        this.visible = true;
        /**
         * 是否大数字
         */
        this.isBigNumber = false;
        /**
         * 属性改变后是否需要刷新整个面板：用于更改其他分类下的属性
         */
        this.refreshPanelAfterChanged = false;
        /**
         * 下拉多选类型：属性值的类型：string(多值以逗号分隔)/array(多值组装成数组)
         */
        this.multiSelectDataType = 'string';
        /**
         * 级联属性是否默认收起
         */
        this.isExpand = false;
        /**
         * 是否隐藏级联属性的头部
         */
        this.hideCascadeTitle = false;
        /**
         * 模态框属性是否展示清除图标
         */
        this.showClearButton = false;
    }
    /**
     * 打开模态框前的方法，一般用于校验逻辑，返回值中result=true，则进一步打开模态框，result=false则提示message内容，并不再打开模态框。
     */
    /**
     * 打开模态框前的方法，一般用于校验逻辑，返回值中result=true，则进一步打开模态框，result=false则提示message内容，并不再打开模态框。
     * @return {?}
     */
    PropertyEntity.prototype.beforeOpenModal = /**
     * 打开模态框前的方法，一般用于校验逻辑，返回值中result=true，则进一步打开模态框，result=false则提示message内容，并不再打开模态框。
     * @return {?}
     */
    function () {
        return new BeforeOpenModalResult();
    };
    return PropertyEntity;
}());
/**
 * 打开模态框前的方法返回值，result=true，则进一步打开模态框，result=false则提示message内容，并不再打开模态框。
 */
var  /**
 * 打开模态框前的方法返回值，result=true，则进一步打开模态框，result=false则提示message内容，并不再打开模态框。
 */
BeforeOpenModalResult = /** @class */ (function () {
    function BeforeOpenModalResult() {
    }
    return BeforeOpenModalResult;
}());
/**
 * 属性变更集
 */
var  /**
 * 属性变更集
 */
PropertyChangeObject = /** @class */ (function () {
    function PropertyChangeObject() {
    }
    return PropertyChangeObject;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PropertyItemComponent = /** @class */ (function () {
    function PropertyItemComponent(resolver, modalService, injector, notifyServ, el) {
        this.resolver = resolver;
        this.modalService = modalService;
        this.injector = injector;
        this.notifyServ = notifyServ;
        this.el = el;
        this.valueChanged = new EventEmitter();
        this.submitModal = new EventEmitter();
        // 向上触发整体面板刷新
        this.triggerRefreshPanel = new EventEmitter();
        // 下拉框的枚举项
        this.selectOptions = [];
        // 控件类型
        this.itemType = 'string';
        // 数字控件精度
        this.precision = 2;
        // 已废弃
        this.showClearButton = false;
        // 默认值
        this.showDefaultValue = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    PropertyItemComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.refresh();
    };
    /**
     * @return {?}
     */
    PropertyItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // this.refresh();
    };
    /**
     * @return {?}
     */
    PropertyItemComponent.prototype.refresh = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var tmpl;
        // 显示格式
        /** @type {?} */
        var propertyType = this.itemType = this.elementConfig.propertyType;
        switch (propertyType) {
            case 'boolean': {
                this.itemType = 'select';
                this.selectOptions = [{ key: true, value: 'true' }, { key: false, value: 'false' }];
                tmpl = this.selectTmpl;
                break;
            }
            case 'select': {
                this.selectOptions = this.elementConfig.iterator || [];
                tmpl = this.selectTmpl;
                break;
            }
            case 'multiSelect': {
                this.selectOptions = this.elementConfig.iterator || [];
                if (this.elementConfig.multiSelectDataType === 'array') {
                    this.elementValue = this.elementValue ? this.elementValue.toString() : '';
                }
                tmpl = this.multiSelectTmpl;
                break;
            }
            case 'modal': {
                this._convertModalShowValue(this.elementValue);
                tmpl = this.modalTmpl;
                break;
            }
            case 'number': {
                this.precision = this.elementConfig.decimals === undefined ? 2 : this.elementConfig.decimals;
                tmpl = this.numberTmpl;
                break;
            }
            case 'string': {
                if (this.elementConfig.readonly) {
                    this._convertModalShowValue(this.elementValue);
                }
                tmpl = this.stringTmpl;
                break;
            }
            case 'boolOrExp': {
                this.selectOptions = [{ key: true, value: 'true' }, { key: false, value: 'false' }];
                tmpl = this.boolOrExpTmpl;
                break;
            }
            case 'date': {
                tmpl = this.dateTmpl;
                break;
            }
            case 'datetime': {
                tmpl = this.datetimeTmpl;
                break;
            }
        }
        // 默认值
        if (Object.keys(this.elementConfig).indexOf('defaultValue') > -1) {
            if (this.elementValue === undefined || this.elementValue === null) {
                this.elementValue = this.elementConfig.defaultValue;
            }
            this.showDefaultValue = true;
        }
        // 是否显示
        if (Object.keys(this.elementConfig).indexOf('visible') < 0) {
            this.elementConfig.visible = true;
        }
        // 创建模板
        if (tmpl && (this.propItem.length === 0 || this.propertyOldType !== this.itemType)) {
            this.propItem.clear();
            this.propItem.createEmbeddedView(tmpl);
            this.propertyOldType = this.itemType;
        }
    };
    /**
     * 鼠标移入 --已废弃
     */
    /**
     * 鼠标移入 --已废弃
     * @return {?}
     */
    PropertyItemComponent.prototype.onmouseover = /**
     * 鼠标移入 --已废弃
     * @return {?}
     */
    function () {
        if (!this.elementConfig.showClearButton) {
            return;
        }
        if (!this.showClearButton) {
            this.showClearButton = true;
        }
    };
    /**
     * 鼠标离开 --已废弃
     */
    /**
     * 鼠标离开 --已废弃
     * @return {?}
     */
    PropertyItemComponent.prototype.onmouseleave = /**
     * 鼠标离开 --已废弃
     * @return {?}
     */
    function () {
        if (!this.elementConfig.showClearButton) {
            return;
        }
        this.showClearButton = false;
    };
    /**
     * 清除模态框内容
     */
    /**
     * 清除模态框内容
     * @return {?}
     */
    PropertyItemComponent.prototype.modalClear = /**
     * 清除模态框内容
     * @return {?}
     */
    function () {
        // 数据转换
        this._convertModalShowValue(null);
        // 若有清除后事件，先执行方法
        if (Object.keys(this.elementConfig).indexOf('afterClickClearButton') > -1 &&
            typeof (this.elementConfig.afterClickClearButton) === 'function') {
            this.elementConfig.afterClickClearButton(this.elementValue);
        }
        /** @type {?} */
        var changeObject = {
            propertyID: this.elementConfig.propertyID,
            propertyValue: null
        };
        this.submitModal.emit({ changeObject: changeObject, parameters: null });
    };
    /**
     * 变更属性值
     */
    /**
     * 变更属性值
     * @param {?} e
     * @return {?}
     */
    PropertyItemComponent.prototype.changeValue = /**
     * 变更属性值
     * @param {?} e
     * @return {?}
     */
    function (e) {
        /** @type {?} */
        var value = this.elementValue;
        // 文本控件限制输入字符
        if (value && this.elementConfig.propertyType === 'string' && !this.elementConfig.readonly &&
            this.elementConfig.notAllowedChars && this.elementConfig.notAllowedChars.length) {
            this.elementConfig.notAllowedChars.forEach(function (c) {
                if (typeof (c) === 'object') {
                    value = value.replace(c, '');
                }
                else if (typeof (c) === 'string') {
                    value = value.replace(new RegExp(c, 'g'), '');
                }
            });
            this.elementValue = value;
        }
        // 多选控件返回数组格式的数据
        if (this.itemType === 'multiSelect' && this.elementConfig.multiSelectDataType === 'array') {
            value = this.elementValue ? this.elementValue.split(',') : '';
        }
        /** @type {?} */
        var changeObject = {
            propertyID: this.elementConfig.propertyID,
            propertyValue: value
        };
        this.valueChanged.emit({ changeObject: changeObject });
        if (this.elementConfig.refreshPanelAfterChanged) {
            this.triggerRefreshPanel.emit();
        }
    };
    /**
     * farris 日期控件的变更事件
     * @param e e
     */
    /**
     * farris 日期控件的变更事件
     * @param {?} e e
     * @return {?}
     */
    PropertyItemComponent.prototype.changeDateValue = /**
     * farris 日期控件的变更事件
     * @param {?} e e
     * @return {?}
     */
    function (e) {
        /** @type {?} */
        var value = e.formatted;
        /** @type {?} */
        var changeObject = {
            propertyID: this.elementConfig.propertyID,
            propertyValue: value
        };
        this.valueChanged.emit({ changeObject: changeObject });
        if (this.elementConfig.refreshPanelAfterChanged) {
            this.triggerRefreshPanel.emit();
        }
    };
    /**
     * 自定义编辑器使用模态框打开
     */
    /**
     * 自定义编辑器使用模态框打开
     * @return {?}
     */
    PropertyItemComponent.prototype.openModal = /**
     * 自定义编辑器使用模态框打开
     * @return {?}
     */
    function () {
        if (this.elementConfig.readonly) {
            return;
        }
        if (Object.keys(this.elementConfig).indexOf('beforeOpenModal') > -1 && typeof (this.elementConfig.beforeOpenModal) === 'function') {
            /** @type {?} */
            var result = this.elementConfig.beforeOpenModal();
            if (result && !result.result) {
                this.notifyServ.warning((/** @type {?} */ ({
                    title: '系统提示', msg: result.message, timeout: 3000
                })));
                return;
            }
        }
        this.createEditorComponent();
    };
    /**
     * 创建自定义编辑器
     */
    /**
     * 创建自定义编辑器
     * @private
     * @return {?}
     */
    PropertyItemComponent.prototype.createEditorComponent = /**
     * 创建自定义编辑器
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var editor = this.elementConfig.editor;
        if (!editor) {
            return;
        }
        // 创建模态框组件
        /** @type {?} */
        var compFactory = this.resolver.resolveComponentFactory(editor);
        /** @type {?} */
        var compRef = compFactory.create(this.injector);
        compRef.instance.value = this.elementValue;
        if (this.elementConfig.editorParams) { // 编辑器需要的额外参数
            compRef.instance.editorParams = this.elementConfig.editorParams;
        }
        /** @type {?} */
        var modalConfig = compRef.instance.modalConfig;
        if (!modalConfig) {
            modalConfig = {
                title: '属性配置',
                width: 800,
                height: 400,
                showButtons: false
            };
        }
        else if (modalConfig.showButtons) {
            modalConfig.buttons = compRef.instance.modalFooter;
        }
        /** @type {?} */
        var dialog = this.modalService.show(compRef, modalConfig);
        // 监听关闭模态框
        if (compRef.instance.closeModal && compRef.instance.closeModal instanceof EventEmitter) {
            compRef.instance.closeModal.subscribe(function (data) {
                // 数据转换
                if (data) {
                    _this._convertModalShowValue(data);
                    /** @type {?} */
                    var changeObject = {
                        propertyID: _this.elementConfig.propertyID,
                        propertyValue: data
                    };
                    _this.valueChanged.emit({ changeObject: changeObject });
                }
                dialog.close();
            });
        }
        // 弹出框关闭事件，带参数，格式为{ value, parameters }
        if (compRef.instance.submitModal && compRef.instance.submitModal instanceof EventEmitter) {
            compRef.instance.submitModal.subscribe(function (data) {
                if (!data) {
                    dialog.close();
                    return;
                }
                var value = data.value, parameters = data.parameters;
                // 数据转换
                _this._convertModalShowValue(value);
                /** @type {?} */
                var changeObject = {
                    propertyID: _this.elementConfig.propertyID,
                    propertyValue: value
                };
                _this.submitModal.emit({ changeObject: changeObject, parameters: parameters });
                dialog.close();
            });
        }
    };
    /**
     * 模态框场景下将属性值转换为输入框中显示的值
     * @param value
     */
    /**
     * 模态框场景下将属性值转换为输入框中显示的值
     * @private
     * @param {?} value
     * @return {?}
     */
    PropertyItemComponent.prototype._convertModalShowValue = /**
     * 模态框场景下将属性值转换为输入框中显示的值
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.elementConfig.converter) {
            this.elementShowValue = this.elementConfig.converter.convertTo(value);
            return;
        }
        if (value && value instanceof Object) {
            this.elementShowValue = JSON.stringify(value);
            return;
        }
        this.elementShowValue = value;
    };
    PropertyItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'webide-property-item',
                    template: "<div class=\"farris-group-wrap property-item\" [hidden]=\"!elementConfig.visible\">\r\n  <div class=\"form-group farris-form-group\">\r\n    <label class=\"col-form-label\">\r\n      <span class=\"farris-label-text\" [popover]=\"popTemplate\" [popoverTitle]=\"elementConfig.propertyName\"\r\n        container=\"body\" placement=\"left\" triggers=\"hover\">{{elementConfig.propertyName}}</span>\r\n    </label>\r\n    <!-- <label class=\"col-form-label\">\r\n      <span class=\"farris-label-text\" farrisPopover [popover]=\"popTemplate\" container=\"body\"\r\n        triggers=\"hover\">{{elementConfig.propertyName}}</span>\r\n    </label> -->\r\n    <!-- <label class=\"col-form-label\">\r\n      <span class=\"farris-label-text\">{{elementConfig.propertyName}}</span>\r\n    </label> -->\r\n\r\n\r\n    <ng-container #propItem> </ng-container>\r\n\r\n    <!--\u6587\u672C-->\r\n    <ng-template #stringTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <input type=\"input\" class=\"form-control form-control-sm\" [(ngModel)]=\"elementValue\" (blur)=\"changeValue($event)\"\r\n          *ngIf=\"!elementConfig.readonly\">\r\n        <input type=\"input\" class=\"form-control form-control-sm\" [(ngModel)]=\"elementShowValue\" [readonly]=\"'readonly'\"\r\n          *ngIf=\"elementConfig.readonly\">\r\n      </div>\r\n    </ng-template>\r\n\r\n    <ng-template #numberTmpl>\r\n      <!-- \u6570\u5B57-->\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-number-spinner [(ngModel)]=\"elementValue\" [readonly]=\"elementConfig.readonly\" [precision]=\"precision\"\r\n          [autoDecimal]=\"true\" [min]=\"elementConfig.min\" [max]=\"elementConfig.max\" [canNull]=\"true\"\r\n          [bigNumber]=\"elementConfig.isBigNumber\" (ngModelChange)=\"changeValue($event)\">\r\n        </farris-number-spinner>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u4E0B\u62C9\u5217\u8868-->\r\n    <ng-template #selectTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-combo-list [(ngModel)]=\"elementValue\" [idField]=\"'key'\" [textField]=\"'value'\" [data]=\"selectOptions\"\r\n          [readonly]=\"elementConfig.readonly\" [editable]=\"false\" [enableClear]=\"false\" [enableCancelSelected]=\"false\"\r\n          (valueChange)=\"changeValue($event)\">\r\n        </farris-combo-list>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u53EF\u7F16\u8F91\u7684\u4E0B\u62C9\u5217\u8868\uFF08\u6B64\u5904\u662F\u6539\u52A8\u540E\u7684farris combolist\uFF0Cfarris combolist\uFF09-->\r\n    <ng-template #boolOrExpTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-editable-combo-list [data]=\"selectOptions\" textField=\"value\" idField=\"key\" [(ngModel)]=\"elementValue\"\r\n          (valueChange)=\"changeValue($event)\" [editable]=\"true\" [readonly]=\"elementConfig.readonly?true:false\">\r\n        </farris-editable-combo-list>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u4E0B\u62C9\u591A\u9009-->\r\n    <ng-template #multiSelectTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-combo-list [(ngModel)]=\"elementValue\" [idField]=\"'key'\" [textField]=\"'value'\" [data]=\"selectOptions\"\r\n          [readonly]=\"elementConfig.readonly\" [editable]=\"false\" [multiSelect]=\"true\" [enableClear]=\"false\"\r\n          (ngModelChange)=\"changeValue($event)\">\r\n        </farris-combo-list>\r\n      </div>\r\n    </ng-template>\r\n\r\n    <!--\u65E5\u671F-->\r\n    <ng-template #dateTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-datepicker [(ngModel)]=\"elementValue\" [editable]=\"false\" [showTime]=\"false\" [dateFormat]=\"'yyyy-MM-dd'\"\r\n          [readonly]=\"elementConfig.readonly\" (valueChange)=\"changeDateValue($event)\" [returnType]=\"'string'\"\r\n          [maxDate]=\"elementConfig.max\" [minDate]=\"elementConfig.min\">\r\n        </farris-datepicker>\r\n      </div>\r\n    </ng-template>\r\n\r\n\r\n    <!-- \u65E5\u671F\u65F6\u95F4 -->\r\n    <ng-template #datetimeTmpl>\r\n      <div class=\"farris-input-wrap\">\r\n        <farris-datepicker [(ngModel)]=\"elementValue\" [editable]=\"false\" [showTime]=\"true\"\r\n          [dateFormat]=\"'yyyy-MM-dd HH:mm:ss'\" [readonly]=\"elementConfig.readonly\"\r\n          (valueChange)=\"changeDateValue($event)\" [returnType]=\"'string'\" [maxDate]=\"elementConfig.max\"\r\n          [minDate]=\"elementConfig.min\">\r\n        </farris-datepicker>\r\n      </div>\r\n    </ng-template>\r\n\r\n\r\n    <!-- \u6A21\u6001\u6846 -->\r\n    <ng-template #modalTmpl>\r\n      <div class=\"farris-input-wrap modalIcon\">\r\n        <input type=\"input\" class=\"form-control form-control-sm\" [(ngModel)]=\"elementShowValue\" readonly>\r\n        <span *ngIf=\"elementConfig.showClearButton && !elementConfig.readonly\" class=\"showClearButton\"\r\n          (click)=\"modalClear()\">\r\n          <i class=\"material-icons clearIcon\">close</i>\r\n        </span>\r\n        <i class=\"material-icons moreIcon\" (click)=\"openModal()\">filter_none</i>\r\n      </div>\r\n    </ng-template>\r\n\r\n  </div>\r\n</div>\r\n\r\n\r\n<ng-template #popTemplate>\r\n  <div *ngIf=\"elementConfig.propertyID\">\r\n    <span>\u7F16\u53F7\uFF1A </span> {{elementConfig.propertyID}}</div>\r\n  <div *ngIf=\"elementConfig.description\">\r\n    <span>\u63CF\u8FF0\uFF1A </span> {{elementConfig.description}}</div>\r\n</ng-template>",
                    styles: [".property-item .form-group{margin-bottom:2px}.property-item .modalIcon .showClearButton{display:none}.property-item .modalIcon:hover .showClearButton{display:block}.property-item .modalIcon input{padding-right:30px}.property-item .modalIcon .moreIcon{position:absolute;top:6px;right:6px;cursor:pointer;font-size:16px;color:#758a96}.property-item .modalIcon .clearIcon{position:absolute;top:5px;right:30px;cursor:pointer;font-size:19px;color:#758a96}.property-item .form-control[readonly]{background-color:#fff}.property-item .form-control:disabled,.property-item .form-control[readonly]{color:#4b4c4c}"]
                }] }
    ];
    /** @nocollapse */
    PropertyItemComponent.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: BsModalService },
        { type: Injector },
        { type: NotifyService },
        { type: ElementRef }
    ]; };
    PropertyItemComponent.propDecorators = {
        elementConfig: [{ type: Input }],
        elementValue: [{ type: Input }],
        valueChanged: [{ type: Output }],
        submitModal: [{ type: Output }],
        triggerRefreshPanel: [{ type: Output }],
        propItem: [{ type: ViewChild, args: ['propItem', { read: ViewContainerRef },] }],
        stringTmpl: [{ type: ViewChild, args: ['stringTmpl',] }],
        numberTmpl: [{ type: ViewChild, args: ['numberTmpl',] }],
        selectTmpl: [{ type: ViewChild, args: ['selectTmpl',] }],
        boolOrExpTmpl: [{ type: ViewChild, args: ['boolOrExpTmpl',] }],
        multiSelectTmpl: [{ type: ViewChild, args: ['multiSelectTmpl',] }],
        dateTmpl: [{ type: ViewChild, args: ['dateTmpl',] }],
        datetimeTmpl: [{ type: ViewChild, args: ['datetimeTmpl',] }],
        modalTmpl: [{ type: ViewChild, args: ['modalTmpl',] }]
    };
    return PropertyItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PropertyItemListComponent = /** @class */ (function () {
    function PropertyItemListComponent() {
        // 属性值
        this.valueChanged = new EventEmitter();
        this.submitModal = new EventEmitter();
        this.triggerRefreshPanel = new EventEmitter();
    }
    /**
     * @param {?} simpleChanges
     * @return {?}
     */
    PropertyItemListComponent.prototype.ngOnChanges = /**
     * @param {?} simpleChanges
     * @return {?}
     */
    function (simpleChanges) {
        // 若分类下有propertyData，则取分类下的propertyData；否则取整体的propertyData
        if (this.category.propertyData && this.category.enableCascade) {
            this.data = this.category.propertyData;
        }
        else {
            this.data = this.propertyData;
        }
        this.adaptProperties();
    };
    /**
     * 适配属性
     */
    /**
     * 适配属性
     * @private
     * @return {?}
     */
    PropertyItemListComponent.prototype.adaptProperties = /**
     * 适配属性
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.category.properties.forEach(function (propItem) {
            if (propItem.propertyType === 'cascade') {
                _this.cascadeValueStringify(propItem, _this.data[propItem.propertyID]);
                if (Object.keys(propItem).indexOf('visible') < 0) {
                    propItem.visible = true;
                }
            }
        });
    };
    /**
     * @return {?}
     */
    PropertyItemListComponent.prototype.refresh = /**
     * @return {?}
     */
    function () {
        // 若分类下有propertyData，则取分类下的propertyData；否则取整体的propertyData
        if (this.category.propertyData && this.category.enableCascade) {
            this.data = this.category.propertyData;
        }
        else {
            this.data = this.propertyData;
        }
        this.items.forEach(function (item) { return item.refresh(); });
    };
    /**
     * 一般属性变更
     * @param $event
     */
    /**
     * 一般属性变更
     * @param {?} $event
     * @return {?}
     */
    PropertyItemListComponent.prototype._itemChanged = /**
     * 一般属性变更
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        var changeObject = $event.changeObject;
        this.data[changeObject.propertyID] = changeObject.propertyValue;
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data);
            this.items.forEach(function (item) { return item.refresh(); });
        }
        changeObject.categoryId = this.category.categoryId;
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID;
        }
        this.valueChanged.emit(changeObject);
    };
    /**
     * 模态框数据变更（TODO:待优化，合并valueChange事件）
     * @param $event
     */
    /**
     * 模态框数据变更（TODO:待优化，合并valueChange事件）
     * @param {?} $event
     * @return {?}
     */
    PropertyItemListComponent.prototype._submitModal = /**
     * 模态框数据变更（TODO:待优化，合并valueChange事件）
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        var changeObject = $event.changeObject, parameters = $event.parameters;
        this.data[changeObject.propertyID] = changeObject.propertyValue;
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data, parameters);
            this.items.forEach(function (item) { return item.refresh(); });
        }
        changeObject.categoryId = this.category.categoryId;
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID;
        }
        this.submitModal.emit($event);
    };
    /**
     * 级联属性变更
     */
    /**
     * 级联属性变更
     * @param {?} $event
     * @param {?} propItem
     * @return {?}
     */
    PropertyItemListComponent.prototype._cascadeitemChanged = /**
     * 级联属性变更
     * @param {?} $event
     * @param {?} propItem
     * @return {?}
     */
    function ($event, propItem) {
        /** @type {?} */
        var parentPropertyID = propItem.propertyID;
        if (!parentPropertyID) {
            return;
        }
        var changeObject = $event.changeObject;
        if (!this.data[parentPropertyID]) {
            this.data[parentPropertyID] = {};
        }
        this.data[parentPropertyID][changeObject.propertyID] = changeObject.propertyValue;
        changeObject.categoryId = this.category.categoryId;
        changeObject.parentPropertyID = changeObject.propertyPath = parentPropertyID;
        // 分类启用了级联，并且分类下有级联属性
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID + '.' + changeObject.parentPropertyID;
        }
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data);
            this.items.forEach(function (item) { return item.refresh(); });
        }
        this.cascadeValueStringify(propItem, this.data[parentPropertyID]);
        this.valueChanged.emit(changeObject);
    };
    /**
     * 级联模态框属性变更
     */
    /**
     * 级联模态框属性变更
     * @param {?} $event
     * @param {?} propItem
     * @return {?}
     */
    PropertyItemListComponent.prototype.__cascadeitemSubmitModal = /**
     * 级联模态框属性变更
     * @param {?} $event
     * @param {?} propItem
     * @return {?}
     */
    function ($event, propItem) {
        /** @type {?} */
        var parentPropertyID = propItem.propertyID;
        if (!parentPropertyID) {
            return;
        }
        var changeObject = $event.changeObject, parameters = $event.parameters;
        if (!this.data[parentPropertyID]) {
            this.data[parentPropertyID] = {};
        }
        this.data[parentPropertyID][changeObject.propertyID] = changeObject.propertyValue;
        changeObject.categoryId = this.category.categoryId;
        changeObject.parentPropertyID = changeObject.propertyPath = parentPropertyID;
        // 分类启用了级联，并且分类下有级联属性
        if (this.category.enableCascade) {
            changeObject.propertyPath = this.category.parentPropertyID + '.' + changeObject.parentPropertyID;
        }
        if (this.category.setPropertyRelates && typeof (this.category.setPropertyRelates) === 'function') {
            this.category.setPropertyRelates(changeObject, this.data, parameters);
            this.items.forEach(function (item) { return item.refresh(); });
        }
        this.cascadeValueStringify(propItem, this.data[parentPropertyID]);
        this.submitModal.emit($event);
    };
    /**
     * 级联属性的汇总信息
     * @param propItem
     * @param valueObject
     */
    /**
     * 级联属性的汇总信息
     * @param {?} propItem
     * @param {?} valueObject
     * @return {?}
     */
    PropertyItemListComponent.prototype.cascadeValueStringify = /**
     * 级联属性的汇总信息
     * @param {?} propItem
     * @param {?} valueObject
     * @return {?}
     */
    function (propItem, valueObject) {
        if (!propItem || !propItem.cascadeConfig) {
            return;
        }
        if (!valueObject) {
            propItem.cascadeSummary = '';
            return;
        }
        if (!propItem.cascadeConverter || !propItem.cascadeConverter.convertTo) {
            propItem.cascadeSummary = JSON.stringify(valueObject);
        }
        else {
            propItem.cascadeSummary = propItem.cascadeConverter.convertTo(valueObject, propItem.cascadeConfig);
        }
    };
    /**
     *  已废弃
     */
    /**
     *  已废弃
     * @param {?} propItem
     * @return {?}
     */
    PropertyItemListComponent.prototype._checkCascadeVisible = /**
     *  已废弃
     * @param {?} propItem
     * @return {?}
     */
    function (propItem) {
        if (Object.keys(propItem).indexOf('visible') < 0) {
            return true;
        }
        else {
            return propItem.visible;
        }
    };
    /**
     * @return {?}
     */
    PropertyItemListComponent.prototype.refreshPanel = /**
     * @return {?}
     */
    function () {
        this.triggerRefreshPanel.emit();
    };
    /**
     * @param {?} index
     * @param {?} PropItem
     * @return {?}
     */
    PropertyItemListComponent.prototype.trackByPropId = /**
     * @param {?} index
     * @param {?} PropItem
     * @return {?}
     */
    function (index, PropItem) {
        return PropItem.propertyID;
    };
    PropertyItemListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'webide-property-item-list',
                    template: "<div *ngFor=\"let propItem of category.properties; trackBy:trackByPropId\">\r\n    <div *ngIf=\"propItem.propertyType != 'cascade'\" class=\"px-2\">\r\n        <webide-property-item (valueChanged)=\"_itemChanged($event)\" (submitModal)=\"_submitModal($event)\"\r\n            [elementValue]=\"data[propItem.propertyID]\" [elementConfig]=\"propItem\"\r\n            (triggerRefreshPanel)=\"refreshPanel()\"></webide-property-item>\r\n    </div>\r\n\r\n    <div class=\"farris-panel\" *ngIf=\"propItem.propertyType == 'cascade' && propItem.visible\">\r\n        <div class=\"propertyCascadeItem farris-panel-item card\">\r\n            <div class=\"card-header\" (click)=\"propItem.isExpand=!propItem.isExpand\">\r\n                <div class=\"panel-item-title\">\r\n                    <div class=\"form-group farris-form-group\">\r\n                        <div class=\"f-section-formgroup-legend\">\r\n                            <div class=\"f-header px-0  col-form-label\" style=\"font-size: inherit;\">\r\n                                <div class=\"f-title f-utils-fill\">{{propItem.propertyName}}</div>\r\n                                <div class=\"f-toolbar\">\r\n                                    <button class=\"btn f-btn-collapse-expand f-btn-mx\"\r\n                                        [class.f-state-expand]=\"propItem.isExpand\"><span></span></button>\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        <div class=\"farris-input-wrap\" *ngIf=\"!propItem.hideCascadeTitle\">\r\n                            <input type=\"input\" class=\"form-control form-control-sm\" readonly\r\n                                [value]=\"propItem.cascadeSummary\">\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"card-body\" [style.display]=\"propItem.isExpand?'block':'none'\">\r\n                <div *ngFor=\"let cascadeItem of propItem.cascadeConfig\" class=\"px-2\">\r\n                    <webide-property-item (valueChanged)=\"_cascadeitemChanged($event,propItem)\"\r\n                        (submitModal)=\"__cascadeitemSubmitModal($event, propItem)\"\r\n                        [elementValue]=\"data[propItem.propertyID]?data[propItem.propertyID][cascadeItem.propertyID]:''\"\r\n                        [elementConfig]=\"cascadeItem\" (triggerRefreshPanel)=\"refreshPanel()\">\r\n                    </webide-property-item>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n\r\n</div>",
                    encapsulation: ViewEncapsulation.None,
                    styles: [".propertyCascadeItem{background-color:transparent!important;border:none!important}.propertyCascadeItem .card-header{background-color:transparent!important;padding:4px 12px!important;color:inherit!important}.propertyCascadeItem .card-header .panel-item-title{width:100%;position:relative;font-size:inherit!important}.propertyCascadeItem .card-header .panel-item-title .farris-input-wrap{margin-left:-5px;margin-right:-5px}.propertyCascadeItem .f-accordion-collapse,.propertyCascadeItem .f-accordion-expand{right:0;left:auto!important;top:6px;color:#6b94ec!important;position:absolute}.propertyCascadeItem .card-body{padding:3px 12px!important;background:rgba(255,255,255,.8);border-radius:8px;margin:4px 8px}"]
                }] }
    ];
    /** @nocollapse */
    PropertyItemListComponent.ctorParameters = function () { return []; };
    PropertyItemListComponent.propDecorators = {
        category: [{ type: Input }],
        propertyData: [{ type: Input }],
        valueChanged: [{ type: Output }],
        submitModal: [{ type: Output }],
        triggerRefreshPanel: [{ type: Output }],
        items: [{ type: ViewChildren, args: [PropertyItemComponent,] }]
    };
    return PropertyItemListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PropertyPanelComponent = /** @class */ (function () {
    function PropertyPanelComponent() {
        /**
         * 是否持有面板的隐藏显示状态
         */
        this.isPersitOpenState = false;
        /**
         * isPersitOpenState=true时，控制面板是否隐藏显示
         */
        this.isShowPanel = false;
        /**
         * isPersitOpenState=true时，抛出面板的关闭事件
         */
        this.closePropertyPanel = new EventEmitter();
        /**
         * 属性值
         */
        this.propertyData = {};
        /**
         * 属性变更事件
         */
        this.propertyChanged = new EventEmitter();
        /**
         * 模态框属性变更事件
         */
        this.submitModal = new EventEmitter();
        /**
         * 是否展示关闭按钮
         */
        this.showCloseBtn = true;
        /**
         * 当前展示状态
         */
        this.isOpen = true;
        /**
         * 外层分类，以标签页形式展示
         */
        this.categoryTabs = [];
    }
    /**
     * @return {?}
     */
    PropertyPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.width) {
            this.eastDiv.nativeElement.style.width = this.width + 'px';
        }
        else {
            this.eastDiv.nativeElement.style.width = 'inherit';
        }
        if (this.height) {
            this.eastDiv.nativeElement.style.height = this.height + 'px';
        }
        else {
            this.eastDiv.nativeElement.style.height = '100%';
        }
        if (this.isPersitOpenState) {
            this.isOpen = this.isShowPanel;
        }
        this.checkShowTabCategory();
    };
    /**
     *  更改面板的隐藏显示状态，只有在isPersitOpenState=true时生效
     */
    /**
     *  更改面板的隐藏显示状态，只有在isPersitOpenState=true时生效
     * @param {?} simpleChanges
     * @return {?}
     */
    PropertyPanelComponent.prototype.ngOnChanges = /**
     *  更改面板的隐藏显示状态，只有在isPersitOpenState=true时生效
     * @param {?} simpleChanges
     * @return {?}
     */
    function (simpleChanges) {
        if (simpleChanges.isShowPanel && this.isPersitOpenState) {
            this.isOpen = this.isShowPanel;
        }
        this.checkShowTabCategory();
    };
    /**
     * @return {?}
     */
    PropertyPanelComponent.prototype.refreshPanel = /**
     * @return {?}
     */
    function () {
        this.checkShowTabCategory();
        this.itemLists.forEach(function (item) { return item.refresh(); });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PropertyPanelComponent.prototype.changeStatus = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.propertyConfig.length < 2) {
            return;
        }
        if (!item.status || item.status === 'open') {
            item.status = 'closed';
        }
        else {
            item.status = 'open';
        }
    };
    /**
     *  隐藏面板
     */
    /**
     *  隐藏面板
     * @return {?}
     */
    PropertyPanelComponent.prototype.collapse = /**
     *  隐藏面板
     * @return {?}
     */
    function () {
        // isPersitOpenState=true时,由外部确定状态
        if (!this.isPersitOpenState) {
            this.isOpen = false;
        }
        this.closePropertyPanel.emit();
    };
    /**
     * 抛出属性变更事件
     */
    /**
     * 抛出属性变更事件
     * @param {?} changeObject
     * @return {?}
     */
    PropertyPanelComponent.prototype._valueChanged = /**
     * 抛出属性变更事件
     * @param {?} changeObject
     * @return {?}
     */
    function (changeObject) {
        this.propertyChanged.emit(changeObject);
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    PropertyPanelComponent.prototype._submitModal = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.submitModal.emit($event);
    };
    /**
     * 将属性分类按照标签页进行归类
     */
    /**
     * 将属性分类按照标签页进行归类
     * @private
     * @return {?}
     */
    PropertyPanelComponent.prototype.checkShowTabCategory = /**
     * 将属性分类按照标签页进行归类
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.categoryTabs = [];
        if (!this.propertyConfig || this.propertyConfig.length === 0) {
            this.categoryTabs = [{
                    tabId: 'default',
                    tabName: '属性',
                    categoryList: []
                }];
            this.selectedTab = null;
            return;
        }
        this.propertyConfig.forEach(function (config) {
            if (config.tabId) {
                /** @type {?} */
                var propTab = _this.categoryTabs.find(function (t) { return t.tabId === config.tabId; });
                if (!propTab) {
                    _this.categoryTabs.push({
                        tabId: config.tabId,
                        tabName: config.tabName,
                        categoryList: [config],
                        hide: config.hide || config.properties.length === 0
                    });
                }
                else {
                    propTab.categoryList.push(config);
                    if (propTab.hide) {
                        propTab.hide = config.hide || config.properties.length === 0;
                    }
                }
            }
            else {
                /** @type {?} */
                var defaultTab = _this.categoryTabs.find(function (t) { return t.tabId === 'default'; });
                if (!defaultTab) {
                    _this.categoryTabs.push({
                        tabId: 'default',
                        tabName: '属性',
                        categoryList: [config]
                    });
                }
                else {
                    defaultTab.categoryList.push(config);
                }
            }
        });
        this.selectedTab = this.categoryTabs[0];
    };
    PropertyPanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'app-property-panel',
                    template: "<div #east [style.display]=\"isOpen?'block':'none'\">\r\n    <div class=\"propertyPanel panel d-flex flex-column\">\r\n\r\n\r\n        <div class=\"title d-flex\">\r\n            <div class=\"title-label\" *ngFor=\"let tab of categoryTabs\" (click)=\"selectedTab=tab\" [hidden]=\"tab.hide\"\r\n                [class.active]=\"selectedTab && selectedTab.tabId===tab.tabId && categoryTabs.length>1\">\r\n                <span>{{tab.tabName}}</span>\r\n            </div>\r\n            <div class=\"title-actions\">\r\n                <div class=\"monaco-toolbar\">\r\n                    <div class=\"monaco-action-bar animated\">\r\n                        <ul class=\"actions-container\" role=\"toolbar\">\r\n                            <li class=\"action-item\" (click)=\"collapse()\" *ngIf=\"showCloseBtn\">\r\n                                <a class=\"hide-panel\" title=\"\u5173\u95ED\"></a>\r\n                            </li>\r\n                        </ul>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n\r\n        <div #propertyPanel class=\"panel-body\" [style.height]=\"(height - 35) + 'px'\" *ngIf=\"selectedTab\">\r\n            <ul class=\"property-grid\">\r\n                <li *ngFor=\"let category of selectedTab.categoryList\">\r\n                    <ng-container *ngIf=\"!category.hide\">\r\n                        <span *ngIf=\"!category.hideTitle\"\r\n                            [class]=\"category.status === 'closed' ? 'group-label collapse': 'group-label expand' \"\r\n                            (click)=\"changeStatus(category)\">{{ category.categoryName }}</span>\r\n                        <div [style.display]=\"!category.status || category.status === 'open'?'block':'none'\"\r\n                            class=\"py-1 \">\r\n                            <webide-property-item-list [category]=\"category\" [propertyData]=\"propertyData\"\r\n                                (valueChanged)=\"_valueChanged($event)\" (submitModal)=\"_submitModal($event)\"\r\n                                (triggerRefreshPanel)=\"refreshPanel()\"></webide-property-item-list>\r\n                        </div>\r\n                    </ng-container>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n\r\n</div>",
                    styles: [":host{width:inherit;height:inherit}.propertyPanel{width:100%;height:100%;color:rgba(0,0,0,.75);background:#f3f8ff!important;border-color:#d8dbe2!important}.propertyPanel .title{position:relative;background:#d0d8e9!important;padding-right:40px;flex-wrap:wrap}.propertyPanel .title>.title-label{line-height:34px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-left:12px;padding-right:12px;color:#333;font-size:14px;font-weight:600;cursor:pointer}.propertyPanel .title>.title-label.active{background:#8fb1df!important}.propertyPanel .title .title-actions{padding-left:35px;height:35px;flex:1;box-sizing:border-box;position:absolute;right:10px;top:0}.propertyPanel .property-grid .group-label{line-height:30px;display:block;padding-left:12px;cursor:pointer;background:#e2e9f6!important;color:#34495e!important;font-weight:600!important}.propertyPanel .panel-body{overflow:auto;height:100%}.propertyPanel .property-grid{list-style:none;margin:0;padding:0}.propertyPanel .action-item{cursor:pointer;display:inline-block;transition:transform 50ms;transition:transform 50ms,-webkit-transform 50ms;position:relative;padding:0}.propertyPanel .action-item .hide-panel{height:35px;display:block;line-height:35px;min-width:28px;color:rgba(66,66,66,.75);background-color:transparent!important;outline:0!important;background:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M9.784 8L13 11.217 11.215 13 8.001 9.786 4.785 13 3 11.216l3.214-3.215L3 4.785 4.784 3 8 6.216 11.216 3 13 4.785 9.784 8.001z' fill='%23424242'/%3E%3C/svg%3E\") 50% 50% no-repeat}"]
                }] }
    ];
    /** @nocollapse */
    PropertyPanelComponent.ctorParameters = function () { return []; };
    PropertyPanelComponent.propDecorators = {
        width: [{ type: Input }],
        height: [{ type: Input }],
        isPersitOpenState: [{ type: Input }],
        isShowPanel: [{ type: Input }],
        closePropertyPanel: [{ type: Output }],
        propertyConfig: [{ type: Input }],
        propertyData: [{ type: Input }],
        propertyChanged: [{ type: Output }],
        submitModal: [{ type: Output }],
        showCloseBtn: [{ type: Input }],
        eastDiv: [{ type: ViewChild, args: ['east',] }],
        itemLists: [{ type: ViewChildren, args: [PropertyItemListComponent,] }]
    };
    return PropertyPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PropertyPanelModule = /** @class */ (function () {
    function PropertyPanelModule() {
    }
    PropertyPanelModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        PropertyPanelComponent,
                        PropertyItemListComponent,
                        PropertyItemComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        PopoverModule,
                        // PopoverModule.forRoot(),
                        InputsModule,
                        DropDownsModule,
                        ComboListModule$1,
                        NotifyModule.forRoot(),
                        ModalModule.forRoot(),
                        FarrisDatePickerModule,
                        ComboListModule,
                        NumberSpinnerModule
                    ],
                    exports: [PropertyPanelComponent],
                    entryComponents: [PropertyPanelComponent, PropertyItemComponent]
                },] }
    ];
    /** @nocollapse */
    PropertyPanelModule.ctorParameters = function () { return []; };
    return PropertyPanelModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbTabset component.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the tabsets used in the application.
 */
var NgbTabsetConfig = /** @class */ (function () {
    function NgbTabsetConfig() {
        this.justify = 'start';
        this.orientation = 'horizontal';
        this.type = 'tabs';
    }
    NgbTabsetConfig.decorators = [
        { type: Injectable }
    ];
    return NgbTabsetConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var nextId = 0;
/**
 * This directive should be used to wrap tab titles that need to contain HTML markup or other directives.
 */
var NgbTabTitle = /** @class */ (function () {
    function NgbTabTitle(templateRef) {
        this.templateRef = templateRef;
    }
    NgbTabTitle.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbTabTitle]' },] }
    ];
    /** @nocollapse */
    NgbTabTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbTabTitle;
}());
/**
 * This directive must be used to wrap content to be displayed in a tab.
 */
var NgbTabContent = /** @class */ (function () {
    function NgbTabContent(templateRef) {
        this.templateRef = templateRef;
    }
    NgbTabContent.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbTabContent]' },] }
    ];
    /** @nocollapse */
    NgbTabContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbTabContent;
}());
/**
 * A directive representing an individual tab.
 */
var NgbTab = /** @class */ (function () {
    function NgbTab() {
        /**
         * Unique tab identifier. Must be unique for the entire document for proper accessibility support.
         */
        this.id = "ngb-tab-" + nextId++;
        /**
         * Allows toggling disabled state of a given state. Disabled tabs can't be selected.
         */
        this.disabled = false;
    }
    NgbTab.decorators = [
        { type: Directive, args: [{ selector: 'ngb-tab' },] }
    ];
    NgbTab.propDecorators = {
        id: [{ type: Input }],
        title: [{ type: Input }],
        disabled: [{ type: Input }],
        contentTpl: [{ type: ContentChild, args: [NgbTabContent,] }],
        titleTpl: [{ type: ContentChild, args: [NgbTabTitle,] }]
    };
    return NgbTab;
}());
/**
 * A component that makes it easy to create tabbed interface.
 */
var NgbTabset = /** @class */ (function () {
    function NgbTabset(config) {
        /**
         * Whether the closed tabs should be hidden without destroying them
         */
        this.destroyOnHide = true;
        /**
         * A tab change event fired right before the tab selection happens. See NgbTabChangeEvent for payload details
         */
        this.tabChange = new EventEmitter();
        this.type = config.type;
        this.justify = config.justify;
        this.orientation = config.orientation;
    }
    Object.defineProperty(NgbTabset.prototype, "justify", {
        /**
         * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
         * 'justified'
         * The default value is 'start'.
         */
        set: /**
         * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
         * 'justified'
         * The default value is 'start'.
         * @param {?} className
         * @return {?}
         */
        function (className) {
            if (className === 'fill' || className === 'justified') {
                this.justifyClass = "nav-" + className;
            }
            else {
                this.justifyClass = "justify-content-" + className;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     */
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    NgbTabset.prototype.select = /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    function (tabId) {
        /** @type {?} */
        var selectedTab = this._getTabById(tabId);
        if (selectedTab && !selectedTab.disabled && this.activeId !== selectedTab.id) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            this.tabChange.emit({ activeId: this.activeId, nextId: selectedTab.id, preventDefault: function () { defaultPrevented_1 = true; } });
            if (!defaultPrevented_1) {
                this.activeId = selectedTab.id;
            }
        }
    };
    /**
     * @return {?}
     */
    NgbTabset.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // auto-correct activeId that might have been set incorrectly as input
        /** @type {?} */
        var activeTab = this._getTabById(this.activeId);
        this.activeId = activeTab ? activeTab.id : (this.tabs.length ? this.tabs.first.id : null);
    };
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    NgbTabset.prototype._getTabById = /**
     * @private
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var tabsWithId = this.tabs.filter(function (tab) { return tab.id === id; });
        return tabsWithId.length ? tabsWithId[0] : null;
    };
    NgbTabset.decorators = [
        { type: Component, args: [{
                    selector: 'ngb-tabset',
                    exportAs: 'ngbTabset',
                    template: "\n    <ul [class]=\"'web-ide-content-tab-header nav nav-' + type + (orientation == 'horizontal'?  ' '\n      + justifyClass : ' flex-column')\" role=\"tablist\">\n      <li class=\"nav-item\" *ngFor=\"let tab of tabs\">\n        <a [id]=\"tab.id\" class=\"nav-link\" [class.active]=\"tab.id === activeId\" [class.disabled]=\"tab.disabled\"\n          href (click)=\"select(tab.id)\" role=\"tab\" [attr.tabindex]=\"(tab.disabled ? '-1': undefined)\"\n          [attr.aria-controls]=\"((!destroyOnHide || tab.id === activeId) ? tab.id + '-panel' : null)\"\n          [attr.aria-expanded]=\"tab.id === activeId\" [attr.aria-disabled]=\"tab.disabled\">\n          {{tab.title}}<ng-template [ngTemplateOutlet]=\"tab.titleTpl?.templateRef\"></ng-template>\n        </a>\n      </li>\n    </ul>\n    <div class=\"web-ide-content tab-content d-flex\">\n      <ng-template ngFor let-tab [ngForOf]=\"tabs\">\n        <div\n          class=\"tab-pane {{tab.id === activeId ? 'active' : null}}\"\n          *ngIf=\"!destroyOnHide || tab.id === activeId\"\n          role=\"tabpanel\"\n          [attr.aria-labelledby]=\"tab.id\" id=\"{{tab.id}}-panel\"\n          [attr.aria-expanded]=\"tab.id === activeId\">\n          <ng-template [ngTemplateOutlet]=\"tab.contentTpl.templateRef\"></ng-template>\n        </div>\n      </ng-template>\n    </div>\n  ",
                    styles: [":host{display:flex!important;flex:1;flex-direction:column}"]
                }] }
    ];
    /** @nocollapse */
    NgbTabset.ctorParameters = function () { return [
        { type: NgbTabsetConfig }
    ]; };
    NgbTabset.propDecorators = {
        tabs: [{ type: ContentChildren, args: [NgbTab,] }],
        activeId: [{ type: Input }],
        destroyOnHide: [{ type: Input }],
        justify: [{ type: Input }],
        orientation: [{ type: Input }],
        type: [{ type: Input }],
        tabChange: [{ type: Output }]
    };
    return NgbTabset;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NGB_TABSET_DIRECTIVES = [NgbTabset, NgbTab, NgbTabContent, NgbTabTitle];
var NgbTabsetModule = /** @class */ (function () {
    function NgbTabsetModule() {
    }
    /**
     * @return {?}
     */
    NgbTabsetModule.forRoot = /**
     * @return {?}
     */
    function () { return { ngModule: NgbTabsetModule, providers: [NgbTabsetConfig] }; };
    NgbTabsetModule.decorators = [
        { type: NgModule, args: [{ declarations: NGB_TABSET_DIRECTIVES, exports: NGB_TABSET_DIRECTIVES, imports: [CommonModule] },] }
    ];
    return NgbTabsetModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbNavTabset component.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the tabsets used in the application.
 */
var NgbNavTabsetConfig = /** @class */ (function () {
    function NgbNavTabsetConfig() {
        this.justify = 'start';
        this.orientation = 'horizontal';
        this.type = 'tabs';
    }
    NgbNavTabsetConfig.decorators = [
        { type: Injectable }
    ];
    return NgbNavTabsetConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var nextId$1 = 0;
/**
 * This directive should be used to wrap tab titles that need to contain HTML markup or other directives.
 */
var NgbNavTabTitle = /** @class */ (function () {
    function NgbNavTabTitle(templateRef) {
        this.templateRef = templateRef;
    }
    NgbNavTabTitle.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbNavTabTitle]' },] }
    ];
    /** @nocollapse */
    NgbNavTabTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbNavTabTitle;
}());
/**
 * This directive must be used to wrap content to be displayed in a tab.
 */
var NgbNavTabContent = /** @class */ (function () {
    function NgbNavTabContent(templateRef) {
        this.templateRef = templateRef;
    }
    NgbNavTabContent.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbNavTabContent]' },] }
    ];
    /** @nocollapse */
    NgbNavTabContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbNavTabContent;
}());
/**
 * A directive representing an individual tab.
 */
var NgbNavTab = /** @class */ (function () {
    function NgbNavTab() {
        /**
         * Unique tab identifier. Must be unique for the entire document for proper accessibility support.
         */
        this.id = "ngb-tab-" + nextId$1++;
        /**
         * Allows toggling disabled state of a given state. Disabled tabs can't be selected.
         */
        this.disabled = false;
    }
    NgbNavTab.decorators = [
        { type: Directive, args: [{ selector: 'ngb-navtab' },] }
    ];
    NgbNavTab.propDecorators = {
        id: [{ type: Input }],
        title: [{ type: Input }],
        disabled: [{ type: Input }],
        contentTpl: [{ type: ContentChild, args: [NgbNavTabContent,] }],
        titleTpl: [{ type: ContentChild, args: [NgbNavTabTitle,] }]
    };
    return NgbNavTab;
}());
/**
 * A component that makes it easy to create tabbed interface.
 */
var NgbNavTabset = /** @class */ (function () {
    function NgbNavTabset(config) {
        /**
         * Whether the closed tabs should be hidden without destroying them
         */
        this.destroyOnHide = true;
        /**
         * A tab change event fired right before the tab selection happens. See NgbNavTabChangeEvent for payload details
         */
        this.tabChange = new EventEmitter();
        this.type = config.type;
        this.justify = config.justify;
        this.orientation = config.orientation;
    }
    Object.defineProperty(NgbNavTabset.prototype, "justify", {
        /**
         * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
         * 'justified'
         * The default value is 'start'.
         */
        set: /**
         * The horizontal alignment of the nav with flexbox utilities. Can be one of 'start', 'center', 'end', 'fill' or
         * 'justified'
         * The default value is 'start'.
         * @param {?} className
         * @return {?}
         */
        function (className) {
            if (className === 'fill' || className === 'justified') {
                this.justifyClass = "nav-" + className;
            }
            else {
                this.justifyClass = "justify-content-" + className;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     */
    /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    NgbNavTabset.prototype.select = /**
     * Selects the tab with the given id and shows its associated pane.
     * Any other tab that was previously selected becomes unselected and its associated pane is hidden.
     * @param {?} tabId
     * @return {?}
     */
    function (tabId) {
        /** @type {?} */
        var selectedTab = this._getTabById(tabId);
        if (selectedTab && !selectedTab.disabled && this.activeId !== selectedTab.id) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            this.tabChange.emit({ activeId: this.activeId, nextId: selectedTab.id, preventDefault: function () { defaultPrevented_1 = true; } });
            if (!defaultPrevented_1) {
                this.activeId = selectedTab.id;
            }
        }
    };
    /**
     * @return {?}
     */
    NgbNavTabset.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        // auto-correct activeId that might have been set incorrectly as input
        /** @type {?} */
        var activeTab = this._getTabById(this.activeId);
        this.activeId = activeTab ? activeTab.id : (this.tabs.length ? this.tabs.first.id : null);
    };
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    NgbNavTabset.prototype._getTabById = /**
     * @private
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var tabsWithId = this.tabs.filter(function (tab) { return tab.id === id; });
        return tabsWithId.length ? tabsWithId[0] : null;
    };
    NgbNavTabset.decorators = [
        { type: Component, args: [{
                    selector: 'ngb-navtabset',
                    exportAs: 'NgbNavTabset',
                    template: "\n    <ul [class]=\"'web-ide-activity-bar nav nav-' + type + (orientation == 'horizontal'?  ' '\n      + justifyClass : ' flex-column')\" role=\"tablist\">\n      <li class=\"nav-item\" *ngFor=\"let tab of tabs\">\n        <a [id]=\"tab.id\" class=\"nav-link\" [class.active]=\"tab.id === activeId\" [class.disabled]=\"tab.disabled\"\n          href (click)=\"select(tab.id)\" role=\"tab\" [attr.tabindex]=\"(tab.disabled ? '-1': undefined)\"\n          [attr.aria-controls]=\"(!destroyOnHide || tab.id === activeId ? tab.id + '-panel' : null)\"\n          [attr.aria-expanded]=\"tab.id === activeId\" [attr.aria-disabled]=\"tab.disabled\">\n          {{tab.title}}<ng-template [ngTemplateOutlet]=\"tab.titleTpl?.templateRef\"></ng-template>\n        </a>\n      </li>\n    </ul>\n    <div class=\"web-ide-side-bar tab-content\">\n      <ng-template ngFor let-tab [ngForOf]=\"tabs\">\n        <div\n          class=\"tab-pane {{tab.id === activeId ? 'active' : null}}\"\n          *ngIf=\"!destroyOnHide || tab.id === activeId\"\n          role=\"tabpanel\"\n          [attr.aria-labelledby]=\"tab.id\" id=\"{{tab.id}}-panel\"\n          [attr.aria-expanded]=\"tab.id === activeId\">\n          <ng-template [ngTemplateOutlet]=\"tab.contentTpl.templateRef\"></ng-template>\n        </div>\n      </ng-template>\n    </div>\n  ",
                    styles: [":host{display:flex!important;flex:1}"]
                }] }
    ];
    /** @nocollapse */
    NgbNavTabset.ctorParameters = function () { return [
        { type: NgbNavTabsetConfig }
    ]; };
    NgbNavTabset.propDecorators = {
        tabs: [{ type: ContentChildren, args: [NgbNavTab,] }],
        activeId: [{ type: Input }],
        destroyOnHide: [{ type: Input }],
        justify: [{ type: Input }],
        orientation: [{ type: Input }],
        type: [{ type: Input }],
        tabChange: [{ type: Output }]
    };
    return NgbNavTabset;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NGB_TABSET_DIRECTIVES$1 = [NgbNavTabset, NgbNavTab, NgbNavTabContent, NgbNavTabTitle];
var NgbNavTabsetModule = /** @class */ (function () {
    function NgbNavTabsetModule() {
    }
    /**
     * @return {?}
     */
    NgbNavTabsetModule.forRoot = /**
     * @return {?}
     */
    function () { return { ngModule: NgbNavTabsetModule, providers: [NgbNavTabsetConfig] }; };
    NgbNavTabsetModule.decorators = [
        { type: NgModule, args: [{ declarations: NGB_TABSET_DIRECTIVES$1, exports: NGB_TABSET_DIRECTIVES$1, imports: [CommonModule] },] }
    ];
    return NgbNavTabsetModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function isString(value) {
    return typeof value === 'string';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbAccordion component.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the accordions used in the application.
 */
var NgbAccordionConfig = /** @class */ (function () {
    function NgbAccordionConfig() {
        this.closeOthers = false;
    }
    NgbAccordionConfig.decorators = [
        { type: Injectable }
    ];
    return NgbAccordionConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var nextId$2 = 0;
/**
 * This directive should be used to wrap accordion panel titles that need to contain HTML markup or other directives.
 */
var NgbPanelTitle = /** @class */ (function () {
    function NgbPanelTitle(templateRef) {
        this.templateRef = templateRef;
    }
    NgbPanelTitle.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbPanelTitle]' },] }
    ];
    /** @nocollapse */
    NgbPanelTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbPanelTitle;
}());
/**
 * This directive must be used to wrap accordion panel content.
 */
var NgbPanelContent = /** @class */ (function () {
    function NgbPanelContent(templateRef) {
        this.templateRef = templateRef;
    }
    NgbPanelContent.decorators = [
        { type: Directive, args: [{ selector: 'ng-template[ngbPanelContent]' },] }
    ];
    /** @nocollapse */
    NgbPanelContent.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return NgbPanelContent;
}());
/**
 * The NgbPanel directive represents an individual panel with the title and collapsible
 * content
 */
var NgbPanel = /** @class */ (function () {
    function NgbPanel() {
        /**
         *  A flag determining whether the panel is disabled or not.
         *  When disabled, the panel cannot be toggled.
         */
        this.disabled = false;
        /**
         *  An optional id for the panel. The id should be unique.
         *  If not provided, it will be auto-generated.
         */
        this.id = "ngb-panel-" + nextId$2++;
        /**
         * A flag telling if the panel is currently open
         */
        this.isOpen = false;
    }
    NgbPanel.decorators = [
        { type: Directive, args: [{ selector: 'ngb-panel' },] }
    ];
    NgbPanel.propDecorators = {
        disabled: [{ type: Input }],
        id: [{ type: Input }],
        title: [{ type: Input }],
        type: [{ type: Input }],
        contentTpl: [{ type: ContentChild, args: [NgbPanelContent,] }],
        titleTpl: [{ type: ContentChild, args: [NgbPanelTitle,] }]
    };
    return NgbPanel;
}());
/**
 * The NgbAccordion directive is a collection of panels.
 * It can assure that only one panel can be opened at a time.
 */
var NgbAccordion = /** @class */ (function () {
    function NgbAccordion(config) {
        /**
         * An array or comma separated strings of panel identifiers that should be opened
         */
        this.activeIds = [];
        /**
         * Whether the closed panels should be hidden without destroying them
         */
        this.destroyOnHide = true;
        /**
         * A panel change event fired right before the panel toggle happens. See NgbPanelChangeEvent for payload details
         */
        this.panelChange = new EventEmitter();
        this.type = config.type;
        this.closeOtherPanels = config.closeOthers;
    }
    /**
     * Programmatically toggle a panel with a given id.
     */
    /**
     * Programmatically toggle a panel with a given id.
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype.toggle = /**
     * Programmatically toggle a panel with a given id.
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) {
        /** @type {?} */
        var panel = this.panels.find(function (p) { return p.id === panelId; });
        if (panel && !panel.disabled) {
            /** @type {?} */
            var defaultPrevented_1 = false;
            this.panelChange.emit({ panelId: panelId, nextState: !panel.isOpen, preventDefault: function () { defaultPrevented_1 = true; } });
            if (!defaultPrevented_1) {
                panel.isOpen = !panel.isOpen;
                if (this.closeOtherPanels) {
                    this._closeOthers(panelId);
                }
                this._updateActiveIds();
            }
        }
    };
    /**
     * @return {?}
     */
    NgbAccordion.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // active id updates
        if (isString(this.activeIds)) {
            this.activeIds = ((/** @type {?} */ (this.activeIds))).split(/\s*,\s*/);
        }
        // update panels open states
        this.panels.forEach(function (panel) { return panel.isOpen = !panel.disabled && _this.activeIds.indexOf(panel.id) > -1; });
        // closeOthers updates
        if (this.activeIds.length > 1 && this.closeOtherPanels) {
            this._closeOthers(this.activeIds[0]);
            this._updateActiveIds();
        }
    };
    /**
     * @private
     * @param {?} panelId
     * @return {?}
     */
    NgbAccordion.prototype._closeOthers = /**
     * @private
     * @param {?} panelId
     * @return {?}
     */
    function (panelId) {
        this.panels.forEach(function (panel) {
            if (panel.id !== panelId) {
                panel.isOpen = false;
            }
        });
    };
    /**
     * @private
     * @return {?}
     */
    NgbAccordion.prototype._updateActiveIds = /**
     * @private
     * @return {?}
     */
    function () {
        this.activeIds = this.panels.filter(function (panel) { return panel.isOpen && !panel.disabled; }).map(function (panel) { return panel.id; });
    };
    NgbAccordion.decorators = [
        { type: Component, args: [{
                    selector: 'ngb-accordion',
                    exportAs: 'ngbAccordion',
                    // host: { 'role': 'tablist', '[attr.aria-multiselectable]': '!closeOtherPanels' },
                    template: "\n    <ng-template ngFor let-panel [ngForOf]=\"panels\">\n      <div class=\"card\">\n        <div role=\"tab\" id=\"{{panel.id}}-header\"\n          [class]=\"'card-header ' + (panel.type ? 'card-'+panel.type: type ? 'card-'+type : '')\" [class.active]=\"panel.isOpen\">\n          <a href (click)=\"toggle(panel.id)\" [class.text-muted]=\"panel.disabled\" [attr.tabindex]=\"(panel.disabled ? '-1' : null)\"\n            [attr.aria-expanded]=\"panel.isOpen\" [attr.aria-controls]=\"(panel.isOpen ? panel.id : null)\"\n            [attr.aria-disabled]=\"panel.disabled\">\n            {{panel.title}}<ng-template [ngTemplateOutlet]=\"panel.titleTpl?.templateRef\"></ng-template>\n          </a>\n        </div>\n        <div id=\"{{panel.id}}\" role=\"tabpanel\" [attr.aria-labelledby]=\"panel.id + '-header'\"\n             class=\"card-body collapse {{panel.isOpen ? 'show' : null}}\" *ngIf=\"!destroyOnHide || panel.isOpen\">\n             <ng-template [ngTemplateOutlet]=\"panel.contentTpl.templateRef\"></ng-template>\n        </div>\n      </div>\n    </ng-template>\n  "
                }] }
    ];
    /** @nocollapse */
    NgbAccordion.ctorParameters = function () { return [
        { type: NgbAccordionConfig }
    ]; };
    NgbAccordion.propDecorators = {
        panels: [{ type: ContentChildren, args: [NgbPanel,] }],
        activeIds: [{ type: Input }],
        closeOtherPanels: [{ type: Input, args: ['closeOthers',] }],
        destroyOnHide: [{ type: Input }],
        type: [{ type: Input }],
        panelChange: [{ type: Output }]
    };
    return NgbAccordion;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NGB_ACCORDION_DIRECTIVES = [NgbAccordion, NgbPanel, NgbPanelTitle, NgbPanelContent];
var NgbAccordionModule = /** @class */ (function () {
    function NgbAccordionModule() {
    }
    /**
     * @return {?}
     */
    NgbAccordionModule.forRoot = /**
     * @return {?}
     */
    function () { return { ngModule: NgbAccordionModule, providers: [NgbAccordionConfig] }; };
    NgbAccordionModule.decorators = [
        { type: NgModule, args: [{ declarations: NGB_ACCORDION_DIRECTIVES, exports: NGB_ACCORDION_DIRECTIVES, imports: [CommonModule] },] }
    ];
    return NgbAccordionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SashDirective = /** @class */ (function () {
    function SashDirective(_elementRef, renderer, _viewContainerRef) {
        this._elementRef = _elementRef;
        this.renderer = renderer;
        this._viewContainerRef = _viewContainerRef;
        this.widthChanged = new EventEmitter();
    }
    /**
     * @return {?}
     */
    SashDirective.prototype.onMouseDown = /**
     * @return {?}
     */
    function () {
        console.log('mousedown');
        this.bindDocumentClickListener();
    };
    /**
     * @return {?}
     */
    SashDirective.prototype.onMouseUp = /**
     * @return {?}
     */
    function () {
        console.log('mouseup');
    };
    /**
     * @return {?}
     */
    SashDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    SashDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    SashDirective.prototype.bindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer.listen('document', 'mouseup', function (event) {
                console.log('mouseup');
                console.log(event);
                _this.unbindDocumentMoveListener();
                _this.unbindDocumentClickListener();
            });
            if (!this.documentMoveListener) {
                this.bindDocumentClickListener = this.renderer.listen('document', 'mousemove', function (event) {
                    _this.panelWidth = event.clientX;
                    /** @type {?} */
                    var newWidth = (/** @type {?} */ (event.clientX));
                    _this.widthChanged.emit(newWidth);
                });
            }
        }
    };
    /**
     * @return {?}
     */
    SashDirective.prototype.unbindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    /**
     * @return {?}
     */
    SashDirective.prototype.unbindDocumentMoveListener = /**
     * @return {?}
     */
    function () {
        if (this.bindDocumentClickListener) {
            this.bindDocumentClickListener();
            this.bindDocumentClickListener = null;
        }
    };
    SashDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[sash]',
                    exportAs: 'sash'
                },] }
    ];
    /** @nocollapse */
    SashDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: ViewContainerRef }
    ]; };
    SashDirective.propDecorators = {
        panelWidth: [{ type: Input }],
        widthChanged: [{ type: Output }],
        onMouseDown: [{ type: HostListener, args: ['mousedown',] }],
        onMouseUp: [{ type: HostListener, args: ['mouseup',] }]
    };
    return SashDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PanelModule = /** @class */ (function () {
    function PanelModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    PanelModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return {
            ngModule: PanelModule
        };
    };
    PanelModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        SashDirective
                    ],
                    exports: [
                        SashDirective
                    ]
                },] }
    ];
    return PanelModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NGB_MODULES = [
    NgbTabsetModule,
    NgbNavTabsetModule,
    NgbAccordionModule
];
// @NgModule({
//   imports: [
//     BsDropdownModule.forRoot()
//   ],
//   exports: [BsDropdownModule],
//   schemas: [NO_ERRORS_SCHEMA]
// })
// export class MDBRootModule {
// }
// @NgModule({ exports: [BsDropdownModule] })
// export class MDBBootstrapModule {
//   public static forRoot(): ModuleWithProviders {
//     return { ngModule: MDBRootModule };
//   }
// }
var NgbRootModule = /** @class */ (function () {
    function NgbRootModule() {
    }
    NgbRootModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        NgbTabsetModule.forRoot(),
                        NgbNavTabsetModule.forRoot(),
                        NgbAccordionModule.forRoot()
                    ],
                    exports: [
                        NGB_MODULES
                    ]
                },] }
    ];
    return NgbRootModule;
}());
var NgbModule = /** @class */ (function () {
    function NgbModule() {
    }
    /**
     * @return {?}
     */
    NgbModule.forRoot = /**
     * @return {?}
     */
    function () { return { ngModule: NgbRootModule }; };
    NgbModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    return NgbModule;
}());
var IDERootModule = /** @class */ (function () {
    function IDERootModule() {
    }
    IDERootModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        PanelModule.forRoot()
                    ]
                },] }
    ];
    return IDERootModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
LinkedList = /** @class */ (function () {
    function LinkedList() {
        this.length = 0;
        this.asArray = [];
        // Array methods overriding END
    }
    /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    LinkedList.prototype.getNode = /**
     * @protected
     * @param {?} position
     * @return {?}
     */
    function (position) {
        if (this.length === 0 || position < 0 || position >= this.length) {
            throw new Error('Position is out of the list');
        }
        /** @type {?} */
        var current = this.head;
        for (var index = 0; index < position; index++) {
            current = current.next;
        }
        return current;
    };
    /**
     * @protected
     * @return {?}
     */
    LinkedList.prototype.createInternalArrayRepresentation = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var outArray = [];
        /** @type {?} */
        var current = this.head;
        while (current) {
            outArray.push(current.value);
            current = current.next;
        }
        this.asArray = outArray;
    };
    /**
     * @param {?} position
     * @return {?}
     */
    LinkedList.prototype.get = /**
     * @param {?} position
     * @return {?}
     */
    function (position) {
        if (this.length === 0 || position < 0 || position >= this.length) {
            return void 0;
        }
        /** @type {?} */
        var current = this.head;
        for (var index = 0; index < position; index++) {
            current = current.next;
        }
        return current.value;
    };
    /**
     * @param {?} value
     * @param {?=} position
     * @return {?}
     */
    LinkedList.prototype.add = /**
     * @param {?} value
     * @param {?=} position
     * @return {?}
     */
    function (value, position) {
        if (position === void 0) { position = this.length; }
        if (position < 0 || position > this.length) {
            throw new Error('Position is out of the list');
        }
        /** @type {?} */
        var node = {
            value: (/** @type {?} */ (value)),
            next: (/** @type {?} */ (undefined)),
            previous: (/** @type {?} */ (undefined))
        };
        if (this.length === 0) {
            this.head = node;
            this.tail = node;
            this.current = node;
        }
        else {
            if (position === 0) {
                // first node
                node.next = this.head;
                this.head.previous = node;
                this.head = node;
            }
            else if (position === this.length) {
                // last node
                this.tail.next = node;
                node.previous = this.tail;
                this.tail = node;
            }
            else {
                // node in middle
                /** @type {?} */
                var currentPreviousNode = this.getNode(position - 1);
                /** @type {?} */
                var currentNextNode = currentPreviousNode.next;
                currentPreviousNode.next = node;
                currentNextNode.previous = node;
                node.previous = currentPreviousNode;
                node.next = currentNextNode;
            }
        }
        this.length++;
        this.createInternalArrayRepresentation();
    };
    /**
     * @param {?=} position
     * @return {?}
     */
    LinkedList.prototype.remove = /**
     * @param {?=} position
     * @return {?}
     */
    function (position) {
        if (position === void 0) { position = 0; }
        if (this.length === 0 || position < 0 || position >= this.length) {
            throw new Error('Position is out of the list');
        }
        if (position === 0) {
            // first node
            this.head = this.head.next;
            if (this.head) {
                // there is no second node
                this.head.previous = undefined;
            }
            else {
                // there is no second node
                this.tail = undefined;
            }
        }
        else if (position === this.length - 1) {
            // last node
            this.tail = this.tail.previous;
            this.tail.next = undefined;
        }
        else {
            // middle node
            /** @type {?} */
            var removedNode = this.getNode(position);
            removedNode.next.previous = removedNode.previous;
            removedNode.previous.next = removedNode.next;
        }
        this.length--;
        this.createInternalArrayRepresentation();
    };
    /**
     * @param {?} position
     * @param {?} value
     * @return {?}
     */
    LinkedList.prototype.set = /**
     * @param {?} position
     * @param {?} value
     * @return {?}
     */
    function (position, value) {
        if (this.length === 0 || position < 0 || position >= this.length) {
            throw new Error('Position is out of the list');
        }
        /** @type {?} */
        var node = this.getNode(position);
        node.value = value;
        this.createInternalArrayRepresentation();
    };
    /**
     * @return {?}
     */
    LinkedList.prototype.toArray = /**
     * @return {?}
     */
    function () {
        return this.asArray;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    LinkedList.prototype.findAll = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        /** @type {?} */
        var current = this.head;
        /** @type {?} */
        var result = [];
        for (var index = 0; index < this.length; index++) {
            if (fn(current.value, index)) {
                result.push({ index: index, value: current.value });
            }
            current = current.next;
        }
        return result;
    };
    // Array methods overriding start
    // Array methods overriding start
    /**
     * @param {...?} args
     * @return {?}
     */
    LinkedList.prototype.push = 
    // Array methods overriding start
    /**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        args.forEach(function (arg) {
            _this.add(arg);
        });
        return this.length;
    };
    /**
     * @return {?}
     */
    LinkedList.prototype.pop = /**
     * @return {?}
     */
    function () {
        if (this.length === 0) {
            return undefined;
        }
        /** @type {?} */
        var last$$1 = this.tail;
        this.remove(this.length - 1);
        return last$$1.value;
    };
    /**
     * @param {...?} args
     * @return {?}
     */
    LinkedList.prototype.unshift = /**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        args.reverse();
        args.forEach(function (arg) {
            _this.add(arg, 0);
        });
        return this.length;
    };
    /**
     * @return {?}
     */
    LinkedList.prototype.shift = /**
     * @return {?}
     */
    function () {
        if (this.length === 0) {
            return undefined;
        }
        /** @type {?} */
        var lastItem = this.head.value;
        this.remove();
        return lastItem;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    LinkedList.prototype.forEach = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        /** @type {?} */
        var current = this.head;
        for (var index = 0; index < this.length; index++) {
            fn(current.value, index);
            current = current.next;
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    LinkedList.prototype.indexOf = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var current = this.head;
        /** @type {?} */
        var position = 0;
        for (var index = 0; index < this.length; index++) {
            if (current.value === value) {
                position = index;
                break;
            }
            current = current.next;
        }
        return position;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    LinkedList.prototype.some = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        /** @type {?} */
        var current = this.head;
        /** @type {?} */
        var result = false;
        while (current && !result) {
            if (fn(current.value)) {
                result = true;
                break;
            }
            current = current.next;
        }
        return result;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    LinkedList.prototype.every = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        /** @type {?} */
        var current = this.head;
        /** @type {?} */
        var result = true;
        while (current && result) {
            if (!fn(current.value)) {
                result = false;
            }
            current = current.next;
        }
        return result;
    };
    /**
     * @return {?}
     */
    LinkedList.prototype.toString = /**
     * @return {?}
     */
    function () {
        return '[Linked List]';
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    LinkedList.prototype.find = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        /** @type {?} */
        var current = this.head;
        /** @type {?} */
        var result;
        for (var index = 0; index < this.length; index++) {
            if (fn(current.value, index)) {
                result = current.value;
                break;
            }
            current = current.next;
        }
        return result;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    LinkedList.prototype.findIndex = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        /** @type {?} */
        var current = this.head;
        /** @type {?} */
        var result;
        for (var index = 0; index < this.length; index++) {
            if (fn(current.value, index)) {
                result = index;
                break;
            }
            current = current.next;
        }
        return result;
    };
    return LinkedList;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var EventBusProxy = /** @class */ (function () {
    function EventBusProxy(eventBus, hostType, eventTokenValueProvider) {
        this.eventBus = eventBus;
        this.hostType = hostType;
        this.eventTokenValueProvider = eventTokenValueProvider;
    }
    /**
     * @param {?} eventName
     * @param {?} data
     * @return {?}
     */
    EventBusProxy.prototype.post = /**
     * @param {?} eventName
     * @param {?} data
     * @return {?}
     */
    function (eventName, data) {
        this.eventBus.post(this.hostType, this.eventTokenValueProvider(), eventName, data);
    };
    return EventBusProxy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var EventPipe = /** @class */ (function () {
    function EventPipe(name, tokenValue, emitter, parentEventPipeList) {
        this.name = name;
        this.tokenValue = tokenValue;
        this.emitter = emitter;
        this.parentEventPipeList = parentEventPipeList;
        this.eventSubject = new Subject$1();
        this.subscriptionMap = new Map();
        this.onceSubscriptionMap = new Map();
        if (this.parentEventPipeList) {
            this.parentEventPipeList.push(this);
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    EventPipe.prototype.post = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.eventSubject.next(data);
    };
    /**
     * @param {?} eventHandler
     * @param {?} caller
     * @return {?}
     */
    EventPipe.prototype.subscribe = /**
     * @param {?} eventHandler
     * @param {?} caller
     * @return {?}
     */
    function (eventHandler, caller) {
        /** @type {?} */
        var subscription = this.eventSubject.subscribe(function (value) { return eventHandler.call(caller, value); });
        this.subscriptionMap.set(caller, subscription);
        return this;
    };
    /**
     * @param {?} eventHandler
     * @param {?} caller
     * @return {?}
     */
    EventPipe.prototype.subscribeOnce = /**
     * @param {?} eventHandler
     * @param {?} caller
     * @return {?}
     */
    function (eventHandler, caller) {
        /** @type {?} */
        var subscription = this.eventSubject.subscribe(function (value) { return eventHandler.call(caller, value); });
        this.onceSubscriptionMap.set(caller, subscription);
        return this;
    };
    /**
     * @param {?} subscriber
     * @return {?}
     */
    EventPipe.prototype.unSubscribe = /**
     * @param {?} subscriber
     * @return {?}
     */
    function (subscriber) {
        /** @type {?} */
        var subscription = this.subscriptionMap.get(subscriber);
        if (subscription) {
            subscription.unsubscribe();
            subscription = null;
            this.subscriptionMap.delete(subscriber);
        }
        else {
            subscription = this.onceSubscriptionMap.get(subscriber);
            if (subscription) {
                subscription.unsubscribe();
                subscription = null;
                this.onceSubscriptionMap.delete(subscriber);
            }
        }
    };
    // 注销使用once方法注册的订阅。
    // 注销使用once方法注册的订阅。
    /**
     * @return {?}
     */
    EventPipe.prototype.unSubscribeForOnce = 
    // 注销使用once方法注册的订阅。
    /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(Array.from(this.onceSubscriptionMap.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
                var subscriber = _c.value;
                this.unSubscribe(subscriber);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @param {?} emitter
     * @param {?} tokenValue
     * @return {?}
     */
    EventPipe.prototype.matchEmitterToken = /**
     * @param {?} emitter
     * @param {?} tokenValue
     * @return {?}
     */
    function (emitter, tokenValue) {
        if (this.emitter && emitter && this.emitter !== emitter) {
            return false;
        }
        if (this.tokenValue && tokenValue && this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    };
    /**
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    EventPipe.prototype.examByTargetToken = /**
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    function (target, tokenValue) {
        if (this.emitter !== target) {
            return false;
        }
        if (this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    };
    /**
     * @param {?} subscriber
     * @return {?}
     */
    EventPipe.prototype.dispose = /**
     * @param {?} subscriber
     * @return {?}
     */
    function (subscriber) {
        var _this = this;
        this.unSubscribe(subscriber);
        if (this.subscriptionMap.size === 0 && this.parentEventPipeList) {
            /** @type {?} */
            var location_1 = this.parentEventPipeList.findIndex(function (item) { return item === _this; });
            if (location_1 !== -1) {
                this.parentEventPipeList.splice(location_1, 1);
            }
        }
    };
    return EventPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DuplexEventPipe = /** @class */ (function () {
    function DuplexEventPipe(eventName) {
        this.listenerResults = new Map();
        this.subject = new Subject();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    DuplexEventPipe.prototype.notify = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var thenFn = function () { };
        /** @type {?} */
        var catchFn = function () { };
        /** @type {?} */
        var timestamp = Date.now().toString();
        this.subject.next({ value: value, timestamp: timestamp });
        // fooObservable无意义，有两个作用：
        // 1. 没有实际observable时能够让forkJoin输出值，进入subscriber.next
        // 2. 建立延迟的observable（跳出当前micro task），避免subscription未返回和thenFn未被设置。
        /** @type {?} */
        var fooObservable = timer(0).pipe(mapTo(true));
        /** @type {?} */
        var listenerResultArray = this.listenerResults.get(timestamp);
        if (!listenerResultArray) {
            listenerResultArray = [fooObservable];
        }
        else {
            listenerResultArray = listenerResultArray.concat(fooObservable);
            this.listenerResults.delete(timestamp);
        }
        /** @type {?} */
        var subscription = forkJoin(listenerResultArray).subscribe({ next: function (results) {
                /** @type {?} */
                var success = results.reduce(function (previous, current) { return previous && current; });
                if (success) {
                    thenFn();
                }
                else {
                    catchFn();
                }
                subscription.unsubscribe();
            }, error: function () {
                subscription.unsubscribe();
            } });
        return {
            then: /**
             * @param {?} callback
             * @return {?}
             */
            function (callback) {
                thenFn = callback;
                return this;
            },
            catch: /**
             * @param {?} callback
             * @return {?}
             */
            function (callback) {
                catchFn = callback;
                return this;
            }
        };
    };
    /**
     * @param {?} callback
     * @param {?=} caller
     * @return {?}
     */
    DuplexEventPipe.prototype.listen = /**
     * @param {?} callback
     * @param {?=} caller
     * @return {?}
     */
    function (callback, caller) {
        var _this = this;
        /** @type {?} */
        var listener = caller ? callback.bind(caller) : callback;
        this.subject.subscribe(function (_a) {
            var value = _a.value, timestamp = _a.timestamp;
            /** @type {?} */
            var listenerResult;
            /** @type {?} */
            var invokeResult = listener(value);
            if (invokeResult instanceof Observable) {
                listenerResult = invokeResult;
            }
            else if (typeof invokeResult === 'boolean') {
                listenerResult = of(invokeResult);
            }
            else {
                listenerResult = of(true);
            }
            /** @type {?} */
            var listenerResultArray = _this.listenerResults.get(timestamp);
            if (!listenerResultArray) {
                listenerResultArray = [];
                _this.listenerResults.set(timestamp, listenerResultArray);
            }
            listenerResultArray.push(listenerResult);
        });
    };
    return DuplexEventPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var EventBus = /** @class */ (function () {
    function EventBus() {
        this.proxyMap = new Map();
        this.eventMap = new Map();
        this.notificationMap = new Map();
    }
    /**
     * @param {?} ownerType
     * @param {?} eventTokenValueProvider
     * @return {?}
     */
    EventBus.prototype.getProxy = /**
     * @param {?} ownerType
     * @param {?} eventTokenValueProvider
     * @return {?}
     */
    function (ownerType, eventTokenValueProvider) {
        /** @type {?} */
        var ownerName = ownerType.constructor.name;
        if (!this.proxyMap.has(ownerName)) {
            this.proxyMap.set(ownerName, new EventBusProxy(this, ownerType, eventTokenValueProvider));
        }
        return this.proxyMap.get(ownerName);
    };
    /**
     * 发送事件，通知订阅者接收消息。
     */
    /**
     * 发送事件，通知订阅者接收消息。
     * @param {?} emitterType
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    EventBus.prototype.post = /**
     * 发送事件，通知订阅者接收消息。
     * @param {?} emitterType
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    function (emitterType, tokenValue, eventName, eventArgs) {
        var e_1, _a;
        /** @type {?} */
        var eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            return;
        }
        if (!emitterType) {
            console.error('post方法的参数emitterType不能为空。');
            return;
        }
        /** @type {?} */
        var emitter;
        if (emitterType instanceof Type) {
            emitter = emitterType.name;
        }
        else {
            emitter = emitterType;
        }
        try {
            for (var eventPipeList_1 = __values(eventPipeList), eventPipeList_1_1 = eventPipeList_1.next(); !eventPipeList_1_1.done; eventPipeList_1_1 = eventPipeList_1.next()) {
                var eventPipe = eventPipeList_1_1.value;
                if (eventPipe.matchEmitterToken(emitter, tokenValue)) {
                    eventPipe.post(eventArgs);
                    eventPipe.unSubscribeForOnce();
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (eventPipeList_1_1 && !eventPipeList_1_1.done && (_a = eventPipeList_1.return)) _a.call(eventPipeList_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * 订阅事件
     */
    /**
     * 订阅事件
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    EventBus.prototype.on = /**
     * 订阅事件
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    function (target, tokenValue, eventName, caller, handler) {
        return this.getEventPipe(eventName, target, tokenValue).subscribe(handler, caller);
    };
    /**
     * 订阅一次。接收到一次消息之后自动取消订阅
     */
    /**
     * 订阅一次。接收到一次消息之后自动取消订阅
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    EventBus.prototype.once = /**
     * 订阅一次。接收到一次消息之后自动取消订阅
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    function (target, tokenValue, eventName, caller, handler) {
        return this.getEventPipe(eventName, target, tokenValue).subscribeOnce(handler, caller);
    };
    /**
     * 发送一个请求事件，获取监听者的响应并处理
     */
    /**
     * 发送一个请求事件，获取监听者的响应并处理
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} requestName
     * @param {?} requestValue
     * @param {?} success
     * @param {?=} fail
     * @return {?}
     */
    EventBus.prototype.requestFor = /**
     * 发送一个请求事件，获取监听者的响应并处理
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} requestName
     * @param {?} requestValue
     * @param {?} success
     * @param {?=} fail
     * @return {?}
     */
    function (target, tokenValue, requestName, requestValue, success, fail) {
        /** @type {?} */
        var eventPipe = this.findExistEventPipe(requestName, 'RequestSubject', tokenValue);
        if (eventPipe) {
            this.once(target, tokenValue, requestName, this, function (response) {
                if (response.status === 'success') {
                    success(response.data);
                }
                else {
                    if (fail) {
                        fail('No target responser listening');
                    }
                }
            });
            eventPipe.post({ target: target, token: tokenValue, data: requestValue });
        }
        else {
            if (fail) {
                fail('No target responser listening.');
            }
        }
    };
    /**
     * 监听一个请求事件，给出响应
     */
    /**
     * 监听一个请求事件，给出响应
     * @param {?} responseSubject
     * @param {?} requestName
     * @param {?} callback
     * @return {?}
     */
    EventBus.prototype.responseOn = /**
     * 监听一个请求事件，给出响应
     * @param {?} responseSubject
     * @param {?} requestName
     * @param {?} callback
     * @return {?}
     */
    function (responseSubject, requestName, callback) {
        var _this = this;
        this.on('RequestSubject', null, requestName, this, function (requestObj) {
            /** @type {?} */
            var response = { status: 'fail', data: null };
            if (responseSubject === requestObj.target) {
                response.data = callback(requestObj.data);
                response.status = 'success';
            }
            _this.post(requestObj.target, requestObj.token, requestName, response);
        });
    };
    /**
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    EventBus.prototype.notify = /**
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventName, eventArgs) {
        /** @type {?} */
        var notification = this.notificationMap.get(eventName);
        if (!notification) {
            notification = new DuplexEventPipe(eventName);
            this.notificationMap.set(eventName, notification);
        }
        return notification.notify(eventArgs);
    };
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} caller
     * @return {?}
     */
    EventBus.prototype.listen = /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} caller
     * @return {?}
     */
    function (eventName, handler, caller) {
        /** @type {?} */
        var notification = this.notificationMap.get(eventName);
        if (!notification) {
            notification = new DuplexEventPipe(eventName);
            this.notificationMap.set(eventName, notification);
        }
        return notification.listen(handler, caller);
    };
    /**
     * @private
     * @param {?} eventName
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    EventBus.prototype.getEventPipe = /**
     * @private
     * @param {?} eventName
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    function (eventName, target, tokenValue) {
        /** @type {?} */
        var eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            eventPipeList = new Array();
            this.eventMap.set(eventName, eventPipeList);
        }
        /** @type {?} */
        var eventPipe = eventPipeList.find(function (item) { return item.examByTargetToken(target, tokenValue); });
        if (!eventPipe) {
            eventPipe = new EventPipe(eventName, tokenValue, target, eventPipeList);
        }
        return eventPipe;
    };
    /**
     * @private
     * @param {?} eventName
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    EventBus.prototype.findExistEventPipe = /**
     * @private
     * @param {?} eventName
     * @param {?} target
     * @param {?} tokenValue
     * @return {?}
     */
    function (eventName, target, tokenValue) {
        var e_2, _a;
        /** @type {?} */
        var eventPipeList = this.eventMap.get(eventName);
        if (!eventPipeList) {
            return null;
        }
        try {
            // return eventPipeList.find(item => item.examByTargetToken(target, tokenValue));
            for (var eventPipeList_2 = __values(eventPipeList), eventPipeList_2_1 = eventPipeList_2.next(); !eventPipeList_2_1.done; eventPipeList_2_1 = eventPipeList_2.next()) {
                var eventPipe = eventPipeList_2_1.value;
                if (eventPipe.matchEmitterToken(target, tokenValue)) {
                    return eventPipe;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (eventPipeList_2_1 && !eventPipeList_2_1.done && (_a = eventPipeList_2.return)) _a.call(eventPipeList_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return null;
    };
    EventBus.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    EventBus.ctorParameters = function () { return []; };
    return EventBus;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Model = /** @class */ (function () {
    function Model(params) {
        this.alive = true;
    }
    Object.defineProperty(Model.prototype, "isAlive", {
        get: /**
         * @return {?}
         */
        function () { return this.alive; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Model.prototype, "isDestroyed", {
        get: /**
         * @return {?}
         */
        function () { return !this.alive; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} id
     * @return {?}
     */
    Model.prototype.assignId = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
    };
    /**
     * @return {?}
     */
    Model.prototype.destroy = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    Model.prototype.resetNextInstanceId = /**
     * @return {?}
     */
    function () {
    };
    return Model;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PaneAxis = /** @class */ (function (_super) {
    __extends(PaneAxis, _super);
    function PaneAxis(params, viewRegistry) {
        return _super.call(this, {}) || this;
    }
    /**
     * @return {?}
     */
    PaneAxis.prototype.deserialize = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    PaneAxis.prototype.getElement = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    PaneAxis.prototype.addChild = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    PaneAxis.prototype.removeChidl = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    PaneAxis.prototype.insertChildBefore = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    PaneAxis.prototype.subscribeToChild = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    PaneAxis.prototype.unsubscribeFromChild = /**
     * @return {?}
     */
    function () { };
    return PaneAxis;
}(Model));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: A handle to a resource that can be disposed. For example,
// {Emitter::on} returns disposables representing subscriptions.
var Disposable = /** @class */ (function () {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct a Disposable
    //
    // * `disposalAction` A {Function} to call when {::dispose} is called for the
    //   first time.
    function Disposable(disposalAction) {
        this.disposalAction = disposalAction;
        this.disposed = false;
    }
    // Public: Ensure that `object` correctly implements the `Disposable`
    // contract.
    //
    // * `object` An {Object} you want to perform the check against.
    //
    // Returns a {Boolean} indicating whether `object` is a valid `Disposable`.
    // Public: Ensure that `object` correctly implements the `Disposable`
    // contract.
    //
    // * `object` An {Object} you want to perform the check against.
    //
    // Returns a {Boolean} indicating whether `object` is a valid `Disposable`.
    /**
     * @param {?} object
     * @return {?}
     */
    Disposable.isDisposable = 
    // Public: Ensure that `object` correctly implements the `Disposable`
    // contract.
    //
    // * `object` An {Object} you want to perform the check against.
    //
    // Returns a {Boolean} indicating whether `object` is a valid `Disposable`.
    /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        if (object && object.dispose && typeof (object.dispose) === 'function') {
            return true;
        }
        return false;
    };
    // Public: Perform the disposal action, indicating that the resource associated
    // with this disposable is no longer needed.
    //
    // You can call this method more than once, but the disposal action will only
    // be performed the first time.
    // Public: Perform the disposal action, indicating that the resource associated
    // with this disposable is no longer needed.
    //
    // You can call this method more than once, but the disposal action will only
    // be performed the first time.
    /**
     * @return {?}
     */
    Disposable.prototype.dispose = 
    // Public: Perform the disposal action, indicating that the resource associated
    // with this disposable is no longer needed.
    //
    // You can call this method more than once, but the disposal action will only
    // be performed the first time.
    /**
     * @return {?}
     */
    function () {
        if (!this.disposed) {
            this.disposed = true;
            if (this.disposalAction) {
                this.disposalAction();
            }
            this.disposalAction = null;
        }
    };
    return Disposable;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: An object that aggregates multiple {Disposable} instances together
// into a single disposable, so they can all be disposed as a group.
//
// These are very useful when subscribing to multiple events.
//
// ## Examples
//
// ```coffee
// {CompositeDisposable} = require 'atom'
//
// class Something
//   constructor: ->
//     @disposables = new CompositeDisposable
//     editor = atom.workspace.getActiveTextEditor()
//     @disposables.add editor.onDidChange ->
//     @disposables.add editor.onDidChangePath ->
//
//   destroy: ->
//     @disposables.dispose()
// ```
var 
// Essential: An object that aggregates multiple {Disposable} instances together
// into a single disposable, so they can all be disposed as a group.
//
// These are very useful when subscribing to multiple events.
//
// ## Examples
//
// ```coffee
// {CompositeDisposable} = require 'atom'
//
// class Something
//   constructor: ->
//     @disposables = new CompositeDisposable
//     editor = atom.workspace.getActiveTextEditor()
//     @disposables.add editor.onDidChange ->
//     @disposables.add editor.onDidChangePath ->
//
//   destroy: ->
//     @disposables.dispose()
// ```
CompositeDisposable = /** @class */ (function () {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct an instance, optionally with one or more disposables
    function CompositeDisposable() {
        var disposables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            disposables[_i] = arguments[_i];
        }
        this.disposed = false;
        this.disposables = new Set();
        this.add.apply(this, __spread(disposables));
    }
    // Public: Dispose all disposables added to this composite disposable.
    //
    // If this object has already been disposed, this method has no effect.
    // Public: Dispose all disposables added to this composite disposable.
    //
    // If this object has already been disposed, this method has no effect.
    /**
     * @return {?}
     */
    CompositeDisposable.prototype.dispose = 
    // Public: Dispose all disposables added to this composite disposable.
    //
    // If this object has already been disposed, this method has no effect.
    /**
     * @return {?}
     */
    function () {
        if (!this.disposed) {
            this.disposed = true;
            this.disposables.forEach(function (disposable) { return disposable.dispose(); });
            this.disposables = null;
        }
    };
    //////
    /// Section: Managing Disposables
    //////
    // Public: Add disposables to be disposed when the composite is disposed.
    //
    // If this object has already been disposed, this method has no effect.
    //
    // * `...disposables` {Disposable} instances or any objects with `.dispose()`
    //   methods.
    //////
    /// Section: Managing Disposables
    //////
    // Public: Add disposables to be disposed when the composite is disposed.
    //
    // If this object has already been disposed, this method has no effect.
    //
    // * `...disposables` {Disposable} instances or any objects with `.dispose()`
    //   methods.
    /**
     * @param {...?} disposables
     * @return {?}
     */
    CompositeDisposable.prototype.add = 
    //////
    /// Section: Managing Disposables
    //////
    // Public: Add disposables to be disposed when the composite is disposed.
    //
    // If this object has already been disposed, this method has no effect.
    //
    // * `...disposables` {Disposable} instances or any objects with `.dispose()`
    //   methods.
    /**
     * @param {...?} disposables
     * @return {?}
     */
    function () {
        var disposables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            disposables[_i] = arguments[_i];
        }
        var e_1, _a;
        if (!this.disposed) {
            try {
                for (var disposables_1 = __values(disposables), disposables_1_1 = disposables_1.next(); !disposables_1_1.done; disposables_1_1 = disposables_1.next()) {
                    var disposable = disposables_1_1.value;
                    if (this.assertDisposable(disposable)) {
                        this.disposables.add(disposable);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (disposables_1_1 && !disposables_1_1.done && (_a = disposables_1.return)) _a.call(disposables_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    // Public: Remove a previously added disposable.
    //
    // * `disposable` {Disposable} instance or any object with a `.dispose()`
    //   method.
    // Public: Remove a previously added disposable.
    //
    // * `disposable` {Disposable} instance or any object with a `.dispose()`
    //   method.
    /**
     * @param {?} disposable
     * @return {?}
     */
    CompositeDisposable.prototype.remove = 
    // Public: Remove a previously added disposable.
    //
    // * `disposable` {Disposable} instance or any object with a `.dispose()`
    //   method.
    /**
     * @param {?} disposable
     * @return {?}
     */
    function (disposable) {
        if (!this.disposed) {
            this.disposables.delete(disposable);
        }
    };
    // Public: Alias to {CompositeDisposable::remove}
    // Public: Alias to {CompositeDisposable::remove}
    /**
     * @param {?} disposable
     * @return {?}
     */
    CompositeDisposable.prototype.delete = 
    // Public: Alias to {CompositeDisposable::remove}
    /**
     * @param {?} disposable
     * @return {?}
     */
    function (disposable) {
        this.remove(disposable);
    };
    // Public: Clear all disposables. They will not be disposed by the next call
    // to dispose.
    // Public: Clear all disposables. They will not be disposed by the next call
    // to dispose.
    /**
     * @return {?}
     */
    CompositeDisposable.prototype.clear = 
    // Public: Clear all disposables. They will not be disposed by the next call
    // to dispose.
    /**
     * @return {?}
     */
    function () {
        if (!this.disposed) {
            this.disposables.clear();
        }
    };
    /**
     * @param {?} disposable
     * @return {?}
     */
    CompositeDisposable.prototype.assertDisposable = /**
     * @param {?} disposable
     * @return {?}
     */
    function (disposable) {
        if (!Disposable.isDisposable(disposable)) {
            throw new TypeError('Arguments to CompositeDisposable.add must have a .dispose() method');
        }
        return true;
    };
    return CompositeDisposable;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: Utility class to be used when implementing event-based APIs that
// allows for handlers registered via `::on` to be invoked with calls to
// `::emit`. Instances of this class are intended to be used internally by
// classes that expose an event-based API.
//
// For example:
//
// ```coffee
// class User
//   constructor: ->
//     @emitter = new Emitter
//
//   onDidChangeName: (callback) ->
//     @emitter.on 'did-change-name', callback
//
//   setName: (name) ->
//     if name isnt @name
//       @name = name
//       @emitter.emit 'did-change-name', name
//     @name
// ```
var Emitter = /** @class */ (function () {
    //////
    /// Section: Construction and Destruction
    //////
    // Public: Construct an emitter.
    //
    // ```coffee
    // @emitter = new Emitter()
    // ```
    function Emitter() {
        this.disposed = false;
        this.clear();
    }
    /**
     * @param {?} exceptionHandler
     * @return {?}
     */
    Emitter.onEventHandlerException = /**
     * @param {?} exceptionHandler
     * @return {?}
     */
    function (exceptionHandler) {
        var _this = this;
        this.dispatch = this.simpleDispatch;
        if (this.exceptionHandlers.length === 0) {
            this.dispatch = this.exceptionHandlingDispatch;
        }
        this.exceptionHandlers.push(exceptionHandler);
        return new Disposable(function () {
            _this.exceptionHandlers.splice(_this.exceptionHandlers.indexOf(exceptionHandler), 1);
            if (_this.exceptionHandlers.length === 0) {
                return _this.dispatch = _this.simpleDispatch;
            }
        });
    };
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    Emitter.simpleDispatch = /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    function (handler, value) {
        return handler(value);
    };
    /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    Emitter.exceptionHandlingDispatch = /**
     * @param {?} handler
     * @param {?} value
     * @return {?}
     */
    function (handler, value) {
        try {
            return handler(value);
        }
        catch (exception) {
            return this.exceptionHandlers.map(function (exceptionHandler) { return exceptionHandler(exception); });
        }
    };
    // Public: Clear out any existing subscribers.
    // Public: Clear out any existing subscribers.
    /**
     * @return {?}
     */
    Emitter.prototype.clear = 
    // Public: Clear out any existing subscribers.
    /**
     * @return {?}
     */
    function () {
        if (this.subscriptions) {
            this.subscriptions.dispose();
        }
        this.subscriptions = new CompositeDisposable();
        return this.handlersByEventName = {};
    };
    // Public: Unsubscribe all handlers.
    // Public: Unsubscribe all handlers.
    /**
     * @return {?}
     */
    Emitter.prototype.dispose = 
    // Public: Unsubscribe all handlers.
    /**
     * @return {?}
     */
    function () {
        this.subscriptions.dispose();
        this.handlersByEventName = null;
        this.disposed = true;
    };
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    Emitter.prototype.on = 
    //////
    /// Section: Event Subscription
    //////
    // Public: Register the given handler function to be invoked whenever events by
    // the given name are emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    function (eventName, handler, unshift) {
        var _this = this;
        if (unshift === void 0) { unshift = false; }
        if (this.disposed) {
            throw new Error('Emitter has been disposed');
        }
        if (typeof handler !== 'function') {
            throw new Error('Handler must be a function');
        }
        /** @type {?} */
        var currentHandlers = this.handlersByEventName[eventName];
        if (currentHandlers) {
            if (unshift) {
                this.handlersByEventName[eventName] = [handler].concat(currentHandlers);
            }
            else {
                this.handlersByEventName[eventName] = currentHandlers.concat(handler);
            }
        }
        else {
            this.handlersByEventName[eventName] = [handler];
        }
        // When the emitter is disposed, we want to dispose of all subscriptions.
        // However, we also need to stop tracking disposables when they're disposed
        // from outside, otherwise this class will hold references to all the
        // disposables it created (instead of just the active ones).
        /** @type {?} */
        var cleanup = new Disposable(function () {
            _this.subscriptions.remove(cleanup);
            return _this.off(eventName, handler);
        });
        this.subscriptions.add(cleanup);
        return cleanup;
    };
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    Emitter.prototype.once = 
    // Public: Register the given handler function to be invoked the next time an
    // events with the given name is emitted via {::emit}.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @param {?=} unshift
     * @return {?}
     */
    function (eventName, handler, unshift) {
        if (unshift === void 0) { unshift = false; }
        /** @type {?} */
        var disposable;
        /** @type {?} */
        var wrapped = function (value) {
            disposable.dispose();
            handler(value);
        };
        disposable = this.on(eventName, wrapped, unshift);
        return disposable;
    };
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    Emitter.prototype.preempt = 
    // Public: Register the given handler function to be invoked *before* all
    // other handlers existing at the time of subscription whenever events by the
    // given name are emitted via {::emit}.
    //
    // Use this method when you need to be the first to handle a given event. This
    // could be required when a data structure in a parent object needs to be
    // updated before third-party event handlers registered on a child object via a
    // public API are invoked. Your handler could itself be preempted via
    // subsequent calls to this method, but this can be controlled by keeping
    // methods based on `::preempt` private.
    //
    // * `eventName` {String} naming the event that you want to invoke the handler
    //   when emitted.
    // * `handler` {Function} to invoke when {::emit} is called with the given
    //   event name.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} eventName
     * @param {?} handler
     * @return {?}
     */
    function (eventName, handler) {
        this.on(eventName, handler, true);
    };
    // Private: Used by the disposable.
    // Private: Used by the disposable.
    /**
     * @param {?} eventName
     * @param {?} handlerToRemove
     * @return {?}
     */
    Emitter.prototype.off = 
    // Private: Used by the disposable.
    /**
     * @param {?} eventName
     * @param {?} handlerToRemove
     * @return {?}
     */
    function (eventName, handlerToRemove) {
        var e_1, _a;
        if (this.disposed) {
            return;
        }
        /** @type {?} */
        var oldHandlers = this.handlersByEventName[eventName];
        if (oldHandlers) {
            /** @type {?} */
            var newHandlers = [];
            try {
                for (var oldHandlers_1 = __values(oldHandlers), oldHandlers_1_1 = oldHandlers_1.next(); !oldHandlers_1_1.done; oldHandlers_1_1 = oldHandlers_1.next()) {
                    var handler = oldHandlers_1_1.value;
                    if (handler !== handlerToRemove) {
                        newHandlers.push(handler);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (oldHandlers_1_1 && !oldHandlers_1_1.done && (_a = oldHandlers_1.return)) _a.call(oldHandlers_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (newHandlers.length > 0) {
                this.handlersByEventName[eventName] = newHandlers;
            }
            else {
                delete this.handlersByEventName[eventName];
            }
        }
    };
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    Emitter.prototype.emit = 
    //////
    /// Section: Event Emission
    //////
    // Public: Invoke handlers registered via {::on} for the given event name.
    //
    // * `eventName` The name of the event to emit. Handlers registered with {::on}
    //   for the same name will be invoked.
    // * `value` Callbacks will be invoked with this value as an argument.
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    function (eventName, value) {
        var e_2, _a;
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            var handlers = this.handlersByEventName[eventName];
            try {
                for (var handlers_1 = __values(handlers), handlers_1_1 = handlers_1.next(); !handlers_1_1.done; handlers_1_1 = handlers_1.next()) {
                    var handler = handlers_1_1.value;
                    Emitter.dispatch(handler, value);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (handlers_1_1 && !handlers_1_1.done && (_a = handlers_1.return)) _a.call(handlers_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    Emitter.prototype.emitAsync = /**
     * @param {?} eventName
     * @param {?} value
     * @return {?}
     */
    function (eventName, value) {
        var e_3, _a;
        if (this.handlersByEventName && this.handlersByEventName[eventName]) {
            /** @type {?} */
            var results = [];
            try {
                for (var _b = __values(this.handlersByEventName[eventName]), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var handler = _c.value;
                    results.push(Emitter.dispatch(handler, value));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return Promise.all(results).then(function () { });
        }
        return Promise.resolve();
    };
    /**
     * @return {?}
     */
    Emitter.prototype.getEventNames = /**
     * @return {?}
     */
    function () {
        return Object.keys(this.handlersByEventName);
    };
    /**
     * @param {?} eventName
     * @return {?}
     */
    Emitter.prototype.listenerCountForEventName = /**
     * @param {?} eventName
     * @return {?}
     */
    function (eventName) {
        return this.handlersByEventName && this.handlersByEventName[eventName] ? this.handlersByEventName[eventName].length : 0;
    };
    /**
     * @return {?}
     */
    Emitter.prototype.getTotalListenerCount = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = 0;
        for (var eventName in this.handlersByEventName) {
            if (this.handlersByEventName.hasOwnProperty(eventName)) {
                result += this.handlersByEventName[eventName].length;
            }
        }
        return result;
    };
    Emitter.exceptionHandlers = [];
    Emitter.dispatch = Emitter.simpleDispatch;
    return Emitter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// const Grim = require('grim')
// const {CompositeDisposable, Emitter} = require('event-kit')
// const PaneAxis = require('./pane-axis')
// const TextEditor = require('./text-editor')
// const PaneElement = require('./pane-element')
/** @type {?} */
var nextInstanceId$1 = 1;
var SaveCancelledError = /** @class */ (function (_super) {
    __extends(SaveCancelledError, _super);
    function SaveCancelledError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SaveCancelledError;
}(Error));
// Extended: A container for presenting content in the center of the workspace.
// Panes can contain multiple items, one of which is *active* at a given time.
// The view corresponding to the active item is displayed in the interface. In
// the default configuration, tabs are also displayed for each item.
//
// Each pane may also contain one *pending* item. When a pending item is added
// to a pane, it will replace the currently pending item, if any, instead of
// simply being added. In the default configuration, the text in the tab for
// pending items is shown in italics.
var 
// Extended: A container for presenting content in the center of the workspace.
// Panes can contain multiple items, one of which is *active* at a given time.
// The view corresponding to the active item is displayed in the interface. In
// the default configuration, tabs are also displayed for each item.
//
// Each pane may also contain one *pending* item. When a pending item is added
// to a pane, it will replace the currently pending item, if any, instead of
// simply being added. In the default configuration, the text in the tab for
// pending items is shown in italics.
Pane = /** @class */ (function () {
    function Pane(params) {
        this.alive = true;
        this.subscriptionsPerItem = new WeakMap();
        this.items = [];
        this.itemStack = [];
        this.container = null;
        this.setPendingItem = this.setPendingItem.bind(this);
        this.getPendingItem = this.getPendingItem.bind(this);
        this.clearPendingItem = this.clearPendingItem.bind(this);
        this.onItemDidTerminatePendingState = this.onItemDidTerminatePendingState.bind(this);
        this.saveItem = this.saveItem.bind(this);
        this.saveItemAs = this.saveItemAs.bind(this);
        this.id = params.id;
        if (this.id != null) {
            nextInstanceId$1 = Math.max(nextInstanceId$1, this.id + 1);
        }
        else {
            this.id = nextInstanceId$1++;
        }
        this.activeItem = params.activeItem;
        this.focused = params.focused != null ? params.focused : false;
        this.applicationDelegate = params.applicationDelegate;
        this.notificationManager = params.notificationManager;
        this.config = params.config;
        this.deserializerManager = params.deserializerManager;
        this.viewRegistry = params.viewRegistry;
        this.emitter = new Emitter();
        this.alive = true;
        this.subscriptionsPerItem = new WeakMap();
        this.items = [];
        this.itemStack = [];
        this.container = null;
        this.addItems((params.items || []).filter(function (item) { return item; }));
        if (!this.getActiveItem()) {
            this.setActiveItem(this.items[0]);
        }
        this.addItemsToStack(params.itemStackIndices || []);
        this.setFlexScale(params.flexScale || 1);
    }
    /**
     * @param {?} state
     * @param {?} __1
     * @return {?}
     */
    Pane.deserialize = /**
     * @param {?} state
     * @param {?} __1
     * @return {?}
     */
    function (state, _a) {
        var deserializers = _a.deserializers, applicationDelegate = _a.applicationDelegate, config = _a.config, notifications = _a.notifications, views = _a.views;
        var e_1, _b;
        var activeItemIndex = state.activeItemIndex;
        /** @type {?} */
        var activeItemURI = state.activeItemURI || state.activeItemUri;
        /** @type {?} */
        var items = [];
        try {
            for (var _c = __values(state.items), _d = _c.next(); !_d.done; _d = _c.next()) {
                var itemState = _d.value;
                /** @type {?} */
                var item = deserializers.deserialize(itemState);
                if (item) {
                    items.push(item);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        state.items = items;
        state.activeItem = items[activeItemIndex];
        if (!state.activeItem && activeItemURI) {
            state.activeItem = state.items.find(function (item) {
                return typeof item.getURI === 'function' && item.getURI() === activeItemURI;
            });
        }
        return new Pane(Object.assign(state, {
            deserializerManager: deserializers,
            notificationManager: notifications,
            viewRegistry: views,
            config: config,
            applicationDelegate: applicationDelegate
        }));
    };
    /**
     * @return {?}
     */
    Pane.prototype.inspect = /**
     * @return {?}
     */
    function () {
        return "Pane " + this.id;
    };
    /**
     * @return {?}
     */
    Pane.prototype.getElement = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    Pane.prototype.serialize = /**
     * @return {?}
     */
    function () {
        var e_2, _a;
        /** @type {?} */
        var itemsToBeSerialized = this.items.filter(function (item) { return item && typeof item.serialize === 'function'; });
        /** @type {?} */
        var itemStackIndices = [];
        try {
            for (var _b = __values(this.itemStack), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (typeof item.serialize === 'function') {
                    itemStackIndices.push(itemsToBeSerialized.indexOf(item));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        /** @type {?} */
        var activeItemIndex = itemsToBeSerialized.indexOf(this.activeItem);
        return {
            deserializer: 'Pane',
            id: this.id,
            items: itemsToBeSerialized.map(function (item) { return item.serialize(); }),
            itemStackIndices: itemStackIndices,
            activeItemIndex: activeItemIndex,
            focused: this.focused,
            flexScale: this.flexScale
        };
    };
    /**
     * @return {?}
     */
    Pane.prototype.getParent = /**
     * @return {?}
     */
    function () { return this.parent; };
    /**
     * @param {?} parent
     * @return {?}
     */
    Pane.prototype.setParent = /**
     * @param {?} parent
     * @return {?}
     */
    function (parent) {
        this.parent = parent;
    };
    /**
     * @return {?}
     */
    Pane.prototype.getContainer = /**
     * @return {?}
     */
    function () { return this.container; };
    /**
     * @param {?} container
     * @return {?}
     */
    Pane.prototype.setContainer = /**
     * @param {?} container
     * @return {?}
     */
    function (container) {
        if (container && container !== this.container) {
            this.container = container;
            container.didAddPane({ pane: this });
        }
    };
    // Private: Determine whether the given item is allowed to exist in this pane.
    //
    // * `item` the Item
    //
    // Returns a {Boolean}.
    // Private: Determine whether the given item is allowed to exist in this pane.
    //
    // * `item` the Item
    //
    // Returns a {Boolean}.
    /**
     * @param {?} item
     * @return {?}
     */
    Pane.prototype.isItemAllowed = 
    // Private: Determine whether the given item is allowed to exist in this pane.
    //
    // * `item` the Item
    //
    // Returns a {Boolean}.
    /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (typeof item.getAllowedLocations !== 'function') {
            return true;
        }
        else {
            return item.getAllowedLocations().includes(this.getContainer().getLocation());
        }
    };
    /**
     * @param {?} flexScale
     * @return {?}
     */
    Pane.prototype.setFlexScale = /**
     * @param {?} flexScale
     * @return {?}
     */
    function (flexScale) {
        this.flexScale = flexScale;
        return this.flexScale;
    };
    /**
     * @return {?}
     */
    Pane.prototype.getFlexScale = /**
     * @return {?}
     */
    function () { return this.flexScale; };
    /**
     * @return {?}
     */
    Pane.prototype.increaseSize = /**
     * @return {?}
     */
    function () { this.setFlexScale(this.getFlexScale() * 1.1); };
    /**
     * @return {?}
     */
    Pane.prototype.decreaseSize = /**
     * @return {?}
     */
    function () { this.setFlexScale(this.getFlexScale() / 1.1); };
    /*
    Section: Event Subscription
    */
    // Public: Invoke the given callback when the pane resizes
    //
    // The callback will be invoked when pane's flexScale property changes.
    // Use {::getFlexScale} to get the current value.
    //
    // * `callback` {Function} to be called when the pane is resized
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which '.dispose()' can be called to unsubscribe.
    /*
      Section: Event Subscription
      */
    // Public: Invoke the given callback when the pane resizes
    //
    // The callback will be invoked when pane's flexScale property changes.
    // Use {::getFlexScale} to get the current value.
    //
    // * `callback` {Function} to be called when the pane is resized
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which '.dispose()' can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidChangeFlexScale = /*
      Section: Event Subscription
      */
    // Public: Invoke the given callback when the pane resizes
    //
    // The callback will be invoked when pane's flexScale property changes.
    // Use {::getFlexScale} to get the current value.
    //
    // * `callback` {Function} to be called when the pane is resized
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which '.dispose()' can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback with the current and future values of
    // {::getFlexScale}.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::getFlexScale} property.
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback with the current and future values of
    // {::getFlexScale}.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::getFlexScale} property.
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.observeFlexScale = 
    // Public: Invoke the given callback with the current and future values of
    // {::getFlexScale}.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::getFlexScale} property.
    //   * `flexScale` {Number} representing the panes `flex-grow`; ability for a
    //     flex item to grow if necessary.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        callback(this.flexScale);
        return this.onDidChangeFlexScale(callback);
    };
    // Public: Invoke the given callback when the pane is activated.
    //
    // The given callback will be invoked whenever {::activate} is called on the
    // pane, even if it is already active at the time.
    //
    // * `callback` {Function} to be called when the pane is activated.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when the pane is activated.
    //
    // The given callback will be invoked whenever {::activate} is called on the
    // pane, even if it is already active at the time.
    //
    // * `callback` {Function} to be called when the pane is activated.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidActivate = 
    // Public: Invoke the given callback when the pane is activated.
    //
    // The given callback will be invoked whenever {::activate} is called on the
    // pane, even if it is already active at the time.
    //
    // * `callback` {Function} to be called when the pane is activated.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback before the pane is destroyed.
    //
    // * `callback` {Function} to be called before the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback before the pane is destroyed.
    //
    // * `callback` {Function} to be called before the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onWillDestroy = 
    // Public: Invoke the given callback before the pane is destroyed.
    //
    // * `callback` {Function} to be called before the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidDestroy = 
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback when the value of the {::isActive}
    // property changes.
    //
    // * `callback` {Function} to be called when the value of the {::isActive}
    //   property changes.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when the value of the {::isActive}
    // property changes.
    //
    // * `callback` {Function} to be called when the value of the {::isActive}
    //   property changes.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidChangeActive = 
    // Public: Invoke the given callback when the value of the {::isActive}
    // property changes.
    //
    // * `callback` {Function} to be called when the value of the {::isActive}
    //   property changes.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        var _this = this;
        return this.container.onDidChangeActivePane(function (activePane) {
            /** @type {?} */
            var isActive = _this === activePane;
            callback(isActive);
        });
    };
    // Public: Invoke the given callback with the current and future values of the
    // {::isActive} property.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::isActive} property.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback with the current and future values of the
    // {::isActive} property.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::isActive} property.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.observeActive = 
    // Public: Invoke the given callback with the current and future values of the
    // {::isActive} property.
    //
    // * `callback` {Function} to be called with the current and future values of
    //   the {::isActive} property.
    //   * `active` {Boolean} indicating whether the pane is active.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        callback(this.isActive());
        return this.onDidChangeActive(callback);
    };
    // Public: Invoke the given callback when an item is added to the pane.
    //
    // * `callback` {Function} to be called with when items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `index` {Number} indicating where the item is located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when an item is added to the pane.
    //
    // * `callback` {Function} to be called with when items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `index` {Number} indicating where the item is located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidAddItem = 
    // Public: Invoke the given callback when an item is added to the pane.
    //
    // * `callback` {Function} to be called with when items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `index` {Number} indicating where the item is located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-add-item', callback);
    };
    // Public: Invoke the given callback when an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `index` {Number} indicating where the item was located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `index` {Number} indicating where the item was located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidRemoveItem = 
    // Public: Invoke the given callback when an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `index` {Number} indicating where the item was located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-remove-item', callback);
    };
    // Public: Invoke the given callback before an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The pane item to be removed.
    //     * `index` {Number} indicating where the item is located.
    // Public: Invoke the given callback before an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The pane item to be removed.
    //     * `index` {Number} indicating where the item is located.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onWillRemoveItem = 
    // Public: Invoke the given callback before an item is removed from the pane.
    //
    // * `callback` {Function} to be called with when items are removed.
    //   * `event` {Object} with the following keys:
    //     * `item` The pane item to be removed.
    //     * `index` {Number} indicating where the item is located.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback when an item is moved within the pane.
    //
    // * `callback` {Function} to be called with when items are moved.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `oldIndex` {Number} indicating where the item was located.
    //     * `newIndex` {Number} indicating where the item is now located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when an item is moved within the pane.
    //
    // * `callback` {Function} to be called with when items are moved.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `oldIndex` {Number} indicating where the item was located.
    //     * `newIndex` {Number} indicating where the item is now located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidMoveItem = 
    // Public: Invoke the given callback when an item is moved within the pane.
    //
    // * `callback` {Function} to be called with when items are moved.
    //   * `event` {Object} with the following keys:
    //     * `item` The removed pane item.
    //     * `oldIndex` {Number} indicating where the item was located.
    //     * `newIndex` {Number} indicating where the item is now located.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback with all current and future items.
    //
    // * `callback` {Function} to be called with current and future items.
    //   * `item` An item that is present in {::getItems} at the time of
    //     subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback with all current and future items.
    //
    // * `callback` {Function} to be called with current and future items.
    //   * `item` An item that is present in {::getItems} at the time of
    //     subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.observeItems = 
    // Public: Invoke the given callback with all current and future items.
    //
    // * `callback` {Function} to be called with current and future items.
    //   * `item` An item that is present in {::getItems} at the time of
    //     subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        var e_3, _a;
        try {
            for (var _b = __values(this.getItems()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                callback(item);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return this.onDidAddItem(function (_a) {
            var item = _a.item;
            return callback(item);
        });
    };
    // 公有方法： 当{::getActiveItem}值变换前调用。
    // 公有方法： 当{::getActiveItem}值变换前调用。
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDoingChangeActiveItem = 
    // 公有方法： 当{::getActiveItem}值变换前调用。
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('doing-change-active-item', callback);
    };
    // Public: Invoke the given callback when the value of {::getActiveItem}
    // changes.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when the value of {::getActiveItem}
    // changes.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDidChangeActiveItem = 
    // Public: Invoke the given callback when the value of {::getActiveItem}
    // changes.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-change-active-item', callback);
    };
    // Public: Invoke the given callback when {::activateNextRecentlyUsedItem}
    // has been called, either initiating or continuing a forward MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `nextRecentlyUsedItem` The next MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when {::activateNextRecentlyUsedItem}
    // has been called, either initiating or continuing a forward MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `nextRecentlyUsedItem` The next MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onChooseNextMRUItem = 
    // Public: Invoke the given callback when {::activateNextRecentlyUsedItem}
    // has been called, either initiating or continuing a forward MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `nextRecentlyUsedItem` The next MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback when {::activatePreviousRecentlyUsedItem}
    // has been called, either initiating or continuing a reverse MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `previousRecentlyUsedItem` The previous MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when {::activatePreviousRecentlyUsedItem}
    // has been called, either initiating or continuing a reverse MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `previousRecentlyUsedItem` The previous MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onChooseLastMRUItem = 
    // Public: Invoke the given callback when {::activatePreviousRecentlyUsedItem}
    // has been called, either initiating or continuing a reverse MRU traversal of
    // pane items.
    //
    // * `callback` {Function} to be called with when the active item changes.
    //   * `previousRecentlyUsedItem` The previous MRU item, now being set active
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback when {::moveActiveItemToTopOfStack}
    // has been called, terminating an MRU traversal of pane items and moving the
    // current active item to the top of the stack. Typically bound to a modifier
    // (e.g. CTRL) key up event.
    //
    // * `callback` {Function} to be called with when the MRU traversal is done.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when {::moveActiveItemToTopOfStack}
    // has been called, terminating an MRU traversal of pane items and moving the
    // current active item to the top of the stack. Typically bound to a modifier
    // (e.g. CTRL) key up event.
    //
    // * `callback` {Function} to be called with when the MRU traversal is done.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onDoneChoosingMRUItem = 
    // Public: Invoke the given callback when {::moveActiveItemToTopOfStack}
    // has been called, terminating an MRU traversal of pane items and moving the
    // current active item to the top of the stack. Typically bound to a modifier
    // (e.g. CTRL) key up event.
    //
    // * `callback` {Function} to be called with when the MRU traversal is done.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Invoke the given callback with the current and future values of
    // {::getActiveItem}.
    //
    // * `callback` {Function} to be called with the current and future active
    //   items.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback with the current and future values of
    // {::getActiveItem}.
    //
    // * `callback` {Function} to be called with the current and future active
    //   items.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.observeActiveItem = 
    // Public: Invoke the given callback with the current and future values of
    // {::getActiveItem}.
    //
    // * `callback` {Function} to be called with the current and future active
    //   items.
    //   * `activeItem` The current active item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        callback(this.getActiveItem());
        return this.onDidChangeActiveItem(callback);
    };
    // Public: Invoke the given callback before items are destroyed.
    //
    // * `callback` {Function} to be called before items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item that will be destroyed.
    //     * `index` The location of the item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to
    // unsubscribe.
    // Public: Invoke the given callback before items are destroyed.
    //
    // * `callback` {Function} to be called before items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item that will be destroyed.
    //     * `index` The location of the item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to
    // unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onWillDestroyItem = 
    // Public: Invoke the given callback before items are destroyed.
    //
    // * `callback` {Function} to be called before items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item that will be destroyed.
    //     * `index` The location of the item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to
    // unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Called by the view layer to indicate that the pane has gained focus.
    // Called by the view layer to indicate that the pane has gained focus.
    /**
     * @return {?}
     */
    Pane.prototype.focus = 
    // Called by the view layer to indicate that the pane has gained focus.
    /**
     * @return {?}
     */
    function () {
        this.focused = true;
        return this.activate();
    };
    // Called by the view layer to indicate that the pane has lost focus.
    // Called by the view layer to indicate that the pane has lost focus.
    /**
     * @return {?}
     */
    Pane.prototype.blur = 
    // Called by the view layer to indicate that the pane has lost focus.
    /**
     * @return {?}
     */
    function () {
        this.focused = false;
        return true; // if this is called from an event handler, don't cancel it
    };
    /**
     * @return {?}
     */
    Pane.prototype.isFocused = /**
     * @return {?}
     */
    function () { return this.focused; };
    /**
     * @return {?}
     */
    Pane.prototype.getPanes = /**
     * @return {?}
     */
    function () { return [this]; };
    /**
     * @param {?} item
     * @return {?}
     */
    Pane.prototype.unsubscribeFromItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var subscription = this.subscriptionsPerItem.get(item);
        if (subscription) {
            subscription.dispose();
            this.subscriptionsPerItem.delete(item);
        }
    };
    /*
    Section: Items
    */
    // Public: Get the items in this pane.
    //
    // Returns an {Array} of items.
    /*
      Section: Items
      */
    // Public: Get the items in this pane.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    Pane.prototype.getItems = /*
      Section: Items
      */
    // Public: Get the items in this pane.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    function () {
        return this.items.slice();
    };
    // Public: Get the active pane item in this pane.
    //
    // Returns a pane item.
    // Public: Get the active pane item in this pane.
    //
    // Returns a pane item.
    /**
     * @return {?}
     */
    Pane.prototype.getActiveItem = 
    // Public: Get the active pane item in this pane.
    //
    // Returns a pane item.
    /**
     * @return {?}
     */
    function () { return this.activeItem; };
    /**
     * @param {?=} activeItem
     * @param {?=} options
     * @return {?}
     */
    Pane.prototype.setActiveItem = /**
     * @param {?=} activeItem
     * @param {?=} options
     * @return {?}
     */
    function (activeItem, options) {
        /** @type {?} */
        var modifyStack = options && options.modifyStack;
        if (activeItem !== this.activeItem) {
            if (modifyStack !== false) {
                this.addItemToStack(activeItem);
            }
            this.emitter.emit('doing-change-active-item', this.activeItem);
            this.activeItem = activeItem;
            this.emitter.emit('did-change-active-item', this.activeItem);
            if (this.container) {
                this.container.didChangeActiveItemOnPane(this, this.activeItem);
            }
        }
        return this.activeItem;
    };
    // Build the itemStack after deserializing
    // Build the itemStack after deserializing
    /**
     * @param {?} itemStackIndices
     * @return {?}
     */
    Pane.prototype.addItemsToStack = 
    // Build the itemStack after deserializing
    /**
     * @param {?} itemStackIndices
     * @return {?}
     */
    function (itemStackIndices) {
        var e_4, _a;
        if (this.items.length > 0) {
            if (itemStackIndices.length !== this.items.length || itemStackIndices.includes(-1)) {
                itemStackIndices = this.items.map(function (item, i) { return i; });
            }
            try {
                for (var itemStackIndices_1 = __values(itemStackIndices), itemStackIndices_1_1 = itemStackIndices_1.next(); !itemStackIndices_1_1.done; itemStackIndices_1_1 = itemStackIndices_1.next()) {
                    var itemIndex = itemStackIndices_1_1.value;
                    this.addItemToStack(this.items[itemIndex]);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (itemStackIndices_1_1 && !itemStackIndices_1_1.done && (_a = itemStackIndices_1.return)) _a.call(itemStackIndices_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
    };
    // Add item (or move item) to the end of the itemStack
    // Add item (or move item) to the end of the itemStack
    /**
     * @param {?} newItem
     * @return {?}
     */
    Pane.prototype.addItemToStack = 
    // Add item (or move item) to the end of the itemStack
    /**
     * @param {?} newItem
     * @return {?}
     */
    function (newItem) {
        if (newItem == null) {
            return;
        }
        /** @type {?} */
        var index = this.itemStack.indexOf(newItem);
        if (index !== -1) {
            this.itemStack.splice(index, 1);
        }
        return this.itemStack.push(newItem);
    };
    // Public: Return the item at the given index.
    //
    // * `index` {Number}
    //
    // Returns an item or `null` if no item exists at the given index.
    // Public: Return the item at the given index.
    //
    // * `index` {Number}
    //
    // Returns an item or `null` if no item exists at the given index.
    /**
     * @param {?} index
     * @return {?}
     */
    Pane.prototype.itemAtIndex = 
    // Public: Return the item at the given index.
    //
    // * `index` {Number}
    //
    // Returns an item or `null` if no item exists at the given index.
    /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.items[index];
    };
    // Makes the next item in the itemStack active.
    // Makes the next item in the itemStack active.
    /**
     * @return {?}
     */
    Pane.prototype.activateNextRecentlyUsedItem = 
    // Makes the next item in the itemStack active.
    /**
     * @return {?}
     */
    function () {
        if (this.items.length > 1) {
            if (this.itemStackIndex == null) {
                this.itemStackIndex = this.itemStack.length - 1;
            }
            if (this.itemStackIndex === 0) {
                this.itemStackIndex = this.itemStack.length;
            }
            this.itemStackIndex--;
            /** @type {?} */
            var nextRecentlyUsedItem = this.itemStack[this.itemStackIndex];
            this.setActiveItem(nextRecentlyUsedItem, { modifyStack: false });
        }
    };
    // Makes the previous item in the itemStack active.
    // Makes the previous item in the itemStack active.
    /**
     * @return {?}
     */
    Pane.prototype.activatePreviousRecentlyUsedItem = 
    // Makes the previous item in the itemStack active.
    /**
     * @return {?}
     */
    function () {
        if (this.items.length > 1) {
            if (this.itemStackIndex + 1 === this.itemStack.length || this.itemStackIndex == null) {
                this.itemStackIndex = -1;
            }
            this.itemStackIndex++;
            /** @type {?} */
            var previousRecentlyUsedItem = this.itemStack[this.itemStackIndex];
            this.setActiveItem(previousRecentlyUsedItem, { modifyStack: false });
        }
    };
    // Moves the active item to the end of the itemStack once the ctrl key is lifted
    // Moves the active item to the end of the itemStack once the ctrl key is lifted
    /**
     * @return {?}
     */
    Pane.prototype.moveActiveItemToTopOfStack = 
    // Moves the active item to the end of the itemStack once the ctrl key is lifted
    /**
     * @return {?}
     */
    function () {
        delete this.itemStackIndex;
        this.addItemToStack(this.activeItem);
    };
    // Public: Makes the next item active.
    // Public: Makes the next item active.
    /**
     * @return {?}
     */
    Pane.prototype.activateNextItem = 
    // Public: Makes the next item active.
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this.getActiveItemIndex();
        if (index < (this.items.length - 1)) {
            this.activateItemAtIndex(index + 1);
        }
        else {
            this.activateItemAtIndex(0);
        }
    };
    // Public: Makes the previous item active.
    // Public: Makes the previous item active.
    /**
     * @return {?}
     */
    Pane.prototype.activatePreviousItem = 
    // Public: Makes the previous item active.
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this.getActiveItemIndex();
        if (index > 0) {
            this.activateItemAtIndex(index - 1);
        }
        else {
            this.activateItemAtIndex(this.items.length - 1);
        }
    };
    /**
     * @return {?}
     */
    Pane.prototype.activateLastItem = /**
     * @return {?}
     */
    function () {
        this.activateItemAtIndex(this.items.length - 1);
    };
    // Public: Move the active tab to the right.
    // Public: Move the active tab to the right.
    /**
     * @return {?}
     */
    Pane.prototype.moveItemRight = 
    // Public: Move the active tab to the right.
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this.getActiveItemIndex();
        /** @type {?} */
        var rightItemIndex = index + 1;
        if (rightItemIndex <= this.items.length - 1) {
            this.moveItem(this.getActiveItem(), rightItemIndex);
        }
    };
    // Public: Move the active tab to the left
    // Public: Move the active tab to the left
    /**
     * @return {?}
     */
    Pane.prototype.moveItemLeft = 
    // Public: Move the active tab to the left
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this.getActiveItemIndex();
        /** @type {?} */
        var leftItemIndex = index - 1;
        if (leftItemIndex >= 0) {
            return this.moveItem(this.getActiveItem(), leftItemIndex);
        }
    };
    // Public: Get the index of the active item.
    //
    // Returns a {Number}.
    // Public: Get the index of the active item.
    //
    // Returns a {Number}.
    /**
     * @return {?}
     */
    Pane.prototype.getActiveItemIndex = 
    // Public: Get the index of the active item.
    //
    // Returns a {Number}.
    /**
     * @return {?}
     */
    function () {
        return this.items.indexOf(this.activeItem);
    };
    // Public: Activate the item at the given index.
    //
    // * `index` {Number}
    // Public: Activate the item at the given index.
    //
    // * `index` {Number}
    /**
     * @param {?} index
     * @return {?}
     */
    Pane.prototype.activateItemAtIndex = 
    // Public: Activate the item at the given index.
    //
    // * `index` {Number}
    /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var item = this.itemAtIndex(index) || this.getActiveItem();
        return this.setActiveItem(item);
    };
    // Public: Make the given item *active*, causing it to be displayed by
    // the pane's view.
    //
    // * `item` The item to activate
    // * `options` (optional) {Object}
    //   * `pending` (optional) {Boolean} indicating that the item should be added
    //     in a pending state if it does not yet exist in the pane. Existing pending
    //     items in a pane are replaced with new pending items when they are opened.
    // Public: Make the given item *active*, causing it to be displayed by
    // the pane's view.
    //
    // * `item` The item to activate
    // * `options` (optional) {Object}
    //   * `pending` (optional) {Boolean} indicating that the item should be added
    //     in a pending state if it does not yet exist in the pane. Existing pending
    //     items in a pane are replaced with new pending items when they are opened.
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    Pane.prototype.activateItem = 
    // Public: Make the given item *active*, causing it to be displayed by
    // the pane's view.
    //
    // * `item` The item to activate
    // * `options` (optional) {Object}
    //   * `pending` (optional) {Boolean} indicating that the item should be added
    //     in a pending state if it does not yet exist in the pane. Existing pending
    //     items in a pane are replaced with new pending items when they are opened.
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    function (item, options) {
        if (options === void 0) { options = {}; }
        if (item) {
            /** @type {?} */
            var index = (this.getPendingItem() === this.activeItem)
                ? this.getActiveItemIndex()
                : this.getActiveItemIndex() + 1;
            this.addItem(item, Object.assign({}, options, { index: index }));
            this.setActiveItem(item);
        }
    };
    // Public: Add the given item to the pane.
    //
    // * `item` The item to add. It can be a model with an associated view or a
    //   view.
    // * `options` (optional) {Object}
    //   * `index` (optional) {Number} indicating the index at which to add the item.
    //     If omitted, the item is added after the current active item.
    //   * `pending` (optional) {Boolean} indicating that the item should be
    //     added in a pending state. Existing pending items in a pane are replaced with
    //     new pending items when they are opened.
    //
    // Returns the added item.
    // Public: Add the given item to the pane.
    //
    // * `item` The item to add. It can be a model with an associated view or a
    //   view.
    // * `options` (optional) {Object}
    //   * `index` (optional) {Number} indicating the index at which to add the item.
    //     If omitted, the item is added after the current active item.
    //   * `pending` (optional) {Boolean} indicating that the item should be
    //     added in a pending state. Existing pending items in a pane are replaced with
    //     new pending items when they are opened.
    //
    // Returns the added item.
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    Pane.prototype.addItem = 
    // Public: Add the given item to the pane.
    //
    // * `item` The item to add. It can be a model with an associated view or a
    //   view.
    // * `options` (optional) {Object}
    //   * `index` (optional) {Number} indicating the index at which to add the item.
    //     If omitted, the item is added after the current active item.
    //   * `pending` (optional) {Boolean} indicating that the item should be
    //     added in a pending state. Existing pending items in a pane are replaced with
    //     new pending items when they are opened.
    //
    // Returns the added item.
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    function (item, options) {
        if (options === void 0) { options = {}; }
        // Backward compat with old API:
        //   addItem(item, index=@getActiveItemIndex() + 1)
        if (typeof options === 'number') {
            options = { index: options };
        }
        /** @type {?} */
        var index = options.index != null ? options.index : this.getActiveItemIndex() + 1;
        /** @type {?} */
        var moved = options.moved != null ? options.moved : false;
        /** @type {?} */
        var pending = options.pending != null ? options.pending : false;
        if (!item || typeof item !== 'object') {
            throw new Error("Pane items must be objects. Attempted to add item " + item + ".");
        }
        if (typeof item.isDestroyed === 'function' && item.isDestroyed()) {
            throw new Error("Adding a pane item with URI\n      '" + (typeof item.getURI === 'function' && item.getURI()) + "' that has already been destroyed");
        }
        if (this.items.find(function (it) { return it === item; })) {
            return;
        }
        if (typeof item.onDidDestroy === 'function') ;
        this.items.splice(index, 0, item);
        /** @type {?} */
        var lastPendingItem = this.getPendingItem();
        /** @type {?} */
        var replacingPendingItem = lastPendingItem != null && !moved;
        if (replacingPendingItem) {
            this.pendingItem = null;
        }
        if (pending) {
            this.setPendingItem(item);
        }
        this.emitter.emit('did-add-item', { item: item, index: index, moved: moved });
        if (!moved) {
            if (this.container) {
                this.container.didAddPaneItem(item, this, index);
            }
        }
        if (replacingPendingItem) {
            this.destroyItem(lastPendingItem);
        }
        if (!this.getActiveItem()) {
            this.setActiveItem(item);
        }
        return item;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    Pane.prototype.setPendingItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.pendingItem !== item) {
            /** @type {?} */
            var mostRecentPendingItem = this.pendingItem;
            this.pendingItem = item;
        }
    };
    /**
     * @return {?}
     */
    Pane.prototype.getPendingItem = /**
     * @return {?}
     */
    function () {
        return this.pendingItem || null;
    };
    /**
     * @return {?}
     */
    Pane.prototype.clearPendingItem = /**
     * @return {?}
     */
    function () {
        this.setPendingItem(null);
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    Pane.prototype.onItemDidTerminatePendingState = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Public: Add the given items to the pane.
    //
    // * `items` An {Array} of items to add. Items can be views or models with
    //   associated views. Any objects that are already present in the pane's
    //   current items will not be added again.
    // * `index` (optional) {Number} index at which to add the items. If omitted,
    //   the item is #   added after the current active item.
    //
    // Returns an {Array} of added items.
    // Public: Add the given items to the pane.
    //
    // * `items` An {Array} of items to add. Items can be views or models with
    //   associated views. Any objects that are already present in the pane's
    //   current items will not be added again.
    // * `index` (optional) {Number} index at which to add the items. If omitted,
    //   the item is #   added after the current active item.
    //
    // Returns an {Array} of added items.
    /**
     * @param {?} items
     * @param {?=} index
     * @return {?}
     */
    Pane.prototype.addItems = 
    // Public: Add the given items to the pane.
    //
    // * `items` An {Array} of items to add. Items can be views or models with
    //   associated views. Any objects that are already present in the pane's
    //   current items will not be added again.
    // * `index` (optional) {Number} index at which to add the items. If omitted,
    //   the item is #   added after the current active item.
    //
    // Returns an {Array} of added items.
    /**
     * @param {?} items
     * @param {?=} index
     * @return {?}
     */
    function (items, index) {
        var _this = this;
        if (index === void 0) { index = this.getActiveItemIndex() + 1; }
        items = items.filter(function (item) { return !_this.items.find(function (it) { return it === item; }); });
        for (var i = 0; i < items.length; i++) {
            /** @type {?} */
            var item = items[i];
            this.addItem(item, { index: index + i });
        }
        return items;
    };
    /**
     * @param {?} item
     * @param {?=} moved
     * @return {?}
     */
    Pane.prototype.removeItem = /**
     * @param {?} item
     * @param {?=} moved
     * @return {?}
     */
    function (item, moved) {
        if (moved === void 0) { moved = false; }
        /** @type {?} */
        var index = this.items.indexOf(item);
        if (index === -1) {
            return;
        }
        if (this.getPendingItem() === item) {
            this.pendingItem = null;
        }
        this.removeItemFromStack(item);
        // this.emitter.emit('will-remove-item', {item, index, destroyed: !moved, moved});
        this.unsubscribeFromItem(item);
        if (item === this.activeItem) {
            if (this.items.length === 1) {
                this.setActiveItem(undefined);
            }
            else if (index === 0) {
                this.activateNextItem();
            }
            else {
                this.activatePreviousItem();
            }
        }
        this.items.splice(index, 1);
        this.emitter.emit('did-remove-item', { item: item, index: index, destroyed: !moved, moved: moved });
        if (!moved && this.container) {
            this.container.didDestroyPaneItem({ item: item, index: index, pane: this });
        }
        if (this.items.length === 0 && this.config && this.config.get && this.config.get('core.destroyEmptyPanes')) {
            this.destroy();
        }
    };
    // Remove the given item from the itemStack.
    //
    // * `item` The item to remove.
    // * `index` {Number} indicating the index to which to remove the item from the itemStack.
    // Remove the given item from the itemStack.
    //
    // * `item` The item to remove.
    // * `index` {Number} indicating the index to which to remove the item from the itemStack.
    /**
     * @param {?} item
     * @return {?}
     */
    Pane.prototype.removeItemFromStack = 
    // Remove the given item from the itemStack.
    //
    // * `item` The item to remove.
    // * `index` {Number} indicating the index to which to remove the item from the itemStack.
    /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var index = this.itemStack.indexOf(item);
        if (index !== -1) {
            this.itemStack.splice(index, 1);
        }
    };
    // Public: Move the given item to the given index.
    //
    // * `item` The item to move.
    // * `index` {Number} indicating the index to which to move the item.
    // Public: Move the given item to the given index.
    //
    // * `item` The item to move.
    // * `index` {Number} indicating the index to which to move the item.
    /**
     * @param {?} item
     * @param {?} newIndex
     * @return {?}
     */
    Pane.prototype.moveItem = 
    // Public: Move the given item to the given index.
    //
    // * `item` The item to move.
    // * `index` {Number} indicating the index to which to move the item.
    /**
     * @param {?} item
     * @param {?} newIndex
     * @return {?}
     */
    function (item, newIndex) {
        /** @type {?} */
        var oldIndex = this.items.indexOf(item);
        this.items.splice(oldIndex, 1);
        this.items.splice(newIndex, 0, item);
    };
    // Public: Move the given item to the given index on another pane.
    //
    // * `item` The item to move.
    // * `pane` {Pane} to which to move the item.
    // * `index` {Number} indicating the index to which to move the item in the
    //   given pane.
    // Public: Move the given item to the given index on another pane.
    //
    // * `item` The item to move.
    // * `pane` {Pane} to which to move the item.
    // * `index` {Number} indicating the index to which to move the item in the
    //   given pane.
    /**
     * @param {?=} item
     * @param {?=} pane
     * @param {?=} index
     * @return {?}
     */
    Pane.prototype.moveItemToPane = 
    // Public: Move the given item to the given index on another pane.
    //
    // * `item` The item to move.
    // * `pane` {Pane} to which to move the item.
    // * `index` {Number} indicating the index to which to move the item in the
    //   given pane.
    /**
     * @param {?=} item
     * @param {?=} pane
     * @param {?=} index
     * @return {?}
     */
    function (item, pane, index) {
        this.removeItem(item, true);
        return pane.addItem(item, { index: index, moved: true });
    };
    // Public: Destroy the active item and activate the next item.
    //
    // Returns a {Promise} that resolves when the item is destroyed.
    // Public: Destroy the active item and activate the next item.
    //
    // Returns a {Promise} that resolves when the item is destroyed.
    /**
     * @return {?}
     */
    Pane.prototype.destroyActiveItem = 
    // Public: Destroy the active item and activate the next item.
    //
    // Returns a {Promise} that resolves when the item is destroyed.
    /**
     * @return {?}
     */
    function () {
        return this.destroyItem(this.activeItem);
    };
    // Public: Destroy the given item.
    //
    // If the item is active, the next item will be activated. If the item is the
    // last item, the pane will be destroyed if the `core.destroyEmptyPanes` config
    // setting is `true`.
    //
    // * `item` Item to destroy
    // * `force` (optional) {Boolean} Destroy the item without prompting to save
    //    it, even if the item's `isPermanentDockItem` method returns true.
    //
    // Returns a {Promise} that resolves with a {Boolean} indicating whether or not
    // the item was destroyed.
    // Public: Destroy the given item.
    //
    // If the item is active, the next item will be activated. If the item is the
    // last item, the pane will be destroyed if the `core.destroyEmptyPanes` config
    // setting is `true`.
    //
    // * `item` Item to destroy
    // * `force` (optional) {Boolean} Destroy the item without prompting to save
    //    it, even if the item's `isPermanentDockItem` method returns true.
    //
    // Returns a {Promise} that resolves with a {Boolean} indicating whether or not
    // the item was destroyed.
    /**
     * @param {?=} item
     * @param {?=} force
     * @return {?}
     */
    Pane.prototype.destroyItem = 
    // Public: Destroy the given item.
    //
    // If the item is active, the next item will be activated. If the item is the
    // last item, the pane will be destroyed if the `core.destroyEmptyPanes` config
    // setting is `true`.
    //
    // * `item` Item to destroy
    // * `force` (optional) {Boolean} Destroy the item without prompting to save
    //    it, even if the item's `isPermanentDockItem` method returns true.
    //
    // Returns a {Promise} that resolves with a {Boolean} indicating whether or not
    // the item was destroyed.
    /**
     * @param {?=} item
     * @param {?=} force
     * @return {?}
     */
    function (item, force) {
        return __awaiter(this, void 0, void 0, function () {
            var index;
            return __generator(this, function (_a) {
                index = this.items.indexOf(item);
                if (index === -1) {
                    return [2 /*return*/, false];
                }
                if (!force &&
                    typeof item.isPermanentDockItem === 'function' && item.isPermanentDockItem() &&
                    (!this.container || this.container.getLocation() !== 'center')) {
                    return [2 /*return*/, false];
                }
                // In the case where there are no `onWillDestroyPaneItem` listeners, preserve the old behavior
                // where `Pane.destroyItem` and callers such as `Pane.close` take effect synchronously.
                this.removeItem(item, false);
                if (typeof item.destroy === 'function') {
                    item.destroy();
                }
                return [2 /*return*/, true];
            });
        });
    };
    // Public: Destroy all items.
    // Public: Destroy all items.
    /**
     * @return {?}
     */
    Pane.prototype.destroyItems = 
    // Public: Destroy all items.
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        return Promise.all(this.getItems().map(function (item) { return _this.destroyItem(item); }));
    };
    // Public: Destroy all items except for the active item.
    // Public: Destroy all items except for the active item.
    /**
     * @return {?}
     */
    Pane.prototype.destroyInactiveItems = 
    // Public: Destroy all items except for the active item.
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        return Promise.all(this.getItems()
            .filter(function (item) { return item !== _this.activeItem; })
            .map(function (item) { return _this.destroyItem(item); }));
    };
    /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    Pane.prototype.promptToSaveItem = /**
     * @param {?} item
     * @param {?=} options
     * @return {?}
     */
    function (item, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (typeof item.shouldPromptToSave !== 'function' || !item.shouldPromptToSave(options)) {
            return Promise.resolve(true);
        }
        /** @type {?} */
        var uri;
        if (typeof item.getURI === 'function') {
            uri = item.getURI();
        }
        else if (typeof item.getUri === 'function') {
            uri = item.getUri();
        }
        else {
            return Promise.resolve(true);
        }
        /** @type {?} */
        var title = (typeof item.getTitle === 'function' && item.getTitle()) || uri;
        /** @type {?} */
        var saveDialog = function (saveButtonText, saveFn, message) {
            /** @type {?} */
            var chosen = _this.applicationDelegate.confirm({
                message: message,
                detailedMessage: 'Your changes will be lost if you close this item without saving.',
                buttons: [saveButtonText, 'Cancel', '&Don\'t Save']
            });
            switch (chosen) {
                case 0:
                    return new Promise(function (resolve) {
                        return saveFn(item, function (error) {
                            if (error instanceof SaveCancelledError) {
                                resolve(false);
                            }
                            else if (error) {
                                saveDialog('Save as', _this.saveItemAs, "'" + title + "' could not be saved.\nError: " + _this.getMessageForErrorCode(error.code)).then(resolve);
                            }
                            else {
                                resolve(true);
                            }
                        });
                    });
                case 1:
                    return Promise.resolve(false);
                case 2:
                    return Promise.resolve(true);
            }
        };
        return saveDialog('Save', this.saveItem, "'" + title + "' has changes, do you want to save them?");
    };
    // Public: Save the active item.
    // Public: Save the active item.
    /**
     * @param {?=} nextAction
     * @return {?}
     */
    Pane.prototype.saveActiveItem = 
    // Public: Save the active item.
    /**
     * @param {?=} nextAction
     * @return {?}
     */
    function (nextAction) {
        return this.saveItem(this.getActiveItem(), nextAction);
    };
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `nextAction` (optional) {Function} which will be called after the item is
    //   successfully saved.
    //
    // Returns a {Promise} that resolves when the save is complete
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `nextAction` (optional) {Function} which will be called after the item is
    //   successfully saved.
    //
    // Returns a {Promise} that resolves when the save is complete
    /**
     * @param {?=} nextAction
     * @return {?}
     */
    Pane.prototype.saveActiveItemAs = 
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `nextAction` (optional) {Function} which will be called after the item is
    //   successfully saved.
    //
    // Returns a {Promise} that resolves when the save is complete
    /**
     * @param {?=} nextAction
     * @return {?}
     */
    function (nextAction) {
        return this.saveItemAs(this.getActiveItem(), nextAction);
    };
    // Public: Save the given item.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    //
    // Returns a {Promise} that resolves when the save is complete
    // Public: Save the given item.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    //
    // Returns a {Promise} that resolves when the save is complete
    /**
     * @param {?} item
     * @param {?} nextAction
     * @return {?}
     */
    Pane.prototype.saveItem = 
    // Public: Save the given item.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    //
    // Returns a {Promise} that resolves when the save is complete
    /**
     * @param {?} item
     * @param {?} nextAction
     * @return {?}
     */
    function (item, nextAction) {
        var _this = this;
        if (!item) {
            return Promise.resolve();
        }
        /** @type {?} */
        var itemURI;
        if (typeof item.getURI === 'function') {
            itemURI = item.getURI();
        }
        else if (typeof item.getUri === 'function') {
            itemURI = item.getUri();
        }
        if (itemURI != null) {
            if (typeof item.save === 'function') {
                return promisify(function () { return item.save(); })
                    .then(function () {
                    if (nextAction) {
                        nextAction();
                    }
                })
                    .catch(function (error) {
                    if (nextAction) {
                        nextAction(error);
                    }
                    else {
                        _this.handleSaveError(error, item);
                    }
                });
            }
            else if (nextAction) {
                nextAction();
                return Promise.resolve();
            }
        }
        else {
            return this.saveItemAs(item, nextAction);
        }
    };
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    /**
     * @param {?} item
     * @param {?} nextAction
     * @return {?}
     */
    Pane.prototype.saveItemAs = 
    // Public: Prompt the user for a location and save the active item with the
    // path they select.
    //
    // * `item` The item to save.
    // * `nextAction` (optional) {Function} which will be called with no argument
    //   after the item is successfully saved, or with the error if it failed.
    //   The return value will be that of `nextAction` or `undefined` if it was not
    //   provided
    /**
     * @param {?} item
     * @param {?} nextAction
     * @return {?}
     */
    function (item, nextAction) {
    };
    // Public: Save all items.
    // Public: Save all items.
    /**
     * @return {?}
     */
    Pane.prototype.saveItems = 
    // Public: Save all items.
    /**
     * @return {?}
     */
    function () {
    };
    // Public: Return the first item that matches the given URI or undefined if
    // none exists.
    //
    // * `uri` {String} containing a URI.
    // Public: Return the first item that matches the given URI or undefined if
    // none exists.
    //
    // * `uri` {String} containing a URI.
    /**
     * @param {?} uri
     * @return {?}
     */
    Pane.prototype.itemForURI = 
    // Public: Return the first item that matches the given URI or undefined if
    // none exists.
    //
    // * `uri` {String} containing a URI.
    /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        return this.items.find(function (item) {
            if (typeof item.getURI === 'function') {
                return item.getURI() === uri;
            }
            else if (typeof item.getUri === 'function') {
                return item.getUri() === uri;
            }
        });
    };
    // Public: Activate the first item that matches the given URI.
    //
    // * `uri` {String} containing a URI.
    //
    // Returns a {Boolean} indicating whether an item matching the URI was found.
    // Public: Activate the first item that matches the given URI.
    //
    // * `uri` {String} containing a URI.
    //
    // Returns a {Boolean} indicating whether an item matching the URI was found.
    /**
     * @param {?} uri
     * @return {?}
     */
    Pane.prototype.activateItemForURI = 
    // Public: Activate the first item that matches the given URI.
    //
    // * `uri` {String} containing a URI.
    //
    // Returns a {Boolean} indicating whether an item matching the URI was found.
    /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        /** @type {?} */
        var item = this.itemForURI(uri);
        if (item) {
            this.activateItem(item);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @return {?}
     */
    Pane.prototype.copyActiveItem = /**
     * @return {?}
     */
    function () {
        if (this.activeItem && typeof this.activeItem.copy === 'function') {
            return this.activeItem.copy();
        }
    };
    /*
    Section: Lifecycle
    */
    // Public: Determine whether the pane is active.
    //
    // Returns a {Boolean}.
    /*
      Section: Lifecycle
      */
    // Public: Determine whether the pane is active.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    Pane.prototype.isActive = /*
      Section: Lifecycle
      */
    // Public: Determine whether the pane is active.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    function () {
        return this.container && this.container.getActivePane() === this;
    };
    // Public: Makes this pane the *active* pane, causing it to gain focus.
    // Public: Makes this pane the *active* pane, causing it to gain focus.
    /**
     * @return {?}
     */
    Pane.prototype.activate = 
    // Public: Makes this pane the *active* pane, causing it to gain focus.
    /**
     * @return {?}
     */
    function () {
    };
    // Public: Close the pane and destroy all its items.
    //
    // If this is the last pane, all the items will be destroyed but the pane
    // itself will not be destroyed.
    // Public: Close the pane and destroy all its items.
    //
    // If this is the last pane, all the items will be destroyed but the pane
    // itself will not be destroyed.
    /**
     * @return {?}
     */
    Pane.prototype.destroy = 
    // Public: Close the pane and destroy all its items.
    //
    // If this is the last pane, all the items will be destroyed but the pane
    // itself will not be destroyed.
    /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    Pane.prototype.isAlive = /**
     * @return {?}
     */
    function () { return this.alive; };
    // Public: Determine whether this pane has been destroyed.
    //
    // Returns a {Boolean}.
    // Public: Determine whether this pane has been destroyed.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    Pane.prototype.isDestroyed = 
    // Public: Determine whether this pane has been destroyed.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    function () { return !this.isAlive(); };
    /*
    Section: Splitting
    */
    // Public: Create a new pane to the left of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /*
      Section: Splitting
      */
    // Public: Create a new pane to the left of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    Pane.prototype.splitLeft = /*
      Section: Splitting
      */
    // Public: Create a new pane to the left of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        return this.split('horizontal', 'before', params);
    };
    // Public: Create a new pane to the right of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    // Public: Create a new pane to the right of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    Pane.prototype.splitRight = 
    // Public: Create a new pane to the right of this pane.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        return this.split('horizontal', 'after', params);
    };
    // Public: Creates a new pane above the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    // Public: Creates a new pane above the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    Pane.prototype.splitUp = 
    // Public: Creates a new pane above the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        return this.split('vertical', 'before', params);
    };
    // Public: Creates a new pane below the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    // Public: Creates a new pane below the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    Pane.prototype.splitDown = 
    // Public: Creates a new pane below the receiver.
    //
    // * `params` (optional) {Object} with the following keys:
    //   * `items` (optional) {Array} of items to add to the new pane.
    //   * `copyActiveItem` (optional) {Boolean} true will copy the active item into the new split pane
    //
    // Returns the new {Pane}.
    /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        return this.split('vertical', 'after', params);
    };
    /**
     * @param {?} orientation
     * @param {?} side
     * @param {?} params
     * @return {?}
     */
    Pane.prototype.split = /**
     * @param {?} orientation
     * @param {?} side
     * @param {?} params
     * @return {?}
     */
    function (orientation, side, params) {
        if (params && params.copyActiveItem) {
            if (!params.items) {
                params.items = [];
            }
            params.items.push(this.copyActiveItem());
        }
        if (this.parent.orientation !== orientation) {
            this.parent.replaceChild(this, new PaneAxis({
                container: this.container,
                orientation: orientation,
                children: [this],
                flexScale: this.flexScale
            }, this.viewRegistry));
            this.setFlexScale(1);
        }
        /** @type {?} */
        var newPane = new Pane(Object.assign({
            applicationDelegate: this.applicationDelegate,
            notificationManager: this.notificationManager,
            deserializerManager: this.deserializerManager,
            config: this.config,
            viewRegistry: this.viewRegistry
        }, params));
        switch (side) {
            case 'before':
                this.parent.insertChildBefore(this, newPane);
                break;
            case 'after':
                this.parent.insertChildAfter(this, newPane);
                break;
        }
        if (params && params.moveActiveItem && this.activeItem) {
            this.moveItemToPane(this.activeItem, newPane);
        }
        newPane.activate();
        return newPane;
    };
    // If the parent is a horizontal axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    // If the parent is a horizontal axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    /**
     * @return {?}
     */
    Pane.prototype.findLeftmostSibling = 
    // If the parent is a horizontal axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    /**
     * @return {?}
     */
    function () {
        if (this.parent.orientation === 'horizontal') {
            var _a = __read(this.parent.children, 1), leftmostSibling = _a[0];
            if (leftmostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return leftmostSibling;
            }
        }
        else {
            return this;
        }
    };
    /**
     * @return {?}
     */
    Pane.prototype.findRightmostSibling = /**
     * @return {?}
     */
    function () {
        if (this.parent.orientation === 'horizontal') {
            /** @type {?} */
            var rightmostSibling = this.parent.children[this.parent.children.length - 1];
            if (rightmostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return rightmostSibling;
            }
        }
        else {
            return this;
        }
    };
    // If the parent is a horizontal axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane rightward.
    // If the parent is a horizontal axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane rightward.
    /**
     * @return {?}
     */
    Pane.prototype.findOrCreateRightmostSibling = 
    // If the parent is a horizontal axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane rightward.
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var rightmostSibling = this.findRightmostSibling();
        if (rightmostSibling === this) {
            return this.splitRight({});
        }
        else {
            return rightmostSibling;
        }
    };
    // If the parent is a vertical axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    // If the parent is a vertical axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    /**
     * @return {?}
     */
    Pane.prototype.findTopmostSibling = 
    // If the parent is a vertical axis, returns its first child if it is a pane;
    // otherwise returns this pane.
    /**
     * @return {?}
     */
    function () {
        if (this.parent.orientation === 'vertical') {
            var _a = __read(this.parent.children, 1), topmostSibling = _a[0];
            if (topmostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return topmostSibling;
            }
        }
        else {
            return this;
        }
    };
    /**
     * @return {?}
     */
    Pane.prototype.findBottommostSibling = /**
     * @return {?}
     */
    function () {
        if (this.parent.orientation === 'vertical') {
            /** @type {?} */
            var bottommostSibling = this.parent.children[this.parent.children.length - 1];
            if (bottommostSibling instanceof PaneAxis) {
                return this;
            }
            else {
                return bottommostSibling;
            }
        }
        else {
            return this;
        }
    };
    // If the parent is a vertical axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane bottomward.
    // If the parent is a vertical axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane bottomward.
    /**
     * @return {?}
     */
    Pane.prototype.findOrCreateBottommostSibling = 
    // If the parent is a vertical axis, returns its last child if it is a pane;
    // otherwise returns a new pane created by splitting this pane bottomward.
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var bottommostSibling = this.findBottommostSibling();
        if (bottommostSibling === this) {
            return this.splitDown({});
        }
        else {
            return bottommostSibling;
        }
    };
    // Private: Close the pane unless the user cancels the action via a dialog.
    //
    // Returns a {Promise} that resolves once the pane is either closed, or the
    // closing has been cancelled.
    // Private: Close the pane unless the user cancels the action via a dialog.
    //
    // Returns a {Promise} that resolves once the pane is either closed, or the
    // closing has been cancelled.
    /**
     * @return {?}
     */
    Pane.prototype.close = 
    // Private: Close the pane unless the user cancels the action via a dialog.
    //
    // Returns a {Promise} that resolves once the pane is either closed, or the
    // closing has been cancelled.
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        return Promise.all(this.getItems().map(function (item) { return _this.promptToSaveItem(item); }))
            .then(function (results) {
            if (!results.find(function (item) { return item === false; })) {
                return _this.destroy();
            }
        });
    };
    /**
     * @param {?} error
     * @param {?} item
     * @return {?}
     */
    Pane.prototype.handleSaveError = /**
     * @param {?} error
     * @param {?} item
     * @return {?}
     */
    function (error, item) {
    };
    /**
     * @param {?} errorCode
     * @return {?}
     */
    Pane.prototype.getMessageForErrorCode = /**
     * @param {?} errorCode
     * @return {?}
     */
    function (errorCode) {
        switch (errorCode) {
            case 'EACCES': return 'Permission denied';
            case 'ECONNRESET': return 'Connection reset';
            case 'EINTR': return 'Interrupted system call';
            case 'EIO': return 'I/O error writing file';
            case 'ENOSPC': return 'No space left on device';
            case 'ENOTSUP': return 'Operation not supported on socket';
            case 'ENXIO': return 'No such device or address';
            case 'EROFS': return 'Read-only file system';
            case 'ESPIPE': return 'Invalid seek';
            case 'ETIMEDOUT': return 'Connection timed out';
        }
    };
    return Pane;
}());
/**
 * @param {?} callback
 * @return {?}
 */
function promisify(callback) {
    try {
        return Promise.resolve(callback());
    }
    catch (error) {
        return Promise.reject(error);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ItemRegistry = /** @class */ (function () {
    function ItemRegistry() {
        this.items = new WeakSet();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    ItemRegistry.prototype.addItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.hasItem(item)) {
            throw new Error("The workspace can only contain one instance of item " + item);
        }
        this.items.add(item);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ItemRegistry.prototype.removeItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.items.delete(item);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ItemRegistry.prototype.hasItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.items.has(item);
    };
    return ItemRegistry;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var SERIALIZATION_VERSION = 1;
var PaneContainer = /** @class */ (function () {
    function PaneContainer(params) {
        /** @type {?} */
        var applicationDelegate;
        /** @type {?} */
        var deserializerManager;
        /** @type {?} */
        var notificationManager;
        (this.config = params.config, applicationDelegate = params.applicationDelegate, notificationManager = params.notificationManager, deserializerManager = params.deserializerManager, this.viewRegistry = params.viewRegistry, this.location = params.location);
        this.itemRegistry = new ItemRegistry();
        this.alive = true;
        this.setRoot(new Pane({
            container: this,
            config: this.config,
            applicationDelegate: applicationDelegate,
            notificationManager: notificationManager,
            deserializerManager: deserializerManager,
            viewRegistry: this.viewRegistry
        }));
        this.didActivatePane(this.getRoot());
    }
    /**
     * @return {?}
     */
    PaneContainer.prototype.getLocation = /**
     * @return {?}
     */
    function () { return this.location; };
    /**
     * @return {?}
     */
    PaneContainer.prototype.getElement = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        this.alive = false;
        try {
            for (var _b = __values(this.getRoot().getPanes()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pane = _c.value;
                pane.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.isAlive = /**
     * @return {?}
     */
    function () { return this.alive; };
    /**
     * @return {?}
     */
    PaneContainer.prototype.isDestroyed = /**
     * @return {?}
     */
    function () { return !this.isAlive(); };
    /**
     * @param {...?} params
     * @return {?}
     */
    PaneContainer.prototype.serialize = /**
     * @param {...?} params
     * @return {?}
     */
    function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        return {
            deserializer: 'PaneContainer',
            version: SERIALIZATION_VERSION,
            root: this.root ? this.root.serialize() : null,
            activePaneId: this.activePane.id
        };
    };
    /**
     * @param {?} state
     * @param {?} deserializerManager
     * @return {?}
     */
    PaneContainer.prototype.deserialize = /**
     * @param {?} state
     * @param {?} deserializerManager
     * @return {?}
     */
    function (state, deserializerManager) {
        if (state.version !== SERIALIZATION_VERSION) {
            return;
        }
        this.setRoot(deserializerManager.deserialize(state.root));
        this.activePane = this.getRoot().getPanes().find(function (pane) { return pane.id === state.activePaneId; }) || this.getPanes()[0];
        if (this.config && this.config.get && this.config.get('core.destroyEmptyPanes')) {
            this.destroyEmptyPanes();
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidChangeRoot = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.observeRoot = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        fn(this.getRoot());
        return this.onDidChangeRoot(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidAddPane = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.observePanes = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        var e_2, _a;
        try {
            for (var _b = __values(this.getPanes()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pane = _c.value;
                fn(pane);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return this.onDidAddPane(function (_a) {
            var pane = _a.pane;
            return fn(pane);
        });
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidDestroyPane = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onWillDestroyPane = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidChangeActivePane = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidActivatePane = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.observeActivePane = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        fn(this.getActivePane());
        return this.onDidChangeActivePane(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidAddPaneItem = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.observePaneItems = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        var e_3, _a;
        try {
            for (var _b = __values(this.getPaneItems()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                fn(item);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return this.onDidAddPaneItem(function (_a) {
            var item = _a.item;
            return fn(item);
        });
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidChangeActivePaneItem = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidStopChangingActivePaneItem = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.observeActivePaneItem = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        fn(this.getActivePaneItem());
        return this.onDidChangeActivePaneItem(fn);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onWillDestroyPaneItem = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    PaneContainer.prototype.onDidDestroyPaneItem = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.getRoot = /**
     * @return {?}
     */
    function () { return this.root; };
    /**
     * @param {?} root
     * @return {?}
     */
    PaneContainer.prototype.setRoot = /**
     * @param {?} root
     * @return {?}
     */
    function (root) {
        this.root = root;
        this.root.setParent(this);
        this.root.setContainer(this);
        if ((this.getActivePane() == null) && this.root instanceof Pane) {
            this.didActivatePane(this.root);
        }
    };
    /**
     * @param {?} oldChild
     * @param {?} newChild
     * @return {?}
     */
    PaneContainer.prototype.replaceChild = /**
     * @param {?} oldChild
     * @param {?} newChild
     * @return {?}
     */
    function (oldChild, newChild) {
        if (oldChild !== this.root) {
            throw new Error('Replacing non-existent child');
        }
        this.setRoot(newChild);
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.getPanes = /**
     * @return {?}
     */
    function () {
        if (this.alive) {
            return this.getRoot().getPanes();
        }
        else {
            return [];
        }
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.getPaneItems = /**
     * @return {?}
     */
    function () {
        return this.getRoot().getItems();
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.getActivePane = /**
     * @return {?}
     */
    function () {
        return this.activePane;
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.getActivePaneItem = /**
     * @return {?}
     */
    function () {
        return this.getActivePane().getActiveItem();
    };
    /**
     * @param {?} uri
     * @return {?}
     */
    PaneContainer.prototype.paneForURI = /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        return this.getPanes().find(function (pane) { return pane.itemForURI(uri) != null; });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PaneContainer.prototype.paneForItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.getPanes().find(function (pane) { return pane.getItems().find(function (it) { return it === item; }); });
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.saveAll = /**
     * @return {?}
     */
    function () {
        var e_4, _a;
        try {
            for (var _b = __values(this.getPanes()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pane = _c.value;
                pane.saveItems();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    /**
     * @param {?} options
     * @return {?}
     */
    PaneContainer.prototype.confirmClose = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        var e_5, _a, e_6, _b;
        /** @type {?} */
        var promises = [];
        try {
            for (var _c = __values(this.getPanes()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var pane = _d.value;
                try {
                    for (var _e = __values(pane.getItems()), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var item = _f.value;
                        promises.push(pane.promptToSaveItem(item, options));
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return Promise.all(promises).then(function (results) { return !results.find(function (item) { return item === false; }); });
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.activateNextPane = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var panes = this.getPanes();
        if (panes.length > 1) {
            /** @type {?} */
            var currentIndex = panes.indexOf(this.activePane);
            /** @type {?} */
            var nextIndex = (currentIndex + 1) % panes.length;
            panes[nextIndex].activate();
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.activatePreviousPane = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var panes = this.getPanes();
        if (panes.length > 1) {
            /** @type {?} */
            var currentIndex = panes.indexOf(this.activePane);
            /** @type {?} */
            var previousIndex = currentIndex - 1;
            if (previousIndex < 0) {
                previousIndex = panes.length - 1;
            }
            panes[previousIndex].activate();
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} destPane
     * @return {?}
     */
    PaneContainer.prototype.moveActiveItemToPane = /**
     * @param {?} destPane
     * @return {?}
     */
    function (destPane) {
        /** @type {?} */
        var item = this.activePane.getActiveItem();
        if (!destPane.isItemAllowed(item)) {
            return;
        }
        this.activePane.moveItemToPane(item, destPane);
        destPane.setActiveItem(item);
    };
    /**
     * @param {?} destPane
     * @return {?}
     */
    PaneContainer.prototype.copyActiveItemToPane = /**
     * @param {?} destPane
     * @return {?}
     */
    function (destPane) {
        /** @type {?} */
        var item = this.activePane.copyActiveItem();
        if (item && destPane.isItemAllowed(item)) {
            destPane.activateItem(item);
        }
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.destroyEmptyPanes = /**
     * @return {?}
     */
    function () {
        var e_7, _a;
        try {
            for (var _b = __values(this.getPanes()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var pane = _c.value;
                if (pane.items.length === 0) {
                    pane.destroy();
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    PaneContainer.prototype.didAddPane = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var items = event.pane.getItems();
        for (var i = 0, length_1 = items.length; i < length_1; i++) {
            /** @type {?} */
            var item = items[i];
            this.didAddPaneItem(item, event.pane, i);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    PaneContainer.prototype.willDestroyPane = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    PaneContainer.prototype.didDestroyPane = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
    };
    /**
     * @param {?} activePane
     * @return {?}
     */
    PaneContainer.prototype.didActivatePane = /**
     * @param {?} activePane
     * @return {?}
     */
    function (activePane) {
        if (activePane !== this.activePane) {
            if (!this.getPanes().find(function (item) { return item === activePane; })) {
                throw new Error('Setting active pane that is not present in pane container');
            }
            this.activePane = activePane;
            this.didChangeActiveItemOnPane(this.activePane, this.activePane.getActiveItem());
        }
        return this.activePane;
    };
    /**
     * @param {?} item
     * @param {?} pane
     * @param {?} index
     * @return {?}
     */
    PaneContainer.prototype.didAddPaneItem = /**
     * @param {?} item
     * @param {?} pane
     * @param {?} index
     * @return {?}
     */
    function (item, pane, index) {
        this.itemRegistry.addItem(item);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    PaneContainer.prototype.willDestroyPaneItem = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    PaneContainer.prototype.didDestroyPaneItem = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.itemRegistry.removeItem(event.item);
        // this.emitter.emit('did-destroy-pane-item', event);
    };
    /**
     * @param {?} pane
     * @param {?} activeItem
     * @return {?}
     */
    PaneContainer.prototype.didChangeActiveItemOnPane = /**
     * @param {?} pane
     * @param {?} activeItem
     * @return {?}
     */
    function (pane, activeItem) {
        if (pane === this.getActivePane()) {
            this.cancelStoppedChangingActivePaneItemTimeout();
            // `setTimeout()` isn't available during the snapshotting phase, but that's okay.
        }
    };
    /**
     * @return {?}
     */
    PaneContainer.prototype.cancelStoppedChangingActivePaneItemTimeout = /**
     * @return {?}
     */
    function () {
    };
    return PaneContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var DockStyle = {
    none: 0,
    left: 1,
    right: 2,
    top: 3,
    bottom: 4,
};
DockStyle[DockStyle.none] = 'none';
DockStyle[DockStyle.left] = 'left';
DockStyle[DockStyle.right] = 'right';
DockStyle[DockStyle.top] = 'top';
DockStyle[DockStyle.bottom] = 'bottom';
var Dock = /** @class */ (function () {
    function Dock(params) {
        this.handleResizeHandleDragStart = this.handleResizeHandleDragStart.bind(this);
        this.handleResizeToFit = this.handleResizeToFit.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.location = params.location;
        this.widthOrHeight = getWidthOrHeight(this.location);
        this.viewRegistry = params.viewRegistry;
        this.didActivate = params.didActivate;
        this.emitter = new Emitter();
        this.paneContainer = new PaneContainer({
            location: this.location,
            viewRegistry: this.viewRegistry
        });
        this.state = {
            size: null,
            visible: false,
            shouldAnimate: false
        };
    }
    // This method is called explicitly by the object which adds the Dock to the document.
    // This method is called explicitly by the object which adds the Dock to the document.
    /**
     * @return {?}
     */
    Dock.prototype.elementAttached = 
    // This method is called explicitly by the object which adds the Dock to the document.
    /**
     * @return {?}
     */
    function () {
        // Re-render when the dock is attached to make sure we remeasure sizes defined in CSS.
        this.render(this.state);
    };
    /**
     * @return {?}
     */
    Dock.prototype.getElement = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    Dock.prototype.getLocation = /**
     * @return {?}
     */
    function () {
        return this.location;
    };
    /**
     * @return {?}
     */
    Dock.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.paneContainer.destroy();
        // window.removeEventListener('mousemove', this.handleMouseMove);
        // window.removeEventListener('mouseup', this.handleMouseUp);
        // window.removeEventListener('drag', this.handleDrag);
        // window.removeEventListener('dragend', this.handleDragEnd);
    };
    /**
     * @param {?} hovered
     * @return {?}
     */
    Dock.prototype.setHovered = /**
     * @param {?} hovered
     * @return {?}
     */
    function (hovered) {
        if (hovered === this.state.hovered) {
            return;
        }
        this.setState({ hovered: hovered });
    };
    /**
     * @param {?} draggingItem
     * @return {?}
     */
    Dock.prototype.setDraggingItem = /**
     * @param {?} draggingItem
     * @return {?}
     */
    function (draggingItem) {
        if (draggingItem === this.state.draggingItem) {
            return;
        }
        this.setState({ draggingItem: draggingItem });
    };
    // Extended: Show the dock and focus its active {Pane}.
    // Extended: Show the dock and focus its active {Pane}.
    /**
     * @return {?}
     */
    Dock.prototype.activate = 
    // Extended: Show the dock and focus its active {Pane}.
    /**
     * @return {?}
     */
    function () {
        this.getActivePane().activate();
    };
    // Extended: Show the dock without focusing it.
    // Extended: Show the dock without focusing it.
    /**
     * @return {?}
     */
    Dock.prototype.show = 
    // Extended: Show the dock without focusing it.
    /**
     * @return {?}
     */
    function () {
        this.setState({ visible: true });
    };
    // Extended: Hide the dock and activate the {WorkspaceCenter} if the dock was
    // was previously focused.
    // Extended: Hide the dock and activate the {WorkspaceCenter} if the dock was
    // was previously focused.
    /**
     * @return {?}
     */
    Dock.prototype.hide = 
    // Extended: Hide the dock and activate the {WorkspaceCenter} if the dock was
    // was previously focused.
    /**
     * @return {?}
     */
    function () {
        this.setState({ visible: false });
    };
    // Extended: Toggle the dock's visibility without changing the {Workspace}'s
    // active pane container.
    // Extended: Toggle the dock's visibility without changing the {Workspace}'s
    // active pane container.
    /**
     * @return {?}
     */
    Dock.prototype.toggle = 
    // Extended: Toggle the dock's visibility without changing the {Workspace}'s
    // active pane container.
    /**
     * @return {?}
     */
    function () {
        // const state = { visible: !this.state.visible };
        // if (!state.visible) { state.hovered = false; }
        // this.setState(state);
    };
    // Extended: Check if the dock is visible.
    //
    // Returns a {Boolean}.
    // Extended: Check if the dock is visible.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    Dock.prototype.isVisible = 
    // Extended: Check if the dock is visible.
    //
    // Returns a {Boolean}.
    /**
     * @return {?}
     */
    function () {
        return this.state.visible;
    };
    /**
     * @param {?} newState
     * @return {?}
     */
    Dock.prototype.setState = /**
     * @param {?} newState
     * @return {?}
     */
    function (newState) {
        /** @type {?} */
        var prevState = this.state;
        /** @type {?} */
        var nextState = Object.assign({}, prevState, newState);
        // Update the `shouldAnimate` state. This needs to be written to the DOM before updating the
        // class that changes the animated property. Normally we'd have to defer the class change a
        // frame to ensure the property is animated (or not) appropriately, however we luck out in this
        // case because the drag start always happens before the item is dragged into the toggle button.
        if (nextState.visible !== prevState.visible) {
            // Never animate toggling visibility...
            nextState.shouldAnimate = false;
        }
        else if (!nextState.visible && nextState.draggingItem && !prevState.draggingItem) {
            // ...but do animate if you start dragging while the panel is hidden.
            nextState.shouldAnimate = true;
        }
        this.state = nextState;
        this.render(this.state);
        var visible = this.state.visible;
        // if (visible !== prevState.visible) {
        //   this.emitter.emit('did-change-visible', visible);
        // }
    };
    /**
     * @param {?} state
     * @return {?}
     */
    Dock.prototype.render = /**
     * @param {?} state
     * @return {?}
     */
    function (state) {
    };
    /**
     * @return {?}
     */
    Dock.prototype.handleDidAddPaneItem = /**
     * @return {?}
     */
    function () {
        if (this.state.size == null) {
            this.setState({ size: this.getInitialSize() });
        }
    };
    /**
     * @return {?}
     */
    Dock.prototype.handleDidRemovePaneItem = /**
     * @return {?}
     */
    function () {
        // Hide the dock if you remove the last item.
        if (this.paneContainer.getPaneItems().length === 0) {
            this.setState({ visible: false, hovered: false, size: null });
        }
    };
    /**
     * @return {?}
     */
    Dock.prototype.handleResizeHandleDragStart = /**
     * @return {?}
     */
    function () {
        window.addEventListener('mousemove', this.handleMouseMove);
        window.addEventListener('mouseup', this.handleMouseUp);
        this.setState({ resizing: true });
    };
    /**
     * @return {?}
     */
    Dock.prototype.handleResizeToFit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var item = this.getActivePaneItem();
        if (item) {
            /** @type {?} */
            var size = getPreferredSize(item, this.getLocation());
            if (size != null) {
                this.setState({ size: size });
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    Dock.prototype.handleMouseMove = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.buttons === 0) { // We missed the mouseup event. For some reason it happens on Windows
            this.handleMouseUp(event);
            return;
        }
        /** @type {?} */
        var size = 0;
        // switch (this.location) {
        //   case 'left':
        //     size = event.pageX - this.element.getBoundingClientRect().left;
        //     break;
        //   case 'bottom':
        //     size = this.element.getBoundingClientRect().bottom - event.pageY;
        //     break;
        //   case 'right':
        //     size = this.element.getBoundingClientRect().right - event.pageX;
        //     break;
        // }
        this.setState({ size: size });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    Dock.prototype.handleMouseUp = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        window.removeEventListener('mousemove', this.handleMouseMove);
        window.removeEventListener('mouseup', this.handleMouseUp);
        this.setState({ resizing: false });
    };
    // Determine whether the cursor is within the dock hover area. This isn't as simple as just using
    // mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is
    // over the footer, we want to show the bottom dock's toggle button. Also note that our criteria
    // for detecting entry are different than detecting exit but, in order for us to avoid jitter, the
    // area considered when detecting exit MUST fully encompass the area considered when detecting
    // entry.
    // Determine whether the cursor is within the dock hover area. This isn't as simple as just using
    // mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is
    // over the footer, we want to show the bottom dock's toggle button. Also note that our criteria
    // for detecting entry are different than detecting exit but, in order for us to avoid jitter, the
    // area considered when detecting exit MUST fully encompass the area considered when detecting
    // entry.
    /**
     * @param {?} point
     * @param {?} detectingExit
     * @return {?}
     */
    Dock.prototype.pointWithinHoverArea = 
    // Determine whether the cursor is within the dock hover area. This isn't as simple as just using
    // mouseenter/leave because we want to be a little more forgiving. For example, if the cursor is
    // over the footer, we want to show the bottom dock's toggle button. Also note that our criteria
    // for detecting entry are different than detecting exit but, in order for us to avoid jitter, the
    // area considered when detecting exit MUST fully encompass the area considered when detecting
    // entry.
    /**
     * @param {?} point
     * @param {?} detectingExit
     * @return {?}
     */
    function (point, detectingExit) {
    };
    /**
     * @return {?}
     */
    Dock.prototype.getInitialSize = /**
     * @return {?}
     */
    function () {
        // The item may not have been activated yet. If that's the case, just use the first item.
        /** @type {?} */
        var activePaneItem = this.paneContainer.getActivePaneItem() || this.paneContainer.getPaneItems()[0];
        // If there are items, we should have an explicit width; if not, we shouldn't.
        return activePaneItem
            ? getPreferredSize(activePaneItem, this.location)
            : null;
    };
    /**
     * @return {?}
     */
    Dock.prototype.serialize = /**
     * @return {?}
     */
    function () {
        return {
            deserializer: 'Dock',
            size: this.state.size,
            paneContainer: this.paneContainer.serialize({}),
            visible: this.state.visible
        };
    };
    /**
     * @param {?} serialized
     * @param {?} deserializerManager
     * @return {?}
     */
    Dock.prototype.deserialize = /**
     * @param {?} serialized
     * @param {?} deserializerManager
     * @return {?}
     */
    function (serialized, deserializerManager) {
        this.paneContainer.deserialize(serialized.paneContainer, deserializerManager);
        this.setState({
            size: serialized.size || this.getInitialSize(),
            // If no items could be deserialized, we don't want to show the dock (even if it was visible last time)
            visible: serialized.visible && (this.paneContainer.getPaneItems().length > 0)
        });
    };
    /*
    Section: Event Subscription
    */
    // Essential: Invoke the given callback when the visibility of the dock changes.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /*
      Section: Event Subscription
      */
    // Essential: Invoke the given callback when the visibility of the dock changes.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidChangeVisible = /*
      Section: Event Subscription
      */
    // Essential: Invoke the given callback when the visibility of the dock changes.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
    };
    // Essential: Invoke the given callback with the current and all future visibilities of the dock.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback with the current and all future visibilities of the dock.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.observeVisible = 
    // Essential: Invoke the given callback with the current and all future visibilities of the dock.
    //
    // * `callback` {Function} to be called when the visibility changes.
    //   * `visible` {Boolean} Is the dock now visible?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        callback(this.isVisible());
        return this.onDidChangeVisible(callback);
    };
    // Essential: Invoke the given callback with all current and future panes items
    // in the dock.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback with all current and future panes items
    // in the dock.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.observePaneItems = 
    // Essential: Invoke the given callback with all current and future panes items
    // in the dock.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.observePaneItems(callback);
    };
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidChangeActivePaneItem = 
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidChangeActivePaneItem(callback);
    };
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidStopChangingActivePaneItem = 
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidStopChangingActivePaneItem(callback);
    };
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the dock.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the dock.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.observeActivePaneItem = 
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the dock.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.observeActivePaneItem(callback);
    };
    // Extended: Invoke the given callback when a pane is added to the dock.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane is added to the dock.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidAddPane = 
    // Extended: Invoke the given callback when a pane is added to the dock.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidAddPane(callback);
    };
    // Extended: Invoke the given callback before a pane is destroyed in the
    // dock.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback before a pane is destroyed in the
    // dock.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onWillDestroyPane = 
    // Extended: Invoke the given callback before a pane is destroyed in the
    // dock.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onWillDestroyPane(callback);
    };
    // Extended: Invoke the given callback when a pane is destroyed in the dock.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane is destroyed in the dock.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidDestroyPane = 
    // Extended: Invoke the given callback when a pane is destroyed in the dock.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidDestroyPane(callback);
    };
    // Extended: Invoke the given callback with all current and future panes in the
    // dock.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback with all current and future panes in the
    // dock.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.observePanes = 
    // Extended: Invoke the given callback with all current and future panes in the
    // dock.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.observePanes(callback);
    };
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidChangeActivePane = 
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidChangeActivePane(callback);
    };
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.observeActivePane = 
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.observeActivePane(callback);
    };
    // Extended: Invoke the given callback when a pane item is added to the dock.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane item is added to the dock.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidAddPaneItem = 
    // Extended: Invoke the given callback when a pane item is added to the dock.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidAddPaneItem(callback);
    };
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onWillDestroyPaneItem = 
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onWillDestroyPaneItem(callback);
    };
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidDestroyPaneItem = 
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidDestroyPaneItem(callback);
    };
    // Extended: Invoke the given callback when the hovered state of the dock changes.
    //
    // * `callback` {Function} to be called when the hovered state changes.
    //   * `hovered` {Boolean} Is the dock now hovered?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when the hovered state of the dock changes.
    //
    // * `callback` {Function} to be called when the hovered state changes.
    //   * `hovered` {Boolean} Is the dock now hovered?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Dock.prototype.onDidChangeHovered = 
    // Extended: Invoke the given callback when the hovered state of the dock changes.
    //
    // * `callback` {Function} to be called when the hovered state changes.
    //   * `hovered` {Boolean} Is the dock now hovered?
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-change-hovered', callback);
    };
    /*
    Section: Pane Items
    */
    // Essential: Get all pane items in the dock.
    //
    // Returns an {Array} of items.
    /*
      Section: Pane Items
      */
    // Essential: Get all pane items in the dock.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    Dock.prototype.getPaneItems = /*
      Section: Pane Items
      */
    // Essential: Get all pane items in the dock.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getPaneItems();
    };
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    /**
     * @return {?}
     */
    Dock.prototype.getActivePaneItem = 
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getActivePaneItem();
    };
    // Save all pane items.
    // Save all pane items.
    /**
     * @return {?}
     */
    Dock.prototype.saveAll = 
    // Save all pane items.
    /**
     * @return {?}
     */
    function () {
        this.paneContainer.saveAll();
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Dock.prototype.confirmClose = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.paneContainer.confirmClose(options);
    };
    /*
    Section: Panes
    */
    // Extended: Get all panes in the dock.
    //
    // Returns an {Array} of {Pane}s.
    /*
      Section: Panes
      */
    // Extended: Get all panes in the dock.
    //
    // Returns an {Array} of {Pane}s.
    /**
     * @return {?}
     */
    Dock.prototype.getPanes = /*
      Section: Panes
      */
    // Extended: Get all panes in the dock.
    //
    // Returns an {Array} of {Pane}s.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getPanes();
    };
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    /**
     * @return {?}
     */
    Dock.prototype.getActivePane = 
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getActivePane();
    };
    // Extended: Make the next pane active.
    // Extended: Make the next pane active.
    /**
     * @return {?}
     */
    Dock.prototype.activateNextPane = 
    // Extended: Make the next pane active.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.activateNextPane();
    };
    // Extended: Make the previous pane active.
    // Extended: Make the previous pane active.
    /**
     * @return {?}
     */
    Dock.prototype.activatePreviousPane = 
    // Extended: Make the previous pane active.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.activatePreviousPane();
    };
    /**
     * @param {?} uri
     * @return {?}
     */
    Dock.prototype.paneForURI = /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        return this.paneContainer.paneForURI(uri);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    Dock.prototype.paneForItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.paneContainer.paneForItem(item);
    };
    // Destroy (close) the active pane.
    // Destroy (close) the active pane.
    /**
     * @return {?}
     */
    Dock.prototype.destroyActivePane = 
    // Destroy (close) the active pane.
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var activePane = this.getActivePane();
        if (activePane != null) {
            activePane.destroy();
        }
    };
    return Dock;
}());
/**
 * @param {?} location
 * @return {?}
 */
function getWidthOrHeight(location) {
    return location === 'left' || location === 'right' ? 'width' : 'height';
}
/**
 * @param {?} item
 * @param {?} location
 * @return {?}
 */
function getPreferredSize(item, location) {
    switch (location) {
        case 'left':
        case 'right':
            return typeof item.getPreferredWidth === 'function'
                ? item.getPreferredWidth()
                : null;
        default:
            return typeof item.getPreferredHeight === 'function'
                ? item.getPreferredHeight()
                : null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Abstract cache storage
 * @abstract
 */
var  /**
 * Abstract cache storage
 * @abstract
 */
CacheStorageAbstract = /** @class */ (function () {
    function CacheStorageAbstract() {
    }
    return CacheStorageAbstract;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in session storage
 */
var CacheSessionStorage = /** @class */ (function (_super) {
    __extends(CacheSessionStorage, _super);
    function CacheSessionStorage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    CacheSessionStorage.prototype.getItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var value = sessionStorage.getItem(key);
        return value ? JSON.parse(value) : null;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    CacheSessionStorage.prototype.setItem = /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        try {
            sessionStorage.setItem(key, JSON.stringify(value));
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * @param {?} key
     * @return {?}
     */
    CacheSessionStorage.prototype.removeItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        sessionStorage.removeItem(key);
    };
    /**
     * @return {?}
     */
    CacheSessionStorage.prototype.clear = /**
     * @return {?}
     */
    function () {
        sessionStorage.clear();
    };
    /**
     * @return {?}
     */
    CacheSessionStorage.prototype.type = /**
     * @return {?}
     */
    function () {
        return 1 /* SESSION_STORAGE */;
    };
    /**
     * @return {?}
     */
    CacheSessionStorage.prototype.isEnabled = /**
     * @return {?}
     */
    function () {
        try {
            sessionStorage.setItem('test', 'test');
            sessionStorage.removeItem('test');
            return true;
        }
        catch (e) {
            return false;
        }
    };
    CacheSessionStorage.decorators = [
        { type: Injectable }
    ];
    return CacheSessionStorage;
}(CacheStorageAbstract));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in local storage
 */
var CacheLocalStorage = /** @class */ (function (_super) {
    __extends(CacheLocalStorage, _super);
    function CacheLocalStorage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    CacheLocalStorage.prototype.getItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var value = localStorage.getItem(key);
        return value ? JSON.parse(value) : null;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    CacheLocalStorage.prototype.setItem = /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * @param {?} key
     * @return {?}
     */
    CacheLocalStorage.prototype.removeItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        localStorage.removeItem(key);
    };
    /**
     * @return {?}
     */
    CacheLocalStorage.prototype.clear = /**
     * @return {?}
     */
    function () {
        localStorage.clear();
    };
    /**
     * @return {?}
     */
    CacheLocalStorage.prototype.type = /**
     * @return {?}
     */
    function () {
        return 0 /* LOCAL_STORAGE */;
    };
    /**
     * @return {?}
     */
    CacheLocalStorage.prototype.isEnabled = /**
     * @return {?}
     */
    function () {
        try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            return true;
        }
        catch (e) {
            return false;
        }
    };
    CacheLocalStorage.decorators = [
        { type: Injectable }
    ];
    return CacheLocalStorage;
}(CacheStorageAbstract));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Service for storing data in local storage
 */
var CacheMemoryStorage = /** @class */ (function (_super) {
    __extends(CacheMemoryStorage, _super);
    function CacheMemoryStorage() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._data = {};
        return _this;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    CacheMemoryStorage.prototype.getItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this._data[key] ? this._data[key] : null;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    CacheMemoryStorage.prototype.setItem = /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        this._data[key] = value;
        return true;
    };
    /**
     * @param {?} key
     * @return {?}
     */
    CacheMemoryStorage.prototype.removeItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        delete this._data[key];
    };
    /**
     * @return {?}
     */
    CacheMemoryStorage.prototype.clear = /**
     * @return {?}
     */
    function () {
        this._data = [];
    };
    /**
     * @return {?}
     */
    CacheMemoryStorage.prototype.type = /**
     * @return {?}
     */
    function () {
        return 2 /* MEMORY */;
    };
    /**
     * @return {?}
     */
    CacheMemoryStorage.prototype.isEnabled = /**
     * @return {?}
     */
    function () {
        return true;
    };
    CacheMemoryStorage.decorators = [
        { type: Injectable }
    ];
    return CacheMemoryStorage;
}(CacheStorageAbstract));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CACHE_PREFIX = 'CacheService';
/** @type {?} */
var DEFAULT_STORAGE = 2 /* MEMORY */;
/** @type {?} */
var DEFAULT_ENABLED_STORAGE = 1 /* SESSION_STORAGE */;
var CacheService = /** @class */ (function () {
    function CacheService(_storage) {
        this._storage = _storage;
        /**
         * Default cache options
         */
        this._defaultOptions = {
            expires: Number.MAX_VALUE,
            maxAge: Number.MAX_VALUE
        };
        /**
         * Cache prefix
         */
        this._prefix = CACHE_PREFIX;
        this._validateStorage();
    }
    /**
     * Set data to cache
     * @param key key
     * @param value value
     * @param options options
     */
    /**
     * Set data to cache
     * @param {?} key key
     * @param {?} value value
     * @param {?=} options options
     * @return {?}
     */
    CacheService.prototype.set = /**
     * Set data to cache
     * @param {?} key key
     * @param {?} value value
     * @param {?=} options options
     * @return {?}
     */
    function (key, value, options) {
        /** @type {?} */
        var storageKey = this._toStorageKey(key);
        options = options ? options : this._defaultOptions;
        if (this._storage.setItem(storageKey, this._toStorageValue(value, options))) {
            if (!this._isSystemKey(key) && options.tag) {
                this._saveTag(options.tag, storageKey);
            }
            return true;
        }
        return false;
    };
    /**
     * Get data from cache
     * @param key key
     * @returns result
     */
    /**
     * Get data from cache
     * @param {?} key key
     * @return {?} result
     */
    CacheService.prototype.get = /**
     * Get data from cache
     * @param {?} key key
     * @return {?} result
     */
    function (key) {
        /** @type {?} */
        var storageValue = this._storage.getItem(this._toStorageKey(key));
        /** @type {?} */
        var value = null;
        if (storageValue) {
            if (this._validateStorageValue(storageValue)) {
                value = storageValue.value;
            }
            else {
                this.remove(key);
            }
        }
        return value;
    };
    /**
     * Check if value exists
     * @param key key
     * @returns result
     */
    /**
     * Check if value exists
     * @param {?} key key
     * @return {?} result
     */
    CacheService.prototype.exists = /**
     * Check if value exists
     * @param {?} key key
     * @return {?} result
     */
    function (key) {
        return !!this.get(key);
    };
    /**
     * Remove item from cache
     * @param key key
     */
    /**
     * Remove item from cache
     * @param {?} key key
     * @return {?}
     */
    CacheService.prototype.remove = /**
     * Remove item from cache
     * @param {?} key key
     * @return {?}
     */
    function (key) {
        this._storage.removeItem(this._toStorageKey(key));
        this._removeFromTag(this._toStorageKey(key));
    };
    /**
     * Remove all from cache
     */
    /**
     * Remove all from cache
     * @return {?}
     */
    CacheService.prototype.removeAll = /**
     * Remove all from cache
     * @return {?}
     */
    function () {
        this._storage.clear();
    };
    /**
     * Get all tag data
     * @param tag tag
     * @returns result
     */
    /**
     * Get all tag data
     * @param {?} tag tag
     * @return {?} result
     */
    CacheService.prototype.getTagData = /**
     * Get all tag data
     * @param {?} tag tag
     * @return {?} result
     */
    function (tag) {
        var _this = this;
        /** @type {?} */
        var tags = this.get(this._tagsStorageKey()) || {};
        /** @type {?} */
        var result = {};
        if (tags[tag]) {
            tags[tag].forEach(function (key) {
                /** @type {?} */
                var data = _this.get(_this._fromStorageKey(key));
                if (data) {
                    result[_this._fromStorageKey(key)] = data;
                }
            });
        }
        return result;
    };
    /**
     * Create a new instance of cache with needed storage
     * @param type type
     * @returns result
     */
    /**
     * Create a new instance of cache with needed storage
     * @param {?} type type
     * @return {?} result
     */
    CacheService.prototype.useStorage = /**
     * Create a new instance of cache with needed storage
     * @param {?} type type
     * @return {?} result
     */
    function (type) {
        /** @type {?} */
        var service = new CacheService(this._initStorage(type));
        service.setGlobalPrefix(this._getCachePrefix());
        return service;
    };
    /**
     * Remove all by tag
     * @param tag tag
     */
    /**
     * Remove all by tag
     * @param {?} tag tag
     * @return {?}
     */
    CacheService.prototype.removeTag = /**
     * Remove all by tag
     * @param {?} tag tag
     * @return {?}
     */
    function (tag) {
        var _this = this;
        /** @type {?} */
        var tags = this.get(this._tagsStorageKey()) || {};
        if (tags[tag]) {
            tags[tag].forEach(function (key) {
                _this._storage.removeItem(key);
            });
            delete tags[tag];
            this.set(this._tagsStorageKey(), tags);
        }
    };
    /**
     * Set global cache key prefix
     * @param prefix prefix
     */
    /**
     * Set global cache key prefix
     * @param {?} prefix prefix
     * @return {?}
     */
    CacheService.prototype.setGlobalPrefix = /**
     * Set global cache key prefix
     * @param {?} prefix prefix
     * @return {?}
     */
    function (prefix) {
        this._prefix = prefix;
    };
    /**
     * Validate cache storage
     */
    /**
     * Validate cache storage
     * @private
     * @return {?}
     */
    CacheService.prototype._validateStorage = /**
     * Validate cache storage
     * @private
     * @return {?}
     */
    function () {
        if (!this._storage) {
            this._storage = this._initStorage(DEFAULT_STORAGE);
        }
        if (!this._storage.isEnabled()) {
            this._storage = this._initStorage(DEFAULT_ENABLED_STORAGE);
        }
    };
    /**
     * Remove key from tags keys list
     * @param key key
     */
    /**
     * Remove key from tags keys list
     * @private
     * @param {?} key key
     * @return {?}
     */
    CacheService.prototype._removeFromTag = /**
     * Remove key from tags keys list
     * @private
     * @param {?} key key
     * @return {?}
     */
    function (key) {
        // tslint:disable-next-line:prefer-const
        /** @type {?} */
        var tags = this.get(this._tagsStorageKey()) || {};
        /** @type {?} */
        var index;
        // tslint:disable-next-line:forin
        for (var tag in tags) {
            index = tags[tag].indexOf(key);
            if (index !== -1) {
                tags[tag].splice(index, 1);
                this.set(this._tagsStorageKey(), tags);
                break;
            }
        }
    };
    /**
     * Init storage by type
     * @param type type
     */
    /**
     * Init storage by type
     * @private
     * @param {?} type type
     * @return {?}
     */
    CacheService.prototype._initStorage = /**
     * Init storage by type
     * @private
     * @param {?} type type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var storage;
        switch (type) {
            case 1 /* SESSION_STORAGE */:
                storage = new CacheSessionStorage();
                break;
            case 0 /* LOCAL_STORAGE */:
                storage = new CacheLocalStorage();
                break;
            default: storage = new CacheMemoryStorage();
        }
        return storage;
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    CacheService.prototype._toStorageKey = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this._getCachePrefix() + key;
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    CacheService.prototype._fromStorageKey = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return key.replace(this._getCachePrefix(), '');
    };
    /**
     * Prepare value to set to storage
     * @param value value
     * @param options options
     * @returns result
     */
    /**
     * Prepare value to set to storage
     * @private
     * @param {?} value value
     * @param {?} options options
     * @return {?} result
     */
    CacheService.prototype._toStorageValue = /**
     * Prepare value to set to storage
     * @private
     * @param {?} value value
     * @param {?} options options
     * @return {?} result
     */
    function (value, options) {
        return {
            value: value,
            options: this._toStorageOptions(options)
        };
    };
    /**
     * Prepare options to set to storage
     * @param options options
     * @returns result
     */
    /**
     * Prepare options to set to storage
     * @private
     * @param {?} options options
     * @return {?} result
     */
    CacheService.prototype._toStorageOptions = /**
     * Prepare options to set to storage
     * @private
     * @param {?} options options
     * @return {?} result
     */
    function (options) {
        /** @type {?} */
        var storageOptions = {};
        storageOptions.expires = options.expires ? options.expires :
            (options.maxAge ? Date.now() + (options.maxAge * 1000) : this._defaultOptions.expires);
        storageOptions.maxAge = options.maxAge ? options.maxAge : this._defaultOptions.maxAge;
        return storageOptions;
    };
    /**
     * Validate storage value
     * @param value value
     * @returns result
     */
    /**
     * Validate storage value
     * @private
     * @param {?} value value
     * @return {?} result
     */
    CacheService.prototype._validateStorageValue = /**
     * Validate storage value
     * @private
     * @param {?} value value
     * @return {?} result
     */
    function (value) {
        return !!value.options.expires && value.options.expires > Date.now();
    };
    /**
     * check if its system cache key
     * @param key key
     * @returns result
     */
    /**
     * check if its system cache key
     * @private
     * @param {?} key key
     * @return {?} result
     */
    CacheService.prototype._isSystemKey = /**
     * check if its system cache key
     * @private
     * @param {?} key key
     * @return {?} result
     */
    function (key) {
        return [this._tagsStorageKey()].indexOf(key) !== -1;
    };
    /**
     * Save tag to list of tags
     * @param tag tag
     * @param key key
     */
    /**
     * Save tag to list of tags
     * @private
     * @param {?} tag tag
     * @param {?} key key
     * @return {?}
     */
    CacheService.prototype._saveTag = /**
     * Save tag to list of tags
     * @private
     * @param {?} tag tag
     * @param {?} key key
     * @return {?}
     */
    function (tag, key) {
        /** @type {?} */
        var tags = this.get(this._tagsStorageKey()) || {};
        if (!tags[tag]) {
            tags[tag] = [key];
        }
        else {
            tags[tag].push(key);
        }
        this.set(this._tagsStorageKey(), tags);
    };
    /**
     * Get global cache prefix
     * @returns result
     */
    /**
     * Get global cache prefix
     * @private
     * @return {?} result
     */
    CacheService.prototype._getCachePrefix = /**
     * Get global cache prefix
     * @private
     * @return {?} result
     */
    function () {
        return this._prefix;
    };
    /**
     * @private
     * @return {?}
     */
    CacheService.prototype._tagsStorageKey = /**
     * @private
     * @return {?}
     */
    function () {
        return 'CacheService_tags';
    };
    CacheService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    CacheService.ctorParameters = function () { return [
        { type: CacheStorageAbstract, decorators: [{ type: Optional }] }
    ]; };
    return CacheService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import { calculateSpecificity, validateSelector } from 'clear-cut';
// const _ = require('underscore-plus')
/** @type {?} */
var SequenceCount = 0;
// Public: Associates listener functions with commands in a
// context-sensitive way using CSS selectors. You can access a global instance of
// this class via `atom.commands`, and commands registered there will be
// presented in the command palette.
//
// The global command registry facilitates a style of event handling known as
// *event delegation* that was popularized by jQuery. Atom commands are expressed
// as custom DOM events that can be invoked on the currently focused element via
// a key binding or manually via the command palette. Rather than binding
// listeners for command events directly to DOM nodes, you instead register
// command event listeners globally on `atom.commands` and constrain them to
// specific kinds of elements with CSS selectors.
//
// Command names must follow the `namespace:action` pattern, where `namespace`
// will typically be the name of your package, and `action` describes the
// behavior of your command. If either part consists of multiple words, these
// must be separated by hyphens. E.g. `awesome-package:turn-it-up-to-eleven`.
// All words should be lowercased.
//
// As the event bubbles upward through the DOM, all registered event listeners
// with matching selectors are invoked in order of specificity. In the event of a
// specificity tie, the most recently registered listener is invoked first. This
// mirrors the "cascade" semantics of CSS. Event listeners are invoked in the
// context of the current DOM node, meaning `this` always points at
// `event.currentTarget`. As is normally the case with DOM events,
// `stopPropagation` and `stopImmediatePropagation` can be used to terminate the
// bubbling process and prevent invocation of additional listeners.
//
// ## Example
//
// Here is a command that inserts the current date in an editor:
//
// ```coffee
// atom.commands.add 'atom-text-editor',
//   'user:insert-date': (event) ->
//     editor = @getModel()
//     editor.insertText(new Date().toLocaleString())
// ```
var 
// Public: Associates listener functions with commands in a
// context-sensitive way using CSS selectors. You can access a global instance of
// this class via `atom.commands`, and commands registered there will be
// presented in the command palette.
//
// The global command registry facilitates a style of event handling known as
// *event delegation* that was popularized by jQuery. Atom commands are expressed
// as custom DOM events that can be invoked on the currently focused element via
// a key binding or manually via the command palette. Rather than binding
// listeners for command events directly to DOM nodes, you instead register
// command event listeners globally on `atom.commands` and constrain them to
// specific kinds of elements with CSS selectors.
//
// Command names must follow the `namespace:action` pattern, where `namespace`
// will typically be the name of your package, and `action` describes the
// behavior of your command. If either part consists of multiple words, these
// must be separated by hyphens. E.g. `awesome-package:turn-it-up-to-eleven`.
// All words should be lowercased.
//
// As the event bubbles upward through the DOM, all registered event listeners
// with matching selectors are invoked in order of specificity. In the event of a
// specificity tie, the most recently registered listener is invoked first. This
// mirrors the "cascade" semantics of CSS. Event listeners are invoked in the
// context of the current DOM node, meaning `this` always points at
// `event.currentTarget`. As is normally the case with DOM events,
// `stopPropagation` and `stopImmediatePropagation` can be used to terminate the
// bubbling process and prevent invocation of additional listeners.
//
// ## Example
//
// Here is a command that inserts the current date in an editor:
//
// ```coffee
// atom.commands.add 'atom-text-editor',
//   'user:insert-date': (event) ->
//     editor = @getModel()
//     editor.insertText(new Date().toLocaleString())
// ```
CommandRegistry = /** @class */ (function () {
    function CommandRegistry() {
        this.handleCommandEvent = this.handleCommandEvent.bind(this);
        this.rootNode = null;
        this.clear();
    }
    /**
     * @return {?}
     */
    CommandRegistry.prototype.clear = /**
     * @return {?}
     */
    function () {
        this.registeredCommands = {};
        this.selectorBasedListenersByCommandName = {};
        this.inlineListenersByCommandName = {};
        this.emitter = new Emitter();
    };
    /**
     * @param {?} rootNode
     * @return {?}
     */
    CommandRegistry.prototype.attach = /**
     * @param {?} rootNode
     * @return {?}
     */
    function (rootNode) {
        this.rootNode = rootNode;
        for (var command in this.selectorBasedListenersByCommandName) {
            this.commandRegistered(command);
        }
        for (var command in this.inlineListenersByCommandName) {
            this.commandRegistered(command);
        }
    };
    /**
     * @return {?}
     */
    CommandRegistry.prototype.destroy = /**
     * @return {?}
     */
    function () {
        for (var commandName in this.registeredCommands) {
            this.rootNode.removeEventListener(commandName, this.handleCommandEvent, true);
        }
    };
    // Public: Add one or more command listeners associated with a selector.
    //
    // ## Arguments: Registering One Command
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the command will be globally associated with all matching
    //   elements. The `,` combinator is not currently supported. If you pass a
    //   DOM element, the command will be associated with just that element.
    // * `commandName` A {String} containing the name of a command you want to
    //   handle such as `user:insert-date`.
    // * `listener` A listener which handles the event.  Either a {Function} to
    //   call when the given command is invoked on an element matching the
    //   selector, or an {Object} with a `didDispatch` property which is such a
    //   function.
    //
    //   The function (`listener` itself if it is a function, or the `didDispatch`
    //   method if `listener` is an object) will be called with `this` referencing
    //   the matching DOM node and the following argument:
    //     * `event`: A standard DOM event instance. Call `stopPropagation` or
    //       `stopImmediatePropagation` to terminate bubbling early.
    //
    //   Additionally, `listener` may have additional properties which are returned
    //   to those who query using `atom.commands.findCommands`, as well as several
    //   meaningful metadata properties:
    //     * `displayName`: Overrides any generated `displayName` that would
    //       otherwise be generated from the event name.
    //     * `description`: Used by consumers to display detailed information about
    //       the command.
    //     * `hiddenInCommandPalette`: If `true`, this command will not appear in
    //       the bundled command palette by default, but can still be shown with.
    //       the `Command Palette: Show Hidden Commands` command. This is a good
    //       option when you need to register large numbers of commands that don't
    //       make sense to be executed from the command palette. Please use this
    //       option conservatively, as it could reduce the discoverability of your
    //       package's commands.
    //
    // ## Arguments: Registering Multiple Commands
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the commands will be globally associated with all
    //   matching elements. The `,` combinator is not currently supported.
    //   If you pass a DOM element, the command will be associated with just that
    //   element.
    // * `commands` An {Object} mapping command names like `user:insert-date` to
    //   listener {Function}s.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added command handler(s).
    // Public: Add one or more command listeners associated with a selector.
    //
    // ## Arguments: Registering One Command
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the command will be globally associated with all matching
    //   elements. The `,` combinator is not currently supported. If you pass a
    //   DOM element, the command will be associated with just that element.
    // * `commandName` A {String} containing the name of a command you want to
    //   handle such as `user:insert-date`.
    // * `listener` A listener which handles the event.  Either a {Function} to
    //   call when the given command is invoked on an element matching the
    //   selector, or an {Object} with a `didDispatch` property which is such a
    //   function.
    //
    //   The function (`listener` itself if it is a function, or the `didDispatch`
    //   method if `listener` is an object) will be called with `this` referencing
    //   the matching DOM node and the following argument:
    //     * `event`: A standard DOM event instance. Call `stopPropagation` or
    //       `stopImmediatePropagation` to terminate bubbling early.
    //
    //   Additionally, `listener` may have additional properties which are returned
    //   to those who query using `atom.commands.findCommands`, as well as several
    //   meaningful metadata properties:
    //     * `displayName`: Overrides any generated `displayName` that would
    //       otherwise be generated from the event name.
    //     * `description`: Used by consumers to display detailed information about
    //       the command.
    //     * `hiddenInCommandPalette`: If `true`, this command will not appear in
    //       the bundled command palette by default, but can still be shown with.
    //       the `Command Palette: Show Hidden Commands` command. This is a good
    //       option when you need to register large numbers of commands that don't
    //       make sense to be executed from the command palette. Please use this
    //       option conservatively, as it could reduce the discoverability of your
    //       package's commands.
    //
    // ## Arguments: Registering Multiple Commands
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the commands will be globally associated with all
    //   matching elements. The `,` combinator is not currently supported.
    //   If you pass a DOM element, the command will be associated with just that
    //   element.
    // * `commands` An {Object} mapping command names like `user:insert-date` to
    //   listener {Function}s.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added command handler(s).
    /**
     * @param {?} target
     * @param {?} commandName
     * @param {?} listener
     * @param {?=} throwOnInvalidSelector
     * @return {?}
     */
    CommandRegistry.prototype.add = 
    // Public: Add one or more command listeners associated with a selector.
    //
    // ## Arguments: Registering One Command
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the command will be globally associated with all matching
    //   elements. The `,` combinator is not currently supported. If you pass a
    //   DOM element, the command will be associated with just that element.
    // * `commandName` A {String} containing the name of a command you want to
    //   handle such as `user:insert-date`.
    // * `listener` A listener which handles the event.  Either a {Function} to
    //   call when the given command is invoked on an element matching the
    //   selector, or an {Object} with a `didDispatch` property which is such a
    //   function.
    //
    //   The function (`listener` itself if it is a function, or the `didDispatch`
    //   method if `listener` is an object) will be called with `this` referencing
    //   the matching DOM node and the following argument:
    //     * `event`: A standard DOM event instance. Call `stopPropagation` or
    //       `stopImmediatePropagation` to terminate bubbling early.
    //
    //   Additionally, `listener` may have additional properties which are returned
    //   to those who query using `atom.commands.findCommands`, as well as several
    //   meaningful metadata properties:
    //     * `displayName`: Overrides any generated `displayName` that would
    //       otherwise be generated from the event name.
    //     * `description`: Used by consumers to display detailed information about
    //       the command.
    //     * `hiddenInCommandPalette`: If `true`, this command will not appear in
    //       the bundled command palette by default, but can still be shown with.
    //       the `Command Palette: Show Hidden Commands` command. This is a good
    //       option when you need to register large numbers of commands that don't
    //       make sense to be executed from the command palette. Please use this
    //       option conservatively, as it could reduce the discoverability of your
    //       package's commands.
    //
    // ## Arguments: Registering Multiple Commands
    //
    // * `target` A {String} containing a CSS selector or a DOM element. If you
    //   pass a selector, the commands will be globally associated with all
    //   matching elements. The `,` combinator is not currently supported.
    //   If you pass a DOM element, the command will be associated with just that
    //   element.
    // * `commands` An {Object} mapping command names like `user:insert-date` to
    //   listener {Function}s.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added command handler(s).
    /**
     * @param {?} target
     * @param {?} commandName
     * @param {?} listener
     * @param {?=} throwOnInvalidSelector
     * @return {?}
     */
    function (target, commandName, listener, throwOnInvalidSelector) {
        if (throwOnInvalidSelector === void 0) { throwOnInvalidSelector = true; }
        if (typeof commandName === 'object') {
            /** @type {?} */
            var commands = commandName;
            throwOnInvalidSelector = listener;
            /** @type {?} */
            var disposable = new CompositeDisposable();
            for (commandName in commands) {
                listener = commands[commandName];
                disposable.add(this.add(target, commandName, listener, throwOnInvalidSelector));
            }
            return disposable;
        }
        if (listener == null) {
            throw new Error('Cannot register a command with a null listener.');
        }
        // type Listener = ((e: CustomEvent) => void) | {
        //   displayName?: string,
        //   description?: string,
        //   didDispatch(e: CustomEvent): void,
        // }
        if ((typeof listener !== 'function') && (typeof listener.didDispatch !== 'function')) {
            throw new Error('Listener must be a callback function or an object with a didDispatch method.');
        }
        if (typeof target === 'string') {
            if (throwOnInvalidSelector) {
                validateSelector(target);
            }
            return this.addSelectorBasedListener(target, commandName, listener);
        }
        else {
            return this.addInlineListener(target, commandName, listener);
        }
    };
    /**
     * @param {?} selector
     * @param {?} commandName
     * @param {?} listener
     * @return {?}
     */
    CommandRegistry.prototype.addSelectorBasedListener = /**
     * @param {?} selector
     * @param {?} commandName
     * @param {?} listener
     * @return {?}
     */
    function (selector, commandName, listener) {
        var _this = this;
        if (this.selectorBasedListenersByCommandName[commandName] == null) {
            this.selectorBasedListenersByCommandName[commandName] = [];
        }
        /** @type {?} */
        var listenersForCommand = this.selectorBasedListenersByCommandName[commandName];
        /** @type {?} */
        var selectorListener = new SelectorBasedListener(selector, commandName, listener);
        listenersForCommand.push(selectorListener);
        this.commandRegistered(commandName);
        return new Disposable(function () {
            listenersForCommand.splice(listenersForCommand.indexOf(selectorListener), 1);
            if (listenersForCommand.length === 0) {
                delete _this.selectorBasedListenersByCommandName[commandName];
            }
        });
    };
    /**
     * @param {?} element
     * @param {?} commandName
     * @param {?} listener
     * @return {?}
     */
    CommandRegistry.prototype.addInlineListener = /**
     * @param {?} element
     * @param {?} commandName
     * @param {?} listener
     * @return {?}
     */
    function (element, commandName, listener) {
        if (this.inlineListenersByCommandName[commandName] == null) {
            this.inlineListenersByCommandName[commandName] = new WeakMap();
        }
        /** @type {?} */
        var listenersForCommand = this.inlineListenersByCommandName[commandName];
        /** @type {?} */
        var listenersForElement = listenersForCommand.get(element);
        if (!listenersForElement) {
            listenersForElement = [];
            listenersForCommand.set(element, listenersForElement);
        }
        /** @type {?} */
        var inlineListener = new InlineListener(commandName, listener);
        listenersForElement.push(inlineListener);
        this.commandRegistered(commandName);
        return new Disposable(function () {
            listenersForElement.splice(listenersForElement.indexOf(inlineListener), 1);
            if (listenersForElement.length === 0) {
                listenersForCommand.delete(element);
            }
        });
    };
    // Public: Find all registered commands matching a query.
    //
    // * `params` An {Object} containing one or more of the following keys:
    //   * `target` A DOM node that is the hypothetical target of a given command.
    //
    // Returns an {Array} of `CommandDescriptor` {Object}s containing the following keys:
    //  * `name` The name of the command. For example, `user:insert-date`.
    //  * `displayName` The display name of the command. For example,
    //    `User: Insert Date`.
    // Additional metadata may also be present in the returned descriptor:
    //  * `description` a {String} describing the function of the command in more
    //    detail than the title
    //  * `tags` an {Array} of {String}s that describe keywords related to the
    //    command
    //  Any additional nonstandard metadata provided when the command was `add`ed
    //  may also be present in the returned descriptor.
    // Public: Find all registered commands matching a query.
    //
    // * `params` An {Object} containing one or more of the following keys:
    //   * `target` A DOM node that is the hypothetical target of a given command.
    //
    // Returns an {Array} of `CommandDescriptor` {Object}s containing the following keys:
    //  * `name` The name of the command. For example, `user:insert-date`.
    //  * `displayName` The display name of the command. For example,
    //    `User: Insert Date`.
    // Additional metadata may also be present in the returned descriptor:
    //  * `description` a {String} describing the function of the command in more
    //    detail than the title
    //  * `tags` an {Array} of {String}s that describe keywords related to the
    //    command
    //  Any additional nonstandard metadata provided when the command was `add`ed
    //  may also be present in the returned descriptor.
    /**
     * @param {?} __0
     * @return {?}
     */
    CommandRegistry.prototype.findCommands = 
    // Public: Find all registered commands matching a query.
    //
    // * `params` An {Object} containing one or more of the following keys:
    //   * `target` A DOM node that is the hypothetical target of a given command.
    //
    // Returns an {Array} of `CommandDescriptor` {Object}s containing the following keys:
    //  * `name` The name of the command. For example, `user:insert-date`.
    //  * `displayName` The display name of the command. For example,
    //    `User: Insert Date`.
    // Additional metadata may also be present in the returned descriptor:
    //  * `description` a {String} describing the function of the command in more
    //    detail than the title
    //  * `tags` an {Array} of {String}s that describe keywords related to the
    //    command
    //  Any additional nonstandard metadata provided when the command was `add`ed
    //  may also be present in the returned descriptor.
    /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var target = _a.target;
        var e_1, _b;
        /** @type {?} */
        var commandNames = new Set();
        /** @type {?} */
        var commands = [];
        /** @type {?} */
        var currentTarget = target;
        while (true) {
            /** @type {?} */
            var listeners = void 0;
            for (var name_1 in this.inlineListenersByCommandName) {
                listeners = this.inlineListenersByCommandName[name_1];
                if (listeners.has(currentTarget) && !commandNames.has(name_1)) {
                    commandNames.add(name_1);
                    /** @type {?} */
                    var targetListeners = listeners.get(currentTarget);
                    commands.push.apply(commands, __spread(targetListeners.map(function (listener) { return listener.descriptor; })));
                }
            }
            for (var commandName in this.selectorBasedListenersByCommandName) {
                listeners = this.selectorBasedListenersByCommandName[commandName];
                try {
                    for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
                        var listener = listeners_1_1.value;
                        if (listener.matchesTarget(currentTarget)) {
                            if (!commandNames.has(commandName)) {
                                commandNames.add(commandName);
                                commands.push(listener.descriptor);
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (listeners_1_1 && !listeners_1_1.done && (_b = listeners_1.return)) _b.call(listeners_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            if (currentTarget === window) {
                break;
            }
            currentTarget = currentTarget.parentNode || window;
        }
        return commands;
    };
    // Public: Simulate the dispatch of a command on a DOM node.
    //
    // This can be useful for testing when you want to simulate the invocation of a
    // command on a detached DOM node. Otherwise, the DOM node in question needs to
    // be attached to the document so the event bubbles up to the root node to be
    // processed.
    //
    // * `target` The DOM node at which to start bubbling the command event.
    // * `commandName` {String} indicating the name of the command to dispatch.
    // Public: Simulate the dispatch of a command on a DOM node.
    //
    // This can be useful for testing when you want to simulate the invocation of a
    // command on a detached DOM node. Otherwise, the DOM node in question needs to
    // be attached to the document so the event bubbles up to the root node to be
    // processed.
    //
    // * `target` The DOM node at which to start bubbling the command event.
    // * `commandName` {String} indicating the name of the command to dispatch.
    /**
     * @param {?} target
     * @param {?} commandName
     * @param {?} detail
     * @return {?}
     */
    CommandRegistry.prototype.dispatch = 
    // Public: Simulate the dispatch of a command on a DOM node.
    //
    // This can be useful for testing when you want to simulate the invocation of a
    // command on a detached DOM node. Otherwise, the DOM node in question needs to
    // be attached to the document so the event bubbles up to the root node to be
    // processed.
    //
    // * `target` The DOM node at which to start bubbling the command event.
    // * `commandName` {String} indicating the name of the command to dispatch.
    /**
     * @param {?} target
     * @param {?} commandName
     * @param {?} detail
     * @return {?}
     */
    function (target, commandName, detail) {
        /** @type {?} */
        var event = new CustomEvent(commandName, { bubbles: true, detail: detail });
        Object.defineProperty(event, 'target', { value: target });
        return this.handleCommandEvent(event);
    };
    // Public: Invoke the given callback before dispatching a command event.
    //
    // * `callback` {Function} to be called before dispatching each command
    //   * `event` The Event that will be dispatched
    // Public: Invoke the given callback before dispatching a command event.
    //
    // * `callback` {Function} to be called before dispatching each command
    //   * `event` The Event that will be dispatched
    /**
     * @param {?} callback
     * @return {?}
     */
    CommandRegistry.prototype.onWillDispatch = 
    // Public: Invoke the given callback before dispatching a command event.
    //
    // * `callback` {Function} to be called before dispatching each command
    //   * `event` The Event that will be dispatched
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('will-dispatch', callback);
    };
    // Public: Invoke the given callback after dispatching a command event.
    //
    // * `callback` {Function} to be called after dispatching each command
    //   * `event` The Event that was dispatched
    // Public: Invoke the given callback after dispatching a command event.
    //
    // * `callback` {Function} to be called after dispatching each command
    //   * `event` The Event that was dispatched
    /**
     * @param {?} callback
     * @return {?}
     */
    CommandRegistry.prototype.onDidDispatch = 
    // Public: Invoke the given callback after dispatching a command event.
    //
    // * `callback` {Function} to be called after dispatching each command
    //   * `event` The Event that was dispatched
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-dispatch', callback);
    };
    /**
     * @return {?}
     */
    CommandRegistry.prototype.getSnapshot = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var snapshot = {};
        for (var commandName in this.selectorBasedListenersByCommandName) {
            /** @type {?} */
            var listeners = this.selectorBasedListenersByCommandName[commandName];
            snapshot[commandName] = listeners.slice();
        }
        return snapshot;
    };
    /**
     * @param {?} snapshot
     * @return {?}
     */
    CommandRegistry.prototype.restoreSnapshot = /**
     * @param {?} snapshot
     * @return {?}
     */
    function (snapshot) {
        this.selectorBasedListenersByCommandName = {};
        for (var commandName in snapshot) {
            /** @type {?} */
            var listeners = snapshot[commandName];
            this.selectorBasedListenersByCommandName[commandName] = listeners.slice();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CommandRegistry.prototype.handleCommandEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var e_2, _a;
        /** @type {?} */
        var propagationStopped = false;
        /** @type {?} */
        var immediatePropagationStopped = false;
        /** @type {?} */
        var matched = [];
        /** @type {?} */
        var currentTarget = event.target;
        /** @type {?} */
        var dispatchedEvent = new CustomEvent(event.type, {
            bubbles: true,
            detail: event.detail
        });
        Object.defineProperty(dispatchedEvent, 'eventPhase', {
            value: Event.BUBBLING_PHASE
        });
        Object.defineProperty(dispatchedEvent, 'currentTarget', {
            get: /**
             * @return {?}
             */
            function () {
                return currentTarget;
            }
        });
        Object.defineProperty(dispatchedEvent, 'target', { value: currentTarget });
        Object.defineProperty(dispatchedEvent, 'preventDefault', {
            value: /**
             * @return {?}
             */
            function () {
                return event.preventDefault();
            }
        });
        Object.defineProperty(dispatchedEvent, 'stopPropagation', {
            value: /**
             * @return {?}
             */
            function () {
                event.stopPropagation();
                propagationStopped = true;
            }
        });
        Object.defineProperty(dispatchedEvent, 'stopImmediatePropagation', {
            value: /**
             * @return {?}
             */
            function () {
                event.stopImmediatePropagation();
                propagationStopped = true;
                immediatePropagationStopped = true;
            }
        });
        Object.defineProperty(dispatchedEvent, 'abortKeyBinding', {
            value: /**
             * @return {?}
             */
            function () {
                if (typeof event.abortKeyBinding === 'function') {
                    event.abortKeyBinding();
                }
            }
        });
        try {
            for (var _b = __values(Object.keys(event)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (!(key in dispatchedEvent)) {
                    dispatchedEvent[key] = event[key];
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.emitter.emit('will-dispatch', dispatchedEvent);
        while (true) {
            /** @type {?} */
            var commandInlineListeners = this.inlineListenersByCommandName[event.type]
                ? this.inlineListenersByCommandName[event.type].get(currentTarget)
                : null;
            /** @type {?} */
            var listeners = commandInlineListeners || [];
            if (currentTarget.webkitMatchesSelector != null) {
                /** @type {?} */
                var selectorBasedListeners = (this.selectorBasedListenersByCommandName[event.type] || [])
                    .filter(function (listener) { return listener.matchesTarget(currentTarget); })
                    .sort(function (a, b) { return a.compare(b); });
                listeners = selectorBasedListeners.concat(listeners);
            }
            // Call inline listeners first in reverse registration order,
            // and selector-based listeners by specificity and reverse
            // registration order.
            for (var i = listeners.length - 1; i >= 0; i--) {
                /** @type {?} */
                var listener = listeners[i];
                if (immediatePropagationStopped) {
                    break;
                }
                matched.push(listener.didDispatch.call(currentTarget, dispatchedEvent));
            }
            if (currentTarget === window) {
                break;
            }
            if (propagationStopped) {
                break;
            }
            currentTarget = currentTarget.parentNode || window;
        }
        this.emitter.emit('did-dispatch', dispatchedEvent);
        return (matched.length > 0 ? Promise.all(matched) : null);
    };
    /**
     * @param {?} commandName
     * @return {?}
     */
    CommandRegistry.prototype.commandRegistered = /**
     * @param {?} commandName
     * @return {?}
     */
    function (commandName) {
        if (this.rootNode != null && !this.registeredCommands[commandName]) {
            this.rootNode.addEventListener(commandName, this.handleCommandEvent, true);
            return (this.registeredCommands[commandName] = true);
        }
    };
    return CommandRegistry;
}());
// type Listener = {
//   descriptor: CommandDescriptor,
//   extractDidDispatch: (e: CustomEvent) => void,
// };
var 
// type Listener = {
//   descriptor: CommandDescriptor,
//   extractDidDispatch: (e: CustomEvent) => void,
// };
SelectorBasedListener = /** @class */ (function () {
    function SelectorBasedListener(selector, commandName, listener) {
        this.selector = selector;
        this.didDispatch = extractDidDispatch(listener);
        this.descriptor = extractDescriptor(commandName, listener);
        this.specificity = calculateSpecificity(this.selector);
        this.sequenceNumber = SequenceCount++;
    }
    /**
     * @param {?} other
     * @return {?}
     */
    SelectorBasedListener.prototype.compare = /**
     * @param {?} other
     * @return {?}
     */
    function (other) {
        return (this.specificity - other.specificity ||
            this.sequenceNumber - other.sequenceNumber);
    };
    /**
     * @param {?} target
     * @return {?}
     */
    SelectorBasedListener.prototype.matchesTarget = /**
     * @param {?} target
     * @return {?}
     */
    function (target) {
        return target.webkitMatchesSelector && target.webkitMatchesSelector(this.selector);
    };
    return SelectorBasedListener;
}());
var InlineListener = /** @class */ (function () {
    function InlineListener(commandName, listener) {
        this.didDispatch = extractDidDispatch(listener);
        this.descriptor = extractDescriptor(commandName, listener);
    }
    return InlineListener;
}());
// type CommandDescriptor = {
//   name: string,
//   displayName: string,
// };
/**
 * @param {?} name
 * @param {?} listener
 * @return {?}
 */
function extractDescriptor(name, listener) {
    return Object.assign(omit(listener, 'didDispatch'), {
        name: name,
        displayName: listener.displayName ? listener.displayName : humanizeEventName(name)
    });
}
/**
 * @param {?} listener
 * @return {?}
 */
function extractDidDispatch(listener) {
    return typeof listener === 'function' ? listener : listener.didDispatch;
}
/**
 * @param {?} selector
 * @return {?}
 */
function validateSelector(selector) {
    if (!isSelectorValid(selector)) {
        /** @type {?} */
        var error = new SyntaxError(selector + ' is not a valid selector');
        // error.code = 'EBADSELECTOR';
        throw error;
    }
}
/**
 * @param {?} selector
 * @return {?}
 */
function isSelectorValid(selector) {
    /** @type {?} */
    var valid;
    try {
        document.querySelector(selector);
        valid = true;
    }
    catch (error) {
        valid = false;
    }
    return valid;
}
/**
 * @param {?} selector
 * @return {?}
 */
function calculateSpecificity(selector) {
    /** @type {?} */
    var specificity = calculate(selector);
    return specificity;
}
/**
 * @param {?} selector
 * @return {?}
 */
function calculate(selector) {
    /** @type {?} */
    var commaIndex = selector.indexOf(',');
    if (commaIndex !== -1) {
        selector = selector.substring(0, commaIndex);
    }
    /** @type {?} */
    var types = {
        a: 0,
        b: 0,
        c: 0
    };
    // The following regular expressions assume that selectors matching the preceding regular expressions have been removed
    /** @type {?} */
    var attributeRegex = /(\[[^\]]+\])/g;
    /** @type {?} */
    var idRegex = /(#[^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
    /** @type {?} */
    var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    var elementRegex = /([^\s\+>~\.\[:]+)/g;
    /** @type {?} */
    var notRegex = /:not\(([^\)]*)\)/g;
    /** @type {?} */
    var ruleRegex = /\{[^]*/gm;
    /** @type {?} */
    var separatorRegex = /[\*\s\+>~]/g;
    /** @type {?} */
    var straysRegex = /[#\.]/g;
    // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
    selector = selector.replace(notRegex, ' $1 ');
    // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
    selector = selector.replace(ruleRegex, ' ');
    // Add attribute selectors to parts collection (type b)
    selector = findMatch(attributeRegex, 'b', types, selector);
    // Add ID selectors to parts collection (type a)
    selector = findMatch(idRegex, 'a', types, selector);
    // Add class selectors to parts collection (type b)
    selector = findMatch(classRegex, 'b', types, selector);
    // Add pseudo-element selectors to parts collection (type c)
    selector = findMatch(pseudoElementRegex, 'c', types, selector);
    // Add pseudo-class selectors to parts collection (type b)
    selector = findMatch(pseudoClassRegex, 'b', types, selector);
    // Remove universal selector and separator characters
    selector = selector.replace(separatorRegex, ' ');
    // Remove any stray dots or hashes which aren't attached to words
    // These may be present if the user is live-editing this selector
    selector = selector.replace(straysRegex, ' ');
    // The only things left should be element selectors (type c)
    findMatch(elementRegex, 'c', types, selector);
    return (types.a * 100) + (types.b * 10) + (types.c * 1);
}
/**
 * @param {?} regex
 * @param {?} type
 * @param {?} types
 * @param {?} selector
 * @return {?}
 */
function findMatch(regex, type, types, selector) {
    var e_3, _a;
    /** @type {?} */
    var matches = selector.match(regex);
    if (matches) {
        try {
            for (var matches_1 = __values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                var match = matches_1_1.value;
                types[type]++;
                // Replace this simple selector with whitespace so it won't be counted in further simple selectors
                selector = selector.replace(match, ' ');
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    return selector;
}
/**
 * @param {?} obj
 * @param {...?} props
 * @return {?}
 */
function omit(obj) {
    // const iteratee = (value, key) => !props.find(key);
    var props = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        props[_i - 1] = arguments[_i];
    }
    // const iteratee = (value, key) => !props.find(key);
    /** @type {?} */
    var result = {};
    if (!obj) {
        return result;
    }
    Object.keys(obj).forEach(function (key) {
        if (!props.find(function (prop) { return prop === key; })) {
            return;
        }
        result[key] = obj[key];
    });
    return result;
}
/**
 * @param {?} eventName
 * @param {?=} eventDoc
 * @return {?}
 */
function humanizeEventName(eventName, eventDoc) {
    if (eventDoc === void 0) { eventDoc = null; }
    /** @type {?} */
    var ref = eventName.split(':');
    var _a = __read(ref, 2), namespace = _a[0], event = _a[1];
    if (event == null) {
        return undash(namespace);
    }
    /** @type {?} */
    var namespaceDoc = undash(namespace);
    if (eventDoc == null) {
        eventDoc = undash(event);
    }
    return '' + namespaceDoc + ': ' + eventDoc;
}
/**
 * @param {?} str
 * @return {?}
 */
function undash(str) {
    if (str) {
        return str.split('-').join(' ');
    }
    else {
        return '';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Util = /** @class */ (function () {
    function Util() {
    }
    /**
     * @return {?}
     */
    Util.prototype.newGuid = /**
     * @return {?}
     */
    function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            // tslint:disable: no-bitwise
            /** @type {?} */
            var r = Math.random() * 16 | 0;
            /** @type {?} */
            var v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };
    /**
     * 向url添加QueryParam
     * @param url 原始url
     * @param paramName 参数名
     * @param paramValue 参数值
     * @param override 是否覆盖。为True时，如果参数已存在，将覆盖已有参数，否则放弃处理。默认为False。
     */
    /**
     * 向url添加QueryParam
     * @param {?} url 原始url
     * @param {?} paramName 参数名
     * @param {?} paramValue 参数值
     * @param {?=} override 是否覆盖。为True时，如果参数已存在，将覆盖已有参数，否则放弃处理。默认为False。
     * @return {?}
     */
    Util.prototype.setUrlParam = /**
     * 向url添加QueryParam
     * @param {?} url 原始url
     * @param {?} paramName 参数名
     * @param {?} paramValue 参数值
     * @param {?=} override 是否覆盖。为True时，如果参数已存在，将覆盖已有参数，否则放弃处理。默认为False。
     * @return {?}
     */
    function (url, paramName, paramValue, override) {
        var _a = __read(url.split('?'), 2), path = _a[0], search = _a[1];
        /** @type {?} */
        var params = new URLSearchParams(search);
        if (params.has(paramName) && !override) {
            return url;
        }
        params.set(paramName, paramValue);
        return path + '?' + params.toString();
    };
    Util.decorators = [
        { type: Injectable }
    ];
    return Util;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: `ViewRegistry` handles the association between model and view
// types in Atom. We call this association a View Provider. As in, for a given
// model, this class can provide a view via {::getView}, as long as the
// model/view association was registered via {::addViewProvider}
//
// If you're adding your own kind of pane item, a good strategy for all but the
// simplest items is to separate the model and the view. The model handles
// application logic and is the primary point of API interaction. The view
// just handles presentation.
//
// Note: Models can be any object, but must implement a `getTitle()` function
// if they are to be displayed in a {Pane}
//
// View providers inform the workspace how your model objects should be
// presented in the DOM. A view provider must always return a DOM node, which
// makes [HTML 5 custom elements](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/)
// an ideal tool for implementing views in Atom.
//
// You can access the `ViewRegistry` object via `atom.views`.
var  
// Essential: `ViewRegistry` handles the association between model and view
// types in Atom. We call this association a View Provider. As in, for a given
// model, this class can provide a view via {::getView}, as long as the
// model/view association was registered via {::addViewProvider}
//
// If you're adding your own kind of pane item, a good strategy for all but the
// simplest items is to separate the model and the view. The model handles
// application logic and is the primary point of API interaction. The view
// just handles presentation.
//
// Note: Models can be any object, but must implement a `getTitle()` function
// if they are to be displayed in a {Pane}
//
// View providers inform the workspace how your model objects should be
// presented in the DOM. A view provider must always return a DOM node, which
// makes [HTML 5 custom elements](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/)
// an ideal tool for implementing views in Atom.
//
// You can access the `ViewRegistry` object via `atom.views`.
ViewRegistry = /** @class */ (function () {
    // private documentWriters: any;
    // private documentReaders: any;
    // private nextUpdatePromise: any;
    // private resolveNextUpdatePromise: (value?: {} | PromiseLike<{}>) => void;
    function ViewRegistry(gspEnvironment) {
        // this.animationFrameRequest = null
        // this.documentReadInProgress = false
        // this.performDocumentUpdate = this.performDocumentUpdate.bind(this);
        this.gspEnvironment = gspEnvironment;
        this.clear();
    }
    /**
     * @return {?}
     */
    ViewRegistry.prototype.clear = /**
     * @return {?}
     */
    function () {
        this.views = new WeakMap();
        this.providers = [];
        this.clearDocumentRequests();
    };
    // Essential: Add a provider that will be used to construct views in the
    // workspace's view layer based on model objects in its model layer.
    //
    // ## Examples
    //
    // Text editors are divided into a model and a view layer, so when you interact
    // with methods like `atom.workspace.getActiveTextEditor()` you're only going
    // to get the model object. We display text editors on screen by teaching the
    // workspace what view constructor it should use to represent them:
    //
    // ```coffee
    // atom.views.addViewProvider TextEditor, (textEditor) ->
    //   textEditorElement = new TextEditorElement
    //   textEditorElement.initialize(textEditor)
    //   textEditorElement
    // ```
    //
    // * `modelConstructor` (optional) Constructor {Function} for your model. If
    //   a constructor is given, the `createView` function will only be used
    //   for model objects inheriting from that constructor. Otherwise, it will
    //   will be called for any object.
    // * `createView` Factory {Function} that is passed an instance of your model
    //   and must return a subclass of `HTMLElement` or `undefined`. If it returns
    //   `undefined`, then the registry will continue to search for other view
    //   providers.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added provider.
    // Essential: Add a provider that will be used to construct views in the
    // workspace's view layer based on model objects in its model layer.
    //
    // ## Examples
    //
    // Text editors are divided into a model and a view layer, so when you interact
    // with methods like `atom.workspace.getActiveTextEditor()` you're only going
    // to get the model object. We display text editors on screen by teaching the
    // workspace what view constructor it should use to represent them:
    //
    // ```coffee
    // atom.views.addViewProvider TextEditor, (textEditor) ->
    //   textEditorElement = new TextEditorElement
    //   textEditorElement.initialize(textEditor)
    //   textEditorElement
    // ```
    //
    // * `modelConstructor` (optional) Constructor {Function} for your model. If
    //   a constructor is given, the `createView` function will only be used
    //   for model objects inheriting from that constructor. Otherwise, it will
    //   will be called for any object.
    // * `createView` Factory {Function} that is passed an instance of your model
    //   and must return a subclass of `HTMLElement` or `undefined`. If it returns
    //   `undefined`, then the registry will continue to search for other view
    //   providers.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added provider.
    /**
     * @param {?} modelConstructor
     * @param {?} createView
     * @return {?}
     */
    ViewRegistry.prototype.addViewProvider = 
    // Essential: Add a provider that will be used to construct views in the
    // workspace's view layer based on model objects in its model layer.
    //
    // ## Examples
    //
    // Text editors are divided into a model and a view layer, so when you interact
    // with methods like `atom.workspace.getActiveTextEditor()` you're only going
    // to get the model object. We display text editors on screen by teaching the
    // workspace what view constructor it should use to represent them:
    //
    // ```coffee
    // atom.views.addViewProvider TextEditor, (textEditor) ->
    //   textEditorElement = new TextEditorElement
    //   textEditorElement.initialize(textEditor)
    //   textEditorElement
    // ```
    //
    // * `modelConstructor` (optional) Constructor {Function} for your model. If
    //   a constructor is given, the `createView` function will only be used
    //   for model objects inheriting from that constructor. Otherwise, it will
    //   will be called for any object.
    // * `createView` Factory {Function} that is passed an instance of your model
    //   and must return a subclass of `HTMLElement` or `undefined`. If it returns
    //   `undefined`, then the registry will continue to search for other view
    //   providers.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to remove the
    // added provider.
    /**
     * @param {?} modelConstructor
     * @param {?} createView
     * @return {?}
     */
    function (modelConstructor, createView) {
        var _this = this;
        /** @type {?} */
        var provider;
        if (arguments.length === 1) {
            switch (typeof modelConstructor) {
                case 'function':
                    provider = { createView: modelConstructor, modelConstructor: null };
                    break;
                case 'object':
                    provider = modelConstructor;
                    break;
                default:
                    throw new TypeError('Arguments to addViewProvider must be functions');
            }
        }
        else {
            provider = { modelConstructor: modelConstructor, createView: createView };
        }
        this.providers.push(provider);
        return new Disposable(function () {
            _this.providers = _this.providers.filter(function (p) { return p !== provider; });
        });
    };
    /**
     * @return {?}
     */
    ViewRegistry.prototype.getViewProviderCount = /**
     * @return {?}
     */
    function () {
        return this.providers.length;
    };
    // Essential: Get the view associated with an object in the workspace.
    //
    // If you're just *using* the workspace, you shouldn't need to access the view
    // layer, but view layer access may be necessary if you want to perform DOM
    // manipulation that isn't supported via the model API.
    //
    // ## View Resolution Algorithm
    //
    // The view associated with the object is resolved using the following
    // sequence
    //
    //  1. Is the object an instance of `HTMLElement`? If true, return the object.
    //  2. Does the object have a method named `getElement` that returns an
    //     instance of `HTMLElement`? If true, return that value.
    //  3. Does the object have a property named `element` with a value which is
    //     an instance of `HTMLElement`? If true, return the property value.
    //  4. Is the object a jQuery object, indicated by the presence of a `jquery`
    //     property? If true, return the root DOM element (i.e. `object[0]`).
    //  5. Has a view provider been registered for the object? If true, use the
    //     provider to create a view associated with the object, and return the
    //     view.
    //
    // If no associated view is returned by the sequence an error is thrown.
    //
    // Returns a DOM element.
    // Essential: Get the view associated with an object in the workspace.
    //
    // If you're just *using* the workspace, you shouldn't need to access the view
    // layer, but view layer access may be necessary if you want to perform DOM
    // manipulation that isn't supported via the model API.
    //
    // ## View Resolution Algorithm
    //
    // The view associated with the object is resolved using the following
    // sequence
    //
    //  1. Is the object an instance of `HTMLElement`? If true, return the object.
    //  2. Does the object have a method named `getElement` that returns an
    //     instance of `HTMLElement`? If true, return that value.
    //  3. Does the object have a property named `element` with a value which is
    //     an instance of `HTMLElement`? If true, return the property value.
    //  4. Is the object a jQuery object, indicated by the presence of a `jquery`
    //     property? If true, return the root DOM element (i.e. `object[0]`).
    //  5. Has a view provider been registered for the object? If true, use the
    //     provider to create a view associated with the object, and return the
    //     view.
    //
    // If no associated view is returned by the sequence an error is thrown.
    //
    // Returns a DOM element.
    /**
     * @param {?} object
     * @return {?}
     */
    ViewRegistry.prototype.getView = 
    // Essential: Get the view associated with an object in the workspace.
    //
    // If you're just *using* the workspace, you shouldn't need to access the view
    // layer, but view layer access may be necessary if you want to perform DOM
    // manipulation that isn't supported via the model API.
    //
    // ## View Resolution Algorithm
    //
    // The view associated with the object is resolved using the following
    // sequence
    //
    //  1. Is the object an instance of `HTMLElement`? If true, return the object.
    //  2. Does the object have a method named `getElement` that returns an
    //     instance of `HTMLElement`? If true, return that value.
    //  3. Does the object have a property named `element` with a value which is
    //     an instance of `HTMLElement`? If true, return the property value.
    //  4. Is the object a jQuery object, indicated by the presence of a `jquery`
    //     property? If true, return the root DOM element (i.e. `object[0]`).
    //  5. Has a view provider been registered for the object? If true, use the
    //     provider to create a view associated with the object, and return the
    //     view.
    //
    // If no associated view is returned by the sequence an error is thrown.
    //
    // Returns a DOM element.
    /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        if (object == null) {
            return;
        }
        /** @type {?} */
        var view = this.views.get(object);
        if (!view) {
            view = this.createView(object);
            this.views.set(object, view);
        }
        return view;
    };
    /**
     * @param {?} object
     * @return {?}
     */
    ViewRegistry.prototype.createView = /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        var e_1, _a;
        if (object instanceof ComponentRef) {
            return object;
        }
        /** @type {?} */
        var element;
        if (object && (typeof object.getElement === 'function')) {
            element = object.getElement();
            if (element instanceof ComponentRef) {
                return element;
            }
        }
        if (object && object.element instanceof ComponentRef) {
            return object.element;
        }
        try {
            // if (object && object.jquery) {
            //   return object[0];
            // }
            for (var _b = __values(this.providers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var provider = _c.value;
                if (provider.modelConstructor === null) {
                    element = provider.createView(object, this.gspEnvironment);
                    if (element) {
                        return element;
                    }
                    continue;
                }
                if (object instanceof provider.modelConstructor) {
                    element = provider.createView && provider.createView(object, this.gspEnvironment);
                    if (element) {
                        return element;
                    }
                    /** @type {?} */
                    var ViewConstructor = provider.viewConstructor;
                    if (ViewConstructor) {
                        element = new ViewConstructor();
                        if (element.initialize) {
                            element.initialize(object);
                        }
                        else if (element.setModel) {
                            element.setModel(object);
                        }
                        return element;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (object && object.getViewClass) {
            /** @type {?} */
            var ViewConstructor = object.getViewClass();
            if (ViewConstructor) {
                /** @type {?} */
                var view = new ViewConstructor(object);
                return view;
            }
        }
        throw new Error("Can't create a view for " + object.constructor.name + " instance. Please register a view provider.");
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ViewRegistry.prototype.updateDocument = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        // this.documentWriters.push(fn)
        // if (!this.documentReadInProgress) { this.requestDocumentUpdate() }
        // return new Disposable(() => {
        //   this.documentWriters = this.documentWriters.filter(writer => writer !== fn)
        // })
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ViewRegistry.prototype.readDocument = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        // this.documentReaders.push(fn)
        // this.requestDocumentUpdate()
        // return new Disposable(() => {
        //   this.documentReaders = this.documentReaders.filter(reader => reader !== fn)
        // })
    };
    /**
     * @return {?}
     */
    ViewRegistry.prototype.getNextUpdatePromise = /**
     * @return {?}
     */
    function () {
        // if (this.nextUpdatePromise == null) {
        //   this.nextUpdatePromise = new Promise(resolve => {
        //     this.resolveNextUpdatePromise = resolve
        //   })
        // }
        // return this.nextUpdatePromise
    };
    /**
     * @return {?}
     */
    ViewRegistry.prototype.clearDocumentRequests = /**
     * @return {?}
     */
    function () {
        // this.documentReaders = []
        // this.documentWriters = []
        // this.nextUpdatePromise = null
        // this.resolveNextUpdatePromise = null
        // if (this.animationFrameRequest != null) {
        //   cancelAnimationFrame(this.animationFrameRequest)
        //   this.animationFrameRequest = null
        // }
    };
    /**
     * @return {?}
     */
    ViewRegistry.prototype.requestDocumentUpdate = /**
     * @return {?}
     */
    function () {
        // if (this.animationFrameRequest == null) {
        //   this.animationFrameRequest = requestAnimationFrame(this.performDocumentUpdate)
        // }
    };
    /**
     * @return {?}
     */
    ViewRegistry.prototype.performDocumentUpdate = /**
     * @return {?}
     */
    function () {
        // const { resolveNextUpdatePromise } = this
        // this.animationFrameRequest = null
        // this.nextUpdatePromise = null
        // this.resolveNextUpdatePromise = null
        // var writer = this.documentWriters.shift()
        // while (writer) {
        //   writer()
        //   writer = this.documentWriters.shift()
        // }
        // var reader = this.documentReaders.shift()
        // this.documentReadInProgress = true
        // while (reader) {
        //   reader()
        //   reader = this.documentReaders.shift()
        // }
        // this.documentReadInProgress = false
        // // process updates requested as a result of reads
        // writer = this.documentWriters.shift()
        // while (writer) {
        //   writer()
        //   writer = this.documentWriters.shift()
        // }
        // if (resolveNextUpdatePromise) { resolveNextUpdatePromise() }
    };
    return ViewRegistry;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PanelContainer = /** @class */ (function () {
    function PanelContainer(viewRegistry, location, dock) {
        if (dock === void 0) { dock = null; }
        this.viewRegistry = viewRegistry;
        this.location = location;
        this.dock = dock;
        this.panels = [];
        this.emitter = new Emitter();
        this.subscriptions = new CompositeDisposable();
    }
    /**
     * @return {?}
     */
    PanelContainer.prototype.destroy = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.getPanels()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var panel = _c.value;
                panel.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @return {?}
     */
    PanelContainer.prototype.getElement = /**
     * @return {?}
     */
    function () {
    };
    /*
    Section: Event Subscription
    */
    /*
      Section: Event Subscription
      */
    /**
     * @param {?} callback
     * @return {?}
     */
    PanelContainer.prototype.onDidAddPanel = /*
      Section: Event Subscription
      */
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-add-panel', callback);
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    PanelContainer.prototype.onDidRemovePanel = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-remove-panel', callback);
    };
    /**
     * @param {?} callback
     * @return {?}
     */
    PanelContainer.prototype.onDidDestroy = /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.once('did-destroy', callback);
    };
    /**
     * @return {?}
     */
    PanelContainer.prototype.getLocation = /**
     * @return {?}
     */
    function () {
        return this.location;
    };
    /**
     * @return {?}
     */
    PanelContainer.prototype.isModal = /**
     * @return {?}
     */
    function () { return this.location === 'modal'; };
    /**
     * @return {?}
     */
    PanelContainer.prototype.getPanels = /**
     * @return {?}
     */
    function () { return this.panels.slice(); };
    /**
     * @param {?} panel
     * @return {?}
     */
    PanelContainer.prototype.addPanel = /**
     * @param {?} panel
     * @return {?}
     */
    function (panel) {
        this.subscriptions.add(panel.onDidDestroy(this.panelDestroyed.bind(this)));
        /** @type {?} */
        var index = this.getPanelIndex(panel);
        if (index === this.panels.length) {
            this.panels.push(panel);
        }
        else {
            this.panels.splice(index, 0, panel);
        }
        this.emitter.emit('did-add-panel', { panel: panel, index: index });
        return panel;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PanelContainer.prototype.panelForItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var e_2, _a;
        try {
            for (var _b = __values(this.panels), _c = _b.next(); !_c.done; _c = _b.next()) {
                var panel = _c.value;
                if (panel.getItem() === item) {
                    return panel;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return null;
    };
    /**
     * @param {?} panel
     * @return {?}
     */
    PanelContainer.prototype.panelDestroyed = /**
     * @param {?} panel
     * @return {?}
     */
    function (panel) {
        /** @type {?} */
        var index = this.panels.indexOf(panel);
        if (index > -1) {
            this.panels.splice(index, 1);
            this.emitter.emit('did-remove-panel', { panel: panel, index: index });
        }
    };
    /**
     * @param {?} panel
     * @return {?}
     */
    PanelContainer.prototype.getPanelIndex = /**
     * @param {?} panel
     * @return {?}
     */
    function (panel) {
        var _this = this;
        /** @type {?} */
        var priority = panel.getPriority();
        if (['bottom', 'right'].find(function (item) { return item === _this.location; })) {
            for (var i = this.panels.length - 1; i >= 0; i--) {
                /** @type {?} */
                var p = this.panels[i];
                if (priority < p.getPriority()) {
                    return i + 1;
                }
            }
            return 0;
        }
        else {
            for (var i = 0; i < this.panels.length; i++) {
                /** @type {?} */
                var p = this.panels[i];
                if (priority < p.getPriority()) {
                    return i;
                }
            }
            return this.panels.length;
        }
    };
    return PanelContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Panel = /** @class */ (function () {
    function Panel(options, viewRegistry) {
        this.destroyed = false;
        this.item = options.item;
        this.autoFocus = options.autoFocus == null ? false : options.autoFocus;
        this.visible = options.visible == null ? true : options.visible;
        this.priority = options.priority == null ? 100 : options.priority;
        this.className = options.className;
        this.viewRegistry = viewRegistry;
        this.emitter = new Emitter();
    }
    // Public: Destroy and remove this panel from the UI.
    // Public: Destroy and remove this panel from the UI.
    /**
     * @return {?}
     */
    Panel.prototype.destroy = 
    // Public: Destroy and remove this panel from the UI.
    /**
     * @return {?}
     */
    function () {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        this.hide();
        this.emitter.emit('did-destroy', this);
        return this.emitter.dispose();
    };
    /**
     * @return {?}
     */
    Panel.prototype.getElement = /**
     * @return {?}
     */
    function () {
        return this.item.getElement(); // 直接返回item的视图，不再包装一层Panel
    };
    /*
    Section: Event Subscription
    */
    // Public: Invoke the given callback when the pane hidden or shown.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `visible` {Boolean} true when the panel has been shown
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /*
      Section: Event Subscription
      */
    // Public: Invoke the given callback when the pane hidden or shown.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `visible` {Boolean} true when the panel has been shown
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Panel.prototype.onDidChangeVisible = /*
      Section: Event Subscription
      */
    // Public: Invoke the given callback when the pane hidden or shown.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `visible` {Boolean} true when the panel has been shown
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.on('did-change-visible', callback);
    };
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `panel` {Panel} this panel
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `panel` {Panel} this panel
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    Panel.prototype.onDidDestroy = 
    // Public: Invoke the given callback when the pane is destroyed.
    //
    // * `callback` {Function} to be called when the pane is destroyed.
    //   * `panel` {Panel} this panel
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.emitter.once('did-destroy', callback);
    };
    /*
    Section: Panel Details
    */
    // Public: Returns the panel's item.
    /*
      Section: Panel Details
      */
    // Public: Returns the panel's item.
    /**
     * @return {?}
     */
    Panel.prototype.getItem = /*
      Section: Panel Details
      */
    // Public: Returns the panel's item.
    /**
     * @return {?}
     */
    function () {
        return this.item;
    };
    // Public: Returns a {Number} indicating this panel's priority.
    // Public: Returns a {Number} indicating this panel's priority.
    /**
     * @return {?}
     */
    Panel.prototype.getPriority = 
    // Public: Returns a {Number} indicating this panel's priority.
    /**
     * @return {?}
     */
    function () {
        return this.priority;
    };
    /**
     * @return {?}
     */
    Panel.prototype.getClassName = /**
     * @return {?}
     */
    function () {
        return this.className;
    };
    // Public: Returns a {Boolean} true when the panel is visible.
    // Public: Returns a {Boolean} true when the panel is visible.
    /**
     * @return {?}
     */
    Panel.prototype.isVisible = 
    // Public: Returns a {Boolean} true when the panel is visible.
    /**
     * @return {?}
     */
    function () {
        return this.visible;
    };
    // Public: Hide this panel
    // Public: Hide this panel
    /**
     * @return {?}
     */
    Panel.prototype.hide = 
    // Public: Hide this panel
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var wasVisible = this.visible;
        this.visible = false;
        if (wasVisible) {
            this.emitter.emit('did-change-visible', this.visible);
        }
    };
    // Public: Show this panel
    // Public: Show this panel
    /**
     * @return {?}
     */
    Panel.prototype.show = 
    // Public: Show this panel
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var wasVisible = this.visible;
        this.visible = true;
        if (!wasVisible) {
            this.emitter.emit('did-change-visible', this.visible);
        }
    };
    return Panel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Essential: Represents the workspace at the center of the entire window.
var  
// Essential: Represents the workspace at the center of the entire window.
WorkspaceCenter = /** @class */ (function () {
    function WorkspaceCenter(params) {
        var _this = this;
        params.location = 'center';
        this.paneContainer = new PaneContainer(params);
        this.didActivate = params.didActivate;
        this.paneContainer.onDidActivatePane(function () { return _this.didActivate(_this); });
        this.paneContainer.onDidChangeActivePane(function (pane) {
            params.didChangeActivePane(_this, pane);
        });
        this.paneContainer.onDidChangeActivePaneItem(function (item) {
            params.didChangeActivePaneItem(_this, item);
        });
        this.paneContainer.onDidDestroyPaneItem(function (item) { return params.didDestroyPaneItem(item); });
    }
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.paneContainer.destroy();
    };
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.serialize = /**
     * @return {?}
     */
    function () {
        return this.paneContainer.serialize();
    };
    /**
     * @param {?} state
     * @param {?} deserializerManager
     * @return {?}
     */
    WorkspaceCenter.prototype.deserialize = /**
     * @param {?} state
     * @param {?} deserializerManager
     * @return {?}
     */
    function (state, deserializerManager) {
        this.paneContainer.deserialize(state, deserializerManager);
    };
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.activate = /**
     * @return {?}
     */
    function () {
        this.getActivePane().activate();
    };
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.getLocation = /**
     * @return {?}
     */
    function () {
        return 'center';
    };
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.setDraggingItem = /**
     * @return {?}
     */
    function () {
        // No-op
    };
    // Essential: Invoke the given callback with all current and future panes items
    // in the workspace center.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback with all current and future panes items
    // in the workspace center.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.observePaneItems = 
    // Essential: Invoke the given callback with all current and future panes items
    // in the workspace center.
    //
    // * `callback` {Function} to be called with current and future pane items.
    //   * `item` An item that is present in {::getPaneItems} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) { return this.paneContainer.observePaneItems(callback); };
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onDidChangeActivePaneItem = 
    // Essential: Invoke the given callback when the active pane item changes.
    //
    // Because observers are invoked synchronously, it's important not to perform
    // any expensive operations via this method. Consider
    // {::onDidStopChangingActivePaneItem} to delay operations until after changes
    // stop occurring.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidChangeActivePaneItem(callback);
    };
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onDidStopChangingActivePaneItem = 
    // Essential: Invoke the given callback when the active pane item stops
    // changing.
    //
    // Observers are called asynchronously 100ms after the last active pane item
    // change. Handling changes here rather than in the synchronous
    // {::onDidChangeActivePaneItem} prevents unneeded work if the user is quickly
    // changing or closing tabs and ensures critical UI feedback, like changing the
    // highlighted tab, gets priority over work that can be done asynchronously.
    //
    // * `callback` {Function} to be called when the active pane item stopts
    //   changing.
    //   * `item` The active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidStopChangingActivePaneItem(callback);
    };
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the workspace center.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the workspace center.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.observeActivePaneItem = 
    // Essential: Invoke the given callback with the current active pane item and
    // with all future active pane items in the workspace center.
    //
    // * `callback` {Function} to be called when the active pane item changes.
    //   * `item` The current active pane item.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.observeActivePaneItem(callback);
    };
    // Extended: Invoke the given callback when a pane is added to the workspace
    // center.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane is added to the workspace
    // center.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onDidAddPane = 
    // Extended: Invoke the given callback when a pane is added to the workspace
    // center.
    //
    // * `callback` {Function} to be called panes are added.
    //   * `event` {Object} with the following keys:
    //     * `pane` The added pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidAddPane(callback);
    };
    // Extended: Invoke the given callback before a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback before a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onWillDestroyPane = 
    // Extended: Invoke the given callback before a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called before panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The pane to be destroyed.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onWillDestroyPane(callback);
    };
    // Extended: Invoke the given callback when a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onDidDestroyPane = 
    // Extended: Invoke the given callback when a pane is destroyed in the
    // workspace center.
    //
    // * `callback` {Function} to be called panes are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `pane` The destroyed pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidDestroyPane(callback);
    };
    // Extended: Invoke the given callback with all current and future panes in the
    // workspace center.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback with all current and future panes in the
    // workspace center.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.observePanes = 
    // Extended: Invoke the given callback with all current and future panes in the
    // workspace center.
    //
    // * `callback` {Function} to be called with current and future panes.
    //   * `pane` A {Pane} that is present in {::getPanes} at the time of
    //      subscription or that is added at some later time.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.observePanes(callback);
    };
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onDidChangeActivePane = 
    // Extended: Invoke the given callback when the active pane changes.
    //
    // * `callback` {Function} to be called when the active pane changes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidChangeActivePane(callback);
    };
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.observeActivePane = 
    // Extended: Invoke the given callback with the current active pane and when
    // the active pane changes.
    //
    // * `callback` {Function} to be called with the current and future active#
    //   panes.
    //   * `pane` A {Pane} that is the current return value of {::getActivePane}.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.observeActivePane(callback);
    };
    // Extended: Invoke the given callback when a pane item is added to the
    // workspace center.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane item is added to the
    // workspace center.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onDidAddPaneItem = 
    // Extended: Invoke the given callback when a pane item is added to the
    // workspace center.
    //
    // * `callback` {Function} to be called when pane items are added.
    //   * `event` {Object} with the following keys:
    //     * `item` The added pane item.
    //     * `pane` {Pane} containing the added item.
    //     * `index` {Number} indicating the index of the added item in its pane.
    //
    // Returns a {Disposable} on which `.dispose()` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidAddPaneItem(callback);
    };
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onWillDestroyPaneItem = 
    // Extended: Invoke the given callback when a pane item is about to be
    // destroyed, before the user is prompted to save it.
    //
    // * `callback` {Function} to be called before pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The item to be destroyed.
    //     * `pane` {Pane} containing the item to be destroyed.
    //     * `index` {Number} indicating the index of the item to be destroyed in
    //       its pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onWillDestroyPaneItem(callback);
    };
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    WorkspaceCenter.prototype.onDidDestroyPaneItem = 
    // Extended: Invoke the given callback when a pane item is destroyed.
    //
    // * `callback` {Function} to be called when pane items are destroyed.
    //   * `event` {Object} with the following keys:
    //     * `item` The destroyed item.
    //     * `pane` {Pane} containing the destroyed item.
    //     * `index` {Number} indicating the index of the destroyed item in its
    //       pane.
    //
    // Returns a {Disposable} on which `.dispose` can be called to unsubscribe.
    /**
     * @param {?} callback
     * @return {?}
     */
    function (callback) {
        return this.paneContainer.onDidDestroyPaneItem(callback);
    };
    /*
    Section: Pane Items
    */
    // Essential: Get all pane items in the workspace center.
    //
    // Returns an {Array} of items.
    /*
      Section: Pane Items
      */
    // Essential: Get all pane items in the workspace center.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.getPaneItems = /*
      Section: Pane Items
      */
    // Essential: Get all pane items in the workspace center.
    //
    // Returns an {Array} of items.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getPaneItems();
    };
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.getActivePaneItem = 
    // Essential: Get the active {Pane}'s active item.
    //
    // Returns an pane item {Object}.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getActivePaneItem();
    };
    // Save all pane items.
    // Save all pane items.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.saveAll = 
    // Save all pane items.
    /**
     * @return {?}
     */
    function () {
        this.paneContainer.saveAll();
    };
    /**
     * @param {?} options
     * @return {?}
     */
    WorkspaceCenter.prototype.confirmClose = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.paneContainer.confirmClose(options);
    };
    /*
    Section: Panes
    */
    // Extended: Get all panes in the workspace center.
    //
    // Returns an {Array} of {Pane}s.
    /*
      Section: Panes
      */
    // Extended: Get all panes in the workspace center.
    //
    // Returns an {Array} of {Pane}s.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.getPanes = /*
      Section: Panes
      */
    // Extended: Get all panes in the workspace center.
    //
    // Returns an {Array} of {Pane}s.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getPanes();
    };
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.getActivePane = 
    // Extended: Get the active {Pane}.
    //
    // Returns a {Pane}.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.getActivePane();
    };
    // Extended: Make the next pane active.
    // Extended: Make the next pane active.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.activateNextPane = 
    // Extended: Make the next pane active.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.activateNextPane();
    };
    // Extended: Make the previous pane active.
    // Extended: Make the previous pane active.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.activatePreviousPane = 
    // Extended: Make the previous pane active.
    /**
     * @return {?}
     */
    function () {
        return this.paneContainer.activatePreviousPane();
    };
    /**
     * @param {?} uri
     * @return {?}
     */
    WorkspaceCenter.prototype.paneForURI = /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        return this.paneContainer.paneForURI(uri);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    WorkspaceCenter.prototype.paneForItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.paneContainer.paneForItem(item);
    };
    // Destroy (close) the active pane.
    // Destroy (close) the active pane.
    /**
     * @return {?}
     */
    WorkspaceCenter.prototype.destroyActivePane = 
    // Destroy (close) the active pane.
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var activePane = this.getActivePane();
        if (activePane != null) {
            activePane.destroy();
        }
    };
    return WorkspaceCenter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ALL_LOCATIONS = ['center', 'left', 'right', 'bottom'];
var Workspace = /** @class */ (function () {
    function Workspace(params) {
        this.initOptions(params);
        this.initWorkspace();
        this.openers = [];
        this.frmOpeners = [];
        this.useFrmOpener = false;
        this.viewRegistry = params.viewRegistry;
        // this.subscribeToEvents();
    }
    /**
     * @private
     * @param {?} params
     * @return {?}
     */
    Workspace.prototype.initOptions = /**
     * @private
     * @param {?} params
     * @return {?}
     */
    function (params) {
        this.config = params.config || {};
    };
    /**
     * @private
     * @return {?}
     */
    Workspace.prototype.initWorkspace = /**
     * @private
     * @return {?}
     */
    function () {
        // 创建工作区停靠面板容器。
        this.paneContainers = {
            // 创建主区域。
            center: this.createCenter(),
            // 创建左侧面板。
            left: this.createDock('left'),
            // 创建右侧面板。
            right: this.createDock('right'),
            // 创建底部面板。
            bottom: this.createDock('bottom')
        };
        this.activePaneContainer = this.paneContainers.center;
        // 创建面板容器
        this.panelContainers = {
            top: new PanelContainer(this.viewRegistry, 'top'),
            left: new PanelContainer(this.viewRegistry, 'left', this.paneContainers.left),
            right: new PanelContainer(this.viewRegistry, 'right', this.paneContainers.right),
            bottom: new PanelContainer(this.viewRegistry, 'bottom', this.paneContainers.bottom),
            header: new PanelContainer(this.viewRegistry, 'header'),
            footer: new PanelContainer(this.viewRegistry, 'footer'),
            modal: new PanelContainer(this.viewRegistry, 'modal')
        };
    };
    Object.defineProperty(Workspace.prototype, "paneContainer", {
        get: /**
         * @return {?}
         */
        function () {
            return this.paneContainers.center.paneContainer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 返回工作区元素
     */
    /**
     * 返回工作区元素
     * @return {?}
     */
    Workspace.prototype.getElement = /**
     * 返回工作区元素
     * @return {?}
     */
    function () {
    };
    /**
     * 创建主面板
     */
    /**
     * 创建主面板
     * @return {?}
     */
    Workspace.prototype.createCenter = /**
     * 创建主面板
     * @return {?}
     */
    function () {
        return new WorkspaceCenter({ viewRegistry: this.viewRegistry });
    };
    /**
     * 创建停靠面板
     * @param location 停靠面板位置
     */
    /**
     * 创建停靠面板
     * @param {?} location 停靠面板位置
     * @return {?}
     */
    Workspace.prototype.createDock = /**
     * 创建停靠面板
     * @param {?} location 停靠面板位置
     * @return {?}
     */
    function (location) {
        return new Dock({
            location: location,
            viewRegistry: this.viewRegistry
        });
    };
    /**
     * 重置工作区
     * @param packageManager 包管理器
     */
    /**
     * 重置工作区
     * @param {?} packageManager 包管理器
     * @return {?}
     */
    Workspace.prototype.reset = /**
     * 重置工作区
     * @param {?} packageManager 包管理器
     * @return {?}
     */
    function (packageManager) {
        this.packageManager = packageManager;
        this.destroyed();
        this.initWorkspace();
    };
    // Called by the Serializable mixin during serialization.
    /**
     * 序列化工作区配置
     */
    // Called by the Serializable mixin during serialization.
    /**
     * 序列化工作区配置
     * @return {?}
     */
    Workspace.prototype.serialize = 
    // Called by the Serializable mixin during serialization.
    /**
     * 序列化工作区配置
     * @return {?}
     */
    function () {
    };
    /**
     * 反序列化工作区配置
     * @param state state
     * @param deserializerManager dm
     */
    /**
     * 反序列化工作区配置
     * @param {?} state state
     * @param {?} deserializerManager dm
     * @return {?}
     */
    Workspace.prototype.deserialize = /**
     * 反序列化工作区配置
     * @param {?} state state
     * @param {?} deserializerManager dm
     * @return {?}
     */
    function (state, deserializerManager) {
    };
    // Updates the application's title and proxy icon based on whichever file is
    // open.
    // Updates the application's title and proxy icon based on whichever file is
    // open.
    /**
     * @return {?}
     */
    Workspace.prototype.updateWindowTitle = 
    // Updates the application's title and proxy icon based on whichever file is
    // open.
    /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} itemOrURI
     * @param {?=} options
     * @return {?}
     */
    Workspace.prototype.open = /**
     * @param {?} itemOrURI
     * @param {?=} options
     * @return {?}
     */
    function (itemOrURI, options) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var uri;
        /** @type {?} */
        var item;
        if (typeof itemOrURI === 'string') {
            uri = itemOrURI; // this.project.resolvePath(itemOrURI);
        }
        else if (itemOrURI) {
            item = itemOrURI;
            if (typeof item.getURI === 'function') {
                uri = item.getURI();
            }
        }
        if (!this.config.get('core.allowPendingPaneItems')) {
            options.pending = false;
        }
        // Avoid adding URLs as recent documents to work-around this Spotlight crash:
        // https://github.com/atom/atom/issues/10071
        // if (uri && (!url.parse(uri).protocol || process.platform === 'win32')) {
        //   this.applicationDelegate.addRecentDocument(uri);
        // }
        /** @type {?} */
        var pane;
        /** @type {?} */
        var itemExistsInWorkspace;
        // Try to find an existing item in the workspace.
        if (item || uri) {
            if (options.pane) {
                pane = options.pane;
            }
            else if (options.searchAllPanes) {
                pane = item ? this.paneForItem(item) : this.paneForURI(uri);
            }
            else {
                // If an item with the given URI is already in the workspace, assume
                // that item's pane container is the preferred location for that URI.
                /** @type {?} */
                var container = void 0;
                if (uri) {
                    container = this.paneContainerForURI(uri);
                }
                if (!container) {
                    container = this.getActivePaneContainer();
                }
                // The `split` option affects where we search for the item.
                pane = container.getActivePane();
                switch (options.split) {
                    case 'left':
                        pane = pane.findLeftmostSibling();
                        break;
                    case 'right':
                        pane = pane.findRightmostSibling();
                        break;
                    case 'up':
                        pane = pane.findTopmostSibling();
                        break;
                    case 'down':
                        pane = pane.findBottommostSibling();
                        break;
                }
            }
            if (pane) {
                if (item) {
                    itemExistsInWorkspace = pane.getItems().includes(item);
                }
                else {
                    item = pane.itemForURI(uri);
                    itemExistsInWorkspace = item != null;
                }
            }
        }
        if (!itemExistsInWorkspace) {
            item = item || this.createItemForURI(uri, options);
            if (!item) {
                return;
            }
            if (options.pane) {
                pane = options.pane;
            }
            else {
                /** @type {?} */
                var location_1 = options.location;
                // if (!location && !options.split && uri && this.enablePersistence) {
                //   // location = await;
                //   this.itemLocationStore.load(uri);
                // }
                if (!location_1 && typeof item.getDefaultLocation === 'function') {
                    location_1 = item.getDefaultLocation();
                }
                /** @type {?} */
                var allowedLocations = typeof item.getAllowedLocations === 'function' ? item.getAllowedLocations() : ALL_LOCATIONS;
                location_1 = allowedLocations.includes(location_1) ? location_1 : allowedLocations[0];
                /** @type {?} */
                var container = this.paneContainers[location_1] || this.getCenter();
                pane = container.getActivePane();
                switch (options.split) {
                    case 'left':
                        pane = pane.findLeftmostSibling();
                        break;
                    case 'right':
                        pane = pane.findOrCreateRightmostSibling();
                        break;
                    case 'up':
                        pane = pane.findTopmostSibling();
                        break;
                    case 'down':
                        pane = pane.findOrCreateBottommostSibling();
                        break;
                }
            }
        }
        if (!options.pending && (pane.getPendingItem() === item)) {
            pane.clearPendingItem();
        }
        this.itemOpened(item);
        if (options.activateItem === false) {
            pane.addItem(item, { pending: options.pending });
        }
        else {
            pane.activateItem(item, { pending: options.pending });
        }
        if (options.activatePane !== false) {
            pane.activate();
        }
        /** @type {?} */
        var initialColumn = 0;
        /** @type {?} */
        var initialLine = 0;
        if (!Number.isNaN(options.initialLine)) {
            initialLine = options.initialLine;
        }
        if (!Number.isNaN(options.initialColumn)) {
            initialColumn = options.initialColumn;
        }
        if (initialLine >= 0 || initialColumn >= 0) {
            if (typeof item.setCursorBufferPosition === 'function') {
                item.setCursorBufferPosition([initialLine, initialColumn]);
            }
        }
        /** @type {?} */
        var index = pane.getActiveItemIndex();
        return item;
    };
    /**
     * @param {?} itemOrURI
     * @return {?}
     */
    Workspace.prototype.hide = /**
     * @param {?} itemOrURI
     * @return {?}
     */
    function (itemOrURI) {
        var e_1, _a, e_2, _b;
        /** @type {?} */
        var foundItems = false;
        try {
            // If any visible item has the given URI, hide it
            for (var _c = __values(this.getPaneContainers()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var container = _d.value;
                /** @type {?} */
                var isCenter = container === this.getCenter();
                if (isCenter || ((/** @type {?} */ (container))).isVisible()) {
                    try {
                        for (var _e = __values(container.getPanes()), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var pane = _f.value;
                            /** @type {?} */
                            var activeItem = pane.getActiveItem();
                            /** @type {?} */
                            var foundItem = (activeItem != null && (activeItem === itemOrURI ||
                                typeof activeItem.getURI === 'function' && activeItem.getURI() === itemOrURI));
                            if (foundItem) {
                                foundItems = true;
                                // We can't really hide the center so we just destroy the item.
                                if (isCenter) {
                                    pane.destroyItem(activeItem);
                                }
                                else {
                                    ((/** @type {?} */ (container))).hide();
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return foundItems;
    };
    /**
     * @param {?} itemOrURI
     * @return {?}
     */
    Workspace.prototype.toggle = /**
     * @param {?} itemOrURI
     * @return {?}
     */
    function (itemOrURI) {
        if (this.hide(itemOrURI)) {
            return Promise.resolve();
        }
        else {
            return this.open(itemOrURI, { searchAllPanes: true });
        }
    };
    /**
     * @param {?=} fileUri
     * @param {?=} options
     * @return {?}
     */
    Workspace.prototype.openSync = /**
     * @param {?=} fileUri
     * @param {?=} options
     * @return {?}
     */
    function (fileUri, options) {
        if (fileUri === void 0) { fileUri = ''; }
        if (options === void 0) { options = { initialColumn: '', initialLine: '', activateItem: '', activatePane: '' }; }
        var e_3, _a;
        var initialLine = options.initialLine, initialColumn = options.initialColumn;
        /** @type {?} */
        var activatePane = options.activatePane != null ? options.activatePane : true;
        /** @type {?} */
        var activateItem = options.activateItem != null ? options.activateItem : true;
        /** @type {?} */
        var uri = fileUri;
        // this.project.resolvePath(uri_);
        /** @type {?} */
        var item = this.getActivePane().itemForURI(uri);
        if (uri && (item == null)) {
            try {
                for (var _b = __values(this.getOpeners()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var opener_1 = _c.value;
                    item = opener_1(uri, options);
                    if (item) {
                        break;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        if (item == null) {
            item = this.project.openSync(uri, { initialLine: initialLine, initialColumn: initialColumn });
        }
        if (activateItem) {
            this.getActivePane().activateItem(item);
        }
        this.itemOpened(item);
        if (activatePane) {
            this.getActivePane().activate();
        }
        return item;
    };
    /**
     * @param {?} uri
     * @param {?} pane
     * @return {?}
     */
    Workspace.prototype.openURIInPane = /**
     * @param {?} uri
     * @param {?} pane
     * @return {?}
     */
    function (uri, pane) {
        return this.open(uri, { pane: pane });
    };
    /**
     * @param {?} uri
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.createItemForURI = /**
     * @param {?} uri
     * @param {?} options
     * @return {?}
     */
    function (uri, options) {
        var e_4, _a;
        if (uri != null) {
            try {
                for (var _b = __values(this.getOpeners()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var opener_2 = _c.value;
                    /** @type {?} */
                    var item = opener_2(uri, options);
                    if (item != null) {
                        if (!item.getURI || typeof item.getURI !== 'function' || !item.getUri || typeof item.getURI !== 'function') {
                            item.getUri = function () { return uri; };
                        }
                        return item;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
    };
    /**
     * @return {?}
     */
    Workspace.prototype.reopenItem = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var uri = this.destroyedItemURIs.pop();
        if (uri) {
            return this.open(uri);
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     * @param {?} opener
     * @return {?}
     */
    Workspace.prototype.addOpener = /**
     * @param {?} opener
     * @return {?}
     */
    function (opener) {
        this.openers.push(opener);
        // return new Disposable(() => { _.remove(this.openers, opener); });
    };
    /**
     * @param {?} opener
     * @return {?}
     */
    Workspace.prototype.addFrmOpener = /**
     * @param {?} opener
     * @return {?}
     */
    function (opener) {
        if (!this.useFrmOpener) {
            this.useFrmOpener = true;
        }
        this.frmOpeners.push(opener);
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getOpeners = /**
     * @return {?}
     */
    function () {
        return this.useFrmOpener ? this.frmOpeners : this.openers;
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getPaneItems = /**
     * @return {?}
     */
    function () {
        return new Array().concat(this.getPaneContainers().map(function (container) { return container.getPaneItems(); }));
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getActivePaneItem = /**
     * @return {?}
     */
    function () {
        return this.getActivePaneContainer().getActivePaneItem();
    };
    /**
     * @return {?}
     */
    Workspace.prototype.saveAll = /**
     * @return {?}
     */
    function () {
        this.getPaneContainers().forEach(function (container) {
            container.saveAll();
        });
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.confirmClose = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return Promise.all(this.getPaneContainers().map(function (container) {
            return container.confirmClose(options);
        })).then(function (results) { return !results.find(function (item) { return item === false; }); });
    };
    /**
     * @return {?}
     */
    Workspace.prototype.saveActivePaneItem = /**
     * @return {?}
     */
    function () {
        return this.getCenter().getActivePane().saveActiveItem();
    };
    /**
     * @return {?}
     */
    Workspace.prototype.saveActivePaneItemAs = /**
     * @return {?}
     */
    function () {
        this.getCenter().getActivePane().saveActiveItemAs();
    };
    /**
     * @return {?}
     */
    Workspace.prototype.destroyActivePaneItem = /**
     * @return {?}
     */
    function () {
        return this.getActivePane().destroyActiveItem();
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getActivePaneContainer = /**
     * @return {?}
     */
    function () {
        return this.activePaneContainer;
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getPanes = /**
     * @return {?}
     */
    function () {
        return new Array().concat(this.getPaneContainers().map(function (container) { return container.getPanes(); }));
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getVisiblePanes = /**
     * @return {?}
     */
    function () {
        return new Array().concat(this.getVisiblePaneContainers().map(function (container) { return container.getPanes(); }));
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getActivePane = /**
     * @return {?}
     */
    function () {
        return this.getActivePaneContainer().getActivePane();
    };
    /**
     * @return {?}
     */
    Workspace.prototype.activateNextPane = /**
     * @return {?}
     */
    function () {
        return this.getActivePaneContainer().activateNextPane();
    };
    /**
     * @return {?}
     */
    Workspace.prototype.activatePreviousPane = /**
     * @return {?}
     */
    function () {
        return this.getActivePaneContainer().activatePreviousPane();
    };
    /**
     * @param {?} uri
     * @return {?}
     */
    Workspace.prototype.paneContainerForURI = /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        return this.getPaneContainers().find(function (container) { return !!container.paneForURI(uri); });
    };
    /**
     * @param {?} uri
     * @return {?}
     */
    Workspace.prototype.paneContainerForItem = /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        return this.getPaneContainers().find(function (container) { return !!container.paneForItem(uri); });
    };
    /**
     * @param {?} uri
     * @return {?}
     */
    Workspace.prototype.paneForURI = /**
     * @param {?} uri
     * @return {?}
     */
    function (uri) {
        var e_5, _a;
        try {
            for (var _b = __values(this.getPaneContainers()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var location_2 = _c.value;
                /** @type {?} */
                var pane = location_2.paneForURI(uri);
                if (pane != null) {
                    return pane;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    Workspace.prototype.paneForItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var e_6, _a;
        try {
            for (var _b = __values(this.getPaneContainers()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var location_3 = _c.value;
                /** @type {?} */
                var pane = location_3.paneForItem(item);
                if (pane != null) {
                    return pane;
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    /**
     * @return {?}
     */
    Workspace.prototype.destroyActivePane = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var activePane = this.getActivePane();
        if (activePane != null) {
            activePane.destroy();
        }
    };
    /**
     * @return {?}
     */
    Workspace.prototype.closeActivePaneItemOrEmptyPaneOrWindow = /**
     * @return {?}
     */
    function () {
        if (this.getCenter().getActivePaneItem() != null) {
            this.getCenter().getActivePane().destroyActiveItem();
        }
        else if (this.getCenter().getPanes().length > 1) {
            this.getCenter().destroyActivePane();
        }
        else if (this.config.get('core.closeEmptyWindows')) ;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    Workspace.prototype.itemOpened = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
    };
    /**
     * @return {?}
     */
    Workspace.prototype.destroyed = /**
     * @return {?}
     */
    function () {
        this.paneContainers.center.destroy();
        this.paneContainers.left.destroy();
        this.paneContainers.right.destroy();
        this.paneContainers.bottom.destroy();
        for (var panelLocation in this.panelContainers) {
            if (this.panelContainers.hasOwnProperty(panelLocation)) {
                /** @type {?} */
                var panelContainer = this.panelContainers[panelLocation];
                this.paneContainer.destroy();
            }
        }
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getCenter = /**
     * @return {?}
     */
    function () {
        return this.paneContainers.center;
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getLeftDock = /**
     * @return {?}
     */
    function () {
        return this.paneContainers.left;
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getRightDock = /**
     * @return {?}
     */
    function () {
        return this.paneContainers.right;
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getBottomDock = /**
     * @return {?}
     */
    function () {
        return this.paneContainers.bottom;
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getPaneContainers = /**
     * @return {?}
     */
    function () {
        return [
            this.paneContainers.center,
            this.paneContainers.left,
            this.paneContainers.right,
            this.paneContainers.bottom
        ];
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getVisiblePaneContainers = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var center = this.getCenter();
        return this.getPaneContainers()
            .filter(function (container) { return container === center || ((/** @type {?} */ (container))).isVisible(); });
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getBottomPanels = /**
     * @return {?}
     */
    function () {
        return this.getPanels('bottom');
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addBottomPanel = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.addPanel('bottom', options);
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getLeftPanels = /**
     * @return {?}
     */
    function () {
        return this.getPanels('left');
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addLeftPanel = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.addPanel('left', options);
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getRightPanels = /**
     * @return {?}
     */
    function () {
        return this.getPanels('right');
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addRightPanel = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.addPanel('right', options);
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getTopPanels = /**
     * @return {?}
     */
    function () {
        return this.getPanels('top');
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addTopPanel = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.addPanel('top', options);
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getHeaderPanels = /**
     * @return {?}
     */
    function () {
        return this.getPanels('header');
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addHeaderPanel = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.addPanel('header', options);
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getFooterPanels = /**
     * @return {?}
     */
    function () {
        return this.getPanels('footer');
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addFooterPanel = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.addPanel('footer', options);
    };
    /**
     * @return {?}
     */
    Workspace.prototype.getModalPanels = /**
     * @return {?}
     */
    function () {
        return this.getPanels('modal');
    };
    /**
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addModalPanel = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        return this.addPanel('modal', options);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    Workspace.prototype.panelForItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        for (var location_4 in this.panelContainers) {
            if (this.panelContainers.hasOwnProperty(location_4)) {
                /** @type {?} */
                var panel = this.panelContainers[location_4].panelForItem(item);
                if (panel != null) {
                    return panel;
                }
            }
        }
        return null;
    };
    /**
     * @param {?} location
     * @return {?}
     */
    Workspace.prototype.getPanelContainer = /**
     * @param {?} location
     * @return {?}
     */
    function (location) {
        return this.panelContainers[location];
    };
    /**
     * @param {?} location
     * @return {?}
     */
    Workspace.prototype.getPanels = /**
     * @param {?} location
     * @return {?}
     */
    function (location) {
        return this.panelContainers[location].getPanels();
    };
    /**
     * @param {?} location
     * @param {?} options
     * @return {?}
     */
    Workspace.prototype.addPanel = /**
     * @param {?} location
     * @param {?} options
     * @return {?}
     */
    function (location, options) {
        /** @type {?} */
        var panel = new Panel(options, this.viewRegistry);
        return this.panelContainers[location].addPanel(panel);
    };
    return Workspace;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GspEventBus = /** @class */ (function (_super) {
    __extends(GspEventBus, _super);
    function GspEventBus() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.commands = [];
        return _this;
    }
    /**
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    GspEventBus.prototype.on = /**
     * @param {?} target
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} caller
     * @param {?} handler
     * @return {?}
     */
    function (target, tokenValue, eventName, caller, handler) {
        // 如果有对应激活命令，监听事件时立即执行回调函数
        /** @type {?} */
        var command = this.commands.find(function (item) { return item.name === eventName; });
        if (command) {
            handler.call(caller, command.eventeParams);
        }
        return _super.prototype.on.call(this, target, tokenValue, eventName, caller, handler);
    };
    /**
     * @param {?} emitterType
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    GspEventBus.prototype.post = /**
     * @param {?} emitterType
     * @param {?} tokenValue
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    function (emitterType, tokenValue, eventName, eventArgs) {
        this.dispatchCommand(eventName, eventArgs);
        _super.prototype.post.call(this, emitterType, tokenValue, eventName, eventArgs);
    };
    /**
     * @param {?} commandName
     * @param {?} plugin
     * @param {?} activateFn
     * @return {?}
     */
    GspEventBus.prototype.registryActivateCommand = /**
     * @param {?} commandName
     * @param {?} plugin
     * @param {?} activateFn
     * @return {?}
     */
    function (commandName, plugin, activateFn) {
        this.commands.push({
            name: commandName,
            plugin: plugin,
            activateFn: activateFn
        });
    };
    /**
     * @private
     * @param {?} commandName
     * @param {?} args
     * @return {?}
     */
    GspEventBus.prototype.dispatchCommand = /**
     * @private
     * @param {?} commandName
     * @param {?} args
     * @return {?}
     */
    function (commandName, args) {
        /** @type {?} */
        var command = this.commands.find(function (item) { return item.name === commandName; });
        if (command) {
            command.activateFn(command.plugin);
            command.eventParams = args;
        }
    };
    return GspEventBus;
}(EventBus));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalFrm = /** @class */ (function () {
    function ModalFrm() {
    }
    /**
     * @param {?} options
     * @return {?}
     */
    ModalFrm.prototype.add = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
    };
    /**
     * @param {?} id
     * @return {?}
     */
    ModalFrm.prototype.show = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
    };
    /**
     * @param {?} id
     * @return {?}
     */
    ModalFrm.prototype.hide = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
    };
    /**
     * @param {?} id
     * @return {?}
     */
    ModalFrm.prototype.close = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
    };
    return ModalFrm;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 提供ide运行所需的方法，供插件使用
 */
var  /**
 * 提供ide运行所需的方法，供插件使用
 */
Ide = /** @class */ (function () {
    function Ide(parent) {
        this.events = new Map();
        this.modal = new ModalFrm();
        this.frameId = this.getParam('frameID');
        if (this.isTop) {
            this.commandData = new Map();
        }
        if (parent) {
            this.msgr = parent.messager;
        }
    }
    Object.defineProperty(Ide.prototype, "isTop", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return window.top === window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Ide.prototype, "parentInstance", {
        get: /**
         * @private
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            /** @type {?} */
            var instance = (/** @type {?} */ (this));
            /** @type {?} */
            var top = window.top;
            if (top && top['gsp']) {
                instance = top['gsp'].ide;
            }
            return instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Ide.prototype, "messager", {
        get: /**
         * @return {?}
         */
        function () {
            return this.msgr;
        },
        enumerable: true,
        configurable: true
    });
    /* #region  frame util */
    /* #region  frame util */
    /**
     * @param {?} key
     * @return {?}
     */
    Ide.prototype.getParam = /* #region  frame util */
    /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var params = new URLSearchParams(window.location.search);
        return unescape(params.get(key));
    };
    /**
     * @param {?=} frameId
     * @return {?}
     */
    Ide.prototype.getInitCommandData = /**
     * @param {?=} frameId
     * @return {?}
     */
    function (frameId) {
        if (!this.isTop) {
            frameId = frameId || this.frameId;
            return this.parentInstance.getInitCommandData(frameId);
        }
        else {
            return this.commandData.get(frameId);
        }
    };
    /**
     * @param {?} frameId
     * @param {?} data
     * @return {?}
     */
    Ide.prototype.setInitCommandData = /**
     * @param {?} frameId
     * @param {?} data
     * @return {?}
     */
    function (frameId, data) {
        if (!this.isTop) {
            this.parentInstance.setInitCommandData(frameId, data);
        }
        else {
            this.commandData.set(frameId, data);
        }
    };
    /**
     * @param {?} messager
     * @return {?}
     */
    Ide.prototype.setMessager = /**
     * @param {?} messager
     * @return {?}
     */
    function (messager) {
        this.msgr = messager;
    };
    /* #endregion */
    /* #region  event */
    /* #endregion */
    /* #region  event */
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onPanelAdded = /* #endregion */
    /* #region  event */
    /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('panel-added', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onPanelRemoved = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('panel-removed', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onPanelShown = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('panel-shown', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onPanelHidden = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('panel-hidden', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onModalConfirming = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        if (this.parentInstance !== this) {
            this.parentInstance.onModalConfirming(cb);
        }
        else {
            this.on('confirm-modal', cb);
        }
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onModalCancelling = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('cancel-modal', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onLeftActivated = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        if (this.isTop) {
            this.on('activate-left', cb);
        }
        else {
            this.parentInstance.onLeftActivated(cb);
        }
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onNotifyShown = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('show-notify', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onLoadingShown = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('show-loading', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onLoadingHidden = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('hide-loading', cb);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onDesignerStatusSet = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.on('set-designer-status', cb);
    };
    // onBeforeClose(id: string, cb: () => boolean) {
    //   this.on('on-before-close', ({metadataId}) => {
    //     if (id === metadataId) {
    //       return cb();
    //     }
    //     return true;
    //   });
    // }
    // onBeforeClose(id: string, cb: () => boolean) {
    //   this.on('on-before-close', ({metadataId}) => {
    //     if (id === metadataId) {
    //       return cb();
    //     }
    //     return true;
    //   });
    // }
    /**
     * @param {?} id
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.onCloseTab = 
    // onBeforeClose(id: string, cb: () => boolean) {
    //   this.on('on-before-close', ({metadataId}) => {
    //     if (id === metadataId) {
    //       return cb();
    //     }
    //     return true;
    //   });
    // }
    /**
     * @param {?} id
     * @param {?} cb
     * @return {?}
     */
    function (id, cb) {
        if (!this.isTop) {
            return this.parentInstance.onCloseTab(id, cb);
        }
        this.on('close-tab', function (tabId) {
            if (id === tabId) {
                return cb();
            }
            return true;
        });
    };
    /* #endregion */
    /* #region  panel */
    /* #endregion */
    /* #region  panel */
    /**
     * @param {?} options
     * @return {?}
     */
    Ide.prototype.addPanel = /* #endregion */
    /* #region  panel */
    /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        this.emit('panel-added', options);
    };
    /* #endregion */
    /* #region  modal */
    /* #endregion */
    /* #region  modal */
    /**
     * @param {?} options
     * @return {?}
     */
    Ide.prototype.addModal = /* #endregion */
    /* #region  modal */
    /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        this.emit('panel-added', options, 'modal');
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    Ide.prototype.closeModal = /**
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (this.parentInstance !== this) {
            this.parentInstance.closeModal(id);
        }
        this.emit('panel-removed', id, 'modal');
    };
    /**
     * @param {?} id
     * @return {?}
     */
    Ide.prototype.confirmModal = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var result = true;
        // if (this.parentInstance !== this) {
        //   result = this.parentInstance.confirmModal(id);
        // }
        result = result && (/** @type {?} */ (this.emit('confirm-modal', id)));
        return result;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    Ide.prototype.cancelModal = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var result = true;
        if (this.parentInstance !== this) {
            result = this.parentInstance.cancelModal(id);
        }
        result = result && (/** @type {?} */ (this.emit('cancel-modal', id)));
        return result;
    };
    // addLeft    registryOpener....
    /* #endregion */
    /* #region  left rigion */
    // addLeft    registryOpener....
    /* #endregion */
    /* #region  left rigion */
    /**
     * @param {?=} frameId
     * @return {?}
     */
    Ide.prototype.activateLeft = 
    // addLeft    registryOpener....
    /* #endregion */
    /* #region  left rigion */
    /**
     * @param {?=} frameId
     * @return {?}
     */
    function (frameId) {
        frameId = frameId || this.frameId;
        if (this.isTop) {
            this.emit('activate-left', frameId);
        }
        else {
            this.parentInstance.activateLeft(frameId);
        }
    };
    /* #endregion */
    /* #endregion */
    /**
     * @param {?} level
     * @param {?} content
     * @return {?}
     */
    Ide.prototype.notify = /* #endregion */
    /**
     * @param {?} level
     * @param {?} content
     * @return {?}
     */
    function (level, content) {
        if (this.isTop) {
            this.emit('show-notify', level, content);
        }
        else {
            this.parentInstance.notify(level, content);
        }
    };
    /**
     * @param {?=} message
     * @return {?}
     */
    Ide.prototype.loading = /**
     * @param {?=} message
     * @return {?}
     */
    function (message) {
        if (this.isTop) {
            this.emit('show-loading', message);
        }
        else {
            this.parentInstance.loading(message);
        }
    };
    /**
     * @return {?}
     */
    Ide.prototype.loaded = /**
     * @return {?}
     */
    function () {
        if (this.isTop) {
            this.emit('hide-loading');
        }
        else {
            this.parentInstance.loaded();
        }
    };
    /**
     * @param {?} metadataId
     * @param {?} isDirty
     * @return {?}
     */
    Ide.prototype.setDesignerStatus = /**
     * @param {?} metadataId
     * @param {?} isDirty
     * @return {?}
     */
    function (metadataId, isDirty) {
        if (this.isTop) {
            this.emit('set-designer-status', { id: metadataId, isDirty: isDirty });
        }
        else {
            this.parentInstance.setDesignerStatus(metadataId, isDirty);
        }
    };
    // closeDesigner(metadataId: string) {
    //   if (this.isTop) {
    //     this.emit('close-designer', {id: metadataId});
    //   } else {
    //     this.parentInstance.closeDesigner(metadataId);
    //   }
    // }
    // closeDesigner(metadataId: string) {
    //   if (this.isTop) {
    //     this.emit('close-designer', {id: metadataId});
    //   } else {
    //     this.parentInstance.closeDesigner(metadataId);
    //   }
    // }
    /**
     * @param {?} id
     * @return {?}
     */
    Ide.prototype.notifyCloseTab = 
    // closeDesigner(metadataId: string) {
    //   if (this.isTop) {
    //     this.emit('close-designer', {id: metadataId});
    //   } else {
    //     this.parentInstance.closeDesigner(metadataId);
    //   }
    // }
    /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (!this.isTop) {
            return this.parentInstance.notifyCloseTab(id);
        }
        /** @type {?} */
        var result = this.emit('close-tab', id);
        if (result == null) {
            return of(true);
        }
        else if (typeof result === 'boolean') {
            return of(result);
        }
        else {
            return result;
        }
    };
    /**
     * @param {?} workspace
     * @return {?}
     */
    Ide.prototype.registerIDE = /**
     * @param {?} workspace
     * @return {?}
     */
    function (workspace) {
        // 用来把ide view实例与gsp对象绑定。
        // TODO： view实例监听gsp对象的操作放在这里。
        if (typeof workspace.onCloseDesigner === 'function') {
            this.on('close-designer', workspace.onCloseDesigner.bind(workspace));
        }
    };
    /* #region  private method */
    /* #region  private method */
    /**
     * @private
     * @param {?} name
     * @param {?} cb
     * @return {?}
     */
    Ide.prototype.on = /* #region  private method */
    /**
     * @private
     * @param {?} name
     * @param {?} cb
     * @return {?}
     */
    function (name, cb) {
        /** @type {?} */
        var callbacks = this.events.get(name);
        if (!callbacks) {
            callbacks = [cb];
            this.events.set(name, callbacks);
        }
        else {
            callbacks.push(cb);
        }
    };
    /**
     * @private
     * @param {?} name
     * @param {...?} params
     * @return {?}
     */
    Ide.prototype.emit = /**
     * @private
     * @param {?} name
     * @param {...?} params
     * @return {?}
     */
    function (name) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        var e_1, _a;
        /** @type {?} */
        var callbacks = this.events.get(name);
        if (!callbacks || !callbacks.length) {
            return;
        }
        /** @type {?} */
        var result = true;
        /** @type {?} */
        var observableResult = new Array();
        try {
            for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
                var cb = callbacks_1_1.value;
                /** @type {?} */
                var cbResult = cb.apply(void 0, __spread(params));
                if (cbResult == null) {
                    continue;
                }
                if (typeof cbResult === 'boolean') {
                    result = result && cbResult;
                }
                else if (typeof cbResult.subscribe === 'function' && cbResult.constructor.name === Observable.name) {
                    // 判断条件不能使用cbResult instanceof Observable,因为cb可能是来自于不同的iframe环境，导致跟这里的Observable构造函数不一样。
                    observableResult.push(cbResult);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (observableResult.length) {
            return forkJoin(__spread(observableResult, [of(result)])).pipe(map(function (results) {
                return results.reduce(function (previous, current) { return previous && current; });
            }));
        }
        else {
            return result;
        }
    };
    return Ide;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GSP = /** @class */ (function () {
    function GSP(parent) {
        this.pConfig = {
            get: /**
             * @param {?} key
             * @return {?}
             */
            function (key) {
                return this[key];
            }
        };
        /** @type {?} */
        var ide;
        if (parent) {
            this.pViews = parent.views;
            this.pCommands = parent.commands;
            this.pEventBus = parent.eventBus;
            this.pUtil = parent.util;
            this.pWorkspace = parent.workspace;
            this.pCache = parent.cache;
            ide = parent.ide;
            /** @type {?} */
            var ctor = parent.context.constructor;
            this.pContext = new ctor();
        }
        else {
            this.pViews = new ViewRegistry(this);
            this.pCommands = new CommandRegistry();
            this.pEventBus = new GspEventBus();
            this.pUtil = new Util();
            this.pWorkspace = new Workspace({
                config: this.pConfig,
                viewRegistry: this.pViews
            });
            this.pCache = new CacheService(null);
        }
        this.pIde = new Ide(ide);
    }
    Object.defineProperty(GSP.prototype, "eventBus", {
        get: /**
         * @return {?}
         */
        function () { return this.pEventBus; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GSP.prototype, "util", {
        get: /**
         * @return {?}
         */
        function () { return this.pUtil; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GSP.prototype, "workspace", {
        get: /**
         * @return {?}
         */
        function () { return this.pWorkspace; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GSP.prototype, "views", {
        get: /**
         * @return {?}
         */
        function () { return this.pViews; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GSP.prototype, "commands", {
        get: /**
         * @return {?}
         */
        function () { return this.pCommands; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GSP.prototype, "ide", {
        get: /**
         * @return {?}
         */
        function () { return this.pIde; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GSP.prototype, "cache", {
        get: /**
         * @return {?}
         */
        function () { return this.pCache; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GSP.prototype, "context", {
        get: /**
         * @return {?}
         */
        function () { return this.pContext; },
        enumerable: true,
        configurable: true
    });
    /**
     * @deprecated 由子模块独自创建gsp实例，传入父实例作为参数。
     * 每个iframe持有一个独有的gsp实例，其中eventbus共享，ide不共享
     */
    /**
     * @deprecated 由子模块独自创建gsp实例，传入父实例作为参数。
     * 每个iframe持有一个独有的gsp实例，其中eventbus共享，ide不共享
     * @return {?}
     */
    GSP.prototype.createChild = /**
     * @deprecated 由子模块独自创建gsp实例，传入父实例作为参数。
     * 每个iframe持有一个独有的gsp实例，其中eventbus共享，ide不共享
     * @return {?}
     */
    function () {
        /** @type {?} */
        var child = new GSP(this);
        // child.pEventBus = this.pEventBus;
        // child.pViews = this.pViews;
        // child.pWorkspace = this.pWorkspace;
        return child;
    };
    return GSP;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// export enum Location {
//   top,
//   left,
//   right,
//   bottom,
//   header,
//   footer,
//   modal
// }

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Messager = /** @class */ (function () {
    function Messager() {
    }
    /**
     * @param {?} message
     * @param {?=} callback
     * @return {?}
     */
    Messager.prototype.info = /**
     * @param {?} message
     * @param {?=} callback
     * @return {?}
     */
    function (message, callback) {
    };
    /**
     * @param {?} message
     * @param {?} okCallback
     * @param {?=} cancelCallback
     * @return {?}
     */
    Messager.prototype.question = /**
     * @param {?} message
     * @param {?} okCallback
     * @param {?=} cancelCallback
     * @return {?}
     */
    function (message, okCallback, cancelCallback) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    Messager.prototype.confirm = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        return null;
    };
    /**
     * @param {?} message
     * @return {?}
     */
    Messager.prototype.error = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    /**
     * @param {?} message
     * @return {?}
     */
    Messager.prototype.warning = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
    };
    return Messager;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PackageView = /** @class */ (function () {
    function PackageView(serializedState) {
    }
    /**
     * @return {?}
     */
    PackageView.prototype.getElement = /**
     * @return {?}
     */
    function () {
        return this.element;
    };
    /**
     * Returns an object that can be retrieved when package is activated.
     */
    /**
     * Returns an object that can be retrieved when package is activated.
     * @return {?}
     */
    PackageView.prototype.serialize = /**
     * Returns an object that can be retrieved when package is activated.
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    PackageView.prototype.destroy = /**
     * @return {?}
     */
    function () {
    };
    return PackageView;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Package = /** @class */ (function () {
    function Package(gsp) {
        this.gsp = gsp;
        // leftPanel: any;
        // modelPanel: any;
        this.subscriptions = [];
        this.packageId = gsp.util.newGuid();
    }
    Object.defineProperty(Package.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this.packageId;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.packageId = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Package.prototype, "view", {
        get: /**
         * @return {?}
         */
        function () {
            return this.packageView;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} state
     * @return {?}
     */
    Package.prototype.activate = /**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this.packageView = new PackageView(state.sagipackageViewState);
        // /*this.leftPanel = */this.ws.addLeftPanel({
        //   title: 'test',
        //   item: this.packageView.getComponent(),
        //   visible: false
        // });
    };
    /**
     * @return {?}
     */
    Package.prototype.initialize = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    Package.prototype.deactivate = /**
     * @return {?}
     */
    function () {
        this.packageView.destroy();
    };
    /**
     * @return {?}
     */
    Package.prototype.serialize = /**
     * @return {?}
     */
    function () {
        return {
            sagipackageViewState: this.packageView.serialize()
        };
    };
    /**
     * @return {?}
     */
    Package.prototype.toggle = /**
     * @return {?}
     */
    function () {
        // return (
        //   this.modelPanel.isVisible() ?
        //     this.modelPanel.hide() :
        //     this.modelPanel.show()
        // );
    };
    /**
     * @return {?}
     */
    Package.prototype.getComponent = /**
     * @return {?}
     */
    function () {
        return null;
    };
    return Package;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PackageModule = /** @class */ (function () {
    function PackageModule() {
    }
    /**
     * @param {?} gsp
     * @return {?}
     */
    PackageModule.prototype.getPackage = /**
     * @param {?} gsp
     * @return {?}
     */
    function (gsp) {
        if (!this.package) {
            this.initPackage(gsp);
            // ng7升级后，插件包是iframe的形式，初始化方式改变。
            if (this.package) {
                this.package.initialize();
            }
        }
        return this.package;
    };
    /**
     * @protected
     * @param {?} gsp
     * @return {?}
     */
    PackageModule.prototype.initPackage = /**
     * @protected
     * @param {?} gsp
     * @return {?}
     */
    function (gsp) {
        this.package = new Package(gsp);
    };
    return PackageModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CacheModule = /** @class */ (function () {
    function CacheModule() {
    }
    /**
     * @return {?}
     */
    CacheModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: CacheModule,
            providers: [
                CacheLocalStorage,
                CacheMemoryStorage,
                CacheSessionStorage,
                CacheService
            ]
        };
    };
    CacheModule.decorators = [
        { type: NgModule, args: [{
                    declarations: []
                },] }
    ];
    return CacheModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HttpService = /** @class */ (function () {
    function HttpService(http, cache) {
        this.http = http;
        this.cache = cache;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    HttpService.prototype.get = /**
     * @param {?} url
     * @return {?}
     */
    function (url) {
        return this.request('Get', url, this.setHeader({}));
    };
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    HttpService.prototype.post = /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    function (url, body) {
        return this.request('Post', url, this.setHeader({ body: body }));
    };
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    HttpService.prototype.put = /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    function (url, body) {
        return this.request('Put', url, this.setHeader({ body: body }));
    };
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    HttpService.prototype.delete = /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    function (url, body) {
        return this.request('Delete', url, this.setHeader({ body: body }));
    };
    /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    HttpService.prototype.patch = /**
     * @param {?} url
     * @param {?} body
     * @return {?}
     */
    function (url, body) {
        return this.request('Patch', url, this.setHeader({ body: body }));
    };
    /**
     * @param {?} options
     * @return {?}
     */
    HttpService.prototype.setHeader = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        options.headers = {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
        };
        if (this.cache.exists('sessionId') && this.cache.get('sessionId')) {
            options.headers['SessionId'] = this.cache.get('sessionId');
        }
        return options;
    };
    /**
     * @param {?} method
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    HttpService.prototype.request = /**
     * @param {?} method
     * @param {?} url
     * @param {?} options
     * @return {?}
     */
    function (method, url, options) {
        if (options.body) {
            if (typeof options.body !== 'string') {
                options.body = JSON.stringify(options.body);
            }
        }
        return this.http.request(method, url, options)
            .pipe(map(function (data) {
            console.log(data);
            return data;
        }));
    };
    HttpService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: CacheService }
    ]; };
    return HttpService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var GSPHttpModule = /** @class */ (function () {
    function GSPHttpModule() {
    }
    GSPHttpModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        HttpClientModule
                    ],
                    providers: [HttpService]
                },] }
    ];
    return GSPHttpModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BsDropdownConfig, BsDropdownContainerComponent, BsDropdownDirective, BsDropdownMenuDirective, BsDropdownModule, BsDropdownState, BsDropdownToggleDirective, DropdownButtonDirective, DropdownItemDirective, PanelModule, NgbAccordionModule, NgbTabsetModule, NgbTabsetConfig, NgbTabset, NgbTab, NgbTabContent, NgbTabTitle, NgbNavTabsetModule, NgbNavTabsetConfig, NgbNavTabset, NgbNavTab, NgbNavTabContent, NgbNavTabTitle, AlertComponent, AlertModule, AlertConfig, TooltipContainerComponent, TooltipDirective, TooltipModule, TooltipConfig, BsModalRef, ModalBackdropOptions, ModalContainerComponent, ModalBackdropComponent, ModalOptions, ModalDirective, ModalModule$1 as ModalModule, BsModalService$1 as BsModalService, NavbarDirective, NavbarState, NavbarModule, TreeModule, TreeComponent, TreeNode, AngularMonacoEditorModule, CODE_EDITOR_INPUT_VALUE_ACCESSOR, AngularMonacoEditorComponent, ANGULAR_MONACO_EDITOR_CONFIG, CODE_EDITOR_EVENTS, CodeEditorEventService, AngularMonacoEditorService, ShContextMenuModule, ShContextMenuComponent, ShAttachMenuDirective, ShContextMenuItemDirective, ShContextMenuService, WizardComponent, WizardModule, ComboListModule$1 as ComboListModule, ComboService, ComboListComponent, PropertyPanelModule, PropertyType, ElementPropertyConfig, PropertyEntity, BeforeOpenModalResult, PropertyChangeObject, PropertyPanelComponent, NgbRootModule, NgbModule, IDERootModule, PopoverDirective, PopoverModule, PopoverConfig, PopoverContainerComponent, OnChange, LinkedList, isBs3$1 as isBs3, Trigger, Utils, warnOnce, positionElements, Positioning, PositioningService, ComponentLoader, ComponentLoaderFactory, ContentRef, win as window, document$1 as document, location, gc, performance, Event$1 as Event, MouseEvent, KeyboardEvent, EventTarget, History, Location, EventListener, EventBus, EventBusProxy, EventPipe, Package, PackageModule, PackageView, Util, DockStyle, Dock, GSP, GspEventBus, ItemRegistry, Model, PaneAxis, PaneContainer, Panel, ViewRegistry, WorkspaceCenter, Workspace, Ide, Messager, CacheService, CacheStorageAbstract, CacheLocalStorage, CacheMemoryStorage, CacheSessionStorage, CacheModule, GSPHttpModule, HttpService, NgbAccordion as ɵf, NgbPanel as ɵe, NgbPanelContent as ɵd, NgbPanelTitle as ɵc, NgbAccordionConfig as ɵg, BaseMonacoEditor as ɵm, CLASS_NAME as ɵa, MenuItemContext as ɵb, TreeNodeContentComponent as ɵk, TreeNodeDropSlotComponent as ɵl, TreeNodeComponent as ɵi, TreeNodeContentDirective as ɵj, TreeModel as ɵh, SashDirective as ɵp, PropertyItemListComponent as ɵn, PropertyItemComponent as ɵo, EventBus as ɵq };

//# sourceMappingURL=farris-ide-devkit.js.map