/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/**
 * @param {?} percent
 * @return {?}
 */
function stripPercentToNumber(percent) {
    return +percent.replace('%', '');
}
/** @type {?} */
export const sortGradient = (/**
 * @param {?} gradients
 * @return {?}
 */
(gradients) => {
    /** @type {?} */
    let tempArr = [];
    Object.keys(gradients).forEach((/**
     * @param {?} key
     * @return {?}
     */
    key => {
        /** @type {?} */
        const value = gradients[key];
        /** @type {?} */
        const formatKey = stripPercentToNumber(key);
        if (!isNaN(formatKey)) {
            tempArr.push({
                key: formatKey,
                value
            });
        }
    }));
    tempArr = tempArr.sort((/**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    (a, b) => a.key - b.key));
    return tempArr;
});
/** @type {?} */
export const handleCircleGradient = (/**
 * @param {?} strokeColor
 * @return {?}
 */
(strokeColor) => {
    return sortGradient(strokeColor).map((/**
     * @param {?} __0
     * @return {?}
     */
    ({ key, value }) => ({ offset: `${key}%`, color: value })));
});
/** @type {?} */
export const handleLinearGradient = (/**
 * @param {?} strokeColor
 * @return {?}
 */
(strokeColor) => {
    const { from = '#59a1ff', to = '#59a1ff', direction = 'to right' } = strokeColor, rest = tslib_1.__rest(strokeColor, ["from", "to", "direction"]);
    if (Object.keys(rest).length !== 0) {
        /** @type {?} */
        const sortedGradients = sortGradient((/** @type {?} */ (rest)))
            .map((/**
         * @param {?} __0
         * @return {?}
         */
        ({ key, value }) => `${value} ${key}%`))
            .join(', ');
        return `linear-gradient(${direction}, ${sortedGradients})`;
    }
    return `linear-gradient(${direction}, ${from}, ${to})`;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3MtdXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL3VpLXByb2dyZXNzLyIsInNvdXJjZXMiOlsibGliL3Byb2dyZXNzLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBLFNBQVMsb0JBQW9CLENBQUMsT0FBZTtJQUN6QyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDckMsQ0FBQzs7QUFFRCxNQUFNLE9BQU8sWUFBWTs7OztBQUFHLENBQUMsU0FBb0MsRUFBRSxFQUFFOztRQUM3RCxPQUFPLEdBQTBDLEVBQUU7SUFDdkQsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPOzs7O0lBQUMsR0FBRyxDQUFDLEVBQUU7O2NBQzdCLEtBQUssR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDOztjQUN0QixTQUFTLEdBQUcsb0JBQW9CLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDckIsT0FBTyxDQUFDLElBQUksQ0FBQztnQkFDWCxHQUFHLEVBQUUsU0FBUztnQkFDZCxLQUFLO2FBQ04sQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDLEVBQUMsQ0FBQztJQUVILE9BQU8sR0FBRyxPQUFPLENBQUMsSUFBSTs7Ozs7SUFBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBQyxDQUFDO0lBQ2hELE9BQU8sT0FBTyxDQUFDO0FBQ25CLENBQUMsQ0FBQTs7QUFFRCxNQUFNLE9BQU8sb0JBQW9COzs7O0FBQUcsQ0FBQyxXQUFzQyxFQUE0QyxFQUFFO0lBQ3JILE9BQU8sWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUc7Ozs7SUFBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUMsQ0FBQztBQUNwRyxDQUFDLENBQUE7O0FBRUQsTUFBTSxPQUFPLG9CQUFvQjs7OztBQUFHLENBQUMsV0FBbUMsRUFBRSxFQUFFO1VBQ2xFLEVBQUUsSUFBSSxHQUFHLFNBQVMsRUFBRSxFQUFFLEdBQUcsU0FBUyxFQUFFLFNBQVMsR0FBRyxVQUFVLEtBQWMsV0FBVyxFQUF2QiwrREFBTztJQUN6RSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7Y0FDNUIsZUFBZSxHQUFHLFlBQVksQ0FBQyxtQkFBQSxJQUFJLEVBQTZCLENBQUM7YUFDcEUsR0FBRzs7OztRQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxJQUFJLEdBQUcsR0FBRyxFQUFDO2FBQzNDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDYixPQUFPLG1CQUFtQixTQUFTLEtBQUssZUFBZSxHQUFHLENBQUM7S0FDNUQ7SUFDRCxPQUFPLG1CQUFtQixTQUFTLEtBQUssSUFBSSxLQUFLLEVBQUUsR0FBRyxDQUFDO0FBQzNELENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZQcm9ncmVzc0dyYWRpZW50UHJvZ3Jlc3MsIEZQcm9ncmVzc0NvbG9yR3JhZGllbnQgfSBmcm9tICcuL3Byb2dyZXNzLW9wdGlvbnMnO1xyXG5cclxuZnVuY3Rpb24gc3RyaXBQZXJjZW50VG9OdW1iZXIocGVyY2VudDogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgIHJldHVybiArcGVyY2VudC5yZXBsYWNlKCclJywgJycpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc29ydEdyYWRpZW50ID0gKGdyYWRpZW50czogRlByb2dyZXNzR3JhZGllbnRQcm9ncmVzcykgPT4ge1xyXG4gICAgbGV0IHRlbXBBcnI6IEFycmF5PHsga2V5OiBudW1iZXI7IHZhbHVlOiBzdHJpbmcgfT4gPSBbXTtcclxuICAgIE9iamVjdC5rZXlzKGdyYWRpZW50cykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IGdyYWRpZW50c1trZXldO1xyXG4gICAgICBjb25zdCBmb3JtYXRLZXkgPSBzdHJpcFBlcmNlbnRUb051bWJlcihrZXkpO1xyXG4gICAgICBpZiAoIWlzTmFOKGZvcm1hdEtleSkpIHtcclxuICAgICAgICB0ZW1wQXJyLnB1c2goe1xyXG4gICAgICAgICAga2V5OiBmb3JtYXRLZXksXHJcbiAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICBcclxuICAgIHRlbXBBcnIgPSB0ZW1wQXJyLnNvcnQoKGEsIGIpID0+IGEua2V5IC0gYi5rZXkpO1xyXG4gICAgcmV0dXJuIHRlbXBBcnI7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaGFuZGxlQ2lyY2xlR3JhZGllbnQgPSAoc3Ryb2tlQ29sb3I6IEZQcm9ncmVzc0dyYWRpZW50UHJvZ3Jlc3MpOiBBcnJheTx7IG9mZnNldDogc3RyaW5nOyBjb2xvcjogc3RyaW5nIH0+ID0+IHtcclxuICAgIHJldHVybiBzb3J0R3JhZGllbnQoc3Ryb2tlQ29sb3IpLm1hcCgoeyBrZXksIHZhbHVlIH0pID0+ICh7IG9mZnNldDogYCR7a2V5fSVgLCBjb2xvcjogdmFsdWUgfSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGhhbmRsZUxpbmVhckdyYWRpZW50ID0gKHN0cm9rZUNvbG9yOiBGUHJvZ3Jlc3NDb2xvckdyYWRpZW50KSA9PiB7XHJcbiAgICBjb25zdCB7IGZyb20gPSAnIzU5YTFmZicsIHRvID0gJyM1OWExZmYnLCBkaXJlY3Rpb24gPSAndG8gcmlnaHQnLCAuLi5yZXN0IH0gPSBzdHJva2VDb2xvcjtcclxuICAgIGlmIChPYmplY3Qua2V5cyhyZXN0KS5sZW5ndGggIT09IDApIHtcclxuICAgICAgY29uc3Qgc29ydGVkR3JhZGllbnRzID0gc29ydEdyYWRpZW50KHJlc3QgYXMgRlByb2dyZXNzR3JhZGllbnRQcm9ncmVzcylcclxuICAgICAgICAubWFwKCh7IGtleSwgdmFsdWUgfSkgPT4gYCR7dmFsdWV9ICR7a2V5fSVgKVxyXG4gICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgICByZXR1cm4gYGxpbmVhci1ncmFkaWVudCgke2RpcmVjdGlvbn0sICR7c29ydGVkR3JhZGllbnRzfSlgO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBsaW5lYXItZ3JhZGllbnQoJHtkaXJlY3Rpb259LCAke2Zyb219LCAke3RvfSlgO1xyXG59OyJdfQ==