import { CommonModule } from '@angular/common';
import ResizeObserver from 'resize-observer-polyfill';
import { MessagerService, MessagerModule } from '@farris/ui-messager';
import { EventManager } from '@angular/platform-browser';
import { LocaleService, LocaleModule } from '@farris/ui-locale';
import { Component, Input, Output, EventEmitter, forwardRef, Optional, ElementRef, HostBinding, ViewEncapsulation, Injector, Directive, HostListener, Renderer2, ViewContainerRef, NgZone, InjectionToken, ChangeDetectorRef, ViewChild, ComponentFactoryResolver, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NgControl, FormsModule } from '@angular/forms';
import { IdService, CommonUtils, OverLayHiddenService, FarrisCommonModule } from '@farris/ui-common';
import { of } from 'rxjs';
import { debounceTime } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioGroupComponent {
    /**
     * @param {?} idSer
     */
    constructor(idSer) {
        this.idSer = idSer;
        this.modelChange = new EventEmitter();
        // tslint:disable-next-line:ban-types
        this.subscriber = [];
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.idSer.generate().replace(/-/g, '_');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeModel(value) {
        this.model = value;
        this.modelChange.emit(this.model);
        this.controlChange(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
        this.changeModel(this.model);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
RadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radio-group',
                template: `
    <div class="farris-radio-group btn-group"
    [class.farris-input-wrap]="type!=='button'"
    [class.btn-group-toggle]="type==='button'"
    [class.farris-checkradio-hor]="horizontal">
      <ng-content></ng-content>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => RadioGroupComponent)),
                        multi: true,
                    }],
                styles: [`
    `]
            }] }
];
/** @nocollapse */
RadioGroupComponent.ctorParameters = () => [
    { type: IdService }
];
RadioGroupComponent.propDecorators = {
    type: [{ type: Input }],
    model: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    modelChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioComponent {
    /**
     * @param {?} radioGroup
     * @param {?} el
     */
    constructor(radioGroup, el) {
        this.radioGroup = radioGroup;
        this.el = el;
        /* radio 值 */
        this.label = '';
        this.name = '';
        this.modelChange = new EventEmitter();
        this.blockClass = true;
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /* radio 原生name 用于多个radio单选使用 */
    // get name() {
    //   if (this.hasParent(this.el.nativeElement)) {
    //     return this.radioGroup.name;
    //   }
    // }
    /* radio 值 */
    /**
     * @return {?}
     */
    get model() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.model;
        }
        return this.nyModel;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this.nyModel = model;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.radioGroup.name;
    }
    /**
     * @return {?}
     */
    changeModelHandler() {
        // 父元素获取label  子元素再从父元素获取model
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.changeModel(this.label);
        }
        this.model = this.label;
        this.modelChange.emit(this.model);
        this.controlChange(this.label);
    }
    /* 是否存在父元素  存在即单选组*/
    /**
     * @param {?} element
     * @return {?}
     */
    hasParent(element) {
        return element.parentElement.classList.contains('farris-radio-group');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
RadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radio',
                template: "<label class=\"custom-control custom-radio\">\r\n    <input class=\"custom-control-input\" [name]=\"name\" [value]=\"label\" \r\n    [ngModel]=\"model\" (ngModelChange)=\"changeModelHandler()\" type=\"radio\" [disabled]=\"disabled\">\r\n    <span class=\"custom-control-label\">\r\n      <ng-content>\r\n      </ng-content>\r\n    </span>\r\n</label>",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => RadioComponent)),
                        multi: true,
                    }]
                // changeDetection: ChangeDetectionStrategy.OnPush,
                ,
                styles: [".btn-group .btn{margin-left:-1px}"]
            }] }
];
/** @nocollapse */
RadioComponent.ctorParameters = () => [
    { type: RadioGroupComponent, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
RadioComponent.propDecorators = {
    model: [{ type: Input }],
    id: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }],
    modelChange: [{ type: Output }],
    blockClass: [{ type: HostBinding, args: ['class.d-block',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioButtonComponent {
    /**
     * @param {?} radioGroup
     * @param {?} el
     */
    constructor(radioGroup, el) {
        this.radioGroup = radioGroup;
        this.el = el;
        /* radio 原生name 用于多个radio单选使用 */
        // get name() {
        // }
        this.name = '';
        /* 按钮类型 */
        this.type = 'secondary';
        /* radio 值 */
        this.label = '';
        this.modelChange = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /* radio 值 */
    /**
     * @return {?}
     */
    get model() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.model;
        }
        return this.nyModel;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this.nyModel = model;
    }
    /**
     * @return {?}
     */
    get farrisRadioButtonClass() { return true; }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.hasParent(this.el.nativeElement) ? this.radioGroup.name : '';
    }
    /**
     * @return {?}
     */
    isGroupModel() {
        return this.label === this.radioGroup.model;
    }
    /**
     * @return {?}
     */
    changeModelHandler() {
        // 父元素获取label  子元素再从父元素获取model
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.changeModel(this.label);
        }
        this.model = this.label;
        this.modelChange.emit(this.model);
        this.controlChange(this.label);
    }
    /* 是否存在父元素  存在即单选组*/
    /**
     * @param {?} element
     * @return {?}
     */
    hasParent(element) {
        return element.parentElement.classList.contains('farris-input-wrap') || element.parentElement.classList.contains('btn-group');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
RadioButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radio-button',
                template: `
    <label [class]="'btn btn-'+type" [class.active]="isGroupModel()" [class.disabled]="disabled">
        <input class="custom-control-input" [name]="name" [value]="label"
        [ngModel]="model" (ngModelChange)="changeModelHandler()" type="radio" [disabled]="disabled">
          <ng-content>
          </ng-content>
    </label>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => RadioButtonComponent)),
                        multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
                styles: [`
        .farris-radio-button>.btn{
            margin-left:-1px
          }
          .farris-radio-button>.btn.active, .farris-radio-button>.btn:hover{
            position: relative;
          }
      `]
            }] }
];
/** @nocollapse */
RadioButtonComponent.ctorParameters = () => [
    { type: RadioGroupComponent, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
RadioButtonComponent.propDecorators = {
    type: [{ type: Input }],
    model: [{ type: Input }],
    id: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }],
    modelChange: [{ type: Output }],
    farrisRadioButtonClass: [{ type: HostBinding, args: ['class.farris-radio-button',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisRadioGroupComponent {
    /**
     * @param {?} idSer
     * @param {?} inject
     */
    constructor(idSer, inject) {
        this.idSer = idSer;
        this.inject = inject;
        /* radio 数组 */
        this.data = [];
        this.textField = 'name';
        this.valueField = 'value';
        /**
         * 数据中标识禁用的字段名称，默认为 disabled
         */
        this.disabledField = 'disabled';
        /**
         * 列表中是否显示已禁用的项，默认 true
         */
        this.showDisabledItem = true;
        /* 点击事件 */
        this.changeValue = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
        if (this.inject) {
            this.commonUtils = this.inject.get(CommonUtils);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.idSer.generate().replace(/-/g, '_');
    }
    /**
     * @param {?} item
     * @return {?}
     */
    clickHandler(item) {
        /** @type {?} */
        let val = this._getValue(item);
        if (this.value == val)
            return;
        // 更改control的值
        this.value = val;
        this.controlChange(this.value);
        this.controlTouch(this.value);
        this.changeValue.emit(this.value);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getText(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.textField, item);
            }
            else {
                return item[this.textField];
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getValue(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.valueField, item);
            }
            else {
                return item[this.valueField];
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
FarrisRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radiogroup',
                template: "<div class=\"farris-input-wrap\" [class.farris-checkradio-hor]=\"horizontal\">\r\n    <div class=\"custom-control custom-radio\" *ngFor=\"let item of data; let i=index\"  [style.display]=\"item[disabledField] && !showDisabledItem ? 'none': ''\">\r\n        <input #input class=\"custom-control-input\" [name]=\"name\" id=\"{{'radio_'+name+i}}\" type=\"radio\"\r\n        [value]=\"_getValue(item)\" (click)=\"clickHandler(item)\" [checked]=\"_getValue(item) == value\" \r\n        [disabled]=\"disabled || item[disabledField]\" tabindex=\"{{tabIndex}}\">\r\n        <label class=\"custom-control-label\" for=\"{{'radio_'+name+i}}\">{{_getText(item)}}</label>\r\n    </div>\r\n</div>\r\n\r\n\r\n",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FarrisRadioGroupComponent)),
                        multi: true,
                    }],
                exportAs: 'FarrisRadioGroupComponent'
            }] }
];
/** @nocollapse */
FarrisRadioGroupComponent.ctorParameters = () => [
    { type: IdService },
    { type: Injector, decorators: [{ type: Optional }] }
];
FarrisRadioGroupComponent.propDecorators = {
    tabIndex: [{ type: Input, args: ['tab-index',] }],
    data: [{ type: Input }],
    type: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    disabledField: [{ type: Input }],
    showDisabledItem: [{ type: Input }],
    changeValue: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxGroupComponent {
    /**
     * @param {?} idSer
     */
    constructor(idSer) {
        this.idSer = idSer;
        /* 初始化 checkbox 的值 */
        this.model = [];
        /*  */
        this.modelChange = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.idSer.generate();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeModel(value) {
        /** @type {?} */
        const index = this.model.findIndex((/**
         * @param {?} ele
         * @return {?}
         */
        ele => {
            return ele === value;
        }));
        // 如果已经选中  则设置为不选中
        if (index > -1) {
            this.model.splice(index, 1);
            return this.modelChange.emit(this.model);
        }
        // 如果没有选中  设置为选中
        this.model.push(value);
        // control的值设置为逗号分隔的字符串  便于存储和传递
        this.controlChange(this.model.join());
        this.modelChange.emit(this.model);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
        this.changeModel(this.model);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
CheckboxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-checkbox-group',
                template: `
    <div class="farris-input-wrap" [class.farris-checkradio-hor]="horizontal">
      <ng-content></ng-content>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => CheckboxGroupComponent)),
                        multi: true,
                    }]
            }] }
];
/** @nocollapse */
CheckboxGroupComponent.ctorParameters = () => [
    { type: IdService }
];
CheckboxGroupComponent.propDecorators = {
    model: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    modelChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxComponent {
    /**
     * @param {?} checkbox
     * @param {?} el
     */
    constructor(checkbox, el) {
        this.checkbox = checkbox;
        this.el = el;
        this.modelChange = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /* radio 原生name 用于多个radio单选使用 */
    /**
     * @return {?}
     */
    get name() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.checkbox.name;
        }
        return '';
    }
    /* model */
    /**
     * @return {?}
     */
    get model() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.checkbox.model.find((/**
             * @param {?} ele
             * @return {?}
             */
            ele => {
                return ele === this.label;
            }));
        }
        return this.nyModel;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this.nyModel = model;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /* 值传递 */
    /**
     * @return {?}
     */
    changeModelHandler() {
        // 父元素获取label  子元素再从父元素获取model
        if (this.hasParent(this.el.nativeElement)) {
            return this.checkbox.changeModel(this.label);
        }
        this.model = this.label;
        this.modelChange.emit(this.model);
        this.controlChange(this.label);
    }
    /* 是否存在父元素  存在即单选组*/
    /**
     * @param {?} element
     * @return {?}
     */
    hasParent(element) {
        return element.parentElement.classList.contains('farris-input-wrap');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-checkbox',
                template: "<label class=\"custom-control custom-checkbox\">\r\n  <input class=\"custom-control-input\" [name]=\"name\" [value]=\"label\" [ngModel]=\"model\"\r\n    (ngModelChange)=\"changeModelHandler()\" type=\"checkbox\" [disabled]=\"disabled\">\r\n  <span class=\"custom-control-label\">\r\n    <ng-content>\r\n    </ng-content>\r\n  </span>\r\n</label>",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => CheckboxComponent)),
                        multi: true,
                    }],
                styles: ['./checkbox.component.css']
            }] }
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
    { type: CheckboxGroupComponent },
    { type: ElementRef }
];
CheckboxComponent.propDecorators = {
    model: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }],
    modelChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisCheckboxGroupComponent {
    /**
     * @param {?} idSer
     * @param {?} inject
     */
    constructor(idSer, inject) {
        this.idSer = idSer;
        this.inject = inject;
        this.tabIndex = 0;
        /* radio 数组 */
        this.data = [];
        /* 分隔符 默认逗号*/
        this.separator = ',';
        /* 值类型是否是string */
        this.isStringValue = true;
        this.textField = 'name';
        this.valueField = 'value';
        this.changeValue = new EventEmitter();
        /* checkbox赋值事件 */
        this.setCheckboxData = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
        if (this.inject) {
            this.commonUtils = this.inject.get(CommonUtils);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // 初始化name
        this.name = this.idSer.generate().replace(/-/g, '_');
        this.setCheckboxData.emit(this);
        // todo 取值可以实现promise
        if (this.loadData) {
            this.loadDataSubscription = this.loadData().subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => this.data = res.data));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.loadDataSubscription) {
            this.loadDataSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getText(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.textField, item);
            }
            else {
                return item[this.textField];
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getValue(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.valueField, item);
            }
            else {
                return item[this.valueField];
            }
        }
        else {
            return '';
        }
    }
    /* 选中input值 */
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    clickHandler(item, index) {
        /** @type {?} */
        let arrValue = this.transformToArr(this.value) || [];
        /** @type {?} */
        const val = String(this._getValue(item));
        if (!arrValue || !arrValue.length) {
            arrValue.push(val);
        }
        else {
            if (arrValue.some((/**
             * @param {?} item
             * @return {?}
             */
            item => item == val))) {
                arrValue = arrValue.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n !== val));
            }
            else {
                arrValue.push(val);
            }
        }
        // 更新value值
        this.value = this.transformToStr(arrValue);
        // 传值formcontrol
        this.controlChange(this.value);
        this.controlTouch(this.value);
        this.changeValue.emit(this.value);
    }
    /* 被选中 */
    /**
     * @param {?} item
     * @return {?}
     */
    checked(item) {
        /** @type {?} */
        const val = String(this._getValue(item));
        /** @type {?} */
        const checkedValue = this.transformToArr(this.value);
        // 多值
        return checkedValue.some((/**
         * @param {?} item
         * @return {?}
         */
        item => item == val));
    }
    /* 值到数组值的转换 */
    /**
     * @param {?} value
     * @return {?}
     */
    transformToArr(value) {
        if (!value) {
            return [];
        }
        if (!this.isStringValue) {
            return value;
        }
        return value.split(this.separator);
    }
    /* 值到字符串值的转换 */
    /**
     * @param {?} value
     * @return {?}
     */
    transformToStr(value) {
        /** @type {?} */
        const allVals = this.data.map((/**
         * @param {?} n
         * @return {?}
         */
        n => this._getValue(n)));
        /** @type {?} */
        const r = [];
        allVals.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (value.some((/**
             * @param {?} item
             * @return {?}
             */
            item => item == n))) {
                r.push(n);
            }
        }));
        if (!this.isStringValue) {
            return r;
        }
        return r.join(this.separator);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /* change操作值变化  方法重写*/
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /* blur值变化  方法重写*/
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
FarrisCheckboxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-checkboxgroup',
                template: "<div class=\"farris-input-wrap\" [class.farris-checkradio-hor]=\"horizontal\">\r\n    <div class=\"custom-control custom-checkbox\" *ngFor=\"let item of data; let i = index\">\r\n        <input #input class=\"custom-control-input\" [name]=\"name\" id=\"{{ 'checkbox_' + name + i }}\"\r\n            type=\"checkbox\" [value]=\"_getValue(item)\" [checked]=\"checked(item)\" [disabled]=\"disable\" (click)=\"clickHandler(item, i)\" \r\n            tabindex=\"{{ tabIndex + i }}\" />\r\n        <label class=\"custom-control-label\" for=\"{{ 'checkbox_' + name + i }}\" title=\"{{_getText(item)}}\">{{ _getText(item) }}</label>\r\n    </div>\r\n</div>\r\n",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FarrisCheckboxGroupComponent)),
                        multi: true,
                    }],
                exportAs: 'FarrisCheckboxGroupComponent'
            }] }
];
/** @nocollapse */
FarrisCheckboxGroupComponent.ctorParameters = () => [
    { type: IdService },
    { type: Injector, decorators: [{ type: Optional }] }
];
FarrisCheckboxGroupComponent.propDecorators = {
    tabIndex: [{ type: Input, args: ['tab-index',] }],
    data: [{ type: Input }],
    type: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    separator: [{ type: Input }],
    disable: [{ type: Input }],
    value: [{ type: Input }],
    isStringValue: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    loadData: [{ type: Input }],
    changeValue: [{ type: Output }],
    setCheckboxData: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaAutoSizeDirective {
    /**
     * @param {?} el
     * @param {?} ngControl
     * @param {?} injector
     */
    constructor(el, ngControl, injector) {
        this.el = el;
        this.ngControl = ngControl;
        this.injector = injector;
        this.enable = true;
        this.previousValue = null;
        this.isUserResized = false;
        this.textarea = this.el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.enable && !changes.enable.isFirstChange()) {
            this.sizeToFit();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.enable) {
            return;
        }
        if (this.maxHeight) {
            this.textarea.style.maxHeight = `${this.maxHeight}px`;
        }
        this.minHeight = this.textarea.getBoundingClientRect().height;
        if (this.minHeight) {
            this.textarea.style.minHeight = `${this.minHeight}px`;
        }
    }
    /**
     * @private
     * @return {?}
     */
    init() {
        if (this.enable) {
            this.document = this.textarea.ownerDocument;
            this.documentElement = this.document.documentElement;
            if (this.textarea) {
                if (this.textarea.value) {
                    this.sizeToFit();
                }
            }
            if (this.ngControl) {
                this.ngControl.valueChanges.subscribe((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => {
                    if (v !== this.previousValue) {
                        this.sizeToFit();
                    }
                }));
            }
        }
    }
    /**
     * @return {?}
     */
    onInput() {
        this.sizeToFit();
    }
    /**
     * @return {?}
     */
    onValueChange() {
        this.sizeToFit();
    }
    /**
     * @private
     * @return {?}
     */
    overflowOffset() {
        /** @type {?} */
        let offsetTop = 0;
        /** @type {?} */
        let el = this.textarea;
        while (el !== document.body && el !== null) {
            offsetTop += el.offsetTop || 0;
            el = el.offsetParent;
        }
        /** @type {?} */
        const top = offsetTop - document.defaultView.pageYOffset;
        /** @type {?} */
        const bottom = this.documentElement.clientHeight - (top + this.textarea.offsetHeight);
        return { top, bottom };
    }
    /**
     * @private
     * @return {?}
     */
    sizeToFit() {
        if (!this.enable) {
            return;
        }
        /** @type {?} */
        const textarea = this.textarea;
        if (this.isUserResized) {
            return;
        }
        if (this.textarea.value === this.previousValue) {
            return;
        }
        if (this.textarea.offsetWidth <= 0 && this.textarea.offsetHeight <= 0) {
            return;
        }
        // const { top, bottom } = this.overflowOffset();
        // if (top < 0 || bottom < 0) {
        //     return;
        // }
        /** @type {?} */
        const textareaStyle = getComputedStyle(textarea);
        /** @type {?} */
        const topBorderWidth = Number(textareaStyle.borderTopWidth.replace(/px/, ''));
        /** @type {?} */
        const bottomBorderWidth = Number(textareaStyle.borderBottomWidth.replace(/px/, ''));
        /** @type {?} */
        const isBorderBox = textareaStyle.boxSizing === 'border-box';
        /** @type {?} */
        const borderAddOn = isBorderBox ? topBorderWidth + bottomBorderWidth : 0;
        // const maxHeight = Number(textareaStyle.height.replace(/px/, '')) + bottom;
        // const adjustedViewportMarginBottom = bottom < viewportMarginBottom ? bottom : viewportMarginBottom;
        // textarea.style.maxHeight = `${maxHeight - adjustedViewportMarginBottom}px`;
        /** @type {?} */
        const container = textarea.parentElement;
        if (container instanceof HTMLElement) {
            /** @type {?} */
            const containerHeight = container.style.height;
            container.style.height = getComputedStyle(container).height;
            textarea.style.height = 'auto';
            /** @type {?} */
            let h = textarea.scrollHeight + borderAddOn;
            if (this.minHeight > h) {
                h = this.minHeight;
            }
            textarea.style.height = `${h}px`;
            container.style.height = containerHeight;
        }
        this.previousValue = textarea.value;
    }
}
TextareaAutoSizeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[auto-size]',
            },] }
];
/** @nocollapse */
TextareaAutoSizeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgControl },
    { type: Injector }
];
TextareaAutoSizeDirective.propDecorators = {
    enable: [{ type: Input, args: ['auto-size',] }],
    maxHeight: [{ type: Input }],
    onInput: [{ type: HostListener, args: ['input',] }],
    onValueChange: [{ type: HostListener, args: ['change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaWordcountDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} injector
     */
    constructor(el, render, injector) {
        this.el = el;
        this.render = render;
        this.injector = injector;
        this.useWordCount = true;
        /**
         * 统计字数的方式； surplus 剩余可输入字数; length: 当前已输入字数；
         *
         * 默认为 surplus
         */
        this.countType = 'surplus';
        this.onlyShowInDialog = false;
        this.wordCountElement = null;
        // 当前字数
        this.currentLengthElement = null;
        this.onInput = null;
        this.ro = null;
        this.eventManager = this.injector.get(EventManager);
        this.localeSer = this.injector.get(LocaleService);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngControl = this.injector.get(NgControl, null);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initWordCount();
        if (this.ngControl && this.useWordCount) {
            this.ngControl.control.valueChanges.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.updateWordsCount();
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useWordCount && !changes.useWordCount.isFirstChange()) {
            if (this.useWordCount) {
                this.initWordCount();
            }
            else {
                this.destroy();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
        if (this.ro) {
            this.ro.disconnect();
            this.ro.unobserve(this.el.nativeElement.parentElement);
        }
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        if (this.onInput) {
            this.onInput();
        }
        if (this.wordCountElement) {
            this.wordCountElement.remove();
        }
    }
    /**
     * @return {?}
     */
    initWordCount() {
        if (this.useWordCount && !this.onlyShowInDialog) {
            this.createWordCountElement();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createWordCountID() {
        /** @type {?} */
        const tagName = this.el.nativeElement.tagName;
        if (this.ngControl) {
            /** @type {?} */
            const ctrlName = this.ngControl.name;
            return `${tagName}_WORDCOUNT_${ctrlName}`;
        }
        else {
            if (this.el.nativeElement.id) {
                return `${tagName}_WORDCOUNT_${this.el.nativeElement.id}`;
            }
        }
        return '';
    }
    /**
     * @private
     * @return {?}
     */
    createWordCountElement() {
        /** @type {?} */
        const max = this.el.nativeElement.maxLength;
        if (!max || max < 0) {
            // console.info('未设置最大字符数，计数功能失效。');
            return;
        }
        /** @type {?} */
        const wordCountSPAN = this.render.createElement('span');
        wordCountSPAN.className = 'textarea-wordcount';
        /** @type {?} */
        const id = this.createWordCountID();
        if (id) {
            wordCountSPAN.id = id;
        }
        this.render.setStyle(wordCountSPAN, 'position', 'absolute');
        this.render.setStyle(wordCountSPAN, 'bottom', '0px');
        const { width, right } = this.el.nativeElement.getBoundingClientRect();
        const { width: parentWidth } = this.el.nativeElement.parentElement.getBoundingClientRect();
        if (parentWidth !== width) {
            this.render.setStyle(wordCountSPAN, 'right', `${parentWidth - width + 10}px`);
            this.ro = new ResizeObserver((/**
             * @param {?} entries
             * @param {?} observer
             * @return {?}
             */
            (entries, observer) => {
                if (entries && entries[0]) {
                    /** @type {?} */
                    const _pw = entries[0].contentRect.width;
                    this.render.setStyle(wordCountSPAN, 'right', `${_pw - width + 10}px`);
                }
            }));
            this.ro.observe(this.el.nativeElement.parentElement);
        }
        else {
            this.render.setStyle(wordCountSPAN, 'right', '10px');
        }
        this.render.setStyle(wordCountSPAN, 'cursor', 'pointer');
        this.el.nativeElement.after(wordCountSPAN);
        this.wordCountElement = wordCountSPAN;
        /** @type {?} */
        const currentLengthSPAN = this.render.createElement('span');
        wordCountSPAN.appendChild(currentLengthSPAN);
        this.currentLengthElement = currentLengthSPAN;
        currentLengthSPAN.after(` / ${max}`);
        this.updateWordsCount();
        this.onInput = this.render.listen(this.el.nativeElement, 'input', (/**
         * @return {?}
         */
        () => {
            // value.replace(/\n|\r/gi, '') // 移除换行符
            this.updateWordsCount();
        }));
    }
    /**
     * @return {?}
     */
    updateWordsCount() {
        if (!this.useWordCount || !this.currentLengthElement) {
            return;
        }
        /** @type {?} */
        const max = this.el.nativeElement.maxLength;
        /** @type {?} */
        const val = this.countType === 'surplus' ? max - this.el.nativeElement.value.length : this.el.nativeElement.value.length;
        /** @type {?} */
        const tip = 'messager.prompt.tips.' + this.countType;
        this.currentLengthElement.innerText = val;
        this.wordCountElement.title = this.localeSer.getValue(tip).replace('{0}', val);
    }
}
TextareaWordcountDirective.decorators = [
    { type: Directive, args: [{
                selector: '[word-count]',
                exportAs: 'WordCountRef'
            },] }
];
/** @nocollapse */
TextareaWordcountDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector }
];
TextareaWordcountDirective.propDecorators = {
    useWordCount: [{ type: Input, args: ['word-count',] }],
    countType: [{ type: Input }],
    onlyShowInDialog: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaZoomDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} injector
     * @param {?} wordCountRef
     */
    constructor(el, render, injector, wordCountRef) {
        this.el = el;
        this.render = render;
        this.injector = injector;
        this.wordCountRef = wordCountRef;
        this.useZoom = true;
        this.dialogWidth = 500;
        this.dialogHeight = 400;
        this.fullscreen = false;
        this.title = '';
        this.value = '';
        this.onMouseEnter = null;
        this.onMouseLeave = null;
        this.onClick = null;
        this.altEnterHandler = null;
        this.zoomButtonElement = null;
        this.messagerService = this.injector.get(MessagerService);
        this.eventManager = this.injector.get(EventManager);
        this.localeSer = this.injector.get(LocaleService, null);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngControl = this.injector.get(NgControl, null);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useZoom && !changes.useZoom.isFirstChange()) {
            if (this.useZoom) {
                this.createZoomButton();
            }
            else {
                this.destroy();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.useZoom) {
            this.createZoomButton();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        if (this.onMouseEnter) {
            this.onMouseEnter();
        }
        if (this.onMouseLeave) {
            this.onMouseLeave();
        }
        if (this.onClick) {
            this.onClick();
        }
        if (this.altEnterHandler) {
            this.altEnterHandler();
        }
        if (this.zoomButtonElement) {
            this.zoomButtonElement.remove();
        }
    }
    /**
     * @private
     * @return {?}
     */
    bindEventHandler() {
        this.altEnterHandler = this.eventManager.addEventListener(this.el.nativeElement, 'keydown.alt.enter', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const target = ((/** @type {?} */ (event.target)));
            /** @type {?} */
            const val = target.value + '\n';
            target.value = val;
            event.preventDefault();
            event.stopPropagation();
            return false;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    createZoombarID() {
        /** @type {?} */
        const tagName = this.el.nativeElement.tagName;
        if (this.ngControl) {
            /** @type {?} */
            const ctrlName = this.ngControl.name;
            return `${tagName}_ZOOMBAR_${ctrlName}`;
        }
        else {
            if (this.el.nativeElement.id) {
                return `${tagName}_ZOOMBAR_${this.el.nativeElement.id}`;
            }
        }
        return '';
    }
    /**
     * @private
     * @return {?}
     */
    createZoomButton() {
        /** @type {?} */
        const zoomSPAN = this.render.createElement('span');
        zoomSPAN.className = 'f-icon modal_maximize textarea-zoom';
        zoomSPAN.title = this.localeSer.getValue('text.zoom') || '点击后弹出进行编辑';
        /** @type {?} */
        const id = this.createZoombarID();
        if (id) {
            zoomSPAN.id = id;
        }
        this.render.setStyle(zoomSPAN, 'position', 'absolute');
        this.render.setStyle(zoomSPAN, 'top', '2px');
        const { width } = this.el.nativeElement.getBoundingClientRect();
        const { width: parentWidth } = this.el.nativeElement.parentElement.getBoundingClientRect();
        if (parentWidth !== width) {
            this.render.setStyle(zoomSPAN, 'left', `${width - 18}px`);
        }
        else {
            this.render.setStyle(zoomSPAN, 'right', '2px');
        }
        this.render.setStyle(zoomSPAN, 'cursor', 'pointer');
        this.el.nativeElement.after(zoomSPAN);
        this.zoomButtonElement = zoomSPAN;
        this.onMouseEnter = this.render.listen(zoomSPAN, 'mouseenter', (/**
         * @return {?}
         */
        () => {
            this.render.setStyle(zoomSPAN, 'fontSize', '22px');
        }));
        this.onMouseLeave = this.render.listen(zoomSPAN, 'mouseleave', (/**
         * @return {?}
         */
        () => {
            this.render.setStyle(zoomSPAN, 'fontSize', '1rem');
        }));
        this.onClick = this.render.listen(zoomSPAN, 'click', (/**
         * @return {?}
         */
        () => {
            this.zoomTextarea();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    zoomTextarea() {
        /** @type {?} */
        const opts = {
            width: this.dialogWidth || 500,
            height: this.dialogHeight || 400,
            showFontSize: true,
            inputType: 'textarea',
            saveSize: true // 启用个性化存储，localStorage
        };
        if (window.localStorage) {
            /** @type {?} */
            const key = this.messagerService.getKeyString();
            /** @type {?} */
            const val = localStorage.getItem(key);
            if (val) {
                /** @type {?} */
                const lastSetting = JSON.parse(val);
                opts.fontSize = lastSetting.fontSize || 18;
                opts.width = lastSetting.width || opts.width;
                opts.height = lastSetting.height || opts.height;
            }
        }
        /** @type {?} */
        const tagName = this.el.nativeElement.tagName;
        /** @type {?} */
        let showText = this.el.nativeElement.value;
        if (this.ngControl) {
            showText = this.ngControl.value;
        }
        else {
            showText = this.el.nativeElement.value;
        }
        showText = this.value || showText;
        if (tagName === 'FARRIS-TEXT' || this.el.nativeElement.readOnly || this.el.nativeElement.disabled) {
            opts.readonly = true;
            opts.showOkButton = false;
            this.messagerService.prompt2(this.title, showText, opts).subscribe();
        }
        else {
            opts.maxLength = this.el.nativeElement.maxLength;
            opts.enableWordCount = this.wordCountRef ? this.wordCountRef.useWordCount : false;
            opts.countType = this.wordCountRef ? this.wordCountRef.countType : 'length';
            this.messagerService.prompt2(this.title, showText, opts).subscribe((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                if (typeof v === 'boolean' && !v) {
                    return;
                }
                else {
                    this.ngControl.control.setValue(v);
                    if (this.wordCountRef) {
                        this.wordCountRef.updateWordsCount();
                    }
                }
            }));
        }
    }
}
TextareaZoomDirective.decorators = [
    { type: Directive, args: [{
                selector: '[textarea-zoom]',
            },] }
];
/** @nocollapse */
TextareaZoomDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector },
    { type: TextareaWordcountDirective, decorators: [{ type: Optional }] }
];
TextareaZoomDirective.propDecorators = {
    useZoom: [{ type: Input, args: ['textarea-zoom',] }],
    dialogWidth: [{ type: Input }],
    dialogHeight: [{ type: Input }],
    fullscreen: [{ type: Input }],
    title: [{ type: Input }],
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputAppendDirective {
    // private ngControl: NgControl;
    /**
     * @param {?} viewRef
     * @param {?} el
     * @param {?} render
     * @param {?} injector
     */
    constructor(viewRef, el, render, injector) {
        this.viewRef = viewRef;
        this.el = el;
        this.render = render;
        this.injector = injector;
        this._enableAppend = true;
        // 应用场景，默认这个功能是在简单表格 Table
        // 追加一个场景在普通表单上 Form
        this._appendScene = 'Table';
        // 追加到哪个类型下 TextBox、MultiTextBox、 StaticText
        this.inputAppendControlType = 'InputGroup';
        // 根据类型不一样，在控件处于禁用、只读时，决定颜色是否可用
        // 有两种：按钮 button 文本 text
        this._appendType = 'button';
        // 追加的文本
        this._inputAppendText = '';
        // 模板
        // @Input() inputAppendTmpl: TemplateRef<any>;
        this._disabled = false;
        // 当_appendCls为空时，
        this._appendCls = 'input-group-text';
        /*
            * 文本点击事件
            */
        this.inputAppendClickEvent = new EventEmitter();
        // 标记native的外层
        this.elWrapElement = null;
        // 标记元素
        this.appendWrapElement = null;
        // 暂时不用
        this.appendTextElement = null;
        this.clickHandler = null;
        this.disabledCls = 'f-state-disabled';
        this.ngZone = null;
        this.ngZone = this.injector.get(NgZone);
    }
    // 相当于启用禁用此功能
    /**
     * @param {?} value
     * @return {?}
     */
    set enableAppend(value) {
        if (value === '' || value) {
            this._enableAppend = true;
            // 需要
            if (!this.appendWrapElement) {
                this.createStruct();
            }
        }
        else {
            this._enableAppend = false;
            if (this.appendWrapElement) {
                this.resetStruct();
            }
        }
    }
    /**
     * @return {?}
     */
    get enableAppend() {
        return this._enableAppend;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set inputAppendScene(val) {
        // 支持这两个场景
        val = val == 'Form' ? 'Form' : 'Table';
        if (val != this._appendScene) {
            switch (this.inputAppendControlType) {
                case 'StaticText':
                    this.render.removeClass(this.el.nativeElement, 'f-cmp-input-append-' + this._appendScene.toLowerCase());
                    this.render.addClass(this.el.nativeElement, 'f-cmp-input-append-' + val.toLowerCase());
                    break;
                case 'TextBox':
                case 'MultiTextBox':
                    if (this.elWrapElement) {
                        this.elWrapElement.className = this.elWrapElement.className.replace('f-cmp-input-append-' + this._appendScene.toLowerCase(), 'f-cmp-input-append-' + val.toLowerCase());
                    }
                    break;
            }
            this._appendScene = val;
            this.modifyPaddingRight();
        }
    }
    /**
     * @return {?}
     */
    get inputAppendScene() {
        return this._appendScene;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inputAppendType(value) {
        if (value) {
            if (['button', 'text'].findIndex((/**
             * @param {?} item
             * @return {?}
             */
            item => item == value)) < 0) {
                // 类型在支持范围内
                value = 'button';
            }
            if (value != this._appendType) {
                if (this.appendWrapElement) {
                    // 移除原来，追加新的
                    this.render.removeClass(this.appendWrapElement, 'input-append-' + this._appendType);
                    this.render.addClass(this.appendWrapElement, 'input-append-' + value);
                    if (this._appendType == 'button') {
                        // 原来是按钮
                        if (this.clickHandler) {
                            this.clickHandler();
                            this.clickHandler = null;
                        }
                    }
                    else {
                        this.clickHandler = this.render.listen(this.appendWrapElement, 'click', (/**
                         * @param {?} ev
                         * @return {?}
                         */
                        (ev) => {
                            this.inputAppendClickEvent.emit(ev);
                        }));
                    }
                }
                this._appendType = value;
                this.modifyPaddingRight();
            }
        }
    }
    /**
     * @return {?}
     */
    get inputAppendType() {
        return this._appendType;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inputAppendText(value) {
        if (value != this._inputAppendText) {
            this._inputAppendText = value;
            if (this.appendWrapElement && this._enableAppend) {
                this.render.removeChild(this.appendWrapElement, this.appendTextElement);
                this.appendTextElement.innerHTML = value;
                this.render.appendChild(this.appendWrapElement, this.appendTextElement);
                this.modifyPaddingRight();
            }
            else {
                this.createStruct();
            }
        }
    }
    /**
     * @return {?}
     */
    get inputAppendText() {
        return this._inputAppendText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inputAppendDisabled(value) {
        if (value != this._disabled) {
            this._disabled = value;
            if (this.appendWrapElement) {
                value && this.render.addClass(this.appendWrapElement, this.disabledCls);
                !value && this.render.removeClass(this.appendWrapElement, this.disabledCls);
            }
            this.modifyPaddingRight();
        }
    }
    /**
     * @return {?}
     */
    get inputAppendDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set inputAppendCls(val) {
        if (val != this._appendCls) {
            val = val ? val : 'input-group-text';
            if (this.appendTextElement) {
                this.appendTextElement.className = val;
            }
            this._appendCls = val;
        }
    }
    /**
     * @return {?}
     */
    get inputAppendCls() {
        return this._appendCls;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        //this.ngControl = this.injector.get(NgControl, null);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.createStruct();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        //this.resetStruct();
        if (this.clickHandler) {
            this.clickHandler();
            this.clickHandler = null;
        }
        if (this.appendWrapElement) {
            this.appendWrapElement.remove();
            this.appendWrapElement = null;
        }
        if (this.elWrapElement) {
            this.elWrapElement.remove();
            this.elWrapElement = null;
        }
    }
    /**
     * 重置
     * @private
     * @return {?}
     */
    resetStruct() {
        if (this.clickHandler) {
            this.clickHandler();
            this.clickHandler = null;
        }
        // 分类型移除不同新增加的结构或样式
        switch (this.inputAppendControlType) {
            case 'StaticText':
                this.render.removeClass(this.el.nativeElement, 'f-cmp-static-text-input-append');
                this.render.removeClass(this.el.nativeElement, 'f-cmp-input-append-' + this.inputAppendScene.toLowerCase());
                break;
            case 'TextBox':
            case 'MultiTextBox':
                if (this.elWrapElement) {
                    /** @type {?} */
                    let wrapParent = this.render.parentNode(this.elWrapElement);
                    this.render.appendChild(wrapParent, this.el.nativeElement);
                    this.elWrapElement.remove();
                    this.elWrapElement = null;
                }
                break;
        }
        if (this.appendWrapElement) {
            this.appendWrapElement.remove();
            this.appendWrapElement = null;
        }
        this.modifyPaddingRight();
    }
    /**
     * 创建插入结构
     * @private
     * @return {?}
     */
    createStruct() {
        if (!this.inputAppendText || !this.enableAppend || this.appendWrapElement) {
            return;
        }
        /** @type {?} */
        const buttonWrap = this.render.createElement('div');
        buttonWrap.className = 'input-group-append input-append-wrapper';
        buttonWrap.className += ' input-append-' + this.inputAppendType;
        if (this._disabled) {
            buttonWrap.className += ' ' + this.disabledCls;
        }
        /** @type {?} */
        const buttonTextWrap = this.render.createElement('div');
        buttonTextWrap.className = this.inputAppendCls;
        buttonTextWrap.innerHTML = this.inputAppendText;
        this.appendTextElement = buttonTextWrap;
        this.appendWrapElement = buttonWrap;
        this.render.appendChild(buttonWrap, buttonTextWrap);
        switch (this.inputAppendControlType) {
            case 'StaticText':
                // 此时还没有生成内部的样式
                // let textareaEl = this.el.nativeElement.querySelector('.f-form-control-textarea');
                /** @type {?} */
                let clsNames = 'f-cmp-static-text-input-append' + (' f-cmp-input-append-' + this.inputAppendScene.toLowerCase()) + (this._disabled ? ' ' + this.disabledCls : '');
                clsNames.split(' ').map((/**
                 * @param {?} tclsName
                 * @return {?}
                 */
                (tclsName) => {
                    this.render.addClass(this.el.nativeElement, tclsName);
                }));
                this.render.appendChild(this.el.nativeElement, buttonWrap);
                break;
            case 'TextBox':
            case 'MultiTextBox':
                /** @type {?} */
                let textParent = this.render.parentNode(this.el.nativeElement);
                /** @type {?} */
                const inputWrap = this.render.createElement('div');
                inputWrap.className = 'f-cmp-text-input-append f-cmp-input-append-' + this.inputAppendScene.toLowerCase() + (this._disabled ? ' ' + this.disabledCls : '');
                if (this.el.nativeElement.outerHTML.indexOf('textarea') > -1) {
                    inputWrap.className = 'f-cmp-textarea-input-append f-cmp-input-append-' + this.inputAppendScene.toLowerCase() + (this._disabled ? ' ' + this.disabledCls : '');
                }
                this.elWrapElement = inputWrap;
                this.render.appendChild(inputWrap, this.el.nativeElement);
                this.render.appendChild(inputWrap, buttonWrap);
                this.render.appendChild(textParent, inputWrap);
                break;
            default:
                // 存在类似下拉这样的控件，内部调用input-group结构还没有初始化
                /** @type {?} */
                let inputGroupEl = this.el.nativeElement.querySelector('.input-group');
                if (inputGroupEl) {
                    this.render.appendChild(inputGroupEl, buttonWrap);
                }
                else {
                    if (this.ngZone) {
                        this.ngZone.runOutsideAngular((/**
                         * @return {?}
                         */
                        () => {
                            setTimeout((/**
                             * @return {?}
                             */
                            () => {
                                /** @type {?} */
                                let inputGroupEl2 = this.el.nativeElement.querySelector('.input-group');
                                this.render.appendChild(inputGroupEl2, buttonWrap);
                            }));
                        }));
                    }
                }
        }
        if (this.inputAppendType == 'button') {
            this.clickHandler = this.render.listen(this.appendWrapElement, 'click', (/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => {
                if (!this.inputAppendDisabled) {
                    this.inputAppendClickEvent.emit(ev);
                }
            }));
        }
        this.modifyPaddingRight();
    }
    /**
     * 因为在普通输入框、静态文本、多行文本框展示时，界面样式问题。
     * 所以需要单独处理，通过absolute定位，设置间距，保持界面一致
     * @private
     * @return {?}
     */
    modifyPaddingRight() {
        /** @type {?} */
        let findType = ['StaticText', 'TextBox', 'MultiTextBox'].find((/**
         * @param {?} typeItem
         * @return {?}
         */
        typeItem => typeItem == this.inputAppendControlType));
        if (this.inputAppendScene == 'Form' && findType) {
            /** @type {?} */
            let changeEl = findType == 'StaticText' ? this.el.nativeElement.querySelector('span') : this.el.nativeElement;
            if (this.enableAppend && !this._disabled && this.appendWrapElement) {
                //window.getComputhis.appendWrapElement
                /** @type {?} */
                const tRectObj = this.appendWrapElement.getBoundingClientRect();
                this.render.setStyle(changeEl, 'paddingRight', tRectObj.width + 'px');
            }
            else {
                this.render.removeStyle(changeEl, 'paddingRight');
            }
        }
    }
}
InputAppendDirective.decorators = [
    { type: Directive, args: [{
                selector: '[input-append]',
            },] }
];
/** @nocollapse */
InputAppendDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector }
];
InputAppendDirective.propDecorators = {
    enableAppend: [{ type: Input, args: ['input-append',] }],
    inputAppendScene: [{ type: Input }],
    inputAppendControlType: [{ type: Input }],
    inputAppendType: [{ type: Input }],
    inputAppendText: [{ type: Input }],
    inputAppendDisabled: [{ type: Input }],
    inputAppendCls: [{ type: Input }],
    inputAppendClickEvent: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShortCutTabKeyDirective {
    /**
     * @param {?} el
     * @param {?} injector
     * @param {?} eventManager
     */
    constructor(el, injector, eventManager) {
        this.el = el;
        this.injector = injector;
        this.eventManager = eventManager;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.eventManager.addEventListener(this.el.nativeElement, 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            e.stopPropagation();
            if (e.key === 'Tab') {
                this.onTabKeydownHandler(e.target);
            }
        }));
    }
    /**
     * @private
     * @param {?} currentTarget
     * @return {?}
     */
    onTabKeydownHandler(currentTarget) {
        /** @type {?} */
        let allInputs = this.el.nativeElement.querySelectorAll('input,textarea');
        allInputs = Array.from(allInputs);
        /** @type {?} */
        const currentInputIndex = allInputs.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => n === currentTarget));
        /** @type {?} */
        let nextInputIndex = currentInputIndex + 1;
        if (nextInputIndex >= allInputs.length) {
            nextInputIndex = 0;
        }
        /** @type {?} */
        const nextInputTarget = allInputs[nextInputIndex];
        if (nextInputTarget) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                nextInputTarget.focus();
            }));
        }
    }
}
ShortCutTabKeyDirective.decorators = [
    { type: Directive, args: [{
                selector: 'shortcut-tab',
            },] }
];
/** @nocollapse */
ShortCutTabKeyDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector },
    { type: EventManager }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CommentsHttpToken = new InjectionToken('Common comments HTTP service');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SingleListComponent {
    /**
     * @param {?} injector
     * @param {?} cdr
     */
    constructor(injector, cdr) {
        this.injector = injector;
        this.cdr = cdr;
        this.showButtons = true;
        this.buttons = [];
        this.data = [];
        this.textField = '';
        this.maxItems = 10;
        this.emptyDataMsg = '暂无数据';
        this.itemClick = new EventEmitter();
        this.activeIndex = -1;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClick($event) {
        $event.stopPropagation();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} items
     * @return {?}
     */
    loadData(items) {
        this.data = items;
        if (!this.cdr['destroyed']) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @param {?} rowObj
     * @return {?}
     */
    formatData(rowObj) {
        return this.formatter(rowObj);
    }
    /**
     * @param {?} $event
     * @param {?} item
     * @return {?}
     */
    onItemClick($event, item) {
        this.itemClick.emit({ data: item, evnet: $event });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    setActiveItem(index) {
        this.activeIndex = index;
        if (!this.cdr['destroyed']) {
            this.cdr.detectChanges();
        }
    }
}
SingleListComponent.decorators = [
    { type: Component, args: [{
                selector: 'single-list',
                template: "<div class=\"d-flex flex-column\" style=\"width: 100%;height:100%;padding-top: 5px; \" #itemsContainer>\r\n    <!-- <div class=\"header\"></div> -->\r\n    <div class=\"list f-utils-fill f-datalist\" style=\"overflow: auto;flex:1;  max-height: 250px;\">\r\n        <ul class=\"list-group list-group-flush p-0\"  [class.h-100]=\"!data || !data.length\">\r\n            <li class=\"list-group-item list-group-item-action\" style=\"cursor: pointer;\" [class.active]=\"activeIndex === i\" *ngFor=\"let item of data; index as i\" (click)=\"onItemClick($event, item)\">\r\n                <span style=\"overflow: hidden;text-overflow: ellipsis;\" title=\" {{item[textField]}}\" *ngIf=\"!formatter\">{{ item[textField] }}</span> \r\n                <span style=\"overflow: hidden;text-overflow: ellipsis;\" *ngIf=\"formatter\" [innerHTML]=\"formatData(item) | safe:'html'\"></span>\r\n            </li>\r\n\r\n            <li class=\"norecord p-2\" *ngIf=\"!data || !data.length\" style=\"color: #848c9a;\">\r\n                {{ emptyDataMsg }}\r\n            </li>\r\n        </ul>\r\n    </div>\r\n    <div class=\"more d-flex\" *ngIf=\"showButtons\" style=\"height: 36px;border-top: 1px solid #dedede;justify-content: center;align-items: center;\">\r\n        <button class=\"btn btn-link\" *ngFor=\"let btn of buttons\" (click)=\"btn.handler($event)\"> \r\n            <span style=\"font-size: 13px;\" class=\"{{btn.iconCls}}\" *ngIf=\"btn.iconCls\"></span>\r\n            {{ btn.text }}\r\n        </button>\r\n    </div>\r\n     <!-- <div class=\"footer\"></div> -->\r\n</div>"
            }] }
];
/** @nocollapse */
SingleListComponent.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef }
];
SingleListComponent.propDecorators = {
    showButtons: [{ type: Input }],
    buttons: [{ type: Input }],
    data: [{ type: Input }],
    textField: [{ type: Input }],
    formatter: [{ type: Input }],
    maxItems: [{ type: Input }],
    emptyDataMsg: [{ type: Input }],
    itemClick: [{ type: Output }],
    itemsContainer: [{ type: ViewChild, args: ['itemsContainer',] }],
    onClick: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaCommentsDirective {
    /**
     * @param {?} injector
     * @param {?} el
     * @param {?} render
     * @param {?} localeSer
     * @param {?} cfr
     */
    constructor(injector, el, render, localeSer, cfr) {
        this.injector = injector;
        this.el = el;
        this.render = render;
        this.localeSer = localeSer;
        this.cfr = cfr;
        this.useComments = true;
        this.maxHeight = 300;
        this.title = '';
        this.mgrText = '';
        this.commentsBtnElement = null;
        this.singListRef = null;
        this.listPanelElRef = null;
        this.commentSer = this.injector.get(CommentsHttpToken, null);
        this.overlaySer = this.injector.get(OverLayHiddenService, null);
        this.commonUtil = this.injector.get(CommonUtils, null);
        if (!this.overlaySer) {
            this.overlaySer = new OverLayHiddenService();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngControl = this.injector.get(NgControl, null);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.init();
        this.listenAttributesChanged();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useComments && !changes.useComments.isFirstChange()) {
            this.init();
        }
    }
    /**
     * @private
     * @return {?}
     */
    init() {
        /** @type {?} */
        const readonly = this.el.nativeElement.readOnly;
        /** @type {?} */
        const disabled = this.el.nativeElement.disabled;
        if (this.useComments && (!readonly && !disabled)) {
            this.createCommentsButton();
        }
        else {
            this.destroy();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
        this.hideListPanel();
        // 停止观察属性变化
        this.observer.disconnect();
        this.observer = null;
    }
    /**
     * @return {?}
     */
    listenAttributesChanged() {
        // 选择需要观察变动的节点
        /** @type {?} */
        const targetNode = this.el.nativeElement;
        // 观察器的配置（需要观察什么变动）
        /** @type {?} */
        const config = { attributes: true };
        // 当观察到变动时执行的回调函数
        /** @type {?} */
        const callback = (/**
         * @param {?} mutationsList
         * @param {?} observer
         * @return {?}
         */
        (mutationsList, observer) => {
            // Use traditional 'for loops' for IE 11
            for (let mutation of mutationsList) {
                if (mutation.type === 'attributes' && (mutation.attributeName === 'readonly' || mutation.attributeName === 'disabled')) {
                    this.init();
                }
            }
        });
        // 创建一个观察器实例并传入回调函数
        this.observer = new MutationObserver(callback);
        // 以上述配置开始观察目标节点
        this.observer.observe(targetNode, config);
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.commentsBtnElement) {
            this.commentsBtnElement.remove();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createID() {
        /** @type {?} */
        const tagName = this.el.nativeElement.tagName;
        if (this.ngControl) {
            /** @type {?} */
            const ctrlName = this.ngControl.name;
            return `${tagName}_COMMENTS_${ctrlName}`;
        }
        else {
            if (this.el.nativeElement.id) {
                return `${tagName}_COMMENTS_${this.el.nativeElement.id}`;
            }
        }
        return '';
    }
    /**
     * @private
     * @return {?}
     */
    createCommentsButton() {
        /** @type {?} */
        const commentsBtn = this.render.createElement('span');
        commentsBtn.className = 'dropdown-toggle';
        commentsBtn.title = this.title ? this.title : (this.localeSer.getValue('text.comments.title') || '常用意见');
        /** @type {?} */
        const id = this.createID();
        if (id) {
            commentsBtn.id = id;
        }
        this.render.setStyle(commentsBtn, 'position', 'absolute');
        this.render.setStyle(commentsBtn, 'left', '3px');
        this.render.setStyle(commentsBtn, 'bottom', '0px');
        this.render.setStyle(commentsBtn, 'cursor', 'pointer');
        /** @type {?} */
        const icon = this.render.createElement('span');
        this.render.appendChild(commentsBtn, icon);
        icon.className = 'f-icon f-icon-message';
        this.render.setStyle(icon, 'position', 'relative');
        // this.render.setStyle(icon, 'margin-right', '3px');
        this.render.setStyle(icon, 'top', '1px');
        this.render.setStyle(icon, 'font-size', '13px');
        this.el.nativeElement.after(commentsBtn);
        this.commentsBtnElement = commentsBtn;
        this.render.listen(commentsBtn, 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            e.stopPropagation();
            if (!this.listPanelElRef) {
                this.showListPanel();
            }
            else {
                this.hideListPanel();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    showListPanel() {
        /** @type {?} */
        const listPanelEl = this.render.createElement('div');
        /** @type {?} */
        const zindex = this.commonUtil.getFloatingLayerIndex();
        const { left, bottom } = this.commentsBtnElement.getBoundingClientRect();
        this.render.setStyle(listPanelEl, 'width', '200px');
        this.render.setStyle(listPanelEl, 'max-height', `${this.maxHeight}px`);
        this.render.setStyle(listPanelEl, 'position', 'absolute');
        this.render.setStyle(listPanelEl, 'left', `${left}px`);
        this.render.setStyle(listPanelEl, 'top', '0px');
        this.render.setStyle(listPanelEl, 'z-index', zindex);
        this.render.setStyle(listPanelEl, 'box-shadow', '0 2px 8px 0 #dedede');
        this.render.setStyle(listPanelEl, 'border-radius', '6px');
        this.render.setStyle(listPanelEl, 'background', 'white');
        this.render.setStyle(listPanelEl, 'visibility', 'hidden');
        document.body.append(listPanelEl);
        this.listPanelElRef = listPanelEl;
        /** @type {?} */
        const singListCmf = this.cfr.resolveComponentFactory(SingleListComponent);
        this.singListRef = singListCmf.create(this.injector);
        this.singListRef.instance.showButtons = true;
        this.singListRef.instance.emptyDataMsg = this.localeSer.getValue('text.comments.empty');
        this.singListRef.instance.buttons = [
            {
                text: this.mgrText ? this.mgrText : this.localeSer.getValue('text.comments.manager'),
                iconCls: 'f-icon f-icon-home-setup', handler: (/**
                 * @return {?}
                 */
                () => {
                    if (this.commentSer) {
                        this.hideListPanel();
                        this.commentSer.showCommentManageDialog({ type: 'forms' }).subscribe((/**
                         * @param {?} e
                         * @return {?}
                         */
                        (e) => {
                            console.log(e);
                        }));
                    }
                })
            }
        ];
        this.singListRef.instance.textField = 'message';
        this.singListRef.instance.maxItems = 999999;
        this.singListRef.instance.itemClick.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            /** @type {?} */
            const val = e.data['message'];
            /** @type {?} */
            let _text = this.el.nativeElement.value || '';
            _text += val;
            if (this.ngControl) {
                this.ngControl.control.patchValue(_text);
            }
            else {
                this.el.nativeElement.value = _text;
            }
            this.hideListPanel();
        }));
        listPanelEl.appendChild(this.singListRef.location.nativeElement);
        this.singListRef.changeDetectorRef.detectChanges();
        this.loadData(this.singListRef);
        this.overlaySer.registerMouseEvent(listPanelEl, (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (this.listPanelElRef.contains(e.target) || this.commentsBtnElement === e.target || this.commentsBtnElement.contains(e.target)) {
                return;
            }
            this.hideListPanel();
        }));
    }
    /**
     * @return {?}
     */
    hideListPanel() {
        if (this.singListRef) {
            this.singListRef.destroy();
            this.singListRef = null;
        }
        if (this.listPanelElRef) {
            this.listPanelElRef.remove();
            this.overlaySer.destory(this.listPanelElRef);
            this.listPanelElRef = null;
        }
    }
    /**
     * @private
     * @param {?} singListRef
     * @return {?}
     */
    loadData(singListRef) {
        if (this.commentSer) {
            this.commentSer.getCommonComments({ type: 'forms' }).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                singListRef.instance.loadData(data);
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.resetPosition();
                }));
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetPosition() {
        const { top, bottom, left } = this.commentsBtnElement.getBoundingClientRect();
        /** @type {?} */
        const panelHeight = this.listPanelElRef.offsetHeight;
        if (window.innerHeight - bottom > this.maxHeight || window.innerHeight - bottom > panelHeight) {
            this.render.setStyle(this.listPanelElRef, 'top', `${bottom}px`);
            this.render.removeStyle(this.listPanelElRef, 'visibility');
            return;
        }
        else {
            if (top > this.maxHeight || top > panelHeight) {
                this.render.setStyle(this.listPanelElRef, 'top', `${top - panelHeight}px`);
            }
            else {
                this.render.setStyle(this.listPanelElRef, 'top', '0px');
                if (left > 200) {
                    this.render.setStyle(this.listPanelElRef, 'left', `${left - 200}px`);
                }
            }
            this.render.removeStyle(this.listPanelElRef, 'visibility');
        }
    }
}
TextareaCommentsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[common-comments]',
            },] }
];
/** @nocollapse */
TextareaCommentsDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LocaleService },
    { type: ComponentFactoryResolver }
];
TextareaCommentsDirective.propDecorators = {
    useComments: [{ type: Input, args: ['common-comments',] }],
    maxHeight: [{ type: Input }],
    title: [{ type: Input }],
    mgrText: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SingleSelectDirective {
    /**
     * @param {?} injector
     * @param {?} elRef
     * @param {?} render
     */
    constructor(injector, elRef, render) {
        this.injector = injector;
        this.elRef = elRef;
        this.render = render;
        this.items = [];
        this.position = 'below';
        this.container = null;
        this.selectEl = null;
        this.overlayHandler = null;
        this.displayTextEl = null;
        this.ngZone = null;
        this.beforeShow = null;
        this.overlaySer = this.injector.get(OverLayHiddenService, new OverLayHiddenService());
        this.ngZone = this.injector.get(NgZone, null);
        if (this.overlaySer) {
            if (this.ngZone) {
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => {
                    this.registerMouseEvent();
                }));
            }
            else {
                this.registerMouseEvent();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    registerMouseEvent() {
        this.overlayHandler = this.overlaySer.registerMouseEvent(this.elRef.nativeElement, (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (!this.panelRef.classList.contains('f-area-show')) {
                return;
            }
            if (this.panelRef.contains(e.target)) {
                return;
            }
            if (this.selectEl.contains(e.target)) {
                return;
            }
            this.panelRef.classList.remove('f-area-show');
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngCtrl = this.injector.get(NgControl);
        if (this.ngCtrl) {
            this.ngCtrl.valueChanges.subscribe((/**
             * @param {?} v
             * @return {?}
             */
            (v) => {
                this.updateDisplayText();
            }));
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        const { container } = this.createMySelect();
        this.selectEl = container;
        this.elRef.nativeElement.style.display = 'none';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.overlayHandler) {
            this.overlayHandler();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createMySelect() {
        /** @type {?} */
        const selectContainerEl = document.createElement('div');
        selectContainerEl.className = 'input-group f-cmp-inputgroup';
        if (this.width) {
            selectContainerEl.style.width = `${this.width}px`;
        }
        selectContainerEl.style.userSelect = 'none';
        selectContainerEl.style.overflow = 'hidden';
        /** @type {?} */
        const selectTextEl = document.createElement('div');
        selectTextEl.className = 'form-control f-utils-fill text-left px-1 d-flex';
        selectTextEl.style.alignItems = 'center';
        selectTextEl.style.whiteSpace = 'nowrap';
        this.displayTextEl = selectTextEl;
        /** @type {?} */
        const selectArrowEl = document.createElement('div');
        selectArrowEl.className = 'input-group-append';
        selectArrowEl.innerHTML = `<span class="input-group-text"><i class="f-icon f-icon-arrow-s"></i></span>`;
        selectContainerEl.appendChild(selectTextEl);
        selectContainerEl.appendChild(selectArrowEl);
        this.elRef.nativeElement.after(selectContainerEl);
        this.render.listen(selectContainerEl, 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (this.panelRef.classList.contains('f-area-show')) {
                this.panelRef.classList.remove('f-area-show');
                return;
            }
            if (!this.beforeShow) {
                this.beforeShow = (/**
                 * @return {?}
                 */
                () => {
                    return of(true);
                });
            }
            this.updatePosition();
            this.beforeShow({ instance: this }).pipe(debounceTime(10)).subscribe((/**
             * @param {?} r
             * @return {?}
             */
            r => {
                if (r) {
                    this.panelRef.classList.add('f-area-show');
                }
            }));
        }));
        this.render.listen(this.panelRef, 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e.target.nodeName === 'LI') {
                /** @type {?} */
                const val = e.target.getAttribute('value');
                this.ngCtrl.control.setValue(val);
                this.panelRef.classList.remove('f-area-show');
                selectTextEl.innerHTML = e.target.innerHTML;
            }
        }));
        this.panelRef.style.cssText = `
        position:fixed;z-index: 100;
        box-shadow: 0 2px 8px 0 rgba(0,0,0,.15);
        border-radius: 3px;max-height:300px;overflow:auto;
        transition: all 0.08s linear;`;
        this.panelRef.querySelector('ul').style.cssText = `position:relative;min-width: 100%;border:none; box-shadow: none;`;
        this.updateDisplayText();
        return { container: selectContainerEl };
    }
    /**
     * @private
     * @return {?}
     */
    updateDisplayText() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const li = this.panelRef.querySelector(`[value="${this.ngCtrl.value}"]`);
            this.displayTextEl.innerHTML = li ? li.innerHTML : '';
            if (this.items && !this.items.length) {
                /** @type {?} */
                const item = this.items.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.value == this.ngCtrl.value));
                if (item) {
                    this.displayTextEl.innerHTML = item.label;
                }
            }
            this.displayTextEl.title = this.displayTextEl.innerText;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    updatePosition() {
        /** @type {?} */
        const ul = this.panelRef.querySelector('ul');
        if (this.position === 'above') {
            ul.style.position = 'relative';
            /** @type {?} */
            const t = this.selectEl.offsetTop - ul.offsetHeight - 6;
            /** @type {?} */
            const top = `${t}px`;
            this.panelRef.style.top = top;
            this.panelRef.style.transformOrigin = 'bottom';
        }
        else {
            this.panelRef.style.top = 'auto';
            if (this.container) {
                this.panelRef.style.top = (this.panelRef.offsetTop - this.container.scrollTop) + 'px';
            }
        }
        // if ( this.selectEl.offsetLeft) {
        //     this.panelRef.style.left = this.selectEl.offsetLeft + 'px';
        // }
        if (!this.width) {
            this.panelRef.style.width = this.selectEl.offsetWidth + 'px';
            ul.style.width = '100%';
        }
        else {
            this.panelRef.style.width = this.width + 'px';
        }
    }
}
SingleSelectDirective.decorators = [
    { type: Directive, args: [{
                selector: '[single-select]',
                exportAs: 'singleSelect'
            },] }
];
/** @nocollapse */
SingleSelectDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: Renderer2 }
];
SingleSelectDirective.propDecorators = {
    items: [{ type: Input }],
    panelRef: [{ type: Input }],
    width: [{ type: Input }],
    position: [{ type: Input }],
    container: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisFormsModule {
}
FarrisFormsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RadioComponent,
                    RadioGroupComponent,
                    CheckboxComponent,
                    CheckboxGroupComponent,
                    RadioButtonComponent,
                    FarrisRadioGroupComponent,
                    FarrisCheckboxGroupComponent,
                    TextareaAutoSizeDirective,
                    TextareaZoomDirective,
                    ShortCutTabKeyDirective,
                    TextareaWordcountDirective,
                    InputAppendDirective,
                    TextareaCommentsDirective,
                    SingleListComponent,
                    SingleSelectDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    MessagerModule.forRoot(),
                    FarrisCommonModule.forRoot(),
                    LocaleModule,
                ],
                exports: [
                    RadioComponent,
                    RadioGroupComponent,
                    CheckboxComponent,
                    CheckboxGroupComponent,
                    RadioButtonComponent,
                    FarrisRadioGroupComponent,
                    FarrisCheckboxGroupComponent,
                    TextareaAutoSizeDirective,
                    TextareaZoomDirective,
                    ShortCutTabKeyDirective,
                    TextareaWordcountDirective,
                    InputAppendDirective,
                    TextareaCommentsDirective,
                    SingleSelectDirective
                ],
                entryComponents: [
                    SingleListComponent
                ],
                providers: [IdService],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TextareaAutoSizeDirective, TextareaZoomDirective, ShortCutTabKeyDirective, TextareaWordcountDirective, InputAppendDirective, TextareaCommentsDirective, SingleListComponent, SingleSelectDirective, FarrisFormsModule, RadioComponent, RadioGroupComponent, FarrisRadioGroupComponent, RadioButtonComponent, CheckboxGroupComponent, CheckboxComponent, FarrisCheckboxGroupComponent, CommentsHttpToken };

//# sourceMappingURL=farris-ui-forms.js.map