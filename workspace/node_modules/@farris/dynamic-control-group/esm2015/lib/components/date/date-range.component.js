/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, HostBinding } from "@angular/core";
import { FormGroup } from "@angular/forms";
export class DateRangeComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.control.control.format = this.control.control.format || 'yyyy-MM-dd';
        this.className = this.control.className ? this.control.className : 'col-12 col-md-6 col-xl-3 col-el-2';
    }
}
DateRangeComponent.decorators = [
    { type: Component, args: [{
                selector: "dynamic-date-range",
                template: `
      <div class="farris-group-wrap" [formGroup]="form">
        <div class="form-group farris-form-group">
          <label class="col-form-label">
            <span *ngIf="0" class="farris-label-info text-danger">*</span>
            <span class="farris-label-text">{{control.name}}</span>
          </label>
          <div class="farris-input-wrap">
            <farris-datepicker [dateRange]="true" [returnFormat]="control.control.format" [formControlName]="control.labelCode" [readonly]="control.control.readonly"></farris-datepicker>
          </div>
        </div>
      </div>
  `
            }] }
];
/** @nocollapse */
DateRangeComponent.ctorParameters = () => [];
DateRangeComponent.propDecorators = {
    className: [{ type: HostBinding, args: ['class',] }],
    control: [{ type: Input }],
    form: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    DateRangeComponent.prototype.className;
    /** @type {?} */
    DateRangeComponent.prototype.control;
    /** @type {?} */
    DateRangeComponent.prototype.form;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1yYW5nZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL2R5bmFtaWMtY29udHJvbC1ncm91cC8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2RhdGUvZGF0ZS1yYW5nZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQVUsS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFtQjNDLE1BQU0sT0FBTyxrQkFBa0I7SUFNN0IsZ0JBQWUsQ0FBQzs7OztJQUNoQixRQUFRO1FBQ04sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUM7UUFDMUUsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDO0lBQ3pHLENBQUM7OztZQTNCRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7R0FZVDthQUVGOzs7Ozt3QkFFRSxXQUFXLFNBQUMsT0FBTztzQkFDbkIsS0FBSzttQkFFTCxLQUFLOzs7O0lBSE4sdUNBQXdDOztJQUN4QyxxQ0FDNkI7O0lBQzdCLGtDQUNnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgSG9zdEJpbmRpbmcgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcclxuaW1wb3J0IHsgSUR5bmFtaWNCYXNlQ29udHJvbCwgSUR5bmFtaWNEYXRlQ29udHJvbCB9IGZyb20gXCIuLi8uLi9pbnRlcmZhY2VzL2R5bmFtaWMtY29udHJvbC5pbnRlcmZhY2VcIjtcclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6IFwiZHluYW1pYy1kYXRlLXJhbmdlXCIsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgICAgPGRpdiBjbGFzcz1cImZhcnJpcy1ncm91cC13cmFwXCIgW2Zvcm1Hcm91cF09XCJmb3JtXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgZmFycmlzLWZvcm0tZ3JvdXBcIj5cclxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbC1mb3JtLWxhYmVsXCI+XHJcbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiMFwiIGNsYXNzPVwiZmFycmlzLWxhYmVsLWluZm8gdGV4dC1kYW5nZXJcIj4qPC9zcGFuPlxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhcnJpcy1sYWJlbC10ZXh0XCI+e3tjb250cm9sLm5hbWV9fTwvc3Bhbj5cclxuICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmFycmlzLWlucHV0LXdyYXBcIj5cclxuICAgICAgICAgICAgPGZhcnJpcy1kYXRlcGlja2VyIFtkYXRlUmFuZ2VdPVwidHJ1ZVwiIFtyZXR1cm5Gb3JtYXRdPVwiY29udHJvbC5jb250cm9sLmZvcm1hdFwiIFtmb3JtQ29udHJvbE5hbWVdPVwiY29udHJvbC5sYWJlbENvZGVcIiBbcmVhZG9ubHldPVwiY29udHJvbC5jb250cm9sLnJlYWRvbmx5XCI+PC9mYXJyaXMtZGF0ZXBpY2tlcj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICBgLFxyXG4gIHN0eWxlczogW11cclxufSlcclxuZXhwb3J0IGNsYXNzIERhdGVSYW5nZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTmFtZTogc3RyaW5nO1xyXG4gIEBJbnB1dCgpXHJcbiAgY29udHJvbDogSUR5bmFtaWNEYXRlQ29udHJvbDtcclxuICBASW5wdXQoKVxyXG4gIGZvcm06IEZvcm1Hcm91cDtcclxuICBjb25zdHJ1Y3RvcigpIHt9XHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICB0aGlzLmNvbnRyb2wuY29udHJvbC5mb3JtYXQgPSB0aGlzLmNvbnRyb2wuY29udHJvbC5mb3JtYXQgfHwgJ3l5eXktTU0tZGQnO1xyXG4gICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNvbnRyb2wuY2xhc3NOYW1lID8gdGhpcy5jb250cm9sLmNsYXNzTmFtZSA6ICdjb2wtMTIgY29sLW1kLTYgY29sLXhsLTMgY29sLWVsLTInO1xyXG4gIH1cclxufVxyXG4iXX0=