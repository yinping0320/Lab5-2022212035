/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { YEARS, OPTS } from '../../constants/constants';
import { UtilService } from '../../services/public-api';
import { KeyCode } from '../../enums/public-api';
export class YearViewComponent {
    /**
     * @param {?} utilService
     */
    constructor(utilService) {
        this.utilService = utilService;
        this.yearCellClicked = new EventEmitter();
        this.yearCellKeyDown = new EventEmitter();
        this.prevCellClicked = new EventEmitter();
        this.nextCellClicked = new EventEmitter();
        this.onMouseEnter = new EventEmitter();
        this.onMouseLeave = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.hasOwnProperty(OPTS)) {
            this.opts = changes[OPTS].currentValue;
        }
        if (changes.hasOwnProperty(YEARS)) {
            this.years = changes[YEARS].currentValue;
        }
    }
    /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    onYearCellClicked(event, cell) {
        event.stopPropagation();
        if (cell.disabled) {
            return;
        }
        this.yearCellClicked.emit(cell);
    }
    /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    onYearCellKeyDown(event, cell) {
        /** @type {?} */
        const keyCode = this.utilService.getKeyCodeFromEvent(event);
        if (keyCode !== KeyCode.tab) {
            event.preventDefault();
            if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {
                this.onYearCellClicked(event, cell);
            }
            else if (this.opts.moveFocusByArrowKeys) {
                this.yearCellKeyDown.emit(cell);
            }
        }
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    onPrevOrNextYearCellClicked(event, index) {
        event.stopPropagation();
        if (index === 0) {
            if (this.prevViewDisabled)
                return;
            this.prevCellClicked.emit(event);
        }
        else {
            if (this.nextViewDisabled)
                return;
            this.nextCellClicked.emit(event);
        }
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    onMonthCellMouseEnter(cell) {
        if (this.utilService.isInitializedDate(this.selectedDateRange.begin) &&
            !this.utilService.isInitializedDate(this.selectedDateRange.end)) {
            for (let i = 0; i < this.years.length; i++) {
                /** @type {?} */
                let row = this.years[i];
                for (let j = 0; j < row.length; j++) {
                    /** @type {?} */
                    let year = row[j];
                    year.range =
                        (this.utilService.isDateSameOrEarlier(this.selectedDateRange.begin, year.yearObj) &&
                            this.utilService.isDateSameOrEarlier(year.yearObj, cell.yearObj)) ||
                            (this.utilService.isDateSameOrEarlier(year.yearObj, this.selectedDateRange.begin) &&
                                this.utilService.isDateSameOrEarlier(cell.yearObj, year.yearObj));
                }
            }
            this.onMouseEnter.emit(cell);
        }
    }
    /**
     * @return {?}
     */
    onMonthCellMouseLeave() {
        for (let i = 0; i < this.years.length; i++) {
            /** @type {?} */
            let row = this.years[i];
            for (let j = 0; j < row.length; j++) {
                /** @type {?} */
                let year = row[j];
                year.range = false;
            }
        }
        this.onMouseLeave.emit();
    }
    /**
     * @param {?} year
     * @return {?}
     */
    isMonthInRange(year) {
        return this.utilService.isDateInRange(year, this.selectedDateRange);
    }
    /**
     * @param {?} year
     * @return {?}
     */
    isYearSame(year) {
        // return this.utilService.isDateSame(
        //     {
        //         year: this.visibleMonth.year
        //     },
        //     year
        // );
        if (this.selectedDate) {
            return this.selectedDate.year === year.year;
        }
        return false;
    }
    /**
     * @param {?} year
     * @return {?}
     */
    isMonthRangeBeginOrEndSame(year) {
        return this.utilService.isDateSame({ year: this.selectedDateRange.begin.year }, year) || this.utilService.isDateSame({ year: this.selectedDateRange.end.year }, year);
    }
}
YearViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-year-view',
                template: "<table class=\"f-datepicker-table-wrapper\">\r\n    <tbody class=\"f-datepicker-table\">\r\n        <tr *ngFor=\"let yr of years; let yi = index\">\r\n            <td\r\n                *ngFor=\"let y of yr; let i = index\"\r\n                id=\"y_{{ yi }}_{{ i }}\"\r\n                class=\"y_{{ yi }}_{{ i }} \"\r\n                [ngClass]=\"{\r\n                    'f-datepicker-no-currmonth':\r\n                        (yi === 0 && i === 0) || (yi === 3 && i === 2)\r\n                }\"\r\n                (click)=\"onYearCellClicked($event, y)\"\r\n                (keydown)=\"onYearCellKeyDown($event, y)\"\r\n                (mouseenter)=\"onMonthCellMouseEnter(y)\"\r\n                (mouseleave)=\"onMonthCellMouseLeave()\"\r\n                tabindex=\"0\"\r\n            >\r\n                <div class=\"f-datepicker-year\">\r\n                    <span\r\n                        class=\"f-datepicker-year-cell\"\r\n                        [ngClass]=\"{\r\n                            'f-datepicker-current':\r\n                                y.currYear && opts.markCurrentYear,\r\n                            'f-datepicker-selected':\r\n                                (!this.opts.dateRange &&\r\n                                    isYearSame(y.yearObj)) ||\r\n                                (this.opts.dateRange &&\r\n                                    isMonthRangeBeginOrEndSame(y.yearObj)),\r\n                            'f-datepicker-disabled': y.disabled,\r\n                            'f-datepicker-range':\r\n                                isMonthInRange(y.yearObj) || y.range\r\n                        }\"\r\n                        >{{ y.year }}</span\r\n                    >\r\n                </div>\r\n            </td>\r\n            <!-- <ng-container *ngFor=\"let y of yr; let i = index\">\r\n                <ng-container\r\n                    *ngIf=\"\r\n                        (yi === 0 && i === 0) || (yi === 3 && i === 2);\r\n                        else elseTemplate\r\n                    \"\r\n                >\r\n                    <td\r\n                        id=\"y_{{ yi }}_{{ i }}\"\r\n                        class=\"y_{{ yi }}_{{ i }}\"\r\n                        (click)=\"onPrevOrNextYearCellClicked($event, i)\"\r\n                        (keydown)=\"onPrevOrNextYearCellKeyDown($event, i)\"\r\n                        tabindex=\"0\"\r\n                    >\r\n                        <div class=\"f-datepicker-year\">\r\n                            <span\r\n                                class=\"f-datepicker-year-cell\"\r\n                                [ngClass]=\"{\r\n                                    'f-datepicker-disabled':\r\n                                        (i === 0 && this.prevViewDisabled) ||\r\n                                        (i === 2 && this.nextViewDisabled)\r\n                                }\"\r\n                                ><i\r\n                                    class=\"f-icon \"\r\n                                    [ngClass]=\"{\r\n                                        'k-i-arrow-chevron-left': i === 0,\r\n                                        'k-i-arrow-chevron-right': i === 2\r\n                                    }\"\r\n                                ></i>\r\n                            </span>\r\n                        </div>\r\n                    </td>\r\n                </ng-container>\r\n                <ng-template #elseTemplate>\r\n                    <td\r\n                        id=\"y_{{ yi }}_{{ i }}\"\r\n                        class=\"y_{{ yi }}_{{ i }}\"\r\n                        (click)=\"onYearCellClicked($event, y)\"\r\n                        (keydown)=\"onYearCellKeyDown($event, y)\"\r\n                        tabindex=\"0\"\r\n                    >\r\n                        <div class=\"f-datepicker-year\">\r\n                            <span\r\n                                class=\"f-datepicker-year-cell\"\r\n                                [ngClass]=\"{\r\n                                    'f-datepicker-current':\r\n                                        y.currYear && opts.markCurrentYear,\r\n                                    'f-datepicker-selected': y.selected,\r\n                                    'f-datepicker-disabled': y.disabled\r\n                                }\"\r\n                                >{{ y.year }}</span\r\n                            >\r\n                        </div>\r\n                    </td>\r\n                </ng-template>\r\n            </ng-container> -->\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n",
                providers: [UtilService],
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
YearViewComponent.ctorParameters = () => [
    { type: UtilService }
];
YearViewComponent.propDecorators = {
    opts: [{ type: Input }],
    years: [{ type: Input }],
    prevViewDisabled: [{ type: Input }],
    nextViewDisabled: [{ type: Input }],
    selectedDate: [{ type: Input }],
    selectedDateRange: [{ type: Input }],
    visibleMonth: [{ type: Input }],
    yearCellClicked: [{ type: Output }],
    yearCellKeyDown: [{ type: Output }],
    prevCellClicked: [{ type: Output }],
    nextCellClicked: [{ type: Output }],
    onMouseEnter: [{ type: Output }],
    onMouseLeave: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    YearViewComponent.prototype.opts;
    /** @type {?} */
    YearViewComponent.prototype.years;
    /** @type {?} */
    YearViewComponent.prototype.prevViewDisabled;
    /** @type {?} */
    YearViewComponent.prototype.nextViewDisabled;
    /** @type {?} */
    YearViewComponent.prototype.selectedDate;
    /** @type {?} */
    YearViewComponent.prototype.selectedDateRange;
    /** @type {?} */
    YearViewComponent.prototype.visibleMonth;
    /** @type {?} */
    YearViewComponent.prototype.yearCellClicked;
    /** @type {?} */
    YearViewComponent.prototype.yearCellKeyDown;
    /** @type {?} */
    YearViewComponent.prototype.prevCellClicked;
    /** @type {?} */
    YearViewComponent.prototype.nextCellClicked;
    /** @type {?} */
    YearViewComponent.prototype.onMouseEnter;
    /** @type {?} */
    YearViewComponent.prototype.onMouseLeave;
    /**
     * @type {?}
     * @private
     */
    YearViewComponent.prototype.utilService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvdWktZGF0ZXBpY2tlci8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3llYXItdmlldy95ZWFyLXZpZXcuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWEsTUFBTSxFQUFpQixpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNwSCxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUV4RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFPakQsTUFBTSxPQUFPLGlCQUFpQjs7OztJQWtCMUIsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFSbEMsb0JBQWUsR0FBa0MsSUFBSSxZQUFZLEVBQW1CLENBQUM7UUFDckYsb0JBQWUsR0FBa0MsSUFBSSxZQUFZLEVBQW1CLENBQUM7UUFDckYsb0JBQWUsR0FBdUIsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUMvRCxvQkFBZSxHQUF1QixJQUFJLFlBQVksRUFBUSxDQUFDO1FBRS9ELGlCQUFZLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFDMUQsaUJBQVksR0FBc0IsSUFBSSxZQUFZLEVBQU8sQ0FBQztJQUVyQixDQUFDOzs7O0lBQ2hELFFBQVEsS0FBVSxDQUFDOzs7OztJQUNuQixXQUFXLENBQUMsT0FBc0I7UUFDOUIsSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQztTQUMxQztRQUNELElBQUksT0FBTyxDQUFDLGNBQWMs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QWlCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFLElBQUksQ0FDcEQsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FDNUIsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQ2xELENBQUM7SUFDTixDQUFDOzs7WUFuSUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxlQUFlO2dCQUN6Qix5aUpBQXlDO2dCQUN6QyxTQUFTLEVBQUUsQ0FBQyxXQUFXLENBQUM7Z0JBQ3hCLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2FBQ3hDOzs7O1lBUlEsV0FBVzs7O21CQVVmLEtBQUs7b0JBQ0wsS0FBSzsrQkFDTCxLQUFLOytCQUNMLEtBQUs7MkJBQ0wsS0FBSztnQ0FDTCxLQUFLOzJCQUNMLEtBQUs7OEJBR0wsTUFBTTs4QkFDTixNQUFNOzhCQUNOLE1BQU07OEJBQ04sTUFBTTsyQkFFTixNQUFNOzJCQUNOLE1BQU07Ozs7SUFmUCxpQ0FBMEI7O0lBQzFCLGtDQUE4Qzs7SUFDOUMsNkNBQW1DOztJQUNuQyw2Q0FBbUM7O0lBQ25DLHlDQUErQjs7SUFDL0IsOENBQXlDOztJQUN6Qyx5Q0FBZ0M7O0lBR2hDLDRDQUErRjs7SUFDL0YsNENBQStGOztJQUMvRiw0Q0FBeUU7O0lBQ3pFLDRDQUF5RTs7SUFFekUseUNBQW9FOztJQUNwRSx5Q0FBb0U7Ozs7O0lBRXhELHdDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFlFQVJTLCBPUFRTIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IFV0aWxTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcHVibGljLWFwaSc7XHJcbmltcG9ydCB7IElNeUNhbGVuZGFyWWVhciwgSU15T3B0aW9ucywgSU15RGF0ZSwgSU15RGF0ZVJhbmdlLCBJTXlNb250aCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvcHVibGljLWFwaSc7XHJcbmltcG9ydCB7IEtleUNvZGUgfSBmcm9tICcuLi8uLi9lbnVtcy9wdWJsaWMtYXBpJztcclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2xpYi15ZWFyLXZpZXcnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL3llYXItdmlldy5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBwcm92aWRlcnM6IFtVdGlsU2VydmljZV0sXHJcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBZZWFyVmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgICBASW5wdXQoKSBvcHRzOiBJTXlPcHRpb25zO1xyXG4gICAgQElucHV0KCkgeWVhcnM6IEFycmF5PEFycmF5PElNeUNhbGVuZGFyWWVhcj4+O1xyXG4gICAgQElucHV0KCkgcHJldlZpZXdEaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIEBJbnB1dCgpIG5leHRWaWV3RGlzYWJsZWQ6IGJvb2xlYW47XHJcbiAgICBASW5wdXQoKSBzZWxlY3RlZERhdGU6IElNeURhdGU7XHJcbiAgICBASW5wdXQoKSBzZWxlY3RlZERhdGVSYW5nZTogSU15RGF0ZVJhbmdlO1xyXG4gICAgQElucHV0KCkgdmlzaWJsZU1vbnRoOiBJTXlNb250aDtcclxuXHJcblxyXG4gICAgQE91dHB1dCgpIHllYXJDZWxsQ2xpY2tlZDogRXZlbnRFbWl0dGVyPElNeUNhbGVuZGFyWWVhcj4gPSBuZXcgRXZlbnRFbWl0dGVyPElNeUNhbGVuZGFyWWVhcj4oKTtcclxuICAgIEBPdXRwdXQoKSB5ZWFyQ2VsbEtleURvd246IEV2ZW50RW1pdHRlcjxJTXlDYWxlbmRhclllYXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTXlDYWxlbmRhclllYXI+KCk7XHJcbiAgICBAT3V0cHV0KCkgcHJldkNlbGxDbGlja2VkOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgbmV4dENlbGxDbGlja2VkOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG4gICAgQE91dHB1dCgpIG9uTW91c2VFbnRlcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIEBPdXRwdXQoKSBvbk1vdXNlTGVhdmU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB1dGlsU2VydmljZTogVXRpbFNlcnZpY2UpIHt9XHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoT1BUUykpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRzID0gY2hhbmdlc1tPUFRTXS5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KFlFQVJTKSkge1xyXG4gICAgICAgICAgICB0aGlzLnllYXJzID0gY2hhbmdlc1tZRUFSU10uY3VycmVudFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblllYXJDZWxsQ2xpY2tlZChldmVudDogYW55LCBjZWxsOiBJTXlDYWxlbmRhclllYXIpOiB2b2lkIHtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBpZiAoY2VsbC5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueWVhckNlbGxDbGlja2VkLmVtaXQoY2VsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25ZZWFyQ2VsbEtleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGNlbGw6IElNeUNhbGVuZGFyWWVhcikge1xyXG4gICAgICAgIGNvbnN0IGtleUNvZGU6IG51bWJlciA9IHRoaXMudXRpbFNlcnZpY2UuZ2V0S2V5Q29kZUZyb21FdmVudChldmVudCk7XHJcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IEtleUNvZGUudGFiKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5Q29kZS5lbnRlciB8fCBrZXlDb2RlID09PSBLZXlDb2RlLnNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uWWVhckNlbGxDbGlja2VkKGV2ZW50LCBjZWxsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMubW92ZUZvY3VzQnlBcnJvd0tleXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueWVhckNlbGxLZXlEb3duLmVtaXQoY2VsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblByZXZPck5leHRZZWFyQ2VsbENsaWNrZWQoZXZlbnQ6IGFueSwgaW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2Vmlld0Rpc2FibGVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMucHJldkNlbGxDbGlja2VkLmVtaXQoZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRWaWV3RGlzYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5uZXh0Q2VsbENsaWNrZWQuZW1pdChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Nb250aENlbGxNb3VzZUVudGVyKGNlbGw6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhpcy51dGlsU2VydmljZS5pc0luaXRpYWxpemVkRGF0ZSh0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLmJlZ2luKSAmJlxyXG4gICAgICAgICAgICAhdGhpcy51dGlsU2VydmljZS5pc0luaXRpYWxpemVkRGF0ZSh0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLmVuZClcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnllYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gdGhpcy55ZWFyc1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHllYXIgPSByb3dbal07XHJcbiAgICAgICAgICAgICAgICAgICAgeWVhci5yYW5nZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWVPckVhcmxpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLmJlZ2luLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhci55ZWFyT2JqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXRpbFNlcnZpY2UuaXNEYXRlU2FtZU9yRWFybGllcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyLnllYXJPYmosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ZWFyT2JqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy51dGlsU2VydmljZS5pc0RhdGVTYW1lT3JFYXJsaWVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhci55ZWFyT2JqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVSYW5nZS5iZWdpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWVPckVhcmxpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC55ZWFyT2JqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHllYXIueWVhck9ialxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRW50ZXIuZW1pdChjZWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb250aENlbGxNb3VzZUxlYXZlKCk6IHZvaWQge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy55ZWFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgcm93ID0gdGhpcy55ZWFyc1tpXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB5ZWFyID0gcm93W2pdO1xyXG4gICAgICAgICAgICAgICAgeWVhci5yYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25Nb3VzZUxlYXZlLmVtaXQoKTtcclxuICAgIH1cclxuICAgIGlzTW9udGhJblJhbmdlKHllYXI6IElNeURhdGUpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51dGlsU2VydmljZS5pc0RhdGVJblJhbmdlKHllYXIsIHRoaXMuc2VsZWN0ZWREYXRlUmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgaXNZZWFyU2FtZSh5ZWFyOiBJTXlEYXRlKTogYm9vbGVhbiB7XHJcbiAgICAgIFxyXG4gICAgICAgIC8vIHJldHVybiB0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWUoXHJcbiAgICAgICAgLy8gICAgIHtcclxuICAgICAgICAvLyAgICAgICAgIHllYXI6IHRoaXMudmlzaWJsZU1vbnRoLnllYXJcclxuICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAvLyAgICAgeWVhclxyXG4gICAgICAgIC8vICk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZERhdGUueWVhciA9PT0geWVhci55ZWFyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaXNNb250aFJhbmdlQmVnaW5PckVuZFNhbWUoeWVhcjogSU15RGF0ZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWUoXHJcbiAgICAgICAgICAgIHsgeWVhcjogdGhpcy5zZWxlY3RlZERhdGVSYW5nZS5iZWdpbi55ZWFyIH0sIHllYXJcclxuICAgICAgICApIHx8IHRoaXMudXRpbFNlcnZpY2UuaXNEYXRlU2FtZShcclxuICAgICAgICAgICAgeyB5ZWFyOiB0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLmVuZC55ZWFyIH0sIHllYXJcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==