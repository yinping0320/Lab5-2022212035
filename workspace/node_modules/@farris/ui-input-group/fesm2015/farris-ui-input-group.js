import ResizeObserver from 'resize-observer-polyfill';
import { PopoverModule } from '@farris/ui-popover';
import { Injectable, Renderer2, forwardRef, Injector, HostBinding, ChangeDetectorRef, NgZone, ViewEncapsulation, Component, Output, EventEmitter, ElementRef, Input, ViewChild, NgModule, defineInjectable } from '@angular/core';
import { FarrisCommonModule } from '@farris/ui-common';
import { CommonModule } from '@angular/common';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputGroupService {
    constructor() { }
}
InputGroupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
InputGroupService.ctorParameters = () => [];
/** @nocollapse */ InputGroupService.ngInjectableDef = defineInjectable({ factory: function InputGroupService_Factory() { return new InputGroupService(); }, token: InputGroupService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INPUT_GROUP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => InputGroupComponent)),
    multi: true
};
class InputGroupComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} ngZone
     * @param {?} injector
     */
    constructor(el, renderer, ngZone, injector) {
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.injector = injector;
        this.autocomplete = 'off';
        this.showClearButton = false;
        this.value = '';
        /**
         * 只读
         */
        this.readonly = false;
        /**
         * 禁用
         */
        this.disabled = false;
        /**
         * 允许编辑
         */
        this.editable = true;
        /**
         * 启用清除按钮
         */
        this.enableClear = true;
        /**
         * 扩展按钮
         */
        this.groupText = '';
        /**
         * 自定义CLASS
         */
        this.customCls = '';
        /**
         * 当组件禁用或只读时显示后边的按钮
         */
        this.showButtonWhenDisabled = false;
        /**
         * 启用提示信息
         */
        this.placeholder = '';
        /**
         * 文本在输入框中的对齐方式
         */
        this.textAlign = 'left';
        this.isPassword = false;
        this.enableViewPassword = true;
        this.noborder = false;
        this.minLength = undefined;
        this.maxLength = undefined;
        this.enableTitle = true;
        /**
         * 扩展信息；在输入框前面 显示 ① 图标鼠标滑过后显示
         */
        this.useExtendInfo = false;
        this.extendInfo = '';
        this.forcePlaceholder = false;
        this.updateExtendInfo = new EventEmitter();
        this.clear = new EventEmitter();
        this.valueChange = new EventEmitter();
        this.clickHandle = new EventEmitter();
        this.blurHandle = new EventEmitter();
        this.focusHandle = new EventEmitter();
        this.enterHandle = new EventEmitter();
        this.iconMouseEnter = new EventEmitter();
        this.iconMouseLeave = new EventEmitter();
        this.keyupHandle = new EventEmitter();
        this.keydownHandle = new EventEmitter();
        this.inputClick = new EventEmitter();
        this.inputType = 'text';
        this.cd = null;
        this.focusCls = 'f-state-focus';
        this.ro = null;
        this.onModelChange = (/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => { });
        this.onModelTouched = (/**
         * @param {?} val
         * @return {?}
         */
        (val) => { });
        this.openEyeICON = '<span class="f-icon f-icon-eye" style="color: rgb(56, 143, 255);"></span>';
        this.closeEyeICON = '<span class="f-icon f-icon-eye"></span>';
        this.cd = this.injector.get(ChangeDetectorRef);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initSmartPassword();
        // this.ngControl = this.injector.get(NgControl, null);
        // console.log(this.ngControl);
        // if (this.ngControl) {
        //     this.ngControl.valueChanges.subscribe((val:any) => {
        //         this.value = val;
        //         this.textbox.nativeElement.value = this.value;
        //     });
        // }
        // if (!this.editable) {
        //     this.readonly = true
        // }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (this.enableClear) {
                this.inputGroup.nativeElement.addEventListener('mouseenter', this.onMouseEnter.bind(this));
                this.inputGroup.nativeElement.addEventListener('mouseleave', this.onMouseLeave.bind(this));
            }
            this.ro = new ResizeObserver((/**
             * @param {?} entries
             * @param {?} observer
             * @return {?}
             */
            (entries, observer) => {
                if (entries && entries[0] && this.clearIconRef) {
                    const { width, height } = entries[0].contentRect;
                    /** @type {?} */
                    const target = entries[0].target;
                    if (width < 70) {
                        this.clearIconRef.nativeElement.classList.add('input-group-clear-right');
                    }
                    else {
                        this.clearIconRef.nativeElement.classList.remove('input-group-clear-right');
                    }
                }
            }));
            this.ro.observe(this.inputGroup.nativeElement);
            if (this.noborder) {
                this.renderer.setStyle(this.inputGroup.nativeElement, 'borderWidth', '0px');
            }
            /** @type {?} */
            const groupAppendEl = this.el.nativeElement.querySelector('.input-group-append');
            if (!this.groupText && groupAppendEl) {
                this.renderer.setStyle(groupAppendEl, 'margin-left', '0');
            }
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // if (changes.groupText && !changes.groupText.isFirstChange()) {
        //     if (changes.groupText.currentValue) {
        //         this.renderer.setStyle(
        //             this.el.nativeElement.querySelector('.input-group-append'),
        //             'margin-left',
        //             '-1'
        //         );
        //     }
        // }
        ['readonly', 'disabled'].forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (changes[n] && !changes[n].isFirstChange()) {
                if (this[n] && this.isPassword) {
                    if (this.groupText) {
                        this.groupText = this.closeEyeICON;
                    }
                    this.inputType = 'password';
                }
            }
        }));
    }
    /**
     * @param {?} val
     * @return {?}
     */
    ngModelChange(val) {
    }
    /**
     * @private
     * @return {?}
     */
    initSmartPassword() {
        if (this.isPassword) {
            this.groupText = this.closeEyeICON;
            if (!this.enableViewPassword) {
                this.groupText = '';
            }
            this.inputType = 'password';
            /** @type {?} */
            let openEyes = false;
            this.onClickHandle = (/**
             * @param {?} $event
             * @return {?}
             */
            ($event) => {
                openEyes = !openEyes;
                /** @type {?} */
                const inputtype = openEyes ? 'text' : 'password';
                this.groupText = openEyes ? this.openEyeICON : this.closeEyeICON;
                this.inputType = inputtype;
                this.cd.detectChanges();
                return false;
            });
        }
        else {
            this.inputType = 'text';
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onEnter($event) {
        // if (this.editable) {
        //     $event.stopPropagation();
        // }
        this.enterHandle.emit({ originalEvent: $event });
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onInputFocus($event) {
        if (this.disabled) {
            return;
        }
        else {
            if (!this.noborder) {
                this.renderer.addClass(this.inputGroup.nativeElement, this.focusCls);
            }
            if (this.editable || !this.readonly) {
                this.focusHandle.emit($event);
            }
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onInputClick($event) {
        this.inputClick.emit($event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseEnter(event) {
        if (this.value) {
            if (!this.editable) {
                if (!this.state && !this.disabled) {
                    this.showClearButton = true;
                }
            }
            else {
                if (!this.readonly && !this.disabled) {
                    this.showClearButton = true;
                }
            }
        }
        if (this.showClearButton) {
            this.toggleClearIcon(event, true);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseLeave(event) {
        this.showClearButton = false;
        this.toggleClearIcon(event, false);
    }
    /**
     * @return {?}
     */
    getStateCls() {
        if (this.disabled) {
            return { 'f-state-disabled': true };
        }
        else {
            if (!this.editable) {
                return { 'f-state-editable': true, 'f-state-readonly': this.readonly };
            }
            else {
                return { 'f-state-readonly': this.readonly };
            }
        }
    }
    /**
     * @private
     * @param {?} event
     * @param {?=} isShow
     * @return {?}
     */
    toggleClearIcon(event, isShow = false) {
        /** @type {?} */
        const str = isShow ? '' : 'none';
        /** @type {?} */
        const clearIcon = event.target.querySelector('.input-group-clear');
        if (clearIcon) {
            clearIcon.style.display = str;
        }
    }
    /**
     * @return {?}
     */
    onMouseOverInExtentInfo() {
        this.updateExtendInfo.emit();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMousedown($event) {
        /** @type {?} */
        const target = (/** @type {?} */ ($event.target));
        if (target.tagName !== 'INPUT') {
            $event.preventDefault();
        }
        $event.stopPropagation();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClearValue($event) {
        /** @type {?} */
        const flag1 = !this.readonly && !this.disabled && this.editable;
        /** @type {?} */
        const flag2 = !this.editable;
        $event.stopPropagation();
        if (flag1 || flag2) {
            this.onValueChange('', false);
            this.showClearButton = false;
            this.clear.emit();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        this.renderer.removeClass(this.inputGroup.nativeElement, this.focusCls);
        this.blurHandle.emit(event);
        event.stopPropagation();
        return false;
    }
    /**
     * @param {?} val
     * @param {?=} emit
     * @return {?}
     */
    onValueChange(val, emit = true) {
        if (this.value !== val) {
            this.value = val;
            this.onModelChange(val);
            this.onModelTouched(val);
            if (emit) {
                this.valueChange.emit(val);
            }
        }
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    onClickHandle(event) {
        if (this.showButtonWhenDisabled || ((!this.editable || !this.readonly) && !this.disabled)) {
            this.clickHandle.emit({
                originalEvent: event,
                value: this.value
            });
        }
        if (event) {
            event.stopPropagation();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onIconMouseEnter(e) {
        this.iconMouseEnter.emit(e);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onIconMouseLeave(e) {
        this.iconMouseLeave.emit(e);
    }
    /**
     * @return {?}
     */
    focus() {
        this.textbox.nativeElement.focus();
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        this.value = (obj === null || obj === undefined) ? '' : obj;
        this.textbox.nativeElement.value = this.value;
        // 在此处执行 onModelChange 则 pristine 状态变为 false 即非第一次加载；导至表单中的错误信息显示出来，
        // 如果必须要执行一次，需要重新ngControl 的状态
        // this.onModelChange(obj);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    setFocusToEnd() {
        /** @type {?} */
        const el = this.textbox.nativeElement;
        el.focus();
        el.selectionStart = el.value.length;
        el.selectionEnd = el.value.length;
    }
}
InputGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farrisui-input-group, input-group, farris-input-group',
                template: `
        <div #inputGroup [class]="customCls + ' input-group'"
            [class.f-state-disabled]="disabled"
            [class.f-state-editable]="editable && !disabled && !readonly"
            [class.f-state-readonly]="readonly && !disabled">
            <span class="input-group-before-tips" *ngIf="useExtendInfo" (mouseenter)="onMouseOverInExtentInfo()"
                farrisPopover [popover]="extendInfo" [triggers]="'hover'" [container]="'body'" [placement]="'top'">
                <i class="f-icon f-icon-info-circle"></i><b class="tips-arrow"></b>
            </span>

            <input
                #textbox
                name="input-group-value"
                class="form-control f-utils-fill"
                [class.text-left]="textAlign == 'left'"
                [class.text-center]="textAlign == 'center'"
                [class.text-right]="textAlign == 'right'"
                [attr.title]="(enableTitle && !isPassword)? value: ''"
                [attr.type]="inputType"
                [attr.placeholder]="(disabled||readonly)&&!forcePlaceholder?'':placeholder"
                [attr.autocomplete]="autocomplete"
                [readonly]="readonly || !editable"
                [ngModel]="value"
                [disabled]="disabled"
                (blur)="onBlur($event)"
                (mousedown)="onMousedown($event)"
                (ngModelChange)="onValueChange($event)"
                (keydown.enter)="onEnter($event)"
                (focus)="onInputFocus($event)"
                (click)="onInputClick($event)"
                minlength="{{minLength}}"
                maxlength="{{maxLength}}"
                (keyup)="keyupHandle.emit($event)"
                (keydown)="keydownHandle.emit($event)"
                [attr.tabindex]="tabIndex"
            />
            <div class="input-group-append" [ngClass]="{'append-force-show':showButtonWhenDisabled && (readonly||disabled)}"  *ngIf="enableClear || groupText || groupTextTemplate">
                <span *ngIf="enableClear && !readonly && !disabled"
                    [style.display]="showClearButton ? 'flex' : 'none'"
                    class="input-group-text input-group-clear" #clearIcon
                    (click)="onClearValue($event)" style="width:24px">
                    <i class="f-icon modal_close"></i>
                </span>
                <span class="input-group-text"
                    (mouseenter)="onIconMouseEnter($event)" (mouseleave)="onIconMouseLeave($event)"
                    *ngIf="groupText && !groupTextTemplate" [innerHTML]="groupText | safe: 'html'"
                    (click)="onClickHandle($event)"></span>
                <ng-container *ngIf="groupTextTemplate">
                    <ng-container *ngTemplateOutlet="groupTextTemplate" ></ng-container>
                </ng-container>
            </div>
        </div>
    `,
                // .input-group-clear:hover {
                //     background: #e9ecef !important;
                // }
                providers: [INPUT_GROUP_VALUE_ACCESSOR],
                encapsulation: ViewEncapsulation.None,
                styles: [`
            .input-group {
                flex-wrap: nowrap;
            }
            .input-group-text {
                cursor: pointer;
            }
            .input-group-clear {
                cursor: pointer;
            }

            .input-group-text:hover {
                background: #ccc;
            }

            .input-group-clear-right {
                position: absolute;
                height: 100%;
                right: 0;
                top: 0;
                z-index: 100;
            }
        `]
            }] }
];
/** @nocollapse */
InputGroupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: Injector }
];
InputGroupComponent.propDecorators = {
    autocomplete: [{ type: HostBinding, args: ['class.f-cmp-inputgroup',] }, { type: Input }],
    value: [{ type: Input }],
    readonly: [{ type: Input }],
    disabled: [{ type: Input }],
    editable: [{ type: Input }],
    enableClear: [{ type: Input }],
    groupText: [{ type: Input }],
    customCls: [{ type: Input }],
    showButtonWhenDisabled: [{ type: Input }],
    placeholder: [{ type: Input }],
    textAlign: [{ type: Input }],
    groupTextTemplate: [{ type: Input }],
    isPassword: [{ type: Input }],
    enableViewPassword: [{ type: Input }],
    noborder: [{ type: Input }],
    minLength: [{ type: Input }],
    maxLength: [{ type: Input }],
    tabIndex: [{ type: Input }],
    enableTitle: [{ type: Input }],
    useExtendInfo: [{ type: Input }],
    extendInfo: [{ type: Input }],
    forcePlaceholder: [{ type: Input }],
    updateExtendInfo: [{ type: Output }],
    clear: [{ type: Output }],
    valueChange: [{ type: Output }],
    clickHandle: [{ type: Output }],
    blurHandle: [{ type: Output }],
    focusHandle: [{ type: Output }],
    enterHandle: [{ type: Output }],
    iconMouseEnter: [{ type: Output }],
    iconMouseLeave: [{ type: Output }],
    keyupHandle: [{ type: Output }],
    keydownHandle: [{ type: Output }],
    inputClick: [{ type: Output }],
    inputGroup: [{ type: ViewChild, args: ['inputGroup',] }],
    textbox: [{ type: ViewChild, args: ['textbox',] }],
    clearIconRef: [{ type: ViewChild, args: ['clearIcon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputGroupModule {
}
InputGroupModule.decorators = [
    { type: NgModule, args: [{
                declarations: [InputGroupComponent],
                imports: [
                    CommonModule,
                    FormsModule,
                    PopoverModule.forRoot(),
                    FarrisCommonModule
                ],
                exports: [
                    InputGroupComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { InputGroupService, INPUT_GROUP_VALUE_ACCESSOR, InputGroupComponent, InputGroupModule };

//# sourceMappingURL=farris-ui-input-group.js.map