/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Component, EventEmitter, Output } from '@angular/core';
var DatePropertyComponent = /** @class */ (function () {
    function DatePropertyComponent(cd) {
        this.cd = cd;
        this.showTime = false;
        this.dateFormat = 'yyyy-MM-dd';
        this.valueChanged = new EventEmitter();
    }
    Object.defineProperty(DatePropertyComponent.prototype, "elementConfig", {
        get: /**
         * @return {?}
         */
        function () {
            return this._elementConfig;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._elementConfig = value;
            if (!this.elementConfig) {
                return;
            }
            this.maxDate = value.max;
            this.minDate = value.min;
            this.showTime = this.elementConfig.propertyType === 'datetime';
            this.dateFormat = this.elementConfig.propertyType === 'datetime' ? 'yyyy-MM-dd HH:mm:ss' : 'yyyy-MM-dd';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatePropertyComponent.prototype, "elementValue", {
        get: /**
         * @return {?}
         */
        function () {
            return this._elementValue;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._elementValue = value;
        },
        enumerable: true,
        configurable: true
    });
    // editType: string;
    // editType: string;
    /**
     * @return {?}
     */
    DatePropertyComponent.prototype.ngOnInit = 
    // editType: string;
    /**
     * @return {?}
     */
    function () {
        // this.editType = this.elementConfig && this.elementConfig.propertyType;
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    DatePropertyComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    DatePropertyComponent.prototype.changeValue = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        /** @type {?} */
        var value = $event.formatted;
        this.valueChanged.next({ $event: $event, elementValue: value });
    };
    DatePropertyComponent.decorators = [
        { type: Component, args: [{
                    selector: 'app-date-prop',
                    template: "\n        <farris-datepicker [(ngModel)]=\"elementValue\" [editable]=\"false\" [showTime]=\"showTime\"\n          [dateFormat]=\"dateFormat\" [readonly]=\"elementConfig.readonly\"\n          (valueChange)=\"changeValue($event)\" [returnType]=\"'string'\" [maxDate]=\"maxDate\"\n          [minDate]=\"minDate\">\n        </farris-datepicker>\n\n    "
                }] }
    ];
    /** @nocollapse */
    DatePropertyComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    DatePropertyComponent.propDecorators = {
        valueChanged: [{ type: Output }]
    };
    return DatePropertyComponent;
}());
export { DatePropertyComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    DatePropertyComponent.prototype._elementConfig;
    /**
     * @type {?}
     * @private
     */
    DatePropertyComponent.prototype._elementValue;
    /** @type {?} */
    DatePropertyComponent.prototype.maxDate;
    /** @type {?} */
    DatePropertyComponent.prototype.minDate;
    /** @type {?} */
    DatePropertyComponent.prototype.showTime;
    /** @type {?} */
    DatePropertyComponent.prototype.dateFormat;
    /** @type {?} */
    DatePropertyComponent.prototype.valueChanged;
    /**
     * @type {?}
     * @private
     */
    DatePropertyComponent.prototype.cd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL2lkZS1wcm9wZXJ0eS1wYW5lbC8iLCJzb3VyY2VzIjpbImxpYi9wcm9wZXJ0eS1wYW5lbC9jb250cm9scy9kYXRlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQTRCLE1BQU0sRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFHNUg7SUFrREUsK0JBQW9CLEVBQXFCO1FBQXJCLE9BQUUsR0FBRixFQUFFLENBQW1CO1FBaEN6QyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGVBQVUsR0FBRyxZQUFZLENBQUM7UUE2QmhCLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztJQUlqRCxDQUFDO0lBL0JELHNCQUFJLGdEQUFhOzs7O1FBQWpCO1lBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO1FBQzdCLENBQUM7Ozs7O1FBRUQsVUFBa0IsS0FBSztZQUVyQixJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDdkIsT0FBTzthQUNSO1lBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxLQUFLLFVBQVUsQ0FBQztZQUMvRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztRQUkxRyxDQUFDOzs7T0FmQTtJQWdCRCxzQkFBSSwrQ0FBWTs7OztRQUFoQjtZQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUM1QixDQUFDOzs7OztRQUVELFVBQWlCLEtBQUs7WUFDcEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7UUFDN0IsQ0FBQzs7O09BSkE7SUFhRCxvQkFBb0I7Ozs7O0lBR3BCLHdDQUFROzs7OztJQUFSO1FBQ0UseUVBQXlFO0lBQzNFLENBQUM7Ozs7O0lBQ0QsMkNBQVc7Ozs7SUFBWCxVQUFZLE9BQXNCO0lBRWxDLENBQUM7Ozs7O0lBQ0QsMkNBQVc7Ozs7SUFBWCxVQUFZLE1BQU07O1lBQ1YsS0FBSyxHQUFHLE1BQU0sQ0FBQyxTQUFTO1FBRTlCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxRQUFBLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDMUQsQ0FBQzs7Z0JBbkVGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsZUFBZTtvQkFDekIsUUFBUSxFQUFFLDhWQU9QO2lCQUNKOzs7O2dCQWJRLGlCQUFpQjs7OytCQW1EdkIsTUFBTTs7SUFxQlQsNEJBQUM7Q0FBQSxBQXJFRCxJQXFFQztTQTFEWSxxQkFBcUI7Ozs7OztJQUNoQywrQ0FBdUM7Ozs7O0lBQ3ZDLDhDQUEyQjs7SUFFM0Isd0NBQVE7O0lBQ1Isd0NBQVE7O0lBRVIseUNBQWlCOztJQUNqQiwyQ0FBMEI7O0lBNkIxQiw2Q0FBaUQ7Ozs7O0lBRXJDLG1DQUE2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT25Jbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUHJvcGVydHlFbnRpdHkgfSBmcm9tICcuLi9lbnRpdHkvcHJvcGVydHktZW50aXR5JztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnYXBwLWRhdGUtcHJvcCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZmFycmlzLWRhdGVwaWNrZXIgWyhuZ01vZGVsKV09XCJlbGVtZW50VmFsdWVcIiBbZWRpdGFibGVdPVwiZmFsc2VcIiBbc2hvd1RpbWVdPVwic2hvd1RpbWVcIlxyXG4gICAgICAgICAgW2RhdGVGb3JtYXRdPVwiZGF0ZUZvcm1hdFwiIFtyZWFkb25seV09XCJlbGVtZW50Q29uZmlnLnJlYWRvbmx5XCJcclxuICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJjaGFuZ2VWYWx1ZSgkZXZlbnQpXCIgW3JldHVyblR5cGVdPVwiJ3N0cmluZydcIiBbbWF4RGF0ZV09XCJtYXhEYXRlXCJcclxuICAgICAgICAgIFttaW5EYXRlXT1cIm1pbkRhdGVcIj5cclxuICAgICAgICA8L2ZhcnJpcy1kYXRlcGlja2VyPlxyXG5cclxuICAgIGBcclxufSlcclxuZXhwb3J0IGNsYXNzIERhdGVQcm9wZXJ0eUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcclxuICBwcml2YXRlIF9lbGVtZW50Q29uZmlnOiBQcm9wZXJ0eUVudGl0eTtcclxuICBwcml2YXRlIF9lbGVtZW50VmFsdWU6IGFueTtcclxuXHJcbiAgbWF4RGF0ZTtcclxuICBtaW5EYXRlO1xyXG5cclxuICBzaG93VGltZSA9IGZhbHNlO1xyXG4gIGRhdGVGb3JtYXQgPSAneXl5eS1NTS1kZCc7XHJcblxyXG4gIGdldCBlbGVtZW50Q29uZmlnKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRDb25maWc7XHJcbiAgfVxyXG5cclxuICBzZXQgZWxlbWVudENvbmZpZyh2YWx1ZSkge1xyXG5cclxuICAgIHRoaXMuX2VsZW1lbnRDb25maWcgPSB2YWx1ZTtcclxuICAgIGlmICghdGhpcy5lbGVtZW50Q29uZmlnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMubWF4RGF0ZSA9IHZhbHVlLm1heDtcclxuICAgIHRoaXMubWluRGF0ZSA9IHZhbHVlLm1pbjtcclxuICAgIHRoaXMuc2hvd1RpbWUgPSB0aGlzLmVsZW1lbnRDb25maWcucHJvcGVydHlUeXBlID09PSAnZGF0ZXRpbWUnO1xyXG4gICAgdGhpcy5kYXRlRm9ybWF0ID0gdGhpcy5lbGVtZW50Q29uZmlnLnByb3BlcnR5VHlwZSA9PT0gJ2RhdGV0aW1lJyA/ICd5eXl5LU1NLWRkIEhIOm1tOnNzJyA6ICd5eXl5LU1NLWRkJztcclxuXHJcblxyXG5cclxuICB9XHJcbiAgZ2V0IGVsZW1lbnRWYWx1ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50VmFsdWU7XHJcbiAgfVxyXG5cclxuICBzZXQgZWxlbWVudFZhbHVlKHZhbHVlKSB7XHJcbiAgICB0aGlzLl9lbGVtZW50VmFsdWUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG5cclxuICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmKSB7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gZWRpdFR5cGU6IHN0cmluZztcclxuXHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgLy8gdGhpcy5lZGl0VHlwZSA9IHRoaXMuZWxlbWVudENvbmZpZyAmJiB0aGlzLmVsZW1lbnRDb25maWcucHJvcGVydHlUeXBlO1xyXG4gIH1cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcblxyXG4gIH1cclxuICBjaGFuZ2VWYWx1ZSgkZXZlbnQpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gJGV2ZW50LmZvcm1hdHRlZDtcclxuXHJcbiAgICB0aGlzLnZhbHVlQ2hhbmdlZC5uZXh0KHsgJGV2ZW50LCBlbGVtZW50VmFsdWU6IHZhbHVlIH0pO1xyXG4gIH1cclxuXHJcbn1cclxuIl19