/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Input, Renderer2 } from '@angular/core';
import { DataTableBodyComponent } from './datatable-body.component';
var CellStylerDirective = /** @class */ (function () {
    function CellStylerDirective(dtb, elRef, render) {
        this.dtb = dtb;
        this.elRef = elRef;
        this.render = render;
        this.options = null;
    }
    /**
     * @return {?}
     */
    CellStylerDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.dtb && this.options) {
            var _a = this.options, val = _a.val, row = _a.row, col = _a.col, index = _a.index;
            /** @type {?} */
            var _sty_1 = null;
            if (!col) {
                _sty_1 = this.dtb.renderRowStyle(row, index) || {};
            }
            else {
                /** @type {?} */
                var rowStyle = this.dtb.renderRowStyle(row, index) || {};
                /** @type {?} */
                var cellStyle = this.dtb.renderCellStyle(val, row, index, col) || {};
                _sty_1 = cellStyle;
                if (col.fixed === 'right') {
                    /** @type {?} */
                    var hasBackground = Object.keys(cellStyle).find((/**
                     * @param {?} n
                     * @return {?}
                     */
                    function (n) {
                        return ['background', 'background-color', 'backgroundcolor'].indexOf(n.toLowerCase()) > -1;
                    }));
                    if (hasBackground !== null) {
                        _sty_1 = Object.assign(cellStyle, rowStyle);
                    }
                }
            }
            if (_sty_1) {
                Object.keys(_sty_1).forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                function (n) {
                    _this.elRef.nativeElement.style.setProperty(n, _sty_1[n], 'important');
                }));
            }
        }
    };
    CellStylerDirective.decorators = [
        { type: Directive, args: [{ selector: '[cell-styler]' },] }
    ];
    /** @nocollapse */
    CellStylerDirective.ctorParameters = function () { return [
        { type: DataTableBodyComponent },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    CellStylerDirective.propDecorators = {
        options: [{ type: Input, args: ['cell-styler',] }]
    };
    return CellStylerDirective;
}());
export { CellStylerDirective };
if (false) {
    /** @type {?} */
    CellStylerDirective.prototype.options;
    /**
     * @type {?}
     * @private
     */
    CellStylerDirective.prototype.dtb;
    /**
     * @type {?}
     * @private
     */
    CellStylerDirective.prototype.elRef;
    /**
     * @type {?}
     * @private
     */
    CellStylerDirective.prototype.render;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VsbC1zdHlsZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL3VpLWRhdGF0YWJsZS8iLCJzb3VyY2VzIjpbImxpYi90YWJsZS9jZWxsLXN0eWxlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFVLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUVwRTtJQUtJLDZCQUFvQixHQUEyQixFQUFVLEtBQWlCLEVBQVUsTUFBaUI7UUFBakYsUUFBRyxHQUFILEdBQUcsQ0FBd0I7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFZO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBVztRQUYvRSxZQUFPLEdBQUcsSUFBSSxDQUFDO0lBR3JDLENBQUM7Ozs7SUFFRCxzQ0FBUTs7O0lBQVI7UUFBQSxpQkEwQkM7UUF6QkcsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDcEIsSUFBQSxpQkFBcUMsRUFBcEMsWUFBRyxFQUFFLFlBQUcsRUFBRSxZQUFHLEVBQUUsZ0JBQXFCOztnQkFDdkMsTUFBSSxHQUFHLElBQUk7WUFDZixJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNOLE1BQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3BEO2lCQUFNOztvQkFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLEVBQUU7O29CQUNwRCxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRTtnQkFDbkUsTUFBSSxHQUFHLFNBQVMsQ0FBQztnQkFDakIsSUFBSSxHQUFHLENBQUMsS0FBSyxLQUFLLE9BQU8sRUFBRTs7d0JBQ2pCLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUk7Ozs7b0JBQUMsVUFBQSxDQUFDO3dCQUMvQyxPQUFPLENBQUMsWUFBWSxFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUMvRixDQUFDLEVBQUM7b0JBQ0YsSUFBSSxhQUFhLEtBQUssSUFBSSxFQUFFO3dCQUN4QixNQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7cUJBQzdDO2lCQUNKO2FBQ0o7WUFFRCxJQUFJLE1BQUksRUFBRTtnQkFDTixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQUksQ0FBQyxDQUFDLE9BQU87Ozs7Z0JBQUMsVUFBQSxDQUFDO29CQUN2QixLQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxNQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7Z0JBQ3hFLENBQUMsRUFBQyxDQUFDO2FBQ047U0FDSjtJQUNMLENBQUM7O2dCQWxDSixTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFOzs7O2dCQUYvQixzQkFBc0I7Z0JBRFgsVUFBVTtnQkFBaUIsU0FBUzs7OzBCQU1uRCxLQUFLLFNBQUMsYUFBYTs7SUFnQ3hCLDBCQUFDO0NBQUEsQUFuQ0QsSUFtQ0M7U0FsQ1ksbUJBQW1COzs7SUFFNUIsc0NBQXFDOzs7OztJQUV6QixrQ0FBbUM7Ozs7O0lBQUUsb0NBQXlCOzs7OztJQUFFLHFDQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uSW5pdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERhdGFUYWJsZUJvZHlDb21wb25lbnQgfSBmcm9tICcuL2RhdGF0YWJsZS1ib2R5LmNvbXBvbmVudCc7XHJcblxyXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2VsbC1zdHlsZXJdJyB9KVxyXG5leHBvcnQgY2xhc3MgQ2VsbFN0eWxlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gICAgQElucHV0KCdjZWxsLXN0eWxlcicpIG9wdGlvbnMgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZHRiOiBEYXRhVGFibGVCb2R5Q29tcG9uZW50LCBwcml2YXRlIGVsUmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyKSB7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHRiICYmIHRoaXMub3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCB7dmFsLCByb3csIGNvbCwgaW5kZXh9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICBsZXQgX3N0eSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghY29sKSB7XHJcbiAgICAgICAgICAgICAgICBfc3R5ID0gdGhpcy5kdGIucmVuZGVyUm93U3R5bGUocm93LCBpbmRleCkgfHwge307XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm93U3R5bGUgPSB0aGlzLmR0Yi5yZW5kZXJSb3dTdHlsZShyb3csIGluZGV4KSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGxldCBjZWxsU3R5bGUgPSB0aGlzLmR0Yi5yZW5kZXJDZWxsU3R5bGUodmFsLCByb3csaW5kZXgsIGNvbCkgfHwge307XHJcbiAgICAgICAgICAgICAgICBfc3R5ID0gY2VsbFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbC5maXhlZCA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0JhY2tncm91bmQgPSBPYmplY3Qua2V5cyhjZWxsU3R5bGUpLmZpbmQobiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2JhY2tncm91bmQnLCAnYmFja2dyb3VuZC1jb2xvcicsICdiYWNrZ3JvdW5kY29sb3InXS5pbmRleE9mKG4udG9Mb3dlckNhc2UoKSkgPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQmFja2dyb3VuZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3R5ID0gT2JqZWN0LmFzc2lnbihjZWxsU3R5bGUsIHJvd1N0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX3N0eSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX3N0eSkuZm9yRWFjaChuID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkobiwgX3N0eVtuXSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iXX0=