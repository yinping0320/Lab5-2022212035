/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { en, zh_CHS, zh_CHT } from './lang';
/** @type {?} */
var SEC_ARRAY = [
    60,
    60,
    24,
    7,
    365 / 7 / 12,
    12,
];
/**
 * @param {?=} input
 * @return {?}
 */
export function toDate(input) {
    if (input instanceof Date)
        return input;
    // @ts-ignore
    if (!isNaN(input) || /^\d+$/.test(input))
        return new Date(parseInt(input));
    input = (input || '')
        // @ts-ignore
        .trim()
        .replace(/\.\d+/, '') // remove milliseconds
        .replace(/-/, '/')
        .replace(/-/, '/')
        .replace(/(\d)T(\d)/, '$1 $2')
        .replace(/Z/, ' UTC') // 2017-2-5T3:57:52Z -> 2017-2-5 3:57:52UTC
        .replace(/([+-]\d\d):?(\d\d)/, ' $1$2'); // -04:00 -> -0400
    return new Date(input);
}
/**
 * format the diff second to *** time ago, with setting locale
 * @param {?} diff
 * @param {?} localeFunc
 * @return {?}
 */
export function formatDiff(diff, localeFunc) {
    /**
     * if locale is not exist, use defaultLocale.
     * if defaultLocale is not exist, use build-in `en`.
     * be sure of no error when locale is not exist.
     *
     * If `time in`, then 1
     * If `time ago`, then 0
     * @type {?}
     */
    var agoIn = diff < 0 ? 1 : 0;
    /**
     * Get absolute value of number (|diff| is non-negative) value of x
     * |diff| = diff if diff is positive
     * |diff| = -diff if diff is negative
     * |0| = 0
     */
    diff = Math.abs(diff);
    /**
     * Time in seconds
     * @type {?}
     */
    var totalSec = diff;
    /**
     * Unit of time
     * @type {?}
     */
    var idx = 0;
    for (; diff >= SEC_ARRAY[idx] && idx < SEC_ARRAY.length; idx++) {
        diff /= SEC_ARRAY[idx];
    }
    /**
     * Math.floor() is alternative of ~~
     *
     * The differences and bugs:
     * Math.floor(3.7) -> 4 but ~~3.7 -> 3
     * Math.floor(1559125440000.6) -> 1559125440000 but ~~1559125440000.6 -> 52311552
     *
     * More information about the performance of algebraic:
     * https://www.youtube.com/watch?v=65-RbBwZQdU
     */
    diff = Math.floor(diff);
    idx *= 2;
    if (diff > (idx === 0 ? 9 : 1))
        idx += 1;
    return localeFunc(diff, idx, totalSec)[agoIn].replace('%s', diff.toString());
}
/**
 * calculate the diff second between date to be formatted an now date.
 * @param {?} date
 * @param {?} relativeDate
 * @return {?}
 */
export function diffSec(date, relativeDate) {
    /** @type {?} */
    var relDate = relativeDate ? toDate(relativeDate) : new Date();
    return (+relDate - +toDate(date)) / 1000;
}
/**
 * nextInterval: calculate the next interval time.
 * - diff: the diff sec between now and date to be formatted.
 *
 * What's the meaning?
 * diff = 61 then return 59
 * diff = 3601 (an hour + 1 second), then return 3599
 * make the interval with high performance.
 *
 * @param {?} diff
 * @return {?}
 */
export function nextInterval(diff) {
    /** @type {?} */
    var rst = 1;
    /** @type {?} */
    var i = 0;
    /** @type {?} */
    var d = Math.abs(diff);
    for (; diff >= SEC_ARRAY[i] && i < SEC_ARRAY.length; i++) {
        diff /= SEC_ARRAY[i];
        rst *= SEC_ARRAY[i];
    }
    d = d % rst;
    d = d ? rst - d : rst;
    return Math.ceil(d);
}
/** @type {?} */
export var format = (/**
 * @param {?} date
 * @param {?=} locale
 * @param {?=} opts
 * @return {?}
 */
function (date, locale, opts) {
    // diff seconds
    /** @type {?} */
    var sec = diffSec(date, opts && opts.relativeDate);
    // format it with locale
    return formatDiff(sec, getLocale(locale));
});
/**
 * All supported locales
 * @type {?}
 */
var Locales = {};
/**
 * register a locale
 * \@param locale
 * \@param func
 * @type {?}
 */
export var register = (/**
 * @param {?} locale
 * @param {?} func
 * @return {?}
 */
function (locale, func) {
    Locales[locale] = func;
});
/**
 * get a locale, default is en_US
 * \@param locale
 * @type {?}
 */
export var getLocale = (/**
 * @param {?} locale
 * @return {?}
 */
function (locale) {
    return Locales[locale] || Locales['zh-CHS'];
});
register('en', en);
register('zh-CHS', zh_CHS);
register('zh-CHT', zh_CHT);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZWFnby5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvdWktY29tbW9uL2RhdGUvIiwic291cmNlcyI6WyJsaWIvdGltZWFnby90aW1lYWdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUMsTUFBTSxRQUFRLENBQUM7O0lBaUJwQyxTQUFTLEdBQUc7SUFDZCxFQUFFO0lBQ0YsRUFBRTtJQUNGLEVBQUU7SUFDRixDQUFDO0lBQ0QsR0FBRyxHQUFHLENBQUMsR0FBRyxFQUFFO0lBQ1osRUFBRTtDQUNMOzs7OztBQUVELE1BQU0sVUFBVSxNQUFNLENBQUMsS0FBOEI7SUFDakQsSUFBSSxLQUFLLFlBQVksSUFBSTtRQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ3hDLGFBQWE7SUFDYixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUMzRSxLQUFLLEdBQUcsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDO1FBQ2pCLGFBQWE7U0FDWixJQUFJLEVBQUU7U0FDTixPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDLHNCQUFzQjtTQUMzQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQztTQUNqQixPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQztTQUNqQixPQUFPLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQztTQUM3QixPQUFPLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLDJDQUEyQztTQUNoRSxPQUFPLENBQUMsb0JBQW9CLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxrQkFBa0I7SUFDL0QsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzQixDQUFDOzs7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LFVBQUMsTUFBYztJQUNwQyxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDaEQsQ0FBQyxDQUFBO0FBR0QsUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNuQixRQUFRLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzNCLFFBQVEsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2VuLCB6aF9DSFMsIHpoX0NIVH0gZnJvbSAnLi9sYW5nJztcclxuXHJcbmV4cG9ydCB0eXBlIFREYXRlID0gRGF0ZSB8IHN0cmluZyB8IG51bWJlcjtcclxuZXhwb3J0IHR5cGUgTG9jYWxlRnVuYyA9IChkaWZmOiBudW1iZXIsIGlkeDogbnVtYmVyLCB0b3RhbFNlYz86IG51bWJlcikgPT4gW3N0cmluZywgc3RyaW5nXTtcclxuZXhwb3J0IHR5cGUgTG9jYWxlTWFwID0gUmVjb3JkPHN0cmluZywgTG9jYWxlRnVuYz47XHJcblxyXG4vKipcclxuICogcmVuZGVyIC8gZm9ybWF0IG9wdGlvbnNcclxuICovXHJcbiBleHBvcnQgdHlwZSBPcHRzID0ge1xyXG4gICAgLyoqIHRoZSByZWxhdGl2ZSBkYXRlICovXHJcbiAgICByZWFkb25seSByZWxhdGl2ZURhdGU/OiBURGF0ZTtcclxuICAgIC8qKiB0aGUgcmVhbHRpbWUgKi9cclxuICAgIHJlYWRvbmx5IG1pbkludGVydmFsPzogbnVtYmVyO1xyXG4gIH07XHJcbiAgXHJcblxyXG5jb25zdCBTRUNfQVJSQVkgPSBbXHJcbiAgICA2MCwgLy8gNjAgc2Vjb25kcyBpbiAxIG1pblxyXG4gICAgNjAsIC8vIDYwIG1pbnMgaW4gMSBob3VyXHJcbiAgICAyNCwgLy8gMjQgaG91cnMgaW4gMSBkYXlcclxuICAgIDcsIC8vIDcgZGF5cyBpbiAxIHdlZWtcclxuICAgIDM2NSAvIDcgLyAxMiwgLy8gNC4zNDUyMzgwOTUyMzgwOTYgd2Vla3MgaW4gMSBtb250aFxyXG4gICAgMTIsIC8vIDEyIG1vbnRocyBpbiAxIHllYXJcclxuXTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0RhdGUoaW5wdXQ/OiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogRGF0ZSB7XHJcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gaW5wdXQ7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBpZiAoIWlzTmFOKGlucHV0KSB8fCAvXlxcZCskLy50ZXN0KGlucHV0KSkgcmV0dXJuIG5ldyBEYXRlKHBhcnNlSW50KGlucHV0KSk7XHJcbiAgICBpbnB1dCA9IChpbnB1dCB8fCAnJylcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgLnRyaW0oKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXC5cXGQrLywgJycpIC8vIHJlbW92ZSBtaWxsaXNlY29uZHNcclxuICAgICAgICAucmVwbGFjZSgvLS8sICcvJylcclxuICAgICAgICAucmVwbGFjZSgvLS8sICcvJylcclxuICAgICAgICAucmVwbGFjZSgvKFxcZClUKFxcZCkvLCAnJDEgJDInKVxyXG4gICAgICAgIC5yZXBsYWNlKC9aLywgJyBVVEMnKSAvLyAyMDE3LTItNVQzOjU3OjUyWiAtPiAyMDE3LTItNSAzOjU3OjUyVVRDXHJcbiAgICAgICAgLnJlcGxhY2UoLyhbKy1dXFxkXFxkKTo/KFxcZFxcZCkvLCAnICQxJDInKTsgLy8gLTA0OjAwIC0+IC0wNDAwXHJcbiAgICByZXR1cm4gbmV3IERhdGUoaW5wdXQpO1xyXG59XHJcblxyXG4vKipcclxuICogZm9ybWF0IHRoZSBkaWZmIHNlY29uZCB0byAqKiogdGltZSBhZ28sIHdpdGggc2V0dGluZyBsb2NhbGVcclxuICogQHBhcmFtIGRpZmZcclxuICogQHBhcmFtIGxvY2FsZUZ1bmNcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREaWZmKGRpZmY6IG51bWJlciwgbG9jYWxlRnVuYzogTG9jYWxlRnVuYyk6IHN0cmluZyB7XHJcbiAgICAvKipcclxuICAgICAqIGlmIGxvY2FsZSBpcyBub3QgZXhpc3QsIHVzZSBkZWZhdWx0TG9jYWxlLlxyXG4gICAgICogaWYgZGVmYXVsdExvY2FsZSBpcyBub3QgZXhpc3QsIHVzZSBidWlsZC1pbiBgZW5gLlxyXG4gICAgICogYmUgc3VyZSBvZiBubyBlcnJvciB3aGVuIGxvY2FsZSBpcyBub3QgZXhpc3QuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYHRpbWUgaW5gLCB0aGVuIDFcclxuICAgICAqIElmIGB0aW1lIGFnb2AsIHRoZW4gMFxyXG4gICAgICovXHJcbiAgICBjb25zdCBhZ29JbiA9IGRpZmYgPCAwID8gMSA6IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWJzb2x1dGUgdmFsdWUgb2YgbnVtYmVyICh8ZGlmZnwgaXMgbm9uLW5lZ2F0aXZlKSB2YWx1ZSBvZiB4XHJcbiAgICAgKiB8ZGlmZnwgPSBkaWZmIGlmIGRpZmYgaXMgcG9zaXRpdmVcclxuICAgICAqIHxkaWZmfCA9IC1kaWZmIGlmIGRpZmYgaXMgbmVnYXRpdmVcclxuICAgICAqIHwwfCA9IDBcclxuICAgICAqL1xyXG4gICAgZGlmZiA9IE1hdGguYWJzKGRpZmYpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZSBpbiBzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHRvdGFsU2VjID0gZGlmZjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuaXQgb2YgdGltZVxyXG4gICAgICovXHJcbiAgICBsZXQgaWR4ID0gMDtcclxuXHJcbiAgICBmb3IgKDsgZGlmZiA+PSBTRUNfQVJSQVlbaWR4XSAmJiBpZHggPCBTRUNfQVJSQVkubGVuZ3RoOyBpZHgrKykge1xyXG4gICAgICAgIGRpZmYgLz0gU0VDX0FSUkFZW2lkeF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRoLmZsb29yKCkgaXMgYWx0ZXJuYXRpdmUgb2Ygfn5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGlmZmVyZW5jZXMgYW5kIGJ1Z3M6XHJcbiAgICAgKiBNYXRoLmZsb29yKDMuNykgLT4gNCBidXQgfn4zLjcgLT4gM1xyXG4gICAgICogTWF0aC5mbG9vcigxNTU5MTI1NDQwMDAwLjYpIC0+IDE1NTkxMjU0NDAwMDAgYnV0IH5+MTU1OTEyNTQ0MDAwMC42IC0+IDUyMzExNTUyXHJcbiAgICAgKlxyXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGVyZm9ybWFuY2Ugb2YgYWxnZWJyYWljOlxyXG4gICAgICogaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj02NS1SYkJ3WlFkVVxyXG4gICAgICovXHJcbiAgICBkaWZmID0gTWF0aC5mbG9vcihkaWZmKTtcclxuXHJcbiAgICBpZHggKj0gMjtcclxuXHJcbiAgICBpZiAoZGlmZiA+IChpZHggPT09IDAgPyA5IDogMSkpIGlkeCArPSAxO1xyXG5cclxuICAgIHJldHVybiBsb2NhbGVGdW5jKGRpZmYsIGlkeCwgdG90YWxTZWMpW2Fnb0luXS5yZXBsYWNlKCclcycsIGRpZmYudG9TdHJpbmcoKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGRpZmYgc2Vjb25kIGJldHdlZW4gZGF0ZSB0byBiZSBmb3JtYXR0ZWQgYW4gbm93IGRhdGUuXHJcbiAqIEBwYXJhbSBkYXRlXHJcbiAqIEBwYXJhbSByZWxhdGl2ZURhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaWZmU2VjKGRhdGU6IFREYXRlLCByZWxhdGl2ZURhdGU6IFREYXRlKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IHJlbERhdGUgPSByZWxhdGl2ZURhdGUgPyB0b0RhdGUocmVsYXRpdmVEYXRlKSA6IG5ldyBEYXRlKCk7XHJcbiAgICByZXR1cm4gKCtyZWxEYXRlIC0gK3RvRGF0ZShkYXRlKSkgLyAxMDAwO1xyXG59XHJcblxyXG4vKipcclxuICogbmV4dEludGVydmFsOiBjYWxjdWxhdGUgdGhlIG5leHQgaW50ZXJ2YWwgdGltZS5cclxuICogLSBkaWZmOiB0aGUgZGlmZiBzZWMgYmV0d2VlbiBub3cgYW5kIGRhdGUgdG8gYmUgZm9ybWF0dGVkLlxyXG4gKlxyXG4gKiBXaGF0J3MgdGhlIG1lYW5pbmc/XHJcbiAqIGRpZmYgPSA2MSB0aGVuIHJldHVybiA1OVxyXG4gKiBkaWZmID0gMzYwMSAoYW4gaG91ciArIDEgc2Vjb25kKSwgdGhlbiByZXR1cm4gMzU5OVxyXG4gKiBtYWtlIHRoZSBpbnRlcnZhbCB3aXRoIGhpZ2ggcGVyZm9ybWFuY2UuXHJcbiAqKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5leHRJbnRlcnZhbChkaWZmOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgbGV0IHJzdCA9IDEsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgZCA9IE1hdGguYWJzKGRpZmYpO1xyXG4gICAgZm9yICg7IGRpZmYgPj0gU0VDX0FSUkFZW2ldICYmIGkgPCBTRUNfQVJSQVkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBkaWZmIC89IFNFQ19BUlJBWVtpXTtcclxuICAgICAgICByc3QgKj0gU0VDX0FSUkFZW2ldO1xyXG4gICAgfVxyXG4gICAgZCA9IGQgJSByc3Q7XHJcbiAgICBkID0gZCA/IHJzdCAtIGQgOiByc3Q7XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKGQpO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGZvcm1hdCA9IChkYXRlOiBURGF0ZSwgbG9jYWxlPzogc3RyaW5nLCBvcHRzPzogT3B0cyk6IHN0cmluZyA9PiB7XHJcbiAgICAvLyBkaWZmIHNlY29uZHNcclxuICAgIGNvbnN0IHNlYyA9IGRpZmZTZWMoZGF0ZSwgb3B0cyAmJiBvcHRzLnJlbGF0aXZlRGF0ZSk7XHJcbiAgICAvLyBmb3JtYXQgaXQgd2l0aCBsb2NhbGVcclxuICAgIHJldHVybiBmb3JtYXREaWZmKHNlYywgZ2V0TG9jYWxlKGxvY2FsZSkpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBbGwgc3VwcG9ydGVkIGxvY2FsZXNcclxuICovXHJcbmNvbnN0IExvY2FsZXM6IExvY2FsZU1hcCA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIHJlZ2lzdGVyIGEgbG9jYWxlXHJcbiAqIEBwYXJhbSBsb2NhbGVcclxuICogQHBhcmFtIGZ1bmNcclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlciA9IChsb2NhbGU6IHN0cmluZywgZnVuYzogTG9jYWxlRnVuYykgPT4ge1xyXG4gICAgTG9jYWxlc1tsb2NhbGVdID0gZnVuYztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBnZXQgYSBsb2NhbGUsIGRlZmF1bHQgaXMgZW5fVVNcclxuICogQHBhcmFtIGxvY2FsZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldExvY2FsZSA9IChsb2NhbGU6IHN0cmluZyk6IExvY2FsZUZ1bmMgPT4ge1xyXG4gICAgcmV0dXJuIExvY2FsZXNbbG9jYWxlXSB8fCBMb2NhbGVzWyd6aC1DSFMnXTtcclxufTtcclxuXHJcblxyXG5yZWdpc3RlcignZW4nLCBlbik7XHJcbnJlZ2lzdGVyKCd6aC1DSFMnLCB6aF9DSFMpO1xyXG5yZWdpc3RlcignemgtQ0hUJywgemhfQ0hUKTtcclxuXHJcblxyXG4iXX0=