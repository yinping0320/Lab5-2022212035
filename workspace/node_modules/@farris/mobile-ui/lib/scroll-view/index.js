import { nextTick, openBlock, createBlock, renderSlot, createCommentVNode, createVNode } from 'vue';

// export const isProd = process.env.NODE_ENV === 'production';
var root = typeof window !== 'undefined' ? window : global;
var inBrowser = typeof window !== 'undefined';
function noop() {}
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
function debounce(fn, delay) {
  if (fn === void 0) {
    fn = noop;
  }

  if (delay === void 0) {
    delay = 300;
  }

  var timer = null;
  return function () {
    var context = this;
    var args = arguments;

    if (timer) {
      clearTimeout(timer);
    }

    timer = setTimeout(function () {
      fn.apply(context, args);
    }, delay);
  };
}

/* istanbul ignore file */

var Animate = function (global) {
  /* istanbul ignore next */
  var time = Date.now || function () {
    return +new Date();
  };

  var desiredFrames = 60;
  var millisecondsPerSecond = 1000;
  var running = {};
  var counter = 1;
  return {
    /**
     * A requestAnimationFrame wrapper / polyfill.
     *
     * @param callback {Function} The callback to be invoked before the next repaint.
     * @param root {HTMLElement} The root element for the repaint
     */
    requestAnimationFrame: function () {
      // Check for request animation Frame support
      var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
      var isNative = !!requestFrame;

      if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
        isNative = false;
      }

      if (isNative) {
        return function (callback, root) {
          requestFrame(callback, root);
        };
      }

      var TARGET_FPS = 60;
      var requests = {};
      var rafHandle = 1;
      var intervalHandle = null;
      var lastActive = +new Date();
      return function (callback) {
        var callbackHandle = rafHandle++; // Store callback

        requests[callbackHandle] = callback;

        if (intervalHandle === null) {
          intervalHandle = setInterval(function () {
            var time = +new Date();
            var currentRequests = requests; // Reset data structure before executing callbacks

            requests = {};

            for (var key in currentRequests) {
              if (currentRequests.hasOwnProperty(key)) {
                currentRequests[key](time);
                lastActive = time;
              }
            } // Disable the timeout when nothing happens for a certain
            // period of time


            if (time - lastActive > 2500) {
              clearInterval(intervalHandle);
              intervalHandle = null;
            }
          }, 1000 / TARGET_FPS);
        }

        return callbackHandle;
      };
    }(),

    /**
     * Stops the given animation.
     *
     * @param id {Integer} Unique animation ID
     * @return {Boolean} Whether the animation was stopped (aka, was running before)
     */
    stop: function stop(id) {
      var cleared = running[id] != null;
      cleared && (running[id] = null);
      return cleared;
    },

    /**
     * Whether the given animation is still running.
     *
     * @param id {Integer} Unique animation ID
     * @return {Boolean} Whether the animation is still running
     */
    isRunning: function isRunning(id) {
      return running[id] != null;
    },

    /**
     * Start the animation.
     *
     * @param stepCallback {Function} Pointer to function which is executed on every step.
     *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`
     * @param verifyCallback {Function} Executed before every animation step.
     *   Signature of the method should be `function() { return continueWithAnimation; }`
     * @param completedCallback {Function}
     *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`
     * @param duration {Integer} Milliseconds to run the animation
     * @param easingMethod {Function} Pointer to easing function
     *   Signature of the method should be `function(percent) { return modifiedValue; }`
     * @param root {Element ? document.body} Render root, when available. Used for internal
     *   usage of requestAnimationFrame.
     * @return {Integer} Identifier of animation. Can be used to stop it any time.
     */
    start: function start(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
      var _this = this;

      var start = time();
      var lastFrame = start;
      var percent = 0;
      var dropCounter = 0;
      var id = counter++;

      if (!root) {
        root = document.body;
      } // Compacting running db automatically every few new animations


      if (id % 20 === 0) {
        var newRunning = {};

        for (var usedId in running) {
          newRunning[usedId] = true;
        }

        running = newRunning;
      } // This is the internal step method which is called every few milliseconds


      var step = function step(virtual) {
        // Normalize virtual value
        var render = virtual !== true; // Get current time

        var now = time(); // Verification is executed before next animation step

        if (!running[id] || verifyCallback && !verifyCallback(id)) {
          running[id] = null;
          completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, false);
          return;
        } // For the current rendering to apply let's update omitted steps in memory.
        // This is important to bring internal state variables up-to-date with progress in time.


        if (render) {
          var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;

          for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
            step(true);
            dropCounter++;
          }
        } // Compute percent value


        if (duration) {
          percent = (now - start) / duration;

          if (percent > 1) {
            percent = 1;
          }
        } // Execute step callback, then...


        var value = easingMethod ? easingMethod(percent) : percent;
        value = isNaN(value) ? 0 : value;

        if ((stepCallback(value, now, render) === false || percent === 1) && render) {
          running[id] = null;
          completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, percent === 1 || duration == null);
        } else if (render) {
          lastFrame = now;

          _this.requestAnimationFrame(step, root);
        }
      }; // Mark as running


      running[id] = true; // Init first step

      this.requestAnimationFrame(step, root); // Return unique animation ID

      return id;
    }
  };
}(root);

var easeOutCubic = function easeOutCubic(pos) {
  return Math.pow(pos - 1, 3) + 1;
};
var easeInOutCubic = function easeInOutCubic(pos) {
  if ((pos /= 0.5) < 1) {
    return 0.5 * Math.pow(pos, 3);
  }

  return 0.5 * (Math.pow(pos - 2, 3) + 2);
};

var members = {
  _isSingleTouch: false,
  _isTracking: false,
  _didDecelerationComplete: false,
  _isGesturing: false,
  _isDragging: false,
  _isDecelerating: false,
  _isAnimating: false,
  _clientLeft: 0,
  _clientTop: 0,
  _clientWidth: 0,
  _clientHeight: 0,
  _contentWidth: 0,
  _contentHeight: 0,
  _snapWidth: 100,
  _snapHeight: 100,
  _refreshHeight: null,
  _refreshActive: false,
  _refreshActivate: null,
  _refreshDeactivate: null,
  _refreshStart: null,
  _zoomLevel: 1,
  _scrollLeft: 0,
  _scrollTop: 0,
  _maxScrollLeft: 0,
  _maxScrollTop: 0,
  _scheduledLeft: 0,
  _scheduledTop: 0,
  _lastTouchLeft: null,
  _lastTouchTop: null,
  _lastTouchMove: null,
  _positions: null,
  _minDecelerationScrollLeft: null,
  _minDecelerationScrollTop: null,
  _maxDecelerationScrollLeft: null,
  _maxDecelerationScrollTop: null,
  _decelerationVelocityX: null,
  _decelerationVelocityY: null
};
/* istanbul ignore next */

var Scroller = /*#__PURE__*/function () {
  function Scroller(callback, options) {
    if (callback === void 0) {
      callback = noop;
    }

    this.options = {
      scrollingX: true,
      scrollingY: true,
      animating: true,
      animationDuration: 250,
      inRequestAnimationFrame: false,
      bouncing: true,
      locking: true,
      paging: false,
      snapping: false,
      snappingVelocity: 4,
      zooming: false,
      minZoom: 0.5,
      maxZoom: 3,
      speedMultiplier: 1,
      scrollingComplete: noop,
      penetrationDeceleration: 0.03,
      penetrationAcceleration: 0.08
    };
    extend(this.options, options);
    this._callback = callback;
  }
  /**
   * Configures the dimensions of the client (outer) and content (inner) elements.
   * Requires the available space for the outer element and the outer size of the inner element.
   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.
   *
   * @param clientWidth {Integer ? null} Inner width of outer element
   * @param clientHeight {Integer ? null} Inner height of outer element
   * @param contentWidth {Integer ? null} Outer width of inner element
   * @param contentHeight {Integer ? null} Outer height of inner element
   */


  var _proto = Scroller.prototype;

  _proto.setDimensions = function setDimensions(clientWidth, clientHeight, contentWidth, contentHeight) {
    // Only update values which are defined
    if (clientWidth === +clientWidth) {
      this._clientWidth = clientWidth;
    }

    if (clientHeight === +clientHeight) {
      this._clientHeight = clientHeight;
    }

    if (contentWidth === +contentWidth) {
      this._contentWidth = contentWidth;
    }

    if (contentHeight === +contentHeight) {
      this._contentHeight = contentHeight;
    } // Refresh maximums


    this._computeScrollMax(); // Refresh scroll position


    this.scrollTo(this._scrollLeft, this._scrollTop, true);
  }
  /**
   * Sets the client coordinates in relation to the document.
   *
   * @param left {Integer ? 0} Left position of outer element
   * @param top {Integer ? 0} Top position of outer element
   */
  ;

  _proto.setPosition = function setPosition(left, top) {
    this._clientLeft = left || 0;
    this._clientTop = top || 0;
  }
  /**
   * Configures the snapping (when snapping is active)
   *
   * @param width {Integer} Snapping width
   * @param height {Integer} Snapping height
   */
  ;

  _proto.setSnapSize = function setSnapSize(width, height) {
    this._snapWidth = width;
    this._snapHeight = height;
  }
  /**
   * Returns the scroll position and zooming values
   *
   * @return {Map} `left` and `top` scroll position and `zoom` level
   */
  ;

  _proto.getValues = function getValues() {
    return {
      left: this._scrollLeft,
      top: this._scrollTop,
      zoom: this._zoomLevel
    };
  }
  /**
   * Returns the maximum scroll values
   *
   * @return {Map} `left` and `top` maximum scroll values
   */
  ;

  _proto.getScrollMax = function getScrollMax() {
    return {
      left: this._maxScrollLeft,
      top: this._maxScrollTop
    };
  }
  /**
   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever
   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like
   * the official Twitter client.
   *
   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list
   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.
   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.
   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.
   */
  ;

  _proto.activatePullToRefresh = function activatePullToRefresh(height, activateCallback, deactivateCallback, startCallback) {
    this._refreshHeight = height;
    this._refreshActivate = activateCallback;
    this._refreshDeactivate = deactivateCallback;
    this._refreshStart = startCallback;
  }
  /**
   * Starts pull-to-refresh manually.
   */
  ;

  _proto.triggerPullToRefresh = function triggerPullToRefresh() {
    // Use publish instead of scrollTo to allow scrolling to out of boundary position
    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled
    this._publish(this._scrollLeft, -this._refreshHeight, this._zoomLevel, true);

    if (this._refreshStart) {
      this._refreshStart();
    }
  }
  /**
   * Signalizes that pull-to-refresh is finished.
   */
  ;

  _proto.finishPullToRefresh = function finishPullToRefresh() {
    this._refreshActive = false;

    if (this._refreshDeactivate) {
      this._refreshDeactivate();
    }

    this.scrollTo(this._scrollLeft, this._scrollTop, true);
  }
  /**
   * Scrolls to the given position. Respect limitations and snapping automatically.
   *
   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>
   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>
   * @param animate {Boolean?false} Whether the scrolling should happen using an animation
   * @param zoom {Number?null} Zoom level to go to
   */
  ;

  _proto.scrollTo = function scrollTo(left, top, animate, zoom) {
    if (zoom === void 0) {
      zoom = 1;
    }

    // Stop deceleration
    if (this._isDecelerating) {
      Animate.stop(this._isDecelerating);
      this._isDecelerating = false;
    } // Correct coordinates based on new zoom level


    if (zoom != null && zoom !== this._zoomLevel) {
      if (!this.options.zooming) ;

      zoom = zoom ? zoom : 1;
      left *= zoom;
      top *= zoom; // // Recompute maximum values while temporary tweaking maximum scroll ranges

      this._computeScrollMax(zoom);
    } else {
      // Keep zoom when not defined
      zoom = this._zoomLevel;
    }

    if (!this.options.scrollingX) {
      left = this._scrollLeft;
    } else {
      if (this.options.paging) {
        left = Math.round(left / this._clientWidth) * this._clientWidth;
      } else if (this.options.snapping) {
        left = Math.round(left / this._snapWidth) * this._snapWidth;
      }
    }

    if (!this.options.scrollingY) {
      top = this._scrollTop;
    } else {
      if (this.options.paging) {
        top = Math.round(top / this._clientHeight) * this._clientHeight;
      } else if (this.options.snapping) {
        top = Math.round(top / this._snapHeight) * this._snapHeight;
      }
    } // Limit for allowed ranges


    left = Math.max(Math.min(this._maxScrollLeft, left), 0);
    top = Math.max(Math.min(this._maxScrollTop, top), 0); // Don't animate when no change detected, still call publish to make sure
    // that rendered position is really in-sync with internal data

    if (left === this._scrollLeft && top === this._scrollTop) {
      animate = false;
    } // Publish new values


    if (!this._isTracking) {
      this._publish(left, top, zoom, animate);
    }
  }
  /**
   * Zooms to the given level. Supports optional animation. Zooms
   * the center when no coordinates are given.
   *
   * @param level {Number} Level to zoom to
   * @param animate {Boolean ? false} Whether to use animation
   * @param originLeft {Number ? null} Zoom in at given left coordinate
   * @param originTop {Number ? null} Zoom in at given top coordinate
   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.
   */
  ;

  _proto.zoomTo = function zoomTo(level, animate, originLeft, originTop, callback) {
    if (!this.options.zooming) ; // Add callback if exists


    if (callback) {
      this._zoomComplete = callback;
    } // Stop deceleration


    if (this._isDecelerating) {
      Animate.stop(this._isDecelerating);
      this._isDecelerating = false;
    }

    var oldLevel = this._zoomLevel; // Normalize input origin to center of viewport if not defined

    if (originLeft == null) {
      originLeft = this._clientWidth / 2;
    }

    if (originTop == null) {
      originTop = this._clientHeight / 2;
    } // Limit level according to configuration


    level = Math.max(Math.min(level, this.options.maxZoom), this.options.minZoom); // Recompute maximum values while temporary tweaking maximum scroll ranges

    this._computeScrollMax(level); // Recompute left and top coordinates based on new zoom level


    var left = (originLeft + this._scrollLeft) * level / oldLevel - originLeft;
    var top = (originTop + this._scrollTop) * level / oldLevel - originTop; // Limit x-axis

    if (left > this._maxScrollLeft) {
      left = this._maxScrollLeft;
    } else if (left < 0) {
      left = 0;
    } // Limit y-axis


    if (top > this._maxScrollTop) {
      top = this._maxScrollTop;
    } else if (top < 0) {
      top = 0;
    } // Push values out


    this._publish(left, top, level, animate);
  };

  _proto.doTouchStart = function doTouchStart(touches, timeStamp) {
    // Array-like check is enough here
    if (touches.length == null) ;

    if (timeStamp instanceof Date) {
      timeStamp = timeStamp.valueOf();
    }


    this._interruptedAnimation = true; // Stop deceleration

    if (this._isDecelerating) {
      Animate.stop(this._isDecelerating);
      this._isDecelerating = false;
      this._interruptedAnimation = true;
    } // Stop animation


    if (this._isAnimating) {
      Animate.stop(this._isAnimating);
      this._isAnimating = false;
      this._interruptedAnimation = true;
    } // Use center point when dealing with two fingers


    var isSingleTouch = touches.length === 1;
    var currentTouchLeft, currentTouchTop;

    if (isSingleTouch) {
      currentTouchLeft = touches[0].pageX;
      currentTouchTop = touches[0].pageY;
    } else {
      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
    } // Store initial positions


    this._initialTouchLeft = currentTouchLeft;
    this._initialTouchTop = currentTouchTop; // Store current zoom level

    this._zoomLevelStart = this._zoomLevel; // Store initial touch positions

    this._lastTouchLeft = currentTouchLeft;
    this._lastTouchTop = currentTouchTop; // Store initial move time stamp

    this._lastTouchMove = timeStamp; // Reset initial scale

    this._lastScale = 1; // Reset locking flags

    this._enableScrollX = !isSingleTouch && this.options.scrollingX;
    this._enableScrollY = !isSingleTouch && this.options.scrollingY; // Reset tracking flag

    this._isTracking = true; // Reset deceleration complete flag

    this._didDecelerationComplete = false; // Dragging starts directly with two fingers, otherwise lazy with an offset

    this._isDragging = !isSingleTouch; // Some features are disabled in multi touch scenarios

    this._isSingleTouch = isSingleTouch; // Clearing data structure

    this._positions = [];
  };

  _proto.doTouchMove = function doTouchMove(touches, timeStamp, scale) {
    // Array-like check is enough here
    if (touches.length == null) ;

    if (timeStamp instanceof Date) {
      timeStamp = timeStamp.valueOf();
    }


    if (!this._isTracking) {
      return;
    }

    var currentTouchLeft, currentTouchTop; // Compute move based around of center of fingers

    if (touches.length === 2) {
      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
    } else {
      currentTouchLeft = touches[0].pageX;
      currentTouchTop = touches[0].pageY;
    }

    var positions = this._positions; // Are we already is dragging mode?

    if (this._isDragging) {
      // Compute move distance
      var moveX = currentTouchLeft - this._lastTouchLeft;
      var moveY = currentTouchTop - this._lastTouchTop; // Read previous scroll position and zooming

      var scrollLeft = this._scrollLeft;
      var scrollTop = this._scrollTop;
      var level = this._zoomLevel; // Work with scaling

      if (scale != null && this.options.zooming) {
        var oldLevel = level; // Recompute level based on previous scale and new scale

        level = level / this._lastScale * scale; // Limit level according to configuration

        level = Math.max(Math.min(level, this.options.maxZoom), this.options.minZoom); // Only do further compution when change happened

        if (oldLevel !== level) {
          // Compute relative event position to container
          var currentTouchLeftRel = currentTouchLeft - this._clientLeft;
          var currentTouchTopRel = currentTouchTop - this._clientTop; // Recompute left and top coordinates based on new zoom level

          scrollLeft = (currentTouchLeftRel + scrollLeft) * level / oldLevel - currentTouchLeftRel;
          scrollTop = (currentTouchTopRel + scrollTop) * level / oldLevel - currentTouchTopRel; // Recompute max scroll values

          this._computeScrollMax(level);
        }
      }

      if (this._enableScrollX) {
        scrollLeft -= moveX * this.options.speedMultiplier;
        var maxScrollLeft = this._maxScrollLeft;

        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
          // Slow down on the edges
          if (this.options.bouncing) {
            scrollLeft += moveX / 2 * this.options.speedMultiplier;
          } else if (scrollLeft > maxScrollLeft) {
            scrollLeft = maxScrollLeft;
          } else {
            scrollLeft = 0;
          }
        }
      } // Compute new vertical scroll position


      if (this._enableScrollY) {
        scrollTop -= moveY * this.options.speedMultiplier;
        var maxScrollTop = this._maxScrollTop;

        if (scrollTop > maxScrollTop || scrollTop < 0) {
          // Slow down on the edges
          if (this.options.bouncing) {
            scrollTop += moveY / 2 * this.options.speedMultiplier; // Support pull-to-refresh (only when only y is scrollable)

            if (!this._enableScrollX && this._refreshHeight != null) {
              if (!this._refreshActive && scrollTop <= -this._refreshHeight) {
                this._refreshActive = true;

                if (this._refreshActivate) {
                  this._refreshActivate();
                }
              } else if (this._refreshActive && scrollTop > -this._refreshHeight) {
                this._refreshActive = false;

                if (this._refreshDeactivate) {
                  this._refreshDeactivate();
                }
              }
            }
          } else if (scrollTop > maxScrollTop) {
            scrollTop = maxScrollTop;
          } else {
            scrollTop = 0;
          }
        }
      } // Keep list from growing infinitely (holding min 10, max 20 measure points)


      if (positions.length > 60) {
        positions.splice(0, 30);
      } // Track scroll movement for decleration


      positions.push(scrollLeft, scrollTop, timeStamp); // Sync scroll position

      this._publish(scrollLeft, scrollTop, level); // Otherwise figure out whether we are switching into dragging mode now.

    } else {
      var minimumTrackingForScroll = this.options.locking ? 3 : 0;
      var minimumTrackingForDrag = 5;
      var distanceX = Math.abs(currentTouchLeft - this._initialTouchLeft);
      var distanceY = Math.abs(currentTouchTop - this._initialTouchTop);
      this._enableScrollX = this.options.scrollingX && distanceX >= minimumTrackingForScroll;
      this._enableScrollY = this.options.scrollingY && distanceY >= minimumTrackingForScroll;
      positions.push(this._scrollLeft, this._scrollTop, timeStamp);
      this._isDragging = (this._enableScrollX || this._enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);

      if (this._isDragging) {
        this._interruptedAnimation = false;
      }
    } // Update last touch positions and time stamp for next event


    this._lastTouchLeft = currentTouchLeft;
    this._lastTouchTop = currentTouchTop;
    this._lastTouchMove = timeStamp;
  };

  _proto.doTouchEnd = function doTouchEnd(timeStamp) {
    if (timeStamp instanceof Date) {
      timeStamp = timeStamp.valueOf();
    }
    // This is required as this listener ('touchmove') sits on the document and not on the element itthis.


    if (!this._isTracking) {
      return;
    } // Not touching anymore (when two finger hit the screen there are two touch end events)


    this._isTracking = false; // Be sure to reset the dragging flag now. Here we also detect whether
    // the finger has moved fast enough to switch into a deceleration animation.

    if (this._isDragging) {
      // Reset dragging flag
      this._isDragging = false; // Start deceleration
      // Verify that the last move detected was in some relevant time frame

      if (this._isSingleTouch && this.options.animating && timeStamp - this._lastTouchMove <= 100) {
        // Then figure out what the scroll position was about 100ms ago
        var positions = this._positions;
        var endPos = positions.length - 1;
        var startPos = endPos; // Move pointer to position measured 100ms ago

        for (var i = endPos; i > 0 && positions[i] > this._lastTouchMove - 100; i -= 3) {
          startPos = i;
        } // If start and stop position is identical in a 100ms timeframe,
        // we cannot compute any useful deceleration.


        if (startPos !== endPos) {
          // Compute relative movement between these two points
          var timeOffset = positions[endPos] - positions[startPos];
          var movedLeft = this._scrollLeft - positions[startPos - 2];
          var movedTop = this._scrollTop - positions[startPos - 1]; // Based on 50ms compute the movement to apply for each render step

          this._decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
          this._decelerationVelocityY = movedTop / timeOffset * (1000 / 60); // How much velocity is required to start the deceleration

          var minVelocityToStartDeceleration = this.options.paging || this.options.snapping ? this.options.snappingVelocity : 0.01; // Verify that we have enough velocity to start deceleration

          if (Math.abs(this._decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(this._decelerationVelocityY) > minVelocityToStartDeceleration) {
            // Deactivate pull-to-refresh when decelerating
            if (!this._refreshActive) {
              this._startDeceleration(timeStamp);
            }
          } else {
            this.options.scrollingComplete();
          }
        } else {
          this.options.scrollingComplete();
        }
      } else if (timeStamp - this._lastTouchMove > 100) {
        !this.options.snapping && this.options.scrollingComplete();
      }
    } // If this was a slower move it is per default non decelerated, but this
    // still means that we want snap back to the bounds which is done here.
    // This is placed outside the condition above to improve edge case stability
    // e.g. touchend fired without enabled dragging. This should normally do not
    // have modified the scroll positions or even showed the scrollbars though.


    if (!this._isDecelerating) {
      if (this._refreshActive && this._refreshStart) {
        // Use publish instead of scrollTo to allow scrolling to out of boundary position
        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled
        this._publish(this._scrollLeft, -this._refreshHeight, this._zoomLevel, true);

        if (this._refreshStart) {
          this._refreshStart();
        }
      } else {
        if (this._interruptedAnimation || this._isDragging) {
          this.options.scrollingComplete();
        }

        this.scrollTo(this._scrollLeft, this._scrollTop, true, this._zoomLevel); // Directly signalize deactivation (nothing todo on refresh?)

        if (this._refreshActive) {
          this._refreshActive = false;

          if (this._refreshDeactivate) {
            this._refreshDeactivate();
          }
        }
      }
    } // Fully cleanup list


    this._positions.length = 0;
  };

  _proto._publish = function _publish(left, top, zoom, animate) {
    var _this = this;

    if (zoom === void 0) {
      zoom = 1;
    }

    if (animate === void 0) {
      animate = false;
    }

    // Remember whether we had an animation, then we try to continue based on the current "drive" of the animation
    var wasAnimating = this._isAnimating;

    if (wasAnimating) {
      Animate.stop(wasAnimating);
      this._isAnimating = false;
    }

    if (animate && this.options.animating) {
      // Keep scheduled positions for scrollBy/zoomBy functionality
      this._scheduledLeft = left;
      this._scheduledTop = top;
      this._scheduledZoom = zoom;
      var oldLeft = this._scrollLeft;
      var oldTop = this._scrollTop;
      var oldZoom = this._zoomLevel;
      var diffLeft = left - oldLeft;
      var diffTop = top - oldTop;
      var diffZoom = zoom - oldZoom;

      var step = function step(percent, now, render) {
        if (render) {
          _this._scrollLeft = oldLeft + diffLeft * percent;
          _this._scrollTop = oldTop + diffTop * percent;
          _this._zoomLevel = oldZoom + diffZoom * percent; // Push values out

          if (_this._callback) {
            _this._callback(_this._scrollLeft, _this._scrollTop, _this._zoomLevel);
          }
        }
      };

      var verify = function verify(id) {
        return _this._isAnimating === id;
      };

      var completed = function completed(renderedFramesPerSecond, animationId, wasFinished) {
        if (animationId === _this._isAnimating) {
          _this._isAnimating = false;
        }

        if (_this._didDecelerationComplete || wasFinished) {
          _this.options.scrollingComplete();
        }

        if (_this.options.zooming) {
          _this._computeScrollMax();

          if (_this._zoomComplete) {
            _this._zoomComplete();

            _this._zoomComplete = null;
          }
        }
      };

      var doAnimation = function doAnimation() {
        // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out
        _this._isAnimating = Animate.start(step, verify, completed, _this.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
      };

      if (this.options.inRequestAnimationFrame) {
        Animate.requestAnimationFrame(function () {
          doAnimation();
        });
      } else {
        doAnimation();
      }
    } else {
      this._scheduledLeft = this._scrollLeft = left;
      this._scheduledTop = this._scrollTop = top;
      this._scheduledZoom = this._zoomLevel = zoom; // Push values out

      if (this._callback) {
        this._callback(left, top, zoom);
      } // Fix max scroll ranges


      if (this.options.zooming) {
        this._computeScrollMax();

        if (this._zoomComplete) {
          this._zoomComplete();

          this._zoomComplete = null;
        }
      }
    }
  };

  _proto._computeScrollMax = function _computeScrollMax(zoomLevel) {
    if (zoomLevel == null) {
      zoomLevel = this._zoomLevel;
    }

    this._maxScrollLeft = Math.max(this._contentWidth * zoomLevel - this._clientWidth, 0);
    this._maxScrollTop = Math.max(this._contentHeight * zoomLevel - this._clientHeight, 0);
  };

  _proto._startDeceleration = function _startDeceleration(timeStamp) {
    var _this2 = this;

    if (this.options.paging) {
      var scrollLeft = Math.max(Math.min(this._scrollLeft, this._maxScrollLeft), 0);
      var scrollTop = Math.max(Math.min(this._scrollTop, this._maxScrollTop), 0);
      var clientWidth = this._clientWidth;
      var clientHeight = this._clientHeight; // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.
      // Each page should have exactly the size of the client area.

      this._minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
      this._minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
      this._maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
      this._maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
    } else {
      this._minDecelerationScrollLeft = 0;
      this._minDecelerationScrollTop = 0;
      this._maxDecelerationScrollLeft = this._maxScrollLeft;
      this._maxDecelerationScrollTop = this._maxScrollTop;
    } // Wrap class method


    var step = function step(percent, now, render) {
      _this2._stepThroughDeceleration(render);
    }; // How much velocity is required to keep the deceleration running


    var minVelocityToKeepDecelerating = this.options.snapping ? this.options.snappingVelocity : 0.01; // Detect whether it's still worth to continue animating steps
    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.

    var verify = function verify() {
      var shouldContinue = Math.abs(_this2._decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(_this2._decelerationVelocityY) >= minVelocityToKeepDecelerating;

      if (!shouldContinue) {
        _this2._didDecelerationComplete = true;
      }

      return shouldContinue;
    };

    var completed = function completed(renderedFramesPerSecond, animationId, wasFinished) {
      _this2._isDecelerating = false; // if (this._didDecelerationComplete) {
      //   this.options.scrollingComplete()
      // }
      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions

      _this2.scrollTo(_this2._scrollLeft, _this2._scrollTop, _this2.options.snapping);
    }; // Start animation and switch on flag


    this._isDecelerating = Animate.start(step, verify, completed);
  };

  _proto._stepThroughDeceleration = function _stepThroughDeceleration(render) {
    //
    // COMPUTE NEXT SCROLL POSITION
    //
    // Add deceleration to scroll position
    var scrollLeft = this._scrollLeft + this._decelerationVelocityX;
    var scrollTop = this._scrollTop + this._decelerationVelocityY; //
    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE
    //

    if (!this.options.bouncing) {
      var scrollLeftFixed = Math.max(Math.min(this._maxDecelerationScrollLeft, scrollLeft), this._minDecelerationScrollLeft);

      if (scrollLeftFixed !== scrollLeft) {
        scrollLeft = scrollLeftFixed;
        this._decelerationVelocityX = 0;
      }

      var scrollTopFixed = Math.max(Math.min(this._maxDecelerationScrollTop, scrollTop), this._minDecelerationScrollTop);

      if (scrollTopFixed !== scrollTop) {
        scrollTop = scrollTopFixed;
        this._decelerationVelocityY = 0;
      }
    } //
    // UPDATE SCROLL POSITION
    //


    if (render) {
      this._publish(scrollLeft, scrollTop, this._zoomLevel);
    } else {
      this._scrollLeft = scrollLeft;
      this._scrollTop = scrollTop;
    } //
    // SLOW DOWN
    //
    // Slow down velocity on every iteration


    if (!this.options.paging) {
      // This is the factor applied to every iteration of the animation
      // to slow down the process. This should emulate natural behavior where
      // objects slow down when the initiator of the movement is removed
      var frictionFactor = 0.95;
      this._decelerationVelocityX *= frictionFactor;
      this._decelerationVelocityY *= frictionFactor;
    } //
    // BOUNCING SUPPORT
    //


    if (this.options.bouncing) {
      var scrollOutsideX = 0;
      var scrollOutsideY = 0; // This configures the amount of change applied to deceleration/acceleration when reaching boundaries

      var penetrationDeceleration = this.options.penetrationDeceleration;
      var penetrationAcceleration = this.options.penetrationAcceleration; // Check limits

      if (scrollLeft < this._minDecelerationScrollLeft) {
        scrollOutsideX = this._minDecelerationScrollLeft - scrollLeft;
      } else if (scrollLeft > this._maxDecelerationScrollLeft) {
        scrollOutsideX = this._maxDecelerationScrollLeft - scrollLeft;
      }

      if (scrollTop < this._minDecelerationScrollTop) {
        scrollOutsideY = this._minDecelerationScrollTop - scrollTop;
      } else if (scrollTop > this._maxDecelerationScrollTop) {
        scrollOutsideY = this._maxDecelerationScrollTop - scrollTop;
      } // Slow down until slow enough, then flip back to snap position


      if (scrollOutsideX !== 0) {
        if (scrollOutsideX * this._decelerationVelocityX <= 0) {
          this._decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
        } else {
          this._decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
        }
      }

      if (scrollOutsideY !== 0) {
        if (scrollOutsideY * this._decelerationVelocityY <= 0) {
          this._decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
        } else {
          this._decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
        }
      }
    }
  };

  return Scroller;
}();
extend(Scroller.prototype, members);

/* istanbul ignore file */

var render = function (global) {
  // for ssr
  if (!inBrowser) {
    return function (content, left, top) {
      content.style.marginLeft = left ? -left + "px" : '';
      content.style.marginTop = top ? -top + "px" : '';
    };
  }

  var docStyle = document.documentElement.style;
  var engine;

  if (global.opera && Object.prototype.toString.call(opera) === '[object Opera]') {
    engine = 'presto';
  } else if ('MozAppearance' in docStyle) {
    engine = 'gecko';
  } else if ('WebkitAppearance' in docStyle) {
    engine = 'webkit';
  } else if (typeof navigator.cpuClass === 'string') {
    engine = 'trident';
  }

  var vendorPrefix = {
    trident: 'ms',
    gecko: 'Moz',
    webkit: 'Webkit',
    presto: 'O'
  }[engine];
  var helperElem = document.createElement('div');
  var perspectiveProperty = vendorPrefix + 'Perspective';
  var transformProperty = vendorPrefix + 'Transform';

  if (helperElem.style[perspectiveProperty] !== undefined) {
    return function (content, left, top, zoom, useNativeDriver) {
      if (zoom === void 0) {
        zoom = 1;
      }

      if (useNativeDriver === void 0) {
        useNativeDriver = true;
      }

      if (useNativeDriver) {
        content.style[transformProperty] = "translate3d(" + -left + "px," + -top + "px,0) scale(" + zoom + ")";
      } else {
        content.style[transformProperty] = "translate(" + -left + "px," + -top + "px) scale(" + zoom + ")";
      }
    };
  } else if (helperElem.style[transformProperty] !== undefined) {
    return function (content, left, top, zoom) {
      if (zoom === void 0) {
        zoom = 1;
      }

      content.style[transformProperty] = "translate(" + -left + "px," + -top + "px) scale(" + zoom + ")";
    };
  } else {
    return function (content, left, top, zoom) {
      content.style.marginLeft = left ? -left + "px" : '';
      content.style.marginTop = top ? -top + "px" : '';
      content.style.zoom = zoom || '';
    };
  }
}(root);

var script = {
  name: 'fm-scroll-view',
  props: {
    scrollingX: {
      type: Boolean,
      "default": true
    },
    scrollingY: {
      type: Boolean,
      "default": true
    },
    bouncing: {
      type: Boolean,
      "default": true
    },
    autoReflow: {
      type: Boolean,
      "default": false
    },
    //手动初始化
    manualInit: {
      type: Boolean,
      "default": false
    },
    endReachedThreshold: {
      type: Number,
      "default": 0
    },
    immediateCheckEndReaching: {
      type: Boolean,
      "default": false
    },
    touchAngle: {
      type: Number,
      "default": 45
    },
    isPrevent: {
      type: Boolean,
      "default": true
    }
  },
  data: function data() {
    return {
      container: null,
      content: null,
      refresher: null,
      more: null,
      scroller: null,
      refreshOffsetY: 0,
      isInitialed: false,
      isMouseDown: false,
      isRefreshing: false,
      isRefreshActive: false,
      isEndReachingStart: false,
      isEndReaching: false,
      scrollX: null,
      scrollY: null,
      startX: 0,
      startY: 0,
      currentX: 0,
      currentY: 0,
      containerW: 0,
      containerH: 0,
      contentW: 0,
      contentH: 0,
      reflowTimer: null,
      endReachedHandler: null
    };
  },
  computed: {
    hasRefresher: function hasRefresher() {
      return !!this.$slots.refresh;
    },
    hasMore: function hasMore() {
      return !!this.$slots.more;
    }
  },
  watch: {
    autoReflow: function autoReflow(val) {
      if (val) {
        this.$_initAutoReflow();
      } else {
        this.$_destroyAutoReflow();
      }
    }
  },
  mounted: function mounted() {
    if (!this.manualInit) {
      this.$_initScroller();
    }
  },
  unmounted: function unmounted() {
    this.$_destroyAutoReflow();
  },
  methods: {
    $_initScroller: function $_initScroller() {
      var _this = this;

      /* istanbul ignore if */
      if (this.isInitialed) {
        return;
      }

      this.container = this.$el;
      this.refresher = this.$el.querySelector('.scroll-view-refresh');
      this.more = this.$el.querySelector('.scroll-view-more');
      this.content = this.$el.querySelector('.scroll-view-container');
      this.refreshOffsetY = this.refresher ? this.refresher.clientHeight : 0;
      this.moreOffsetY = this.more ? this.more.clientHeight : 0;
      var container = this.container;
      var content = this.content;
      var rect = container.getBoundingClientRect();
      var scroller = new Scroller(function (left, top) {
        render(content, left, top);

        if (_this.isInitialed) {
          _this.$_onScroll(left, top);
        }
      }, {
        scrollingX: this.scrollingX,
        scrollingY: this.scrollingY,
        bouncing: this.bouncing,
        zooming: false,
        animationDuration: 200,
        speedMultiplier: 1.2,
        inRequestAnimationFrame: true
      });
      scroller.setPosition(rect.left + container.clientLeft, rect.top + container.clientTop);

      if (this.hasRefresher) {
        scroller.activatePullToRefresh(this.refreshOffsetY, function () {
          _this.isRefreshActive = true;
          _this.isRefreshing = false;

          _this.$emit('refreshActive');
        }, function () {
          _this.isRefreshActive = false;
          _this.isRefreshing = false;
        }, function () {
          _this.isRefreshActive = false;
          _this.isRefreshing = true;

          _this.$emit('refreshing');
        });
      }

      this.scroller = scroller;
      this.reflowScroller(true);
      this.autoReflow && this.$_initAutoReflow();
      this.endReachedHandler = debounce(function () {
        _this.isEndReaching = true;

        _this.$emit('endReached');

        _this.$emit('end-reached');
      }, 50);
      setTimeout(function () {
        _this.isInitialed = true;
      }, 50);

      if (this.immediateCheckEndReaching) {
        nextTick(this.$_checkScrollerEnd);
      }
    },
    $_initAutoReflow: function $_initAutoReflow() {
      var _this2 = this;

      this.$_destroyAutoReflow();
      this.reflowTimer = setInterval(function () {
        _this2.reflowScroller();
      }, 100);
    },
    $_destroyAutoReflow: function $_destroyAutoReflow() {
      this.reflowTimer && clearInterval(this.reflowTimer);
    },
    $_checkScrollerEnd: function $_checkScrollerEnd() {
      if (!this.scroller) {
        return;
      }

      var containerHeight = this.scroller._clientHeight;
      var content = this.scroller._contentHeight;
      var top = this.scroller._scrollTop;
      var moreOffsetY = this.moreOffsetY;
      var moreThreshold = this.endReachedThreshold;
      var endOffset = content - containerHeight - (top + moreOffsetY + moreThreshold);

      if (top >= 0 && !this.isEndReaching && endOffset <= 0 && this.endReachedHandler) {
        // First prepare for "load more" state
        this.isEndReachingStart = true; // Second enter "load more" state
        // & trigger endReached event only once after the rebounding animation

        this.endReachedHandler();
      }
    },
    $_getScrollerAngle: function $_getScrollerAngle() {
      var diffX = this.currentX - this.startX;
      var diffY = this.currentY - this.startY;
      var angle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
      return this.scrollingX ? 90 - angle : angle;
    },
    // MARK: events handler
    $_onScrollerTouchStart: function $_onScrollerTouchStart(event) {
      // event.target.tagName && event.target.tagName.match(/input|textarea|select/i)

      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      this.startX = event.targetTouches[0].pageX;
      this.startY = event.targetTouches[0].pageY;
      this.scroller.doTouchStart(event.touches, event.timeStamp);
    },
    $_onScrollerTouchMove: function $_onScrollerTouchMove(event) {
      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      var hadPrevent = false;

      if (this.isPrevent) {
        event.preventDefault();
        hadPrevent = true;
      }

      this.currentX = event.targetTouches[0].pageX;
      this.currentY = event.targetTouches[0].pageY;

      if (!this.scrollingX || !this.scrollingY) {
        var currentTouchAngle = this.$_getScrollerAngle();

        if (currentTouchAngle < this.touchAngle) {
          return;
        }
      }

      if (!hadPrevent && event.cancelable) {
        event.preventDefault();
      }

      this.scroller.doTouchMove(event.touches, event.timeStamp, event.scale);
      var boundaryDistance = 15;
      var scrollLeft = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft;
      var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
      var pX = this.currentX - scrollLeft;
      var pY = this.currentY - scrollTop;

      if (pX > document.documentElement.clientWidth - boundaryDistance || pY > document.documentElement.clientHeight - boundaryDistance || pX < boundaryDistance || pY < boundaryDistance) {
        this.scroller.doTouchEnd(event.timeStamp);
      }
    },
    $_onScrollerTouchEnd: function $_onScrollerTouchEnd(event) {
      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      this.scroller.doTouchEnd(event.timeStamp);
    },
    $_onScrollerMouseDown: function $_onScrollerMouseDown(event) {
      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      this.startX = event.pageX;
      this.startY = event.pageY;
      this.scroller.doTouchStart([{
        pageX: event.pageX,
        pageY: event.pageY
      }], event.timeStamp);
      this.isMouseDown = true;
    },
    $_onScrollerMouseMove: function $_onScrollerMouseMove(event) {
      /* istanbul ignore if */
      if (!this.scroller || !this.isMouseDown) {
        return;
      }

      this.currentX = event.pageX;
      this.currentY = event.pageY;

      if (!this.scrollingX || !this.scrollingY) {
        var currentTouchAngle = this.$_getScrollerAngle();

        if (currentTouchAngle < this.touchAngle) {
          return;
        }
      }

      this.scroller.doTouchMove([{
        pageX: event.pageX,
        pageY: event.pageY
      }], event.timeStamp);
      this.isMouseDown = true;
    },
    $_onScrollerMouseUp: function $_onScrollerMouseUp(event) {
      /* istanbul ignore if */
      if (!this.scroller || !this.isMouseDown) {
        return;
      }

      this.scroller.doTouchEnd(event.timeStamp);
      this.isMouseDown = false;
    },
    $_onScroll: function $_onScroll(left, top) {
      left = +left.toFixed(2);
      top = +top.toFixed(2);

      if (this.scrollX === left && this.scrollY === top) {
        return;
      }

      this.scrollX = left;
      this.scrollY = top;
      this.$_checkScrollerEnd();
      this.$emit('scroll', {
        scrollLeft: left,
        scrollTop: top
      });
    },
    init: function init() {
      var _this3 = this;

      nextTick(function () {
        _this3.$_initScroller();
      });
    },
    scrollTo: function scrollTo(left, top, animate) {
      if (animate === void 0) {
        animate = false;
      }

      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      this.scroller.scrollTo(left, top, animate);
    },
    getOffsets: function getOffsets() {
      /* istanbul ignore if */
      if (!this.scroller) {
        return {
          left: 0,
          top: 0
        };
      }

      return this.scroller.getValues();
    },
    reflowScroller: function reflowScroller(force) {
      var _this4 = this;

      if (force === void 0) {
        force = false;
      }

      var container = this.container;
      var content = this.content;
      /* istanbul ignore if */

      if (!this.scroller || !container || !content) {
        return;
      }

      nextTick(function () {
        var containerW = container.clientWidth;
        var containerH = container.clientHeight;
        var contentW = content.offsetWidth;
        var contentH = content.offsetHeight;

        if (force || _this4.containerW !== containerW || _this4.containerH !== containerH || _this4.contentW !== contentW || _this4.contentH !== contentH) {
          _this4.scroller.setDimensions(container.clientWidth, container.clientHeight, content.offsetWidth, content.offsetHeight);

          _this4.containerW = containerW;
          _this4.containerH = containerH;
          _this4.contentW = contentW;
          _this4.contentH = contentH;
        }
      });
    },
    triggerRefresh: function triggerRefresh() {
      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      this.scroller.triggerPullToRefresh();
    },
    finishRefresh: function finishRefresh() {
      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      this.scroller.finishPullToRefresh();
      this.reflowScroller();
    },
    finishLoadMore: function finishLoadMore() {
      /* istanbul ignore if */
      if (!this.scroller) {
        return;
      }

      this.isEndReachingStart = false;
      this.isEndReaching = false;
      this.reflowScroller();
    }
  }
};

const _hoisted_1 = {
  key: 0,
  class: "scroll-view-header"
};
const _hoisted_2 = {
  key: 1,
  class: "scroll-view-footer"
};

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: "fm-scroll-view",
    onTouchstart: _cache[1] || (_cache[1] = (...args) => ($options.$_onScrollerTouchStart && $options.$_onScrollerTouchStart(...args))),
    onTouchmove: _cache[2] || (_cache[2] = (...args) => ($options.$_onScrollerTouchMove && $options.$_onScrollerTouchMove(...args))),
    onTouchend: _cache[3] || (_cache[3] = (...args) => ($options.$_onScrollerTouchEnd && $options.$_onScrollerTouchEnd(...args))),
    onTouchcancel: _cache[4] || (_cache[4] = (...args) => ($options.$_onScrollerTouchEnd && $options.$_onScrollerTouchEnd(...args))),
    onMousedown: _cache[5] || (_cache[5] = (...args) => ($options.$_onScrollerMouseDown && $options.$_onScrollerMouseDown(...args))),
    onMousemove: _cache[6] || (_cache[6] = (...args) => ($options.$_onScrollerMouseMove && $options.$_onScrollerMouseMove(...args))),
    onMouseup: _cache[7] || (_cache[7] = (...args) => ($options.$_onScrollerMouseUp && $options.$_onScrollerMouseUp(...args))),
    onMouseleave: _cache[8] || (_cache[8] = (...args) => ($options.$_onScrollerMouseUp && $options.$_onScrollerMouseUp(...args)))
  }, [
    (_ctx.$slots.header)
      ? (openBlock(), createBlock("div", _hoisted_1, [
          renderSlot(_ctx.$slots, "header")
        ]))
      : createCommentVNode("v-if", true),
    createVNode("div", {
      class: ["scroll-view-container", {
        'horizon': $props.scrollingX && !$props.scrollingY
      }],
      "scroll-wrapper": ""
    }, [
      ($options.hasRefresher)
        ? (openBlock(), createBlock("div", {
            key: 0,
            class: ["scroll-view-refresh", {
          'refreshing': $data.isRefreshing,
          'refresh-active': $data.isRefreshActive,
        }]
          }, [
            renderSlot(_ctx.$slots, "refresh", {
              scrollTop: $data.scrollY,
              isRefreshing: $data.isRefreshing,
              isRefreshActive: $data.isRefreshActive
            })
          ], 2 /* CLASS */))
        : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default"),
      ($options.hasMore)
        ? (openBlock(), createBlock("div", {
            key: 1,
            class: [{active: $data.isEndReachingStart || $data.isEndReaching}, "scroll-view-more"]
          }, [
            renderSlot(_ctx.$slots, "more", {
              isEndReaching: $data.isEndReachingStart || $data.isEndReaching
            })
          ], 2 /* CLASS */))
        : createCommentVNode("v-if", true)
    ], 2 /* CLASS */),
    (_ctx.$slots.footer)
      ? (openBlock(), createBlock("div", _hoisted_2, [
          renderSlot(_ctx.$slots, "footer")
        ]))
      : createCommentVNode("v-if", true)
  ], 32 /* HYDRATE_EVENTS */))
}

script.render = render$1;
script.__file = "packages/scroll-view/index.vue";

script.install = function (app) {
  app.component(script.name, script);
};

export default script;
export { script as ScrollView };
