import { defineComponent, computed, ref, watch, reactive, onMounted, createVNode, Fragment, withDirectives, vModelText, vModelDynamic, createTextVNode, resolveComponent, unref } from 'vue';
import { useExpose } from '../hook';
import { parseFloat, stopPropagation, isDef, isFunction, formatToNumber, isObject } from '../utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var Input = defineComponent({
  name: 'fm-input',
  props: {
    modelValue: {
      type: [String, Number],
      "default": ''
    },
    editable: {
      type: Boolean,
      "default": true
    },
    required: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    readonly: {
      type: Boolean,
      "default": false
    },
    labelAlign: {
      type: String,
      "default": 'left'
    },
    inputAlign: {
      type: String,
      "default": 'right'
    },
    type: {
      type: String,
      "default": 'text'
    },
    label: {
      type: String
    },
    placeholder: {
      type: String,
      "default": '请输入文本'
    },
    clearable: {
      type: Boolean,
      "default": false
    },
    formatTrigger: {
      type: String,
      "default": 'onChange'
    },
    autosize: {
      type: [Boolean, Object],
      "default": false
    },
    showWordLimit: {
      type: Boolean,
      "default": false
    },
    maxlength: Number,
    formatter: {
      type: Function
    },
    isLink: {
      type: Boolean,
      "default": false
    },
    enableNull: {
      type: Boolean,
      "default": false
    },
    updateOn: {
      type: String,
      "default": 'change'
    },
    precision: {
      type: Number,
      "default": 2
    },
    errorMessage: String,
    errorMessageAlign: {
      type: String,
      "default": 'right'
    },
    center: {
      type: Boolean,
      "default": false
    },
    leftIcon: [String, Boolean],
    rightIcon: [String, Boolean],
    extra: [String, Boolean]
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        attrs = _ref.attrs,
        slots = _ref.slots;

    var formatValue = function formatValue(value) {
      value = isDef(value) ? String(value) : '';

      if (isFunction(props.formatter)) {
        return props.formatter(value);
      }

      if (props.type === 'textarea') {
        value = formatTextAreaValue(value);
      } else if (props.type === 'number' || props.type === 'digit') {
        value = formatNumberValue(value);
      }

      return value;
    };

    var formatTextAreaValue = function formatTextAreaValue(value) {
      var maxlength = props.maxlength;

      if (isDef(maxlength) && value.length > maxlength) {
        return value = value.slice(0, maxlength);
      }

      return value;
    };

    var formatNumberValue = function formatNumberValue(value) {
      var allowDot = props.type === 'number' ? true : false;
      return formatToNumber(value, allowDot);
    };

    var updateOn = computed(function () {
      return isReturnNumber(innerValue.value) ? 'blur' : props.updateOn;
    });

    var isReturnNumber = function isReturnNumber(value) {
      return props.type === 'number' && (value || value === 0 || !props.enableNull);
    };

    var updatable = computed(function () {
      return !props.readonly && !props.disabled;
    });

    var initInnerValue = function initInnerValue(value) {
      return isReturnNumber(props.modelValue) ? parseFloat(formatValue(value), props.precision) : formatValue(value);
    };

    var innerValue = ref(initInnerValue(props.modelValue));
    watch(function () {
      return props.modelValue;
    }, function (value) {
      if (innerValue.value !== value) {
        innerValue.value = initInnerValue(value);
      }
    });

    var updateModelValue = function updateModelValue(value) {
      if (!updatable.value) {
        return;
      }

      innerValue.value = formatValue(value);

      if (isReturnNumber(innerValue.value)) {
        innerValue.value = parseFloat(innerValue.value, props.precision);

        if (!props.modelValue && props.modelValue !== 0 || Number(props.modelValue) !== Number(innerValue.value)) {
          emit('update:modelValue', Number(innerValue.value));
        }
      } else {
        emit('update:modelValue', innerValue.value);
      }
    };

    var compositioning = false;

    var onCompositionend = function onCompositionend() {
      compositioning = false;
      onInput();
    };

    var onInput = function onInput() {
      if (compositioning) {
        return;
      }

      if (updateOn.value === 'change') {
        updateModelValue(innerValue.value);
      } else if (props.type === 'number') {
        innerValue.value = formatValue(innerValue.value);
      }

      if (props.clearable && innerValue.value) {
        showClear.value = true;
      }
    };

    var onClear = function onClear() {
      updateModelValue('');
      emit('clear');
    };

    var showClear = ref(false);

    var onBlur = function onBlur(event) {
      emit('blur', event);

      if (!updatable.value) {
        return;
      }

      showClear.value = props.clearable ? false : showClear.value;

      if (updateOn.value === 'blur') {
        updateModelValue(innerValue.value);
      } else if (props.type === 'number' && props.modelValue === 0) {
        innerValue.value = parseFloat(props.modelValue, props.precision);
      }
    };

    var onFocus = function onFocus(event) {
      emit('focus', event);

      if (!updatable.value) {
        return;
      }

      showClear.value = props.clearable && innerValue.value ? true : showClear.value;

      if (props.type === 'number' && Number(innerValue.value) === 0) {
        innerValue.value = '';
      }
    };

    var onClickInput = function onClickInput(event) {
      emit('input-click', event);
    };

    var inputEl = ref();

    var onKeypress = function onKeypress(event) {
      var ENTER_CODE = 'Enter';

      if (event.code === ENTER_CODE) {
        if (props.type === 'search') {
          blur();
        }
      }
    };

    var focus = function focus() {
      var _a;

      (_a = inputEl.value) === null || _a === void 0 ? void 0 : _a.focus();
    };

    var blur = function blur() {
      var _a;

      (_a = inputEl.value) === null || _a === void 0 ? void 0 : _a.blur();
    };

    useExpose({
      focus: focus,
      blur: blur
    });
    var inputType = ref('text');
    var inputMode = ref('text');

    var inputTypeInit = function inputTypeInit(type) {
      if (type === 'number') {
        inputType.value = 'text';
        inputMode.value = 'decimal';
      } else if (type === 'digit') {
        inputType.value = 'tel';
        inputMode.value = 'numeric';
      } else {
        inputType.value = type;
      }
    };

    inputTypeInit(props.type);
    watch(function () {
      return props.type;
    }, inputTypeInit);
    var innerPlaceholder = computed(function () {
      if (props.readonly || props.disabled) {
        return '';
      }

      return props.placeholder;
    });
    var inputStyle = reactive({});

    var adjustSize = function adjustSize() {
      var input = unref(inputEl);

      if (!(props.type === 'textarea' && props.autosize) || !input) {
        return;
      }

      inputStyle.height = 'auto';
      var height = input.scrollHeight;

      if (isObject(props.autosize)) {
        var _props$autosize = props.autosize,
            maxHeight = _props$autosize.maxHeight,
            minHeight = _props$autosize.minHeight;

        if (maxHeight) {
          height = Math.min(height, maxHeight);
        }

        if (minHeight) {
          height = Math.max(height, minHeight);
        }
      }

      if (height) {
        inputStyle.height = height + 'px';
      }
    };

    onMounted(function () {
      adjustSize();
    });

    var renderClearIcon = function renderClearIcon() {
      return showClear.value ? createVNode("span", {
        "class": "fm-input-clear fm-icon fm-icon-cancel",
        "onTouchstart": onClear
      }, null) : '';
    };

    var renderWordLimit = function renderWordLimit() {
      return props.showWordLimit && props.maxlength ? createVNode("div", {
        "class": "fm-input-word-limit"
      }, [createVNode("span", {
        "class": "word-num"
      }, [String(innerValue.value).length]), createTextVNode("/"), props.maxlength]) : '';
    };

    var renderErrorMesagge = function renderErrorMesagge() {
      return props.errorMessage ? createVNode("div", {
        "class": "fm-input-error-message"
      }, [props.errorMessage]) : '';
    };

    var renderInput = function renderInput() {
      return props.type === 'textarea' ? withDirectives(createVNode("textarea", {
        "ref": inputEl,
        "style": inputStyle,
        "class": ['fm-input-control', props.readonly ? 'fm-input-control-readonly' : ''],
        "onUpdate:modelValue": function onUpdateModelValue($event) {
          return innerValue.value = $event;
        },
        "placeholder": innerPlaceholder.value,
        "disabled": props.disabled,
        "readonly": props.readonly || !props.editable,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "onChange": stopPropagation,
        "onClick": onClickInput,
        "onKeypress": onKeypress
      }, null), [[vModelText, innerValue.value]]) : withDirectives(createVNode("input", {
        "ref": inputEl,
        "type": inputType.value,
        "inputmode": inputMode.value,
        "class": ['fm-input-control', props.inputAlign ? 'fm-input-control-' + props.inputAlign : '', props.readonly ? 'fm-input-control-readonly' : ''],
        "onUpdate:modelValue": function onUpdateModelValue($event) {
          return innerValue.value = $event;
        },
        "placeholder": innerPlaceholder.value,
        "disabled": props.disabled,
        "readonly": props.readonly || !props.editable,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "onChange": stopPropagation,
        "onClick": onClickInput,
        "onKeypress": onKeypress,
        "onCompositionstart": function onCompositionstart() {
          return compositioning = true;
        },
        "onCompositionend": onCompositionend
      }, null), [[vModelDynamic, innerValue.value]]);
    };

    var renderBlock = function renderBlock() {
      return function () {
        return createVNode(Fragment, null, [createVNode("div", {
          "class": "fm-input-body"
        }, [slots.input ? createVNode("div", {
          "class": ['fm-input-control', props.inputAlign ? 'fm-input-control-' + props.inputAlign : '', props.readonly ? 'fm-input-control-readonly' : '']
        }, [slots.input()]) : renderInput(), renderClearIcon()]), renderWordLimit(), renderErrorMesagge()]);
      };
    };

    return function () {
      var innerSlots = {
        'left-icon': slots['left-icon'],
        'right-icon': slots['right-icon'],
        title: slots.title,
        label: slots.label,
        extra: slots.extra,
        "default": renderBlock()
      };
      var className = ['fm-input', props.type === 'textarea' ? 'fm-input-textarea' : '', props.disabled ? 'fm-input-disabled' : '', props.type === 'textarea' && !props.autosize ? 'fm-input-min-height' : ''];
      return createVNode(resolveComponent("fm-cell"), {
        "class": className,
        "title": props.label,
        "required": props.required,
        "titleClass": "fm-input-label",
        "valueClass": "fm-input-value",
        "center": props.center,
        "isLink": props.isLink,
        "leftIcon": props.leftIcon,
        "rightIcon": props.rightIcon,
        "extra": props.extra
      }, _extends({}, innerSlots));
    };
  }
});

Input.install = function (app) {
  app.component(Input.name, Input);
};

export default Input;
export { Input };
