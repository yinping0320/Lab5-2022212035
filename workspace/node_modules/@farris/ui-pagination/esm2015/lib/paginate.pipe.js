/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Optional, Pipe } from '@angular/core';
import { PaginationService } from './pagination.service';
/** @type {?} */
const LARGE_NUMBER = Number.MAX_SAFE_INTEGER;
/**
 * @record
 */
export function PaginatePipeArgs() { }
if (false) {
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.id;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.itemsPerPage;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.currentPage;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.totalItems;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.pageList;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.remote;
}
/**
 * @record
 */
export function PipeState() { }
if (false) {
    /** @type {?} */
    PipeState.prototype.collection;
    /** @type {?} */
    PipeState.prototype.size;
    /** @type {?} */
    PipeState.prototype.start;
    /** @type {?} */
    PipeState.prototype.end;
    /** @type {?} */
    PipeState.prototype.slice;
}
export class PaginatePipe {
    /**
     * @param {?} service
     */
    constructor(service) {
        this.service = service;
        // store the values from the last time the pipe was invoked
        this.state = {};
        if (!this.service) {
            this.service = new PaginationService();
        }
    }
    /**
     * @template T, U
     * @param {?} collection
     * @param {?} args
     * @return {?}
     */
    transform(collection, args) {
        // When an observable is passed through the AsyncPipe, it will output
        // `null` until the subscription resolves. In this case, we want to
        // use the cached data from the `state` object to prevent the NgFor
        // from flashing empty until the real values arrive.
        if (!(collection instanceof Array)) {
            /** @type {?} */
            const _id = args.id || this.service.defaultId();
            if (this.state[_id]) {
                return (/** @type {?} */ (this.state[_id].slice));
            }
            else {
                return collection;
            }
        }
        // const serverSideMode = args.totalItems && args.totalItems !== collection.length;
        /** @type {?} */
        const serverSideMode = args.remote;
        /** @type {?} */
        const instance = this.createInstance(collection, args);
        /** @type {?} */
        const id = instance.id;
        /** @type {?} */
        let start;
        /** @type {?} */
        let end;
        /** @type {?} */
        let perPage = instance.itemsPerPage;
        this.service.register(instance);
        if (!serverSideMode && collection instanceof Array) {
            perPage = +perPage || LARGE_NUMBER;
            start = (instance.currentPage - 1) * perPage;
            end = start + perPage;
            /** @type {?} */
            const isIdentical = this.stateIsIdentical(id, collection, start, end);
            if (isIdentical) {
                return (/** @type {?} */ (this.state[id].slice));
            }
            else {
                /** @type {?} */
                const slice = collection.slice(start, end);
                this.saveState(id, collection, slice, start, end);
                this.service.change.emit(id);
                return (/** @type {?} */ (slice));
            }
        }
        // save the state for server-side collection to avoid null
        // flash as new data loads.
        this.saveState(id, collection, collection, start, end);
        return collection;
    }
    /**
     * Create an PaginationInstance object, using defaults for any optional properties not supplied.
     * @private
     * @param {?} collection
     * @param {?} config
     * @return {?}
     */
    createInstance(collection, config) {
        // this.checkConfig(config);
        return {
            id: config.id != null ? config.id : this.service.defaultId(),
            itemsPerPage: +config.itemsPerPage || 0,
            currentPage: +config.currentPage || 1,
            totalItems: +config.totalItems || collection.length,
            pageList: config.pageList || [10, 20, 30, 50, 100],
            remote: config.remote
        };
    }
    /**
     * Ensure the argument passed to the filter contains the required properties.
     * @private
     * @param {?} config
     * @return {?}
     */
    checkConfig(config) {
        /** @type {?} */
        const required = ['itemsPerPage', 'currentPage'];
        /** @type {?} */
        const missing = required.filter((/**
         * @param {?} prop
         * @return {?}
         */
        prop => !(prop in config)));
        if (0 < missing.length) {
            throw new Error(`PaginatePipe: Argument is missing the following required properties: ${missing.join(', ')}`);
        }
    }
    /**
     * To avoid returning a brand new array each time the pipe is run, we store the state of the sliced
     * array for a given id. This means that the next time the pipe is run on this collection & id, we just
     * need to check that the collection, start and end points are all identical, and if so, return the
     * last sliced array.
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} slice
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    saveState(id, collection, slice, start, end) {
        this.state[id] = {
            collection,
            size: collection.length,
            slice,
            start,
            end
        };
    }
    /**
     * For a given id, returns true if the collection, size, start and end values are identical.
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    stateIsIdentical(id, collection, start, end) {
        /** @type {?} */
        const state = this.state[id];
        if (!state) {
            return false;
        }
        /** @type {?} */
        const isMetaDataIdentical = state.size === collection.length &&
            state.start === start &&
            state.end === end;
        if (!isMetaDataIdentical) {
            return false;
        }
        return state.slice.every((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => element === collection[start + index]));
    }
}
PaginatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'paginate',
                pure: false
            },] }
];
/** @nocollapse */
PaginatePipe.ctorParameters = () => [
    { type: PaginationService, decorators: [{ type: Optional }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    PaginatePipe.prototype.state;
    /**
     * @type {?}
     * @private
     */
    PaginatePipe.prototype.service;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGUucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvdWktcGFnaW5hdGlvbi8iLCJzb3VyY2VzIjpbImxpYi9wYWdpbmF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7O01BR25ELFlBQVksR0FBRyxNQUFNLENBQUMsZ0JBQWdCOzs7O0FBSTVDLHNDQU9DOzs7SUFORyw4QkFBWTs7SUFDWix3Q0FBK0I7O0lBQy9CLHVDQUE4Qjs7SUFDOUIsc0NBQTZCOztJQUM3QixvQ0FBb0I7O0lBQ3BCLGtDQUFpQjs7Ozs7QUFHckIsK0JBTUM7OztJQUxHLCtCQUFrQjs7SUFDbEIseUJBQWE7O0lBQ2IsMEJBQWM7O0lBQ2Qsd0JBQVk7O0lBQ1osMEJBQWE7O0FBT2pCLE1BQU0sT0FBTyxZQUFZOzs7O0lBS3JCLFlBQWdDLE9BQTBCO1FBQTFCLFlBQU8sR0FBUCxPQUFPLENBQW1COztRQUZsRCxVQUFLLEdBQWdDLEVBQUUsQ0FBQztRQUc1QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO1NBQzFDO0lBQ0wsQ0FBQzs7Ozs7OztJQUVNLFNBQVMsQ0FBNkIsVUFBYSxFQUFFLElBQXNCO1FBRTlFLHFFQUFxRTtRQUNyRSxtRUFBbUU7UUFDbkUsbUVBQW1FO1FBQ25FLG9EQUFvRDtRQUlwRCxJQUFJLENBQUMsQ0FBQyxVQUFVLFlBQVksS0FBSyxDQUFDLEVBQUU7O2tCQUMxQixHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUMvQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JB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IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUGFnaW5hdGlvblNlcnZpY2UgfSBmcm9tICcuL3BhZ2luYXRpb24uc2VydmljZSc7XHJcbmltcG9ydCB7IFBhZ2luYXRpb25JbnN0YW5jZSB9IGZyb20gJy4vcGFnaW5hdGlvbi1pbnN0YW5jZSc7XHJcblxyXG5jb25zdCBMQVJHRV9OVU1CRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuXHJcbmV4cG9ydCB0eXBlIENvbGxlY3Rpb248VD4gPSBUW10gfCBSZWFkb25seUFycmF5PFQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0ZVBpcGVBcmdzIHtcclxuICAgIGlkPzogc3RyaW5nO1xyXG4gICAgaXRlbXNQZXJQYWdlPzogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgY3VycmVudFBhZ2U/OiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICB0b3RhbEl0ZW1zPzogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgcGFnZUxpc3Q/OiBudW1iZXJbXTtcclxuICAgIHJlbW90ZT86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGlwZVN0YXRlIHtcclxuICAgIGNvbGxlY3Rpb246IGFueVtdO1xyXG4gICAgc2l6ZTogbnVtYmVyO1xyXG4gICAgc3RhcnQ6IG51bWJlcjtcclxuICAgIGVuZDogbnVtYmVyO1xyXG4gICAgc2xpY2U6IGFueVtdO1xyXG59XHJcblxyXG5AUGlwZSh7XHJcbiAgICBuYW1lOiAncGFnaW5hdGUnLFxyXG4gICAgcHVyZTogZmFsc2VcclxufSlcclxuZXhwb3J0IGNsYXNzIFBhZ2luYXRlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG5cclxuICAgIC8vIHN0b3JlIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbGFzdCB0aW1lIHRoZSBwaXBlIHdhcyBpbnZva2VkXHJcbiAgICBwcml2YXRlIHN0YXRlOiB7IFtpZDogc3RyaW5nXTogUGlwZVN0YXRlIH0gPSB7fTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIHNlcnZpY2U6IFBhZ2luYXRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlID0gbmV3IFBhZ2luYXRpb25TZXJ2aWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm08VCwgVSBleHRlbmRzIENvbGxlY3Rpb248VD4+KGNvbGxlY3Rpb246IFUsIGFyZ3M6IFBhZ2luYXRlUGlwZUFyZ3MpOiBVIHtcclxuXHJcbiAgICAgICAgLy8gV2hlbiBhbiBvYnNlcnZhYmxlIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBBc3luY1BpcGUsIGl0IHdpbGwgb3V0cHV0XHJcbiAgICAgICAgLy8gYG51bGxgIHVudGlsIHRoZSBzdWJzY3JpcHRpb24gcmVzb2x2ZXMuIEluIHRoaXMgY2FzZSwgd2Ugd2FudCB0b1xyXG4gICAgICAgIC8vIHVzZSB0aGUgY2FjaGVkIGRhdGEgZnJvbSB0aGUgYHN0YXRlYCBvYmplY3QgdG8gcHJldmVudCB0aGUgTmdGb3JcclxuICAgICAgICAvLyBmcm9tIGZsYXNoaW5nIGVtcHR5IHVudGlsIHRoZSByZWFsIHZhbHVlcyBhcnJpdmUuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKCEoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBfaWQgPSBhcmdzLmlkIHx8IHRoaXMuc2VydmljZS5kZWZhdWx0SWQoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVbX2lkXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVbX2lkXS5zbGljZSBhcyBVO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnN0IHNlcnZlclNpZGVNb2RlID0gYXJncy50b3RhbEl0ZW1zICYmIGFyZ3MudG90YWxJdGVtcyAhPT0gY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyU2lkZU1vZGUgPSBhcmdzLnJlbW90ZTtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuY3JlYXRlSW5zdGFuY2UoY29sbGVjdGlvbiwgYXJncyk7XHJcbiAgICAgICAgY29uc3QgaWQgPSBpbnN0YW5jZS5pZDtcclxuICAgICAgICBsZXQgc3RhcnQ6IG51bWJlcjtcclxuICAgICAgICBsZXQgZW5kOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHBlclBhZ2UgPSBpbnN0YW5jZS5pdGVtc1BlclBhZ2U7XHJcblxyXG4gICAgICAgIHRoaXMuc2VydmljZS5yZWdpc3RlcihpbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIGlmICghc2VydmVyU2lkZU1vZGUgJiYgY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIHBlclBhZ2UgPSArcGVyUGFnZSB8fCBMQVJHRV9OVU1CRVI7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gKGluc3RhbmNlLmN1cnJlbnRQYWdlIC0gMSkgKiBwZXJQYWdlO1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIHBlclBhZ2U7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpc0lkZW50aWNhbCA9IHRoaXMuc3RhdGVJc0lkZW50aWNhbChpZCwgY29sbGVjdGlvbiwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIGlmIChpc0lkZW50aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVbaWRdLnNsaWNlIGFzIFU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbGljZSA9IGNvbGxlY3Rpb24uc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVTdGF0ZShpZCwgY29sbGVjdGlvbiwgc2xpY2UsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmNoYW5nZS5lbWl0KGlkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZSBhcyBVO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzYXZlIHRoZSBzdGF0ZSBmb3Igc2VydmVyLXNpZGUgY29sbGVjdGlvbiB0byBhdm9pZCBudWxsXHJcbiAgICAgICAgLy8gZmxhc2ggYXMgbmV3IGRhdGEgbG9hZHMuXHJcbiAgICAgICAgdGhpcy5zYXZlU3RhdGUoaWQsIGNvbGxlY3Rpb24sIGNvbGxlY3Rpb24sIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIFBhZ2luYXRpb25JbnN0YW5jZSBvYmplY3QsIHVzaW5nIGRlZmF1bHRzIGZvciBhbnkgb3B0aW9uYWwgcHJvcGVydGllcyBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlSW5zdGFuY2UoY29sbGVjdGlvbjogYW55W10sIGNvbmZpZzogUGFnaW5hdGVQaXBlQXJncyk6IFBhZ2luYXRpb25JbnN0YW5jZSB7XHJcbiAgICAgICAgLy8gdGhpcy5jaGVja0NvbmZpZyhjb25maWcpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogY29uZmlnLmlkICE9IG51bGwgPyBjb25maWcuaWQgOiB0aGlzLnNlcnZpY2UuZGVmYXVsdElkKCksXHJcbiAgICAgICAgICAgIGl0ZW1zUGVyUGFnZTogK2NvbmZpZy5pdGVtc1BlclBhZ2UgfHwgMCxcclxuICAgICAgICAgICAgY3VycmVudFBhZ2U6ICtjb25maWcuY3VycmVudFBhZ2UgfHwgMSxcclxuICAgICAgICAgICAgdG90YWxJdGVtczogK2NvbmZpZy50b3RhbEl0ZW1zIHx8IGNvbGxlY3Rpb24ubGVuZ3RoLFxyXG4gICAgICAgICAgICBwYWdlTGlzdDogY29uZmlnLnBhZ2VMaXN0IHx8IFsxMCwgMjAsIDMwLCA1MCwgMTAwXSxcclxuICAgICAgICAgICAgcmVtb3RlOiBjb25maWcucmVtb3RlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBmaWx0ZXIgY29udGFpbnMgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tDb25maWcoY29uZmlnOiBQYWdpbmF0ZVBpcGVBcmdzKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBbJ2l0ZW1zUGVyUGFnZScsICdjdXJyZW50UGFnZSddO1xyXG5cclxuICAgICAgICBjb25zdCBtaXNzaW5nID0gcmVxdWlyZWQuZmlsdGVyKHByb3AgPT4gIShwcm9wIGluIGNvbmZpZykpO1xyXG4gICAgICAgIGlmICgwIDwgbWlzc2luZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYWdpbmF0ZVBpcGU6IEFyZ3VtZW50IGlzIG1pc3NpbmcgdGhlIGZvbGxvd2luZyByZXF1aXJlZCBwcm9wZXJ0aWVzOiAke21pc3Npbmcuam9pbignLCAnKX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBhdm9pZCByZXR1cm5pbmcgYSBicmFuZCBuZXcgYXJyYXkgZWFjaCB0aW1lIHRoZSBwaXBlIGlzIHJ1biwgd2Ugc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBzbGljZWRcclxuICAgICAqIGFycmF5IGZvciBhIGdpdmVuIGlkLiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5leHQgdGltZSB0aGUgcGlwZSBpcyBydW4gb24gdGhpcyBjb2xsZWN0aW9uICYgaWQsIHdlIGp1c3RcclxuICAgICAqIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgY29sbGVjdGlvbiwgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIGFsbCBpZGVudGljYWwsIGFuZCBpZiBzbywgcmV0dXJuIHRoZVxyXG4gICAgICogbGFzdCBzbGljZWQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2F2ZVN0YXRlKGlkOiBzdHJpbmcsIGNvbGxlY3Rpb246IGFueVtdLCBzbGljZTogYW55W10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZVtpZF0gPSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgIHNpemU6IGNvbGxlY3Rpb24ubGVuZ3RoLFxyXG4gICAgICAgICAgICBzbGljZSxcclxuICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgYSBnaXZlbiBpZCwgcmV0dXJucyB0cnVlIGlmIHRoZSBjb2xsZWN0aW9uLCBzaXplLCBzdGFydCBhbmQgZW5kIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRlSXNJZGVudGljYWwoaWQ6IHN0cmluZywgY29sbGVjdGlvbjogYW55W10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlW2lkXTtcclxuICAgICAgICBpZiAoIXN0YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNNZXRhRGF0YUlkZW50aWNhbCA9IHN0YXRlLnNpemUgPT09IGNvbGxlY3Rpb24ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHN0YXRlLnN0YXJ0ID09PSBzdGFydCAmJlxyXG4gICAgICAgICAgICBzdGF0ZS5lbmQgPT09IGVuZDtcclxuXHJcbiAgICAgICAgaWYgKCFpc01ldGFEYXRhSWRlbnRpY2FsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdGF0ZS5zbGljZS5ldmVyeSgoZWxlbWVudCwgaW5kZXgpID0+IGVsZW1lbnQgPT09IGNvbGxlY3Rpb25bc3RhcnQgKyBpbmRleF0pO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==