/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Optional, Pipe } from '@angular/core';
import { PaginationService } from './pagination.service';
/** @type {?} */
var LARGE_NUMBER = Number.MAX_SAFE_INTEGER;
/**
 * @record
 */
export function PaginatePipeArgs() { }
if (false) {
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.id;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.itemsPerPage;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.currentPage;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.totalItems;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.pageList;
    /** @type {?|undefined} */
    PaginatePipeArgs.prototype.remote;
}
/**
 * @record
 */
export function PipeState() { }
if (false) {
    /** @type {?} */
    PipeState.prototype.collection;
    /** @type {?} */
    PipeState.prototype.size;
    /** @type {?} */
    PipeState.prototype.start;
    /** @type {?} */
    PipeState.prototype.end;
    /** @type {?} */
    PipeState.prototype.slice;
}
var PaginatePipe = /** @class */ (function () {
    function PaginatePipe(service) {
        this.service = service;
        // store the values from the last time the pipe was invoked
        this.state = {};
        if (!this.service) {
            this.service = new PaginationService();
        }
    }
    /**
     * @template T, U
     * @param {?} collection
     * @param {?} args
     * @return {?}
     */
    PaginatePipe.prototype.transform = /**
     * @template T, U
     * @param {?} collection
     * @param {?} args
     * @return {?}
     */
    function (collection, args) {
        // When an observable is passed through the AsyncPipe, it will output
        // `null` until the subscription resolves. In this case, we want to
        // use the cached data from the `state` object to prevent the NgFor
        // from flashing empty until the real values arrive.
        if (!(collection instanceof Array)) {
            /** @type {?} */
            var _id = args.id || this.service.defaultId();
            if (this.state[_id]) {
                return (/** @type {?} */ (this.state[_id].slice));
            }
            else {
                return collection;
            }
        }
        // const serverSideMode = args.totalItems && args.totalItems !== collection.length;
        /** @type {?} */
        var serverSideMode = args.remote;
        /** @type {?} */
        var instance = this.createInstance(collection, args);
        /** @type {?} */
        var id = instance.id;
        /** @type {?} */
        var start;
        /** @type {?} */
        var end;
        /** @type {?} */
        var perPage = instance.itemsPerPage;
        this.service.register(instance);
        if (!serverSideMode && collection instanceof Array) {
            perPage = +perPage || LARGE_NUMBER;
            start = (instance.currentPage - 1) * perPage;
            end = start + perPage;
            /** @type {?} */
            var isIdentical = this.stateIsIdentical(id, collection, start, end);
            if (isIdentical) {
                return (/** @type {?} */ (this.state[id].slice));
            }
            else {
                /** @type {?} */
                var slice = collection.slice(start, end);
                this.saveState(id, collection, slice, start, end);
                this.service.change.emit(id);
                return (/** @type {?} */ (slice));
            }
        }
        // save the state for server-side collection to avoid null
        // flash as new data loads.
        this.saveState(id, collection, collection, start, end);
        return collection;
    };
    /**
     * Create an PaginationInstance object, using defaults for any optional properties not supplied.
     */
    /**
     * Create an PaginationInstance object, using defaults for any optional properties not supplied.
     * @private
     * @param {?} collection
     * @param {?} config
     * @return {?}
     */
    PaginatePipe.prototype.createInstance = /**
     * Create an PaginationInstance object, using defaults for any optional properties not supplied.
     * @private
     * @param {?} collection
     * @param {?} config
     * @return {?}
     */
    function (collection, config) {
        // this.checkConfig(config);
        return {
            id: config.id != null ? config.id : this.service.defaultId(),
            itemsPerPage: +config.itemsPerPage || 0,
            currentPage: +config.currentPage || 1,
            totalItems: +config.totalItems || collection.length,
            pageList: config.pageList || [10, 20, 30, 50, 100],
            remote: config.remote
        };
    };
    /**
     * Ensure the argument passed to the filter contains the required properties.
     */
    /**
     * Ensure the argument passed to the filter contains the required properties.
     * @private
     * @param {?} config
     * @return {?}
     */
    PaginatePipe.prototype.checkConfig = /**
     * Ensure the argument passed to the filter contains the required properties.
     * @private
     * @param {?} config
     * @return {?}
     */
    function (config) {
        /** @type {?} */
        var required = ['itemsPerPage', 'currentPage'];
        /** @type {?} */
        var missing = required.filter((/**
         * @param {?} prop
         * @return {?}
         */
        function (prop) { return !(prop in config); }));
        if (0 < missing.length) {
            throw new Error("PaginatePipe: Argument is missing the following required properties: " + missing.join(', '));
        }
    };
    /**
     * To avoid returning a brand new array each time the pipe is run, we store the state of the sliced
     * array for a given id. This means that the next time the pipe is run on this collection & id, we just
     * need to check that the collection, start and end points are all identical, and if so, return the
     * last sliced array.
     */
    /**
     * To avoid returning a brand new array each time the pipe is run, we store the state of the sliced
     * array for a given id. This means that the next time the pipe is run on this collection & id, we just
     * need to check that the collection, start and end points are all identical, and if so, return the
     * last sliced array.
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} slice
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    PaginatePipe.prototype.saveState = /**
     * To avoid returning a brand new array each time the pipe is run, we store the state of the sliced
     * array for a given id. This means that the next time the pipe is run on this collection & id, we just
     * need to check that the collection, start and end points are all identical, and if so, return the
     * last sliced array.
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} slice
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (id, collection, slice, start, end) {
        this.state[id] = {
            collection: collection,
            size: collection.length,
            slice: slice,
            start: start,
            end: end
        };
    };
    /**
     * For a given id, returns true if the collection, size, start and end values are identical.
     */
    /**
     * For a given id, returns true if the collection, size, start and end values are identical.
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    PaginatePipe.prototype.stateIsIdentical = /**
     * For a given id, returns true if the collection, size, start and end values are identical.
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (id, collection, start, end) {
        /** @type {?} */
        var state = this.state[id];
        if (!state) {
            return false;
        }
        /** @type {?} */
        var isMetaDataIdentical = state.size === collection.length &&
            state.start === start &&
            state.end === end;
        if (!isMetaDataIdentical) {
            return false;
        }
        return state.slice.every((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        function (element, index) { return element === collection[start + index]; }));
    };
    PaginatePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'paginate',
                    pure: false
                },] }
    ];
    /** @nocollapse */
    PaginatePipe.ctorParameters = function () { return [
        { type: PaginationService, decorators: [{ type: Optional }] }
    ]; };
    return PaginatePipe;
}());
export { PaginatePipe };
if (false) {
    /**
     * @type {?}
     * @private
     */
    PaginatePipe.prototype.state;
    /**
     * @type {?}
     * @private
     */
    PaginatePipe.prototype.service;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGUucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvdWktcGFnaW5hdGlvbi8iLCJzb3VyY2VzIjpbImxpYi9wYWdpbmF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7O0lBR25ELFlBQVksR0FBRyxNQUFNLENBQUMsZ0JBQWdCOzs7O0FBSTVDLHNDQU9DOzs7SUFORyw4QkFBWTs7SUFDWix3Q0FBK0I7O0lBQy9CLHVDQUE4Qjs7SUFDOUIsc0NBQTZCOztJQUM3QixvQ0FBb0I7O0lBQ3BCLGtDQUFpQjs7Ozs7QUFHckIsK0JBTUM7OztJQUxHLCtCQUFrQjs7SUFDbEIseUJBQWE7O0lBQ2IsMEJBQWM7O0lBQ2Qsd0JBQVk7O0lBQ1osMEJBQWE7O0FBR2pCO0lBU0ksc0JBQWdDLE9BQTBCO1FBQTFCLFlBQU8sR0FBUCxPQUFPLENBQW1COztRQUZsRCxVQUFLLEdBQWdDLEVBQUUsQ0FBQztRQUc1QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO1NBQzFDO0lBQ0wsQ0FBQzs7Ozs7OztJQUVNLGdDQUFTOzs7Ozs7SUFBaEIsVUFBNkMsVUFBYSxFQUFFLElBQXNCO1FBRTlFLHFFQUFxRTtRQUNyRSxtRUFBbUU7UUFDbkUsbUVBQW1FO1FBQ25FLG9EQUFvRDtRQUlwRCxJQUFJLENBQUMsQ0FBQyxVQUFVLFlBQVksS0FBSyxDQUFDLEVBQUU7O2dCQUMxQixHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUMvQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2pCLE9BQU8sbUJBQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUssQ0FBQzthQUNyQztpQkFBTTtnQkFDSCxPQUFPLFVBQVUsQ0FBQzthQUNyQjtTQUNKOzs7WUFHSyxjQUFjLEdBQUcsSUFBSSxDQUFDLE1BQU07O1lBQzVCLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUM7O1lBQ2hELEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRTs7WUFDbEIsS0FBYTs7WUFDYixHQUFXOztZQUNYLE9BQU8sR0FBRyxRQUFRLENBQUMsWUFBWTtRQUVuQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVoQyxJQUFJLENBQUMsY0FBYyxJQUFJLFVBQVUsWUFBWSxLQUFLLEVBQUU7WUFDaEQsT0FBTyxHQUFHLENBQUMsT0FBTyxJQUFJLFlBQVksQ0FBQztZQUNuQyxLQUFLLEdBQUcsQ0FBQyxRQUFRLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztZQUM3QyxHQUFHLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQzs7Z0JBRWhCLFdBQVcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDO1lBQ3JFLElBQUksV0FBVyxFQUFFO2dCQUNiLE9BQU8sbUJBQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUssQ0FBQzthQUNwQztpQkFBTTs7b0JBQ0csS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQztnQkFDMUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ2xELElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDN0IsT0FBTyxtQkFBQSxLQUFLLEVBQUssQ0FBQzthQUNyQjtTQUNKO1FBRUQsMERBQTBEO1FBQzFELDJCQUEyQjtRQUMzQixJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN2RCxPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7O0lBQ0sscUNBQWM7Ozs7Ozs7SUFBdEIsVUFBdUIsVUFBaUIsRUFBRSxNQUF3QjtRQUM5RCw0QkFBNEI7UUFFNUIsT0FBTztZQUNILEVBQUUsRUFBRSxNQUFNLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDNUQsWUFBWSxFQUFFLENBQUMsTUFBTSxDQUFDLFlBQVksSUFBSSxDQUFDO1lBQ3ZDLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLElBQUksQ0FBQztZQUNyQyxVQUFVLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQyxNQUFNO1lBQ25ELFFBQVEsRUFBRSxNQUFNLENBQUMsUUFBUSxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsQ0FBQztZQUNsRCxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU07U0FDeEIsQ0FBQztJQUNOLENBQUM7SUFFRDs7T0FFRzs7Ozs7OztJQUNLLGtDQUFXOzs7Ozs7SUFBbkIsVUFBb0IsTUFBd0I7O1lBQ2xDLFFBQVEsR0FBRyxDQUFDLGNBQWMsRUFBRSxhQUFhLENBQUM7O1lBRTFDLE9BQU8sR0FBRyxRQUFRLENBQUMsTUFBTTs7OztRQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsQ0FBQyxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsRUFBakIsQ0FBaUIsRUFBQztRQUMxRCxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEVBQXdFLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFHLENBQUMsQ0FBQztTQUNqSDtJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRzs7Ozs7Ozs7Ozs7Ozs7SUFDSyxnQ0FBUzs7Ozs7Ozs7Ozs7OztJQUFqQixVQUFrQixFQUFVLEVBQUUsVUFBaUIsRUFBRSxLQUFZLEVBQUUsS0FBYSxFQUFFLEdBQVc7UUFDckYsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRztZQUNiLFVBQVUsWUFBQTtZQUNWLElBQUksRUFBRSxVQUFVLENBQUMsTUFBTTtZQUN2QixLQUFLLE9BQUE7WUFDTCxLQUFLLE9BQUE7WUFDTCxHQUFHLEtBQUE7U0FDTixDQUFDO0lBQ04sQ0FBQztJQUVEOztPQUVHOzs7Ozs7Ozs7O0lBQ0ssdUNBQWdCOzs7Ozs7Ozs7SUFBeEIsVUFBeUIsRUFBVSxFQUFFLFVBQWlCLEVBQUUsS0FBYSxFQUFFLEdBQVc7O1lBQ3hFLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUM1QixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1IsT0FBTyxLQUFLLENBQUM7U0FDaEI7O1lBQ0ssbUJBQW1CLEdBQUcsS0FBSyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsTUFBTTtZQUN4RCxLQUFLLENBQUMsS0FBSyxLQUFLLEtBQUs7WUFDckIsS0FBSyxDQUFDLEdBQUcsS0FBSyxHQUFHO1FBRXJCLElBQUksQ0FBQyxtQkFBbUIsRUFBRTtZQUN0QixPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLOzs7OztRQUFDLFVBQUMsT0FBTyxFQUFFLEtBQUssSUFBSyxPQUFBLE9BQU8sS0FBSyxVQUFVLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxFQUFyQyxDQUFxQyxFQUFDLENBQUM7SUFDeEYsQ0FBQzs7Z0JBOUhKLElBQUksU0FBQztvQkFDRixJQUFJLEVBQUUsVUFBVTtvQkFDaEIsSUFBSSxFQUFFLEtBQUs7aUJBQ2Q7Ozs7Z0JBM0JRLGlCQUFpQix1QkFpQ1QsUUFBUTs7SUFzSHpCLG1CQUFDO0NBQUEsQUEvSEQsSUErSEM7U0EzSFksWUFBWTs7Ozs7O0lBR3JCLDZCQUFnRDs7Ozs7SUFFcEMsK0JBQThDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3B0aW9uYWwsIFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUGFnaW5hdGlvblNlcnZpY2UgfSBmcm9tICcuL3BhZ2luYXRpb24uc2VydmljZSc7XHJcbmltcG9ydCB7IFBhZ2luYXRpb25JbnN0YW5jZSB9IGZyb20gJy4vcGFnaW5hdGlvbi1pbnN0YW5jZSc7XHJcblxyXG5jb25zdCBMQVJHRV9OVU1CRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuXHJcbmV4cG9ydCB0eXBlIENvbGxlY3Rpb248VD4gPSBUW10gfCBSZWFkb25seUFycmF5PFQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0ZVBpcGVBcmdzIHtcclxuICAgIGlkPzogc3RyaW5nO1xyXG4gICAgaXRlbXNQZXJQYWdlPzogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgY3VycmVudFBhZ2U/OiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICB0b3RhbEl0ZW1zPzogc3RyaW5nIHwgbnVtYmVyO1xyXG4gICAgcGFnZUxpc3Q/OiBudW1iZXJbXTtcclxuICAgIHJlbW90ZT86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGlwZVN0YXRlIHtcclxuICAgIGNvbGxlY3Rpb246IGFueVtdO1xyXG4gICAgc2l6ZTogbnVtYmVyO1xyXG4gICAgc3RhcnQ6IG51bWJlcjtcclxuICAgIGVuZDogbnVtYmVyO1xyXG4gICAgc2xpY2U6IGFueVtdO1xyXG59XHJcblxyXG5AUGlwZSh7XHJcbiAgICBuYW1lOiAncGFnaW5hdGUnLFxyXG4gICAgcHVyZTogZmFsc2VcclxufSlcclxuZXhwb3J0IGNsYXNzIFBhZ2luYXRlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG5cclxuICAgIC8vIHN0b3JlIHRoZSB2YWx1ZXMgZnJvbSB0aGUgbGFzdCB0aW1lIHRoZSBwaXBlIHdhcyBpbnZva2VkXHJcbiAgICBwcml2YXRlIHN0YXRlOiB7IFtpZDogc3RyaW5nXTogUGlwZVN0YXRlIH0gPSB7fTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIHNlcnZpY2U6IFBhZ2luYXRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlID0gbmV3IFBhZ2luYXRpb25TZXJ2aWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm08VCwgVSBleHRlbmRzIENvbGxlY3Rpb248VD4+KGNvbGxlY3Rpb246IFUsIGFyZ3M6IFBhZ2luYXRlUGlwZUFyZ3MpOiBVIHtcclxuXHJcbiAgICAgICAgLy8gV2hlbiBhbiBvYnNlcnZhYmxlIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBBc3luY1BpcGUsIGl0IHdpbGwgb3V0cHV0XHJcbiAgICAgICAgLy8gYG51bGxgIHVudGlsIHRoZSBzdWJzY3JpcHRpb24gcmVzb2x2ZXMuIEluIHRoaXMgY2FzZSwgd2Ugd2FudCB0b1xyXG4gICAgICAgIC8vIHVzZSB0aGUgY2FjaGVkIGRhdGEgZnJvbSB0aGUgYHN0YXRlYCBvYmplY3QgdG8gcHJldmVudCB0aGUgTmdGb3JcclxuICAgICAgICAvLyBmcm9tIGZsYXNoaW5nIGVtcHR5IHVudGlsIHRoZSByZWFsIHZhbHVlcyBhcnJpdmUuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKCEoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBfaWQgPSBhcmdzLmlkIHx8IHRoaXMuc2VydmljZS5kZWZhdWx0SWQoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVbX2lkXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVbX2lkXS5zbGljZSBhcyBVO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnN0IHNlcnZlclNpZGVNb2RlID0gYXJncy50b3RhbEl0ZW1zICYmIGFyZ3MudG90YWxJdGVtcyAhPT0gY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc2VydmVyU2lkZU1vZGUgPSBhcmdzLnJlbW90ZTtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuY3JlYXRlSW5zdGFuY2UoY29sbGVjdGlvbiwgYXJncyk7XHJcbiAgICAgICAgY29uc3QgaWQgPSBpbnN0YW5jZS5pZDtcclxuICAgICAgICBsZXQgc3RhcnQ6IG51bWJlcjtcclxuICAgICAgICBsZXQgZW5kOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHBlclBhZ2UgPSBpbnN0YW5jZS5pdGVtc1BlclBhZ2U7XHJcblxyXG4gICAgICAgIHRoaXMuc2VydmljZS5yZWdpc3RlcihpbnN0YW5jZSk7XHJcblxyXG4gICAgICAgIGlmICghc2VydmVyU2lkZU1vZGUgJiYgY29sbGVjdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIHBlclBhZ2UgPSArcGVyUGFnZSB8fCBMQVJHRV9OVU1CRVI7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gKGluc3RhbmNlLmN1cnJlbnRQYWdlIC0gMSkgKiBwZXJQYWdlO1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIHBlclBhZ2U7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpc0lkZW50aWNhbCA9IHRoaXMuc3RhdGVJc0lkZW50aWNhbChpZCwgY29sbGVjdGlvbiwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIGlmIChpc0lkZW50aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVbaWRdLnNsaWNlIGFzIFU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbGljZSA9IGNvbGxlY3Rpb24uc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVTdGF0ZShpZCwgY29sbGVjdGlvbiwgc2xpY2UsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmNoYW5nZS5lbWl0KGlkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbGljZSBhcyBVO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzYXZlIHRoZSBzdGF0ZSBmb3Igc2VydmVyLXNpZGUgY29sbGVjdGlvbiB0byBhdm9pZCBudWxsXHJcbiAgICAgICAgLy8gZmxhc2ggYXMgbmV3IGRhdGEgbG9hZHMuXHJcbiAgICAgICAgdGhpcy5zYXZlU3RhdGUoaWQsIGNvbGxlY3Rpb24sIGNvbGxlY3Rpb24sIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIFBhZ2luYXRpb25JbnN0YW5jZSBvYmplY3QsIHVzaW5nIGRlZmF1bHRzIGZvciBhbnkgb3B0aW9uYWwgcHJvcGVydGllcyBub3Qgc3VwcGxpZWQuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlSW5zdGFuY2UoY29sbGVjdGlvbjogYW55W10sIGNvbmZpZzogUGFnaW5hdGVQaXBlQXJncyk6IFBhZ2luYXRpb25JbnN0YW5jZSB7XHJcbiAgICAgICAgLy8gdGhpcy5jaGVja0NvbmZpZyhjb25maWcpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogY29uZmlnLmlkICE9IG51bGwgPyBjb25maWcuaWQgOiB0aGlzLnNlcnZpY2UuZGVmYXVsdElkKCksXHJcbiAgICAgICAgICAgIGl0ZW1zUGVyUGFnZTogK2NvbmZpZy5pdGVtc1BlclBhZ2UgfHwgMCxcclxuICAgICAgICAgICAgY3VycmVudFBhZ2U6ICtjb25maWcuY3VycmVudFBhZ2UgfHwgMSxcclxuICAgICAgICAgICAgdG90YWxJdGVtczogK2NvbmZpZy50b3RhbEl0ZW1zIHx8IGNvbGxlY3Rpb24ubGVuZ3RoLFxyXG4gICAgICAgICAgICBwYWdlTGlzdDogY29uZmlnLnBhZ2VMaXN0IHx8IFsxMCwgMjAsIDMwLCA1MCwgMTAwXSxcclxuICAgICAgICAgICAgcmVtb3RlOiBjb25maWcucmVtb3RlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBmaWx0ZXIgY29udGFpbnMgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgY2hlY2tDb25maWcoY29uZmlnOiBQYWdpbmF0ZVBpcGVBcmdzKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBbJ2l0ZW1zUGVyUGFnZScsICdjdXJyZW50UGFnZSddO1xyXG5cclxuICAgICAgICBjb25zdCBtaXNzaW5nID0gcmVxdWlyZWQuZmlsdGVyKHByb3AgPT4gIShwcm9wIGluIGNvbmZpZykpO1xyXG4gICAgICAgIGlmICgwIDwgbWlzc2luZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYWdpbmF0ZVBpcGU6IEFyZ3VtZW50IGlzIG1pc3NpbmcgdGhlIGZvbGxvd2luZyByZXF1aXJlZCBwcm9wZXJ0aWVzOiAke21pc3Npbmcuam9pbignLCAnKX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBhdm9pZCByZXR1cm5pbmcgYSBicmFuZCBuZXcgYXJyYXkgZWFjaCB0aW1lIHRoZSBwaXBlIGlzIHJ1biwgd2Ugc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBzbGljZWRcclxuICAgICAqIGFycmF5IGZvciBhIGdpdmVuIGlkLiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5leHQgdGltZSB0aGUgcGlwZSBpcyBydW4gb24gdGhpcyBjb2xsZWN0aW9uICYgaWQsIHdlIGp1c3RcclxuICAgICAqIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgY29sbGVjdGlvbiwgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIGFsbCBpZGVudGljYWwsIGFuZCBpZiBzbywgcmV0dXJuIHRoZVxyXG4gICAgICogbGFzdCBzbGljZWQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2F2ZVN0YXRlKGlkOiBzdHJpbmcsIGNvbGxlY3Rpb246IGFueVtdLCBzbGljZTogYW55W10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZVtpZF0gPSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgIHNpemU6IGNvbGxlY3Rpb24ubGVuZ3RoLFxyXG4gICAgICAgICAgICBzbGljZSxcclxuICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgYSBnaXZlbiBpZCwgcmV0dXJucyB0cnVlIGlmIHRoZSBjb2xsZWN0aW9uLCBzaXplLCBzdGFydCBhbmQgZW5kIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRlSXNJZGVudGljYWwoaWQ6IHN0cmluZywgY29sbGVjdGlvbjogYW55W10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlW2lkXTtcclxuICAgICAgICBpZiAoIXN0YXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNNZXRhRGF0YUlkZW50aWNhbCA9IHN0YXRlLnNpemUgPT09IGNvbGxlY3Rpb24ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHN0YXRlLnN0YXJ0ID09PSBzdGFydCAmJlxyXG4gICAgICAgICAgICBzdGF0ZS5lbmQgPT09IGVuZDtcclxuXHJcbiAgICAgICAgaWYgKCFpc01ldGFEYXRhSWRlbnRpY2FsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdGF0ZS5zbGljZS5ldmVyeSgoZWxlbWVudCwgaW5kZXgpID0+IGVsZW1lbnQgPT09IGNvbGxlY3Rpb25bc3RhcnQgKyBpbmRleF0pO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==