import { BehaviorSubject } from 'rxjs';
import { ViewModelContext } from '../view-model/index';
import { StateDictionary, RenderStateDictionary, RenderDictionary } from './types';
import { StateMachineContext } from './state_machine_context';
import { StateMachineWatcher } from './state_machine_watcher';
/**
 * 状态机
 */
export declare class StateMachine {
    /**
     * 初始状态
     */
    private initialState;
    /**
     * 状态字典
     */
    states: StateDictionary;
    /**
     * 渲染状态字典
     */
    renderStates: RenderStateDictionary;
    /**
     * 渲染器字典
     */
    renders: RenderDictionary;
    /**
     * 状态机上下文
     */
    context: StateMachineContext;
    /**
     * 状态变更
     */
    stateChange: BehaviorSubject<string>;
    /**
     * ViewModel上下文
     */
    viewModelContext: ViewModelContext;
    /**
     * 状态机事件监听
     */
    stateMachineWatcher: StateMachineWatcher;
    /**
     * 构造函数
     */
    constructor();
    /**
     * 初始化状态机
     * @param viewModelContext ViewModel上下文
     * @summary
     * 状态机变更，为了在绑定数据之后执行状态机的操作，把render方法延后执行。
     */
    init(viewModelContext: ViewModelContext): void;
    /**
     * 批量处理属性元数据
     */
    private handlePropMetadatas;
    /**
     * 处理属性元数据
     */
    private handlePropMetadata;
    /**
     * 包装State
     * @param stateName 状态名称
     * @param ngState   状态对象
     */
    private buildState;
    /**
     * 包装RenderState
     * @param renderStateName 渲染状态名称
     * @param ngRenderState   渲染状态元数据
     */
    private buildRenderState;
    /**
     * 包装Action
     * @param actionName 动作名称
     * @param ngAction 动作元数据
     */
    private buildAction;
    /**
     * 重新计算所有渲染状态的值
     * @sumamry
     * 当 state切换的时候，调用遍历所有的render方法，更改renderState
     */
    render(): void;
}
