import { of, from, Subject, Observable, isObservable as isObservable$1, forkJoin, BehaviorSubject, EMPTY as EMPTY$1 } from 'rxjs';
import { switchMap, map, shareReplay, tap, catchError, concatMap, every, take, throwIfEmpty, takeLast } from 'rxjs/operators';
import axios from 'axios';
import 'reflect-metadata';
import { format, parseISO, isDate, isEqual as isEqual$1, compareAsc } from 'date-fns';
import dayjs from 'dayjs';
import IsBetween from 'dayjs/plugin/IsBetween';
import relativeTime from 'dayjs/plugin/relativeTime';
import Calendar from 'dayjs/plugin/calendar';
import 'dayjs/locale/zh-cn';
import { Expression as Expression$1, ExpressionEngine, ExpressionContext } from '@farris/expression-engine';

const Type = Function;
var DataChangeType;
(function (DataChangeType) {
    DataChangeType[DataChangeType["Add"] = 0] = "Add";
    DataChangeType[DataChangeType["Delete"] = 1] = "Delete";
    DataChangeType[DataChangeType["Edit"] = 2] = "Edit";
    DataChangeType[DataChangeType["Append"] = 3] = "Append";
})(DataChangeType || (DataChangeType = {}));

function isType(v) {
    return typeof v === 'function';
}
var InjectFlags;
(function (InjectFlags) {
    InjectFlags[InjectFlags["Default"] = 0] = "Default";
    InjectFlags[InjectFlags["Self"] = 1] = "Self";
    InjectFlags[InjectFlags["SkipSelf"] = 2] = "SkipSelf";
    InjectFlags[InjectFlags["Optional"] = 4] = "Optional";
})(InjectFlags || (InjectFlags = {}));

const EMPTY = [];
const IDENT = function (value) {
    return value;
};
const CIRCULAR = IDENT;
const MULTI_PROVIDER_FN = function () {
    return Array.prototype.slice.call(arguments);
};
const NEW_LINE = /\n/gm;
const NO_NEW_LINE = 'ɵ';
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';

function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (Array.isArray(token)) {
        return '[' + token.map(stringify).join(', ') + ']';
    }
    if (token == null) {
        return '' + token;
    }
    if (token.overriddenName) {
        return `${token.overriddenName}`;
    }
    if (token.name) {
        return `${token.name}`;
    }
    const res = token.toString();
    if (res == null) {
        return '' + res;
    }
    const newLineIndex = res.indexOf('\n');
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function getClosureSafeProperty(objWithPropertyToExtract) {
    for (const key in objWithPropertyToExtract) {
        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
            return key;
        }
    }
    throw Error('Could not find renamed property on target object.');
}
function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === '\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
    let context = stringify(obj);
    if (Array.isArray(obj)) {
        context = obj.map(stringify).join(' -> ');
    }
    else if (typeof obj === 'object') {
        const parts = [];
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));
            }
        }
        context = `{${parts.join(', ')}}`;
    }
    return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\n  ')}`;
}
function staticError(text, obj) {
    return new Error(formatError(text, obj, 'StaticInjectorError'));
}

function ɵɵdefineInjectable(opts) {
    return {
        token: opts.token,
        providedIn: opts.providedIn || null,
        factory: opts.factory,
        value: undefined,
    };
}
const NG_PROV_DEF = getClosureSafeProperty({ ɵprov: getClosureSafeProperty });
const NG_INJ_DEF = getClosureSafeProperty({ ɵinj: getClosureSafeProperty });
const NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
function getOwnDefinition(type, def) {
    return def && def.token === type ? def : null;
}
function getInjectableDef(type) {
    return getOwnDefinition(type, type[NG_PROV_DEF]) ||
        getOwnDefinition(type, type[NG_INJECTABLE_DEF]);
}

class InjectionToken {
    constructor(_desc, options) {
        this._desc = _desc;
        this.ngMetadataName = 'InjectionToken';
        this.ɵprov = undefined;
        if (typeof options === 'number') {
            this.__NG_ELEMENT_ID__ = options;
        }
        else if (options !== undefined) {
            this.ɵprov = ɵɵdefineInjectable({
                token: this,
                providedIn: options.providedIn || 'root',
                factory: options.factory,
            });
        }
    }
    toString() {
        return `InjectionToken ${this._desc}`;
    }
}
function createInjectionToken(token) {
    return new InjectionToken(token);
}

/**
 * 注入器抽象类
 */
class Injector {
}

class NullInjector {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
            error.name = 'NullInjectorError';
            throw error;
        }
        return notFoundValue;
    }
}
const NULL_INJECTOR = new NullInjector();

const __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
}
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () {
        return stringify(this());
    };
    return forwardRefFn;
}
function isForwardRef(fn) {
    return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&
        fn.__forward_ref__ === forwardRef;
}

const INJECTOR = new InjectionToken('INJECTOR', -1);
const ɵ0 = getClosureSafeProperty;
const USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0 });
let _currentInjector = undefined;
function setCurrentInjector(injector) {
    const former = _currentInjector;
    _currentInjector = injector;
    return former;
}
class StaticInjector {
    constructor(providers, parent = NULL_INJECTOR, source = null) {
        parent = parent ? parent : NULL_INJECTOR;
        this.parent = parent;
        this.source = source;
        const records = this._records = new Map();
        records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        this.scope = recursivelyProcessProviders(records, providers);
    }
    get(token, notFoundValue, flags = InjectFlags.Default) {
        const records = this._records;
        let record = records.get(token);
        if (record === undefined) {
            const injectableDef = getInjectableDef(token);
            if (injectableDef) {
                const providedIn = injectableDef && injectableDef.providedIn;
                if (providedIn === 'any' || providedIn != null && providedIn === this.scope) {
                    records.set(token, record = resolveProvider({ provide: token, useFactory: injectableDef.factory, deps: EMPTY }));
                }
            }
            if (record === undefined) {
                records.set(token, null);
            }
        }
        const lastInjector = setCurrentInjector(this);
        try {
            return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
        }
        catch (e) {
            throw e;
        }
        finally {
            setCurrentInjector(lastInjector);
        }
    }
    toString() {
        const tokens = [];
        const records = this._records;
        records.forEach((v, token) => tokens.push(stringify(token)));
        return `StaticInjector[${tokens.join(', ')}]`;
    }
}
function multiProviderMixError(token) {
    return staticError('Cannot mix multi providers and regular providers', token);
}
const INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');
/**
 * 递归处理Provider
 */
function recursivelyProcessProviders(records, provider) {
    let scope = null;
    if (provider) {
        provider = resolveForwardRef(provider);
        if (Array.isArray(provider)) {
            for (let i = 0; i < provider.length; i++) {
                scope = recursivelyProcessProviders(records, provider[i]) || scope;
            }
        }
        else if (typeof provider === 'function') {
            throw staticError('Function/Class not supported', provider);
        }
        else if (provider && typeof provider === 'object' && provider.provide) {
            let token = resolveForwardRef(provider.provide);
            const resolvedProvider = resolveProvider(provider);
            // multi
            if (provider.multi === true) {
                let multiProvider = records.get(token);
                if (multiProvider) {
                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                        throw multiProviderMixError(token);
                    }
                }
                else {
                    records.set(token, multiProvider = {
                        token: provider.provide,
                        deps: [],
                        useNew: false,
                        fn: MULTI_PROVIDER_FN,
                        value: EMPTY
                    });
                }
                token = provider;
                multiProvider.deps.push({ token, options: 6 /* Default */ });
            }
            const record = records.get(token);
            if (record && record.fn === MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
            }
            if (token === INJECTOR_SCOPE) {
                scope = resolvedProvider.value;
            }
            records.set(token, resolvedProvider);
        }
        else {
            throw staticError('Unexpected provider', provider);
        }
    }
    return scope;
}
function resolveProvider(provider) {
    const deps = computeDeps(provider);
    let fn = IDENT;
    let value = EMPTY;
    let useNew = false;
    const provide = resolveForwardRef(provider.provide);
    if (USE_VALUE in provider) {
        value = provider.useValue;
    }
    else if (provider.useFactory) {
        fn = provider.useFactory;
    }
    else if (provider.useExisting) {
        // Just use IDENT
    }
    else if (provider.useClass) {
        // 静态类型
        useNew = true;
        fn = resolveForwardRef(provider.useClass);
    }
    else if (typeof provide === 'function') {
        // 构造函数
        useNew = true;
        fn = provide;
    }
    else {
        throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
    }
    return { deps, fn, useNew, value };
}
/**
 * 计算依赖
 */
function computeDeps(provider) {
    let deps = EMPTY;
    const providerDeps = provider.deps;
    if (providerDeps && providerDeps.length) {
        deps = [];
        for (let i = 0; i < providerDeps.length; i++) {
            const options = 6 /* Default */;
            const token = resolveForwardRef(providerDeps[i]);
            deps.push({ token, options });
        }
    }
    else if (provider.useExisting) {
        const token = resolveForwardRef(provider.useExisting);
        deps = [{ token, options: 6 /* Default */ }];
    }
    else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError('\'deps\' required', provider);
    }
    return deps;
}
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
    try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
    }
    catch (e) {
        if (!(e instanceof Error)) {
            e = new Error(e);
        }
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);
        // 清空循环引用的值
        if (record && record.value === CIRCULAR) {
            record.value = EMPTY;
        }
        throw e;
    }
}
function resolveToken(token, record, records, parent, notFoundValue, flags) {
    let value;
    if (record && !(flags & InjectFlags.SkipSelf)) {
        value = record.value;
        if (value === CIRCULAR) {
            throw Error(NO_NEW_LINE + 'Circular dependency');
        }
        else if (value === EMPTY) {
            record.value = CIRCULAR;
            const useNew = record.useNew;
            const fn = record.fn;
            const depRecords = record.deps;
            let deps = EMPTY;
            if (depRecords.length) {
                deps = [];
                for (let i = 0; i < depRecords.length; i++) {
                    const depRecord = depRecords[i];
                    const options = depRecord.options;
                    const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                    deps.push(tryResolveToken(depRecord.token, childRecord, records, !childRecord && !(options & 4 /* CheckParent */) ? NULL_INJECTOR : parent, options & 1 /* Optional */ ? null : THROW_IF_NOT_FOUND, InjectFlags.Default));
                }
            }
            record.value = value = useNew ? new fn(...deps) : fn.apply(undefined, deps);
        }
    }
    else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
    }
    else if (!(flags & InjectFlags.Optional)) {
        value = NULL_INJECTOR.get(token, notFoundValue);
    }
    else {
        value = NULL_INJECTOR.get(token, typeof notFoundValue !== 'undefined' ? notFoundValue : null);
    }
    return value;
}

function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {
    return new StaticInjector(providers, parent, name);
}
const INJECTOR_IMPL = INJECTOR_IMPL__PRE_R3__;
function createInjector(options, parent) {
    if (Array.isArray(options)) {
        return INJECTOR_IMPL(options, parent, '');
    }
    else {
        return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
    }
}

const ANNOTATIONS = '__annotations__';
const PARAMETERS = '__parameters__';
const PROP_METADATA = '__prop__metadata__';
/**
 * @suppress {globalThis}
 */
function makeDecorator(name, props, parentClass, chainFn, typeFn) {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
        if (this instanceof DecoratorFactory) {
            metaCtor.call(this, ...args);
            return this;
        }
        const annotationInstance = new DecoratorFactory(...args);
        const typeDecorator = function createTypeDecorator(cls) {
            typeFn && typeFn(cls, ...args);
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const annotations = cls.hasOwnProperty(ANNOTATIONS) ?
                cls[ANNOTATIONS] :
                Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
            annotations.push(annotationInstance);
            return cls;
        };
        if (chainFn) {
            chainFn(typeDecorator);
        }
        return typeDecorator;
    }
    if (parentClass) {
        DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
}
function makeMetadataCtor(props) {
    return function ctor(...args) {
        if (props) {
            const values = props(...args);
            // tslint:disable-next-line:forin
            for (const propName in values) {
                this[propName] = values[propName];
            }
        }
    };
}
function makeParamDecorator(name, props, parentClass) {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
        if (this instanceof ParamDecoratorFactory) {
            metaCtor.apply(this, args);
            return this;
        }
        const annotationInstance = new ParamDecoratorFactory(...args);
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
        function ParamDecorator(cls, unusedKey, index) {
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const parameters = cls.hasOwnProperty(PARAMETERS) ?
                cls[PARAMETERS] :
                Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
            // there might be gaps if some in between parameters do not have annotations.
            // we pad with nulls.
            while (parameters.length <= index) {
                parameters.push(null);
            }
            (parameters[index] = parameters[index] || []).push(annotationInstance);
            return cls;
        }
    }
    if (parentClass) {
        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
}
function makePropDecorator(name, props, parentClass) {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
        if (this instanceof PropDecoratorFactory) {
            metaCtor.apply(this, args);
            return this;
        }
        const decoratorInstance = new PropDecoratorFactory(...args);
        // tslint:disable-next-line:no-shadowed-variable
        return function PropDecorator(target, name) {
            const constructor = target.constructor;
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const meta = constructor.hasOwnProperty(PROP_METADATA) ?
                constructor[PROP_METADATA] :
                Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
            meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
            meta[name].unshift(decoratorInstance);
        };
    }
    if (parentClass) {
        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
}

/**
 * 元数据解析
 * 约束：
 * 1、类型装饰器：在某个类型上，某种类型的装饰器，只使用一次，不重复添加；
 * 2、属性装饰器：在某个属性上，某种类型的装饰器，只使用一次，不重复添加
 */
class MetadataUtil {
    // ----------------------------------------
    // 类型元数据
    // ----------------------------------------
    /**
     * 获取类元数据
     * 返回结果形如：
     * [
     *   Injectable
     *   NgViewModel
     *   NgViewModel
     * ]
     */
    static getClassMetadatas(constructor) {
        const metadatas = constructor[ANNOTATIONS];
        return metadatas;
    }
    /**
     * 获取某个class上的某种装饰器
     * 返回结果：NgViewModel
     */
    static getClassMetadataByName(constructor, metadataName) {
        const metadata = this.getClassMetadataByNameWithTranslate(constructor, metadataName, null, null);
        return metadata;
    }
    static getClassMetadataByNameWithTranslate(constructor, metadataName, translateService, keysToTranslate) {
        const allClassMetadatas = this.getClassMetadatas(constructor);
        if (!allClassMetadatas) {
            return null;
        }
        const metadata = allClassMetadatas.find((classMetadata) => {
            return classMetadata.ngMetadataName === metadataName;
        });
        if (metadata && translateService && keysToTranslate) {
            keysToTranslate.forEach((metadataPropKey) => {
                const propertyVariable = metadata[metadataPropKey];
                if (propertyVariable && propertyVariable.startsWith('{{') && propertyVariable.endsWith('}}')) {
                    const translateKey = propertyVariable.replace('{{', '').replace('}}', '').trim();
                    metadata[metadataPropKey] = translateService.transform(translateKey, null);
                }
            });
        }
        return metadata;
    }
    // ----------------------------------------
    // 属性元数据
    // ----------------------------------------
    /**
     * 获取所有属性的所有元数据
     * 返回格式：
     * {
     *   propName1: [ NgDefaultValue, NgMaxLength, NgMinLength],
     *   propName2: [ NgDefaultValue, NgMaxLength, NgMinLength]
     * }
     */
    static getPropsMetadatas(constructor) {
        const allPropMetadatas = constructor[PROP_METADATA];
        return allPropMetadatas;
    }
    /**
     * 获取所有属性的某一类型的元数据
     * 如果同一属性
     * 返回结果：
     * {
     *    propName1: NgDefaultValue,
     *    propName2: NgDefaultValue
     * }
     */
    static getPropsMetadatasByName(constructor, metadataName) {
        const metadatas = this.getPropsMetadatasByNameWithTranslate(constructor, metadataName);
        return metadatas;
    }
    static getPropsMetadatasByNameWithTranslate(constructor, metadataName, translateService, keysToTranslate) {
        const metadatas = {};
        // 读取构造函数中存储的类属性注解。
        const allPropMetadatas = this.getPropsMetadatas(constructor);
        if (!allPropMetadatas) {
            return metadatas;
        }
        // 遍历所有属性提取注解信息。
        Object.keys(allPropMetadatas).forEach((propName) => {
            // 提取当前属性注解对象
            const propMetadatas = allPropMetadatas[propName];
            // 提取指定类型的注解项
            const metadata = propMetadatas.find((propMetadata) => {
                return propMetadata.ngMetadataName === metadataName;
            });
            if (translateService && keysToTranslate) {
                keysToTranslate.forEach((metadataPropKey) => {
                    const propertyVariable = metadata[metadataPropKey];
                    if (propertyVariable && propertyVariable.startsWith('{{') && propertyVariable.endsWith('}}')) {
                        const translateKey = propertyVariable.replace('{{', '').replace('}}', '').trim();
                        metadata[metadataPropKey] = translateService.transform(translateKey, null);
                    }
                });
            }
            if (metadata) {
                metadatas[propName] = metadata;
            }
        });
        return metadatas;
    }
    /**
     * 获取某个属性的所有元数据
     * 返回格式：[ NgDefaultValue, NgMaxLength, NgMinLength]
     */
    static getPropMetadatasByName(constructor, propName) {
        // 暂不实现
        return null;
    }
    /**
     * 获取某个属性的某种元数据
     * 返回格式：NgDefaultValue
     */
    static getPropMetadataByName(constructor, propName, metadataName) {
        // 暂不实现
        return null;
    }
}

/**
 * HttpMethods
 */
class HttpMethods {
}
HttpMethods.GET = 'GET';
HttpMethods.DELETE = 'DELETE';
HttpMethods.HEAD = 'HEAD';
HttpMethods.OPTIONS = 'OPTIONS';
HttpMethods.POST = 'POST';
HttpMethods.PUT = 'PUT';
HttpMethods.PATCH = 'PATCH';
HttpMethods.LINK = 'LINK';
HttpMethods.UNLINK = 'UNLINK';

class HttpUtil {
    /**
     * 追加Header
     */
    static appendHeader(headers, key, value) {
        headers = Object.assign({}, headers, { [key]: value });
        return headers;
    }
    /**
     * 向RequestConfig中追加body
     */
    static appendBodyToRequestConfig(body, requestConfig) {
        if (!requestConfig) {
            requestConfig = {};
        }
        requestConfig = Object.assign({}, requestConfig, { body: body });
        return requestConfig;
    }
    /**
     * 构造AxiosReqeustConfig
     */
    static buildAxiosRequestConfig(method, url, requestConfig) {
        requestConfig = requestConfig || {};
        const axiosRequestConfig = {
            url: url,
            method: method,
            params: requestConfig.params || null,
            headers: requestConfig.headers || null,
            responseType: requestConfig.responseType || 'json',
            data: requestConfig.body || null
        };
        return axiosRequestConfig;
    }
    /**
     * 构造Http响应信息
     */
    static buildHttpResponse(axiosResponse) {
        const httpResponse = {
            body: axiosResponse.data,
            headers: axiosResponse.headers,
            status: axiosResponse.status,
            statusText: axiosResponse.statusText
        };
        return httpResponse;
    }
}

/**
 * HttpClient
 */
class HttpClient {
    /**
     * 构造函数
     */
    constructor() {
        this.axiosInstance = axios.create();
    }
    /**
     * 发送GET请求
     */
    get(url, requestConfig) {
        return this.request('GET', url, requestConfig);
    }
    /**
     * 发送POST请求
     */
    post(url, body, requestConfig) {
        requestConfig = HttpUtil.appendBodyToRequestConfig(body, requestConfig);
        return this.request('POST', url, requestConfig);
    }
    /**
     * 发送PUT请求
     */
    put(url, body, requestConfig) {
        requestConfig = HttpUtil.appendBodyToRequestConfig(body, requestConfig);
        return this.request('PUT', url, requestConfig);
    }
    /**
     * 发送PATCH请求
     */
    patch(url, body, requestConfig) {
        requestConfig = HttpUtil.appendBodyToRequestConfig(body, requestConfig);
        return this.request('PATCH', url, requestConfig);
    }
    /**
     * 发送DELETE请求
     */
    delete(url, requestConfig) {
        return this.request('DELETE', url, requestConfig);
    }
    /**
     * 发送请求
     */
    request(method, url, requestConfig) {
        const request$ = of(true).pipe(switchMap(() => {
            const axiosRequestConfig = HttpUtil.buildAxiosRequestConfig(method, url, requestConfig);
            return from(this.axiosInstance.request(axiosRequestConfig));
        }));
        return request$.pipe(map((axiosResponse) => {
            const httpResponse = HttpUtil.buildHttpResponse(axiosResponse);
            return requestConfig.observe === 'response' ? httpResponse : axiosResponse.data;
        }));
    }
}

const HTTP_PROVIDERS = [
    { provide: HttpClient, useClass: HttpClient, deps: [] }
];

/**
 * 变更记录
 */
class Modification {
    /**
     * 构造函数
     * @param value 新值
     * @param modifyType 变更类型
     * @param path 变更路径
     * @param preValue 旧值
     */
    constructor(value, modifyType, path, preValue, position) {
        this.type = modifyType;
        this.value = value;
        this.preValue = preValue;
        this.path = path;
        this.position = position;
    }
}
/**
 * 变更类型
 */
var ModifyType;
(function (ModifyType) {
    /**
     * 添加
     */
    ModifyType["Add"] = "ADD";
    /**
     * 添加数据
     */
    ModifyType["AddData"] = "AddData";
    /**
     * 克隆数据
     */
    ModifyType["Clone"] = "CLONE";
    /**
     * 删除
     */
    ModifyType["Remove"] = "REMOVE";
    ModifyType["RemoveData"] = "RemoveData";
    /**
     * 修改
     */
    ModifyType["ValueChange"] = "VALUE_CHANGE";
    /**
     * 加载
     */
    ModifyType["Load"] = "LOAD";
    /**
     * 未改变
     */
    ModifyType["UnChanged"] = "UNCHANGED";
    /**
     * 分页信息变更
     */
    ModifyType["PaginationInfoChange"] = "PAGINATION_INFO_CHANGE";
    /**
     * 插入
     */
    ModifyType["Insert"] = "Insert";
    /**
     * 更新实体
     */
    ModifyType["Update"] = "UPDATE";
})(ModifyType || (ModifyType = {}));

/*
 * @Author: Lucus, Witt
 * @Date: 2018-10-30 15:53:59
 * @Last Modified by: Witt
 * @Last Modified time: 2018-11-08 17:25:08
 */
function isEqual(value, other) {
    return JSON.stringify(value) === JSON.stringify(other);
}
/**
 * 实体数据变更集
 */
class ChangeSet {
    constructor() {
        /**
         * 变更集合
         */
        this.modifications = [];
    }
    /**
     *  获取所有的变更记录
     */
    get changes() {
        return this.modifications;
    }
    /**
     * 将变更集添加到集合中
     * ### 使用示例
     * ```
     * const changeSet = new ChangeSet();
     * const modify = new Modification('newValue', ModifyType.ValueChange, [1, 'title'], 'oldValue');
     * changeSet.append(modify)
     * ```
     * @param changeItem 变更数据
     */
    append(modification) {
        switch (modification.type) {
            case ModifyType.ValueChange:
                this.appendValueChangeModification(modification);
                break;
            case ModifyType.Add:
            case ModifyType.Insert:
            case ModifyType.Clone:
                this.appendAddModification(modification);
                break;
            case ModifyType.Remove:
                this.appendRemoveModification(modification);
                break;
            case ModifyType.Load:
                break;
            default:
                throw new Error('不支持此类型的变更');
        }
    }
    /**
     * 添加值变化变更
     */
    appendValueChangeModification(modification) {
        const value = modification.value;
        const existedModification = this.findModifyItemsPath(modification.path);
        if (existedModification) {
            // 如果存在相同路径的ValueChange类型的变更集，则更新值；
            existedModification.value = value;
        }
        else {
            const existedAddModification = this.findNewAddItemsPath(modification.path);
            if (existedAddModification) {
                // @todo：
                // 1、此处逻辑有问题，value是个字符串，不能直接assign；
                // 2、之所以没有出现问题，是因为都是服务器端新增，新增后，客户端清空了所有变更。
                // 如果存在涵盖该ValueChange变更的Add变更，则更新Add变更对应的数据；
                existedAddModification.value = Object.assign({}, existedAddModification.value, value);
            }
            else {
                // 其他情况，新增一条ValueChange变更。
                this.modifications.push(modification);
            }
        }
    }
    /**
     * 添加新增变更
     */
    appendAddModification(modification) {
        const value = modification.value;
        const existedModification = this.findNewAddItemsPath(modification.path);
        if (existedModification) {
            // 1、如果已经存在相同路径的Add变更，则合并Value。
            existedModification.value = existedModification.value.concat(value);
        }
        else {
            // 2、如果没有，则新增一条Add变更。
            this.modifications.push(modification);
        }
    }
    /**
     * 添加删除变更
     */
    appendRemoveModification(modification) {
        const path = modification.path;
        const primaryKey = Object.keys(modification.value)[0];
        const primaryKeyValue = modification.value[primaryKey];
        // 1、存在相同path的新增变更，移除新增变更，不需要添加删除变更；
        // @todo：待重构（1、只考虑了主从情况，2、临时用多重循环实现）
        this.modifications.forEach((addModification) => {
            // 只处理新增变更
            if (addModification.type !== ModifyType.Add && addModification.type !== ModifyType.Insert && addModification.type !== ModifyType.Clone) {
                return;
            }
            // @todo 只考虑主从结构，再深的层次暂不考虑
            if (isEqual(addModification.path, path) === false) {
                return;
            }
            // 遍历新增新增变更的value（value是个数组），移除相匹配的新增删除
            addModification.value = addModification.value.filter((addDataItem) => {
                return addDataItem[primaryKey] !== primaryKeyValue;
            });
        });
        // 2、移除对应的修改变更
        const fullRemovePath = path.concat(`${primaryKey}:${primaryKeyValue}`);
        this.modifications = this.modifications.filter((valueModification) => {
            if (valueModification.type !== ModifyType.ValueChange) {
                return true;
            }
            const valueChangePath = Array.from(valueModification.path);
            valueChangePath.pop();
            // 路径相同进行移除
            const isToRemove = isEqual(valueChangePath, fullRemovePath);
            return !isToRemove;
        });
        // 先删除下级删除变更，再插入
        // 主要针对从从表删除之后，又删除子表时，根实体上还存在从从表删除变更的场景
        this.removeDescendantRemoveModifications(modification);
        this.modifications.push(modification);
    }
    /**
     * 清空变更集合
     */
    clear() {
        this.modifications = [];
    }
    /**
     * 根据path获取Add类型的变更记录
     * @param path 变更路径
     */
    findNewAddItemsPath(path) {
        return this.modifications.find((value, index) => {
            return isEqual(path, value.path) && (value.type === ModifyType.Add || value.type === ModifyType.Insert || value.type === ModifyType.Clone);
        });
    }
    /**
     * 根据path获取ValueChange类型的变更记录
     * @param path 变更路径
     */
    findModifyItemsPath(path) {
        return this.modifications.find((value, index) => {
            return isEqual(path, value.path) && value.type === ModifyType.ValueChange;
        });
    }
    /**
     * 删除后代（包括自己）所有的删除变更
     * @todo：临时做一个最小化修改
     */
    removeDescendantRemoveModifications(parentRemoveModification) {
        const parentPathWithId = this.createRemovePathWithId(parentRemoveModification);
        // 删除后代修改变更
        this.modifications = this.modifications.filter((modification) => {
            if (modification.type !== ModifyType.Remove) {
                return true;
            }
            const descendantPathWithId = this.createRemovePathWithId(modification);
            const isDescendant = this.isDescendantPath(parentPathWithId, descendantPathWithId);
            return !isDescendant;
        });
    }
    /**
     * 获取删除路径的完整格式
     * @summary
     * 1、目前删除变更的路径标记到父集合；
     * 2、为了方便比较，将被删除的数据id加入到路径中
     */
    createRemovePathWithId(modification) {
        const path = modification.path;
        const primaryKey = Object.keys(modification.value)[0];
        const primaryKeyValue = modification.value[primaryKey];
        const pathWithId = path.concat([`${primaryKey}:${primaryKeyValue}`]);
        return pathWithId;
    }
    /**
     * 判断是否是后代节点路径
     * @param parentPath 父节点路径
     * @param descendantPath 后代节点
     */
    isDescendantPath(parentPath, descendantPath) {
        if (parentPath.length > descendantPath.length) {
            return false;
        }
        let isDescendantPath = true;
        parentPath.forEach((parentPathItem, parentPathItemIndex) => {
            if (parentPathItem !== descendantPath[parentPathItemIndex]) {
                isDescendantPath = false;
                return;
            }
        });
        return isDescendantPath;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-27 09:25:38
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-27 09:39:10
 */
/**
 * 路径类型
 */
var DataPathNodeType;
(function (DataPathNodeType) {
    /**
     * 标记该节点是一个实体主键值，用来在列表上定位一个实体
     */
    DataPathNodeType["DataId"] = "DataId";
    /**
     * 标记该节点是一个属性名，用来在对象上定位一个属性
     */
    DataPathNodeType["PropName"] = "PropName";
})(DataPathNodeType || (DataPathNodeType = {}));
/**
 * 路径节点
 */
class DataPathNode {
    /**
     * 构造函数
     */
    constructor(type, data) {
        this.type = type;
        this.value = data;
        this.prev = null;
        this.next = null;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-27 09:26:41
 * @Last Modified by: Witt
 * @Last Modified time: 2019-01-15 22:00:45
 */
/**
 * 变更路径（简单双向列表）
 */
class DataPath {
    /**
     * 构造函数
     */
    constructor() {
        this.head = new DataPathNode(null, null);
        this.length = 0;
    }
    /**
     * 添加一个节点到头部
     */
    unshift(type, data) {
        const newNode = new DataPathNode(type, data);
        newNode.next = this.head.next;
        newNode.prev = this.head;
        this.head.next = newNode;
        if (newNode.next) {
            newNode.next.prev = newNode;
        }
        this.length++;
    }
    /**
     * 在链表最后追加一个节点
     */
    push(type, data) {
        const tailNode = this.getTail();
        const newNode = new DataPathNode(type, data);
        tailNode.next = newNode;
        this.length++;
    }
    /**
     * 获取链表尾部节点
     */
    getTail() {
        let lastNode = this.head;
        while (lastNode.next) {
            lastNode = lastNode.next;
        }
        return lastNode;
    }
    /**
     * 转换为数组格式
     */
    toArray() {
        const pathArray = [];
        let currentNode = this.head.next;
        while (currentNode) {
            pathArray.push(`${currentNode.type}:${currentNode.value}`);
            currentNode = currentNode.next;
        }
        return pathArray;
    }
    /**
     * 转换为字符串格式
     */
    toString() {
        const pathArray = this.toArray();
        const pathString = pathArray.join(', ');
        return `[${pathString}]`;
    }
    /**
     * 拷贝
     */
    clone() {
        const newDataPath = new DataPath();
        let curDataNode = this.head.next;
        while (curDataNode) {
            newDataPath.push(curDataNode.type, curDataNode.value);
            curDataNode = curDataNode.next;
        }
        return newDataPath;
    }
}

/*
 * @Author: Witt
 * @Date: 2019-08-14 14:11:51
 * @Last Modified by: Witt
 * @Last Modified time: 2019-08-14 16:11:51
 */
/**
 * 实体属性分组
 */
var DataPropGroup;
(function (DataPropGroup) {
    /**
     * 简单类型
     */
    DataPropGroup["Primitive"] = "Primitive";
    /**
     * 实体类型
     */
    DataPropGroup["Object"] = "Object";
    /**
     * 动态实体类型
     */
    DataPropGroup["Dynamic"] = "Dynamic";
    /**
     * 列表类型
     */
    DataPropGroup["List"] = "List";
})(DataPropGroup || (DataPropGroup = {}));
/**
 * 实体属性信息
 */
class DataPropInfo {
}

/**
 * 元数据名称
 */
const PRIMITIVE_PROP_META = 'PrimitivePropMeta';
/**
 * 【简单属性装饰器工厂】的工厂
 */
function makePrimitivePropMetaDecorator(options) {
    let metadata = {
        primary: false,
        foreign: false
    };
    if (options) {
        const paramType = typeof options;
        switch (paramType) {
            case 'boolean':
                metadata.primary = Boolean(options);
                break;
            case 'string':
                metadata.dataField = String(options);
                break;
            case 'object':
                metadata = Object.assign(metadata, options);
                break;
        }
    }
    return metadata;
}
/**
 * 简单属性装饰器工厂
 */
const PrimitivePropMeta = makePropDecorator(PRIMITIVE_PROP_META, makePrimitivePropMetaDecorator);

class StringUtil {
    /**
       * 字符串格式化
       */
    static format(value, options) {
        const { maxLenght, prefix = '', suffix = '', ellipsis = '...' } = options;
        if (!maxLenght)
            return value;
        if (!value)
            return value;
        if (maxLenght && value.length > maxLenght) {
            value = value.slice(0, maxLenght);
            return prefix + value + suffix + ellipsis;
        }
        return prefix + value + suffix;
    }
    static filterSearchValue(value, options) {
        if (value == undefined || value == null || value == '') {
            return value;
        }
        value = value.trim();
        if (options == undefined || options == null || options == '') {
            value = value.replace(/[<>&"]/g, function (c) { return { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' }[c]; });
            return value;
        }
        if (options && options.text == "") {
            value = value.replace(/[<>&"]/g, function (c) { return { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' }[c]; });
            return "<p>" + value + "</p>";
        }
        if (typeof options === 'string') {
            const re = new RegExp(`${options}`, 'g');
            let newStr = value.replace(re, `##s1p1##${options}##s2p2##`);
            newStr = newStr.replace(/[<>&"]/g, function (c) { return { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' }[c]; });
            newStr = newStr.replace(/##s1p1##/g, '<span style="color:red">');
            newStr = newStr.replace(/##s2p2##/g, "</span>");
            return `<p>${newStr}</p>`;
        }
        if (typeof options === 'object') {
            const { text, style } = options;
            const re = new RegExp(`${text}`, 'g');
            let newStr = value.replace(re, "##s1p1##" + style + "##s2p2##" + text + "##s3p3##");
            newStr = newStr.replace(/[<>&"]/g, function (c) { return { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' }[c]; });
            newStr = newStr.replace(/##s1p1##/g, "<span style=\"");
            newStr = newStr.replace(/##s2p2##/g, "\">");
            newStr = newStr.replace(/##s3p3##/g, "</span>");
            return `<p>${newStr}</p>`;
        }
    }
}

class NumberUtil {
    /**
       * 数字格式化
       * {
       *   precision: 2,
       *   decimal: true,
       *   thousand: ','
       *   prefix: '',
       *   suffix: ''
       * }
       */
    static format(value, options) {
        // 参数处理
        let decimals = (options.precision || options.precision === 0) ? options.precision : 2;
        let decimalPoint = options.decimal || '.';
        let thousandsSep = options.thousand || '';
        let prefix = options.prefix || '';
        let suffix = options.suffix || '';
        let prefixType = options.prefixType;
        if (prefixType == "dynamic" && options.prefix) {
            // 表示前缀为一个函数  那么执行函数定义
            let prefixFunc = new Function("return " + options.prefix);
            prefix = prefixFunc()(options.sourceData);
        }
        value = (value + '').replace(/[^0-9+-Ee.]/g, '');
        let s;
        // 处理精度
        let toFixedFix = function (n, prec) {
            var k = Math.pow(10, prec);
            return '' + parseFloat(Math.round(parseFloat((n * k).toFixed(prec * 2))).toFixed(prec * 2)) / k;
        };
        s = ((decimals || decimals === 0) ? toFixedFix(value, decimals) : '' + Math.round(value)).split('.');
        // 处理千分位
        if (thousandsSep) {
            let pattern = /(-?\d+)(\d{3})/;
            while (pattern.test(s[0])) {
                s[0] = s[0].replace(pattern, "$1" + thousandsSep + "$2");
            }
            if ((s[1] || '').length < decimals) {
                s[1] = s[1] || '';
                s[1] += new Array(decimals - s[1].length + 1).join('0');
            }
        }
        let formatedValue = s.join(decimalPoint);
        formatedValue = `${prefix}${formatedValue}${suffix}`;
        return formatedValue;
    }
}

/**
 * 布尔工具类
 */
class BoolUtil {
    /**
     * 布尔值格式化
    */
    static format(value, options) {
        if (value === true) {
            return '是';
        }
        else {
            return '否';
        }
    }
}

class EnumUtil {
    /**
     * 枚举格式化
     * {
     *  enumData: [
     *    {value: 'value1', name: 'name1'},
     *    {value: 'value2', name: 'name2'}
     *  ]
     * }
     */
    static format(value, options) {
        const separator = options.separator;
        const enumOptions = options.enumData;
        let valueArry = [];
        if (value && separator) {
            valueArry = value.split(separator);
        }
        if (valueArry.length > 1) {
            const nameArry = valueArry.map(item => {
                const targetEnumOption = enumOptions.find((enumOption) => {
                    return enumOption.value === item;
                });
                if (!targetEnumOption) {
                    console.error(`找不到${item}对应的枚举选项`);
                    return item;
                }
                return targetEnumOption.name;
            });
            return nameArry.join(separator);
        }
        const targetEnumOption = enumOptions.find((enumOption) => {
            return enumOption.value === value;
        });
        if (!targetEnumOption) {
            console.error(`找不到${value}对应的枚举选项`);
            return value;
        }
        return targetEnumOption.name;
    }
}

dayjs.locale('zh-cn');
/**
 * 日期处理类
 */
class DateUtil {
    /**
     * 将日期（或日期字符串）转换为完整的的ISO格式的字符串
     */
    static formatISO(dateOrDateString) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const dateObj = this.parse(dateOrDateString);
        return format(dateObj, this.defaultISOFormat);
    }
    /**
     * 将日期（或日期字符串）转换为指定格式的字符串
     * @param dateOrDateString 日期对象或符合ISO8601规范的日期字符串
     * @param dateFormat 日期格式字符串
     */
    static format(dateOrDateString, dateFormat) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const dateObj = this.parse(dateOrDateString);
        dateFormat = dateFormat ? dateFormat : this.defaultDisplayFormat;
        return format(dateObj, dateFormat);
    }
    static dateShow(dateOrDateString, type) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        if (!type || "" === type) {
            return;
        }
        return this[type] && this[type](dateOrDateString);
    }
    static dateOperation(dateOrDateString, options) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const { type = "", option } = options;
        if (!type || "" === type) {
            return;
        }
        if ('isSame' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['granularity']);
        }
        if ('isBefore' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['granularity']);
        }
        if ('isAfter' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['granularity']);
        }
        if ('isBetween' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['targetDate2'], options['granularity'], options['contains']);
        }
        if (!option) {
            return this[type] && this[type](dateOrDateString);
        }
        return this[type] && this[type](dateOrDateString, option);
    }
    static relativeTime(dateOrDateString, option) {
        dayjs.extend(relativeTime);
        const dateObj = dayjs(dateOrDateString);
        if (!option) {
            return dayjs(dateObj).fromNow();
        }
        return dayjs(dateObj).fromNow(option);
    }
    static isToday(dateOrDateString) {
        const todayDate = new Date();
        const dateObj = dayjs(dateOrDateString);
        return this.isSame(dateObj, todayDate, 'date');
    }
    static calendar(dateOrDateString, option) {
        const dateObj = dayjs(dateOrDateString);
        dayjs.extend(Calendar);
        if (option) {
            return dayjs().calendar(dateObj, Object.assign({}, option));
        }
        return dayjs().calendar(dateObj, {
            sameDay: '[今天] HH:mm',
            nextDay: '[明天] HH:mm',
            lastDay: '[昨天] HH:mm',
            sameElse: 'YYYY-MM-DD'
        });
    }
    /**
     * 创建日期
     * @param dateOrDateString 日期对象或符合ISO8601规范的日期字符串
     */
    static parse(dateOrDateString) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return null;
        }
        if (this.isDate(dateOrDateString) === true) {
            return dateOrDateString;
        }
        return parseISO(dateOrDateString);
    }
    /**
     * 是否是日期对象
     */
    static isDate(date) {
        return isDate(date);
    }
    /**
     * 是否是空日期或者空日期字符串
     * @param dateOrDateString 日期或日期字符串
     */
    static isEmptyDateOrDateString(dateOrDateString) {
        if (this.isDate(dateOrDateString) === true) {
            return this.isEmptyDate(dateOrDateString);
        }
        return this.isEmptyDateString(dateOrDateString);
    }
    /**
     * 是否为空日期字符串
     * @param date 日期对象
     */
    static isEmptyDate(date) {
        if (!date) {
            return true;
        }
        return false;
    }
    /**
     * 是否是空日期字符串
     * @param dateString 日期字符串
     */
    static isEmptyDateString(dateString) {
        if (!dateString || dateString.startsWith('0001-01-01') === true) {
            return true;
        }
        return false;
    }
    /**
     * 两个日期是否相等
     * @param dateOrDateString1 日期对象或字符串
     * @param dateOrDateString1 日期对象或字符串
     * @return 相等返回true，否则返回false
     */
    static isEqual(dateOrDateString1, dateOrDateString2) {
        const dateObj1 = this.parse(dateOrDateString1);
        const dateObj2 = this.parse(dateOrDateString2);
        if (dateObj1 === dateObj2) {
            return true;
        }
        return isEqual$1(dateObj1, dateObj2);
    }
    /**
     * 两个日期是否相等
     * @param dateOrDateString1 日期对象或字符串
     * @param dateOrDateString1 日期对象或字符串
     * @return 返回-1、0、1
     */
    static compare(dateOrDateString1, dateOrDateString2) {
        const dateObj1 = this.parse(dateOrDateString1);
        const dateObj2 = this.parse(dateOrDateString2);
        if (this.isEqual(dateObj1, dateObj2) === true) {
            return 0;
        }
        // 处理解析后为null的场景，null比所有有效日期小
        if (!dateObj1 && this.isDate(dateObj2) === true) {
            return -1;
        }
        if (!dateObj2 && this.isDate(dateObj1) === true) {
            return 1;
        }
        return compareAsc(dateObj1, dateObj2);
    }
    /**
     *
     * @param currentDate 当前日期
     * @param targetDate 目标日期
     * @param type 比较类型 date	D	天00:00 day	d	星期00:00 month	M	月第一天00:00 year	y	1月1日00点 week	w	周第一天00:00hour	h	00:00:00minute	m	00:00second	s	00millisecond	ms	0
     * @returns
     */
    static isSame(currentDate, targetDate, type) {
        if (type) {
            return dayjs(currentDate).isSame(dayjs(targetDate), type);
        }
        return dayjs(currentDate).isSame(dayjs(targetDate));
    }
    /**
     *
     * @param currentDate 当前日期
     * @param targetDate 目标日期
     * @returns boolean
     */
    static isBefore(currentDate, targetDate, type) {
        if (type) {
            return dayjs(currentDate).isBefore(dayjs(targetDate), type);
        }
        return dayjs(currentDate).isBefore(dayjs(targetDate));
    }
    /**
   *
   * @param currentDate 当前日期
   * @param targetDate 目标日期
   * @returns boolean
   */
    static isAfter(currentDate, targetDate, type) {
        if (type) {
            return dayjs(currentDate).isAfter(dayjs(targetDate), type);
        }
        return dayjs(currentDate).isAfter(dayjs(targetDate));
    }
    /**
     *
     * @param currentDate
     * @param targetDate1
     * @param targetDate2
     * @returns
     */
    static isBetween(currentDate, targetDate1, targetDate2, type, contains) {
        dayjs.extend(IsBetween);
        if (type) {
            return dayjs(currentDate).isBetween(dayjs(targetDate1), dayjs(targetDate2), type, contains);
        }
        return dayjs(currentDate).isBetween(dayjs(targetDate1), dayjs(targetDate2), null, contains);
    }
}
/**
 * 空日期字符串（N版）
 * @todo：兼容服务器端，不应该在devkit体现这种兼容，待移除
 */
// static emptyDateTimeString = '0001-01-01T00:00:00';
DateUtil.emptyDateTimeString = null;
/**
 * 默认空日期字符串（ISO标准格式）
 */
// static emptyISODateTimeString = '0001-01-01T00:00:00+00:00';
DateUtil.emptyISODateTimeString = null;
/**
 * 默认日期听格式
 */
DateUtil.defaultISOFormat = `yyyy-MM-dd'T'HH:mm:ssxxx`;
DateUtil.defaultDisplayFormat = 'yyyy-MM-dd HH:mm:ss';
DateUtil.defaultDateFormat = 'yyyy-MM-dd';
DateUtil.defaultTimeFormat = 'HH:mm:ss';

class ArrayUtil {
    /**
     * 从数组中删除一项
     */
    static remove(arr, itemToRemove) {
        const indexToRemove = arr.findIndex((item) => {
            return item === itemToRemove;
        });
        this.removeByIndex(arr, indexToRemove);
    }
    /**
     * 从数组中删除indexToRemove对应的项
     * @param index
     */
    static removeByIndex(arr, indexToRemove) {
        if (!arr || arr[indexToRemove] !== undefined) {
        }
        arr.splice(indexToRemove, 1);
    }
}

class ObjectUtil {
    /**
     * 检查是否是简单对象
     */
    static isPlainObject(value) {
        if (!(typeof value === 'object' && value !== null) || Object.prototype.toString.call({}) !== '[object Object]') {
            return false;
        }
        if (Object.getPrototypeOf(value) === null) {
            return true;
        }
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
}

/**
 * 数据路径处理
 */
class BindingPathConverter {
    /**
     * (BindingPathString | BindingPathArray) => BindingPathArray
     * @param bindingPath BindingPath的字符串或者数组格式
     * @return BindingPath数组
     */
    static toBindingPathArray(bindingPath) {
        let bindingPathArray;
        if (typeof bindingPath === 'string') {
            bindingPathArray = bindingPath.split('/').filter((part) => {
                return part !== '';
            });
            return bindingPathArray;
        }
        else {
            bindingPathArray = bindingPath.concat([]);
        }
        return bindingPathArray;
    }
    /**
     * BindingPathArray => BindingPathString
     */
    static toBindingPathString(bindingPathArray) {
        return '/' + bindingPathArray.join('/');
    }
}

/**
 * BindingPath比较器
 */
class BindingPathComparer {
    /**
     * 是否相等
     */
    static isEqual(srcPath, dstPath) {
        const srcPathArray = BindingPathConverter.toBindingPathArray(srcPath);
        const dstPathArray = BindingPathConverter.toBindingPathArray(dstPath);
        const isEqual = srcPathArray.every((srcPathItem, srcPathIndex) => {
            return srcPathItem === dstPathArray[srcPathIndex];
        });
        return isEqual;
    }
    /**
     * 是否是父路径
     */
    static isParent(childPath, parentPath) {
        const childPathArray = BindingPathConverter.toBindingPathArray(childPath);
        const parentPathArray = BindingPathConverter.toBindingPathArray(parentPath);
        // 长度差1个
        if (childPathArray.length !== parentPathArray.length + 1) {
            return;
        }
        return this.isAncestor(childPath, parentPath);
    }
    /**
     * 是否是祖先路径
     */
    static isAncestor(descendantPath, ancestorPath) {
        const descendantPathArray = BindingPathConverter.toBindingPathArray(descendantPath);
        const ancestorPathArray = BindingPathConverter.toBindingPathArray(ancestorPath);
        if (descendantPath.length <= ancestorPathArray.length) {
            return false;
        }
        const isAncestor = ancestorPathArray.every((ancestorPathItem, ancestorPathIndex) => {
            return ancestorPathItem === descendantPathArray[ancestorPathIndex];
        });
        return isAncestor;
    }
}

/**
 * BindingPath遍历器
 */
class BindingPathTraverser {
    /**
     * 获取叶子节点的Path
     */
    static getLeafPathString(bindingPath) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPath);
        return bindingPathArray.pop();
    }
    /**
     * 获取父路径
     */
    static getParentPathString(bindingPath) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPath);
        bindingPathArray.pop();
        return '/' + bindingPathArray.join('/');
    }
}

/**
 * 变更相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 绑定数据变更类型
 */
var ChangeType;
(function (ChangeType) {
    ChangeType["Load"] = "Load";
    ChangeType["Append"] = "Append";
    ChangeType["Remove"] = "Remove";
    ChangeType["Swap"] = "Swap";
    ChangeType["SelectionChanged"] = "SelectionChanged";
    ChangeType["ValueChanged"] = "ValueChanged";
    ChangeType["UpdateErrors"] = "UpdateErrors";
    ChangeType["GlobalSelectionChanged"] = "GlobalSelectionChanged";
    /**
     * 分页信息变化
     */
    ChangeType["PaginationInfoChange"] = "PaginationInfoChange";
})(ChangeType || (ChangeType = {}));
/**
 * 视图变更类型
 */
var ViewChangeType;
(function (ViewChangeType) {
    ViewChangeType[ViewChangeType["ValueChanged"] = 0] = "ValueChanged";
})(ViewChangeType || (ViewChangeType = {}));

/**
 * 绑定属性相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 属性类型
 */
var BindingPropertyType;
(function (BindingPropertyType) {
    /**
     * 简单类型
     */
    BindingPropertyType["Plain"] = "Plain";
    /**
     * 对象类型
     */
    BindingPropertyType["Object"] = "Object";
    /**
     * 列表类型
     */
    BindingPropertyType["List"] = "List";
    /**
     * 动态类型
     */
    BindingPropertyType["Dynamic"] = "Dynamic";
})(BindingPropertyType || (BindingPropertyType = {}));

/**
 * 属性工具类
 */
class PropertyUtil {
    /**
     * 获取实体上的属性集合，并将他们转换成BindingProperty集合
     * @param  entityType 实体类型
     * @returns 绑定属性集合
     */
    static getProperties(entityType) {
        const properties = [];
        // Plain
        const ngFieldProperties = FieldMetadataUtil.getNgFields(entityType);
        Object.keys(ngFieldProperties).forEach((propertyName) => {
            const ngFieldProperty = ngFieldProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Plain,
                isPrimaryKey: ngFieldProperty.primary,
                isForeignKey: ngFieldProperty.foreign,
                enableMultiLangInput: ngFieldProperty.enableMultiLangInput
            });
        });
        // Object
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propertyName) => {
            const ngObjectProperty = ngObjectProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Object,
                entityType: ngObjectProperty.type
            });
        });
        // List
        const ngListProperties = FieldMetadataUtil.getNgList(entityType);
        Object.keys(ngListProperties).forEach((propertyName) => {
            const ngListProperty = ngListProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.List,
                entityType: ngListProperty.type
            });
        });
        // Dynamics
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propertyName) => {
            const ngDynamicProperty = ngDynamicProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Dynamic,
                entityType: ngDynamicProperty.type
            });
        });
        return properties;
    }
    static getDynamicProperties(dynamicData) {
        const properties = [];
        Object.keys(dynamicData).forEach((propertyName) => {
            if (dynamicData.hasOwnProperty(propertyName)) {
                if (dynamicData[propertyName] instanceof Object) {
                    properties.push({
                        name: propertyName,
                        type: BindingPropertyType.Dynamic,
                        entityType: null
                    });
                }
                else {
                    properties.push({
                        name: propertyName,
                        type: BindingPropertyType.Plain,
                        isPrimaryKey: false,
                        isForeignKey: false
                    });
                }
            }
        });
        return properties;
    }
    /**
     * 根据属性名获取属性
     */
    static getPropertyByName(properties, propertyName) {
        const targetProperty = properties.find((property) => {
            return property.name === propertyName;
        });
        return targetProperty;
    }
    /**
     * 获取实体主键名
     * @param properties 属性集合
     * @returns 主键名
     */
    static getPrimaryKey(properties) {
        // 实体必须有主键，如果没有主键在构造实体的时候就已经报错，这里不需要再进行检查
        const primaryProperty = properties.find((property) => {
            return property.isPrimaryKey === true;
        });
        return primaryProperty ? primaryProperty.name : '';
    }
}

/**
 * BindingObject相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingObject是Entity在绑定层的一个影射，它将Entity内的数据转换为不可变对象，并用于界面绑定。
 */
class BindingObject {
    /**
     * 构造函数
     * @param properties 属性集合
     */
    constructor(properties) {
        /**
         * 标识是否提交过
         */
        this.isShowValidationMsg = false;
        /**
         * 以{ [propertyName]: FormControl }的形式存放每条数据的control
         */
        this.controlMap = {};
        this.properties = properties;
        this.primaryKey = PropertyUtil.getPrimaryKey(properties);
        this.innerValues = new Map();
        this.changes = new Subject();
        this.viewChanges = new Subject();
    }
    /**
     * 主键值
     */
    get primaryKeyValue() {
        return this.primaryKey ? this.getValue(this.primaryKey) : '';
    }
    /**
     * 设置是否提交过
     */
    setShowValidationMsg(flag) {
        this.isShowValidationMsg = flag;
    }
    /**
     * 根据属性名获取属性值
     * @param   propertyName 属性名
     * @returns 属性值
     */
    getValue(propertyName) {
        return this.innerValues.get(propertyName);
    }
    /**
     * 设置属性值
     * @param propertyName        属性名
     * @param propertyValue       属性值
     * @param emitEventToView     是否通知View层去更新界面，默认为false
     * @param emitEventToEntity   是否通知Entity层去更新值，默认为false
     * @param errors              错误消息
     * @param invokeOnValueChange 值变化事件执行句柄
     */
    setValue(propertyName, propertyValue, emitEventToView = false, emitEventToEntity = false, errors, invokeOnValueChange) {
        const oldPropertyValue = this.getValue(propertyName);
        // 由于特定原因（@邵珠强），无法屏蔽oldPropertyValue === propertyValue
        if (oldPropertyValue === propertyValue) {
            return;
        }
        if (!invokeOnValueChange || oldPropertyValue === propertyValue) {
            // 设定缺省
            invokeOnValueChange = function (preValue, value, entityChanged) {
                return of(true);
            };
        }
        if (emitEventToEntity === true) {
            // BUG 322301，删除@2019.08.10; 如果无对应实体，则中止值传递; 这种情况发生在带从表的单据新增，从表响应Load变化的情况；
            // if(!this.innerValues.has(propertyName)) {
            //   return;
            // }
            // 执行实体值变化前事件
            invokeOnValueChange(oldPropertyValue, propertyValue, false).subscribe((result) => {
                if (result) {
                    // 如果成功，执行变化，并通知实体变化
                    this.innerValues = this.innerValues.set(propertyName, propertyValue);
                    const viewChange = {
                        type: ViewChangeType.ValueChanged,
                        path: [propertyName],
                        value: propertyValue,
                        errors: errors
                    };
                    this.viewChanges.next(viewChange);
                    // 如果需要通知视图，通知视图相应修改
                    if (emitEventToView === true) {
                        this.changes.next({
                            type: ChangeType.ValueChanged,
                            path: [propertyName],
                            value: propertyValue,
                            id: this.primaryKeyValue,
                            errors: errors
                        });
                    }
                    // 执行实体值变化后事件
                    invokeOnValueChange(oldPropertyValue, propertyValue, true).subscribe();
                }
                else {
                    // 如果失败，不再通知实体变化
                    // 并执行界面回滚操作
                    this.changes.next({
                        type: ChangeType.ValueChanged,
                        path: [propertyName],
                        value: oldPropertyValue,
                        id: this.primaryKeyValue,
                        errors: errors
                    });
                }
            });
        }
        else {
            // `emitEventToEntity === false`, 则认定实体值已经发生变化，通知视图变化，并触发实体值变化后事件
            this.innerValues = this.innerValues.set(propertyName, propertyValue);
            if (emitEventToView === true) {
                this.changes.next({
                    type: ChangeType.ValueChanged,
                    path: [propertyName],
                    value: propertyValue,
                    id: this.primaryKeyValue,
                    errors: errors
                });
            }
            // 执行实体值变化后事件
            invokeOnValueChange(oldPropertyValue, propertyValue, true).subscribe();
        }
    }
    /**
     * 将BindingObject实例转换成JSON对象
     */
    toJSON(options) {
        const langCode = window.localStorage.getItem('languageCode') || 'zh-CHS';
        const result = {};
        this.properties.forEach((property) => {
            const propName = property.name;
            if (property.type === BindingPropertyType.List) {
                const list = this[propName];
                result[propName] = list.toJSON(options);
            }
            else if (property.type === BindingPropertyType.Object) {
                const object = this[propName];
                result[propName] = object.toJSON(options);
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                const object = this[propName];
                result[propName] = object.toJSON(options);
            }
            else {
                // 1、对于多语录入字段；
                // 2、传入ignoreMultiLangInput标志，则取当前语言的值给控件。
                if (options && options.ignoreMultiLangInput === true && property.enableMultiLangInput === true) {
                    const multiLangValueObj = this.getValue(propName);
                    if (multiLangValueObj) {
                        result[propName] = multiLangValueObj[langCode];
                    }
                    else {
                        result[propName] = multiLangValueObj;
                    }
                }
                else {
                    result[propName] = this.getValue(propName);
                }
            }
        });
        return result;
    }
}

/**
 * 绑定列表工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingList工厂用于创建一个空的BindingList对象，并将当前行的属性影射到BindingList对象上。
 *
 * **示例代码**
 * ```ts
 * const deptProperties: BindingProperty[] = PropertyUtil.getProperties(DeptEntity);
 * const deptList = BindingListFactory.create(deptProperties);
 * ```
 */
class BindingListFactory {
    /**
     * 创建BindingList实例，并扩展其属性
     * @param bindingProperties 绑定属性集合
     */
    static create(bindingProperties) {
        const bindingList = new BindingList(bindingProperties);
        this.extendProperties(bindingList, bindingProperties);
        return bindingList;
    }
    /**
     * 扩展BindingList属性，将当前行上的属性映射到列表上
     * @param bindingList       要扩展的绑定列表
     * @param bindingProperties 绑定属性集合
     */
    static extendProperties(bindingList, bindingProperties) {
        bindingProperties.forEach((bindingProperty) => {
            const propertyName = bindingProperty.name;
            Object.defineProperty(bindingList, propertyName, {
                get: () => {
                    return bindingList.currentItem[propertyName];
                }
            });
        });
    }
}

/**
 * 绑定对象工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingObject工厂用于创建一个空的BindingObject对象，并对其属性进行扩展。
 *
 * **扩展属性处理**
 *
 * 对于要扩展的属性（BindingProperty）有三种处理：
 * - 普通属性：初始化为一个undefined，并包装get、set方法，通过set方法监听变更；
 * - 对象属性：初始化为一个空的BindingObject对象，并监听子对象的变更；
 * - 列表属性：初始化为一个空的BindingList对象，并监听子列表的变更；
 *
 * **示例代码**
 *
 * ```ts
 *  const empProperties = PropertyUtil.getProperties(EmpEntity);
 * const empBindingObject = BindingObjectFactory.create(properties);
 * ```
 */
class BindingObjectFactory {
    /**
     * 创建BindingObject实例
     * @param properties 要扩展的属性集合
     * @returns 带扩展属性的空BindingObject对象
     * @
     */
    static create(properties) {
        const object = new BindingObject(properties);
        this.extendProperties(object, properties);
        return object;
    }
    static createDynamicBindingObject(data) {
        const properties = PropertyUtil.getDynamicProperties(data);
        const object = new BindingObject(properties);
        this.extendProperties(object, properties);
        return object;
    }
    /**
     * 扩展属性绑定对象的属性
     * @param object     要扩展的绑定对象
     * @param properties 绑定属性集合
     */
    static extendProperties(object, properties) {
        // 扩展BindingObject属性
        properties.forEach((property) => {
            if (property.type === BindingPropertyType.List) {
                this.extendListProperty(object, property);
            }
            else if (property.type === BindingPropertyType.Object) {
                this.extendObjectProperty(object, property);
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                this.extendDynamicObjectProperty(object, property);
            }
            else {
                this.extendPlainProperty(object, property);
            }
        });
    }
    /**
     * 扩展列表类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 列表类型的绑定属性集合
     */
    static extendListProperty(object, property) {
        const propertyName = property.name;
        const childListProperties = PropertyUtil.getProperties(property.entityType);
        const childList = BindingListFactory.create(childListProperties);
        // 指定子List的parent、监听子List的changes事件
        childList.parent = object;
        childList.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        // 将子的BindingList实例赋值给当前属性
        Object.defineProperty(object, propertyName, {
            value: childList
        });
    }
    /**
     * 扩展对象类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 对象类型的绑定属性集合
     */
    static extendObjectProperty(object, property) {
        const propertyName = property.name;
        const childObjectProperties = PropertyUtil.getProperties(property.entityType);
        const childObject = this.create(childObjectProperties);
        // 指定子Object的parent、监听子Object的changes事件
        childObject.parent = object;
        childObject.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        Object.defineProperty(object, propertyName, {
            value: childObject
        });
    }
    static extendDynamicObjectProperty(object, property) {
        const propertyName = property.name;
        object[propertyName] = null;
    }
    static attachDynamicObjectProperty(object, propertyName, dynamicObject) {
        dynamicObject.parent = object;
        dynamicObject.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        Object.defineProperty(object, propertyName, {
            value: dynamicObject
        });
    }
    /**
     * 扩展简单类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 简单类型的绑定属性集合
     */
    static extendPlainProperty(object, property) {
        const propertyName = property.name;
        Object.defineProperty(object, propertyName, {
            get: () => {
                return object.getValue(propertyName);
            },
            set: (value) => {
                const oldValue = object.getValue(propertyName);
                if (value === oldValue) {
                    return;
                }
                object.setValue(propertyName, value, true, true);
            }
        });
    }
}

/**
 * 实体操作工具类
 */
class EntityUtil {
    /**
     * 将entity的数据加载到bindingObject中，并保持两者同步。
     * @param entity        实体对象
     * @param bindingObject 绑定对象
     */
    static loadEntity(entity, bindingObject) {
        // 遍历bindingObject的properties进行赋值
        bindingObject.properties.forEach((property) => {
            const propertyName = property.name;
            if (property.type === BindingPropertyType.List) {
                this.loadEntityList(entity[propertyName] || entity[PARENT_CLASS], bindingObject[propertyName]);
            }
            else if (property.type === BindingPropertyType.Object) {
                if (entity && entity[propertyName]) {
                    this.loadEntity(entity[propertyName], bindingObject[propertyName]);
                }
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                if (entity && entity[propertyName]) {
                    const dynamicObject = BindingObjectFactory.createDynamicBindingObject(entity[propertyName].data);
                    BindingObjectFactory.attachDynamicObjectProperty(bindingObject, propertyName, dynamicObject);
                    this.loadEntity(entity[propertyName], bindingObject[propertyName]);
                }
            }
            else {
                bindingObject.setValue(propertyName, entity[propertyName], false, false);
            }
        });
        this.setUpEntityPipeline(entity, bindingObject);
    }
    /**
     * 建立entity和bindingObject之间的关联
     * @param entity        实体对象
     * @param bindingObject 绑定对象
     */
    static setUpEntityPipeline(entity, bindingObject) {
        // 监听entity变更
        entity.onValueChanged.subscribe((modification) => {
            if (modification.type !== ModifyType.ValueChange || modification.path.length === 0) {
                return;
            }
            const propertyName = modification.path[modification.path.length - 1];
            const primaryKeyPath = modification.path[modification.path.length - 2];
            // 验证主键是否匹配
            // 存在主键并且主键不是id时才检查（值对象、关联对象不检查）
            if (bindingObject.primaryKey && bindingObject.primaryKey === 'id') {
                const primaryKey = bindingObject.primaryKey;
                const primaryKeyValue = bindingObject.getValue(primaryKey);
                if (primaryKeyPath !== `${primaryKey}:${primaryKeyValue}`) {
                    return;
                }
            }
            // 值没有发生变化，不再设置
            // TODO: 通过bindingObject修改entity属性值时，entity总会触发一个变更回来，如果不截获这个重复的变更，会导致重复或死循环
            if (bindingObject.getValue(propertyName) === modification.value) {
                return;
            }
            bindingObject.setValue(propertyName, modification.value, true, false, modification.errors);
        });
        // 监听bindingObject变更
        bindingObject.viewChanges.subscribe((viewChange) => {
            const value = viewChange.value;
            const propertyName = viewChange.path[0];
            let pathPrefix = '';
            const pathData = entity.getPaths();
            const paths = pathData.path;
            let id = bindingObject['id'];
            if (pathData.isUdt) {
                // grid中udt没有id，从父级中取出id，以便存放验证信息
                const getParentId = (target) => {
                    let parentId = '';
                    const findId = (item) => {
                        if (item && item && item['id']) {
                            parentId = item['id'];
                            return;
                        }
                        else if (item['parent']) {
                            findId(item['parent']);
                        }
                    };
                    findId(target);
                    return parentId;
                };
                id = getParentId(bindingObject);
                if (pathData.isGrid) {
                    // grid 将从表主字段去除
                    paths.shift();
                }
                if (paths.length) {
                    pathPrefix = paths.join('.') + '.';
                }
            }
            // 不是主键值字段时，要先检查主键是否存在，并且主键是否相等（防止后代变更冒泡上来）
            // 非主键属性变更时，要先检查主键是否匹配（如果主键也修改了，要求先修改主键再修改其他值）
            if (bindingObject.primaryKey) {
                const primaryKey = bindingObject.primaryKey;
                if (propertyName !== primaryKey) {
                    if (!entity[primaryKey] || entity[primaryKey] !== bindingObject[primaryKey]) {
                        return;
                    }
                }
            }
            // 如果BindingObject上的属性值和Entity上对应属性值一样，则不再设置
            if (entity[propertyName] === value) {
                return;
            }
            // 调用表单验证,通过后调用实体验证
            // bingdingObject变化后，先调用实体上的验证，通过后再设置实体的变动
            entity[propertyName] = value;
        });
    }
    /**
     * 将entityList中的Entity对象转换为BindingObject对象，加载到bindingList中，并保持entityList和bindingList同步。
     * @param entityList  实体列表
     * @param bindingList 绑定列表
     */
    static loadEntityList(entityList, bindingList) {
        this.loadEntities(entityList.items, bindingList);
        this.setUpEntityListPipeline(entityList, bindingList);
    }
    /**
     * 建立entityList和bindingList之间的关联
     * @param entityList  实体列表
     * @param bindingList 绑定列表
     */
    static setUpEntityListPipeline(entityList, bindingList) {
        entityList.onListChanged.subscribe((modification) => {
            switch (modification.type) {
                // 添加实体
                case ModifyType.Add:
                case ModifyType.Clone:
                    {
                        const entitiesToAdd = modification.value;
                        if (entitiesToAdd.length === 0) {
                            return;
                        }
                        // 检查父id是否一致，冒泡导致的变更不处理
                        const paths = modification.path;
                        const parentPath = paths[paths.length - 2];
                        const parentId = bindingList.parent.primaryKeyValue;
                        if (parentPath.indexOf(parentId) === -1) {
                            return;
                        }
                        this.appendEntities(modification.value, bindingList, modification.type === ModifyType.Clone);
                    }
                    break;
                case ModifyType.Insert:
                    {
                        // 检查父id是否一致，冒泡导致的变更不处理
                        const paths = modification.path;
                        const parentPath = paths[paths.length - 2];
                        const parentId = bindingList.parent.primaryKeyValue;
                        const position = modification.position;
                        if (parentPath.indexOf(parentId) === -1) {
                            return;
                        }
                        this.insertEntity(modification.value[0], bindingList, position);
                    }
                    break;
                // 删除实体
                case ModifyType.Remove:
                    {
                        // 删除实体（value格式待商榷，目前value的格式为 { primaryKey: primaryValue}）
                        const id = modification.value[bindingList.primaryKey];
                        bindingList.removeByIds([id]);
                        // this.removeEntities(<Entity[]>modification.value, bindingList);
                    }
                    break;
                // 加载实体
                case ModifyType.Load:
                    const entities = modification.value;
                    this.loadEntities(entities, bindingList);
                    break;
                default:
                    break;
            }
        });
    }
    /**
     * 监听repository变化，保持repository和bindingList同步。
     * @param repository  实体仓库
     * @param bindingList 绑定列表
     */
    static loadRepository(repository, bindingList) {
        // 初次加载
        const entities = Array.from(repository.entityCollection.toArray());
        this.loadEntities(entities, bindingList);
        // 监听变化
        repository.entityCollectionChange.subscribe((modification) => {
            switch (modification.type) {
                case ModifyType.Load:
                    this.loadEntities(modification.value, bindingList, modification.entityCreate);
                    break;
                case ModifyType.Add:
                case ModifyType.Clone:
                    this.appendEntities(modification.value, bindingList, modification.type === ModifyType.Clone);
                    break;
                case ModifyType.AddData:
                    this.addData(modification.value, bindingList);
                    break;
                case ModifyType.Insert:
                    this.insertEntity(modification.value, bindingList, modification.position);
                    break;
                case ModifyType.Remove:
                    this.removeEntities(modification.value, bindingList);
                    break;
                case ModifyType.RemoveData:
                    this.removeData(modification.value, bindingList);
                    break;
                case ModifyType.PaginationInfoChange:
                    bindingList.paginationInfo = modification.value;
                    break;
                default:
                    break;
            }
        });
        // 监听BindingList数据变化
        bindingList.changes.subscribe((change) => {
            if (change.type === ChangeType.PaginationInfoChange) {
                const entityCollection = repository.entityCollection;
                // const entityTypeName = entityCollection.entityTypeName;
                // const original = entityCollection.paginationInfo[entityTypeName];
                // const entityPaginationInfo = Object.assign({}, original, change.value);
                entityCollection.paginationInfo = Object.assign({}, entityCollection.paginationInfo, change.value);
            }
        });
    }
    /**
     * 将entities中的Entity对象转换为BindingObject对象，并加载到bindingList中
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static loadEntities(entities, bindingList, entityCreate = false) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.load(bindingObjects, entityCreate);
    }
    /**
     * 将entities中的Entity对象转换为BIndingObject对象，并追加到bindingList中
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static appendEntities(entities, bindingList, isCloned = false) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.append(bindingObjects, isCloned);
    }
    /**
     * 增加实体数据（不切换当前行）
     * @param entities
     * @param bindingList
     */
    static addData(entities, bindingList) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.addData(bindingObjects);
    }
    static insertEntity(entity, bindingList, position) {
        const bindingObject = this.createBindingObject(entity, bindingList);
        bindingList.insert(bindingObject, position);
    }
    /**
     * 从bindingList移除entities对应的BindingObject对象
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static removeEntities(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return;
        }
        // 归集要删除的id数组
        const primaryKey = bindingList.primaryKey;
        const ids = [];
        entities.forEach((entity) => {
            ids.push(entity[primaryKey]);
        });
        bindingList.removeByIds(ids);
    }
    static removeData(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return;
        }
        // 归集要删除的id数组
        const primaryKey = bindingList.primaryKey;
        const ids = [];
        entities.forEach((entity) => {
            ids.push(entity[primaryKey]);
        });
        bindingList.removeDataByIds(ids);
    }
    /**
     * 将entities中的Entity对象转换为BindingObject对象
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static createBindingObjects(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return [];
        }
        const bindingObjects = [];
        entities.forEach((entity) => {
            const bindingObject = BindingObjectFactory.create(bindingList.properties);
            bindingObject['_ENTITY_'] = entity;
            this.loadEntity(entity, bindingObject);
            // // 为bindingObject设置默认值initialData属性
            // if (entity['initialData']) {
            //   bindingObject['initialData'] = entity['initialData'];
            // }
            bindingObjects.push(bindingObject);
        });
        return bindingObjects;
    }
    static createBindingObject(entity, bindingList) {
        const bindingObject = BindingObjectFactory.create(bindingList.properties);
        this.loadEntity(entity, bindingObject);
        return bindingObject;
    }
    static watchReposiroty(repository, bindingData) {
        // reposiroty => bindingData
        repository.entityCollectionChange.subscribe((modification) => {
            switch (modification.type) {
                case ModifyType.PaginationInfoChange:
                    bindingData.pagingInfo = modification.value;
                    break;
                default:
                    break;
            }
        });
    }
    /**
     * 查找属性的类型
     * @param entityType 实体类型
     * @param targetPropName 属性名称
     * @return 属性信息，包含属性类型（NgField、NgObject、NgList）和属性对应的实体类型（当NgField类型时为null）
     */
    static getPropInfo(entityType, targetPropName) {
        let propType;
        let propEntityType;
        // NgField
        const ngFieldProperties = FieldMetadataUtil.getNgFields(entityType);
        Object.keys(ngFieldProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgField';
                propEntityType = null;
            }
        });
        // NgObject
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgObject';
                propEntityType = ngObjectProperties[propName].type;
            }
        });
        // NgList
        const ngListProperties = FieldMetadataUtil.getNgList(entityType);
        Object.keys(ngListProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgList';
                propEntityType = ngListProperties[propName].type;
            }
        });
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgDynamic';
                propEntityType = ngDynamicProperties[propName].type;
            }
        });
        return { propType, propEntityType };
    }
    /**
     * 获取实体的主键名
     * @param entityType 实体类型
     */
    static getPrimaryKey(entityType) {
        const primaryNgFiledProp = FieldMetadataUtil.getPrimaryFieldMetadata(entityType);
        if (primaryNgFiledProp) {
            return primaryNgFiledProp.dataField;
        }
        else {
            return '';
        }
    }
    /**
     * 是否为对象属性
     */
    static isObjectProp(entityType, targetPropName) {
        let isObjectProp = false;
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propName) => {
            if (propName === targetPropName) {
                isObjectProp = true;
            }
        });
        return isObjectProp;
    }
    /**
     * 检查是否是动态列属性
     */
    static isDynamicProp(entityType, targetPropName) {
        let isDynamicProp = false;
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            if (propName === targetPropName) {
                isDynamicProp = true;
            }
        });
        return isDynamicProp;
    }
    /**
     * 为实体增加initialData属性
     * @param entity 实体实例
     * @param initialData 默认值对象
     */
    static appendInitialData(entity, initialData) {
        const data = Object.assign({}, initialData);
        delete data.id;
        delete data.parentID;
        entity['initialData'] = data;
    }
}

// tslint:disable: max-line-length member-ordering
/**
 * BindingData
 */
class BindingData {
    constructor() {
        this.paginationInfo = null;
    }
    /**
     * 绑定该路径
     */
    get bindingPath() {
        if (this.viewModelContext && this.viewModelContext.viewModel.bindingPath) {
            return this.viewModelContext.viewModel.bindingPath;
        }
        return '/';
    }
    set pagingInfo(pagingInfo) {
        this.paginationInfo = pagingInfo;
        this.firePagingChangeEvent();
    }
    get pagingInfo() {
        return this.paginationInfo;
    }
    /**
     * 设置分页信息
     * @param skip 跳过
     * @param take 获取
     * @param bindingPath 路径
     */
    setPagingInfo(skip, take, bindingPath) {
        if (bindingPath.length < 1 || bindingPath === '/') {
            this.paginationInfo = Object.assign(this.paginationInfo, { pageSize: take, pageIndex: skip / take + 1 });
        }
        else {
            let pagingInfo = this.paginationInfo || {};
            const bindingPaths = bindingPath.substr(1).split('/').filter(item => !!item && item.length > 0).map(item => item.substring(0, item.length - 1));
            bindingPaths.forEach(path => {
                if (!pagingInfo.hasOwnProperty(path)) {
                    pagingInfo[path] = {};
                }
                pagingInfo = pagingInfo[path];
            });
            pagingInfo.pageIndex = ((skip / take) || 0) + 1;
            pagingInfo.pageSize = take || 0;
        }
        this.firePagingChangeEvent();
    }
    firePagingChangeEvent() {
        this.list.changes.next({
            type: ChangeType.PaginationInfoChange,
            path: [],
            value: this.paginationInfo
        });
    }
    /**
     * 变更集
     */
    get changes() {
        return this.list.changes;
    }
    /**
     * 设置值变化执行器工厂
     * @param value 值变化执行器工厂
     */
    setValueChangeInvokerFactory(value) {
        this.valueChangeInvokerFactory = value;
    }
    /**
     * 初始化（已废弃）
     */
    init(repository, bindingPath) {
        this.initByRepository(repository, null);
    }
    /**
     * 根据Repository对BindingData进行初始化
     */
    initByRepository(repository, viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.properties = PropertyUtil.getProperties(repository.entityType);
        this.list = BindingListFactory.create(this.properties);
        // 从repository初始化bindingData
        this.pagingInfo = repository.entityCollection.paginationInfo;
        // @todo
        // BindingData不应该知道Repository，加载数据、建立关联关系的过程应该转移到外边
        EntityUtil.loadRepository(repository, this.list);
        this.dataTypeInfo = repository.entityTypeInfo;
        this.extendProperties(this.properties);
    }
    /**
     * 初始化
     */
    initByBindingList(bindingList, viewModelContext, dataTypeInfo) {
        this.list = bindingList;
        this.viewModelContext = viewModelContext;
        this.dataTypeInfo = dataTypeInfo;
        this.extendProperties(this.list.properties);
    }
    /**
     * 获取paths对应的属性值
     * @param  paths 属性路径数组
     * @returns 属性值
     */
    getValue(paths) {
        let target = this.list;
        paths.forEach((path) => {
            if (target) {
                target = target[path];
            }
        });
        return target;
    }
    /**
     * 根据paths设置属性值
     * @param paths 属性路径数组
     * @param value 属性值
     * @param emitEventToView 如果设置为true，则发送事件通知订阅它的组件、指令去更新界面，默认为false。
     * @param emitEventToEntity 如果设置为true，则同步去更新Entity上对应的字段，默认为true。
     */
    setValue(paths, value, emitEventToView = false, emitEventToEntity = true) {
        if (!paths || paths.length === 0) {
            throw Error('路径不能为空');
        }
        const parentPaths = paths.slice(0, paths.length - 1);
        const propName = paths[paths.length - 1];
        let parent = this.getValue(parentPaths);
        if (!parent) {
            throw Error('找不到要设置的对象');
        }
        if (parent instanceof BindingData) {
            parent = parent.list.currentItem;
        }
        else if (parent instanceof BindingList) {
            parent = parent.currentItem;
        }
        if (!!this.valueChangeInvokerFactory) {
            parent.setValue(propName, value, emitEventToView, emitEventToEntity, null, this.valueChangeInvokerFactory(paths));
        }
        else {
            parent.setValue(propName, value, emitEventToView, emitEventToEntity);
        }
    }
    /**
     * 根据paths清空属性值
     */
    clearValue(paths, emitEventToView = false, emitEventToEntity = true) {
        let initValue;
        const propInfo = this.dataTypeInfo.getPropInfoByPath(paths);
        if (propInfo && propInfo.metadataInfo && propInfo.metadataInfo.initValue !== undefined) {
            initValue = propInfo.metadataInfo.initValue;
        }
        else {
            // 原来的帮助映射中，强行纠正了数值的情况，保持一致
            const oldValue = this.getValue(paths);
            if (typeof oldValue === 'number') {
                initValue = 0;
            }
            else {
                initValue = '';
            }
        }
        this.setValue(paths, initValue, emitEventToView, emitEventToEntity);
    }
    /**
     * 获取当前列表
     */
    getList() {
        if (!this.bindingPath || this.bindingPath === '/') {
            return this.list;
        }
        const bindingPath = this.bindingPath.substr(1);
        const bindingPathArray = bindingPath.split('/').filter((part) => {
            return part !== '';
        });
        return this.getValue(bindingPathArray);
    }
    /**
     * 获取当前对象
     */
    getObject() {
        const bindingList = this.getList();
        return bindingList.currentItem;
    }
    /**
     * 绑定路径（仅路径部分，不包括属性）
     * @param bindingPath 绑定路径
     */
    getPath(bindingPath) {
        const bindingPaths = bindingPath.filter(p => p);
        const path = [`${this.list.primaryKey}:${this.list.currentId}`];
        bindingPaths.forEach((item) => {
            path.push(item);
            const list = this[item];
            if (list) {
                path.push(`${list.primaryKey}:${list.currentId}`);
            }
        });
        return path;
    }
    /**
     * 通过绑定路径获取属性初始值
     * @param paths 绑定路径
     */
    getInitValueByPaths(paths) {
        let initValue;
        const propInfo = this.dataTypeInfo && this.dataTypeInfo.getPropInfoByPath(paths) || null;
        if (propInfo && propInfo.metadataInfo && propInfo.metadataInfo.initValue !== undefined) {
            initValue = propInfo.metadataInfo.initValue;
        }
        return initValue;
    }
    /**
     * 扩展BindingData属性，映射BindingData所持有的绑定列表当前行的属性，减少绑定层级。
     * @param properties 关联实体的属性集合
     */
    extendProperties(properties) {
        properties.forEach((property) => {
            const propName = property.name;
            Object.defineProperty(this, propName, {
                get: () => {
                    return this.list.currentItem[propName];
                },
                set: (value) => {
                    this.list.currentItem[propName] = value;
                }
            });
        });
    }
}

/**
 * BindingList是一个BindingObject集合
 */
class BindingList {
    /**
     * 构造函数
     */
    constructor(properties) {
        //#region 分页相关
        /**
         * 分页信息
         */
        this._paginationInfo = null;
        this.properties = properties;
        this.primaryKey = PropertyUtil.getPrimaryKey(properties);
        this.changes = new Subject();
        this.innerList = [];
        this.currentId = null;
    }
    set paginationInfo(sPaginationInfo) {
        this._paginationInfo = sPaginationInfo;
        if (this._paginationInfo === sPaginationInfo) {
            return;
        }
        this.changes.next({
            type: ChangeType.PaginationInfoChange,
            path: [],
            value: this._paginationInfo
        });
    }
    get paginationInfo() {
        return this._paginationInfo;
    }
    /**
     * 获取页码
     */
    get pageIndex() {
        if (!!this.paginationInfo && this.paginationInfo.hasOwnProperty("pageIndex")) {
            return this.paginationInfo.pageIndex;
        }
        return 1;
    }
    /**
     * 获取分页大小
     */
    get pageSize() {
        if (!!this.paginationInfo && this.paginationInfo.hasOwnProperty("pageSize")) {
            return this.paginationInfo.pageSize;
        }
        return 0;
    }
    /**
     * 获取数据总项数
     */
    get total() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.total || this.paginationInfo.totalCount;
        }
        return 0;
    }
    /**
     * 获取跳过的数据条数
     */
    get skip() {
        const pageIndex = this.pageIndex;
        const pageSize = this.pageSize;
        return (pageIndex - 1) * pageSize;
    }
    /**
     * 前台设置分页信息
     * @param skip skip
     * @param take take
     */
    setPaginationInfo(skip, take) {
        this.paginationInfo = Object.assign({}, this.paginationInfo, {
            pageSize: take,
            pageIndex: skip / take + 1
        });
        /*this.changes.next({
          type: ChangeType.PaginationInfoChange,
          path: [],
          value: this.paginationInfo
        });*/
    }
    //#endregion
    /**
     * 当前行对应的绑定对象
     * 如果currentId为null，则创建一个空结构，防止绑定报错；
     */
    get currentItem() {
        const currentItem = this.findById(this.currentId);
        if (!currentItem) {
            if (!this.emptyCurrentItem) {
                this.emptyCurrentItem = BindingObjectFactory.create(this.properties);
            }
            return this.emptyCurrentItem;
        }
        return currentItem;
    }
    /**
     * 绑定对象的数量
     */
    get length() {
        return this.innerList.length;
    }
    /**
     * 添加[Symbol.iterator]，使之能通过for of遍历
     */
    [Symbol.iterator]() {
        const self = this;
        let index = -1;
        const size = this.innerList.length;
        return {
            next: function () {
                index++;
                if (index < size) {
                    return {
                        done: false,
                        value: self.innerList[index]
                    };
                }
                return { done: true, value: undefined };
            }
        };
    }
    /**
     * 批量加载绑定对象，加载之前先清空绑定列表，并重置当前行，加载之后将第一行设置为默认当前行。
     * @param objects 要加载绑定对象数组
     */
    load(objects, entityCreate = false) {
        // 重置列表
        this.innerList = [];
        if (objects.length !== 0) {
            // 加载数据
            objects.forEach((object) => {
                this.add(object);
            });
            // 设置默认当前行
            const currentItem = this.findById(this.currentId);
            if (!currentItem) {
                const firstId = objects[0][this.primaryKey];
                this.setCurrentId(firstId, false, false);
            }
        }
        else {
            this.currentId = null;
        }
        const change = {
            type: ChangeType.Load,
            path: [],
            value: objects
        };
        change.create = entityCreate;
        // 触发事件
        this.changes.next(change);
    }
    /**
     * 批量追加绑定对象，追加之后将最后一个追加的绑定对象设置为当前行。
     * @param objects 要加载绑定对象数组
     */
    append(objects, isCloned = false) {
        if (objects.length === 0) {
            return;
        }
        // 加载BindingObject
        objects.forEach((object) => {
            this.add(object);
        });
        // 当前行为新追加的最后1行
        const lastId = objects[objects.length - 1][this.primaryKey];
        this.setCurrentId(lastId, true, true);
        // 触发事件
        const change = {
            type: ChangeType.Append,
            path: [],
            value: objects
        };
        if (isCloned) {
            change.isCloned = true;
        }
        this.changes.next(change);
    }
    /**
     * 增加数据
     * @param objects 实体
     * @description 增加实体数据，但不切换当前行
     */
    addData(objects) {
        if (objects.length === 0) {
            return;
        }
        // 加载BindingObject
        objects.forEach((object) => {
            this.add(object);
        });
        // 触发事件
        this.changes.next({
            type: ChangeType.Append,
            path: [],
            value: objects
        });
    }
    insert(object, position) {
        // const currentIndex = this.innerList.findIndex((obj: BindingObject) => obj.primaryKeyValue === this.currentId);
        // // 加载BindingObject
        // if (position === 1) {
        //   this.innerList = this.innerList.insert(currentIndex + 1, object);
        // } else if (position === -1) {
        //   this.innerList = this.innerList.insert(currentIndex, object);
        // } else {
        //   this.innerList = this.innerList.push(object);
        // }
        // object.parent = this;
        // // 监听object变更，并继续向上抛，由于list有当前行的概念，不需要在path中追加路径
        // object.changes.subscribe((change: Change) => {
        //   this.changes.next(change);
        // });
        // this.setCurrentId(object.primaryKeyValue, true, true);
        // // 触发事件
        // this.changes.next({
        //   type: ChangeType.Append,
        //   path: [],
        //   value: object
        // });
    }
    /**
     * 添加绑定对象，并建立绑定对象和绑定列表之间的关联。
     * @param object 绑定对象
     */
    add(object) {
        this.innerList.push(object);
        object.parent = this;
        // 监听object变更，并继续向上抛，由于list有当前行的概念，不需要在path中追加路径
        object.changes.subscribe((change) => {
            this.changes.next(change);
        });
    }
    /**
     * 删除主键值数组对应的绑定对象。
     * @param ids 主键值数组
     */
    removeByIds(ids) {
        if (!ids || ids.length === 0) {
            return;
        }
        let nextCurrentId = this.currentId;
        ids.forEach((id) => {
            // 如果当前行被删除，计算下一当前行
            if (id === nextCurrentId) {
                nextCurrentId = this.getCurrentIdBeforeDeleting();
            }
            // 删除对象，找不到时跳过
            const index = this.getIndexById(id);
            if (index === -1) {
                return;
            }
            ArrayUtil.removeByIndex(this.innerList, index);
        });
        // 重新设置当前行
        if (this.innerList.length === 0) {
            this.currentId = null;
        }
        else {
            this.setCurrentId(nextCurrentId, false, false);
        }
        // 出发行删除事件
        this.changes.next({
            type: ChangeType.Remove,
            path: [],
            value: ids
        });
    }
    /**
     * 删除数据（不切换当前行）
     * @param ids ids
     */
    removeDataByIds(ids) {
        // if (!ids || ids.length === 0) {
        //   return;
        // }
        // ids.forEach((id: string) => {
        //   // 删除对象，找不到时跳过
        //   const index = this.getIndexById(id);
        //   if (index === -1) {
        //     return;
        //   }
        //   this.innerList = this.innerList.delete(index);
        // });
        // // 出发行删除事件
        // this.changes.next({
        //   type: ChangeType.Remove,
        //   path: [],
        //   value: ids
        // });
    }
    /**
     * 清空
     */
    clear() {
        this.innerList = [];
        this.currentId = null;
        this.changes.next({
            type: ChangeType.Remove,
            path: [],
            value: []
        });
    }
    /**
     * 如果当前行被删除，删除之前重新计算当前行的位置，并返回下一当前行的主键值。
     * - 如果被删除的行是最后1行，则上移1行；
     * - 其他情况，下移1行。
     */
    getCurrentIdBeforeDeleting() {
        let nextIndex = -1;
        const currentIndex = this.getIndexById(this.currentId);
        if (currentIndex === this.length - 1) {
            nextIndex = currentIndex - 1;
        }
        else {
            nextIndex = currentIndex + 1;
        }
        return this.getIdByIndex(nextIndex);
    }
    /**
     * 根据主键值获取对应绑定对象
     * @param   id 要查找的主键值
     * @returns 找到时返回对应BindingObject， 找不到时返回null
     */
    findById(id) {
        let target;
        target = this.innerList.find((item) => {
            return item.getValue(this.primaryKey) === id;
        });
        return target === undefined ? null : target;
    }
    /**
     * 将主键值为id的绑定对象设置为当前行
     * @param  id        要设置的主键值
     * @param  emitEvent 是否发送当前行变更事件
     */
    setCurrentId(id, emitEvent = true, emitGlobalEvent = true) {
        if (this.currentId === id) {
            return;
        }
        // 不存在时设置为null
        // const currentObj = this.findById(id);
        // if (!currentObj) {
        //   this.currentId = null;
        // } else {
        //   this.currentId = id;
        // }
        // @todo：找不到时按理应该设置为null，目前是直接返回，框架部分功能依赖该特性。
        const currentObj = this.findById(id);
        if (!currentObj) {
            return;
        }
        this.currentId = id;
        // 发出行切换事件
        if (emitEvent === true) {
            this.changes.next({
                type: ChangeType.SelectionChanged,
                path: [],
                value: this.currentItem
            });
        }
        // 是否发送全局的行切换事件
        if (emitGlobalEvent === true) {
            this.changes.next({
                type: ChangeType.GlobalSelectionChanged,
                path: [],
                value: this.currentItem
            });
        }
    }
    /**
     * 根据主键值为id的绑定对象的索引
     * @param id 主键值
     * @returns 找到时返回对应的index，找不到时返回-1
     */
    getIndexById(id) {
        return this.innerList.findIndex((obj) => {
            return obj[this.primaryKey] === id;
        });
    }
    /**
     * 根据索引位置获取对应绑定对象的主键值
     * @reutrn 找到时返回对应主键值，找不到返回null
     */
    getIdByIndex(index) {
        if (index < 0 || index > this.length) {
            return null;
        }
        const obj = this.innerList[index];
        if (!obj) {
            return null;
        }
        return obj[this.primaryKey];
    }
    /**
     * 转换为BindingObject数组
     */
    toArray() {
        return this.innerList.concat([]);
    }
    /**
     * 交互数据位置
     * @param id1 id1
     * @param id2 id2
     */
    swapById(id1, id2) {
        // const item1 = this.innerList.find(element => element.primaryKeyValue === id1);
        // const item2 = this.innerList.find(element => element.primaryKeyValue === id2);
        // this.innerList = this.innerList.map((bindingObject: BindingObject, index: number) => {
        //   if (bindingObject.primaryKeyValue === id1) {
        //     return item2;
        //   } else if (bindingObject.primaryKeyValue === id2) {
        //     return item1;
        //   } else return bindingObject;
        // }).toList();
        // this.changes.next({
        //   type: ChangeType.Swap,
        //   path: []
        // });
    }
    /**
     * 转换为JSON对象
     * @returns 普通对象数组
     */
    toJSON(options) {
        const result = [];
        this.innerList.forEach((obj) => {
            result.push(obj.toJSON(options));
        });
        return result;
    }
    /**
     * 获取分页信息
     * @param path 路径
     * @param defaultValue 默认值
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationInfo;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0).map(item => item.trim());
        let config = this.paginationInfo;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 对bindingList就行排序
     * @param string 排序字段
     * @param directions 排序规则字段
     * @param options 参数
     */
    sortBy(fields, directions, options) {
        if (!fields || fields.length < 1 || !directions || directions.length < 1) {
            throw new Error('sortBy:argument error');
        }
        // 默认升序
        const arrFields = typeof fields === 'string' ? fields.split(',') : fields || [];
        const arrDirections = typeof directions === 'string' ? directions.split(',') : directions || [];
        // 排序字段和排序方式应一致
        if (arrFields.length !== arrDirections.length || arrFields.length < 1) {
            throw new Error('sortBy:fields and directions not match');
        }
        // nage,age,total
        const comparator = (props, orders) => (item1, item2) => {
            for (const prop of props) {
                const order = ['asc'].includes(orders[props.indexOf(prop)]) ? 1 : -1;
                if (item1.getValue(prop) > item2.getValue(prop)) {
                    return order * 1;
                }
                if (item1.getValue(prop) < item2.getValue(prop)) {
                    return order * -1;
                }
            }
            return 0;
        };
        this.innerList = this.innerList.sort(comparator(arrFields, arrDirections));
    }
    getValue(target, propName, isMultiLangProp = false, currentLanguage = 'zh-CHS') {
        if (target instanceof BindingList) {
            target = target.currentItem;
        }
        else if (target instanceof BindingData) {
            target = target.list.currentItem;
        }
        let result = null;
        if (propName.indexOf('.') === -1) {
            result = target[propName];
        }
        else {
            const props = propName.split('.');
            for (const prop of props) {
                target = result = this.getValue(target, prop, isMultiLangProp, currentLanguage);
            }
        }
        if (isMultiLangProp && result && result.hasOwnProperty(currentLanguage)) {
            return result[currentLanguage];
        }
        else {
            return result;
        }
    }
}

class BindingDataFactory {
    /**
     * 根据Repository创建一个BindingData
     */
    static createFromRepository(repository, bindingPath) {
        const bindingData = new BindingData();
        const bindingProperties = PropertyUtil.getProperties(repository.entityType);
        const bindingList = BindingListFactory.create(bindingProperties);
        bindingData.initByBindingList(bindingList, null, repository.entityTypeInfo);
        EntityUtil.loadRepository(repository, bindingList);
        // 从repository初始化bindingData
        bindingData.pagingInfo = repository.entityCollection.paginationInfo;
        return bindingData;
    }
    /**
     * 根据EntityManager创建BindingData，并建立双向关联（请勿使用）
     * @internal
     * @summary
     * 1、该方法暂时仅供内部单元测试使用；
     * 2、该方法暂时只创建BindingData，不建立双向关联
     */
    static createFromEntityManager(entityManager, bindingPath) {
        const bindingData = new BindingData();
        const bindingProperties = PropertyUtil.getProperties(entityManager.entityType);
        const bindingList = BindingListFactory.create(bindingProperties);
        bindingData.initByBindingList(bindingList, null, entityManager.entityCollection.entityTypeInfo);
        // 初始化数据
        const entities = entityManager.getEntitiesByPath([]);
        EntityUtil.loadEntities(entities, bindingList);
        return bindingData;
    }
    /**
     * 根据已经存在的BindingData创建一个新的BindingData
     */
    static createFromExistingBindingData(existingBindingData, bindingPath) {
        const bindingData = new BindingData();
        bindingData.initByBindingList(existingBindingData.list, null, bindingData.dataTypeInfo);
        return bindingData;
    }
}

/**
 * EntityPath转换器
 */
class EntityPathConverter {
    /**
     * 转换为Entity可识别的路径
     * 根：[]
     * 主表：['id:xxx', 'name'],
     * 关联：['id:xxx', 'deptInfo', 'id:xxx', 'name']
     * UDT: ['id:xxx', 'updateInfo', ':', 'createdOn']
     * 从表：['id:xxx', 'edus', 'id:xxx', 'name'],
     * 从从表：['id:xxx', 'edus', 'id:xxx', 'grades', 'id:xxx', 'name']
     */
    static toEntityPathArray(bindingPathString, bindingData) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPathString);
        const entityPathArray = [];
        if (bindingPathArray.length === 0) {
            return entityPathArray;
        }
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            switch (propInfo.type) {
                case BindingPropertyType.Plain:
                    entityPathArray.push(propName);
                    break;
                case BindingPropertyType.Object:
                    currentBindingObject = currentBindingObject[propName];
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                case BindingPropertyType.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                default:
                    break;
            }
        });
        return entityPathArray;
    }
    /**
     * 创建路径中的主键部分
     */
    static createPrimaryKeyPath(primaryKey, primaryKeyValue) {
        return `${primaryKey}:${primaryKeyValue}`;
    }
}

/**
 * 实体路径比较器
 */
class EntityPathComparer {
}

/**
 * 表单路径转换类
 */
class FormPathConverter {
    /**
     * ControlPathString => BingingPathArray
     * @params controlPath FormControl对应的数据绑定路径（BindingData的bindingPaht + FormControl的binding）
     * @return BindingPath数组
     */
    static toBindingPathArray(formPahtString) {
        const bindingPathArray = formPahtString.split('.').filter((part) => {
            return part !== '';
        });
        return bindingPathArray;
    }
}

/**
 * 数据路径转换、比较等工具类
 * @summary
 * ----------------------------------------
 * 术语：
 * BindingPath：数组形式；
 * BindingPathString：BindingPath的字符串形式，用/分隔；
 * ControlPathString：BindingPath的字符串形式，用.分隔；
 *
 * EntityPath：数组形式；
 * EntityPathString：EntityPath的字符串形式，使用/分隔；
 * ----------------------------------------
 */

/**
 * 路径处理工具类（处理/PathNode1/PathNode2/...格式的路径）
 */
class DataPathUtil {
    /**
     * 转换成BindingData可识别的路径
     */
    static convertToBindingPathArray(path) {
        const bindingPathArray = path.split('/').filter((part) => {
            return part !== '';
        });
        return bindingPathArray;
    }
    /**
     * 转换为Entity可识别的路径
     * 根：[]
     * 主表：['id:xxx', 'name'],
     * 关联：['id:xxx', 'deptInfo', 'id:xxx', 'name']
     * UDT: ['id:xxx', 'updateInfo', ':', 'createdOn']
     * 从表：['id:xxx', 'edus', 'id:xxx', 'name'],
     * 从从表：['id:xxx', 'edus', 'id:xxx', 'grades', 'id:xxx', 'name']
     */
    static convertToEntityPathArray(path, bindingData) {
        const bindingPathArray = this.convertToBindingPathArray(path);
        const entityPathArray = [];
        if (bindingPathArray.length === 0) {
            return entityPathArray;
        }
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            switch (propInfo.type) {
                case BindingPropertyType.Plain:
                    entityPathArray.push(propName);
                    break;
                case BindingPropertyType.Object:
                    currentBindingObject = currentBindingObject[propName];
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                case BindingPropertyType.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                default:
                    break;
            }
        });
        return entityPathArray;
    }
    /**
     * 转换为RestUrl里的路径
     *
     * 返回结果：
     * 主表（/）：/
     * 从表（/jiwtEdus）：/xxx/jiwtEdus
     * 从从表（/jiwtEdus/jiwtGrades）： /xxx/jiwtEdus/xxx/jiwtGrades
     */
    static convertToRestUrl(path, bindingData) {
        const bindingPathArray = this.convertToBindingPathArray(path);
        const restPathArray = [];
        let currentBindingObject = bindingData.list.currentItem;
        restPathArray.push(currentBindingObject.primaryKeyValue);
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            if (propInfo.type !== BindingPropertyType.List) {
                throw new Error(`${propInfo.name}不是子表对应的属性`);
            }
            const currentBindingList = currentBindingObject[propName];
            currentBindingObject = currentBindingList.currentItem;
            restPathArray.push(propName);
            restPathArray.push(currentBindingObject.primaryKeyValue);
        });
        // 移除最后一个主键
        restPathArray.pop();
        return '/' + restPathArray.join('/');
    }
    /**
     * 获取叶子节点的Path
     */
    static getLeafPath(path) {
        const pathArray = DataPathUtil.convertToBindingPathArray(path);
        return pathArray.pop();
    }
    /**
     * 获取父路径
     */
    static getParentPath(path) {
        const pathArray = DataPathUtil.convertToBindingPathArray(path);
        pathArray.pop();
        return '/' + pathArray.join('/');
    }
    /**
     * 创建路径中的主键部分
     */
    static createPrimaryKeyPath(primaryKey, primaryKeyValue) {
        return `${primaryKey}:${primaryKeyValue}`;
    }
}

// tslint:disable: max-line-length
/**
 * GUID创建服务
 * @scope 静态类没有提供Provider
 */
class Guid {
    constructor(guid) {
        if (!guid) {
            throw new TypeError('Invalid argument; `value` has no value.');
        }
        this.value = Guid.EMPTY;
        if (guid && Guid.isGuid(guid)) {
            this.value = guid;
        }
    }
    static isGuid(guid) {
        const value = guid.toString();
        return guid && (guid instanceof Guid || Guid.validator.test(value));
    }
    static create() {
        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join('-'));
    }
    static createEmpty() {
        return new Guid('emptyguid');
    }
    static parse(guid) {
        return new Guid(guid);
    }
    static raw() {
        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join('-');
    }
    static gen(count) {
        let out = '';
        for (let i = 0; i < count; i++) {
            // tslint:disable-next-line:no-bitwise
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    }
    equals(other) {
        // Comparing string `value` against provided `guid` will auto-call
        // toString on `guid` for comparison
        return Guid.isGuid(other) && this.value === other.toString();
    }
    isEmpty() {
        return this.value === Guid.EMPTY;
    }
    toString() {
        return this.value;
    }
    toJSON() {
        return {
            value: this.value,
        };
    }
}
Guid.validator = new RegExp('^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$', 'i');
Guid.EMPTY = '00000000-0000-0000-0000-000000000000';

/*
 * @Author: aalizzwell
 * @Date: 2019-10-25 13:30:52
 * @Last Modified by:   aalizzwell
 * @Last Modified time: 2019-10-25 13:30:52
 */
const isObservable = (value) => {
    if (!value) {
        return false;
    }
    if (value[Symbol.observable] && value === value[Symbol.observable]()) {
        return true;
    }
    if (value['@@observable'] && value === value['@@observable']()) {
        return true;
    }
    if (value instanceof Observable) {
        return true;
    }
    return false;
};
const ɵ0$1 = isObservable;

/**
 * 环境工具类
 */
class EnvUtil {
    /**
     * 是否在任务中心中运行
     */
    static isInWf() {
        const url = window.top.location.pathname;
        if (url.indexOf('wf/webapp/apptaskcenter') !== -1 || url.indexOf('wf/webapp/mobiletaskcenter') !== -1 || url.indexOf('wf/webapp/proc-center-mobile') !== -1) {
            return true;
        }
        return false;
    }
}

/**
 * Url工具类
 */
class UrlUtil {
    /**
     * 获取参数对象
     */
    static getParams(url) {
        const urlParts = url.split('?');
        if (urlParts.length < 2) {
            return null;
        }
        const params = {};
        const paramsString = urlParts[1];
        const keyValueStrings = paramsString.split('&');
        keyValueStrings.forEach((keyValueString) => {
            if (!keyValueString) {
                return;
            }
            const keyValue = keyValueString.split('=');
            if (keyValue.length < 2) {
                return;
            }
            params[keyValue[0]] = keyValue[1];
        });
        return params;
    }
}

/**
 * 【对象属性元数据】名称
 */
const OBJECT_PROP_META = 'ObjectPropMeta';
/**
 * 【对象属性元数据装饰器工厂】的工厂
 */
function makeObjectPropMetaDecorator(options) {
    if (ObjectUtil.isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 对象属性元数据装饰器工厂
 */
const ObjectPropMeta = makePropDecorator(OBJECT_PROP_META, makeObjectPropMetaDecorator);

/**
 * 【动态对象元数据装饰器】名称
 */
const DYNAMIC_PROP_META = 'DynamicPropMeta';
/**
 * 【动态对象元数据装饰器工厂】的工厂
 */
function makeDynamicPropMetaDecorator(options) {
    if (ObjectUtil.isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 实体属性注解
 */
const DynamicPropMeta = makePropDecorator(DYNAMIC_PROP_META, makeDynamicPropMetaDecorator);

/**
 * 【列表属性元数据】名称
 */
const LIST_PROP_META = 'ListPropMeta';
/**
 * 【列表属性元数据装饰器工厂】的工厂
 */
function makeListPropMetaDecorator(options) {
    if (ObjectUtil.isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 列表属性装饰器工厂
 */
const ListPropMeta = makePropDecorator(LIST_PROP_META, makeListPropMetaDecorator);

const ENTITY_META = 'EntityMeta';
/**
 * 实体装饰器
 */
function EntityMeta(options) {
    const decoratorFactory = makeDecorator(ENTITY_META, (obj) => obj);
    return decoratorFactory(options);
}

/**
 * 属性注解器通用方法
 */
class FieldMetadataUtil {
    /**
     * 获取实体所有的简单属性元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgObjectProperty}
     */
    static getNgFields(target) {
        return MetadataUtil.getPropsMetadatasByName(target, PRIMITIVE_PROP_META);
    }
    /**
     * 获取某个简单属性的元数据
     */
    static getNgField(target, propName) {
        const ngFields = this.getNgFields(target);
        const ngField = ngFields[propName];
        return ngField;
    }
    /**
     * 获取实体属性在原始数据中的属性名
     */
    static getDataField(target, propName) {
        const ngField = this.getNgField(target, propName);
        return ngField.dataField || propName;
    }
    /**
     * 获取标注为NgObject的属性的元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgObjectProperty}
     */
    static getNgObjects(target) {
        return MetadataUtil.getPropsMetadatasByName(target, OBJECT_PROP_META);
    }
    static getNgDynamic(target) {
        return MetadataUtil.getPropsMetadatasByName(target, DYNAMIC_PROP_META);
    }
    /**
     * 获取标注为NgList的属性的元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgListProperty}
     */
    static getNgList(target) {
        return MetadataUtil.getPropsMetadatasByName(target, LIST_PROP_META);
    }
    /**
     * 获取实体标注为主键的属性元数据
     * @param target 实体类型
     */
    static getPrimaryFieldMetadata(target) {
        const ngFieldObj = FieldMetadataUtil.getNgFields(target);
        const primaryKey = Object.keys(ngFieldObj).find((prop) => {
            return ngFieldObj[prop].primary;
        });
        if (primaryKey) {
            const propMeta = ngFieldObj[primaryKey];
            propMeta.property = primaryKey;
            if (!propMeta.dataField) {
                propMeta.dataField = primaryKey;
            }
            return propMeta;
        }
        return undefined;
    }
    /**
     * 获取主键名称，没有主键时返回空字符串
     */
    static getPrimaryKey(entityType) {
        const primaryNgField = this.getPrimaryFieldMetadata(entityType);
        if (!primaryNgField) {
            return '';
        }
        return primaryNgField.property;
    }
}

/**
 * 实体元数据工具类
 */
class EntityMetadataUtil {
    /**
     * 获取所有属性
     * @todo：封装根据基类获取所有元数据的方法，解决重复代码
     */
    static getAllNgProperties(entityType) {
        const ngPlainProperties = this.getNgFieldProperties(entityType);
        const ngEntityProperties = this.getNgObjectProperties(entityType);
        const ngDynamicProperties = this.getNgDynamicProperties(entityType);
        const ngEntityListProperties = this.getNgObjectProperties(entityType);
        return Object.assign({}, ngPlainProperties, ngEntityProperties, ngDynamicProperties, ngEntityListProperties);
    }
    /**
     * 获取EnttiyClassMetadata
     */
    static getNgEntityMatadata(entityType) {
        return MetadataUtil.getClassMetadataByNameWithTranslate(entityType, ENTITY_META);
    }
    /**
     * 获取PrimitivePropMetadata的属性元数据
     */
    static getNgFieldProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, PRIMITIVE_PROP_META);
    }
    /**
     * 获取ObjectPropMetadata属性元数据
     */
    static getNgObjectProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, OBJECT_PROP_META);
    }
    /**
     * 获取DynamicPropMetadata属性元数据
     */
    static getNgDynamicProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, DYNAMIC_PROP_META);
    }
    /**
     * 获取ListPropMetadata属性元数据
     */
    static getNgListProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, LIST_PROP_META);
    }
    /**
     * 获取主键属性元数据
     */
    static getPrimaryKeyProperty(entityType) {
        let primaryKeyProperty;
        const ngPlainProperties = EntityMetadataUtil.getNgFieldProperties(entityType);
        Object.keys(ngPlainProperties).forEach((propName) => {
            const ngProperty = ngPlainProperties[propName];
            if (ngProperty.primary === true) {
                primaryKeyProperty = ngProperty;
            }
        });
        return primaryKeyProperty;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-07 09:05:09
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-27 20:35:02
 */
/**
 * 实体类型信息
 * @todo：
 * 1、构造时不应该识别Entity模块的东西，应该是更抽象的；
 * 2、构造函数应该接收一个Builder接口，由Entity或者其他实现层来实现这个接口。
 */
class DataTypeInfo {
    /**
     * 是否为值对象
     */
    get isValueObject() {
        return !this.primaryKey;
    }
    /**
     * 构造函数
     * @todo：不应该识别
     */
    constructor(type) {
        this.type = type;
        this.primaryKey = '';
        this.foreignKey = '';
        this.propInfoMap = new Map();
        this.collectEntityInfos();
        this.collectPropInfos();
    }
    /**
     * 获取全部属性信息
     */
    getPropInfos() {
        return Array.from(this.propInfoMap.values());
    }
    /**
     * 获取全部属性的名称
     */
    getPropNames() {
        const propNames = [];
        const propInfos = this.getPropInfos();
        propInfos.forEach((propInfo) => {
            propNames.push(propInfo.name);
        });
        return propNames;
    }
    /**
     * 根据group获取属性信息数组
     */
    getPropInfosByGroup(group) {
        const allPropInfos = Array.from(this.propInfoMap.values());
        const propInfos = allPropInfos.filter((propInfo) => {
            return propInfo.group === group;
        });
        return propInfos;
    }
    /**
     * 根据group获取属性名称数组
     * @param group 属性分组
     */
    getPropNamesByGroup(group) {
        const propNames = [];
        const propInfos = this.getPropInfosByGroup(group);
        propInfos.forEach((propInfo) => {
            propNames.push(propInfo.name);
        });
        return propNames;
    }
    /**
     * 根据propName获取属性信息
     */
    getPropInfoByName(propName) {
        if (this.propInfoMap.has(propName)) {
            return this.propInfoMap.get(propName);
        }
        return null;
    }
    /**
     * 根据path获取属性信息
     */
    getPropInfoByPath(path) {
        // 先复制，防止shift方法产生污染
        const arrPath = path.concat([]);
        if (arrPath.length === 0) {
            throw Error(`属性路径不能为空`);
        }
        // 循环查找
        let typeInfo = this;
        let propInfo = null;
        while (typeInfo && arrPath.length > 0) {
            const propName = arrPath.shift();
            propInfo = typeInfo.getPropInfoByName(propName);
            if (!propInfo) {
                throw Error(`路径${path}中存在不正确的节点${propName}，请检查`);
            }
            typeInfo = propInfo.typeInfo;
            // 如果是动态列，并且路径数组里还有属性，统一设置为null(动态列不再描述属性信息)
            if (propInfo.group === DataPropGroup.Dynamic && arrPath.length > 0) {
                propInfo = null;
                typeInfo = null;
            }
        }
        return propInfo;
    }
    /**
     * 根据path获取对应属性的TypeInfo
     */
    getTypeInfoByPath(path) {
        // 空数组时返回
        if (path.length === 0) {
            return this;
        }
        // 获取对应属性信息
        const propInfo = this.getPropInfoByPath(path);
        if (!propInfo.typeInfo) {
            throw Error(`路径${path}无法定位到一个EntityTypeInfo，请检查`);
        }
        return propInfo.typeInfo;
    }
    /**
     * 获取主键的属性信息
     */
    getPrimaryKeyPropInfo() {
        return this.getPropInfoByName(this.primaryKey);
    }
    /**
     * 根据name获取影射名
     */
    getPropMappingByName(name) {
        const propInfo = this.getPropInfoByName(name);
        if (!propInfo) {
            return '';
        }
        return propInfo.mapping;
    }
    /**
     * 根据path获取映射名
     */
    getPropMappingByPath(path) {
        const propInfo = this.getPropInfoByPath(path);
        if (!propInfo) {
            return '';
        }
        return propInfo.mapping;
    }
    /**
     * 检查属性是否属于特定的分组
     */
    checkPropGroup(propName, propGroup) {
        const propInfo = this.getPropInfoByName(propName);
        if (propInfo && propInfo.group === propGroup) {
            return true;
        }
        return false;
    }
    /**
     * --------------------------------------------------------------------------------
     * 属性元数据 => 属性描述信息
     * --------------------------------------------------------------------------------
     */
    collectEntityInfos() {
        const entityMetadata = EntityMetadataUtil.getNgEntityMatadata(this.type);
        this.entityInfo = entityMetadata;
    }
    /**
     * 搜集所有属性信息
     * @todo：消除重复代码，ts不支持interface类型检测，暂时通过遍历实现。
     */
    collectPropInfos() {
        // 简单属性
        const ngPlainProperties = EntityMetadataUtil.getNgFieldProperties(this.type);
        Object.keys(ngPlainProperties).forEach((propName) => {
            const ngProperty = ngPlainProperties[propName];
            if (ngProperty.primary === true) {
                this.primaryKey = propName;
            }
            if (ngProperty.foreign === true) {
                this.foreignKey = propName;
            }
            this.addPropInfo(DataPropGroup.Primitive, propName, ngProperty.dataField, null, ngProperty);
        });
        // 实体属性
        const ngEntityProperties = EntityMetadataUtil.getNgObjectProperties(this.type);
        Object.keys(ngEntityProperties).forEach((propName) => {
            const ngProperty = ngEntityProperties[propName];
            this.addPropInfo(DataPropGroup.Object, propName, ngProperty.dataField, ngProperty.type, ngProperty);
        });
        // 动态实体属性
        const ngDynamicProperties = EntityMetadataUtil.getNgDynamicProperties(this.type);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            const ngProperty = ngDynamicProperties[propName];
            this.addPropInfo(DataPropGroup.Dynamic, propName, ngProperty.dataField, null, ngProperty);
        });
        // 实体列表属性
        const ngEntityListProperties = EntityMetadataUtil.getNgListProperties(this.type);
        Object.keys(ngEntityListProperties).forEach((propName) => {
            const ngProperty = ngEntityListProperties[propName];
            this.addPropInfo(DataPropGroup.List, propName, ngProperty.dataField, ngProperty.type, ngProperty);
        });
    }
    /**
     * 添加属性信息
     */
    addPropInfo(group, name, mapping, type, metadataInfo) {
        // 没有设置影射时，用属性名充当影射
        mapping = mapping ? mapping : name;
        let typeInfo = null;
        if (type) {
            typeInfo = new DataTypeInfo(type);
        }
        const propInfo = { group, name, mapping, typeInfo, metadataInfo };
        this.propInfoMap.set(name, propInfo);
    }
}

/**
 * 数据Path工厂类
 */
class DataPathCreator {
    /**
     * 将长路径数组或字符串转换为
     * @param fullPathArrayOrString 路径数组或字符串
     * @param repository 实体仓库
     * @summary
     * 1、长路径格式说明参考：data-path.md
     */
    static createByLongPathFromRoot(fullPathArrayOrString, entityManager) {
        const dataPath = new DataPath();
        const fullPathArray = fullPathArrayOrString;
        if (!fullPathArray || fullPathArray.length === 0) {
            return dataPath;
        }
        let currentNodeInfo = {
            nodeValue: fullPathArray.shift(),
            nodeType: DataPathNodeType.DataId,
            entityTypeInfo: new DataTypeInfo(entityManager.entityType)
        };
        while (currentNodeInfo) {
            dataPath.push(currentNodeInfo.nodeType, currentNodeInfo.nodeValue);
            // 处理下一个节点
            const nextNodeValue = fullPathArray.shift();
            if (!nextNodeValue || !currentNodeInfo.entityTypeInfo) {
                break;
            }
            currentNodeInfo = this.getNextPathNodeInfo(currentNodeInfo, nextNodeValue);
        }
        return dataPath;
    }
    /**
     * 获取下一个路径节点的信息
     * @param parentNodeInfo 当前路径节点信息
     * @param nextNodeValue 下一个路径节点的值
     * @summary
     * 1、这个递归写的很绕，说明数据结构设计不合理；
     * 2、多个因素混用了一个结构；
     */
    static getNextPathNodeInfo(parentNodeInfo, nextNodeValue) {
        const parentNodeValue = parentNodeInfo.nodeValue;
        const parentNodeType = parentNodeInfo.nodeType;
        const parentEntityTypeInfo = parentNodeInfo.entityTypeInfo;
        if (!nextNodeValue || !parentEntityTypeInfo) {
            return null;
        }
        const nextPathNodeInfo = {
            nodeValue: nextNodeValue,
            nodeType: null,
            entityTypeInfo: null
        };
        // DataNodeType=List：下一节点肯定是Object，并且EntityTypeInfo不变
        if (parentNodeType === DataPathNodeType.DataId) {
            nextPathNodeInfo.nodeType = DataPathNodeType.PropName;
            nextPathNodeInfo.entityTypeInfo = parentEntityTypeInfo;
        }
        else {
            // DataNodeType=Object：必然对应一个属性信息
            const nextPropInfo = parentEntityTypeInfo.getPropInfoByName(parentNodeValue);
            if (nextPropInfo.group === DataPropGroup.List) {
                // EntityPropGroup=EntityList：下一个节点是List类型。
                nextPathNodeInfo.nodeType = DataPathNodeType.DataId;
                nextPathNodeInfo.entityTypeInfo = nextPropInfo.typeInfo;
            }
            else {
                // EntityPropGroup=Entity：       下级entityTypeInfo为
                // EntityPropGroup=Dynamic|Plain：null
                nextPathNodeInfo.nodeType = DataPathNodeType.PropName;
                nextPathNodeInfo.entityTypeInfo = nextPropInfo.group === DataPropGroup.Object ? nextPropInfo.typeInfo : null;
            }
        }
        return nextPathNodeInfo;
    }
    /**
     * @param fullPathArrayOrString 路径数组或字符串
     * @param repository 实体仓库
     * @summary
     * 1、长路径格式说明参考：data-path.md
     * 2、shortPathArrayOrString暂时只支持字符串数组
     */
    static createByShortPathFromRoot(shortPathArrayOrString, entityManager, bindingData) {
        const dataPath = new DataPath();
        const shortPathArray = shortPathArrayOrString;
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        let currentEntityTypeInfo = new DataTypeInfo(entityManager.entityType);
        dataPath.push(DataPathNodeType.DataId, currentBindingObject.primaryKeyValue);
        // 遍历下级节点
        shortPathArray.forEach((propName) => {
            const propInfo = currentEntityTypeInfo.getPropInfoByName(propName);
            switch (propInfo.group) {
                case DataPropGroup.Primitive:
                    dataPath.push(DataPathNodeType.PropName, propName);
                    break;
                case DataPropGroup.Object:
                    currentBindingObject = currentBindingObject[propName];
                    currentEntityTypeInfo = propInfo.typeInfo;
                    dataPath.push(DataPathNodeType.PropName, propName);
                    break;
                case DataPropGroup.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    currentEntityTypeInfo = propInfo.typeInfo;
                    dataPath.push(DataPathNodeType.PropName, propName);
                    dataPath.push(DataPathNodeType.DataId, currentBindingObject.primaryKeyValue);
                    break;
                default:
                    break;
            }
        });
        return dataPath;
    }
}

/**
 * 获取path对应的实体
 * @summary
 * 关于path的格式如下：
 * - 主表：[parentId]
 * - 主表关联: [parentId, assoInfo]
 * - 从表: [parentId, child1s, child1Id]
 * - 从表关联：[parentId, child1s, child1Id, assoInfo]
 * - 从从表: [parentId, child1s, child1Id, grand11s, grand11Id]
 * - 从从表关联：[parentId, child1s, child1Id, grand11s, grand11Id, assoInfo]
 */

const PARENT_PATH = '__PARENT_PATH__';
const PARENT_CLASS = '__PARENT__';

/**
 * 创建实体
 * @param entityType 实体类型
 * @param entityData 实体数据
 */
function createEntity(entityType, entityData) {
    const entity = new entityType(entityData);
    return entity;
}
/**
 * 批量创建实体
 * @param entityType     实体类型
 * @param entityListData 实体数据数组
 */
function createEntities(entityType, entityListData) {
    const entities = [];
    entityListData.forEach((entityData) => {
        const entity = createEntity(entityType, entityData);
        entities.push(entity);
    });
    return entities;
}
/**
 * 已弃用：请使用createEntity方法代替。
 */
function EntityFactory(T, data) {
    const entity = new T(data);
    return entity;
}

/**
 * 实体集合列表
 */
class EntityList {
    // #endregion
    /**
     * @param data JSON数据集合
     * @param type 集合中的实体类型
     */
    constructor(data, type) {
        this.__type__ = 'EntityList';
        // #region 私有属性
        this.originalData = [];
        /**
         * 已废弃：请勿使用
         */
        this.listChanged = new Subject();
        /**
         * 已废弃：请勿使用
         */
        this.changeSet = new ChangeSet();
        // #endregion
        // #region 公有属性
        /**
         * 集合改变时触发(新增、行记录修改、删除)
         * @event
         */
        this.onListChanged = this.listChanged.asObservable();
        this.clear();
        if (data) {
            // this.loadEntities(data);
            data.forEach(item => {
                this.initEntity(EntityFactory(type, item));
            });
        }
    }
    /**
     * 获取项集合
     */
    get items() {
        return this.rawData;
    }
    /**
     * 列表变更集
     */
    get changes() {
        return this.changeSet.changes;
    }
    /**
     * 迭代器
     */
    *[Symbol.iterator]() {
        yield* this.items;
    }
    // #region 公有方法
    /** 加载实体列表 */
    loadEntities(entities) {
        this.clear();
        entities.forEach(entity => {
            this.initEntity(entity);
        });
        // 发送Load变更
        const changeItem = {
            path: [],
            value: entities,
            preValue: undefined,
            type: ModifyType.Load,
            target: this
        };
        this.setChanges(changeItem);
    }
    /**
     * 清空
     */
    clear() {
        this.rawData = [];
        this.originalData = [];
    }
    /**
     * 添加实体对象到集合中，并返回新加的对象
     * @param entity 实体对象
     * @param isCloned 克隆
     */
    appendNew(entity, isCloned = false) {
        const newEntity = this.initEntity(entity, true);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Add
        };
        if (isCloned === true) {
            changeItem.type = ModifyType.Clone;
        }
        this.setChanges(changeItem);
        return newEntity;
    }
    /**
     * 在指定位置插入实体
     * @param entity 实体
     * @param position 插入位置
     */
    insert(entity, position) {
        const newEntity = this.initEntity(entity, true);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Insert,
            position: position,
        };
        this.setChanges(changeItem);
        return newEntity;
    }
    /**
     * 追加实体
     */
    appendEntity(entity) {
        const newEntity = this.initEntity(entity);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Add
        };
        this.setChanges(changeItem);
    }
    /**
     * 批量追加实体
     */
    appendEntities(entities) {
        const newEntites = entities.map((entity) => {
            return this.initEntity(entity);
        });
        const changeItem = {
            path: [],
            value: newEntites,
            preValue: undefined,
            type: ModifyType.Add
        };
        this.setChanges(changeItem);
    }
    /**
     * 删除指定主键ID 的实体对象，返回布尔，true 删除成功，false 删除失败
     * @param primaryId 主键ID
     */
    remove(primaryId) {
        const total = this.count();
        const indexToRemove = this.rawData.findIndex((entity) => {
            return entity.primaryValue === primaryId;
        });
        if (indexToRemove === -1) {
            return false;
        }
        const entityToRemove = this.rawData[indexToRemove];
        this.rawData.splice(indexToRemove, 1);
        // 删除变更
        const changeItem = {
            path: [],
            value: { [entityToRemove.primaryProperty.dataField]: primaryId },
            preValue: undefined,
            type: ModifyType.Remove
        };
        this.updateIndex(total);
        this.setChanges(changeItem);
        return true;
    }
    /**
     * 从集合中获取指定ID值的实体对象
     * @param id 主键值
     */
    get(id) {
        return this.items.find(item => {
            return item.primaryValue === id;
        });
    }
    /**
     * 将变更记录添加到集合变更集中
     * @param value 变更记录
     */
    setChanges(modinfo) {
        // 向app层发送的变更
        this.listChanged.next(modinfo);
        // 构造向changeSet中添加的chagne
        const change = Object.assign({}, modinfo);
        if ((modinfo.type === ModifyType.Add || modinfo.type === ModifyType.Insert || modinfo.type === ModifyType.Clone) && modinfo.value[0] instanceof Entity) {
            change.value = [modinfo.value[0].data];
        }
        this.changeSet.append(change);
    }
    /** 集合总记录数 */
    count() {
        return this.items.length;
    }
    /**
     * 获取实体对象的索引值
     */
    indexOf(entity) {
        return this.items.indexOf(entity);
    }
    /**
     * 计算集合中某个属性的总和
     * @param propertyName 属性名称
     */
    sum(propertyName) {
        if (this.count() === 0) {
            return 0;
        }
        return this.items.reduce((val, curr) => {
            return val + curr[propertyName];
        }, 0);
    }
    /**
     * 已废弃：请使用toJSON方法代替
     * @deprecated
     */
    toJson() {
        return this.rawData;
    }
    /**
     * 转换为JSON格式
     */
    toJSON() {
        const result = [];
        this.items.forEach((entity) => {
            result.push(entity.toJSON());
        });
        return result;
    }
    toArray() {
        return this.items;
    }
    // #endregion
    // #region 私有方法
    /**
     * 实体初始化
     * @param entity 实体
     */
    initEntity(entity, isNewEntity = false) {
        entity[PARENT_CLASS] = this;
        entity[PARENT_PATH] = this[PARENT_PATH];
        entity.onValueChanged.subscribe((v) => {
            const path = v.path;
            const value = v.value;
            const preValue = v.preValue;
            const operator = v.type;
            const subChanges = { path, value, preValue, type: operator };
            if (v.changeSetValue !== undefined) {
                subChanges['changeSetValue'] = v.changeSetValue;
            }
            this.setChanges(subChanges);
        });
        // TODO: 添加数据验证逻辑代码
        const newLength = this.rawData.push(entity);
        this[newLength - 1] = entity;
        if (!isNewEntity) {
            this.originalData.push(entity.toJSON());
        }
        return entity;
    }
    /**
     * 更新索引
     * @param total 总记录数
     */
    updateIndex(total) {
        for (let i = 0; i < total; i++) {
            delete this[i];
        }
        this.rawData.forEach((entity, index) => {
            this[index] = entity;
        });
    }
    /**
     * 获取属性名称
     */
    getPropertyName() {
        const path = this[PARENT_PATH];
        if (path && path.length) {
            const name = path[path.length - 1];
            return name;
        }
        return undefined;
    }
}

function EntityFactory$1(T, data) {
    const entity = new T(data);
    return entity;
}

;
/**
 * @author Lucas Huang
 * 实体抽象基类，所有实体必须扩展自Entity
 *
 * ### 使用示例
 * ```
 * export class UserEntity extends Entity {
 *    userId: string;
 *    userName: string;
 *
 *    constructor(data: any){
 *        super(data);
 *    }
 * }
 * ```
 */
class Entity {
    // #endregion
    /**
     * @param data JSON数据
     */
    constructor(data) {
        // #region 私有、保护属性
        /**
         * 验证错误集合
         */
        this.validErrors = {};
        /**
         * 增量变更集合
         */
        this.changeSet = new ChangeSet();
        /**
         * 是否正在验证
         */
        this.isValidating = false;
        /**
         * 新数据
         */
        this.newData = undefined;
        // #endregion
        // #region 公有属性
        /**
         * 变更流
         */
        this.valueChanged = new Subject();
        /**
         * 属性值改变时触发
         *
         * ### 使用示例
         * ```
         *  const entity = new UserEntity(data);
         *  entity.onValueChanged.subscribe((data: Modification) => {
         *      console.log(data);
         *  })
         *
         * ```
         *
         * @event
         */
        this.onValueChanged = this.valueChanged.asObservable();
        /**
         * 是否变更
         */
        this.hasChange = false;
        this.newData = Object.assign({}, data);
        this.onValueChanged = this.valueChanged;
        this.initialize();
    }
    /**
     * 返回JSON格式的数据
     */
    get data() {
        return this.newData;
    }
    /**
     * 验证错误集合
     */
    get errors() {
        return this.validErrors;
    }
    /**
     * 实体变更集
     */
    get changes() {
        return this.changeSet.changes;
    }
    /**
     * 实体主键元数据
     */
    get primaryProperty() {
        return FieldMetadataUtil.getPrimaryFieldMetadata(this.constructor);
    }
    /**
     * 主键
     * @todo
     * 1、没有主键时返回''不合理，应该返回undefined
     */
    get primaryKey() {
        if (this.primaryProperty) {
            return this.primaryProperty.property;
        }
        else {
            return '';
        }
    }
    /**
     * 实体主键值
     * 1、没有主键时返回''不合理，应该返回undefined
     */
    get primaryValue() {
        if (this.primaryKey) {
            // return this[this.primaryProperty.property].toString();
            const primaryValue = this[this.primaryProperty.property];
            return primaryValue ? primaryValue : '';
        }
        else {
            return '';
        }
    }
    // #region 公有方法
    /**
     * 将变更记录保存至变更集中
     * @param value 变更记录
     */
    setChanges(value) {
        const propertyName = value.path[value.path.length - 1];
        // 增加实体变化后增加标志，加载数据或者重新加载不做标记
        if (value.type !== ModifyType.Load) {
            this.hasChange = true;
        }
        // @todo：事件会从下级向上冒泡，change可能是下级的，不能和当前Entity的newData合并。
        // this.newData = Object.assign(this.newData, { [propertyName]: value.value });
        this.valueChanged.next(value);
        this.changeSet.append(value);
    }
    getPaths() {
        const pathObj = {
            path: [],
            isUdt: false,
            isGrid: false
        };
        const handleParent = item => {
            const parentPaths = item[PARENT_PATH];
            if (parentPaths) {
                const prop = parentPaths[parentPaths.length - 1];
                // 父级所在实体包含的ngObject，存在当前实体字段，则判断为UDt字段
                if (Object.keys(FieldMetadataUtil.getNgObjects(item[PARENT_CLASS].constructor)).indexOf(prop) > -1) {
                    pathObj.isUdt = true;
                }
                // 存在类型为ngList，则判断为grid
                if (item[PARENT_CLASS] && item instanceof EntityList === true) {
                    pathObj.isGrid = true;
                }
                pathObj.path.push(prop);
            }
            if (item[PARENT_CLASS] && item instanceof EntityList === true) {
                handleParent(item[PARENT_CLASS]);
            }
        };
        handleParent(this);
        pathObj.path = pathObj.path.reverse();
        return pathObj;
    }
    /**
     * 加载数据
     * @param data 新数据
     */
    load(data) {
        if (!data) {
            data = {};
        }
        this.loadFields(data);
        this.loadLists(data);
        this.loadObjects(data);
        this.loadDynamicObjects(data);
        this.newData = Object.assign({}, data);
    }
    /**
     * 转换为JSON
     */
    toJSON() {
        const result = {};
        // 简单属性
        const ngFields = FieldMetadataUtil.getNgFields(this.constructor);
        Object.keys(ngFields).forEach((propName) => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            result[dataField] = this[propName];
        });
        // 对象属性
        const ngObjects = FieldMetadataUtil.getNgObjects(this.constructor);
        Object.keys(ngObjects).forEach((propName) => {
            const ngObject = ngObjects[propName];
            const dataField = ngObject.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON() : {};
        });
        // 动态属性
        const ngDynamics = FieldMetadataUtil.getNgDynamic(this.constructor);
        Object.keys(ngDynamics).forEach((propName) => {
            const ngDynamic = ngDynamics[propName];
            const dataField = ngDynamic.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON() : {};
        });
        // 列表属性
        const ngLists = FieldMetadataUtil.getNgList(this.constructor);
        Object.keys(ngLists).forEach((propName) => {
            const ngList = ngLists[propName];
            const dataField = ngList.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON() : {};
        });
        return result;
    }
    // #endregion
    //#region 实体初始化相关private方法
    /**
     * 初始化实体
     */
    initialize() {
        const constructor = this.constructor;
        const ngFields = FieldMetadataUtil.getNgFields(constructor);
        const ngObjects = FieldMetadataUtil.getNgObjects(constructor);
        const ngLists = FieldMetadataUtil.getNgList(constructor);
        const ngDynamic = FieldMetadataUtil.getNgDynamic(constructor);
        this.initializeNormalField(ngFields);
        this.initializeList(ngLists);
        this.initializeObject(ngObjects);
        this.initializeDynamic(ngDynamic);
    }
    /**
     * 创建path
     * @param propertyName 属性名称
     */
    createPath(propertyName) {
        const primaryFieldMetadata = this.primaryProperty;
        if (primaryFieldMetadata) {
            const primaryDataField = primaryFieldMetadata.dataField;
            return [primaryDataField + ':' + this.primaryValue, propertyName];
        }
        else {
            return [':', propertyName];
        }
    }
    /**
     * 属性字段初始化
     * @param ngFields 属性字段元数据
     */
    initializeNormalField(ngFields) {
        Object.keys(ngFields).forEach(propName => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            if (delete this[propName]) {
                Object.defineProperty(this, propName, {
                    get: function () {
                        return this.getPropValue(propName, ngField);
                    },
                    set: function (newPropValue) {
                        // 影响清空关联字段的主键值，移除此逻辑
                        // // 有主键的实体，不允许给实体赋空值
                        // if (this.primaryKey && this.primaryKey === propName && !newPropValue) {
                        //   return;
                        // }
                        // 有主键的实体，必须先给主键赋值，否则其他字段不允许赋值
                        if (this.primaryKey && this.primaryKey !== propName && !this.primaryValue) {
                            return;
                        }
                        // 值相同时不触发变更。
                        const oldPropValue = this.getPropValue(propName, ngField);
                        if (this.isPropValueChanged(propName, ngField, newPropValue, oldPropValue) === false) {
                            return;
                        }
                        this.setPropValue(propName, ngField, newPropValue);
                        this.emitValueChange(propName, ngField, newPropValue, oldPropValue);
                    },
                    configurable: true
                });
            }
        });
    }
    /**
     * 初始化列表类型的元数据
     * @param ngListMetadata 列表类型元数据
     */
    initializeList(ngListMetadata) {
        Object.keys(ngListMetadata).forEach(propertyName => {
            const fieldMetadata = ngListMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            const val = this.data[dataField];
            const entityList = new EntityList();
            entityList[PARENT_CLASS] = this;
            entityList[PARENT_PATH] = path;
            if (val) {
                const entities = val.map(v => EntityFactory$1(fieldMetadata.type, v));
                entityList.loadEntities(entities);
            }
            entityList.onListChanged.subscribe(value => {
                if (value) {
                    if (entityList[PARENT_PATH][0] !== value.path[0]) {
                        value.path = entityList[PARENT_PATH].concat(value.path);
                    }
                    this.setChanges(value);
                }
            });
            this[propertyName] = entityList;
        });
    }
    /**
     * 初始化子对象
     * @param ngObjectMetadata 子对象元数据
     */
    initializeObject(ngObjectMetadata) {
        Object.keys(ngObjectMetadata).forEach(propertyName => {
            const fieldMetadata = ngObjectMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            // val不存在时，用空对象代替
            const val = this.data[dataField] || {};
            const createEntityFromJsonData = (value) => {
                let instance;
                if (value instanceof fieldMetadata.type) {
                    instance = value;
                }
                else {
                    instance = EntityFactory$1(fieldMetadata.type, value);
                }
                instance[PARENT_CLASS] = this;
                instance[PARENT_PATH] = path;
                instance.onValueChanged.subscribe(changes => {
                    if (changes) {
                        changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                        this.setChanges(changes);
                    }
                });
                return instance;
            };
            // 如果没有值用一个空对象代替
            let childEntity = createEntityFromJsonData(val);
            if (delete this[propertyName]) {
                Object.defineProperty(this, propertyName, {
                    get: () => {
                        return childEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: childEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        childEntity = createEntityFromJsonData(value);
                        this.setChanges(modifyInfo);
                    },
                    configurable: true
                });
            }
        });
    }
    initializeDynamic(ngDynamicMetadata) {
        Object.keys(ngDynamicMetadata).forEach(propertyName => {
            const fieldMetadata = ngDynamicMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            const originalData = this.data[dataField] || {};
            const createEntityFromJsonData = (value) => {
                let instance;
                if (value instanceof fieldMetadata.type) {
                    instance = value;
                }
                else {
                    instance = EntityFactory$1(fieldMetadata.type, value);
                }
                instance[PARENT_CLASS] = this;
                instance[PARENT_PATH] = path;
                instance.onValueChanged.subscribe(changes => {
                    if (changes) {
                        changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                        this.setChanges(changes);
                    }
                });
                return instance;
            };
            let dynamicEntity = createEntityFromJsonData(originalData);
            if (delete this[propertyName]) {
                Object.defineProperty(this, propertyName, {
                    get: function () {
                        return dynamicEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: dynamicEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        dynamicEntity = createEntityFromJsonData(value);
                        this.setChanges(modifyInfo);
                    },
                    configurable: true
                });
            }
        });
    }
    //#endregion
    // #region 加载实体数据相关private、projected方法
    /**
     * 加载简单字段值
     * @todo 临时用修改的方式模拟
     */
    loadFields(data) {
        const ngFields = FieldMetadataUtil.getNgFields(this.constructor);
        Object.keys(ngFields).forEach((propName) => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            // if (ngField.primary === false) {
            //   this[propName] = data[dataField];
            // }
            this[propName] = data[dataField];
        });
    }
    /**
     * 加载子列表数据
     * @param data 数据
     */
    loadLists(data) {
        const ngLists = FieldMetadataUtil.getNgList(this.constructor);
        Object.keys(ngLists).forEach((propName) => {
            const ngList = ngLists[propName];
            const dataField = ngList.dataField || propName;
            const entityType = ngList.type;
            // 创建实体
            const listData = data[dataField];
            if (listData) {
                const entities = listData.map((entityData) => {
                    return EntityFactory$1(entityType, entityData);
                });
                this[propName].loadEntities(entities);
            }
            else {
                this[propName].loadEntities([]);
            }
        });
    }
    loadObjects(data) {
        const ngObjects = FieldMetadataUtil.getNgObjects(this.constructor);
        Object.keys(ngObjects).forEach((propName) => {
            const ngObject = ngObjects[propName];
            const dataField = ngObject.dataField || propName;
            const objectData = data[dataField];
            const entity = this[propName];
            if (!entity || !objectData) {
                return;
            }
            entity.load(objectData);
        });
    }
    loadDynamicObjects(data) {
        const ngDynamicObjects = FieldMetadataUtil.getNgDynamic(this.constructor);
        Object.keys(ngDynamicObjects).forEach((propName) => {
            const ngDynamicObject = ngDynamicObjects[propName];
            const dataField = ngDynamicObject.dataField || propName;
            const dynamicData = data[dataField] || {};
            const dynamicEntity = this[propName];
            if (!dynamicEntity) {
                return;
            }
            dynamicEntity.loadDynamicData(dynamicData);
        });
    }
    // #endregion
    // #region 私有工具方法
    /**
     * 发送值变更
     */
    emitValueChange(propName, propMetadata, newPropValue, oldPropValue) {
        const change = {
            path: this.createPath(propName),
            value: newPropValue,
            preValue: oldPropValue,
            type: ModifyType.ValueChange
        };
        if (this[PARENT_PATH]) {
            change.path = this[PARENT_PATH].concat(change.path);
        }
        this.setChanges(change);
    }
    /**
     * 获取属性值
     */
    getPropValue(propName, propMetadata) {
        const dataField = propMetadata.dataField || propName;
        const value = this.data[dataField];
        // 对多语录入字段，query不返回问题进行兼容
        if (propMetadata.enableMultiLangInput === true && !value) {
            const langCode = window.localStorage.getItem('languageCode') || 'zh-CHS';
            const originDataField = dataField.replace('_MULTILANGUAGE', '');
            return {
                [langCode]: this.data[originDataField]
            };
        }
        return value;
    }
    /**
     * 设置属性值
     */
    setPropValue(propName, propMetadata, propValue) {
        const dataField = propMetadata.dataField || propName;
        this.data[dataField] = propValue;
    }
    /**
     * 检查属性值是否发生变化
     */
    isPropValueChanged(propName, propMetadata, newPropValue, oldPropValue) {
        if (propMetadata.enableMultiLangInput === true) {
            if (this.isEmptyMultiLangPropValue(newPropValue) === true && this.isEmptyMultiLangPropValue(oldPropValue) === true) {
                return false;
            }
            return JSON.stringify(newPropValue) !== JSON.stringify(oldPropValue);
        }
        else {
            return newPropValue !== oldPropValue;
        }
    }
    /**
     * 多语录入字段的值是否为空
     */
    isEmptyMultiLangPropValue(value) {
        return !value || Object.keys(value).length === 0;
    }
}

/**
 * 支持动态字段集合的动态实体
 */
class DynamicEntity extends Entity {
    /**
     * 是否是嵌套的动态实体
     */
    get IsNested() {
        return this[PARENT_CLASS] instanceof DynamicEntity;
    }
    /**
     * @param data JSON数据
     */
    constructor(data) {
        super(data);
        this.loadDynamicData(data);
    }
    loadDynamicData(dynamicData) {
        this.initializeDynamicField(dynamicData);
        // super.loadFields(dynamicData);
    }
    /**
     * 初始化动态数据
     * @param dynamicData 动态数据
     */
    initializeDynamicField(dynamicData) {
        // 遍历动态数据的key，创建动态实体属性。
        Object.keys(dynamicData).forEach(propertyName => {
            // 如果属性已经存在，先删除
            if (this[propertyName]) {
                delete this[propertyName];
            }
            const dataField = propertyName;
            if (dynamicData[propertyName] instanceof Object) {
                const path = this.createPath(propertyName);
                let dynamicEntity = this.createDynamicEntityFromJsonData(dynamicData[propertyName], path);
                Object.defineProperty(this, propertyName, {
                    get: function () {
                        return dynamicEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: dynamicEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        dynamicEntity = this.createDynamicEntityFromJsonData(value, path);
                        this.setChanges(modifyInfo);
                    },
                    configurable: true
                });
            }
            else {
                Object.defineProperty(this, propertyName, {
                    // 定义返回数据方法。
                    get: function () {
                        // 从初始数据返回字段值。
                        return this.data[dataField];
                    },
                    set: function (value) {
                        // 值相同时不触发变更。
                        const oldValue = this.data[dataField];
                        if (oldValue === value) {
                            return;
                        }
                        // 更新元数据数据。
                        this.data[dataField] = value;
                        // 变更集
                        const changes = {
                            type: ModifyType.ValueChange,
                            path: this.createPath(propertyName),
                            value: value,
                            preValue: oldValue
                        };
                        if (this[PARENT_PATH]) {
                            changes.path = this[PARENT_PATH].concat(changes.path);
                        }
                        this.setChanges(changes);
                    },
                    configurable: true
                });
            }
        });
    }
    createDynamicEntityFromJsonData(value, parentPath) {
        let instance;
        if (value instanceof DynamicEntity) {
            instance = value;
        }
        else {
            instance = new DynamicEntity(value);
        }
        instance[PARENT_CLASS] = this;
        instance[PARENT_PATH] = parentPath;
        instance.onValueChanged.subscribe(changes => {
            if (changes) {
                changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                this.setChanges(changes);
            }
        });
        return instance;
    }
    /**
     * 将变更记录保存至变更集中
     * @param value 变更记录
     * @todo
     * 1、preValue的处理有问题，下级传递上来的变更这样可以，根DyanmicaEntity上的，data已经发生变化，prevalue和value是一样了；
     * 2、当value是下级冒泡上来的，需要根据value去更新当前层级的data，该逻辑不应该放在setChagnes，待修改。
     */
    setChanges(value) {
        const propertyName = value.path[value.path.length - 1];
        const preValue = Object.assign({}, this.data);
        this.newData = Object.assign(this.newData, { [propertyName]: value.value });
        let parentPath = value.path;
        if (value.path.length > 2) {
            parentPath = value.path.slice(0, value.path.length - 2);
        }
        // 统一不使用构造函数（保持和其他位置对Modification的构造一致）
        // const parentModification = new Modification(this.data, value.type, parentPath, preValue);
        const parentModification = {
            path: parentPath,
            value: this.data,
            preValue: preValue,
            type: value.type
        };
        this.valueChanged.next(parentModification);
        this.changeSet.append(value);
    }
    /**
     * toJSON
     */
    toJSON() {
        return this.data;
    }
}

/**
 * REPOSITORY_META
 */
const REPOSITORY_META = 'RepositoryMeta';
/**
 * RepositoryMeta
 */
function RepositoryMeta(options) {
    const decoratorFactory = makeDecorator(REPOSITORY_META, (obj) => obj);
    return decoratorFactory(options);
}

// tslint:disable: no-bitwise
/**
 * 实体集合
 * @todo：应该用EntityList代替。
 */
class EntityCollection {
    /**
     * 构造函数
     */
    constructor(entityType) {
        this.innerEntitySet = new Set();
        this.innerEntityMap = new Map();
        this.collectionChanged = new Subject();
        this.changes = new Subject();
        this.entityType = entityType;
        this.primaryKey = FieldMetadataUtil.getPrimaryKey(this.entityType);
    }
    /**
     * 实体数量
     */
    count() {
        return this.innerEntitySet.size;
    }
    get entityTypeName() {
        return this.entityType.name;
    }
    /**
     * 是否包含指定主键值的实体
     * @param id 主键值
     */
    has(id) {
        return this.innerEntityMap.has(id);
    }
    /**
     * 清空全部实体
     */
    clear() {
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        this.notifyCollectionChanged(new Modification([], ModifyType.Load));
    }
    /**
     * 清空全部实体
     * @param isReset 是否为重置实体操作
     */
    reset() {
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        const modification = new Modification([], ModifyType.Load);
        modification.isReset = true;
        this.notifyCollectionChanged(modification);
    }
    /**
     * 转换为实体数组
     */
    toArray() {
        return Array.from(this.innerEntitySet);
    }
    /**
     * 转换为JSON数组
     */
    toJSON() {
        const result = [];
        const entities = this.toArray();
        entities.forEach((entity) => {
            result.push(entity.toJSON());
        });
        return result;
    }
    /**
     * 批量加载实体
     */
    loadEntities(entities, entityCreate = false) {
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        entities.forEach(entity => {
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
            this.listenEntityChangeEvent(entity);
        });
        const modification = new Modification(entities, ModifyType.Load);
        modification.entityCreate = entityCreate;
        this.notifyCollectionChanged(modification);
    }
    /**
     * 追加实体
     * @param entity 要追加的实体
     * @param isCloned 实体是否是克隆的
     */
    addEntity(entity, isCloned = false) {
        this.verifyEntityToAdd(entity);
        this.innerEntitySet.add(entity);
        this.innerEntityMap.set(entity[this.primaryKey], entity);
        this.listenEntityChangeEvent(entity);
        const modifyType = isCloned ? ModifyType.Clone : ModifyType.Add;
        this.notifyCollectionChanged(new Modification([entity], modifyType));
    }
    /**
     * 在当前行前或后插入数据
     * @param entity 实体
     * @param position 位置
     */
    insertEntity(entity, position) {
        this.verifyEntityToAdd(entity);
        this.innerEntitySet.add(entity);
        this.innerEntityMap.set(entity[this.primaryKey], entity);
        this.listenEntityChangeEvent(entity);
        this.notifyCollectionChanged(new Modification(entity, ModifyType.Insert, null, null, position));
    }
    /**
     * 更新实体
     * @param entity entity
     * @param entityData 实体数据
     */
    updateEntity(entity, entityData) {
        entity.load(entityData);
        this.notifyCollectionChanged(new Modification(entity, ModifyType.Update, null, null));
    }
    /**
     * 批量追加实体
     * @param entities 要加载的实体数组
     */
    addEntities(entities) {
        if (!entities) {
            return;
        }
        const entitiesToAdd = [];
        entities.forEach(entity => {
            this.verifyEntityToAdd(entity);
            entitiesToAdd.push(entity);
        });
        entitiesToAdd.forEach(entity => {
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
            this.listenEntityChangeEvent(entity);
        });
        this.notifyCollectionChanged(new Modification(entitiesToAdd, ModifyType.Add));
    }
    /**
     * 添加实体（不切换当前行）
     * @param entities 实体
     */
    addData(entities) {
        if (!entities) {
            return;
        }
        const entitiesToAdd = [];
        entities.forEach(entity => {
            this.verifyEntityToAdd(entity);
            entitiesToAdd.push(entity);
        });
        entitiesToAdd.forEach(entity => {
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
            this.listenEntityChangeEvent(entity);
        });
        this.notifyCollectionChanged(new Modification(entitiesToAdd, ModifyType.AddData));
    }
    /**
     * 根据主键值获取实体
     */
    getEntityById(identity) {
        if (this.innerEntityMap.has(identity) === false) {
            return null;
        }
        const entity = this.innerEntityMap.get(identity);
        return entity;
    }
    /**
     * 根据路径获取实体
     */
    getEntityByPath(pathArray) {
        const rootEntityId = pathArray[0].split(':')[1];
        let parentNode = this.getEntityById(rootEntityId);
        for (let i = 1; i < pathArray.length && parentNode; i = i + 1) {
            const currentPath = pathArray[i];
            if (parentNode instanceof Entity) {
                // @todo：强识了别冒号
                if (currentPath.indexOf(':') === -1) {
                    parentNode = parentNode[pathArray[i]];
                }
            }
            else {
                parentNode = parentNode.get(pathArray[i].split(':')[1]);
            }
        }
        return parentNode;
    }
    /**
     * id:1/a/id:2/c
     * @param pathArray 路径数组
     */
    getEntitiesByPath(pathArray) {
        const rootEntityId = pathArray[0].split(':')[1];
        let entity = this.getEntityById(rootEntityId);
        for (let i = 1; i < pathArray.length && entity; i += 2) {
            const path = pathArray[i];
            entity = entity[path];
            if (!(entity instanceof EntityList)) {
                throw new Error('路径格式错误');
            }
            if ((i + 1) < pathArray.length) {
                const id = pathArray[i + 1].split(':')[1];
                entity = entity.get(id);
            }
        }
        return entity;
    }
    /**
     * 返回符合指定条件的实体集合
     * @param predicate 条件谓词
     */
    getEntities(predicate) {
        const entities = Array.from(this.innerEntitySet);
        const matchedEntities = entities.filter(predicate);
        return matchedEntities;
    }
    /**
     * 获取全部实体
     */
    getAllEntities() {
        return Array.from(this.innerEntitySet);
    }
    /**
     * 根据主键值删除对应实体
     * @param identity 主键值
     */
    removeEntityById(identity) {
        this.verifyEntityToRemove(identity);
        const entityToRemove = this.innerEntityMap.get(identity);
        this.innerEntityMap.delete(identity);
        this.innerEntitySet.delete(entityToRemove);
        this.notifyCollectionChanged(new Modification([entityToRemove], ModifyType.Remove));
        return entityToRemove;
    }
    removeEntitiesByIds(id) {
    }
    /**
     * 删除符合条件的实体集合
     */
    removeEntities(predicate) {
        const entitiesToRemove = Array.from(this.innerEntitySet).filter(predicate);
        entitiesToRemove.forEach(entityToRemove => {
            this.innerEntityMap.delete(entityToRemove[this.primaryKey]);
            this.innerEntitySet.delete(entityToRemove);
        });
        this.notifyCollectionChanged(new Modification(entitiesToRemove, ModifyType.Remove));
        return entitiesToRemove;
    }
    /**
     * 移除数据（不切换当前行）
     * @param predicate 过滤函数
     */
    removeData(predicate) {
        const entitiesToRemove = Array.from(this.innerEntitySet).filter(predicate);
        entitiesToRemove.forEach(entityToRemove => {
            this.innerEntityMap.delete(entityToRemove[this.primaryKey]);
            this.innerEntitySet.delete(entityToRemove);
        });
        this.notifyCollectionChanged(new Modification(entitiesToRemove, ModifyType.RemoveData));
        return entitiesToRemove;
    }
    /**
     * 重置子表数据
     * @param paths 路径
     * 路径格式 ['id:provinceId','id:cityMDMs','zoneMDMs']
     * @description path参数格式
     * ```json
     * [
     * "id:b5ed23ca-88d9-4377-98ec-92f35c1325f1",
     * "cityMDMs",
     * "id:373706af-622f-4aea-a006-dddbffd7bda3",
     * "zoneMDMs"
     * ]
     * ```
     * @param entities 实体数组
     */
    resetEntities(paths, entities) {
        if (paths[0].indexOf(':') === -1) {
            throw new Error('路径格式错误');
        }
        // paths里面第一个一定是id
        const entityInfo = paths[0].split(':');
        const [entityPrimaryKey, entityId] = entityInfo;
        let entity = null;
        for (const element of this.innerEntitySet) {
            if (element[entityPrimaryKey] === entityId) {
                entity = element;
                break;
            }
        }
        // for (let index = 0; index < this.innerEntitySet; index++) {
        //   const element: T = this.innerEntitySet[index];
        //   if (element[entityPrimaryKey] === entityId) {
        //     entity = element;
        //     break;
        //   }
        // }
        if (!entity) {
            throw new Error(`找不到${entityPrimaryKey}为${entityId}的实体`);
        }
        let data = entity;
        paths.slice(1).forEach(path => {
            data = data[path];
        });
        const entityList = data;
        entityList.clear();
        entityList.loadEntities(entities);
    }
    /**
     * 验证实体是否能够添加
     */
    verifyEntityToAdd(entity) {
        if (this.has(entity[this.primaryKey])) {
            this.innerEntitySet.delete(this.innerEntityMap.get(entity[this.primaryKey]));
            this.innerEntityMap.delete(entity[this.primaryKey]);
            // throw new Error(`The repository already had an item with the save identity of '${entity[this.primaryKey]}'`);
        }
        return true;
    }
    /**
     * 验证实体是否能移除
     */
    verifyEntityToRemove(identity) {
        if (!this.has(identity)) {
            throw new Error(`The entity with identity of '${identity} dose not exsit.'`);
        }
        return true;
    }
    /**
     * 实体集合变更流
     */
    notifyCollectionChanged(modification) {
        this.collectionChanged.next(modification);
    }
    //#region 分页
    /**
     * 设置分页大小
     */
    set pageSize(pageSize) {
        if (typeof (pageSize) !== 'number' || pageSize < 0) {
            throw new Error('Invalid parameter:pageSize');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { pageSize });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        // this.notifyCollectionChanged(new Modification(this.paginationInfo[this.entityTypeName], ModifyType.PaginationInfoChange));
        this.paginationInfo = Object.assign({}, original, { pageSize });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取分页大小
     * @description 如果用户未指定分页大小则默认为0，即获取所有数据
     */
    get pageSize() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.pageSize || 0;
        }
        return 0;
    }
    /**
     * 设置数据总条数
     */
    set totalCount(total) {
        if (typeof (total) !== 'number' || total < 0) {
            throw new Error('Invalid parameter:total');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { total });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        this.paginationInfo = Object.assign({}, original, { total });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取数据总条数
     */
    get totalCount() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.total || 0;
        }
        return 0;
    }
    /**
     * 设置当前页码
     */
    set pageIndex(pageIndex) {
        if (typeof (pageIndex) !== 'number' || pageIndex < 0) {
            throw new Error('Invalid parameter:pageIndex');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { pageIndex });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        this.paginationInfo = Object.assign({}, original, { pageIndex });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取当前页码
     */
    get pageIndex() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.pageIndex || 1;
        }
        return 1;
    }
    /**
     * 更新分页信息
     * @param path 绑定路径
     * @param pageInfo 分页信息
     */
    updatePaginationInfoByPath(path, pageInfo) {
        const original = this.paginationInfo;
        const { pageIndex, pageSize, totalCount: total } = pageInfo;
        const paginationInfo = Object.assign({}, original, { pageIndex, pageSize, total });
        this.setPaginationConfigByPath(path, paginationInfo);
    }
    /**
     * 根据路径获取分页大小
     * @param path 路径
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationInfo;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0).map(item => item.trim());
        let config = this.paginationInfo;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 设置分页信息
     * @param path 路径
     * @param value 值
     */
    setPaginationConfigByPath(path, value) {
        const original = JSON.stringify(this.paginationInfo);
        if (!path || path === '/') {
            this.paginationInfo = value;
        }
        else {
            if (!Array.isArray(path)) {
                path = path.toString().match(/[^/[\]]+/g) || [];
            }
            path.slice(0, -1).reduce((prev, current, index) => Object(prev[current]) === prev[current]
                ? prev[current]
                : prev[current] = Math.abs(path[index + 1]) >> 0 === +path[index + 1]
                    ? []
                    : {}, this.paginationInfo)[path[path.length - 1]] = value;
        }
        if (JSON.stringify(this.paginationInfo) !== original) {
            this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
        }
        return this.paginationInfo;
    }
    //#endregion
    /**
     * 监听实体变更
     */
    listenEntityChangeEvent(entity) {
        if (entity) {
            entity.onValueChanged.subscribe((change) => this.changes.next(change));
        }
    }
}

/*
 * @Author: Witt
 * @Date: 2019-03-07 17:24:38
 * @Last Modified by:   Witt
 * @Last Modified time: 2019-03-11 19:50:38
 */
/**
 * 实体管理类
 */
class EntityManager {
    /**
     * 构造函数
     */
    constructor(entityCollection) {
        this.entityCollection = entityCollection;
        this.entityType = entityCollection.entityType;
    }
    // #region 创建实体相关方法
    /**
     * 创建实体
     */
    createEntity(entityData) {
        const entity = createEntity(this.entityType, entityData);
        return entity;
    }
    /**
     * 批量创建实体
     */
    createEntities(entityListData, entityType) {
        const entities = createEntities(this.entityType, entityListData);
        return entities;
    }
    /**
     * 批量创建下级实体
     * @param fPath fpath
     * @param entityListData 实体数据
     */
    createEntitiesByPath(fPath, entityListData) {
        const subPaths = fPath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fPath}]格式不对`);
        }
        if (entityListData.length < 1) {
            return [];
        }
        let childEntityList;
        let propInfo;
        let propName;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            propName = subPaths[i];
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            const entityType = propInfo ? propInfo.propEntityType : this.entityType;
            propInfo = EntityUtil.getPropInfo(entityType, propName);
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fPath}`);
            }
        }
        const entities = entityListData.map(entityData => {
            return createEntity(propInfo.propEntityType, entityData);
        });
        return entities;
    }
    // #endregion
    // #region 获取实体、实体数组相关方法
    /**
     * 获取path对应的实体
     */
    getEntityByPath(path) {
        const entity = this.getEntityNodeByPath(path);
        return entity;
    }
    /**
     * 获取path对应的实体
     */
    getEntitiesByPath(path) {
        const entityCollectionOrList = this.getEntityNodeByPath(path);
        let entities;
        if (entityCollectionOrList instanceof EntityCollection === true) {
            entities = entityCollectionOrList.toArray();
        }
        else {
            entities = entityCollectionOrList.toArray();
        }
        return entities;
    }
    /**
     * 获取实体节点
     * @param path 节点路径
     */
    getEntityNodeByPath(path) {
        const dataPath = DataPathCreator.createByLongPathFromRoot(path, this);
        let entityNode = this.entityCollection;
        let pathNode = dataPath.head.next;
        while (pathNode) {
            if (pathNode.type === DataPathNodeType.DataId) {
                if (entityNode instanceof EntityCollection === true) {
                    entityNode = entityNode.getEntityById(pathNode.value);
                }
                else {
                    entityNode = entityNode.get(pathNode.value);
                }
            }
            else {
                entityNode = entityNode[pathNode.value];
            }
            if (!entityNode) {
                throw new Error(`找不到${pathNode.value}对应的数据节点`);
            }
            pathNode = pathNode.next;
        }
        return entityNode;
    }
    // #endregion
    // #region 获取、设置属性值
    /**
     * 获取path对应的实体属性值
     */
    getPropValueByPath(path) {
        const propName = path.pop();
        const entity = this.getEntityByPath(path);
        return entity[propName];
    }
    /**
     * 设置path对应实体的属性值
     */
    setPropValueByPath(path, propValue) {
        const propName = path.pop();
        const entity = this.getEntityByPath(path);
        entity[propName] = propValue;
    }
    // #endregion
    // #region 插入实体
    /**
     * 在path对应实体前插入实体
     */
    insertEntityBeforeByPath(fpath) {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前批量插入实体
     */
    insertEntitiesBeforeByPath() {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前插入实体
     */
    insertEntityAfterByPath() {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前批量插入实体
     */
    insertEntitiesAfterByPath() {
        throw new Error('Not Implemented');
    }
    // #endregion
    // #region 追加实体
    /**
     * 在path对应的实体集合中追加1个实体
     */
    // public appendEntityByPath(fpath: string[], entity: Entity): void {
    //   const entityCollectionOrList = this.getEntityNodeByPath(fpath);
    //   if (entityCollectionOrList instanceof EntityCollection === true) {
    //     const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
    //     entityCollection.addEntity(entity);
    //   } else {
    //     const entityList = (entityCollectionOrList as EntityList<Entity>);
    //     entityList.appendEntity(entity);
    //   }
    // }
    /**
     * 根据path获取实体集合
     * @param fpath 路径
     * @param entityData 实体数据
     * @param initialData[可选] 默认值
     */
    appendEntityByPath(fpath, entityData, initialData, isCloned = false) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        let propInfo;
        let propName;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            propName = subPaths[i];
            // todo: EntityCollection重构之后这里无需差异处理
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            const entityType = propInfo ? propInfo.propEntityType : this.entityType;
            propInfo = EntityUtil.getPropInfo(entityType, propName);
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        // const propInfo = EntityUtil.getPropInfo(this.entityType, propName);
        const childEntity = createEntity(propInfo.propEntityType, entityData);
        // 在实体的实例上增加默认值属性，以便在createBindingObject时存放默认值
        if (initialData) {
            EntityUtil.appendInitialData(childEntity, initialData);
        }
        childEntityList.appendNew(childEntity, isCloned);
        return childEntity;
    }
    /**
     * 在指定位置插入实体
     * @param fpath 父路径
     * @param entityData 实体数据
     * @param initialData 初始数据
     * @param position 插入位置
     */
    insertEntityByPath(fpath, entityData, initialData, position) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        let propInfo;
        let propName;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            propName = subPaths[i];
            // todo: EntityCollection重构之后这里无需差异处理
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            const entityType = propInfo ? propInfo.propEntityType : this.entityType;
            propInfo = EntityUtil.getPropInfo(entityType, propName);
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        // const propInfo = EntityUtil.getPropInfo(this.entityType, propName);
        const childEntity = createEntity(propInfo.propEntityType, entityData);
        // 在实体的实例上增加默认值属性，以便在createBindingObject时存放默认值
        if (initialData) {
            EntityUtil.appendInitialData(childEntity, initialData);
        }
        childEntityList.insert(childEntity, position);
        return childEntity;
    }
    /**
     * 在path对应的实体集合中追加多个实体
     */
    appendEntitiesByPath(fpath, entities) {
        const entityCollectionOrList = this.getEntityNodeByPath(fpath);
        if (entityCollectionOrList instanceof EntityCollection === true) {
            const entityCollection = entityCollectionOrList;
            entityCollection.addEntities(entities);
        }
        else {
            const entityList = entityCollectionOrList;
            entityList.appendEntities(entities);
        }
    }
    // #endregion
    // #region 删除实体
    /**
     * 从fapth对应的实体集合中删除id对应的实体
     */
    // public removeEntityByPath(fpath: string[], id: string): void {
    //   const entityCollectionOrList = this.getEntityNodeByPath(fpath);
    //   if (entityCollectionOrList instanceof EntityCollection === true) {
    //     const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
    //     entityCollection.removeEntityById(id);
    //   } else {
    //     const entityList = (entityCollectionOrList as EntityList<Entity>);
    //     entityList.remove(id);
    //   }
    // }
    /**
     * 根据path获取实体集合
     * @param fpath path
     */
    removeEntityByPath(fpath, id) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            const propName = subPaths[i];
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        childEntityList.remove(id);
    }
    /**
     * 从fapth对应的实体集合中删除ids对应的实体
     */
    removeEntitiesByPath(fpath, ids) {
        // const entityCollectionOrList = this.getEntityNodeByPath(fpath);
        // if (entityCollectionOrList instanceof EntityCollection === true) {
        //   const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
        //   entityCollection.removeEntitiesByIds(ids);
        // } else {
        //   const entityList = (entityCollectionOrList as EntityList<Entity>);
        //   entityList.remove(ids);
        // }
        throw new Error('Not Implemented');
    }
    // #endregion
    // #region 清空变更集相关方法
    /**
     * 清空所有实体的变更集
     */
    clearAllEntityChanges() {
        const entities = this.entityCollection.toArray();
        entities.forEach((entity) => {
            entity.changes.splice(0, entity.changes.length);
        });
    }
    resetAllEntityChangeMark() {
        const entities = this.entityCollection.toArray();
        entities.forEach((entity) => {
            entity.hasChange = false;
        });
    }
    /**
     * 清空id指定的实体变更集
     */
    clearEntityChangesById(id) {
        const entity = this.entityCollection.getEntityById(id);
        if (!entity) {
            return;
        }
        entity.changes.splice(0, entity.changes.length);
    }
    /**
     * 清空ids数组中指定的实体的变更集
     */
    clearEntityChangesByIds(ids) {
        if (!ids || ids.length < 0) {
            return;
        }
        ids.forEach((id) => {
            this.clearEntityChangesById(id);
        });
    }
    // #endregion
    // #region 变更集检查相关方法
    /**
     * 检查所有的实体，是否有未提交的变更
     */
    checkAllEntityChanges() {
        const entities = this.entityCollection.toArray();
        const hasChanges = entities.some((entity) => {
            if (entity.changes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        });
        return hasChanges;
    }
    /**
     * 检查id对应的实体，是否有未提交的变更
     */
    checkEntityChangesById(id) {
        const entity = this.entityCollection.getEntityById(id);
        if (!entity) {
            return false;
        }
        return entity.changes.length > 0;
    }
    // #endregion
    // #region 不规范方法，待废弃
    /**
     * 待废弃
     * @deprecated
     */
    clearEntityChangesByArray(idArray) {
        this.clearEntityChangesByIds(idArray);
    }
}

// tslint:disable: no-bitwise
class PaginationManager {
    constructor(entityType, paginationConfig) {
        this.entityType = entityType;
        this.paginationConfig = paginationConfig;
        if (this.paginationConfig === null || this.paginationConfig === undefined) {
            this.paginationConfig = this.getNgListProperties();
        }
        // 兼容老表单，将之前的主表分页信息展开到分页配置根中
        this.expandMainEntityConfig();
        this.deleteMainEntityConfig();
    }
    /**
     * 主表分页信息展开到分页配置根中
     */
    expandMainEntityConfig() {
        const entityName = this.entityType.name;
        if (this.paginationConfig.hasOwnProperty(entityName)) {
            const entityConfig = this.paginationConfig[entityName];
            this.paginationConfig = Object.assign(this.paginationConfig, entityConfig);
        }
    }
    /**
     * 删除主表实体配置信息
     */
    deleteMainEntityConfig() {
        delete this.paginationConfig[this.entityType.name];
    }
    /**
     * 获取分页信息
     */
    get pagination() {
        return this.paginationConfig;
    }
    /**
     * 获取分页信息
     * @param path 路径
     * @param defaultValue 默认值
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationConfig;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0);
        let config = this.paginationConfig;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 设置分页信息
     * @param path 路径
     * @param value 值
     */
    setPaginationConfigByPath(path, value) {
        if (!Array.isArray(path)) {
            path = path.toString().match(/[^/[\]]+/g) || [];
        }
        path.slice(0, -1).reduce((prev, current, index) => Object(prev[current]) === prev[current]
            ? prev[current]
            : prev[current] = Math.abs(path[index + 1]) >> 0 === +path[index + 1]
                ? []
                : {}, this.paginationConfig)[path[path.length - 1]] = value;
        return this.paginationConfig;
    }
    /**
     * 递归获取当前实体的所有NgList属性
     * @param defaultPageSize defaultPageSize
     */
    getNgListProperties(defaultPageSize = 0) {
        const getChilds = (objectType) => {
            const listProperties = FieldMetadataUtil.getNgList(objectType);
            let result = {};
            if (Object.keys(listProperties).length < 1) {
                return result;
            }
            Object.keys(listProperties).forEach(prop => {
                let itemTypeName = listProperties[prop].dataField;
                // 去掉尾部的s
                if (itemTypeName.endsWith('s')) {
                    itemTypeName = itemTypeName.substring(0, itemTypeName.length - 1);
                }
                result[itemTypeName] = {
                    pageSize: defaultPageSize
                };
                const child = getChilds(listProperties[prop].type);
                if (child !== null && Object.keys(child).length > 0) {
                    result = Object.assign({}, result, child);
                }
            });
            return result;
        };
        const childs = getChilds(this.entityType);
        const root = Object.assign({}, { pageSize: defaultPageSize }, childs);
        return root;
    }
}

class DataChangeHistory {
    constructor() {
        this.history = [];
        this.cacheData = [];
    }
    addChange(dataChange) {
        const changeType = DataChangeType[dataChange.changeType];
        this[`on${changeType}Data`](dataChange);
    }
    addChanges(dataChange) {
        dataChange.forEach(change => this.addChange(change));
    }
    clear() {
        this.history.splice(0, this.history.length);
    }
    clearByIds(ids) {
        this.history = this.history.filter(item => {
            if (item.fpath && item.fpath !== '/' && item.fpath.includes('/')) {
                for (const id of ids) {
                    const include = item.fpath.split('/').includes(id);
                    return !include;
                }
            }
            else {
                return !ids.includes(item.dataId);
            }
        });
    }
    isChanged() {
        return this.history.length > 0;
    }
    clearCache() {
        this.cacheData.splice(0, this.cacheData.length);
    }
    getCacheData() {
        return this.cacheData;
    }
    onAddData(dataChange) {
        this.history.push(dataChange);
    }
    onEditData(dataChange) {
        this.cacheData.push(dataChange);
    }
    onAppendData(dataChange) {
        this.history.push(dataChange);
        this.cacheData.push(dataChange);
    }
    onDeleteData(dataChange) {
        const index = this.history.findIndex(item => item.dataId === dataChange.dataId && item.changeType === DataChangeType.Add);
        if (index >= 0) {
            this.history.splice(index, 1);
        }
        else {
            this.history.push(dataChange);
        }
    }
}

/*
 * @Author: Witt
 * @Date: 2018-10-12 15:37:11
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-09-03 19:10:44
 * @todo 待优化问题
 * 1、apiUrl是否应该在基类中，子类中的api如何传递给基类；
 */
class Repository {
    /**
     * 构造函数
     */
    constructor() {
        /**
         * 用户分页配置信息
         */
        this.paginationInfo = null;
    }
    init() {
        this.entityTypeInfo = new DataTypeInfo(this.entityType);
        this.entityCollection = new EntityCollection(this.entityType);
        this.entityCollection.entityTypeInfo = this.entityTypeInfo;
        this.dataChangeHistory = new DataChangeHistory();
    }
    get changes() {
        return this.entityCollection.changes;
    }
    /**
     * 实体主键
     */
    get primaryKey() {
        return this.entityCollection.primaryKey;
    }
    /**
     * 实体变更集合
     */
    get entityCollectionChange() {
        return this.entityCollection.collectionChanged;
    }
    /**
     * 重置状态
     */
    reset() {
        this.entityCollection.clear();
    }
    /**
     * 创建实体
     */
    buildEntity(data) {
        const entity = createEntity(this.entityType, data);
        return entity;
    }
    /**
     * 批量创建实体
     */
    buildEntities(listData) {
        const entities = createEntities(this.entityType, listData);
        return entities;
    }
    /**
     * 初始化分页配置
     * @param config 用户分页配置
     */
    setPaginationConfig(config) {
        this.paginationManager = new PaginationManager(this.entityType, config);
        const { pageSize = 0 } = this.paginationManager.getPaginationConfigByPath('/') || {};
        // tslint:disable-next-line: max-line-length
        this.entityCollection.paginationInfo = Object.assign({ pageSize }, this.entityCollection.paginationInfo, this.paginationManager.pagination);
        // 无需再单独设置一次pageSize，减少一次变更
        // this.entityCollection.pageSize = pageSize;
    }
    /**
     * 设置分页
     */
    setPaginationInfo(paginationInfo) {
        this.paginationInfo = Object.assign({}, this.paginationInfo, paginationInfo);
    }
}

/**
 * 空Repository实现
 */
class DefaultRepository extends Repository {
    constructor() {
        super();
    }
    init() {
        super.init();
        this.entityManager = new EntityManager(this.entityCollection);
    }
}

/**
 * 命令处理装饰器名称
 */
const COMMAND_HANDLER_META = 'CommandHandlerMeta';
/**
 * 命令处理装饰器工厂
 */
function CommandHandlerMeta(options) {
    const decoratorFactory = makeDecorator(COMMAND_HANDLER_META, (handler) => handler);
    return decoratorFactory(options);
}
/**
 * 命令处理扩展装饰器名称
 */
const COMMAND_HANDLER_EXTENDER_META = 'CommandHandlerExtenderMeta';
/**
 * 命令处理扩展装饰器工厂
 */
function CommandHandlerExtenderMeta(options) {
    const decoratorFactory = makeDecorator(COMMAND_HANDLER_EXTENDER_META, (extender) => extender);
    return decoratorFactory(options);
}

/**
 * 任务节点
 */
class TaskNode {
    /**
     * 构造函数
     */
    constructor(name, func) {
        this.name = name;
        this.func = func;
    }
    /**
     * 执行任务函数
     */
    execute(context) {
        const result = this.func(context);
        const result$ = isObservable(result) ? result : of(result);
        return result$;
    }
}

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
const VARIABLE_PARSERS = createInjectionToken('@farris/devkit VARIABLE_PARSERS');

class AppOptions {
}

/*
 * @Author: Witt
 * @Date: 2018-12-29 10:46:01
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-30 17:56:02
 */
/**
 * BindingData管理类
 */
class BindingDataManager {
    /**
     * 构造函数
     */
    constructor() {
        this.bindingDataMap = new Map();
    }
    /**
     * 获取BindingDataMap
     */
    getBindingDataMap() {
        return this.bindingDataMap;
    }
    /**
     * 根据name获取BindingData
     * @return 找不到时返回undefined
     */
    getBindingDataByName(name) {
        return this.bindingDataMap.get(name);
    }
    /**
     * 初始化全局的BindingData
     */
    regBindingData(name, bindingData) {
        this.bindingDataMap.set(name, bindingData);
    }
    /**
     * 是否Repository已经存在
     */
    ifBindingDataExits(name) {
        const bindingData = this.getBindingDataByName(name);
        return bindingData ? true : false;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-29 10:46:01
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-30 18:06:11
 */
/**
 * Repository管理类
 */
class RepositoryManager {
    /**
     * 构造函数
     */
    constructor() {
        this.repositoryMap = new Map();
    }
    /**
     * 注册Repository
     */
    regRepository(name, repository) {
        this.repositoryMap.set(name, repository);
    }
    /**
     * 获取RepositoryMap
     * @internal
     */
    getRepositoryMap() {
        return this.repositoryMap;
    }
    /**
     * 获取Repository数组
     */
    getRepositories() {
        return Array.from(this.repositoryMap.values());
    }
    /**
     * 根据name获取Repository
     */
    getRepositoryByName(name) {
        return this.repositoryMap.get(name);
    }
    /**
     * 是否Repository已经存在
     */
    ifRepositoryExits(name) {
        const repository = this.getRepositoryByName(name);
        return repository ? true : false;
    }
}

/**
 * ViewModelContext管理类
 */
class ViewModelContextManager {
    /**
     * 构造函数
     */
    constructor() {
        this.contextMap = new Map();
        this.contextSet = new Set();
    }
    /**
     * 注册Context
     */
    regContext(viewModelContext) {
        const id = viewModelContext.id;
        if (this.contextMap.has(id) === true) {
            // throw Error(`id为${id}的ViewModelContext已经存在`);
            // 临时处理，方式报错。
            this.unregContext(viewModelContext);
        }
        this.contextMap.set(id, viewModelContext);
        this.contextSet.add(viewModelContext);
    }
    /**
     * 取消注册
     */
    unregContext(context) {
        const id = context.id;
        this.contextMap.delete(id);
        this.contextSet.delete(context);
    }
    /**
     * 获取ContextMap
     */
    getContextMap() {
        return this.contextMap;
    }
    /**
     * 获取全部Context
     */
    getContexts() {
        return Array.from(this.contextSet);
    }
    /**
     * 根据命名控件获取上下文集合
     */
    getContextsByNamespace(namespace) {
        return this.getContexts();
    }
    /**
     * 根据id获取Context
     */
    getContextById(id) {
        const targetContext = this.contextMap.get(id);
        return targetContext;
    }
    /**
     * 获取根Context
     */
    getRootContext() {
        const contexts = this.getContexts();
        const rootContext = contexts.find((context) => {
            return context.parent === null;
        });
        return rootContext;
    }
    /**
     * 获取传入视图模型id的root及root的下一代集合数组
     */
    getRootContextAndPosterityById(viewModelId) {
        const targetContext = this.getContextById(viewModelId);
        const contexts = this.getContexts();
        let contextsGroup = [];
        // 1.找到ROOT
        const RootId = this.getContextsGroupRoot(targetContext);
        // 2.可直接遍历拿到所有直系后代 (目前只有两层结构直接获取下一代)
        contexts.map((context) => {
            if (context.parent && context.parent.id === RootId) {
                contextsGroup.push(context);
            }
        });
        contextsGroup.push(this.getContextById(RootId));
        return contextsGroup;
    }
    getContextsGroupRoot(context) {
        if (context.parent) {
            return this.getContextsGroupRoot(context.parent);
        }
        else {
            return context.id;
        }
    }
}

class Context {
    constructor() {
        /**
         * 上下文变量
         */
        this.params = new Map();
    }
    /**
     * 获取变量
     */
    getParam(key) {
        return this.params.get(key);
    }
    /**
     * 设置变量
     */
    setParam(key, value) {
        this.params.set(key, value);
    }
}

/**
 * 表单模块路径
 */
const VALIDATION_RULE_TOKEN = new InjectionToken('@Farris validation rule');

class AppContext extends Context {
    /**
     * 构造函数
     */
    constructor(injector, eventBus, repositoryManager, bindingDataManager, viewModelContextManager, validationManager = {}, validationRule) {
        super();
        this.injector = injector;
        this.eventBus = eventBus;
        this.repositoryManager = repositoryManager;
        this.bindingDataManager = bindingDataManager;
        this.viewModelContextManager = viewModelContextManager;
        this.validationManager = validationManager;
        this.validationRule = validationRule;
        this.validationRule = injector.get(VALIDATION_RULE_TOKEN, []);
    }
    /**
     * 注册FrameContext
     */
    regViewModelContext(viewModelContext) {
        const repository = viewModelContext.repository;
        const repositoryName = repository.name;
        // Repository
        if (this.repositoryManager.ifRepositoryExits(repositoryName) === false) {
            this.repositoryManager.regRepository(repositoryName, repository);
        }
        // BindingData
        if (this.bindingDataManager.ifBindingDataExits(repositoryName) === false) {
            const bindingData = BindingDataFactory.createFromRepository(repository, '/');
            this.bindingDataManager.regBindingData(repositoryName, bindingData);
        }
        // 考虑路由再次进入的时候，AppContext没有被注销，但Component被再次构造的场景
        this.viewModelContextManager.regContext(viewModelContext);
    }
}

/**
 * 视图模型上下文
 */
class ViewModelContext {
    constructor() {
    }
    init(viewModel) {
        this.innerViewModel = viewModel;
        this.id = this.innerViewModel.id;
        this.appContext = viewModel.injector.get(AppContext);
        this.regToTree();
        this.regToAppContext();
    }
    regToTree() {
        const parentInjector = this.innerViewModel.injector.get(Injector, null, InjectFlags.SkipSelf);
        if (parentInjector) {
            this.parent = parentInjector.get(ViewModelContext, null);
            this.root = this.parent ? this.parent.root : this;
        }
        else {
            this.parent = null;
            this.root = this;
        }
    }
    regToAppContext() {
        this.appContext.regViewModelContext(this);
    }
    get viewModel() {
        return this.innerViewModel;
    }
    get injector() {
        return this.innerViewModel.injector;
    }
    get repository() {
        return this.innerViewModel.repository;
    }
    get bindingData() {
        return this.innerViewModel.bindingData;
    }
    get uiState() {
        return this.innerViewModel.uiState;
    }
    get stateMachine() {
        return this.innerViewModel.stateMachine;
    }
    get form() {
        return this.innerViewModel.form;
    }
    get commandBus() {
        return this.innerViewModel.commandBus;
    }
    get expressionEngineImpl() {
        return this.innerViewModel.expressionEngineImpl;
    }
    get expressionManager() {
        return this.innerViewModel.expressionManager;
    }
    ;
    get expressionResult() {
        return this.innerViewModel.expressionResult;
    }
    ;
    get controlsProxy() {
        return this.innerViewModel.controlsProxy;
    }
    ;
    getVirtualRootFrameContext() {
        let formFrameContext = this;
        // let parent = this.parent;
        // while (parent) {
        //   // 兼容没有重新编译的表单，如果判断parent.namespace存在会导致获取不到root-framecontext
        //   if (parent.namespace === this.namespace) {
        //     formFrameContext = parent;
        //     parent = parent.parent;
        //   } else {
        //     break;
        //   }
        // }
        return formFrameContext;
    }
    /**
     * 注册扩展命令
     */
    registerExtendCommand(commandName, commandHandler) {
        this.viewModel.registerExtendCommand(commandName, commandHandler);
    }
}

class ControlInfo {
}
/**
 * UIState属性元数据名称
 */
const CONTROLSTATE_PROP_META = 'ControlStatePropMeta';
const ɵ0$2 = (obj) => obj;
/**
 * UIState属性元数据装饰器工厂
 */
const ControlStatePropMeta = makePropDecorator(CONTROLSTATE_PROP_META, ɵ0$2);

/**
 * UIState属性元数据名称
 */
const UISTATE_PROP_META = 'UIStatePropMeta';
const ɵ0$3 = (obj) => obj;
/**
 * UIState属性元数据装饰器工厂
 */
const UIStatePropMeta = makePropDecorator(UISTATE_PROP_META, ɵ0$3);

class UIStateMetadataUtil {
    /**
     * 获取NgUIState的属性元数据
     * @param
     * @returns 属性元数据对象
     * @example
     * 返回格式：
     * {
     *    '属性名称': <NgUIStateProperty>{ ...}
     * }
     */
    static getUIFields(target) {
        return MetadataUtil.getPropsMetadatasByName(target, UISTATE_PROP_META);
    }
    static getControlFields(target) {
        return MetadataUtil.getPropsMetadatasByName(target, CONTROLSTATE_PROP_META);
    }
}

/**
 * 命令处理器扩展注入Token
 */
const CONTROL_STATE_INTERCEPTOR_TOKEN = createInjectionToken('@farris/devkit CONTROL_STATE_INTERCEPTOR_TOKEN');
class InitContext {
}
class InterceptContext {
}
class ProcessContext {
}

/**
 * 状态拦截器服务
 */
class ControlStateInterceptorService {
    constructor(injector) {
        this.injector = injector;
        //控件状态拦截器
        this.controlInterceptors = [];
        this.controlInterceptors = this.injector.get(CONTROL_STATE_INTERCEPTOR_TOKEN, null, InjectFlags.Optional);
    }
    init() {
        if (this.result) {
            return this.result;
        }
        const inits = [];
        const initContext = new InitContext();
        const processContext = this.getProcessContext();
        initContext.processContext = this.processContext = processContext;
        for (const controlInterceptor of this.controlInterceptors) {
            if (controlInterceptor.init && typeof controlInterceptor.init === 'function') {
                const initFunc = controlInterceptor.init(initContext);
                const $result = isObservable$1(initFunc) ? initFunc : of(initFunc);
                inits.push($result);
            }
        }
        return this.result = forkJoin(inits).pipe(shareReplay(1));
    }
    intercept(interceptContext) {
        interceptContext.processContext = this.processContext;
        for (const controlInterceptor of this.controlInterceptors) {
            controlInterceptor.intercept(interceptContext);
        }
    }
    getProcessContext() {
        const processContext = new ProcessContext();
        const isInWf = EnvUtil.isInWf();
        processContext.isInWf = isInWf;
        if (isInWf === false) {
            return processContext;
        }
        const iframe = window.parent.document.querySelector('iframe');
        if (!iframe || !iframe.src) {
            return processContext;
        }
        const queryParams = UrlUtil.getParams(iframe.src);
        if (!queryParams) {
            return processContext;
        }
        processContext.uiStateInProcess = queryParams.UIStateInProcess;
        processContext.formConfigId = queryParams.formConfigId;
        return processContext;
    }
}

class ControlStateUpdater {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.controlStateInterceptorService = viewModelContext.injector.get(ControlStateInterceptorService);
    }
    /**
     * 初始化
     * @returns
     */
    init() {
        return this.controlStateInterceptorService.init();
    }
    /**
     * 更新【描述控件状态】的变量
     * @param changes 监听到的变化
     */
    updateControlState(changes) {
        //1.获取【描述控件状态】的变量，并缓存
        if (!this.controlFields) {
            const uiState = this.viewModelContext.uiState;
            this.controlFields = UIStateMetadataUtil.getControlFields(uiState.constructor);
            this.variableNames = Object.keys(this.controlFields);
        }
        //2.更新前事件
        if (!this.beforeUpdate(changes)) {
            return;
        }
        //3.遍历变量，进行更新
        this.variableNames.forEach(variableName => {
            const fieldMetadata = this.controlFields[variableName];
            //遍历默认值
            Object.keys(fieldMetadata.originalValue).forEach(propertyName => {
                //更新
                this.update(changes, fieldMetadata, variableName, propertyName);
            });
        });
    }
    /**
     * 更新前事件
     * @param changes
     * @returns
     */
    beforeUpdate(changes) {
        //1.没有【控件状态变量】，无需更新
        if (!this.variableNames) {
            return false;
        }
        const { lintenerType, change } = changes;
        //2.【控件状态变量】变化时，不做处理。否则会造成循环调用
        if (lintenerType === 'uiState' && this.variableNames.includes(change.field)) {
            return false;
        }
        return true;
    }
    /**
     * 更新
     * @param changes 监听到的变化
     * @param fieldMetadata 变量的元数据
     * @param variableName 变量名
     * @param propertyName 控件的属性名
     * @returns
     */
    update(changes, fieldMetadata, variableName, propertyName) {
        let propertyValue = fieldMetadata.originalValue[propertyName];
        //1.是否需要更新
        if (!this.needUpdate(propertyValue, changes)) {
            return;
        }
        //2.计算原始值
        let value = this.computeOriginalValue(propertyValue);
        //3.拦截器处理
        const interceptContext = new InterceptContext();
        interceptContext.controlState = fieldMetadata;
        interceptContext.value = value;
        interceptContext.type = propertyName;
        interceptContext.viewModelContext = this.viewModelContext;
        if (this.controlStateInterceptorService) {
            this.controlStateInterceptorService.intercept(interceptContext);
        }
        //4.更新状态
        const uiState = this.viewModelContext.uiState;
        if (!uiState[variableName]) {
            uiState[variableName] = {};
        }
        uiState[variableName] = Object.assign({}, uiState[variableName], { [propertyName]: interceptContext.value });
        //5.更新后事件
        this.afterUpdate(propertyName, interceptContext);
    }
    /**
     * 是否需要新
     * @param originalValue
     * @returns
     */
    needUpdate(originalValue, changes) {
        const { type, value } = originalValue;
        const { lintenerType, change } = changes;
        //1.第一次更新全部
        if (lintenerType === 'firstUpdate') {
            return true;
        }
        //2.固定值类型：只在第一次更新，后续不需要更新
        if (type === 'constant') {
            return false;
        }
        //3.value为空，也是固定值,也不需要更新
        if (!value) {
            return false;
        }
        //4.表达式类型：监听到表达式变化，直接更新表达式变量
        if (type === 'expression' && lintenerType === 'expression') {
            return true;
        }
        //5.根据监听到变化的类型判断
        switch (lintenerType) {
            case 'bindingData': {
                if (change && change.path && change.path.length > 0) {
                    if (value.includes(change.path[0])) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                break;
            }
            case 'uiState': {
                if (change && change.field) {
                    if (value.includes(change.field)) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                break;
            }
            case 'stateMachine': {
                if (value.includes('stateMachine')) {
                    return true;
                }
                else {
                    return false;
                }
                break;
            }
            case 'form': {
                if (value.includes('form')) {
                    return true;
                }
                else {
                    return false;
                }
                break;
            }
        }
        return true;
    }
    /**
     * 计算变量的值
     * @param originalValue
     * @returns
     */
    computeOriginalValue(originalValue) {
        let value = originalValue.value;
        const type = originalValue.type;
        if (value && typeof value === 'string' && type !== 'constant') {
            const context = {
                bindingData: this.viewModelContext.bindingData.list.currentItem.toJSON(),
                entityListData: this.viewModelContext.bindingData.getList().toJSON(),
                currentEntityData: this.viewModelContext.bindingData.getObject().toJSON(),
                uiState: this.viewModelContext.uiState,
                form: this.viewModelContext.viewModel.form,
                stateMachine: this.viewModelContext.stateMachine.renderStates,
            };
            return this.eval(value, context);
        }
        return value;
    }
    /**
     * 计算
     * @param expr 变量
     * @param contexts 上下文
     * @returns
     */
    eval(expr, contexts) {
        expr = `return ${expr}`;
        const scopeNames = Object.getOwnPropertyNames(contexts);
        const scopeVariable = `__scope__${new Date().valueOf()}`;
        return new Function(scopeVariable, `
          ${scopeNames.map((key) => `var ${key} = ${scopeVariable}['${key}'];`).join('\r\n')}
          return function () {
            try{  \n${expr}\n }catch(e){console.error(e);}
          };`)(contexts)();
    }
    /**
     * 更新变量后，需要进行的操作
     * @param propertyName
     * @param interceptContext
     */
    afterUpdate(propertyName, interceptContext) {
        //1.必填处理
        if (propertyName === 'required') {
            this.updateRequired(interceptContext);
        }
    }
    /**
     * 更新必填状态
     * @param fieldMetadata
     * @param interceptContext
     * @returns
     */
    updateRequired(interceptContext) {
        const bindingPath = interceptContext.controlState.controlInfo.bindingPath;
        if (!bindingPath) {
            return;
        }
        const form = this.viewModelContext.form;
        const formControl = form.getFormValueByBindPath(bindingPath);
        let form_name = formControl.form_name;
        if (!form_name || Object.keys(form_name).length === 0) {
            return;
        }
        const validators = [{ "type": "required", "constraints": [true], message: '必填' }];
        if (interceptContext.value === true) {
            form.addValidate(formControl.bindingPath, formControl.name);
            form_name.pushValidatorFnforRequired(validators, true);
            form_name.required = true;
        }
        else if (interceptContext.value === false) {
            if (form_name.getValidatorFn() && form_name.getValidatorFn().length >= 1) {
                form_name.required = false;
                //去除必填
                form_name.resetValidatorFnforRequired();
                if (form_name.validationResult && form_name.validationResult.type === 'required') {
                    form_name.validationResult = { passing: true, message: '' };
                }
            }
        }
    }
}

class ControlStateListener {
    constructor(viewModelContext) {
        //监听订阅集合
        this.subscriptionsMap = new Map();
        this.viewModelContext = viewModelContext;
        this.controlStateUpdater = viewModelContext.injector.get(ControlStateUpdater);
        //更新器初始化完成后，注册监听,主动触发一次更新
        this.controlStateUpdater.init().subscribe(res => {
            this.register();
            const changes = {
                lintenerType: 'firstUpdate',
                change: null
            };
            this.controlStateUpdater.updateControlState(changes);
        });
    }
    /**
     *注册监听
     */
    register() {
        this.registerBindingDataLintener();
        this.registerUIStateLintener();
        this.registerStateMachineLintener();
        this.registerFormLintener();
    }
    /**
     * 监听BindingData变化
     */
    registerBindingDataLintener() {
        const stateName = 'bindingData';
        if (this.subscriptionsMap.has(stateName) === false) {
            const subscription = this.viewModelContext.bindingData.changes.subscribe((change) => {
                if (change.type === ChangeType.Load) {
                    return;
                }
                this.controlStateUpdater.updateControlState({
                    lintenerType: 'bindingData',
                    change
                });
            });
            this.subscriptionsMap.set(stateName, subscription);
        }
    }
    /**
     * 监听UIState变化
     */
    registerUIStateLintener() {
        const stateName = 'uiState';
        if (this.subscriptionsMap.has(stateName) === false) {
            const subscription = this.viewModelContext.uiState.changes.subscribe((change) => {
                this.controlStateUpdater.updateControlState({
                    lintenerType: 'uiState',
                    change
                });
            });
            this.subscriptionsMap.set(stateName, subscription);
        }
    }
    /**
     * 监听StateMachine变化
     */
    registerStateMachineLintener() {
        const stateName = 'stateMachine';
        if (this.subscriptionsMap.has(stateName) === false && this.viewModelContext.stateMachine) {
            const subscription = this.viewModelContext.stateMachine.stateChange.subscribe((change) => {
                this.controlStateUpdater.updateControlState({
                    lintenerType: 'stateMachine',
                    change
                });
            });
            this.subscriptionsMap.set(stateName, subscription);
        }
    }
    /**
     * 监听Form变化
     */
    registerFormLintener() {
        const stateName = 'form';
        if (this.subscriptionsMap.has(stateName) === false) {
            const subscription = this.viewModelContext.form.changes.subscribe((change) => {
                if (change && change.type === 'validateFieldsFinished') {
                    this.controlStateUpdater.updateControlState({
                        lintenerType: 'expression',
                        change
                    });
                }
                else {
                    this.controlStateUpdater.updateControlState({
                        lintenerType: 'form',
                        change
                    });
                }
            });
            this.subscriptionsMap.set(stateName, subscription);
        }
    }
}

/*
 * @Author: Witt
 * @Date: 2018-11-17 13:38:23
 * @Last Modified by: Witt
 * @Last Modified time: 2018-11-17 13:38:50
 * @todo：临时删除原有功能，待重构
 */
/**
 * UI状态
 */
class UIState {
    constructor() {
        this.changes = new Subject();
        this.innerData = Object.assign({});
        this._init();
    }
    _init() {
        const construct = this.constructor;
        const uiFields = UIStateMetadataUtil.getUIFields(construct);
        const controlFields = UIStateMetadataUtil.getControlFields(construct);
        this.initializeUIField(uiFields);
        this.initializeControlField(controlFields);
    }
    //注册监听
    config(viewModelContext) {
        const construct = this.constructor;
        const controlFields = UIStateMetadataUtil.getControlFields(construct);
        if (controlFields && Object.keys(controlFields).length > 0) {
            this.controlStateListener = viewModelContext.injector.get(ControlStateListener);
        }
    }
    initializeUIField(uiFieldMetadata) {
        Object.keys(uiFieldMetadata).forEach(propertyName => {
            const fieldMetadata = uiFieldMetadata[propertyName];
            const uiField = fieldMetadata.stateName || propertyName;
            if (delete this[propertyName]) {
                this.defineProperty(propertyName, uiField);
            }
        });
    }
    initializeControlField(controlFieldMetadata) {
        Object.keys(controlFieldMetadata).forEach(propertyName => {
            const fieldMetadata = controlFieldMetadata[propertyName];
            const uiField = fieldMetadata.stateName || propertyName;
            if (delete this[propertyName]) {
                this.defineProperty(propertyName, uiField);
            }
        });
    }
    isExistProperty(propertyName) {
        if (this.innerData.hasOwnProperty(propertyName) || this.hasOwnProperty(propertyName)) {
            return true;
        }
        return false;
    }
    defineProperty(propertyName, field = null) {
        Object.defineProperty(this, propertyName, {
            get: function () {
                return field !== null ? this.innerData[field] : this.innerData[propertyName];
            },
            set: function (value) {
                // 值相同时不触发变更
                const oldValue = field !== null ? this.innerData[field] : this.innerData[propertyName];
                if (oldValue === value) {
                    return;
                }
                if (field !== null) {
                    this.innerData[field] = value;
                }
                else {
                    this.innerData[propertyName] = value;
                }
                this.changes.next({
                    field: propertyName,
                    value: value
                });
            }
        });
    }
    setPropertyValue(propertyName, value) {
        if (propertyName === '' || propertyName === undefined) {
            return;
        }
        if (!this.isExistProperty(propertyName)) {
            this.defineProperty(propertyName);
        }
        this[propertyName] = value;
    }
}

/**
 * --------------------------------------------------------------------------------
 * State相关
 * --------------------------------------------------------------------------------
 */
/**
 * 基本状态：表单的基本状态，通过State的运算确定RenderState的值，进而控制页面控件的状态。
 */
class State {
    /**
     * 构造函数
     * @param name 状态名称
     */
    constructor(name) {
        this.name = name;
    }
}
/**
 * 初始渲染状态
 */
const initialUIState = false;

/**
 * 状态元数据名称
 */
const STATE_PROP_META = 'StatePropMeta';
const ɵ0$4 = (obj) => obj;
/**
 * 页面状态元数据装饰器工厂
 */
const StatePropMeta = makePropDecorator(STATE_PROP_META, ɵ0$4);

/**
 * 组件状态元数据名称
 */
const RENDER_STATE_PROP_META = 'RenderStatePropMeta';
const ɵ0$5 = (obj) => obj;
/**
 * 组件状态元数据工厂
 */
const RenderStatePropMeta = makePropDecorator(RENDER_STATE_PROP_META, ɵ0$5);

/**
 * 动作方法元数据名称
 */
const ACTION_METHOD_META = 'ActionMethodMeta';
const ɵ0$6 = (action) => action;
/**
 * 迁移动作元数据装饰工厂
 */
const ActionMethodMeta = makePropDecorator(ACTION_METHOD_META, ɵ0$6);

/**
 * 状态机上下文
 */
class StateMachineContext {
    /**
     * 构造函数
     * @param stateMachine 状态机实例
     * @param initialState 初始状态
     */
    constructor(stateMachine, initialState) {
        this.stateMachine = stateMachine;
        this.state = initialState.name;
    }
    /**
     * 初始化
     */
    init(frameContext) {
        this.viewModelContext = frameContext;
        this.parser = this.viewModelContext.injector.get(VariableParseService);
        this.stateMachineWatcher = this.stateMachine.stateMachineWatcher;
    }
    /**
     * 状态迁移
     * @param stateName 下一状态的名称
     */
    transitTo(stateName) {
        const nextState = this.stateMachine.states[stateName];
        if (nextState) {
            this.state = nextState.name;
            this.stateMachine.render();
        }
    }
    /**
     * 获取expression对应的UIState值
     * @param expression UIState表达式
     */
    getUIState(expression) {
        if (!expression) {
            return;
        }
        const viewModelContext = this.stateMachineWatcher.getViewModelContext(expression);
        if (!viewModelContext) {
            return;
        }
        this.stateMachineWatcher.subscribeUIStateChange(viewModelContext, expression);
        if (this.parser) {
            const value = this.parser.parse(expression, viewModelContext);
            if (value === null) {
                return null;
            }
            if (typeof value === 'object' && Object.keys(value).length === 0) {
                return null;
            }
            return value;
        }
        else {
            throw new Error('未初始化变量解析器。');
        }
    }
    /**
     * 获取数据的值
     */
    getData(expression) {
        if (!expression) {
            return;
        }
        const viewModelContext = this.stateMachineWatcher.getViewModelContext(expression);
        if (!viewModelContext) {
            return;
        }
        this.stateMachineWatcher.subscribeEntityChange(viewModelContext, expression);
        if (this.parser) {
            const value = this.parser.parse(expression, viewModelContext);
            if (value === null) {
                return null;
            }
            if (typeof value === 'object' && Object.keys(value).length === 0) {
                return null;
            }
            return value;
        }
        else {
            throw new Error('未初始化变量解析器。');
        }
    }
}

/**
 * 状态机事件，监听uistate的变化和entity的变化
 */
class StateMachineWatcher {
    constructor(stateMachine) {
        this.stateMachine = stateMachine;
        /**
         * 所有UIStatePath数组
         */
        this.uiStatePathList = [];
        /**
         * 所有DataStatePath数组
         */
        this.dataStatePathList = [];
        this.viewModelContextAndUIStatePathsMap = new Map();
        this.viewModelContextAndDataStatePathsMap = new Map();
    }
    /**
     * 初始化
     * @param viewModelContext 当前视图上下文
     */
    init(viewModelContext) {
        this.viewModelContext = viewModelContext;
    }
    /**
     * 返回表达式中ViewModelId对应的ViewModelContext
     */
    getViewModelContext(expression) {
        const viewModelId = this.extractPaths(expression).split('/')[1];
        return this.viewModelContext.appContext.viewModelContextManager.getContextById(viewModelId);
    }
    /**
     * 监听UIState变更
     * @param viewModelContext ViewModel上下文
     * @param expression UIState表达式
     */
    subscribeUIStateChange(viewModelContext, expression) {
        const uiStatePath = this.getStatePath(expression);
        if (this.viewModelContextAndUIStatePathsMap.has(viewModelContext) === false) {
            this.viewModelContextAndUIStatePathsMap.set(viewModelContext, this.uiStatePathList);
            viewModelContext.uiState.changes.subscribe((uiStateChange) => {
                const uiStatePathList = this.viewModelContextAndUIStatePathsMap.get(viewModelContext);
                if (uiStateChange.field && uiStatePathList.indexOf(uiStateChange.field) > -1) {
                    this.stateMachine.render();
                }
            });
        }
        if (this.viewModelContextAndUIStatePathsMap.get(viewModelContext).indexOf(uiStatePath) === -1) {
            this.uiStatePathList.push(uiStatePath);
        }
    }
    /**
     * 监听实体变更
     */
    subscribeEntityChange(viewModelContext, expression) {
        if (this.viewModelContextAndDataStatePathsMap.has(viewModelContext) === false) {
            this.viewModelContextAndDataStatePathsMap.set(viewModelContext, this.dataStatePathList);
            viewModelContext.bindingData.changes.subscribe((change) => {
                if (change.type === 'Load' || change.type === 'SelectionChanged') {
                    this.stateMachine.render();
                }
                const dataPathList = this.viewModelContextAndDataStatePathsMap.get(viewModelContext);
                if (change.path.join() && this.isAccordingPath(dataPathList, change.path.join('/'))) {
                    this.stateMachine.render();
                }
            });
        }
        if (this.viewModelContextAndDataStatePathsMap.get(viewModelContext).indexOf(expression) === -1) {
            this.dataStatePathList.push(expression);
        }
    }
    /**
     * 根据表达式获取对应的StatePath（移除了ViewModelId之外的部分）
     * @param expression 变量表达式
     */
    getStatePath(expression) {
        return this.extractPaths(expression).split('/')[2];
    }
    /**
     * 判断是否监听范围内的变更路径
     */
    isAccordingPath(dataStatePaths, dataStatePath) {
        const targetPath = dataStatePaths.find((item) => {
            return item.indexOf(dataStatePath) > -1;
        });
        return targetPath === undefined ? false : true;
    }
    /**
     * 暂时把这个方法放了这个地方，等季老师共用方法调整后，直接引用他的方法，该方法可删除
     * @param expression 变量表达式
     */
    extractPaths(expression) {
        let path;
        const UI_STATE_PATTERN_G = /\{UISTATE~(\S+?)\}/g;
        const DATA_PATTERN_G = /\{DATA~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        const dataVariables = expression.match(DATA_PATTERN_G);
        if (uiStateVariables !== null) {
            const UI_STATE_PATTERN = /\{UISTATE~(\S+?)\}/;
            uiStateVariables.forEach((uiStateVariable) => {
                const pathMatches = uiStateVariable.match(UI_STATE_PATTERN);
                if (pathMatches != null && pathMatches.length === 2) {
                    path = pathMatches[1];
                }
            });
        }
        if (dataVariables !== null) {
            const DATA_PATTERN = /\{DATA~(\S+?)\}/;
            dataVariables.forEach((dataVariable) => {
                const pathMatches = dataVariable.match(DATA_PATTERN);
                if (pathMatches != null && pathMatches.length === 2) {
                    path = pathMatches[1];
                }
            });
        }
        return path;
    }
}

/**
 * 状态机
 */
class StateMachine {
    /**
     * 构造函数
     */
    constructor() {
        this.renderStates = {};
        this.handlePropMetadatas();
        this.stateChange = new BehaviorSubject(false);
        this.context = new StateMachineContext(this, this.initialState);
        this.stateMachineWatcher = new StateMachineWatcher(this);
    }
    /**
     * 初始化状态机
     * @param viewModelContext ViewModel上下文
     * @summary
     * 状态机变更，为了在绑定数据之后执行状态机的操作，把render方法延后执行。
     */
    init(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.context.init(this.viewModelContext);
        this.stateMachineWatcher.init(this.viewModelContext);
        this.render();
    }
    /**
     * 批量处理属性元数据
     */
    handlePropMetadatas() {
        const propsMetadatas = MetadataUtil.getPropsMetadatas(this.constructor);
        // 遍历所有属性装饰器，并调用相应的build方法
        if (propsMetadatas) {
            Object.keys(propsMetadatas).forEach((propName) => {
                const propMetadatas = propsMetadatas[propName];
                propMetadatas.forEach(propMetadata => {
                    this.handlePropMetadata(propName, propMetadata);
                });
            });
        }
        if (!this.initialState) {
            throw new Error('请在StatePropMeta注解中指定状态机的初始状态。');
        }
    }
    /**
     * 处理属性元数据
     */
    handlePropMetadata(propName, propMetadata) {
        const ngMetadataName = propMetadata.ngMetadataName;
        switch (ngMetadataName) {
            case STATE_PROP_META:
                this.buildState(propName, propMetadata);
                break;
            case RENDER_STATE_PROP_META:
                this.buildRenderState(propName, propMetadata);
                break;
            case ACTION_METHOD_META:
                this.buildAction(propName, propMetadata);
                break;
            default:
                break;
        }
    }
    /**
     * 包装State
     * @param stateName 状态名称
     * @param ngState   状态对象
     */
    buildState(stateName, ngState) {
        this.states = this.states || {};
        this[stateName] = new State(stateName);
        this.states[stateName] = this[stateName];
        if (ngState.initialState) {
            this.initialState = this[stateName];
        }
    }
    /**
     * 包装RenderState
     * @param renderStateName 渲染状态名称
     * @param ngRenderState   渲染状态元数据
     */
    buildRenderState(renderStateName, ngRenderState) {
        this.renderStates = this.renderStates || {};
        this[renderStateName] = initialUIState;
        this.renderStates[renderStateName] = this[renderStateName];
        // 将renderState上指定的render加入到renders中
        this.renders = this.renders || {};
        this.renders[renderStateName] = ngRenderState.render;
    }
    /**
     * 包装Action
     * @param actionName 动作名称
     * @param ngAction 动作元数据
     */
    buildAction(actionName, ngAction) {
        this[actionName] = () => {
            const nextStateName = ngAction.transitTo;
            const nextState = this.states[nextStateName];
            this.context.transitTo(nextState.name);
            this.render();
        };
    }
    /**
     * 重新计算所有渲染状态的值
     * @sumamry
     * 当 state切换的时候，调用遍历所有的render方法，更改renderState
     */
    render() {
        for (const renderStateName in this.renderStates) {
            if (this.renderStates.hasOwnProperty(renderStateName) === false) {
                continue;
            }
            // 执行RenderState的render方法，更新renderState
            const stateRender = this.renders[renderStateName];
            if (!stateRender) {
                continue;
            }
            this.renderStates[renderStateName] = stateRender(this.context);
            this[renderStateName] = this.renderStates[renderStateName];
        }
        this.stateChange.next(this.context.state);
    }
}

var BindingType;
(function (BindingType) {
    /**
     * 实体状态
     */
    BindingType["EntityState"] = "EntityState";
    /**
     * UI状态
     */
    BindingType["UIState"] = "UIState";
})(BindingType || (BindingType = {}));

/**
 * 日期字符串转换器
 */
class DateStringValueConverter {
    convertFrom(dateObj) {
        return DateUtil.formatISO(dateObj);
    }
    convertTo(dateString) {
        return DateUtil.parse(dateString);
    }
}
/**
 * 数组字符串转换器
 */
class ArrayStringValueConverter {
    convertFrom(arr) {
        return arr.join(',');
    }
    convertTo(arrString) {
        return arrString.split(',');
    }
}

/**
 * Entity值访问器
 */
class EntityBindingValueAccessor {
    constructor(bindingData, bindingPath, valueConverter) {
        this.bindingData = bindingData;
        this.bindingPathSegments = this.getBindingPathSegments(bindingPath);
        this.valueConverter = valueConverter;
    }
    getValue() {
        const stateValue = this.bindingData.getValue(this.bindingPathSegments);
        const controlValue = this.valueConverter ? this.valueConverter.convertTo(stateValue) : stateValue;
        return controlValue;
    }
    setValue(controlValue) {
        const oldStateValue = this.bindingData.getValue(this.bindingPathSegments);
        const stateValue = this.valueConverter ? this.valueConverter.convertFrom(controlValue) : controlValue;
        if (this.isDateConverter(this.valueConverter) === true) {
            if (DateUtil.isEqual(oldStateValue, stateValue) === true) {
                return;
            }
        }
        this.bindingData.setValue(this.bindingPathSegments, stateValue, true, true);
    }
    getBindingPathSegments(bindingPath) {
        const parentPathSegments = BindingPathConverter.toBindingPathArray(this.bindingData.bindingPath);
        bindingPath = bindingPath.replace(/\./g, '\/');
        const bindingPathSegments = BindingPathConverter.toBindingPathArray(bindingPath);
        return parentPathSegments.concat(bindingPathSegments);
    }
    /**
     * 是否是DateConverter
     */
    isDateConverter(converter) {
        let isDateConverter = false;
        if (converter && converter.hasOwnProperty('format') === true) {
            isDateConverter = true;
        }
        return isDateConverter;
    }
}
/**
 * UIState值访问器
 */
class UIStateBindingValueAccessor {
    constructor(uiState, bindingPath, valueConverter) {
        this.uiState = uiState;
        this.bindingPathSegments = this.getUiStateBindingPath(bindingPath);
    }
    getValue() {
        let stateValue;
        let obj = this.uiState;
        this.bindingPathSegments.forEach(item => {
            stateValue = obj[item];
            obj = stateValue;
        });
        return stateValue;
    }
    setValue(controlValue) {
        const length = this.bindingPathSegments.length;
        if (length === 1) {
            this.uiState.setPropertyValue(this.bindingPathSegments, controlValue);
        }
        else {
            let obj;
            for (let i = length - 1; i > 0; i--) {
                obj = { [this.bindingPathSegments[i]]: controlValue };
                controlValue = obj;
            }
            this.uiState.setPropertyValue(this.bindingPathSegments[0], obj);
        }
    }
    // UISTATE获取路径
    getUiStateBindingPath(bindingPath) {
        const index = bindingPath.search('/');
        if (index !== -1) {
            return bindingPath.split('/');
        }
        else {
            return [bindingPath];
        }
    }
}
/**
 * 绑定值访问器工厂
 */
class BindingValueAccessorFactory {
    static create(bindingType, bindingBindingPath, bindingValueConverter, viewModelContext) {
        switch (bindingType) {
            case BindingType.EntityState:
                const bindingData = viewModelContext.bindingData;
                return new EntityBindingValueAccessor(bindingData, bindingBindingPath, bindingValueConverter);
            case BindingType.UIState:
                const uiState = viewModelContext.uiState;
                return new UIStateBindingValueAccessor(uiState, bindingBindingPath, bindingValueConverter);
            default:
                throw new Error('Not Supported');
        }
    }
}

/**
 * FormControl元数据名称
 */
const FORM_CONTROL_PROP_META = 'FormControlPropMeta';
const ɵ0$7 = (obj) => obj;
/**
 * FormControl装饰器工厂
 */
const FormControlPropMeta = makePropDecorator(FORM_CONTROL_PROP_META, ɵ0$7);

/**
 * 验证器工厂
 */
class ValidatorFactory {
    /**
     * 创建适配器
     */
    static create(validRules) {
        let validatorFn = [];
        if (Array.isArray(validRules) && validRules.length > 1) {
            validRules.forEach((validRule) => {
                validatorFn.push(this.initValidRuleFn(validRule));
            });
        }
        else if (Array.isArray(validRules) && validRules.length === 1) {
            validatorFn.push(this.initValidRuleFn(validRules[0]));
        }
        else {
            validatorFn.push(this.initValidRuleFn(validRules));
        }
        return validatorFn;
    }
    static initValidRuleFn(validRule) {
        const { type, constraints, message } = validRule;
        switch (type) {
            case 'required':
                return (v, context) => {
                    if (constraints[0] !== true) {
                        const parseService = context.injector.get(VariableParseService);
                        const parsedArgs = parseService.parse(constraints[0], context);
                        if (parsedArgs === true) {
                            if (null === v || undefined === v || '' === v) {
                                return { type, passing: false, message: message || '必填' };
                            }
                            else {
                                return { type, passing: true, message: '' };
                            }
                        }
                    }
                    if (constraints[0] === true) {
                        if (null === v || undefined === v || '' === v) {
                            return { type, passing: false, message: message || '必填' };
                        }
                        else {
                            return { type, passing: true, message: '' };
                        }
                    }
                    return { type, passing: true, message: '' };
                };
            case 'NumberMaxValue':
            case 'numberMaxValue':
                return (v) => {
                    if (typeof v !== 'number') {
                        return { passing: true, message: '' };
                    }
                    if (constraints[0] || 0 == constraints[0]) {
                        if (v <= parseFloat(constraints[0])) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值不能大于${constraints[0]}` };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'NumberMinValue':
            case 'numberMinValue':
                return (v) => {
                    if (typeof v !== 'number') {
                        return { passing: true, message: '' };
                    }
                    if (constraints[0] || 0 == constraints[0]) {
                        if (v >= parseFloat(constraints[0])) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值不能小于${constraints[0]}` };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'DateMaxValue':
            case 'dateMaxValue':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: true, message: '' };
                    }
                    if (constraints[0]) {
                        let condition = constraints[0];
                        if (condition.length == 21) {
                            condition = condition.slice(1, 20);
                        }
                        if (DateUtil.isBefore(v, condition) || DateUtil.isSame(v, condition)) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入日期不能大于${condition}` };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'DateMinValue':
            case 'dateMinValue':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: true, message: '' };
                    }
                    if (constraints[0]) {
                        let condition = constraints[0];
                        if (condition.length == 21) {
                            condition = condition.slice(1, 20);
                        }
                        if (DateUtil.isAfter(v, condition) || DateUtil.isSame(v, condition)) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入日期不能小于${condition}` };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'StringMaxLength':
            case 'stringMaxLength':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: true, message: '' };
                    }
                    if (constraints[0]) {
                        if (v.length <= constraints[0]) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值长度不能大于${constraints[0]}` };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'StringMinLength':
            case 'stringMinLength':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: true, message: '' };
                    }
                    if (constraints[0]) {
                        if (v.length >= constraints[0]) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值长度不能小于${constraints[0]}` };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'regex':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: true, message: '' };
                    }
                    let constraintsTemp = [];
                    if (typeof constraints[0] === 'string') {
                        constraintsTemp = constraints[0].split(',');
                    }
                    for (let i = 0; i < constraintsTemp.length; i++) {
                        if (constraintsTemp[i] === '') {
                            return;
                        }
                        const re = new RegExp(constraintsTemp[i]);
                        if (re.test(v)) {
                            return { passing: false, message: message || `存在不可输入项${constraintsTemp[i]}` };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'regexp':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: true, message: '' };
                    }
                    const re = new RegExp(constraints[0]);
                    if (!re.test(v)) {
                        return { passing: false, message: message || `请输入正确格式` };
                    }
                    return { passing: true, message: '' };
                };
            case 'mobile':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: false, message: message || `请输入正确的手机号格式` };
                    }
                    const regexStr = constraints[0] === true ? /^1[0-9]{10}$/ : constraints[0];
                    const re = new RegExp(regexStr);
                    if (!re.test(v)) {
                        return { passing: false, message: message || `请输入正确的手机号格式` };
                    }
                    else {
                        return { passing: true, message: '' };
                    }
                };
            case 'email':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: false, message: message || `请输入正确的邮箱格式` };
                    }
                    const regexStr = constraints[0] === true ? /^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/ : constraints[0];
                    const re = new RegExp(regexStr);
                    if (!re.test(v)) {
                        return { passing: false, message: message || `请输入正确的邮箱格式` };
                    }
                    else {
                        return { passing: true, message: '' };
                    }
                };
            case 'idCard':
                return (v) => {
                    if (v === null || v === undefined || v === '') {
                        return { passing: false, message: message || `请输入正确的身份证格式` };
                    }
                    const regexStr = constraints[0] === true ? /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/ : constraints[0];
                    const re = new RegExp(regexStr);
                    if (!re.test(v)) {
                        return { passing: false, message: message || `请输入正确的身份证格式` };
                    }
                    else {
                        return { passing: true, message: '' };
                    }
                };
            case 'customFunction':
                return (v, context) => {
                    if (typeof constraints[0] === 'function') {
                        const message = constraints[0](v, context);
                        if (!message) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message };
                        }
                    }
                    return { passing: true, message: '' };
                };
            case 'expression':
                return (value, viewModelContext, options = {}) => {
                    const result = viewModelContext.expressionManager.validate(constraints[0], options);
                    if (result === false) {
                        return { passing: false, message };
                    }
                    else {
                        return { passing: true, message: '' };
                    }
                };
            case 'requiredExpression':
                return (v, viewModelContext, options = {}) => {
                    const result = viewModelContext.expressionManager.validate(constraints[0], options);
                    if (result === true) {
                        if (null === v || undefined === v || '' === v) {
                            return { type, passing: false, message: message || '必填' };
                        }
                        else {
                            return { type, passing: true, message: '' };
                        }
                    }
                    else {
                        return { passing: true, message: '' };
                    }
                };
            case 'asyncCustomFunction':
                return (v, context) => {
                    if (typeof constraints[0] === 'function') {
                        const $message = from(constraints[0](v, context));
                        return $message.pipe(switchMap((message) => {
                            if (!message) {
                                return of({ passing: true, message: '' });
                            }
                            else {
                                return of({ passing: false, message });
                            }
                        }));
                    }
                    return { passing: true, message: '' };
                };
            default:
                return () => {
                    return { passing: true, message: '' };
                };
        }
    }
    /**
     * 支持异步自定义函数
     * 遍历生成的校验方法对当前值进行校验，当发现错误就返回校验结果
     * 遍历完成没有错误则返回校验通过结果
     * @param validatorFn 校验方法
     * @param value 当前值
     */
    static executeValidator(validatorFn, value, context, options) {
        let validationResult = of({ passing: true, message: '' });
        for (let i = 0; i < validatorFn.length; i++) {
            let result = validatorFn[i](value, context, options);
            if (isObservable(result)) {
                validationResult = result;
                break;
            }
            if (result['passing'] === false) {
                return of(result);
            }
        }
        return validationResult;
    }
    /**
     * 不支持异步自定义函数
     * 遍历生成的校验方法对当前值进行校验，当发现错误就返回校验结果
     * 遍历完成没有错误则返回校验通过结果
     * @param validatorFn 校验方法
     * @param value 当前值
     */
    static noSupportAsynExecuteValidator(validatorFn, value, context, options) {
        for (let i = 0; i < validatorFn.length; i++) {
            let validationResult = validatorFn[i](value, context, options);
            if (isObservable(validationResult)) {
                break;
            }
            if (validationResult['passing'] === false) {
                return validationResult;
            }
        }
        return { passing: true, message: '' };
    }
}

/**
 * FormControl定义
 */
class FormControl {
    constructor(config, viewModelContext) {
        this.validatorFn = [];
        this.required = false;
        this.requiredExpressionFlag = false;
        this.validateExpressionFlag = false;
        this.readonly = false;
        this.visible = true;
        // 初始验证规则
        this.validRules = [];
        // 记忆验证表达式的规则
        this.validRules_validates = [];
        this.valueAccessor = BindingValueAccessorFactory.create(config.bindingType, config.bindingPath, config.valueConverter, viewModelContext);
        this.validRules = [];
        if (config.validRules) {
            this.validRules = config.validRules;
            this.setValidatorFn(config.validRules);
        }
    }
    get value() {
        return this.valueAccessor.getValue();
    }
    set value(val) {
        this.valueAccessor.setValue(val);
    }
    getValidRules() {
        return this.validRules;
    }
    setValidatorFn(validRules) {
        this.validatorFn = ValidatorFactory.create(validRules);
    }
    pushValidatorFnforValidate(validRules, flag) {
        if (flag && this.validateExpressionFlag) {
            return;
        }
        this.validateExpressionFlag = flag;
        this.validRules_validates = validRules;
        this.validatorFn = this.validatorFn.concat(ValidatorFactory.create(validRules));
    }
    pushValidatorFnforRequired(validRules, flag) {
        if (flag && this.requiredExpressionFlag) {
            return;
        }
        this.requiredExpressionFlag = flag;
        this.validatorFn = this.validatorFn.concat(ValidatorFactory.create(validRules));
    }
    resetValidatorFnforRequired() {
        this.requiredExpressionFlag = false;
        this.validatorFn = ValidatorFactory.create(this.validRules.concat(this.validRules_validates));
    }
    getValidatorFn() {
        return this.validatorFn;
    }
}

/**
 * Form抽象类
 */
class Form {
    /**
     * 构造函数
     */
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.formControlConfigs = [];
        this.validateformControls = [];
        this.validateformControlPathMap = new Map;
        this.changes = new Subject();
    }
    /**
     * 初始化
     */
    init() {
        this.collectMetadatas();
        this.createFormControls();
    }
    /**
     * 使用不包含绝对路径的/或者/子表/的路径信息获取对应的formControlConfig的name属性与bindingPath并且返回该路径的formControl
     * @param path 路径信息
     * @returns
     */
    getFormValueByBindPath(path) {
        let formControl = {
            form_name: {},
            name: '',
            bindingPath: ''
        };
        path = path.replace(/\//g, '.');
        if (this.formControlConfigs.length === 0)
            return formControl;
        this.formControlConfigs.forEach((formControlConfig) => {
            if (formControlConfig.bindingPath === path) {
                formControl.form_name = this[formControlConfig.name];
                formControl.name = formControlConfig.name;
                formControl.bindingPath = formControlConfig.bindingPath;
            }
        });
        return formControl;
    }
    /**
     *
     * @returns 获取当前表单上的存在校验字段的集合
     */
    getValidateformControls() {
        return this.validateformControls;
    }
    setValidateformControls(name) {
        if (this.validateformControls && this.validateformControls.length === 0) {
            this.validateformControls.push(name);
        }
        if (this.validateformControls && this.validateformControls.length >= 1) {
            const index = this.validateformControls.findIndex(item => item == name);
            if (index === -1) {
                this.validateformControls.push(name);
            }
        }
        if (!Array.isArray(this.validateformControls)) {
            this.validateformControls = [name];
        }
    }
    getValidateformControlPathMap() {
        return this.validateformControlPathMap;
    }
    setValidateformControlPathMap(name, value) {
        if (!this.validateformControlPathMap.has(name)) {
            this.validateformControlPathMap.set(name, value);
        }
    }
    /**
     * 使用formControlConfig的bindingPath路径信息与对应formControlConfig的name信息储存起来作为验证信息在form上的记录
     * @param path formControlConfig的bindingPath路径信息
     * @param name 对应formContro的name信息
     */
    addValidate(path, name) {
        let bindingPath = this.viewModelContext.bindingData.bindingPath.slice(1).replace(/\//g, '.');
        if (bindingPath) {
            bindingPath = bindingPath + '.';
        }
        ;
        this.setValidateformControlPathMap(bindingPath + path, name);
        this.setValidateformControls(name);
    }
    /**
     * 全部校验
     *  formControlConfigs 上所有的formControl的存在方法调用一遍 将错误信息集中返回
     */
    validateFields() {
        let validationResult = [];
        if (this.validateformControls.length === 0) {
            return validationResult;
        }
        this.validateformControls.forEach((formControl) => {
            const result$ = ValidatorFactory.executeValidator(this[formControl]['validatorFn'], this[formControl]['value'], this.viewModelContext).pipe(tap((message) => {
                this[formControl]['validationResult'] = message;
                !message['passing'] && this.changes.next({ type: 'validateFieldsFinished' });
            }));
            validationResult.push(result$);
        });
        return validationResult;
    }
    /**
     * 不支持自定义异步全部校验
     *  formControlConfigs 上所有的formControl的存在方法调用一遍 将错误信息集中返回
     */
    noSupportAsynValidateFields() {
        let validationResult = [];
        if (this.validateformControls.length === 0) {
            return validationResult;
        }
        this.validateformControls.forEach((formControl) => {
            if (!this[formControl]['validationResult']) {
                this[formControl]['validationResult'] = ValidatorFactory.noSupportAsynExecuteValidator(this[formControl]['validatorFn'], this[formControl]['value'], this.viewModelContext);
            }
            !this[formControl]['validationResult'].passing && validationResult.push(this[formControl]);
        });
        this.changes.next({ type: 'validateFieldsFinished' });
        return validationResult;
    }
    /**
     * 获取某一个得校验错误信息
     * @param name 属性名称
     */
    getFieldError(name) {
        if (this.validateformControls.length === 0) {
            return {};
        }
        const index = this.validateformControls.findIndex((item) => {
            return item === name;
        });
        if (index === -1) {
            return {};
        }
        else {
            const result$ = ValidatorFactory.executeValidator(this[name]['validatorFn'], this[name]['value'], this.viewModelContext).pipe(tap((message) => {
                this[name]['validationResult'] = message;
                !message['passing'] && this.changes.next({ type: 'validateFieldsFinished' });
            }));
            return result$;
        }
    }
    /**
   * 根据form元数据中的path获取某一个得校验错误信息
   * @param path 属性名称数组
   */
    getFieldErrorByPath(path) {
        if (this.validateformControls.length === 0) {
            return {};
        }
        let pathName = path[0];
        if (path && path.length >= 2) {
            pathName = path.join('.');
        }
        const index = this.validateformControlPathMap.has(pathName);
        if (!index) {
            return {};
        }
        else {
            ValidatorFactory.executeValidator(this[this.validateformControlPathMap.get(pathName)]['validatorFn'], this[this.validateformControlPathMap.get(pathName)]['value'], this.viewModelContext).subscribe((message) => {
                this[this.validateformControlPathMap.get(pathName)]['validationResult'] = message;
                this.changes.next({ type: 'validateFieldsFinished', value: this.validateformControlPathMap.get(pathName) });
            });
            return this[this.validateformControlPathMap.get(pathName)]['validationResult'];
        }
    }
    /**
     * 清除一组字段验证状态
     * @param fields 字段的数组
     */
    resetFieldsValidate(fields) {
        if (this.validateformControls.length === 0) {
            return true;
        }
        else {
            if (fields && fields.length > 0) {
                const sb = new Set(fields);
                // 交集
                const intersect = this.validateformControls.filter(x => sb.has(x));
                // 遍历清空所有校验结果数据
                intersect.forEach(item => {
                    this[item]['validationResult'] = undefined;
                });
            }
            else {
                // 没传数据全部清除
                this.validateformControls.forEach(item => {
                    this[item]['validationResult'] = undefined;
                });
            }
            this.changes.next({ type: 'validateFieldsFinished' });
        }
    }
    /**
     * 创建FormControls
     */
    createFormControls() {
        this.formControlConfigs.forEach((formControlConfig) => {
            const name = formControlConfig.name;
            const formControl = new FormControl(formControlConfig, this.viewModelContext);
            this[name] = formControl;
        });
    }
    /**
     * 收集元数据
     */
    collectMetadatas() {
        const formControlMetadatas = MetadataUtil.getPropsMetadatasByName(this.constructor, FORM_CONTROL_PROP_META);
        let bindingPath = this.viewModelContext.bindingData.bindingPath.slice(1).replace(/\//g, '.');
        const validationManager = this.viewModelContext.appContext['validationManager'];
        if (bindingPath) {
            bindingPath = bindingPath + '.';
        }
        ;
        Object.keys(formControlMetadatas).forEach((name) => {
            const formControlMetadata = formControlMetadatas[name];
            let validRules = null;
            if (formControlMetadata.validRules) {
                this.validateformControls.push(name);
                this.validateformControlPathMap.set(bindingPath + formControlMetadata.bindingPath, name);
                validRules = formControlMetadata.validRules;
            }
            const key = ('/' + bindingPath + formControlMetadata.bindingPath).replace(/\./g, '/');
            if (validationManager[key]) {
                if (!validRules) {
                    this.validateformControls.push(name);
                    this.validateformControlPathMap.set(bindingPath + formControlMetadata.bindingPath, name);
                    validRules = Object.values(validationManager[key]);
                }
                else {
                    validRules = validRules.concat(Object.values(validationManager[key]));
                }
            }
            const formControlConfig = {
                name: name,
                bindingType: formControlMetadata.bindingType,
                bindingPath: formControlMetadata.bindingPath,
                valueConverter: formControlMetadata.valueConverter,
                valueChanging: formControlMetadata.valueChanging,
                valueChanged: formControlMetadata.valueChanged,
                validRules: validRules
            };
            this.formControlConfigs.push(formControlConfig);
        });
    }
    getEntityValueChangingListeners() {
        const listeners = {};
        this.formControlConfigs.forEach((formControl) => {
            if (formControl.valueChanging) {
                listeners[formControl.bindingPath] = formControl.valueChanging;
            }
        });
        return listeners;
    }
    getEntityValueChangedListeners() {
        const listeners = {};
        this.formControlConfigs.forEach((formControl) => {
            if (formControl.valueChanged) {
                listeners[formControl.bindingPath] = formControl.valueChanged;
            }
        });
        return listeners;
    }
}

/**
 * 命令装饰器名称
 */
const COMMAND_METHOD_META = 'CommandMethodMeta';
const ɵ0$8 = (obj) => obj;
/**
 * 命令装饰器工厂
 */
const CommandMethodMeta = makePropDecorator(COMMAND_METHOD_META, ɵ0$8);

const RESOLVER_TOKEN = new InjectionToken('@farris_resolver_token');
const ENTITY_TEMPLATE = 'ENTITY~';
const STATE_TEMPLATE = 'STATE~';
const GROUP_FUNCTIONS = ['SumByProp', 'CountByProp', 'AvgByProp', 'MaxByProp', 'MinByProp', 'IsExistRecord', 'ListContains', 'ListGreaterThan', 'ListLessThan', 'ListStartWith', 'ListEndWith'];

class ResolverRegistry {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.resolvers = this.viewModelContext.injector.get(RESOLVER_TOKEN, []);
    }
}

class EntityDependencyResolver {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.repository = this.viewModelContext.repository;
        this.entityTypeInfo = this.repository.entityTypeInfo;
    }
    /**
     * 解析用户表达式中的实体依赖
     * @param expr 用户配置的完整表达式
     * @returns
     */
    resolve(expr) {
        const groupFunctionDependencies = ExpressionUtil.getGroupFunctionDependency(expr, this.repository.entityTypeInfo);
        const entityDependencies = this.getEntityDependency(expr);
        // 去除错误的到子表的依赖
        if (groupFunctionDependencies && groupFunctionDependencies.length > 0 && entityDependencies && entityDependencies.length > 0) {
            groupFunctionDependencies.forEach((dep) => {
                const index = entityDependencies.findIndex(item => dep.startsWith(item));
                if (index !== -1) {
                    entityDependencies.splice(index, 1);
                }
            });
        }
        // 去重
        const merged = [...groupFunctionDependencies, ...entityDependencies];
        const deps = [...new Set(merged)];
        return deps;
    }
    /**
     * 获取合法的实体属性表达式
     * @param entityPropertyExpression 实体属性表达式
     * @returns
     */
    getValidEntityPropertyExpression(entityPropertyExpression) {
        const propPaths = entityPropertyExpression.split('.');
        let propInfo = null;
        try {
            propInfo = this.entityTypeInfo.getPropInfoByPath(propPaths);
        }
        catch (e) { }
        if (!propInfo) {
            if (propPaths.length > 1) {
                propPaths.pop();
                return this.getValidEntityPropertyExpression(propPaths.join('.'));
            }
            else {
                return null;
            }
        }
        else {
            return entityPropertyExpression.split('.');
        }
    }
    /**
     * 获取所有实体依赖
     * @param expr 表达式字符串
     * @returns
     */
    getEntityDependency(expr) {
        const deps = [];
        if (this.entityTypeInfo) {
            // 使用正则匹配出所有实体
            const regex = new RegExp(`[\\'\\"]?\\s*(${this.entityTypeInfo.entityInfo.nodeCode}|${this.entityTypeInfo.entityInfo.originalCode})[\\.\\[\\]a-zA-Z0-9_]+\\s*[\\'\\"]?`, 'g');
            const entityPropertyExpressions = expr.match(regex);
            if (Array.isArray(entityPropertyExpressions) && entityPropertyExpressions.length > 0) {
                // 解析出所有实体相关的字符串，以主实体名字开头，包含主实体属性或子表
                entityPropertyExpressions.forEach((item) => {
                    if (item.indexOf('.') === -1) {
                        console.warn(`无效的实体表达式:${item}`);
                        return;
                    }
                    // 去空格
                    item = item.trim().replace(/\"/g, '');
                    const paths = ExpressionUtil.convertToNodeCode(item, this.repository.entityTypeInfo);
                    item = paths.join('.');
                    // 截去主实体及点
                    item = item.substr(item.indexOf('.') + 1);
                    const dep = this.getValidEntityPropertyExpression(item);
                    if (dep && Array.isArray(dep) && dep.length > 0) {
                        // 此处必须加上主实体的名字来区分依赖的是实体还是其他类型的数据
                        dep.splice(0, 0, ENTITY_TEMPLATE);
                        deps.push(dep.join('/'));
                    }
                });
            }
        }
        else {
            console.warn(`获取实体类型信息失败，请重新编译改表单。`);
        }
        return deps;
    }
}

const CONTEXT_FUNCTIONS = ['GetContextParameter', 'GetSessionValue'];
class StateDependencyResolver {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
    }
    resolve(expr) {
        const deps = [];
        const regex = new RegExp(`DefaultFunction\\.(${CONTEXT_FUNCTIONS.join('|')})\\s*\\([^\\r\\n\\)]*\\)`, 'g');
        const contextFunctions = expr.match(regex);
        if (contextFunctions && contextFunctions.length > 0) {
            // todo: 使用正则匹配时可能会因为参数中有逗号导致问题，后续使用ast解析
            const argumentsRegex = /\(([^\r\n\)]*)\)/;
            contextFunctions.forEach((groupFunction) => {
                const argumentMatchResult = groupFunction.match(argumentsRegex);
                if (argumentMatchResult.length === 2) {
                    const argument = argumentMatchResult[1].trim().replace(/\"/g, '');
                    const dep = ['STATE~'];
                    dep.push(argument);
                    deps.push(dep.join('/'));
                }
            });
        }
        return deps;
    }
}

/**
 * 用户自定义参数解析器
 */
class CommentDependencyResolver {
    resolve(expr) {
        const dependencies = [];
        if (!expr || expr.length < 1) {
            return dependencies;
        }
        const defineRegex = /\/\*\*\s*__define__\((.*)\)\s*\*\//;
        const defineMatchArray = expr.match(defineRegex);
        if (defineMatchArray && defineMatchArray.length === 2) {
            const defineString = defineMatchArray[1].trim();
            let defineObject = null;
            try {
                defineObject = JSON.parse(defineString);
            }
            catch (e) {
                console.warn(`自定义依赖解析失败：${defineString}`);
            }
            if (defineObject && defineObject.hasOwnProperty('deps') && Array.isArray(defineObject['deps'])) {
                dependencies.push(...defineObject['deps']);
            }
        }
        return dependencies;
    }
}

class ResolveService {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.resolverRegistry = this.viewModelContext.injector.get(ResolverRegistry);
    }
    resolve(expression) {
        const deps = [];
        if (!this.resolverRegistry || !this.resolverRegistry.resolvers || this.resolverRegistry.resolvers.length < 1) {
            return;
        }
        // 优先使用用户自定义的依赖
        const commentDependencyResolver = this.resolverRegistry.resolvers.find((resolver) => resolver instanceof CommentDependencyResolver);
        if (commentDependencyResolver) {
            const commentDependencies = commentDependencyResolver.resolve(expression);
            if (commentDependencies && Array.isArray(commentDependencies) && commentDependencies.length > 0) {
                deps.push(...commentDependencies);
            }
        }
        // 如果用户已经自定义了依赖，则不再计算
        if (deps && deps.length > 0) {
            return;
        }
        this.resolverRegistry.resolvers.forEach((resolver) => {
            // 再解析一次也可以，返回的依然是空数组
            if (resolver instanceof CommentDependencyResolver) {
                return;
            }
            const dependency = resolver.resolve(expression);
            if (dependency && dependency.length > 0) {
                deps.push(...dependency);
            }
        });
        // 去重
        return [...new Set(deps)];
    }
}

class ExpressionUtil {
    static getGroupFunctionDependency(expr, entityTypeInfo) {
        const deps = [];
        // 获取聚合函数依赖项
        const groupFunctionRegex = new RegExp(`DefaultFunction\\.(${GROUP_FUNCTIONS.join('|')})\\s*\\([^\\r\\n\\)]*\\)`, "g");
        const groupFunctions = expr.match(groupFunctionRegex);
        if (groupFunctions && groupFunctions.length > 0) {
            // todo: 使用正则匹配时可能会因为参数中有逗号导致问题，后续使用ast解析
            const argumentsRegex = /\(([^\r\n\)]*)\)/;
            groupFunctions.forEach((groupFunction) => {
                const argumentMatchResult = groupFunction.match(argumentsRegex);
                if (argumentMatchResult.length === 2) {
                    const argument = argumentMatchResult[1];
                    const args = argument.split(',').map(p => p.replace(/\"/g, ''));
                    if (args && args.length === 2) {
                        let item = args.join('.');
                        item = this.convertToNodeCode(item, entityTypeInfo).join('.');
                        item = item.substr(item.indexOf('.') + 1);
                        const dep = item.split('.');
                        dep.splice(0, 0, ENTITY_TEMPLATE);
                        deps.push(dep.join('/'));
                    }
                    else {
                        throw new Error(`无法解析参数： ${JSON.stringify(argument)}`);
                    }
                }
            });
        }
        return deps;
    }
    /**
     * 将voCode转换为前端nodeCode
     * @param entityExpression like Entity.Child.p1
     * @returns
     */
    static convertToNodeCode(entityExpression, entityTypeInfo) {
        // UserEntity.storys.p1
        const nodeCodes = [];
        if (entityTypeInfo && entityExpression.includes('.')) {
            const entityExpressions = entityExpression.split('.') || [];
            let dataTypeInfo = entityTypeInfo;
            for (let index = 0; index < entityExpressions.length; index++) {
                const prop = entityExpressions[index];
                if (dataTypeInfo && dataTypeInfo.entityInfo && dataTypeInfo.entityInfo.nodeCode === prop || dataTypeInfo.entityInfo.originalCode === prop) {
                    // 第一个是主表code，不能转nodeCode
                    if (index === 0) {
                        nodeCodes.push(dataTypeInfo.entityInfo.originalCode);
                    }
                    else {
                        nodeCodes.push(dataTypeInfo.entityInfo.nodeCode);
                    }
                    // 下一级可能为子表、对象或属性
                    const nextNodeCode = entityExpressions[index + 1];
                    if (!nextNodeCode) {
                        break;
                    }
                    const nextNodeCodePropInfo = dataTypeInfo.getPropInfoByName(nextNodeCode);
                    if (!nextNodeCodePropInfo) {
                        break;
                    }
                    // 下一级为子表或对象
                    if (nextNodeCodePropInfo.typeInfo) {
                        dataTypeInfo = nextNodeCodePropInfo.typeInfo;
                    }
                }
                else if (dataTypeInfo && dataTypeInfo.getPropInfoByName(prop)) {
                    const dataPropInfo = dataTypeInfo.getPropInfoByName(prop);
                    nodeCodes.push(dataPropInfo.name);
                }
                else {
                    //throw new Error(`错误的属性参数 ${entityExpression}`);
                    break;
                }
            }
        }
        return nodeCodes;
    }
    /**
     * 找到元数据中所有实体路径
     * @param dataTypeInfo
     * @param results
     * @param paths
     */
    static getChildrenEntityPaths(dataTypeInfo, results, paths = []) {
        const list = dataTypeInfo.getPropInfosByGroup(DataPropGroup.List);
        if (list && list.length > 0) {
            list.forEach((dataPropInfo) => {
                if (paths.length === 0) {
                    results.push([dataPropInfo.name]);
                }
                const childrens = dataPropInfo.typeInfo.getPropInfosByGroup(DataPropGroup.List);
                if (childrens && childrens.length > 0) {
                    paths.push(dataPropInfo.name);
                    childrens.forEach((dataPropInfo) => {
                        this.getChildrenEntityPaths(dataPropInfo.typeInfo, results, paths);
                    });
                }
                else {
                    if (paths.length !== 0) {
                        paths.push(dataPropInfo.name);
                        results.push([...paths]);
                    }
                    paths.length = 0;
                }
            });
        }
        else {
            if (paths.length > 0) {
                paths.push(dataTypeInfo.entityInfo.nodeCode);
                results.push([...paths]);
            }
            paths.length = 0;
        }
    }
    /**
     * 获取指定绑定路径的当前行数据
     * @param paths 绑定路径
     * @param bindingData
     * @returns
     */
    static getCurrentRowByPaths(paths, bindingData) {
        let result = null;
        const bindingList = bindingData.getValue(paths);
        if (bindingList && bindingList.length > 0) {
            let primaryValue = bindingList.currentItem.primaryKeyValue || null;
            // 使用事件中的主键
            // 主表或下级表新增，此时事件行就是当前行，无需处理
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
    /**
     * 从实体路径中获取级数最大的从表或从从表
     * @param paths
     * @returns
     */
    static getAvailableChildrenPathsFromEntityPaths(paths, entityTypeInfo) {
        let nodeCodes = [];
        paths = [...paths];
        while (paths.length > 0) {
            const dataPropInfo = entityTypeInfo.getPropInfoByPath(paths);
            if (dataPropInfo.group === 'List') {
                nodeCodes = paths;
                break;
            }
            paths.pop();
        }
        return nodeCodes;
    }
    /**
     * 从路径中获取绑定路径
     * @param paths 路径
     * @param entityTypeInfo entityTypeInfo
     * @returns
     */
    static getBindingPath(paths, entityTypeInfo) {
        paths = this.getEntityPath(paths);
        const entityPaths = this.getAvailableChildrenPathsFromEntityPaths(paths, entityTypeInfo);
        return entityPaths;
    }
    static getEntityPath(path) {
        const paths = path.filter((value, index) => {
            if (index % 2 === 0 && value.includes(':')) {
                return false;
            }
            else {
                return true;
            }
        });
        return paths;
    }
}

class Core {
    static warn(message, ...optionalParams) {
        this.logable() && console && console.warn(message, ...optionalParams);
    }
    static error(message, ...optionalParams) {
        this.logable() && console && console.error(message, ...optionalParams);
    }
    static log(message, ...optionalParams) {
        this.logable() && console && console.log(message, ...optionalParams);
    }
    static logable() {
        return window && window.localStorage && window.localStorage.getItem('__DEVKIT_LOGABLE__') === 'true' || false;
    }
}

const FORM_PATH_TOKEN = new InjectionToken('@farris/devkit form path token');
const BACK_END_MESSAGE_HANDLER_TOKEN = new InjectionToken('@farris/devkit_back_end_message_handler');
const MESSAGE_SERVICE_TOKEN = new InjectionToken('@farris/message_service_token');
const NOTIFY_SERVICE_TOKEN = new InjectionToken('@farris/notify_service_token');
const NAMESPACE = new InjectionToken('@farris/devkit NAMESPACE');

// export type ClassType = new (...args: any[]) => any;
const BigNumberType = 'BigNumber';
/**
 * 后端消息
 */
// tslint:disable-next-line: no-namespace
var BackEndMessage;
(function (BackEndMessage) {
    /**
     * 消息级别
     */
    let Level;
    (function (Level) {
        Level["Error"] = "Error";
        Level["Info"] = "Info";
        Level["Warning"] = "Warning";
    })(Level = BackEndMessage.Level || (BackEndMessage.Level = {}));
    /**
     * 消息
     * @description 接口执行成功，但有info/warning级别的消息
     */
    class Message {
        constructor(bizMessages, context) {
            this.bizMessages = bizMessages;
            this.context = context;
        }
    }
    BackEndMessage.Message = Message;
})(BackEndMessage || (BackEndMessage = {}));

const EFFECTOR_TOKEN = new InjectionToken('@farris/effector_token');

/**
 * 实体副作用器
 * @description 将表达式计算结果赋值给实体属性
 */
class RepositoryEffector {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.ns = this.viewModelContext.injector.get(NAMESPACE, '');
        this.repository = this.viewModelContext.repository;
        this.bindingData = this.viewModelContext.bindingData;
    }
    effect(path, value, options) {
        if (!options || !options.path) {
            throw new Error('repository effector 需要指定行信息。');
        }
        const propertyPath = options.path;
        const rowId = propertyPath[0] || this.bindingData.list.currentItem.primaryKeyValue;
        let entity = this.repository.entityCollection.getEntityById(rowId);
        if (rowId && !entity) {
            console.error(`找不到id：${rowId}对应的实体！`);
            return;
        }
        // propertyPath like : [1, child1s, 1.1, child2s, 1.1.1,propName] or [1,udt,propName] or [1,prop]
        const propName = propertyPath.pop();
        let object = entity;
        for (let index = 1; index < propertyPath.length; index++) {
            const propertyName = propertyPath[index];
            if (object instanceof EntityList) {
                object = object.get(propertyName);
            }
            else {
                object = object[propertyName];
            }
        }
        if (object) {
            if (object[propName] !== value) {
                object[propName] = value;
            }
        }
        else {
            console.error(`找不到实体对应的路径：${propertyPath.push(propName)}`);
        }
    }
}

class UIStateEffector {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.ns = this.viewModelContext.injector.get(NAMESPACE, '');
        this.uiState = this.viewModelContext.uiState;
    }
    effect(path, value, options) {
        this.uiState.setPropertyValue(path, value);
    }
}

class EffectorRegistry {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.effectors = this.viewModelContext.injector.get(EFFECTOR_TOKEN);
    }
}

// tslint:disable-next-line: no-namespace
var Expression;
(function (Expression) {
    /**
     * 表达式绑定字段类型（表达式绑定到实体、UIState?）
     */
    let ExpressionBindingType;
    (function (ExpressionBindingType) {
        ExpressionBindingType["State"] = "State";
        ExpressionBindingType["Field"] = "Field";
    })(ExpressionBindingType = Expression.ExpressionBindingType || (Expression.ExpressionBindingType = {}));
    /**
     * 表达式类型
     */
    let ExpressionType;
    (function (ExpressionType) {
        /**
         * 必填表达式
         */
        ExpressionType["Required"] = "require";
        /**
         * 只读表达式
         */
        ExpressionType["Readonly"] = "readonly";
        /**
         * 计算表达式
         */
        ExpressionType["Compute"] = "compute";
        /**
         * 依赖表达式
         */
        ExpressionType["Dependency"] = "dependency";
        /**
         * 是否可见
         */
        ExpressionType["Visible"] = "visible";
        /**
         * 关联表达式
         */
        ExpressionType["Relative"] = "relative";
        /**
         * 校验表达式
         */
        ExpressionType["Validate"] = "validate";
        /**
         * 帮助前
         */
        ExpressionType["DataPicking"] = "dataPicking";
    })(ExpressionType = Expression.ExpressionType || (Expression.ExpressionType = {}));
    /**
     * 事件类型
     */
    let EventType;
    (function (EventType) {
        EventType["ValueChanged"] = "VALUE_CHANGED";
        EventType["SelectionChanged"] = "SELECTION_CHANGED";
        EventType["Load"] = "Load";
        EventType["Append"] = "Append";
        EventType["Remove"] = "Remove";
        EventType["Update"] = "Update";
    })(EventType = Expression.EventType || (Expression.EventType = {}));
    let EventSource;
    (function (EventSource) {
        EventSource["Field"] = "Field";
        EventSource["State"] = "State";
        EventSource["BindingData"] = "BindingData";
        EventSource["Repository"] = "Repository";
    })(EventSource = Expression.EventSource || (Expression.EventSource = {}));
    let MessageType;
    (function (MessageType) {
        MessageType["error"] = "error";
        MessageType["info"] = "info";
        MessageType["warning"] = "warning";
    })(MessageType = Expression.MessageType || (Expression.MessageType = {}));
    let EffectPath;
    (function (EffectPath) {
        EffectPath[EffectPath["currentRow"] = 0] = "currentRow";
    })(EffectPath = Expression.EffectPath || (Expression.EffectPath = {}));
    Expression.MESSAGE = {
        'zh-CHS': {
            require: `请输入'$property'`,
            validate: `'$property'校验不通过`
        },
        en: {
            require: `Please input '$property'`,
            validate: `'$property' calibration failed`
        },
        'zh-CHT': {
            require: `請輸入'$property'`,
            validate: `'$property'校驗不通過`
        }
    };
    Expression.DEPENDENCY_SPLITER = '/';
})(Expression || (Expression = {}));

const LISTENER_TOKEN = new InjectionToken('@Farris listener');

/**
 * 变更监听器
 */
class ChangeListener {
    constructor() {
        this.subject = new Subject();
    }
    get onEvent() {
        return this.subject;
    }
    /**
     * 找到元数据中所有实体路径
     * @param dataTypeInfo
     * @param results
     * @param paths
     */
    findEntityPaths(dataTypeInfo, results, paths = []) {
        const list = dataTypeInfo.getPropInfosByGroup(DataPropGroup.List);
        if (list && list.length > 0) {
            list.forEach((dataPropInfo) => {
                paths.push(dataPropInfo.name);
                const childrens = dataPropInfo.typeInfo.getPropInfosByGroup(DataPropGroup.List);
                if (childrens && childrens.length > 0) {
                    childrens.forEach((dataPropInfo) => {
                        this.findEntityPaths(dataPropInfo.typeInfo, results, paths);
                    });
                }
                else {
                    results.push(paths);
                }
            });
        }
        else if (paths && paths.length > 0) {
            results.push(paths);
        }
    }
}

/**
 * 监听UIState变更
 */
class UIStateChangeListener extends ChangeListener {
    /**
     * 构造函数
     */
    constructor(viewModelContext) {
        super();
        this.viewModelContext = viewModelContext;
        this.frameId = this.viewModelContext.id;
        this.uiState = this.viewModelContext.uiState;
        this.namespace = this.viewModelContext.injector.get(NAMESPACE, null);
        this.registerEvent();
    }
    buildEventPath(change) {
        return null;
    }
    registerEvent() {
        if (this.uiState && this.uiState.changes) {
            this.uiState.changes.subscribe((change) => {
                const modification = {
                    ns: this.namespace,
                    path: [change.field],
                    type: Expression.EventType.ValueChanged,
                    value: change.value,
                    source: Expression.EventSource.State,
                    frameId: this.frameId
                };
                // console.log("UIStateChangeListener", modification);
                this.subject.next(modification);
            });
        }
    }
}

const EventType = Expression.EventType;
class RepositoryChangeListener extends ChangeListener {
    constructor(viewModelContext) {
        super();
        this.viewModelContext = viewModelContext;
        this.namespace = this.viewModelContext.injector.get(NAMESPACE, null);
        this.repository = this.viewModelContext.repository;
        this.bindingData = this.viewModelContext.bindingData;
        this.registerEvent();
    }
    registerEvent() {
        if (this.repository && this.repository.changes) {
            this.repository.changes.subscribe((change) => {
                let eventType = this.convertEventType(change);
                if (!eventType) {
                    return;
                }
                const path = this.buildEventPath(change);
                const modification = {
                    ns: this.namespace,
                    type: eventType,
                    path: path,
                    value: change.value,
                    source: Expression.EventSource.Field,
                };
                // console.log("RepositoryChangeListener", modification);
                this.subject.next(modification);
            });
        }
        // repository只监听值变化事件
        if (this.repository && this.repository.entityCollectionChange) {
            this.repository.entityCollectionChange.subscribe((change) => {
                let eventType = this.convertEventType(change);
                if (!eventType) {
                    return;
                }
                const path = this.buildEventPath(change);
                const modification = {
                    ns: this.namespace,
                    type: eventType,
                    path: path,
                    value: change.value,
                    source: Expression.EventSource.Repository,
                };
                this.subject.next(modification);
            });
        }
    }
    /**
     * 构建事件路径参数
     * @param event event
     * @description 构建完之后的路径类似[id,prop] or [id,从表名s,从表当前行id,从表属性] or [id,udt,udt_prop]
     * @returns
     */
    buildEventPath(event) {
        const paths = event.path;
        let result = [];
        if (!paths || paths.length < 1) {
            // 主表新增时path为空
            return result;
        }
        // 过滤掉udt的冒号，关联字段的id
        result = paths.filter((path, index) => {
            if (index % 2 === 0 && path.includes(':')) {
                if (path === ':') {
                    return false;
                }
                const primaryKey = path.split(':')[0];
                if (primaryKey !== this.repository.primaryKey) {
                    return false;
                }
            }
            return true;
        });
        // 移除路径中的id字符串
        // result = paths.map((path: string, index: number) => {
        //   if (path.includes(':') && index % 2 === 0) {
        //     return path.split(':')[1];
        //   }
        //   return path;
        // });
        // 此时result中不应该有冒号
        return result;
    }
    convertEventType(change) {
        let eventType = null;
        if (change.type === ModifyType.Add || change.type === ModifyType.AddData || change.type === ModifyType.Insert) {
            // eventType = Expression.EventType.Append;
            // 不处理新增
        }
        else if (change.type === ModifyType.Remove || change.type === ModifyType.RemoveData) {
            // eventType = Expression.EventType.Remove;
        }
        else if (change.type === ModifyType.Load) {
            // eventType = Expression.EventType.Load;
        }
        else if (change.type === ModifyType.ValueChange) {
            //eventType = Expression.EventType.ValueChanged;
            // 不处理值变化
        }
        else if (change.type === ModifyType.Update) {
            eventType = Expression.EventType.Update;
        }
        return eventType;
    }
}

class ListenerRegistry {
    /**
     * 构造函数
     */
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.listeners = this.viewModelContext.injector.get(LISTENER_TOKEN);
    }
}

const EventType$1 = Expression.EventType;
/**
 * 监听bindingList变更
 * @description 主要用于监听行切换等事件
 */
class BindingDataChangeListener extends ChangeListener {
    /**
     * 构造函数
     */
    constructor(viewModelContext) {
        super();
        this.viewModelContext = viewModelContext;
        /**
         * 实体仓库
         */
        this.repository = null;
        this.namespace = this.viewModelContext.injector.get(NAMESPACE, '');
        this.repository = this.viewModelContext.repository;
        this.bindingData = this.viewModelContext.bindingData;
        this.registerEvent();
    }
    /**
     * 注册值变化事件
     */
    registerEvent() {
        if (this.bindingData && this.bindingData.changes && typeof this.bindingData.changes.subscribe === 'function') {
            this.bindingData.changes.subscribe((change) => {
                if (change.type === ChangeType.Append || change.type === ChangeType.ValueChanged || change.type === ChangeType.Remove || change.type === ChangeType.Load || change.type === ChangeType.SelectionChanged) {
                    let eventType = null;
                    if (change.type === ChangeType.Append) {
                        eventType = EventType$1.Append;
                    }
                    else if (change.type === ChangeType.ValueChanged) {
                        eventType = EventType$1.ValueChanged;
                    }
                    else if (change.type === ChangeType.Remove) {
                        eventType = EventType$1.Remove;
                    }
                    else if (change.type === ChangeType.Load) {
                        // 主表新增
                        if (change.create === true) {
                            eventType = EventType$1.Append;
                        }
                        else {
                            eventType = EventType$1.Load;
                        }
                    }
                    else if (change.type === ChangeType.SelectionChanged) {
                        eventType = EventType$1.SelectionChanged;
                    }
                    const path = this.buildEventPath(change);
                    const modification = {
                        ns: this.namespace,
                        path: path,
                        type: eventType,
                        source: Expression.EventSource.BindingData,
                        value: change.value,
                        id: change.id
                    };
                    // console.log("BindingDataChangeListener", modification);
                    this.subject.next(modification);
                }
            });
        }
    }
    buildEventPath(change) {
        const path = change.path;
        const paths = [];
        // if (!path || path.length < 1) {
        //   return paths;
        // }
        const primaryValue = this.bindingData.list.currentItem.primaryKeyValue;
        if (primaryValue) {
            if (!(change.type === ChangeType.Load && change.path.length === 0)) {
                paths.push(`${this.bindingData.list.primaryKey}:${primaryValue}`);
            }
        }
        const currentPath = [];
        for (let index = 0; index < path.length; index++) {
            const propertyName = path[index];
            currentPath.push(propertyName);
            const item = this.bindingData.getValue(currentPath);
            paths.push(propertyName);
            if (item instanceof BindingList) {
                if (currentPath.length < path.length) {
                    const bindingList = item;
                    let currentId = bindingList.currentItem.primaryKeyValue;
                    if (index === path.length - 2 && change.id) {
                        currentId = change.id;
                    }
                    paths.push(`${this.bindingData.list.primaryKey}:${currentId}`);
                }
            }
        }
        return paths;
    }
}

/**
 * 监听器
 * @description 监听bindingList、UIState变更
 */
class Listeners {
    /**
     * 构造函数
     */
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.subject = new Subject();
        this.registry = this.viewModelContext.injector.get(ListenerRegistry, null);
        this.regist();
    }
    get onEvent() {
        return this.subject;
    }
    /**
     * 注册Listender
     */
    regist() {
        const listeners = this.registry && this.registry.listeners || [];
        if (listeners && listeners.length > 0) {
            listeners.forEach((listener) => {
                listener.onEvent.subscribe((modification) => {
                    this.subject.next(modification);
                });
            });
        }
    }
}

/**
 * 事件监听器主要有以下几种类型的事件：
 * 1、值变化
 * 2、行切换
 *    行切换使用场景为需要为数据计算依赖当前行时
 * 3、数据加载
 */
class ExpressionEventEmitter {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.listeners = this.viewModelContext.injector.get(Listeners);
        this.events = new Array();
        this.listeners.onEvent.subscribe((eventArgs) => {
            if (this.onEvent && this.onEvent.observers.length > 0) {
                let events = [];
                if (this.events.length > 0) {
                    events = [...this.events];
                }
                events.push(eventArgs);
                this.onEvent.next(events);
                this.events = [];
            }
            else {
                this.events.push(eventArgs);
            }
        });
    }
    attach() {
        if (!this.onEvent) {
            this.onEvent = new BehaviorSubject(this.events);
        }
        return this.onEvent.asObservable();
    }
}

const TranslateToken = createInjectionToken('@farris/devkit TranslateToken');

const FORM_MANIFEST_SERVICE_TOKEN = new InjectionToken('@farris/form_manifest_service');
const FORM_EXPRESSION_MANIFEST_SERVICE_TOKEN = new InjectionToken('@farris/form_expression_manifest_service');

class ExpressionRegistry {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this._expressions = null;
        this.injector = this.viewModelContext.injector;
        this.formExpressionManifestService = this.injector.get(FORM_EXPRESSION_MANIFEST_SERVICE_TOKEN, null);
        this.translate = this.injector.get(TranslateToken, null);
    }
    /**
     * 加载表达式文件
     */
    load() {
        return this.formExpressionManifestService.load().pipe(switchMap((describe) => {
            const expressions = this.setExpressions(describe);
            this.cleanSpecialCharacters();
            return of(expressions);
        }), catchError((e) => {
            return of([]);
        }));
    }
    setExpressions(describe) {
        const expressions = [];
        const exprs = Array.from(describe);
        const appContext = this.viewModelContext.injector.get(AppContext);
        exprs.forEach((expr) => {
            expr.expressions.forEach((expression) => {
                const expressionObject = {
                    id: expression.id,
                    ns: expr.ns,
                    viewModelId: expr.viewModelId,
                    path: expr.path,
                    bindingType: expr.type,
                    type: expression.type,
                    expression: expression.value || expression.expr || '',
                    message: expression.message || null,
                    messageType: expression.messageType || null,
                    deps: []
                };
                if (expression.type === Expression.ExpressionType.Required) {
                    const b = { type: "requiredExpression", constraints: [expression.id], message: expression.message };
                    appContext.validationManager[expr.path] = Object.assign({}, (appContext.validationManager[expr.path] || {}), { [expression.id]: b });
                }
                if (expression.type === Expression.ExpressionType.Validate) {
                    const b = { type: "expression", constraints: [expression.id], message: expression.message };
                    appContext.validationManager[expr.path] = Object.assign({}, (appContext.validationManager[expr.path] || {}), { [expression.id]: b });
                }
                if ((expression.type === Expression.ExpressionType.Required || expression.type === Expression.ExpressionType.Validate)) {
                    if (!expression.message) {
                        expressionObject.message = this.getExpressionMessage(expression.type);
                    }
                    if (!expression.messageType) {
                        expressionObject.messageType = 'error';
                    }
                }
                if (expressionObject.message) {
                    this.transform(expressionObject);
                }
                expressions.push(expressionObject);
            });
        });
        this._expressions = expressions;
        return expressions;
    }
    /**
     * 获取所有表达式
     */
    get expressions() {
        if (this._expressions) {
            return of(this._expressions);
        }
        // 短路，实现功能
        if (window['__expressions__']) {
            this.setExpressions(window['__expressions__']);
            return of(this._expressions);
        }
        return this.load();
    }
    /**
     * 根据表达式id获取对应的表达式对象
     * @param id 表达式id
     * @returns
     */
    getExpressionById(id) {
        if (!this._expressions || this._expressions.length < 1) {
            return null;
        }
        return this._expressions.find((expressionObject) => expressionObject.id === id);
    }
    getExpressionMessage(expressionType, defaultValue) {
        if (!(expressionType === Expression.ExpressionType.Validate || expressionType === Expression.ExpressionType.Required)) {
            return null;
        }
        if (!this.translate) {
            return defaultValue;
        }
        const currentLanguage = this.translate.getCurrentLanguage() || 'zh-CHS';
        return Expression.MESSAGE[currentLanguage][expressionType];
    }
    transform(expressionObject) {
        if (!this.translate) {
            return;
        }
        if (expressionObject.message && expressionObject.message.startsWith('{{') && expressionObject.message.endsWith('}}')) {
            expressionObject.message = this.translate.transform(expressionObject.message.substr(2, expressionObject.message.length - 4), null) || this.getExpressionMessage(expressionObject.type);
        }
    }
    cleanSpecialCharacters() {
        if (!this._expressions || this._expressions.length < 1 || !Array.isArray(this._expressions)) {
            return;
        }
        const repository = this.viewModelContext.repository;
        if (!repository) {
            return;
        }
        const entityTypeInfo = repository.entityTypeInfo;
        const regex = new RegExp(`[\\'\\"]?\\s*(${entityTypeInfo.entityInfo.nodeCode}|${entityTypeInfo.entityInfo.originalCode})[\\.\\[\\]a-zA-Z0-9_]+\\s*[\\'\\"]?`, 'g');
        this._expressions.forEach((expressionObject) => {
            const expr = expressionObject.expression;
            const entityPropertyExpressions = expr.match(regex);
            if (Array.isArray(entityPropertyExpressions) && entityPropertyExpressions.length > 0) {
                // 解析出所有实体相关的字符串，以主实体名字开头，包含主实体属性或子表
                entityPropertyExpressions.forEach((item) => {
                    if (item.indexOf('.') === -1) {
                        console.warn(`无效的实体表达式:${item}`);
                        return;
                    }
                    // 去数组
                    if (/\[\d\]/g.test(item)) {
                        const replacer = item.replace(/\[\d\]/g, '');
                        expressionObject.expression = this.replaceAll(expressionObject.expression, item, replacer);
                    }
                    // 去星号
                    if (/\*/g.test(item)) {
                        const replacer = item.replace(/\*/g, '');
                        expressionObject.expression = this.replaceAll(expressionObject.expression, item, replacer);
                    }
                });
            }
        });
    }
    replaceAll(originalValue, search, replacer) {
        return originalValue.split(search).join(replacer);
    }
}

class ExpressionExecutor {
    /**
     * 编译执行
     * @param expression
     * @param context
     * @returns
     */
    compile(expressionObject, context) {
        if (Object.prototype.toString.call(context) !== '[object Object]') {
            throw new Error('上下文必须为对象！');
        }
        const expressionContext = this.buildContext(context);
        if (!expressionObject.factory) {
            const expression = new Expression$1(expressionObject.expression, expressionContext);
            expressionObject.factory = expression.compile();
        }
        const expression = expressionObject.factory;
        return expression.eval(expressionContext);
    }
    /**
     * 解析
     * @param expression
     * @param context
     * @returns
     */
    eval(expression, context) {
        if (Object.prototype.toString.call(context) !== '[object Object]') {
            throw new Error('上下文必须为对象！');
        }
        const expressionContext = this.buildContext(context);
        const expressionEngine = new ExpressionEngine(expressionContext);
        return expressionEngine.eval(expression);
    }
    /**
     * 构造表达式上下文
     * @param context
     * @returns
     */
    buildContext(context) {
        const expressionContext = new ExpressionContext();
        if (context && Object.keys(context).length > 0) {
            Object.keys(context).forEach((key) => {
                expressionContext.set(key, context[key]);
            });
        }
        return expressionContext;
    }
}

class EventHandler {
    constructor(frameContext) {
        this.frameContext = frameContext;
        this.injector = frameContext.injector;
        this.repository = frameContext.repository;
        this.bindingData = frameContext.bindingData;
        this.expressionRegistry = this.injector.get(ExpressionRegistry, null);
        this.effectorFactory = this.injector.get(EffectorFactory, null);
        this.expressionExecutor = this.injector.get(ExpressionExecutor);
        this.expressionResult = this.injector.get(ExpressionResult, null);
    }
    handleEvent(event, expressionObjects) {
        event = Object.assign({}, event);
        this.expressionObjects = expressionObjects;
        this.dispatch(event);
    }
    //#endregion
    //#region 属性
    /**
     * 主表主键值
     */
    get primaryValue() {
        return this.bindingData.list.currentItem.primaryKeyValue;
    }
    /**
     * 获取主实体原始字段名
     */
    get entityOriginalNodeCode() {
        return this.repository && this.repository.entityTypeInfo && this.repository.entityTypeInfo.entityInfo && this.repository.entityTypeInfo.entityInfo.originalCode || null;
    }
    //#endregion
    //#region 表达式核心
    /**
     * 执行表达式计算
     * @param expression 表达式
     * @param context 上下文
     * @returns any
     */
    perform(expressionObject, context) {
        return this.expressionExecutor.compile(expressionObject, context);
    }
    /**
     * 副作用
     * @param event event
     * @param expressionObject expressionObject
     */
    effect(event, expressionObject) {
        const effectTo = expressionObject.bindingType;
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            // console.warn(`EventHandler 没有对应的副作用器。${expressionObject.type}`);
            return;
        }
        if (effectTo === Expression.ExpressionBindingType.Field) {
            const effectPaths = expressionObject.effectPaths || [];
            if (effectPaths.length > 0) {
                effectPaths.forEach((path) => {
                    const effectPath = path.split('/');
                    const effectOptions = { path: effectPath, message: expressionObject.message, expressionId: expressionObject.id, eventType: event.type, viewModelId: expressionObject.viewModelId };
                    effector.effect(expressionObject.path, expressionObject.result, effectOptions);
                });
            }
            else if (expressionObject.type === Expression.ExpressionType.Required || expressionObject.type === Expression.ExpressionType.Validate || expressionObject.type === Expression.ExpressionType.Readonly || expressionObject.type === Expression.ExpressionType.Visible) {
                const effectOptions = { message: expressionObject.message, expressionId: expressionObject.id, eventType: event.type, viewModelId: expressionObject.viewModelId };
                effector.effect(expressionObject.path, expressionObject.result, effectOptions);
            }
        }
        else {
            throw new Error('not supported！');
        }
    }
    //#endregion
    //#region util
    isValidateOrRequiredExpression(expressionObject) {
        return expressionObject && (expressionObject.type === Expression.ExpressionType.Validate || expressionObject.type === Expression.ExpressionType.Required);
    }
    /**
     * 以事件参数为依据构建实体路径
     * @param event event
     * @returns
     */
    getEntityPathFromEvent(event) {
        event = JSON.parse(JSON.stringify(event));
        if (!event || !event.path || event.path.length < 1) {
            return [];
        }
        const paths = event.path;
        return this.getEntityPath(paths);
    }
    /**
     * 获取事件路径中的实体路径
     * @param path path
     * @returns
     */
    getEntityPath(path) {
        const paths = path.filter((value, index) => {
            if (index % 2 === 0 && value.includes(':')) {
                return false;
            }
            else {
                return true;
            }
        });
        return paths;
    }
    /**
     * 构造实体路径
     * @param path path
     * @description 删除路径中的id字段
     * @returns
     */
    buildEntityPath(path) {
        const paths = path.filter((value, index) => {
            if (index % 2 === 0 && value.includes(':')) {
                return false;
            }
            else {
                return true;
            }
        });
        return paths;
    }
    /**
     * 清理事件路径中的id主键标识
     * @param path path
     * @returns
     */
    cleanEventPath(path) {
        path = path.filter(p => {
            if (p && p !== ':') {
                return true;
            }
            else {
                return false;
            }
        });
        return path.map((item) => {
            if (item.includes(':')) {
                return item.split(':')[1];
            }
            else {
                return item;
            }
        });
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByPaths(paths) {
        let result = null;
        const bindingList = this.bindingData.getValue(paths);
        if (bindingList && bindingList.length > 0) {
            let primaryValue = bindingList.currentItem.primaryKeyValue || null;
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
    /**
     * 获取事件路径中指定子表的事件行
     * @param path
     * @param tableCode
     * @returns
     */
    getEventId(path, tableCode) {
        if (!path || path.length < 1) {
            throw new Error('invalid path!');
        }
        const propertyIndex = path.findIndex(p => p === tableCode);
        if (propertyIndex === -1) {
            return null;
        }
        const idIndex = propertyIndex + 1;
        if (idIndex > path.length - 1) {
            throw new Error('invalid propertyName or path');
        }
        const id = path[idIndex];
        if (id.indexOf(':') === -1) {
            throw new Error('compute error.');
        }
        return id.split(':')[1];
    }
    //#endregion
    //#region  构造上下文
    /**
     * 构造变量上下文
     * @param event
     * @returns
     */
    buildStateContext(event) {
        const ns = event.ns;
        const appContext = this.injector.get(AppContext, null);
        const frameContexts = appContext.viewModelContextManager.getContextsByNamespace(ns);
        const result = {};
        if (frameContexts && frameContexts.length > 0) {
            const anonymousFrameContext = frameContexts[0];
            const rootFrameContext = anonymousFrameContext.getVirtualRootFrameContext();
            if (rootFrameContext) {
                const uiState = rootFrameContext.viewModel.uiState;
                const propertyNames = Object.getOwnPropertyNames(uiState) || [];
                propertyNames.forEach((prop) => {
                    if (prop.match(/^[a-zA-Z0-9_\$]+$/g) !== null) {
                        result[prop] = uiState[prop];
                    }
                });
            }
        }
        return result;
    }
    /**
     * 获取事件实体
     * @param event
     * @returns
     */
    buildEntityContext(event, expressionObject, currentRows) {
        const expressionBindingType = expressionObject.bindingType;
        if (expressionBindingType === Expression.ExpressionBindingType.Field) {
            const entityTypeInfo = this.repository.entityTypeInfo;
            const childrenEntityPaths = [];
            ExpressionUtil.getChildrenEntityPaths(entityTypeInfo, childrenEntityPaths);
            // 获取当前行
            const row = currentRows && currentRows.find(row => row.bindingPath === '' || row.bindingPath === '/') || null;
            const primaryValue = row && row.primaryValue || this.bindingData.list.currentId;
            let entity = this.bindingData.list.findById(primaryValue);
            if (!entity) {
                return null;
            }
            const object = entity.toJSON();
            object['__type__'] = 'Entity';
            if (!childrenEntityPaths || childrenEntityPaths.length < 1) {
                return object;
            }
            childrenEntityPaths.sort((v1, v2) => v1.length - v2.length);
            // 找到所有子表
            childrenEntityPaths.forEach((paths) => {
                const bindingList = this.bindingData.getValue(paths);
                let currentRowId = bindingList.currentId;
                const propertyName = paths[paths.length - 1];
                // parent 为entity或entitylist或null
                const parent = paths.slice(0, paths.length - 1).reduce((object, path) => {
                    return object && object[path] || null;
                }, object);
                if (!parent) {
                    return;
                }
                const data = parent;
                let node = null;
                if (!currentRowId) {
                    // 当前表没有数据
                    node = { __items__: [], __type__: 'List' };
                    node.length = () => node.__items__.length;
                }
                else {
                    // 纠正当前行
                    if (currentRows && currentRows.length > 0) {
                        // 是否指定了当前行
                        const userAssignCurrentRow = currentRows.find(row => {
                            const bindingPaths = row.bindingPath.split('/').filter(p => p);
                            return bindingPaths.join('/') === paths.join('/');
                        });
                        if (userAssignCurrentRow) {
                            currentRowId = userAssignCurrentRow.primaryValue;
                        }
                    }
                    // 子表当前行
                    const row = bindingList.findById(currentRowId);
                    // 找到子表当前行的上级
                    const list = parent[propertyName];
                    node = Object.assign({ __items__: [] }, row && row.toJSON() || {}, { __type__: 'List' });
                    node.length = () => node.__items__.length;
                    if (list && Array.isArray(list)) {
                        node.__items__ = [].concat(list);
                    }
                }
                data[propertyName] = node;
            });
            return object;
        }
        else if (expressionBindingType === Expression.ExpressionBindingType.State) {
            // todo: 支持状态表达式
        }
        else {
            return null;
        }
    }
    /**
     * 构造表达式计算上下文
     * @param expressionObject 表达式
     * @param event 事件
     * @param entityContext 实体上下文
     * @param currentRows 当前行
     * @returns
     */
    buildContext(expressionObject, event, entityContext, currentRows) {
        let context = [];
        if (entityContext) {
            context.push(entityContext);
        }
        else {
            const entity = this.buildEntityContext(event, expressionObject, currentRows);
            context.push(entity);
        }
        const stateContext = this.buildStateContext(event);
        const entityCode = this.entityOriginalNodeCode;
        let entity = null;
        if (context.length === 1) {
            entity = context.pop();
        }
        else {
            entity = context[0];
            if (!entity['__type__']) {
                entity['__type__'] = 'Entity';
            }
            entity['__items__'] = context;
        }
        return Object.assign({ [entityCode]: entity }, stateContext, { frameContext: this.frameContext, bindingData: this.bindingData, repository: this.repository });
    }
    //#endregion
    /**
     * 构造副作用路径
     * @param event
     * @param expressionObject
     * @returns
     */
    buildEffectPath(event, expressionObject) {
        const expressionPaths = expressionObject.path.split('/').filter(p => p);
        const primaryValue = event.path[0] && event.path[0].split(':')[1];
        if (!primaryValue) {
            throw new Error('Invalid event path!');
        }
        if (expressionPaths.length === 1) {
            // 主表简单字段
            return [primaryValue, expressionPaths.pop()];
        }
        else {
            const result = [primaryValue];
            for (let index = 0; index < expressionPaths.length; index++) {
                const propertyName = expressionPaths[index];
                result.push(propertyName);
                const currentPaths = expressionPaths.slice(0, index + 1);
                const propertyInfo = this.repository.entityTypeInfo.getPropInfoByPath(currentPaths);
                if (propertyInfo.group === 'List') {
                    let id = this.getEventId(event.path, propertyInfo.name) || null;
                    // 事件和表达式不是同一个表
                    if (!id) {
                        const bindingList = this.bindingData.getValue(currentPaths);
                        if (bindingList) {
                            id = bindingList.currentId;
                        }
                    }
                    result.push(id);
                }
            }
            return result;
        }
    }
    //#region 辅助方法
    getPathInfo(path) {
        const paths = path.split('/').filter(p => p);
        // 获取最大实体层级，其余为属性（简单属性、udt、关联、关联嵌套关联）
        const entityPath = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        const propertyName = paths.slice(entityPath.length).join('/');
        return { path: entityPath.join('/'), propertyName, paths: entityPath, propertyNames: propertyName.split('/').filter(p => p) };
    }
    /**
     * get table paths from event paths
     * @param paths event paths
     * @returns
     */
    getTablePathsFromEventPaths(paths) {
        paths = this.getEntityPath(paths);
        const entityPaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        return entityPaths;
    }
    /**
     * get property paths from event paths
     * @param paths event paths
     * @returns
     */
    getPropertyPathsFromEventPaths(paths) {
        paths = this.getEntityPath(paths);
        const tablePaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(paths, this.repository.entityTypeInfo);
        return paths.slice(tablePaths.length);
    }
    /**
     * 分析事件和表达式的关系
     */
    analysis(event, expressionObject) {
        const expressionPathInfo = this.getPathInfo(expressionObject.path);
        const eventPaths = this.getEntityPath(event.path.slice(0));
        const eventPathInfo = this.getPathInfo(eventPaths.join('/'));
        if (!expressionPathInfo || !eventPathInfo) {
            console.warn(`表达式路径或事件路径错误，获取路径信息失败。`);
            return null;
        }
        const expressionTablePaths = expressionPathInfo.path.split('/').filter(p => p);
        const expressionPropertyNames = expressionPathInfo.propertyName.split('/').filter(p => p);
        const eventTablePaths = eventPathInfo.path.split('/').filter(p => p);
        const eventPropertyNames = eventPathInfo.propertyName.split('/').filter(p => p);
        const result = {
            distance: undefined,
            eventFromChildren: undefined,
            eventFromParent: undefined,
            expressionTablePaths,
            expressionPropertyNames,
            eventTablePaths,
            eventPropertyNames,
            isSameTable: false
        };
        result.distance = Math.abs(expressionTablePaths.length - eventTablePaths.length);
        if (result.distance === 1) {
            result.eventFromChildren = eventTablePaths.length > expressionTablePaths.length && eventTablePaths.join('/').startsWith(expressionTablePaths.join('/'));
            result.eventFromParent = eventTablePaths.length < expressionTablePaths.length && expressionTablePaths.join('/').startsWith(eventTablePaths.join('/'));
        }
        result.isSameTable = expressionTablePaths.join('/') === eventTablePaths.join('/');
        return result;
    }
    buildCurrentRows(tablePaths, fullPaths) {
        const currentRows = new Array();
        if (!tablePaths || tablePaths.length < 1) {
            currentRows.push({
                bindingPath: '/',
                primaryValue: fullPaths[0]
            });
        }
        else {
            const paths = [];
            tablePaths.forEach((path, index) => {
                if (index === 0) {
                    currentRows.push({
                        bindingPath: '/',
                        primaryValue: fullPaths[0]
                    });
                }
                paths.push(path);
                const primaryValue = fullPaths[index * 2 + 2];
                currentRows.push({
                    bindingPath: paths.join('/'),
                    primaryValue: primaryValue
                });
            });
        }
        return currentRows;
    }
}

/**
 * 实体值变化处理器
 */
class EntityValueChangedEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     */
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}

class EffectorManager {
    /**
     * 批量副作用
     * @param effector effector
     * @param expressionObject 表达式
     * @param paths 作用路径
     * @returns
     */
    static effect(effector, expressionObject, paths) {
        if (!paths || paths.length < 1) {
            return;
        }
        paths.forEach((path) => {
            const effectOptions = { path, message: expressionObject.message, expressionId: expressionObject.id, viewModelId: expressionObject.viewModelId, eventType: expressionObject.eventType };
            effector.effect(expressionObject.path, expressionObject.result, effectOptions);
        });
    }
}

class StateValueChangedEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     */
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            return this.expressionObjects.filter((expressionObject) => {
                const deps = expressionObject.deps;
                if (!deps || deps.length < 1 || event.ns !== expressionObject.ns) {
                    return false;
                }
                const changePaths = this.cleanEventPath(event.path);
                changePaths.splice(0, 0, STATE_TEMPLATE);
                const eventPath = changePaths.join('/');
                if (deps.includes(eventPath)) {
                    return true;
                }
                else {
                    return false;
                }
            });
        }
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                // const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 副作用
     * @param event event
     * @param expressionObject expressionObject
     */
    effect(event, expressionObject) {
        const effector = this.effectorFactory.getEffector(expressionObject);
        const bindingType = expressionObject.bindingType;
        if (bindingType === Expression.ExpressionBindingType.State) {
            // 如果表达式作用于uistate
            effector.effect(expressionObject.path, expressionObject.result, { message: expressionObject.message, eventType: event.type, viewModelId: expressionObject.viewModelId });
        }
        else if (bindingType === Expression.ExpressionBindingType.Field) {
            // 表达式作用于实体属性
            const expressionPathInfo = this.getPathInfo(expressionObject.path);
            const bindingPaths = expressionPathInfo.paths;
            const entities = this.repository.entityCollection.getAllEntities();
            this.effectRows(entities, bindingPaths, expressionPathInfo.propertyNames, (currentRows, paths) => {
                this.output(event, expressionObject, currentRows, effector, [paths]);
            });
        }
    }
    output(event, expressionObject, currentRows, effector, paths) {
        const context = this.buildContext(expressionObject, event, null, currentRows);
        const value = this.perform(expressionObject, context);
        if (value === undefined) {
            return;
        }
        expressionObject.result = value;
        if (expressionObject.id) {
            this.expressionResult.set(expressionObject.id, expressionObject.result);
        }
        EffectorManager.effect(effector, expressionObject, paths);
    }
    effectRows(entities, bindingPaths, propertyNames, callback, currentRows = [], prevPaths = [], paths = []) {
        if (!bindingPaths || bindingPaths.length < 1) {
            entities.forEach((entity) => {
                if (!entity || !entity.primaryValue) {
                    return;
                }
                const currentPaths = paths.concat([entity.primaryValue]).concat(propertyNames);
                const currentCurrentRows = currentRows.concat([{ bindingPath: prevPaths.join('/') || '/', primaryValue: entity.primaryValue }]);
                callback(currentCurrentRows, currentPaths);
            });
            currentRows.length = 0;
            paths.length = 0;
        }
        else {
            let flag = false;
            let nextPrevPaths = prevPaths;
            entities.forEach((entity) => {
                const prop = bindingPaths[0];
                const entityList = entity[prop];
                if (!entityList || entityList.count() < 1) {
                    return;
                }
                currentRows.push({ bindingPath: prevPaths.join('/') || '/', primaryValue: entity.primaryValue });
                paths.push(entity.primaryValue);
                paths.push(prop);
                if (flag === false) {
                    flag = true;
                    nextPrevPaths.push(prop);
                }
                const nextBindingPaths = bindingPaths.slice(1);
                this.effectRows(entityList.items, nextBindingPaths, propertyNames, callback, currentRows, nextPrevPaths, paths);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}

class RepositoryAddEntityEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     * @description 不支持主表直接依赖子表属性的情况，只能聚合子表的字段
     */
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}

class RepositoryRemoveEntityEventHandler extends EventHandler {
    /**
     * 获取相关表达式
     * @param event event
     */
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
    }
}

class RepositoryLoadEventHandler extends EventHandler {
    filter(event) {
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                else {
                    console.warn(`EventHandler 表达式未设置唯一标识，无法更新表达式值。`);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}

class EntityUpdateEventHandler extends EventHandler {
    filter(event) {
        return this.expressionObjects.filter((expressionObject) => {
            // 重新加载实体时不计算计算表达式，只处理只读、必填等
            if (expressionObject.ns !== event.ns || !expressionObject.deps || expressionObject.deps.length === 0 || expressionObject.type === Expression.ExpressionType.Compute || expressionObject.type === Expression.ExpressionType.Dependency || expressionObject.type === Expression.ExpressionType.DataPicking) {
                return false;
            }
            const result = this.analysis(event, expressionObject);
            if (!result) {
                return false;
            }
            // 必须是主表表达式
            if (result.expressionTablePaths.length !== 0) {
                return false;
            }
            const index = expressionObject.deps.findIndex((dep) => {
                if (!dep.startsWith(ENTITY_TEMPLATE)) {
                    return false;
                }
                const deps = dep.split(Expression.DEPENDENCY_SPLITER).filter(p => p).slice(1);
                const depPathInfo = this.getPathInfo(deps.join('/'));
                if (!depPathInfo) {
                    return false;
                }
                if (depPathInfo.paths.length !== 0) {
                    return false;
                }
                return true;
            });
            return index === -1 ? false : true;
        });
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                else {
                    console.warn(`EventHandler 表达式未设置唯一标识，无法更新表达式值。`);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    getCurrentRowByEvent(paths, event) {
        let result = null;
        const bindingList = this.bindingData.getValue(paths);
        const eventEntityPath = this.getEntityPath(event.path);
        if (bindingList && bindingList.length > 0) {
            let primaryValue = bindingList.currentItem.primaryKeyValue || null;
            // 使用事件中的主键
            const childrenPaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(eventEntityPath, this.repository.entityTypeInfo);
            if (childrenPaths && childrenPaths.toString() === paths.toString()) {
                // 发生值变化的数据位于要获取当前行的子表中，此时事件行应该是发生值变化的数据id，而不是当前行id
                primaryValue = event.id || null;
                if (!primaryValue) {
                    primaryValue = this.getEventId(event.path, paths[paths.length - 1]);
                }
            }
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
}

class BindingDataAppendObjectEventHandler extends EventHandler {
    /**
     * 过滤出需要计算的表达式
     * @param event event
     * @returns
     */
    filter(event) {
        // event.path like ["id:7dd77e50-ebed-4639-b483-d12004603640", "formEEUR1E1s"] or undefined or []
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            // const fullEventPath = event.path || [];
            // 找到聚合相关表达式(依赖新增表的表达式),聚合的前提是表达式path位于事件路径的上方
            // 给实体属性或vo变量设置了聚合相关的表达式，此时表达式依赖中路径到子表属性
            const groupExpressions = this.expressionObjects.filter((expressionObject) => {
                if (expressionObject.ns !== event.ns || !expressionObject.deps || expressionObject.deps.length < 1) {
                    return false;
                }
                const eventTablePaths = this.buildEntityPath(event.path);
                const info = this.analysis(event, expressionObject);
                if (!info) {
                    return false;
                }
                // const eventEntityPath = this.buildEntityPath(event.path);
                // 主表新增
                if (eventTablePaths.length === 0) {
                    if (expressionObject.bindingType === Expression.ExpressionBindingType.Field) {
                        // 认为主表新增时不需要处理聚合函数
                        return false;
                    }
                }
                // 从表或从从表新增
                eventTablePaths.splice(0, 0, ENTITY_TEMPLATE);
                // eventEntityPath like ['ENTITY~','formEEUR1E1s'] // 从表新增
                // deps like ['ENTITY~/formEEUR1E1s/udt/udt_field','ENTITY~/formEEUR1E1s/ref/ref_udt/ref_udt_field']
                // 仅处理上级表达式
                if (info.eventTablePaths.length - 1 !== info.expressionTablePaths.length) {
                    return false;
                }
                // 不支持跨表
                if (!info.eventTablePaths.join(Expression.DEPENDENCY_SPLITER).startsWith(info.expressionTablePaths.join(Expression.DEPENDENCY_SPLITER))) {
                    return false;
                }
                const index = expressionObject.deps.findIndex((dep) => {
                    // 依赖
                    if (!dep.startsWith(eventTablePaths.join(Expression.DEPENDENCY_SPLITER))) {
                        return false;
                    }
                    const deps = dep.split(Expression.DEPENDENCY_SPLITER).filter(p => p).slice(1);
                    const dependPathInfo = this.getPathInfo(deps.join(Expression.DEPENDENCY_SPLITER));
                    if (dependPathInfo && dependPathInfo.paths.join(Expression.DEPENDENCY_SPLITER) === info.eventTablePaths.join(Expression.DEPENDENCY_SPLITER)) {
                        return true;
                    }
                    return false;
                });
                return index === -1 ? false : true;
            });
            const eventTablePaths = this.buildEntityPath(event.path);
            // 事件表中表达式（事件表本身的表达式）
            const relativeExpressions = this.expressionObjects.filter((expressionObject) => {
                // expressionObject.bindingType !== Expression.ExpressionBindingType.Field 暂不支持State表达式
                if (expressionObject.ns !== event.ns) {
                    return false;
                }
                const expressionPathInfo = this.getPathInfo(expressionObject.path);
                // 过滤掉非当前表的表达式
                if (expressionPathInfo.paths.join(Expression.DEPENDENCY_SPLITER) !== eventTablePaths.join(Expression.DEPENDENCY_SPLITER)) {
                    return false;
                }
                // 没有依赖的表达式
                if (!expressionObject.deps || expressionObject.deps.length < 1) {
                    return true;
                }
                // 仅依赖State
                const onlyDependOnState = expressionObject.deps.every((dep) => dep.startsWith(STATE_TEMPLATE));
                // 仅依赖当前表或上级表
                // const onlyDependOnCurrentTable = expressionObject.deps.every((dep: string) => {
                //   if (!dep.startsWith(ENTITY_TEMPLATE)) {
                //     return false;
                //   }
                //   const deps = dep.split(Expression.DEPENDENCY_SPLITER).slice(1);
                //   const dependPathInfo = this.getPathInfo(deps.join(Expression.DEPENDENCY_SPLITER));
                //   return dependPathInfo.paths.join(Expression.DEPENDENCY_SPLITER) === eventTablePaths.join(Expression.DEPENDENCY_SPLITER) || eventTablePaths.join(Expression.DEPENDENCY_SPLITER).startsWith(dependPathInfo.paths.join(Expression.DEPENDENCY_SPLITER)) && dependPathInfo.paths.length + 1 == eventTablePaths.length;
                // });
                // if (onlyDependOnState || onlyDependOnCurrentTable) {
                //   return true;
                // }
                if (onlyDependOnState) {
                    return true;
                }
                const result = this.analysis(event, expressionObject);
                if (result && result.distance === 0 && result.isSameTable) {
                    return true;
                }
                // 事件表表达式，但依赖下级表的未计算
                return false;
            });
            return groupExpressions.concat(relativeExpressions);
        }
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                else {
                    console.warn(`EventHandler 表达式未设置唯一标识，无法更新表达式值。`);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
    /**
     * 新增副作用器
     * @param event event
     * @param expressionObject 表达式
     * @returns
     */
    effect(event, expressionObject) {
        const effectTo = expressionObject.bindingType;
        const eventPath = this.cleanEventPath(event.path);
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            return;
        }
        const info = this.analysis(event, expressionObject);
        if (!info) {
            console.warn(`[BindingDataAppendObjectEventHandler][analysis]获取路径信息失败。`);
            return;
        }
        const expressionPaths = expressionObject.path.split('/').filter(p => p);
        if (effectTo === Expression.ExpressionBindingType.Field) {
            const paths = [];
            const propertyPaths = expressionPaths.slice(info.expressionTablePaths.length);
            // 新增场景仅需要计算事件表及事件表上面的表
            if (info.distance === 0) {
                if (!info.isSameTable) {
                    return;
                }
                // 表达式和事件在同一个表
                const prevPaths = eventPath.slice(0);
                if (eventPath.length === 1) {
                    // 主表新增，此时事件路径中有主键，直接拼接属性就是完整路径
                    if (event.value && Array.isArray(event.value)) {
                        event.value.forEach((bindingObject) => {
                            paths.push([bindingObject.primaryKeyValue].concat(propertyPaths));
                        });
                    }
                    else {
                        const path = prevPaths.concat(propertyPaths);
                        paths.push(path);
                    }
                }
                else {
                    // 从表或从从表新增，此时事件路径中缺少最后一个层级的主键
                    if (event.value && Array.isArray(event.value)) {
                        event.value.forEach((bindingObject) => {
                            paths.push(prevPaths.concat([bindingObject.primaryKeyValue]).concat(propertyPaths));
                        });
                    }
                    else {
                        const bindingList = this.bindingData.getValue(info.eventTablePaths);
                        if (bindingList && bindingList.currentId) {
                            paths.push(prevPaths.concat(bindingList.currentId).concat(propertyPaths));
                        }
                    }
                }
            }
            else {
                // 表达式和事件不在同一个表，即下级表新增或批量新增了一批数据
                if (info.eventFromParent === true) {
                    // 在过滤时这种情况的应该就排除掉了
                    console.warn(`[BindingDataAppendObjectEventHandler][effect_error]`);
                    return;
                }
                else if (info.eventFromChildren === true) {
                    const prevPaths = eventPath.slice(0, eventPath.length - 1);
                    const path = prevPaths.concat(propertyPaths);
                    paths.push(path);
                }
                else {
                    console.warn(`[BindingDataAppendObjectEventHandler][effect_error]`);
                    return;
                }
            }
            paths.forEach((path) => {
                const currentRows = this.buildCurrentRows(info.expressionTablePaths, path);
                this.output(event, expressionObject, currentRows, effector, [path]);
            });
        }
        else if (effectTo === Expression.ExpressionBindingType.State) {
            console.error('not supported！');
        }
    }
    output(event, expressionObject, currentRows, effector, paths) {
        const context = this.buildContext(expressionObject, event, null, currentRows);
        const value = this.perform(expressionObject, context);
        if (value === undefined) {
            return;
        }
        expressionObject.result = value;
        if (expressionObject.id) {
            this.expressionResult.set(expressionObject.id, expressionObject.result);
        }
        EffectorManager.effect(effector, Object.assign({ eventType: event.type }, expressionObject), paths);
    }
}

class BindingDataValueChangeEventHandler extends EventHandler {
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            return this.expressionObjects.filter((expressionObject) => {
                const deps = expressionObject.deps;
                if (!deps || deps.length < 1 || event.ns !== expressionObject.ns) {
                    return false;
                }
                const eventEntityPaths = this.getEntityPath(event.path);
                eventEntityPaths.splice(0, 0, ENTITY_TEMPLATE);
                return deps.includes(eventEntityPaths.join('/'));
            });
        }
        return null;
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 输出副作用
     * @param event event
     * @param expressionObject 表达式
     * @returns
     */
    effect(event, expressionObject) {
        // 首先计算当前表达式和事件会影响那些路径
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            return;
        }
        const result = this.analysis(event, expressionObject);
        if (!result) {
            return;
        }
        const eventPaths = this.cleanEventPath(event.path);
        const paths = [];
        if (result.distance === 0) {
            // 值变化之后影响到了一个表内字段或影响到了同级表字段
            if (result.isSameTable === false) {
                // 同级表跳过
                console.warn(`[BindingDataValueChangeEventHandler]不支持多对多关系。`);
                return;
            }
            const prevPaths = eventPaths.slice(0, eventPaths.length - result.eventPropertyNames.length);
            const path = prevPaths.concat(result.expressionPropertyNames);
            const currentRows = this.buildCurrentRows(result.eventTablePaths, path);
            paths.push(path);
            this.output(event, expressionObject, currentRows, effector, paths);
        }
        else {
            if (result.eventFromChildren === true) {
                if (result.distance > 1) {
                    return;
                }
                // 下级表值变化影响到了上级表的表达式
                const prevPaths = eventPaths.slice(0, eventPaths.length - result.eventPropertyNames.length - 2);
                const path = prevPaths.concat(result.expressionPropertyNames);
                paths.push(path);
                const currentRows = this.buildCurrentRows(result.eventTablePaths, eventPaths);
                this.output(event, expressionObject, currentRows, effector, paths);
            }
            else if (result.eventFromParent === true) {
                if (result.distance > 1) {
                    console.warn(`[BindingDataValueChangeEventHandler]不支持多对多关系。`);
                    return;
                }
                // 上级表值变化影响到了下级表的表达式
                const prevPaths = eventPaths.slice(0, eventPaths.length - result.eventPropertyNames.length);
                // 添加下级表nodecode到路径中
                prevPaths.push(result.expressionTablePaths.slice(0).pop());
                // 遍历子表
                const bindingPaths = result.expressionTablePaths;
                const primaryKeyValue = eventPaths[0];
                if (!primaryKeyValue) {
                    return;
                }
                let object = this.frameContext.repository.entityCollection.getEntityById(primaryKeyValue);
                // prevPaths like [1,c,1.1,cc]
                for (let index = 1; index < prevPaths.length; index++) {
                    const propertyName = prevPaths[index];
                    if (object instanceof EntityList) {
                        object = object.get(propertyName);
                    }
                    else {
                        object = object[propertyName];
                    }
                }
                const list = object;
                if (list && list instanceof EntityList && list.count() > 0) {
                    for (let entity of list) {
                        if (entity && entity.primaryValue) {
                            const path = prevPaths.concat([entity.primaryValue]).concat(result.expressionPropertyNames);
                            const currentRows = this.buildCurrentRows(result.expressionTablePaths, path);
                            this.output(event, expressionObject, currentRows, effector, [path]);
                        }
                    }
                }
            }
            else {
                // 跨表
            }
        }
    }
    output(event, expressionObject, currentRows, effector, paths) {
        const context = this.buildContext(expressionObject, event, null, currentRows);
        const value = this.perform(expressionObject, context);
        if (value === undefined) {
            return;
        }
        expressionObject.result = value;
        if (expressionObject.id) {
            this.expressionResult.set(expressionObject.id, expressionObject.result);
        }
        EffectorManager.effect(effector, expressionObject, paths);
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        event = JSON.parse(JSON.stringify(event));
        let result = null;
        const bindingList = this.bindingData.getValue(paths);
        const eventEntityPath = this.getEntityPath(event.path);
        if (bindingList && bindingList.length > 0) {
            let primaryValue = bindingList.currentItem.primaryKeyValue || null;
            // 使用事件中的主键
            const childrenPaths = ExpressionUtil.getAvailableChildrenPathsFromEntityPaths(eventEntityPath, this.repository.entityTypeInfo);
            if (childrenPaths && childrenPaths.toString() === paths.toString()) {
                // 发生值变化的数据位于要获取当前行的子表中，此时事件行应该是发生值变化的数据id，而不是当前行id
                primaryValue = event.id || null;
                if (!primaryValue) {
                    primaryValue = this.getEventId(event.path, paths[paths.length - 1]);
                }
            }
            if (primaryValue) {
                const bindingObject = bindingList.findById(primaryValue);
                if (bindingObject) {
                    result = bindingObject.toJSON();
                }
            }
        }
        return result;
    }
}

/**
 * 删除数据时需要计算的表达式
 * 1、依赖被删除数据表的上级表达式（不考虑同表内的聚合依赖）
 */
class BindingDataRemoveObjectEventHandler extends EventHandler {
    /**
     * 过滤出需要计算的表达式
     * @param event event
     * @returns
     */
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            // 找到聚合相关表达式
            const expressions = this.expressionObjects.filter((expressionObject) => {
                if (expressionObject.ns !== event.ns || !expressionObject.deps || expressionObject.deps.length < 1) {
                    return false;
                }
                const info = this.analysis(event, expressionObject);
                if (!info) {
                    return false;
                }
                // event.path like [id:xxxx] or [id:xxxx,子表s]
                const eventTablePaths = this.buildEntityPath(event.path);
                // 主表删除
                if (eventTablePaths.length === 0) {
                    if (expressionObject.bindingType === Expression.ExpressionBindingType.Field) {
                        return false;
                    }
                }
                // 从表或从从表删除
                eventTablePaths.splice(0, 0, ENTITY_TEMPLATE);
                // eventEntityPath like ['ENTITY~','formEEUR1E1s'] // 从表新增
                // deps like ['ENTITY~/formEEUR1E1s/udt/udt_field','ENTITY~/formEEUR1E1s/ref/ref_udt/ref_udt_field']
                // 仅处理上级表达式
                if (info.eventTablePaths.length - 1 !== info.expressionTablePaths.length) {
                    return false;
                }
                // 不支持跨表
                if (!info.eventTablePaths.join(Expression.DEPENDENCY_SPLITER).startsWith(info.expressionTablePaths.join(Expression.DEPENDENCY_SPLITER))) {
                    return false;
                }
                const index = expressionObject.deps.findIndex((dep) => {
                    // 依赖
                    if (!dep.startsWith(eventTablePaths.join(Expression.DEPENDENCY_SPLITER))) {
                        return false;
                    }
                    const deps = dep.split(Expression.DEPENDENCY_SPLITER).filter(p => p).slice(1);
                    const dependPathInfo = this.getPathInfo(deps.join(Expression.DEPENDENCY_SPLITER));
                    if (dependPathInfo && dependPathInfo.paths.join(Expression.DEPENDENCY_SPLITER) === info.eventTablePaths.join(Expression.DEPENDENCY_SPLITER)) {
                        return true;
                    }
                    return false;
                });
                return index === -1 ? false : true;
            });
            return expressions;
        }
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 删除副作用器
     * @param event event
     * @param expressionObject 表达式
     * @returns
     */
    effect(event, expressionObject) {
        const effectTo = expressionObject.bindingType;
        const eventPath = this.cleanEventPath(event.path);
        const effector = this.effectorFactory.getEffector(expressionObject);
        if (!effector) {
            return;
        }
        const info = this.analysis(event, expressionObject);
        if (!info) {
            console.warn(`[BindingDataRemoveObjectEventHandler][analysis]获取路径信息失败。`);
            return;
        }
        const expressionPaths = expressionObject.path.split('/').filter(p => p);
        if (effectTo === Expression.ExpressionBindingType.Field) {
            const paths = [];
            const propertyPaths = expressionPaths.slice(info.expressionTablePaths.length);
            // 删除场景仅需要计算事件表上面的表
            if (info.distance !== 0) {
                // 表达式和事件不在同一个表，即下级表删除了一批数据
                if (info.eventFromParent === true) {
                    // 在过滤时这种情况的应该就排除掉了
                    console.warn(`[BindingDataRemoveObjectEventHandler][effect_error]`);
                    return;
                }
                else if (info.eventFromChildren === true) {
                    const prevPaths = eventPath.slice(0, eventPath.length - 1);
                    const path = prevPaths.concat(propertyPaths);
                    paths.push(path);
                }
                else {
                    console.warn(`[BindingDataRemoveObjectEventHandler][effect_error]`);
                    return;
                }
            }
            EffectorManager.effect(effector, expressionObject, paths);
        }
        else if (effectTo === Expression.ExpressionBindingType.State) {
            console.error('not supported！');
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}

class BindingDataLoadEventHandler extends EventHandler {
    filter(event) {
        // 过滤第一次空load
        if ((!event.path || event.path.length === 0) && event.value && Array.isArray(event.value) && event.value.length === 0) {
            return null;
        }
        // 数据加载完成后需要计算当前绑定路径下的只读、必填、校验表达式
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            const expressions = this.expressionObjects.filter((expressionObject) => {
                if (expressionObject.ns !== event.ns || (expressionObject.type !== Expression.ExpressionType.Readonly && expressionObject.type !== Expression.ExpressionType.Visible && expressionObject.type !== Expression.ExpressionType.Required && expressionObject.type !== Expression.ExpressionType.Validate)) {
                    return false;
                }
                const result = this.analysis(event, expressionObject);
                if (!result) {
                    return false;
                }
                return result.distance === 0 && result.isSameTable;
            });
            return expressions;
        }
        else {
            return null;
        }
    }
    /**
     * 发布事件
     * @param event event
     */
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
    /**
     * 获取子表事件行
     * @param paths
     * @param event
     * @returns
     */
    getCurrentRowByEvent(paths, event) {
        return this.getCurrentRowByPaths(paths);
    }
}

class BindingDataSelectionChangedEventHandler extends EventHandler {
    /**
     * 过滤出需要计算的表达式
     * @param event event
     * @returns
     */
    filter(event) {
        if (this.expressionObjects && this.expressionObjects.length > 0) {
            return this.expressionObjects.filter((expressionObject) => {
                const deps = expressionObject.deps;
                // 没有依赖的表达式不需要关注
                if (!deps || deps.length < 1) {
                    return false;
                }
                // 不依赖实体的表达式不需要关注
                let index = deps.findIndex(dep => dep.startsWith(ENTITY_TEMPLATE));
                if (index === -1) {
                    return false;
                }
                const result = this.analysis(event, expressionObject);
                if (!result) {
                    return false;
                }
                // 只关注从表行切换
                if (result.eventTablePaths.length !== 1) {
                    return false;
                }
                // 只关注从从表表达式
                if (result.expressionTablePaths.length !== 2) {
                    return false;
                }
                // 只关注事件直接下级的表达式，跨表的不需要关注
                if (!result.expressionTablePaths.join('/').startsWith(result.eventTablePaths.join('/'))) {
                    return false;
                }
                // 从从表表达式需要依赖上级表
                index = deps.findIndex(dep => dep.startsWith(`${ENTITY_TEMPLATE}/${result.eventTablePaths[0]}`));
                if (index === -1) {
                    return false;
                }
                return true;
            });
        }
        return null;
    }
    dispatch(event) {
        const expressions = this.filter(event);
        if (expressions && expressions.length > 0) {
            expressions.forEach((expressionObject) => {
                const entityContext = this.buildEntityContext(event, expressionObject);
                const context = this.buildContext(expressionObject, event, entityContext);
                const result = this.perform(expressionObject, context);
                if (result === undefined && !this.isValidateOrRequiredExpression(expressionObject)) {
                    return;
                }
                expressionObject.result = result;
                if (expressionObject.id) {
                    this.expressionResult.set(expressionObject.id, expressionObject.result);
                }
                this.effect(event, expressionObject);
            });
        }
    }
}

/**
 * 表单模块路径
 */
const ASSIGNER_TOKEN = new InjectionToken('@Farris expression assigner');
const EVENT_HANDLER_TOKEN = new InjectionToken('@Farris_event_handler');

class EventHandlerRegistry {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.handlers = this.viewModelContext.injector.get(EVENT_HANDLER_TOKEN);
    }
    /**
     * 实体值变化处理器
     */
    get entityValueChangedEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof EntityValueChangedEventHandler);
    }
    /**
     * 状态值变化处理器
     */
    get stateValueChangedEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof StateValueChangedEventHandler);
    }
    get repositoryAddEntityEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof RepositoryAddEntityEventHandler);
    }
    get repositoryRemoveEntityEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof RepositoryRemoveEntityEventHandler);
    }
    get entityUpdateEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof EntityUpdateEventHandler);
    }
    get repositoryLoadEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof RepositoryLoadEventHandler);
    }
    get bindingDataAppendEntityEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataAppendObjectEventHandler);
    }
    get bindingDataValueChangeEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataValueChangeEventHandler);
    }
    get bindingDataRemoveObjectEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataRemoveObjectEventHandler);
    }
    get bindingDataLoadEventHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataLoadEventHandler);
    }
    get bindingDataSelectionChangedHandler() {
        return this.handlers && this.handlers.find((handler) => handler instanceof BindingDataSelectionChangedEventHandler);
    }
}

class ExpressionEngineImpl {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.expressionObjects = new Array();
        this.injector = this.viewModelContext.injector;
        this.expressionRegistry = this.injector.get(ExpressionRegistry);
        this.expressionEventEmitter = this.injector.get(ExpressionEventEmitter);
        this.resolverRegistry = this.injector.get(ResolverRegistry);
        this.eventHandlerRegistry = this.injector.get(EventHandlerRegistry);
        this.resolveService = this.injector.get(ResolveService);
        this.expressionRegistry.expressions.subscribe((exprs) => {
            if (exprs && exprs.length > 0) {
                this.expressionObjects = exprs;
                // 解析表达式依赖
                this.resolveDependency();
            }
            this.attachEvent();
        });
    }
    attachEvent() {
        this.expressionEventEmitter.attach().subscribe((events) => {
            if (!events || events.length < 1 || !this.expressionObjects || this.expressionObjects.length < 1) {
                return;
            }
            events.forEach((event) => {
                const handler = this.getEventHandler(event);
                if (handler) {
                    handler.handleEvent(event, this.expressionObjects);
                }
                else {
                    Core.warn(`没有对应的事件处理器,event=${event.type}`);
                }
            });
        });
    }
    /**
     * 解析表达式依赖
     * @returns
     */
    resolveDependency() {
        if (!this.resolverRegistry || !this.resolverRegistry.resolvers || this.resolverRegistry.resolvers.length < 1 || !this.expressionObjects || this.expressionObjects.length < 1 || !Array.isArray(this.expressionObjects)) {
            return;
        }
        this.expressionObjects.forEach((expressionObject) => {
            const expression = expressionObject.expression;
            const dependencies = this.resolveService.resolve(expression);
            expressionObject.deps = dependencies;
        });
    }
    /**
     * 获取表达式事件处理器
     * @param event event
     * @returns
     */
    getEventHandler(event) {
        if (event.type === Expression.EventType.ValueChanged) {
            // 实体值变化
            if (event.source === Expression.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataValueChangeEventHandler;
            }
            else if (event.source === Expression.EventSource.Field) {
                return this.eventHandlerRegistry.entityValueChangedEventHandler;
            }
            else if (event.source === Expression.EventSource.State) {
                return this.eventHandlerRegistry.stateValueChangedEventHandler;
            }
        }
        else if (event.type === Expression.EventType.Append) {
            if (event.source === Expression.EventSource.Repository || event.source === Expression.EventSource.Field) {
                return this.eventHandlerRegistry.repositoryAddEntityEventHandler;
            }
            else if (event.source === Expression.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataAppendEntityEventHandler;
            }
        }
        else if (event.type === Expression.EventType.Remove) {
            if (event.source === Expression.EventSource.Repository || event.source === Expression.EventSource.Field) {
                return this.eventHandlerRegistry.repositoryRemoveEntityEventHandler;
            }
            else if (event.source === Expression.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataRemoveObjectEventHandler;
            }
        }
        else if (event.type === Expression.EventType.Update) {
            if (event.source === Expression.EventSource.Repository) {
                return this.eventHandlerRegistry.entityUpdateEventHandler;
            }
        }
        else if (event.type === Expression.EventType.Load) {
            if (event.source === Expression.EventSource.Repository || event.source === Expression.EventSource.Field) {
                return this.eventHandlerRegistry.repositoryLoadEventHandler;
            }
            else if (event.source === Expression.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataLoadEventHandler;
            }
        }
        else if (event.type === Expression.EventType.SelectionChanged) {
            if (event.source === Expression.EventSource.BindingData) {
                return this.eventHandlerRegistry.bindingDataSelectionChangedHandler;
            }
        }
        return null;
    }
}

/**
 * 表达式计算结果
 */
class ExpressionResult {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
    }
    /**
     * 更新表达式的值
     * @param expressionId 表达式id
     * @param result
     */
    set(expressionId, result) {
        this[expressionId] = result;
    }
}

class ExpressionManager {
    constructor(frameContext) {
        this.frameContext = frameContext;
        this.injector = this.frameContext.injector;
        this.resolveService = this.injector.get(ResolveService);
        this.expressionExecutor = this.injector.get(ExpressionExecutor);
        this.expressionRegistry = this.injector.get(ExpressionRegistry);
        this.expressionResult = this.injector.get(ExpressionResult);
        this.messageService = this.injector.get(MESSAGE_SERVICE_TOKEN, null);
        this.notifyService = this.injector.get(NOTIFY_SERVICE_TOKEN, null);
    }
    /**
     * 根据表达式id进行计算
     * @param expressionId 表达式id
     * @param viewModel viewModel
     * @param rowData rowData
     * @returns
     */
    eval(expressionId, viewModel, rowData) {
        const expressionObject = this.expressionRegistry.getExpressionById(expressionId);
        if (expressionObject) {
            const customContext = {};
            const bindingPath = viewModel && viewModel.bindingPath || null;
            if (bindingPath && rowData) {
                const bindingPaths = bindingPath.split('/').filter(p => p);
                const bindingList = this.frameContext.bindingData.getValue(bindingPaths);
                let primaryKey = 'id';
                if (bindingList) {
                    primaryKey = bindingList.primaryKey;
                }
                const primaryValue = rowData[primaryKey];
                if (primaryValue) {
                    customContext.currentRows = [{ bindingPath: bindingPaths.join('/'), primaryValue }];
                }
            }
            const result = this.execute(expressionObject.expression, customContext);
            this.expressionResult.set(expressionId, result);
            return result;
        }
        else {
            // console.warn('ExpressionManager 执行失败，未获取到表达式!');
        }
        return undefined;
    }
    validate(expressionId, options) {
        const expressionObject = this.expressionRegistry.getExpressionById(expressionId);
        if (expressionObject) {
            const patch = options && options.patch || null;
            const customContext = {};
            if (patch) {
                customContext.patch = patch;
            }
            const currentRow = options.currentRow || null;
            if (currentRow) {
                customContext.currentRows = customContext.currentRows || [];
                customContext.currentRows.push(currentRow);
            }
            const result = this.execute(expressionObject.expression, customContext);
            this.expressionResult.set(expressionId, result);
            return result;
        }
        else {
            console.warn('ExpressionManager 执行失败，未获取到表达式!');
        }
        return undefined;
    }
    /**
     * 帮助前封装
     * @param event
     */
    onDataPicking(configs) {
        const expressionId = configs && configs.expressionId || null;
        if (!expressionId) {
            console.warn(`ExpressionManager 相关表达式设置错误，没有表达式编号。`);
            return of(true);
        }
        const result = this.eval(expressionId);
        if (!result) {
            const expressionObject = this.expressionRegistry.getExpressionById(expressionId);
            if (!expressionObject) {
                console.warn(`ExpressionManager 无法找到对应的表达式${expressionId}`);
                return of(true);
            }
            const messageType = expressionObject.messageType || Expression.MessageType.warning;
            const message = expressionObject.message;
            if (message) {
                this.notifyService[messageType](message, { hideTitle: true });
            }
            return EMPTY$1;
        }
        return of(result);
    }
    /**
     * 执行表达式计算
     * @param expression 表达式
     * @param customContext 自定义上下文
     * @returns
     */
    execute(expression, customContext) {
        const deps = this.resolveService.resolve(expression);
        const groupDependencies = ExpressionUtil.getGroupFunctionDependency(expression, this.frameContext.repository.entityTypeInfo);
        const entityContext = this.buildEntityContext(deps, groupDependencies, customContext);
        const stateContext = this.buildStateContext();
        const data = customContext && customContext.contexts || null;
        const context = Object.assign({ [this.entityOriginalNodeCode]: entityContext }, stateContext, { frameContext: this.frameContext, bindingData: this.frameContext.bindingData, repository: this.frameContext.repository }, data);
        if (!entityContext) {
            return undefined;
        }
        return this.expressionExecutor.eval(expression, context);
    }
    /**
     * 执行表达式（返回可观察对象）
     * @param expression 表达式
     * @param customContext 自定义上下文
     * @returns
     */
    executeAsync(expression, customContext) {
        const result = this.execute(expression, customContext);
        return of(result);
    }
    /**
     * 构造实体上下文
     * @param deps
     * @param groupDependencies
     * @param context
     * @returns
     */
    buildEntityContext(deps, groupDependencies, context) {
        const currentRows = context && context.currentRows || null;
        const index = deps.findIndex((dep) => {
            const isEntityDependency = this.isEntityDependency(dep);
            // 如果依赖的是state，无需处理，现在需要确定的是返回多少实体的问题，和state没有关系
            // 表达式依赖了实体
            if (isEntityDependency) {
                const isGroupDependency = groupDependencies.findIndex(item => item === dep) !== -1;
                // 是聚合依赖
                if (isGroupDependency) {
                    const dependencyLength = dep.split('/').filter(p => p).length - 1;
                    if (dependencyLength === 1) {
                        // 聚合了主表字段，所有主表数据都需要参与运算，此时已经确定计算的实体上下文了。
                        return true;
                    }
                    else {
                        // 聚合了子表字段，只需要传递当前实体
                        return false;
                    }
                }
                else {
                    // 当前依赖不是聚合，只需要传递当前实体
                    return false;
                }
            }
            return false;
        });
        const isGroupdMainEntity = index !== -1;
        const options = {};
        if (currentRows && currentRows.length > 0) {
            currentRows.forEach((currentRow) => {
                options[currentRow.bindingPath || '/'] = currentRow.primaryValue;
            });
        }
        const entity = this.getEntity(options);
        const patch = context && context.patch || null;
        if (!entity) {
            return null;
        }
        if (patch && Object.keys(patch).length > 0) {
            Object.keys(patch).forEach((key) => {
                const paths = key.split('/').filter(p => p);
                const value = patch[key];
                this.setValue(entity, paths, value);
            });
        }
        if (isGroupdMainEntity) {
            const collection = this.frameContext.repository.entityCollection.toJSON();
            entity['__type__'] = 'List';
            entity['__items__'] = collection;
        }
        return entity;
    }
    setValue(target, paths, value) {
        if (paths.length === 1) {
            target[paths[0]] = value;
        }
        else {
            const propertyName = paths.pop();
            const result = paths.reduce((object, path) => {
                return object && object[path];
            }, target);
            result[propertyName] = value;
        }
    }
    /**
     * 是否为实体依赖
     * @param dep
     * @returns
     */
    isEntityDependency(dep) {
        return dep.startsWith(ENTITY_TEMPLATE);
    }
    /**
     * 获取实体
     * @param options
     * @returns
     */
    getEntity(options) {
        const entityTypeInfo = this.frameContext.repository.entityTypeInfo;
        const bindingData = this.frameContext.bindingData;
        const childrenEntityPaths = [];
        let entity = null;
        if (options['/']) {
            // 修正主表
            entity = this.frameContext.bindingData.list.findById(options['/']);
            if (entity) {
                entity = entity.toJSON();
            }
        }
        else {
            entity = this.frameContext.bindingData.list.currentItem.toJSON();
        }
        if (!entity) {
            return null;
        }
        ExpressionUtil.getChildrenEntityPaths(entityTypeInfo, childrenEntityPaths);
        entity['__type__'] = 'Entity';
        if (!childrenEntityPaths || childrenEntityPaths.length < 1) {
            return entity;
        }
        // 找到所有子表
        childrenEntityPaths.forEach((paths) => {
            let row = null;
            if (options && options[paths.join('/')]) {
                // 不应该使用bindingData，这样就默认使用了当前行
                const bindingList = bindingData.getValue(paths);
                const currentRowId = options[paths.join('/')];
                let currentRow = null;
                if (currentRowId !== bindingList.currentId) {
                    currentRow = bindingList.findById(currentRowId);
                }
                else {
                    currentRow = bindingList.currentItem;
                }
                if (currentRow && currentRow.primaryKeyValue) {
                    row = currentRow.toJSON();
                }
            }
            else {
                // 如果上级表已经切换了当前行，那么下级表也应该切换
                const parentTableCurrentRowChanged = options && !!Object.keys(options).find(path => {
                    const fullPath = path.split('/').join('/');
                    return paths.join('/').startsWith(fullPath);
                }) || false;
                if (parentTableCurrentRowChanged) {
                    const primaryValue = options && options['/'] || bindingData.list.currentId;
                    const entity = this.frameContext.repository.entityCollection.getEntityById(primaryValue);
                    const fullPaths = [];
                    const data = paths.reduce((object, path) => {
                        fullPaths.push(path);
                        const item = object && object[path];
                        if (item) {
                            const currentRowId = options && options[fullPaths.join('/')] || item.items[0] && item.items[0].primaryValue || null;
                            if (currentRowId) {
                                const currentRow = item.get(currentRowId);
                                return currentRow || null;
                            }
                        }
                        return null;
                    }, entity);
                    if (data) {
                        row = data.toJSON();
                    }
                    else {
                        row = {};
                    }
                }
                else {
                    row = ExpressionUtil.getCurrentRowByPaths(paths, bindingData);
                }
            }
            const propertyName = paths.pop();
            let parent = paths.reduce((object, path) => {
                return object && object[path] || null;
            }, entity);
            const list = parent[propertyName];
            const node = Object.assign({ __items__: [] }, row && row || {}, { __type__: 'List' });
            node.length = () => node.__items__.length;
            if (list && Array.isArray(list)) {
                node.__items__ = [].concat(list);
            }
            parent[propertyName] = node;
        });
        return entity;
    }
    /**
     * 获取主实体原始字段名
     */
    get entityOriginalNodeCode() {
        const repository = this.injector.get(Repository);
        return repository && repository.entityTypeInfo && repository.entityTypeInfo.entityInfo && repository.entityTypeInfo.entityInfo.originalCode || null;
    }
    /**
     * 构造变量上下文
     * @param event
     * @returns
     */
    buildStateContext() {
        const result = {};
        if (this.frameContext) {
            const rootFrameContext = this.frameContext.getVirtualRootFrameContext();
            if (rootFrameContext) {
                const uiState = rootFrameContext.viewModel.uiState;
                const propertyNames = Object.getOwnPropertyNames(uiState) || [];
                propertyNames.forEach((prop) => {
                    if (prop.match(/^[a-zA-Z0-9_\$]+$/g) !== null) {
                        result[prop] = uiState[prop];
                    }
                });
            }
        }
        return result;
    }
}

;
class ExpressionResultFactory {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.injector = this.viewModelContext.injector;
        this.expressionRegistry = this.injector.get(ExpressionRegistry);
        this.expressionManager = this.injector.get(ExpressionManager);
        this.expressionResult = this.injector.get(ExpressionResult);
        this.registeEvent();
    }
    registeEvent() {
        this.expressionRegistry.expressions.subscribe((expressionObjects) => {
            // 加载完表达式之后做一次计算
            expressionObjects.forEach((expressionObject) => {
                if (expressionObject.deps && expressionObject.deps.length > 0) {
                    return;
                }
                const result = this.expressionManager.eval(expressionObject.id);
                this.expressionResult[expressionObject.id] = result;
            });
        });
    }
}

class EffectUtil {
    static getFormValueByPath(path, viewModel) {
        if (!viewModel)
            return null;
        if (!path)
            return null;
        if (!viewModel.bindingData)
            return null;
        // 主表
        if (viewModel.bindingData.bindingPath === '/') {
            return viewModel.form.getFormValueByBindPath(path);
        }
        // 子表
        if (viewModel.bindingData.bindingPath && viewModel.bindingData.bindingPath.length > 1) {
            const idnex = path.indexOf(viewModel.bindingData.bindingPath);
            if (idnex == 0) {
                path = path.replace(viewModel.bindingData.bindingPath + '/', '');
                return viewModel.form.getFormValueByBindPath(path);
            }
        }
        return null;
    }
}

class ReadonlyEffector {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.ns = this.viewModelContext.injector.get(NAMESPACE, '');
    }
    effect(path, value, options) {
        let viewModelContext;
        if (options.viewModelId) {
            viewModelContext = this.viewModelContext.appContext.viewModelContextManager.getContextById(options.viewModelId);
        }
        else {
            return;
        }
        if (!viewModelContext)
            return;
        if (!viewModelContext.form)
            return;
        const form_anme = EffectUtil.getFormValueByPath(path, viewModelContext).form_name;
        if (!form_anme) {
            return;
        }
        if (value === true) {
            form_anme['readonly'] = true;
        }
        else {
            form_anme['readonly'] = false;
        }
        viewModelContext.form.changes.next({ type: 'validateFieldsFinished' });
    }
}

class ValidateEffector {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.ns = this.viewModelContext.injector.get(NAMESPACE, '');
    }
    effect(path, value, options) {
        //根据路径寻找字段
        let viewModelContext;
        if (options.viewModelId) {
            viewModelContext = this.viewModelContext.appContext.viewModelContextManager.getContextById(options.viewModelId);
        }
        else {
            return;
        }
        if (!viewModelContext)
            return;
        if (!viewModelContext.form)
            return;
        const formControl = EffectUtil.getFormValueByPath(path, viewModelContext);
        const form_name = formControl.form_name;
        if (!form_name) {
            return;
        }
        // 只认false  为flase认为验证不过
        if (value === false && options.eventType !== Expression.EventType.Append && options.eventType !== Expression.EventType.Load) {
            form_name.validationResult = { passing: !value, message: options.message };
        }
        else if (value === true) {
            form_name.validationResult = { passing: true, message: '' };
        }
        const validators = [{ "type": "expression", "constraints": [options.expressionId], message: options.message }];
        viewModelContext.form.addValidate(formControl.bindingPath, formControl.name);
        form_name.pushValidatorFnforValidate(validators, true);
    }
}

class RequiredEffector {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.ns = this.viewModelContext.injector.get(NAMESPACE, '');
    }
    effect(path, value, options) {
        let viewModelContext;
        if (options.viewModelId) {
            viewModelContext = this.viewModelContext.appContext.viewModelContextManager.getContextById(options.viewModelId);
        }
        else {
            return;
        }
        if (!viewModelContext)
            return;
        if (!viewModelContext.form)
            return;
        const formControl = EffectUtil.getFormValueByPath(path, viewModelContext);
        let form_name = formControl.form_name;
        if (!form_name) {
            return;
        }
        const validators = [{ "type": "required", "constraints": [true], message: options.message || '必填' }];
        if (value === true) {
            viewModelContext.form.addValidate(formControl.bindingPath, formControl.name);
            form_name.pushValidatorFnforRequired(validators, true);
            form_name.required = true;
        }
        else if (value === false) {
            form_name.required = false;
            if (form_name.getValidatorFn() && form_name.getValidatorFn().length >= 1) {
                //去除必填
                form_name.resetValidatorFnforRequired();
                if (form_name.validationResult && form_name.validationResult.type === 'required') {
                    form_name.validationResult = { passing: true, message: '' };
                }
            }
        }
        viewModelContext.form.changes.next({ type: 'validateFieldsFinished' });
    }
}

class VisibleEffector {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.ns = this.viewModelContext.injector.get(NAMESPACE, '');
    }
    effect(path, value, options) {
        let viewModelContext;
        if (options.viewModelId) {
            viewModelContext = this.viewModelContext.appContext.viewModelContextManager.getContextById(options.viewModelId);
        }
        else {
            return;
        }
        if (!viewModelContext)
            return;
        if (!viewModelContext.form)
            return;
        const form_anme = EffectUtil.getFormValueByPath(path, viewModelContext).form_name;
        if (!form_anme) {
            return;
        }
        if (value === true) {
            form_anme['visible'] = true;
        }
        else {
            form_anme['visible'] = false;
        }
        viewModelContext.form.changes.next({ type: 'validateFieldsFinished' });
    }
}

class DependencyEffector {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.ns = this.viewModelContext.injector.get(NAMESPACE, '');
    }
    effect(path, value, options) {
        let viewModelContext;
        if (options.viewModelId) {
            viewModelContext = this.viewModelContext.appContext.viewModelContextManager.getContextById(options.viewModelId);
        }
        else {
            return;
        }
        if (!viewModelContext.form)
            return;
        const formControl = EffectUtil.getFormValueByPath(path, viewModelContext);
        let form_name = formControl.form_name;
        if (!form_name) {
            return;
        }
        if (value === true) {
            form_name.value = null;
            form_name.validationResult = { passing: value, message: '' };
        }
    }
}

class EffectorFactory {
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.injector = this.viewModelContext.injector;
        this.effectorRegistry = this.injector.get(EffectorRegistry);
    }
    getEffector(expressionObject) {
        const path = expressionObject.path;
        const ns = expressionObject.ns;
        const bindingType = expressionObject.bindingType;
        const type = expressionObject.type;
        const nsEffectors = this.effectorRegistry.effectors.filter((effector) => effector.ns == ns);
        // 计算表达式
        if (type === Expression.ExpressionType.Compute) {
            if (bindingType === Expression.ExpressionBindingType.Field) {
                return nsEffectors.find((effector) => effector instanceof RepositoryEffector);
            }
            else if (bindingType === Expression.ExpressionBindingType.State) {
                return nsEffectors.find((effector) => effector instanceof UIStateEffector);
            }
            else {
                throw new Error(`不支持的绑定字段类型：${bindingType}`);
            }
        }
        else if (type === Expression.ExpressionType.Readonly) {
            // 只读表达式
            return nsEffectors.find((effector) => effector instanceof ReadonlyEffector);
        }
        else if (type === Expression.ExpressionType.Dependency) {
            // 依赖表达式
            return nsEffectors.find((effector) => effector instanceof DependencyEffector);
        }
        else if (type === Expression.ExpressionType.Relative) {
            // 关联表达式
            // return nsEffectors.find((effector: Expression.Effector) => effector instanceof RelativeEffector);
        }
        else if (type === Expression.ExpressionType.Validate) {
            // 校验表达式
            return nsEffectors.find((effector) => effector instanceof ValidateEffector);
        }
        else if (type === Expression.ExpressionType.Required) {
            // 必填表达式
            return nsEffectors.find((effector) => effector instanceof RequiredEffector);
        }
        else if (type === Expression.ExpressionType.Visible) {
            // 显隐表达式
            return nsEffectors.find((effector) => effector instanceof VisibleEffector);
        }
        else {
            // Core.warn(`EffectorFactory 没有找到对应的副作用器 ${type}`);
            return null;
        }
    }
}

/**
 * Resolver
 */
const VIEW_MODEL_EXPRESSION_RESOLVER_PROVIDERS = [
    { provide: RESOLVER_TOKEN, useClass: EntityDependencyResolver, multi: true, deps: [ViewModelContext] },
    { provide: RESOLVER_TOKEN, useClass: StateDependencyResolver, multi: true, deps: [ViewModelContext] },
    { provide: RESOLVER_TOKEN, useClass: CommentDependencyResolver, multi: true, deps: [ViewModelContext] },
];
/**
 * ChangeListener
 */
const VIEW_MODEL_EXPRESSION_LISTENER_PROVIDERS = [
    { provide: LISTENER_TOKEN, useClass: UIStateChangeListener, multi: true, deps: [ViewModelContext] },
    { provide: LISTENER_TOKEN, useClass: RepositoryChangeListener, multi: true, deps: [ViewModelContext] },
    { provide: LISTENER_TOKEN, useClass: BindingDataChangeListener, multi: true, deps: [ViewModelContext] }
];
/**
 * EventHandler
 */
const VIEW_MODEL_EXPRESSION_EVENT_HANDLER_PROVIDERS = [
    { provide: EVENT_HANDLER_TOKEN, useClass: RepositoryAddEntityEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: RepositoryRemoveEntityEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: EntityValueChangedEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: StateValueChangedEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: RepositoryLoadEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: EntityUpdateEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataAppendObjectEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataValueChangeEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataRemoveObjectEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataLoadEventHandler, multi: true, deps: [ViewModelContext] },
    { provide: EVENT_HANDLER_TOKEN, useClass: BindingDataSelectionChangedEventHandler, multi: true, deps: [ViewModelContext] },
];
/**
 * Effector
 */
const VIEW_MODEL_EXPRESSION_EFFECTOR_PROVIDERS = [
    { provide: EFFECTOR_TOKEN, useClass: RepositoryEffector, multi: true, deps: [ViewModelContext] },
    { provide: EFFECTOR_TOKEN, useClass: UIStateEffector, multi: true, deps: [ViewModelContext] },
    { provide: EFFECTOR_TOKEN, useClass: ReadonlyEffector, multi: true, deps: [ViewModelContext] },
    { provide: EFFECTOR_TOKEN, useClass: ValidateEffector, multi: true, deps: [ViewModelContext] },
    { provide: EFFECTOR_TOKEN, useClass: RequiredEffector, multi: true, deps: [ViewModelContext] },
    { provide: EFFECTOR_TOKEN, useClass: VisibleEffector, multi: true, deps: [ViewModelContext] },
    { provide: EFFECTOR_TOKEN, useClass: DependencyEffector, multi: true, deps: [ViewModelContext] }
];
const VIEW_MODEL_EXPRESSION_PROVIDERS = [
    { provide: ResolverRegistry, useClass: ResolverRegistry, deps: [ViewModelContext] },
    { provide: ResolveService, useClass: ResolveService, deps: [ViewModelContext] },
    { provide: ListenerRegistry, useClass: ListenerRegistry, deps: [ViewModelContext] },
    { provide: Listeners, useClass: Listeners, deps: [ViewModelContext] },
    { provide: EventHandlerRegistry, useClass: EventHandlerRegistry, deps: [ViewModelContext] },
    { provide: EffectorRegistry, useClass: EffectorRegistry, deps: [ViewModelContext] },
    { provide: EffectorFactory, useClass: EffectorFactory, deps: [ViewModelContext] },
    { provide: ExpressionRegistry, useClass: ExpressionRegistry, deps: [ViewModelContext] },
    { provide: ExpressionEventEmitter, useClass: ExpressionEventEmitter, deps: [ViewModelContext] },
    { provide: ExpressionExecutor, useClass: ExpressionExecutor, deps: [ViewModelContext] },
    { provide: ExpressionManager, useClass: ExpressionManager, deps: [ViewModelContext] },
    { provide: ExpressionResult, useClass: ExpressionResult, deps: [ViewModelContext] },
    { provide: ExpressionResultFactory, useClass: ExpressionResultFactory, deps: [ViewModelContext] },
    { provide: ExpressionEngineImpl, useClass: ExpressionEngineImpl, deps: [ViewModelContext] },
    ...VIEW_MODEL_EXPRESSION_RESOLVER_PROVIDERS,
    ...VIEW_MODEL_EXPRESSION_LISTENER_PROVIDERS,
    ...VIEW_MODEL_EXPRESSION_EVENT_HANDLER_PROVIDERS,
    ...VIEW_MODEL_EXPRESSION_EFFECTOR_PROVIDERS
];

class ControlsProxy {
    constructor() {
        this.controlsProxyMap = new Map();
    }
    setControlProxy(key, value) {
        this.controlsProxyMap.set(key, value);
    }
    getControlProxy(key) {
        return this.controlsProxyMap.get(key);
    }
}

class ViewModel {
    /**
     * 构造函数
     */
    constructor(injector, id) {
        /**
         * 扩展命令
         */
        this.extendCommands = new Map();
        this.injector = injector;
        this.id = id;
    }
    /**
     * 初始化
     */
    init() {
        this.initRepository();
        this.initContext();
        this.initBindingData();
        this.initUIState();
        this.intiStateMachine();
        this.initForm();
        this.initCommandBus();
        this.registerWithParent();
        this.initListeners();
        this.closeOldBeSession();
        this.initExpression();
        this.initControlsProxy();
        this.config();
    }
    config() {
        this.uiState.config(this.context);
    }
    initControlsProxy() {
        this.controlsProxy = this.injector.get(ControlsProxy);
    }
    initRepository() {
        this.repository = this.injector.get(Repository);
    }
    initContext() {
        this.context = this.injector.get(ViewModelContext);
        this.context.init(this);
    }
    initExpression() {
        const appContext = this.context.appContext;
        const allViewModelContexts = appContext.viewModelContextManager.getContexts();
        const existedViewModelContext = allViewModelContexts.find((viewModelContext) => {
            if (viewModelContext.expressionEngineImpl) {
                return true;
            }
            else {
                return false;
            }
        });
        if (existedViewModelContext) {
            this.expressionEngineImpl = existedViewModelContext.expressionEngineImpl;
            this.expressionManager = existedViewModelContext.expressionManager;
            this.expressionResult = existedViewModelContext.expressionResult;
            return;
        }
        this.expressionEngineImpl = this.injector.get(ExpressionEngineImpl, null);
        this.expressionManager = this.injector.get(ExpressionManager, null);
        const expressionResultFactory = this.injector.get(ExpressionResultFactory, null);
        this.expressionResult = this.injector.get(ExpressionResult, null);
    }
    initBindingData() {
        this.bindingData = this.context.injector.get(BindingData);
        this.entityValueChangingListeners = new Map();
        this.entityValueChangedListeners = new Map();
        if (this.bindingData) {
            this.bindingData.setValueChangeInvokerFactory((paths) => {
                return (preValue, value, entityChanged, primaryValue) => {
                    const plainPath = '/' + paths.join('/');
                    let command;
                    if (entityChanged === false) {
                        command = this.entityValueChangingListeners[plainPath];
                    }
                    else {
                        command = this.entityValueChangedListeners[plainPath];
                    }
                    if (!!command) {
                        const change = {
                            paths: paths,
                            preValue: preValue,
                            value: value,
                            changed: entityChanged
                        };
                        const commands = command.split(';').filter(p => p);
                        let valueChangeSuccess = true;
                        return from(commands).pipe(concatMap(item => {
                            if (!valueChangeSuccess) {
                                return EMPTY$1;
                            }
                            return this[item](change).pipe(tap((result) => {
                                valueChangeSuccess = result;
                            }));
                        }), every((result) => result));
                    }
                    else {
                        return of(true);
                    }
                };
            });
        }
        const repositoryName = this.repository.name;
        const bindingDataManager = this.context.appContext.bindingDataManager;
        const repositoryBindingData = bindingDataManager.getBindingDataByName(repositoryName);
        this.bindingData.initByBindingList(repositoryBindingData.list, this.context, repositoryBindingData.dataTypeInfo);
    }
    initUIState() {
        this.uiState = this.injector.get(UIState);
    }
    intiStateMachine() {
        this.stateMachine = this.injector.get(StateMachine, null);
        if (!this.stateMachine) {
            return;
        }
        this.stateMachine.init(this.context);
    }
    initForm() {
        this.form = this.injector.get(Form, null);
        this.form.init();
    }
    initCommandBus() {
        this.commandBus = this.injector.get(CommandBus);
        this.extendCommandMethods();
    }
    extendCommandMethods() {
        this.ngCommands = MetadataUtil.getPropsMetadatasByName(this.constructor, COMMAND_METHOD_META);
        this.keybindingMap = new Map();
        Object.keys(this.ngCommands).forEach((propName) => {
            const ngCommand = this.ngCommands[propName];
            Object.defineProperty(this, propName, {
                value: (eventParams) => {
                    const command = {
                        name: ngCommand.name,
                        params: ngCommand.params,
                        paramDescriptions: ngCommand.paramDescriptions,
                        eventParam: eventParams || null
                    };
                    return this.commandBus.dispatch(command);
                }
            });
            if (ngCommand.keyBinding) {
                this.keybindingMap.set(propName, ngCommand.keyBinding);
            }
        });
    }
    /**
     * 注册扩展命令方法
     */
    registerExtendCommand(commandName, commandHandler) {
        Object.defineProperty(this, commandName, {
            value: (eventParams) => {
                return commandHandler(eventParams, this.context);
            }
        });
        this.extendCommands.set(commandName, commandHandler);
    }
    registerWithParent() {
        const parentContext = this.context.parent;
        if (!parentContext || !parentContext.viewModel || !parentContext.viewModel['childViewModels']) {
            return;
        }
        const parentViewModel = parentContext.viewModel;
        const className = this.constructor.name;
        const propName = parentViewModel['childViewModels'][className];
        parentViewModel[propName] = this;
    }
    /**
     * 关闭老的BeSession
     */
    closeOldBeSession() {
        const allViewModelContexts = this.context.appContext.viewModelContextManager.getContexts();
        if (allViewModelContexts.length === 1 && allViewModelContexts[0] === this.context) {
            this.context.repository.reset();
        }
    }
    /**
   * 从Form获取监听器
   */
    initListeners() {
        const extractPath = (bindingBasePath, bindingPath) => {
            return '/' + bindingBasePath.split('/').concat(bindingPath.split('.')).filter((item) => item.length > 0).join('/');
        };
        if (this.form) {
            const valueChangingListeners = this.form.getEntityValueChangingListeners();
            Object.keys(valueChangingListeners).forEach((bindingPath) => {
                const plainPath = extractPath(this.bindingPath, bindingPath);
                this.entityValueChangingListeners[plainPath] = valueChangingListeners[bindingPath];
            });
            const valueChangedListeners = this.form.getEntityValueChangedListeners();
            Object.keys(valueChangedListeners).forEach((bindingPath) => {
                const plainPath = extractPath(this.bindingPath, bindingPath);
                this.entityValueChangedListeners[plainPath] = valueChangedListeners[bindingPath];
            });
        }
    }
}

class ViewModelOptions {
}

class AppEventBus {
    /**
     * 构造函数
     */
    constructor() {
        this.eventBus = new Subject();
        this.subscriptionsMap = new Map();
    }
    triggerEvent(event) {
        this.eventBus.next(event);
    }
    subscribe(componentId, func, funcError) {
        if (this.subscriptionsMap.has(componentId) === false) {
            const subscription = this.eventBus.subscribe((value) => func(value), (value) => funcError(value));
            this.subscriptionsMap.set(componentId, subscription);
        }
    }
    unsubscribe(componentId) {
        if (this.subscriptionsMap.has(componentId) === true) {
            this.subscriptionsMap.get(componentId).unsubscribe();
            this.subscriptionsMap.delete(componentId);
        }
    }
    /**
     * 清除注册得指定key名监听器
     * @param keyStr 监听器key 默认值为listview上注册得
     * @returns
     */
    unsubscribeAllListview(keyStr = '-listview-extend') {
        if (this.subscriptionsMap.size == 0) {
            return;
        }
        // @ts-ignore: Unreachable code error
        for (let key of this.subscriptionsMap.keys()) {
            if (key.indexOf(keyStr) > 0) {
                this.subscriptionsMap.get(key).unsubscribe();
                this.subscriptionsMap.delete(key);
            }
        }
    }
}

const APP_BASE_PROVIDERS = [
    { provide: AppEventBus, useClass: AppEventBus, deps: [] },
    { provide: BindingDataManager, useClass: BindingDataManager, deps: [] },
    { provide: RepositoryManager, useClass: RepositoryManager, deps: [] },
    { provide: ViewModelContextManager, useClass: ViewModelContextManager, deps: [] },
    {
        provide: AppContext, useClass: AppContext,
        deps: [Injector, AppEventBus, RepositoryManager, BindingDataManager, ViewModelContextManager]
    }
];

const APP_CONTROL_STATE_PROVIDERS = [
    { provide: ControlStateInterceptorService, useClass: ControlStateInterceptorService, deps: [Injector] }
];
const VIEW_MODEL_CONTROL_STATE_PROVIDERS = [
    { provide: ControlStateListener, useClass: ControlStateListener, deps: [ViewModelContext] },
    { provide: ControlStateUpdater, useClass: ControlStateUpdater, deps: [ViewModelContext] }
];

class App {
    /**
     * 构造函数
     */
    constructor(options) {
        options.providers = options.providers || [];
        const appProviders = [
            ...APP_BASE_PROVIDERS,
            ...APP_VARIABLE_PROVIDERS,
            ...HTTP_PROVIDERS,
            ...APP_CONTROL_STATE_PROVIDERS,
            ...options.providers
        ];
        const appInjector = createInjector(appProviders);
        this.context = appInjector.get(AppContext);
    }
    /**
     * 启用ViewModel
     */
    createViewModel(options) {
        const providers = options.providers || [];
        const parent = options.parent || null;
        const mergedProviders = [
            { provide: ViewModelContext, useClass: ViewModelContext, deps: [] },
            { provide: ControlsProxy, useClass: ControlsProxy, deps: [] },
            ...VIEW_MODEL_COMMAND_PROVIDERS,
            ...VIEW_MODEL_EXPRESSION_PROVIDERS,
            ...VIEW_MODEL_CONTROL_STATE_PROVIDERS,
            ...providers
        ];
        const parentInjector = parent ? parent.injector : this.context.injector;
        const injector = createInjector(mergedProviders, parentInjector);
        const viewModel = injector.get(ViewModel);
        viewModel.init();
        return viewModel;
    }
}

/*
 * StateMachine变量解析
 * @Author: Witt
 * @Date: 2018-12-04 17:09:42
 * @Last Modified by: Witt
 * @Last Modified time: 2019-10-30 11:07:10
 */
/**
 * 解析辅助工具类
 */
class ParseUtil {
    /**
     * 获取应用上下文
     */
    static getAppContext(context) {
        if (context instanceof CommandContext) {
            return context.viewModelContext.appContext;
        }
        else if (context instanceof ViewModelContext) {
            return context.appContext;
        }
        else if (context instanceof AppContext) {
            return context;
        }
        else {
            throw new Error('上下文中找不到AppContext，请检查！');
        }
    }
    /**
     * 获取当前Frame的Context
     */
    static getFrameContext(context) {
        if (context instanceof CommandContext) {
            return context.viewModelContext;
        }
        else if (context instanceof ViewModelContext) {
            return context;
        }
        else {
            throw new Error('上下文中找不到FrameContext，请检查！');
        }
    }
    /**
     * 获取根Frame的Context
     */
    static getRootFrameContext(context) {
        const frameContext = this.getFrameContext(context);
        return frameContext.root;
    }
    /**
     * 根据frameId获取FrameContext
     */
    static getFrameContextById(context, frameId) {
        const appContext = this.getAppContext(context);
        return appContext.viewModelContextManager.getContextById(frameId);
    }
}

/**
 * 数据变量解析
 */
class DataVariableParser {
    /**
     * 解析变量
     * @param expression 表达式
     * @param context 上下文
     */
    parse(expression, context) {
        const appContext = ParseUtil.getAppContext(context);
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{DATA~${paths[0]}}`) {
            return this.getValue(paths[0], appContext);
        }
        // 2、其他情况：字符串替换
        paths.forEach((path) => {
            const searchValue = `{DATA~${path}}`;
            const replaceValue = this.getValue(path, appContext);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取路径
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const DATA_PATTERN_G = /\{DATA~(\S+?)\}/g;
        const dataVariables = expression.match(DATA_PATTERN_G);
        if (dataVariables === null) {
            return [];
        }
        // 提取后边的路径
        const DATA_PATTERN = /\{DATA~(\S+?)\}/;
        dataVariables.forEach(dataVariable => {
            const pathMatches = dataVariable.match(DATA_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取值
     * @param path 路径：/
     */
    getValue(path, appContext) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const frameContext = appContext.viewModelContextManager.getContextById(parts[0]);
        if (!frameContext) {
            throw new Error(`${path}不正确，请检查！`);
        }
        const bindingData = frameContext.bindingData;
        if (!bindingData) {
            throw new Error(`${path}不正确，请检查！`);
        }
        return bindingData.getValue(parts.slice(1));
    }
}

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
/**
 * 数据变量解析
 */
class UIStateVariableParser {
    /**
     * 解析变量
     * @param expression 形如：/frameId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const appContext = ParseUtil.getAppContext(context);
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{UISTATE~${paths[0]}}`) {
            return this.getUIState(paths[0], appContext);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{UISTATE~${path}}`;
            const replaceValue = this.getUIState(path, appContext);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取路径
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const UI_STATE_PATTERN_G = /\{UISTATE~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        if (uiStateVariables === null) {
            return [];
        }
        // 提取后边的路径
        const UI_STATE_PATTERN = /\{UISTATE~(\S+?)\}/;
        uiStateVariables.forEach((uiStateVariable) => {
            const pathMatches = uiStateVariable.match(UI_STATE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取UIState
     */
    getUIState(path, appContext) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const [frameId, stateName] = parts;
        const frameContext = appContext.viewModelContextManager.getContextById(frameId);
        let state = frameContext.uiState[stateName];
        if (state && state.constructor.toString().startsWith('function Date()')) {
            return this.formatDate(state);
        }
        for (let i = 2; i < parts.length; i++) {
            state = state[parts[i]];
            // 复杂对象一层层查找下去，如果某一层不存在，结果可以是undefined，但是要直接返回undefined避免报错。
            if (!state) {
                return state;
            }
        }
        return state;
    }
    /**
     * @todo：待删除
     */
    formatDate(value) {
        if (!value) {
            return '';
        }
        // 年
        const year = value.getFullYear();
        // 月
        let month = (value.getMonth() + 1).toString();
        month = month.length === 1 ? ('0' + month) : month;
        // 日
        let day = value.getDate().toString();
        day = day.length === 1 ? ('0' + day) : day;
        return `${year}-${month}-${day}`;
    }
}

/**
 * 状态机变量解析
 * @summary
 *
 * 解析策略：
 * 1、不带frameId，从顶层StateMachine中解析
 * {STATEMACHINE~/states/key}
 * {STATEMACHINE~/renderStates/key}
 *
 * 2、带frameId，从frameId对应的FrameContext的StateMachine中解析
 * {STATEMACHINE~/frameId/states/key}
 * {STATEMACHINE~/frameId/renderStates/key}
 *
 * 存在的问题：
 * 1、不带frameId从顶层StateMachine解析仅为了兼容，将来改为从当前FrameContext的StateMachine中解析；
 * 2、组合表单中顶层StateMachine是主表单的rootFrameContext的StateMachine，显然不合理（既成事实）；
 * 3、farmeId如果是states或renderStates，导致解析失败，几率很小，但又风险。
 */
class StateMachineVariableParser {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 解析变量
     * @param expression 变量：格式形如：/frameId/componentId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{STATEMACHINE~${paths[0]}}`) {
            return this.getValue(paths[0], context);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{STATEMACHINE~${path}}`;
            const replaceValue = this.getValue(path, context);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取Session变量名
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的StateMachine变量字符串
        const STATE_MACHINE_PATTERN_G = /\{STATEMACHINE~(\S+?)\}/g;
        const stateMachineVariables = expression.match(STATE_MACHINE_PATTERN_G);
        if (stateMachineVariables === null) {
            return [];
        }
        // 提取后边的路径
        const STATE_MACHINE_PATTERN = /\{STATEMACHINE~(\S+?)\}/;
        stateMachineVariables.forEach(sessionVariable => {
            const pathMatches = sessionVariable.match(STATE_MACHINE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取对应的值
     */
    getValue(path, context) {
        const pathObj = this.getPathObj(path);
        const stateMachine = this.getTargetStateMachine(pathObj.frameId, context);
        if (pathObj.type === 'currentState') {
            return stateMachine.context.state;
        }
        else if (pathObj.type === 'renderStates') {
            return stateMachine[pathObj.name];
        }
        else {
            throw new Error(`不支类型为${pathObj.type}的状态机变量`);
        }
    }
    /**
     * 解析path，并获取对应的StateMachine实例
     */
    getTargetStateMachine(frameId, context) {
        let targetFrameContext;
        if (frameId) {
            targetFrameContext = ParseUtil.getFrameContextById(context, frameId);
        }
        else {
            targetFrameContext = ParseUtil.getRootFrameContext(context);
        }
        if (!targetFrameContext || !targetFrameContext.stateMachine) {
            throw new Error('找不到对应的状态机实例，请检查！');
        }
        return targetFrameContext.stateMachine;
    }
    /**
     * 将Path解析为格式化的Path对象
     */
    getPathObj(path) {
        let parsedPathObj;
        const parts = this.splitPath(path);
        if (parts[0] === 'currentState' || parts[0] === 'renderStates') {
            parsedPathObj = {
                frameId: '',
                type: parts[0],
                name: parts[1]
            };
        }
        else {
            parsedPathObj = {
                frameId: parts[0],
                type: parts[1],
                name: parts[2]
            };
        }
        return parsedPathObj;
    }
    /**
     * 分隔Path
     */
    splitPath(path) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        return parts;
    }
}

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
/**
 * 命令变量解析
 * {COMMAND~/params/key}
 * {COMMAND~/results/taskName}
 */
class CommandVariableParser {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 解析变量
     * @param expression 变量：格式形如：/frameId/componentId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{COMMAND~${paths[0]}}`) {
            return this.getValue(paths[0], context);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{COMMAND~${path}}`;
            const replaceValue = this.getValue(path, context);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取Session变量名
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const UI_STATE_PATTERN_G = /\{COMMAND~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        if (uiStateVariables === null) {
            return [];
        }
        // 提取后边的路径
        const UI_STATE_PATTERN = /\{COMMAND~(\S+?)\}/;
        uiStateVariables.forEach(sessionVariable => {
            const pathMatches = sessionVariable.match(UI_STATE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取UIState
     */
    getValue(path, context) {
        if (context instanceof CommandContext === false) {
            throw new Error('当前上下文不支持COMMAND变量，请检查！');
        }
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const [type, name] = parts;
        if (type === 'params') {
            return context.command.params[name];
        }
        else if (type === 'results') {
            return context.results[name];
        }
    }
}

/**
 * 变量解析服务
 * 职责：
 * 1、解析字符串中的变量，并替换成相应的值；
 * 2、对表达式进行求值。
 *
 * @todo 对表达式求值的部分和表达式功能重叠，是否转移到表达式中？
 */
class VariableParseService {
    /**
     * 构造变量解析服务
     * @param parsers 解析器集合
     */
    constructor(parsers) {
        this.parsers = parsers;
    }
    /**
     * 解析表达式
     * @param expression 表达式
     * @param context 上下文
     */
    parse(target, context) {
        if (typeof target === 'string' && target.length > 0) {
            // 字符串，直接解析
            return this.parseExpression(target, context);
        }
        else if (Array.isArray(target)) {
            // 遍历数组
            target.forEach((item, itemIndex) => {
                if (typeof item === 'string') {
                    target[itemIndex] = this.parseExpression(item, context);
                }
                else {
                    target[itemIndex] = this.parse(item, context);
                }
            });
        }
        else if (typeof target === 'object' && target !== null) {
            // 遍历对象可枚举属性
            const keys = Object.keys(target);
            keys.forEach(key => {
                if (typeof target[key] === 'string') {
                    target[key] = this.parseExpression(target[key], context);
                }
                else {
                    target[key] = this.parse(target[key], context);
                }
            });
        }
        return target;
    }
    /**
     * 表达式求值
     */
    evaluate(expression, context) {
        const parsedExpression = this.parse(expression, context);
        return (new Function('return ' + parsedExpression))();
    }
    /**
     * 解析表达式
     * @param expression 表达式
     * @param context 上下文
     */
    parseExpression(expression, context) {
        // 空串直接返回
        if (expression === '') {
            return '';
        }
        this.parsers.forEach(parser => {
            if (typeof expression === 'string') {
                expression = parser.parse(expression, context);
            }
        });
        return expression;
    }
}

const APP_VARIABLE_PROVIDERS = [
    { provide: VARIABLE_PARSERS, useClass: DataVariableParser, multi: true, deps: [] },
    { provide: VARIABLE_PARSERS, useClass: UIStateVariableParser, multi: true, deps: [] },
    { provide: VARIABLE_PARSERS, useClass: StateMachineVariableParser, multi: true, deps: [] },
    { provide: VARIABLE_PARSERS, useClass: CommandVariableParser, multi: true, deps: [] },
    { provide: VariableParseService, useClass: VariableParseService, deps: [VARIABLE_PARSERS] },
];

/* eslint-disable no-case-declarations */
/**
 * 任务链接
 */
class TaskLink {
    /**
     * 构造函数
     */
    constructor(from, to, condition) {
        this.from = from;
        this.to = to;
        this.condition = condition;
    }
    /**
     * 是否能够
     */
    canLink(context) {
        const type = typeof this.condition;
        let canLink;
        switch (type) {
            case 'boolean':
                canLink = this.condition;
                break;
            case 'function':
                canLink = this.condition(context);
                break;
            case 'string':
                const parseService = context.viewModelContext.injector.get(VariableParseService);
                canLink = parseService.evaluate(this.condition, context);
                break;
            default:
                canLink = false;
                break;
        }
        return canLink;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-10-17 14:13:40
 * @Last Modified by: Witt
 * @Last Modified time: 2018-10-17 16:08:34
 */
/**
 * 任务执行流程
 */
class TaskFlow {
    constructor() {
        /**
         * 节点集合
         */
        this.nodes = [];
        /**
         * 边集合
         */
        this.links = [];
        // #endregion
    }
    // #region 节点操作
    /**
     * 添加节点
     */
    addNode(name, func) {
        const node = new TaskNode(name, func);
        this.nodes.push(node);
    }
    /**
     * 批量添加链接
     */
    addNodes(nodes) {
        this.nodes = this.nodes.concat(nodes);
    }
    /**
     * 在目标节点之前插入一个节点
     * @param target 目标节点名称
     * @param name 名称
     * @param func 函数
     */
    insertNode(target, name, func) {
        const index = this.findNodeIndex(target);
        const node = this.createNode(name, func);
        this.nodes.splice(index, 0, node);
    }
    /**
     * 在目标节点之前插入一个节点
     */
    appendNode(target, name, func) {
        const index = this.findNodeIndex(target) + 1;
        const node = this.createNode(name, func);
        this.nodes.splice(index, 0, node);
    }
    /**
     * 获取节点索引
     * @param name 名称
     */
    findNodeIndex(name) {
        return this.nodes.findIndex((node) => {
            return node.name === name;
        });
    }
    /**
     * 创建任务节点
     * @param name 名称
     * @param func 函数
     */
    createNode(name, func) {
        const node = new TaskNode(name, func);
        return node;
    }
    // #endregion
    // #region 链接操作
    /**
     * 添加链接
     * @param name 名称
     * @param func 函数
     */
    addLink(from, to, condition) {
        const link = this.createLink(from, to, condition);
        this.links.push(link);
    }
    /**
     * 批量添加链接
     */
    addLinks(links) {
        this.links = this.links.concat(links);
    }
    /**
     * 创建链接
     */
    createLink(from, to, condition) {
        const link = new TaskLink(from, to, condition);
        return link;
    }
    // #endregion
    // #region 流程控制
    /**
     * 获取下一个节点
     * @param from    源节点名称
     * @param context 上下文
     */
    getNext(from, context) {
        if (!from) {
            return this.nodes.shift();
        }
        // 符合满足条件的边
        const nextLink = this.links.find((link) => {
            return link.from === from && link.canLink(context);
        });
        if (!nextLink) {
            return;
        }
        return this.nodes.find((node) => {
            return node.name === nextLink.to;
        });
    }
    // #endregion
    // #region 其他方法
    /**
     * 克隆任务流
     */
    clone() {
        const taskFlow = new TaskFlow();
        taskFlow.addNodes(this.nodes);
        taskFlow.addLinks(this.links);
        return taskFlow;
    }
}

/**
 * Command上下文
 */
class CommandContext {
    /**
     * 构造函数
     * @param command 命令
     * @param viewModelContext 视图模型上下文
     */
    constructor(command, viewModelContext) {
        /**
         * 执行结果
         */
        this.results = {};
        this.command = command;
        this.viewModelContext = viewModelContext;
    }
}

/**
 * 命令处理抽象类，所有具体的命令处理类必须继承它，并实现schedule方法。
 */
class CommandHandler {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 初始化
     */
    init(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.parseService = viewModelContext.injector.get(VariableParseService);
        this.taskFlow = new TaskFlow();
        this.schedule();
    }
    /**
     * 执行任务
     * @param command 要执行的命令
     * @return 最后一个任务的执行结果
     * @todo：按功能拆分小函数
     */
    execute(command) {
        const lastTaskResult$ = new Subject();
        const taskFlow = this.taskFlow.clone();
        // setTimeout暂时不能去掉的原因：
        // 1、树表单加载数据，依赖TreeTableBinding里设置的全局变量，需要延后执行加载时机；
        // 2、关闭前命令需要延迟执行。
        setTimeout(() => {
            // 1、解析参数
            // 避免解析变量时修改了原始的command
            const { eventParam = null } = Object.assign({}, command);
            delete command.eventParam;
            const commandToExecute = JSON.parse(JSON.stringify(command));
            commandToExecute.params = this.parseService.parse(commandToExecute.params, this.viewModelContext);
            command.eventParam = eventParam;
            commandToExecute.eventParam = eventParam;
            // 2、串联任务流
            const initContext = new CommandContext(commandToExecute, this.viewModelContext);
            initContext.eventParams = command.eventParam || null;
            const context$ = new BehaviorSubject(initContext);
            let currentTask = taskFlow.getNext('', initContext);
            const highOrder$ = context$.pipe(concatMap((context) => {
                const result$ = currentTask.execute(context);
                return result$.pipe(take(1), map((result) => {
                    // 写入执行结果
                    context.results[currentTask.name] = result;
                    context.latestResult = result;
                    currentTask = taskFlow.getNext(currentTask.name, context);
                    // 操作控制流
                    if (currentTask) {
                        context$.next(context);
                    }
                    else {
                        context$.complete();
                    }
                    // 将结果流转换为context流
                    return context;
                }), throwIfEmpty(() => {
                    context$.complete();
                }));
            }));
            // 3、执行合并后的任务流
            highOrder$.pipe(takeLast(1)).subscribe({
                next: (context) => {
                    lastTaskResult$.next(context.latestResult);
                },
                error: (error) => {
                    this.displayError(error);
                    lastTaskResult$.error(error);
                },
                complete: () => {
                    lastTaskResult$.complete();
                },
            });
        }, 0);
        return lastTaskResult$;
    }
    /**
     * 显示错误信息
     */
    displayError(error) {
        if (!console || !console.error) {
            return;
        }
        if (!error) {
            error = 'unknown error';
        }
        console.error(error);
    }
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    addTask(name, func) {
        this.taskFlow.addNode(name, func);
    }
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    addLink(from, to, condition) {
        this.taskFlow.addLink(from, to, condition);
    }
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    insertTask(target, name, func) {
        throw new Error('Not Implemented');
    }
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    afterTask(target, name, func) {
        throw new Error('Not Implemented');
    }
    /**
     * 替换任务
     * @param  name 要替换的任务名称
     * @param  func 替换函数
     */
    replaceTask(name, func) {
        throw new Error('Not Implement');
    }
    /**
     * 调用方法
     */
    invoke(serviceInstance, method, args, context) {
        this.setContextToServiceInstance(serviceInstance, context);
        const parsedArgs = this.parseService.parse(args, context);
        return serviceInstance[method](...parsedArgs);
    }
    /**
     * 为服务设置命令上下文
     * @todo
     * 通过这种方式存在很大问题：
     * 1、会覆盖掉已有的context，给开发人员造成困扰和调试成本；
     * 2、服务中依赖了一个没有声明的对象，不符合面向对象的原则。
     * 建议解决方案：
     * 1、将context修改为某个特殊属性名；
     * 2、先检测服务上有没有一个CommandContext类型的context属性，有的话再赋值，
     *    这就要求需要使用context的服务需要是实现一个IContext接口。
     */
    setContextToServiceInstance(serviceInstance, context) {
        // 如果服务上已经存在context属性，并且该属性不是CommandContext类型，则不能覆盖
        const serviceContext = serviceInstance.context;
        if (serviceContext && (serviceContext instanceof CommandContext === false)) {
            return;
        }
        serviceInstance.context = context;
    }
}
/**
 * 命令处理器注入Token
 */
const COMMAND_HANDLERS_TOKEN = createInjectionToken('@Farris/devkit COMMAND_HANDLERS_TOKEN');

/**
 * 命令处理注册器相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理注册器
 */
class CommandHandlerRegistry {
    /**
     * 构造函数
     * @param handlers 命令处理实例数组
     */
    constructor(injector) {
        this.injector = injector;
        const handlers = this.injector.get(COMMAND_HANDLERS_TOKEN, null, InjectFlags.Optional);
        this.handlerMap = new Map();
        if (handlers) {
            handlers.forEach((handler) => {
                this.regist(handler);
            });
        }
    }
    /**
     * 添加命令处理
     * @param  commandName    命令名称
     * @param  commandHandler 命令处理实例
     */
    set(commandName, commandHandler) {
        if (this.handlerMap.has(commandName)) {
            throw new Error(commandName + '对应的CommandHandler已经存在');
        }
        this.handlerMap.set(commandName, commandHandler);
    }
    /**
     * 获取命令处理
     * @param   commandName 命令名称
     * @returns 命令处理实例
     */
    get(commandName) {
        if (this.handlerMap.has(commandName) === false) {
            throw new Error('找不到' + commandName + '对应的CommandHandler');
        }
        return this.handlerMap.get(commandName);
    }
    /**
     * 注册命令处理
     * @param handlers 命令处理实例
     */
    regist(commandHandler) {
        // 根据metadata获取对应的Command名称
        const handlerMetadata = MetadataUtil.getClassMetadataByName(commandHandler.constructor, COMMAND_HANDLER_META);
        if (!handlerMetadata) {
            throw new Error('CommandHandler必须指定要处理的命令名称');
        }
        const commandName = handlerMetadata.commandName;
        this.set(commandName, commandHandler);
    }
}

/**
 * 命令处理扩展相关
 * @author Witt<jiwt@inspur.com>
 */
class CommandHandlerExtender {
}
/**
 * 命令处理器扩展注入Token
 */
const COMMAND_HANDLER_EXTENDERS_TOKEN = createInjectionToken('@farris/devkit COMMAND_HANDLER_EXTENDERS_TOKEN');

/**
 * 命令处理扩展注册器相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理扩展注册器
 */
class CommandHandlerExtenderRegistry {
    /**
     * 构造函数
     * @param extenders 命令扩展实例数组
     */
    constructor(injector) {
        this.injector = injector;
        const extenders = this.injector.get(COMMAND_HANDLER_EXTENDERS_TOKEN, null, InjectFlags.Optional);
        this.extendersMap = new Map();
        if (extenders) {
            extenders.forEach((extender) => {
                this.regist(extender);
            });
        }
    }
    /**
     * 获取命令扩展实例数组
     * @param   commandName 命令名称
     * @returns 命令处理扩展实例数组
     */
    get(commandName) {
        if (this.extendersMap.has(commandName) === false) {
            return [];
        }
        return this.extendersMap.get(commandName);
    }
    /**
     * 添加命令扩展
     * @param commandName Command名称
     * @param extender    CommandHandlerExtender实例
     * @return void
     */
    set(commandName, extender) {
        if (this.extendersMap.has(commandName)) {
            // 如果commandName对应的扩展已经存在，则在扩展数组中追加
            this.extendersMap.get(commandName).push(extender);
        }
        else {
            // 如果不存在，则创建新的扩展数组，并追加
            this.extendersMap.set(commandName, [extender]);
        }
    }
    /**
     * 注册命令扩展
     * @param extender CommandHandlerExtender实例
     */
    regist(extender) {
        // 通过元数据获取要扩展的Comamnd名称
        const extenderMetadata = MetadataUtil.getClassMetadataByName(extender.constructor, COMMAND_HANDLER_EXTENDER_META);
        if (!extenderMetadata) {
            throw new Error('CommandHandlerExtender必须指定要扩展的命令名称');
        }
        const commandName = extenderMetadata.commandName;
        // 添加到Map中
        this.set(commandName, extender);
    }
}

/**
 * 命令处理器工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理器工厂
 */
class CommandHandlerFactory {
    /**
     * 构造函数
     * @param handlerRegistry  命令处理注册器
     * @param extenderRegistry 命令处理扩展注册器
     */
    constructor(handlerRegistry, extenderRegistry, viewModelContext) {
        this.handlerRegistry = handlerRegistry;
        this.extenderRegistry = extenderRegistry;
        this.viewModelContext = viewModelContext;
    }
    /**
     * 创建命令处理器
     * @param   commandName 命令名称
     * @returns 对应的命令处理器实例
     */
    create(commandName) {
        const rawHandler = this.handlerRegistry.get(commandName);
        rawHandler.init(this.viewModelContext);
        const extenders = this.extenderRegistry.get(commandName);
        // 遍历extenders，依次对handler进行扩展
        return extenders.reduce((handler, extender) => {
            return extender.extend(handler);
        }, rawHandler);
    }
}

/**
 * CommandBus相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * CommandBus用于派发Command，它接受一个Command实例，查找对应的CommandHandler，并执行。
 */
class CommandBus {
    /**
     * 构造函数
     */
    constructor(handlerFactory) {
        this.handlerFactory = handlerFactory;
        this.executingCommands = [];
        this.executingCommandCount$ = new BehaviorSubject(this.executingCommands.length);
    }
    /**
     * 派发命令
     * @param command 要派发的命令
     */
    dispatch(command) {
        const commandResult$ = new Subject();
        this.executeCommand(command).subscribe({
            next: (lastTaskResult) => {
                commandResult$.next(lastTaskResult);
                commandResult$.complete();
            },
            complete: () => {
                commandResult$.complete();
                this.removeCommandFromExecutingQueue(command);
            },
            error: (error) => {
                commandResult$.error(error);
                this.removeCommandFromExecutingQueue(command);
            }
        });
        return commandResult$;
    }
    /**
     * 执行命令并返回最后一个任务的执行结果流
     */
    executeCommand(command) {
        this.addCommandToExecutingQueue(command);
        const commandName = command.name;
        const handler = this.handlerFactory.create(commandName);
        const lastTaskResult$ = handler.execute(command);
        return lastTaskResult$;
    }
    /**
     * 添加到执行队列
     */
    addCommandToExecutingQueue(command) {
        this.executingCommands.push(command);
        this.executingCommandCount$.next(this.executingCommands.length);
    }
    /**
     * 从执行队列中移除
     */
    removeCommandFromExecutingQueue(command) {
        this.executingCommands = this.executingCommands.filter((executingCommand) => {
            return executingCommand !== command;
        });
        this.executingCommandCount$.next(this.executingCommands.length);
    }
}

const VIEW_MODEL_COMMAND_PROVIDERS = [
    {
        provide: CommandHandlerRegistry,
        useClass: CommandHandlerRegistry,
        deps: [Injector]
    },
    {
        provide: CommandHandlerExtenderRegistry,
        useClass: CommandHandlerExtenderRegistry,
        deps: [Injector]
    },
    {
        provide: CommandHandlerFactory,
        useClass: CommandHandlerFactory,
        deps: [CommandHandlerRegistry, CommandHandlerExtenderRegistry, ViewModelContext]
    },
    {
        provide: CommandBus,
        useClass: CommandBus,
        deps: [CommandHandlerFactory]
    }
];

/*
 * @Author: aalizzwell
 * @Date: 2019-05-30 11:08:18
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-06-01 17:10:04
 */
const EXCEPTION_HANDLER = '@farris/devkit ExceptionHandler';

/**
 * Generated bundle index. Do not edit.
 */

export { ACTION_METHOD_META, ANNOTATIONS, APP_VARIABLE_PROVIDERS, ASSIGNER_TOKEN, ActionMethodMeta, App, AppContext, AppOptions, ArrayStringValueConverter, ArrayUtil, BACK_END_MESSAGE_HANDLER_TOKEN, BackEndMessage, BigNumberType, BindingData, BindingDataAppendObjectEventHandler, BindingDataChangeListener, BindingDataFactory, BindingDataLoadEventHandler, BindingDataManager, BindingDataRemoveObjectEventHandler, BindingDataSelectionChangedEventHandler, BindingDataValueChangeEventHandler, BindingList, BindingListFactory, BindingObject, BindingObjectFactory, BindingPathComparer, BindingPathConverter, BindingPathTraverser, BindingPropertyType, BindingType, BindingValueAccessorFactory, BoolUtil, COMMAND_HANDLERS_TOKEN, COMMAND_HANDLER_EXTENDERS_TOKEN, COMMAND_HANDLER_EXTENDER_META, COMMAND_HANDLER_META, COMMAND_METHOD_META, CONTROLSTATE_PROP_META, CONTROL_STATE_INTERCEPTOR_TOKEN, ChangeSet, ChangeType, CommandBus, CommandContext, CommandHandler, CommandHandlerExtender, CommandHandlerExtenderMeta, CommandHandlerExtenderRegistry, CommandHandlerFactory, CommandHandlerMeta, CommandHandlerRegistry, CommandMethodMeta, CommandVariableParser, CommentDependencyResolver, Context, ControlStateInterceptorService, ControlStatePropMeta, ControlsProxy, Core, DYNAMIC_PROP_META, DataChangeType, DataPath, DataPathCreator, DataPathNode, DataPathNodeType, DataPathUtil, DataPropGroup, DataPropInfo, DataTypeInfo, DataVariableParser, DateStringValueConverter, DateUtil, DefaultRepository, DependencyEffector, DynamicEntity, DynamicPropMeta, EFFECTOR_TOKEN, ENTITY_META, ENTITY_TEMPLATE, EVENT_HANDLER_TOKEN, EXCEPTION_HANDLER, EffectorFactory, EffectorRegistry, Entity, EntityBindingValueAccessor, EntityCollection, EntityDependencyResolver, EntityFactory, EntityList, EntityManager, EntityMeta, EntityMetadataUtil, EntityPathComparer, EntityPathConverter, EntityUpdateEventHandler, EntityUtil, EntityValueChangedEventHandler, EnumUtil, EnvUtil, EventHandler, EventHandlerRegistry, Expression, ExpressionEngineImpl, ExpressionEventEmitter, ExpressionExecutor, ExpressionManager, ExpressionRegistry, ExpressionResult, ExpressionResultFactory, ExpressionUtil, FORM_CONTROL_PROP_META, FORM_EXPRESSION_MANIFEST_SERVICE_TOKEN, FORM_MANIFEST_SERVICE_TOKEN, FORM_PATH_TOKEN, FieldMetadataUtil, Form, FormControl, FormControlPropMeta, FormPathConverter, GROUP_FUNCTIONS, Guid, HTTP_PROVIDERS, HttpClient, HttpMethods, HttpUtil, INJECTOR, INJECTOR_IMPL, INJECTOR_IMPL__PRE_R3__, INJECTOR_SCOPE, InitContext, InjectFlags, InjectionToken, Injector, InterceptContext, LISTENER_TOKEN, LIST_PROP_META, ListPropMeta, ListenerRegistry, Listeners, MESSAGE_SERVICE_TOKEN, MetadataUtil, Modification, ModifyType, NAMESPACE, NOTIFY_SERVICE_TOKEN, NumberUtil, OBJECT_PROP_META, ObjectPropMeta, ObjectUtil, PARAMETERS, PARENT_CLASS, PARENT_PATH, PRIMITIVE_PROP_META, PROP_METADATA, PrimitivePropMeta, ProcessContext, PropertyUtil, RENDER_STATE_PROP_META, REPOSITORY_META, RESOLVER_TOKEN, ReadonlyEffector, RenderStatePropMeta, Repository, RepositoryAddEntityEventHandler, RepositoryChangeListener, RepositoryEffector, RepositoryLoadEventHandler, RepositoryManager, RepositoryMeta, RepositoryRemoveEntityEventHandler, RequiredEffector, ResolveService, ResolverRegistry, STATE_PROP_META, STATE_TEMPLATE, State, StateDependencyResolver, StateMachine, StateMachineContext, StateMachineVariableParser, StatePropMeta, StateValueChangedEventHandler, StaticInjector, StringUtil, TaskFlow, TaskLink, TaskNode, Type, UISTATE_PROP_META, UIState, UIStateBindingValueAccessor, UIStateChangeListener, UIStateEffector, UIStateMetadataUtil, UIStatePropMeta, UIStateVariableParser, USE_VALUE, UrlUtil, VALIDATION_RULE_TOKEN, VARIABLE_PARSERS, VIEW_MODEL_COMMAND_PROVIDERS, VIEW_MODEL_EXPRESSION_PROVIDERS, ValidateEffector, ValidatorFactory, VariableParseService, ViewChangeType, ViewModel, ViewModelContext, ViewModelContextManager, ViewModelOptions, VisibleEffector, createEntities, createEntity, createInjectionToken, createInjector, initialUIState, isObservable, isType, makeDecorator, makeParamDecorator, makePropDecorator, setCurrentInjector, ɵ0, getClosureSafeProperty as ɵa, Injector as ɵb, createInjectionToken as ɵc, AppEventBus as ɵd, ChangeListener as ɵe };
//# sourceMappingURL=farris-mobile-devkit.js.map
