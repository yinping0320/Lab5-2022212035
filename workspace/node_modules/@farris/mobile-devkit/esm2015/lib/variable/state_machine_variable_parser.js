import { ParseUtil } from './parse_util';
/**
 * 状态机变量解析
 * @summary
 *
 * 解析策略：
 * 1、不带frameId，从顶层StateMachine中解析
 * {STATEMACHINE~/states/key}
 * {STATEMACHINE~/renderStates/key}
 *
 * 2、带frameId，从frameId对应的FrameContext的StateMachine中解析
 * {STATEMACHINE~/frameId/states/key}
 * {STATEMACHINE~/frameId/renderStates/key}
 *
 * 存在的问题：
 * 1、不带frameId从顶层StateMachine解析仅为了兼容，将来改为从当前FrameContext的StateMachine中解析；
 * 2、组合表单中顶层StateMachine是主表单的rootFrameContext的StateMachine，显然不合理（既成事实）；
 * 3、farmeId如果是states或renderStates，导致解析失败，几率很小，但又风险。
 */
class StateMachineVariableParser {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 解析变量
     * @param expression 变量：格式形如：/frameId/componentId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{STATEMACHINE~${paths[0]}}`) {
            return this.getValue(paths[0], context);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{STATEMACHINE~${path}}`;
            const replaceValue = this.getValue(path, context);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取Session变量名
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的StateMachine变量字符串
        const STATE_MACHINE_PATTERN_G = /\{STATEMACHINE~(\S+?)\}/g;
        const stateMachineVariables = expression.match(STATE_MACHINE_PATTERN_G);
        if (stateMachineVariables === null) {
            return [];
        }
        // 提取后边的路径
        const STATE_MACHINE_PATTERN = /\{STATEMACHINE~(\S+?)\}/;
        stateMachineVariables.forEach(sessionVariable => {
            const pathMatches = sessionVariable.match(STATE_MACHINE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取对应的值
     */
    getValue(path, context) {
        const pathObj = this.getPathObj(path);
        const stateMachine = this.getTargetStateMachine(pathObj.frameId, context);
        if (pathObj.type === 'currentState') {
            return stateMachine.context.state;
        }
        else if (pathObj.type === 'renderStates') {
            return stateMachine[pathObj.name];
        }
        else {
            throw new Error(`不支类型为${pathObj.type}的状态机变量`);
        }
    }
    /**
     * 解析path，并获取对应的StateMachine实例
     */
    getTargetStateMachine(frameId, context) {
        let targetFrameContext;
        if (frameId) {
            targetFrameContext = ParseUtil.getFrameContextById(context, frameId);
        }
        else {
            targetFrameContext = ParseUtil.getRootFrameContext(context);
        }
        if (!targetFrameContext || !targetFrameContext.stateMachine) {
            throw new Error('找不到对应的状态机实例，请检查！');
        }
        return targetFrameContext.stateMachine;
    }
    /**
     * 将Path解析为格式化的Path对象
     */
    getPathObj(path) {
        let parsedPathObj;
        const parts = this.splitPath(path);
        if (parts[0] === 'currentState' || parts[0] === 'renderStates') {
            parsedPathObj = {
                frameId: '',
                type: parts[0],
                name: parts[1]
            };
        }
        else {
            parsedPathObj = {
                frameId: parts[0],
                type: parts[1],
                name: parts[2]
            };
        }
        return parsedPathObj;
    }
    /**
     * 分隔Path
     */
    splitPath(path) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        return parts;
    }
}
export { StateMachineVariableParser };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGVfbWFjaGluZV92YXJpYWJsZV9wYXJzZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL21vYmlsZS1kZXZraXQvIiwic291cmNlcyI6WyJsaWIvdmFyaWFibGUvc3RhdGVfbWFjaGluZV92YXJpYWJsZV9wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUV6Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxNQUFNLDBCQUEwQjtJQUU5Qjs7T0FFRztJQUNIO0lBQ0EsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsVUFBa0IsRUFBRSxPQUFZO1FBQzNDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFNUMsZ0JBQWdCO1FBQ2hCLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksVUFBVSxLQUFLLGlCQUFpQixLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRTtZQUNyRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ3pDO1FBRUQsZUFBZTtRQUNmLEtBQUssQ0FBQyxPQUFPLENBQUUsSUFBSSxDQUFDLEVBQUU7WUFDcEIsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLElBQUksR0FBRyxDQUFDO1lBQzdDLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ2xELFVBQVUsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUM3RCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQVEsVUFBVSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7O09BR0c7SUFDSyxZQUFZLENBQUMsVUFBa0I7UUFDckMsTUFBTSxLQUFLLEdBQWMsRUFB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SyxTQUFTLENBQUMsSUFBWTtRQUM1QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQVksRUFBRSxFQUFFO1lBQ3BELE9BQU8sSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUNyQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztDQUVGO0FBRUQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogU3RhdGVNYWNoaW5l5Y+Y6YeP6Kej5p6QXG4gKiBAQXV0aG9yOiBXaXR0XG4gKiBARGF0ZTogMjAxOC0xMi0wNCAxNzowOTo0MlxuICogQExhc3QgTW9kaWZpZWQgYnk6IFdpdHRcbiAqIEBMYXN0IE1vZGlmaWVkIHRpbWU6IDIwMTktMTAtMzAgMTE6MDc6MTBcbiAqL1xuaW1wb3J0IHsgVmlld01vZGVsQ29udGV4dCB9IGZyb20gJy4uL3ZpZXctbW9kZWwvaW5kZXgnO1xuaW1wb3J0IHsgU3RhdGVNYWNoaW5lIH0gZnJvbSAnLi4vc3RhdGUtbWFjaGluZS9pbmRleCc7XG5pbXBvcnQgeyBWYXJpYWJsZVBhcnNlciB9IGZyb20gJy4vdmFyaWFibGVfcGFyc2VyJztcbmltcG9ydCB7IFBhcnNlVXRpbCB9IGZyb20gJy4vcGFyc2VfdXRpbCc7XG5cbi8qKlxuICog54q25oCB5py65Y+Y6YeP6Kej5p6QXG4gKiBAc3VtbWFyeVxuICpcbiAqIOino+aekOetlueVpe+8mlxuICogMeOAgeS4jeW4pmZyYW1lSWTvvIzku47pobblsYJTdGF0ZU1hY2hpbmXkuK3op6PmnpBcbiAqIHtTVEFURU1BQ0hJTkV+L3N0YXRlcy9rZXl9XG4gKiB7U1RBVEVNQUNISU5Ffi9yZW5kZXJTdGF0ZXMva2V5fVxuICpcbiAqIDLjgIHluKZmcmFtZUlk77yM5LuOZnJhbWVJZOWvueW6lOeahEZyYW1lQ29udGV4dOeahFN0YXRlTWFjaGluZeS4reino+aekFxuICoge1NUQVRFTUFDSElORX4vZnJhbWVJZC9zdGF0ZXMva2V5fVxuICoge1NUQVRFTUFDSElORX4vZnJhbWVJZC9yZW5kZXJTdGF0ZXMva2V5fVxuICpcbiAqIOWtmOWcqOeahOmXrumimO+8mlxuICogMeOAgeS4jeW4pmZyYW1lSWTku47pobblsYJTdGF0ZU1hY2hpbmXop6PmnpDku4XkuLrkuoblhbzlrrnvvIzlsIbmnaXmlLnkuLrku47lvZPliY1GcmFtZUNvbnRleHTnmoRTdGF0ZU1hY2hpbmXkuK3op6PmnpDvvJtcbiAqIDLjgIHnu4TlkIjooajljZXkuK3pobblsYJTdGF0ZU1hY2hpbmXmmK/kuLvooajljZXnmoRyb290RnJhbWVDb250ZXh055qEU3RhdGVNYWNoaW5l77yM5pi+54S25LiN5ZCI55CG77yI5pei5oiQ5LqL5a6e77yJ77ybXG4gKiAz44CBZmFybWVJZOWmguaenOaYr3N0YXRlc+aIlnJlbmRlclN0YXRlc++8jOWvvOiHtOino+aekOWksei0pe+8jOWHoOeOh+W+iOWwj++8jOS9huWPiOmjjumZqeOAglxuICovXG5jbGFzcyBTdGF0ZU1hY2hpbmVWYXJpYWJsZVBhcnNlciBpbXBsZW1lbnRzIFZhcmlhYmxlUGFyc2VyIHtcblxuICAvKipcbiAgICog5p6E6YCg5Ye95pWwXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICAvKipcbiAgICog6Kej5p6Q5Y+Y6YePXG4gICAqIEBwYXJhbSBleHByZXNzaW9uIOWPmOmHj++8muagvOW8j+W9ouWmgu+8mi9mcmFtZUlkL2NvbXBvbmVudElkL3N0YXRlTmFtZVxuICAgKiBAcGFyYW0gY29udGV4dCDkuIrkuIvmlodcbiAgICovXG4gIHB1YmxpYyBwYXJzZShleHByZXNzaW9uOiBzdHJpbmcsIGNvbnRleHQ6IGFueSk6IGFueSB7XG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLmV4dHJhY3RQYXRocyhleHByZXNzaW9uKTtcblxuICAgIC8vIDHjgIHljZXkuKrnmoTooajovr7lvI/vvJrnm7TmjqXmsYLlgLxcbiAgICBpZiAocGF0aHMubGVuZ3RoID09PSAxICYmIGV4cHJlc3Npb24gPT09IGB7U1RBVEVNQUNISU5FfiR7cGF0aHNbMF19fWApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKHBhdGhzWzBdLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyAy44CB5YW25LuW5oOF5Ya177ya5a2X56ym5Liy5pu/5o2iXG4gICAgcGF0aHMuZm9yRWFjaCggcGF0aCA9PiB7XG4gICAgICBjb25zdCBzZWFyY2hWYWx1ZSA9IGB7U1RBVEVNQUNISU5FfiR7cGF0aH19YDtcbiAgICAgIGNvbnN0IHJlcGxhY2VWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUocGF0aCwgY29udGV4dCk7XG4gICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICBleHByZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIOaPkOWPllNlc3Npb27lj5jph4/lkI1cbiAgICog5Y+Y6YeP5qC85byP77yae31cbiAgICovXG4gIHByaXZhdGUgZXh0cmFjdFBhdGhzKGV4cHJlc3Npb246IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBwYXRoczogc3RyaW5nW10gID0gW107XG5cbiAgICAvLyDmn6Xmib7miYDmnInnmoRTdGF0ZU1hY2hpbmXlj5jph4/lrZfnrKbkuLJcbiAgICBjb25zdCBTVEFURV9NQUNISU5FX1BBVFRFUk5fRyA9IC9cXHtTVEFURU1BQ0hJTkV+KFxcUys/KVxcfS9nO1xuICAgIGNvbnN0IHN0YXRlTWFjaGluZVZhcmlhYmxlcyA9IGV4cHJlc3Npb24ubWF0Y2goU1RBVEVfTUFDSElORV9QQVRURVJOX0cpO1xuICAgIGlmIChzdGF0ZU1hY2hpbmVWYXJpYWJsZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyDmj5Dlj5blkI7ovrnnmoTot6/lvoRcbiAgICBjb25zdCBTVEFURV9NQUNISU5FX1BBVFRFUk4gPSAvXFx7U1RBVEVNQUNISU5FfihcXFMrPylcXH0vO1xuICAgIHN0YXRlTWFjaGluZVZhcmlhYmxlcy5mb3JFYWNoKCBzZXNzaW9uVmFyaWFibGUgPT4gIHtcbiAgICAgIGNvbnN0IHBhdGhNYXRjaGVzID0gc2Vzc2lvblZhcmlhYmxlLm1hdGNoKFNUQVRFX01BQ0hJTkVfUEFUVEVSTik7XG4gICAgICBpZiAocGF0aE1hdGNoZXMgIT0gbnVsbCAmJiBwYXRoTWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcGF0aHMucHVzaChwYXRoTWF0Y2hlc1sxXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGF0aHM7XG4gIH1cblxuICAvKipcbiAgICog6I635Y+W5a+55bqU55qE5YC8XG4gICAqL1xuICBwcml2YXRlIGdldFZhbHVlKHBhdGg6IHN0cmluZywgY29udGV4dDogYW55KTogYW55IHtcblxuICAgIGNvbnN0IHBhdGhPYmogPSB0aGlzLmdldFBhdGhPYmoocGF0aCk7XG4gICAgY29uc3Qgc3RhdGVNYWNoaW5lID0gdGhpcy5nZXRUYXJnZXRTdGF0ZU1hY2hpbmUocGF0aE9iai5mcmFtZUlkLCBjb250ZXh0KTtcblxuICAgIGlmIChwYXRoT2JqLnR5cGUgPT09ICdjdXJyZW50U3RhdGUnKSB7XG4gICAgICByZXR1cm4gc3RhdGVNYWNoaW5lLmNvbnRleHQuc3RhdGU7XG4gICAgfSBlbHNlIGlmIChwYXRoT2JqLnR5cGUgPT09ICdyZW5kZXJTdGF0ZXMnKSB7XG4gICAgICByZXR1cm4gc3RhdGVNYWNoaW5lW3BhdGhPYmoubmFtZV0gYXMgYm9vbGVhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGDkuI3mlK/nsbvlnovkuLoke3BhdGhPYmoudHlwZX3nmoTnirbmgIHmnLrlj5jph49gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICog6Kej5p6QcGF0aO+8jOW5tuiOt+WPluWvueW6lOeahFN0YXRlTWFjaGluZeWunuS+i1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRUYXJnZXRTdGF0ZU1hY2hpbmUoZnJhbWVJZDogc3RyaW5nLCBjb250ZXh0KTogU3RhdGVNYWNoaW5lIHtcbiAgICBsZXQgdGFyZ2V0RnJhbWVDb250ZXh0OiBWaWV3TW9kZWxDb250ZXh0O1xuICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICB0YXJnZXRGcmFtZUNvbnRleHQgPSBQYXJzZVV0aWwuZ2V0RnJhbWVDb250ZXh0QnlJZChjb250ZXh0LCBmcmFtZUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0RnJhbWVDb250ZXh0ID0gUGFyc2VVdGlsLmdldFJvb3RGcmFtZUNvbnRleHQoY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRGcmFtZUNvbnRleHQgfHwgIXRhcmdldEZyYW1lQ29udGV4dC5zdGF0ZU1hY2hpbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcign5om+5LiN5Yiw5a+55bqU55qE54q25oCB5py65a6e5L6L77yM6K+35qOA5p+l77yBJyk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRGcmFtZUNvbnRleHQuc3RhdGVNYWNoaW5lO1xuICB9XG5cbiAgLyoqXG4gICAqIOWwhlBhdGjop6PmnpDkuLrmoLzlvI/ljJbnmoRQYXRo5a+56LGhXG4gICAqL1xuICBwcml2YXRlIGdldFBhdGhPYmoocGF0aDogc3RyaW5nKTogYW55IHtcbiAgICBsZXQgcGFyc2VkUGF0aE9iajogYW55O1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5zcGxpdFBhdGgocGF0aCk7XG5cbiAgICBpZiAocGFydHNbMF0gPT09ICdjdXJyZW50U3RhdGUnIHx8IHBhcnRzWzBdID09PSAncmVuZGVyU3RhdGVzJykge1xuICAgICAgcGFyc2VkUGF0aE9iaiA9IHtcbiAgICAgICAgZnJhbWVJZDogJycsXG4gICAgICAgIHR5cGU6IHBhcnRzWzBdLFxuICAgICAgICBuYW1lOiBwYXJ0c1sxXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkUGF0aE9iaiA9IHtcbiAgICAgICAgZnJhbWVJZDogcGFydHNbMF0sXG4gICAgICAgIHR5cGU6IHBhcnRzWzFdLFxuICAgICAgICBuYW1lOiBwYXJ0c1syXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkUGF0aE9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiDliIbpmpRQYXRoXG4gICAqL1xuICBwcml2YXRlIHNwbGl0UGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwYXJ0OiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBwYXJ0ICE9PSAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxufVxuXG5leHBvcnQgeyBTdGF0ZU1hY2hpbmVWYXJpYWJsZVBhcnNlciB9O1xuIl19