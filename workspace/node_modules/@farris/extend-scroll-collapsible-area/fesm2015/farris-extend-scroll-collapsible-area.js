import { fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { Component, ElementRef, HostBinding, Input, NgZone, ViewChild, Directive, ContentChild, Injectable, NgModule, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/collapsible-area/collapsible-area.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FECollapsibleAreaComponent {
    /**
     * @param {?} ngZone
     * @param {?} el
     */
    constructor(ngZone, el) {
        this.ngZone = ngZone;
        this.el = el;
        this.cls = true;
        // 样式名称
        this.clsName = {
            'collapse': 'f-state-collapse',
            'expand': 'f-state-expand'
        };
        //默认是否收起
        this.collapseState = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultCollapse(value) {
        if (value !== this.collapseState) {
            if (value) {
                this.collapse();
            }
            else {
                this.expand();
            }
        }
    }
    /**
     * @return {?}
     */
    get defaultCollapse() {
        return this.collapseState;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._initHeight = this.contentArea.nativeElement.getBoundingClientRect().height;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    // 収折
    /**
     * @return {?}
     */
    collapse() {
        if (this.collapseState) {
            return;
        }
        this.containerArea.nativeElement.style.height = "0px";
        /** @type {?} */
        let tName = this.el.nativeElement.className;
        tName = tName.replace(this.clsName.expand, '');
        this.el.nativeElement.className = tName + ' ' + this.clsName.collapse;
        this.collapseState = true;
    }
    // 展开
    /**
     * @return {?}
     */
    expand() {
        if (!this.collapseState) {
            return;
        }
        this.containerArea.nativeElement.style.height = this._initHeight + "px";
        /** @type {?} */
        let tName = this.el.nativeElement.className;
        tName = tName.replace(this.clsName.collapse, '');
        this.el.nativeElement.className = tName + ' ' + this.clsName.expand;
        this.collapseState = false;
    }
    // 改变状态
    /**
     * @return {?}
     */
    changeState() {
        if (this.collapseState) {
            this.expand();
        }
        else {
            this.collapse();
        }
    }
    // 对外传出初始高度
    /**
     * @return {?}
     */
    getInitHeight() {
        return this._initHeight;
    }
    // 更新高度
    /**
     * @param {?} tHeight
     * @param {?} direction
     * @return {?}
     */
    updateHeight(tHeight, direction) {
        if (direction == 'up' && !this.collapseState || direction == 'down' && this.collapseState) {
            //向上，并且已经展开，或者向下，并且已经収折，不需要处理
            return;
        }
        // 向上
        if (direction == 'up' && tHeight < 10 && this.collapseState) {
            this.expand();
        }
        // 向下
        if (direction == 'down' && tHeight > this._initHeight + 10 && !this.collapseState) {
            this.collapse();
        }
        if (direction == 'down') {
            this.containerArea.nativeElement.style.height = (this._initHeight - tHeight) + 'px';
            if (this._initHeight <= tHeight) {
                //如果高度向下，快到阈值，并且还没有収折，意在収折
                this.collapse();
            }
        }
        else if (direction == 'up') {
            this.containerArea.nativeElement.style.height = (this._initHeight - tHeight) + 'px';
            if (tHeight < 10) {
                // 如果向上，快到阈值，并且还没有展开，意在展开
                this.expand();
            }
        }
    }
}
FECollapsibleAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'fe-collapsible-area',
                template: "<div class=\"fe-collapsible-container\" #containerArea>\n  <div class=\"fe-collapsible-area\" #contentArea>\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"fe-collapsible-icon-container\" (click)=\"changeState()\">\n  <span class=\"f-icon-container\"><i class=\"f-icon\"></i></span>\n</div>"
            }] }
];
/** @nocollapse */
FECollapsibleAreaComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef }
];
FECollapsibleAreaComponent.propDecorators = {
    cls: [{ type: HostBinding, args: ['class.fe-cmp-collapsible-area',] }],
    defaultCollapse: [{ type: Input }],
    contentArea: [{ type: ViewChild, args: ['contentArea',] }],
    containerArea: [{ type: ViewChild, args: ['containerArea',] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-area.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FEScrollAreaDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        // 记录滚动的值
        this.scrollAreaTop = 0;
        // 记录值
        this.threshold = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.bindScrollEvent();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollSub.unsubscribe();
        this.scrollSub = null;
    }
    // 追加关联
    /**
     * @param {?} cInstance
     * @return {?}
     */
    addCollapseInstance(cInstance) {
        this.relatedCollapseInstance = cInstance;
    }
    // 绑定事件
    /**
     * @return {?}
     */
    bindScrollEvent() {
        this.scrollSub = fromEvent(this.el.nativeElement, 'scroll').pipe(debounceTime(20)).subscribe((/**
         * @return {?}
         */
        () => {
            //判断滚动的方向
            this.scrollDirection();
        }));
    }
    /**
     * @return {?}
     */
    scrollDirection() {
        /** @type {?} */
        let afterScrollTop = this.el.nativeElement.scrollTop;
        /** @type {?} */
        let delta = afterScrollTop - this.scrollAreaTop;
        // 没有变化
        if (delta === 0)
            return false;
        this.scrollAreaTop = afterScrollTop;
        this.judgeThreshold(delta > 0 ? "down" : "up");
    }
    /**
     * @private
     * @param {?} direction
     * @return {?}
     */
    judgeThreshold(direction) {
        this.relatedCollapseInstance.updateHeight(this.scrollAreaTop, direction);
    }
}
FEScrollAreaDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fe-scroll-area]'
            },] }
];
/** @nocollapse */
FEScrollAreaDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-collapsible-area.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FEScrollCollapsibleAreaDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.scrollArea.addCollapseInstance(this.collapseArea);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // setTimeout(()=>{
        //   debugger;
        //   this.scrollArea.addCollapseInstance(this.collapseArea);
        // },300);
    }
}
FEScrollCollapsibleAreaDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fe-scroll-collapsible]'
            },] }
];
/** @nocollapse */
FEScrollCollapsibleAreaDirective.ctorParameters = () => [
    { type: ElementRef }
];
FEScrollCollapsibleAreaDirective.propDecorators = {
    collapseArea: [{ type: ContentChild, args: [FECollapsibleAreaComponent,] }],
    scrollArea: [{ type: ContentChild, args: [FEScrollAreaDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-collapsible-area.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FEScrollCollapsibleAreaService {
    constructor() { }
}
FEScrollCollapsibleAreaService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FEScrollCollapsibleAreaService.ctorParameters = () => [];
/** @nocollapse */ FEScrollCollapsibleAreaService.ngInjectableDef = defineInjectable({ factory: function FEScrollCollapsibleAreaService_Factory() { return new FEScrollCollapsibleAreaService(); }, token: FEScrollCollapsibleAreaService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scroll-collapsible-area.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FEScrollCollapsibleAreaModule {
}
FEScrollCollapsibleAreaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [FEScrollAreaDirective, FEScrollCollapsibleAreaDirective, FECollapsibleAreaComponent],
                imports: [],
                exports: [FEScrollAreaDirective, FEScrollCollapsibleAreaDirective, FECollapsibleAreaComponent],
                providers: [FEScrollCollapsibleAreaService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: farris-extend-scroll-collapsible-area.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { FECollapsibleAreaComponent, FEScrollAreaDirective, FEScrollCollapsibleAreaDirective, FEScrollCollapsibleAreaService, FEScrollCollapsibleAreaModule };

//# sourceMappingURL=farris-extend-scroll-collapsible-area.js.map