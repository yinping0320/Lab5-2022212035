/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Component, Input, Output, EventEmitter, HostListener, forwardRef, Inject, Optional, Injector, ElementRef, ViewChild } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { SWITCH_OPTIONS } from './switch.token';
import { Observable } from 'rxjs';
/** @type {?} */
const UI_SWITCH_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    /* tslint:disable-next-line: no-use-before-declare */
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => SwitchComponent)),
    multi: true
};
export class SwitchComponent {
    /**
     * @param {?=} config
     * @param {?=} cdr
     * @param {?=} injector
     */
    constructor(config = {}, cdr, injector) {
        this.config = config;
        this.cdr = cdr;
        this.injector = injector;
        this.size = 'medium';
        this.editable = true;
        this.trueValue = true;
        this.falseValue = false;
        /**
         * @deprecated
         */
        this.changeEvent = new EventEmitter();
        this.clickHandle = new EventEmitter();
        /**
         * Emits changed value
         */
        this.valueChange = new EventEmitter();
        this.onTouchedCallback = (/**
         * @param {?} v
         * @return {?}
         */
        (v) => { });
        this.onChangeCallback = (/**
         * @param {?} v
         * @return {?}
         */
        (v) => { });
        this.square = (config && config.square) || false;
        this.size = (config && config.size) || this.size;
        this.color = config && config.color;
        this.switchOffColor = config && config.switchOffColor;
        this.switchColor = config && config.switchColor;
        this.defaultBgColor = config && config.defaultBgColor;
        this.defaultBoColor = config && config.defaultBoColor;
        this.checkedLabel = config && config.checkedLabel;
        this.uncheckedLabel = config && config.uncheckedLabel;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._beforeChange) {
            this._beforeChange.unsubscribe();
        }
    }
    /**
     * @param {?=} flag
     * @return {?}
     */
    getColor(flag = '') {
        if (flag === 'borderColor') {
            return this.defaultBoColor;
        }
        if (flag === 'switchColor') {
            if (this.reverse) {
                return !this.checked
                    ? this.switchColor
                    : this.switchOffColor || this.switchColor;
            }
            return this.checked
                ? this.switchColor
                : this.switchOffColor || this.switchColor;
        }
        if (this.reverse) {
            return !this.checked ? this.color : this.defaultBgColor;
        }
        return this.checked ? this.color : this.defaultBgColor;
    }
    /**
     * @private
     * @param {?} event
     * @param {?=} isClick
     * @return {?}
     */
    updateChecked(event, isClick = true) {
        if (this.disabled || !this.editable) {
            return;
        }
        this.checked = !this.checked;
        /** @type {?} */
        const val = this.getValue(this.checked);
        // Component events
        this.valueChange.emit(val);
        this.changeEvent.emit(event);
        if (isClick) {
            this.clickHandle.emit({ event, checked: this.checked, value: val, instance: this });
        }
        this.onChangeCallback(val);
        this.onTouchedCallback(val);
        if (!this.cdr['destroyed']) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onToggle(event) {
        /** @type {?} */
        const span = ((/** @type {?} */ (event.target))).closest('.f-cmp-switch');
        if (!span || span !== this.switchElRef.nativeElement) {
            return;
        }
        if (this.beforeChange) {
            this._beforeChange = this.beforeChange.subscribe((/**
             * @param {?} confirm
             * @return {?}
             */
            (confirm) => {
                if (confirm) {
                    this.updateChecked(event);
                }
            }));
        }
        else {
            this.updateChecked(event);
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onSpaceHandle($event) {
        $event.preventDefault();
        $event.stopPropagation();
        this.updateChecked($event, false);
    }
    /**
     * @private
     * @param {?} checked
     * @return {?}
     */
    getValue(checked) {
        if (this.trueValue !== undefined && this.falseValue !== undefined) {
            return checked ? this.trueValue : this.falseValue;
        }
        return checked;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    writeValue(obj) {
        if (this.trueValue !== undefined && this.falseValue !== undefined) {
            this.checked = obj == this.trueValue;
        }
        else {
            if (obj !== this.checked) {
                this.checked = !!obj;
            }
        }
        if (this.cdr && !this.cdr['destroyed']) {
            this.cdr.detectChanges();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
SwitchComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                // bugNum2:462134 && 506852
                // style="display:flex;height:100%;align-items:center;"
                selector: 'farris-switch',
                template: `
    <div class="farris-switch-outlayer">
        <span #container tabindex="0" role="button" hidefocus="true" class="switch f-cmp-switch"
            [ngClass]="{
                checked: checked,
                disabled: disabled || !editable,
                square: square,
                'switch-large': size === 'large',
                'switch-medium': size === 'medium',
                'switch-small': size === 'small'
            }"
            [ngStyle]="{
                'outline': 'none',
                'background-color': getColor(),
                'border-color': getColor('borderColor')
            }"
        >
            <span class="switch-pane" *ngIf="checkedLabel || uncheckedLabel">
                <span class="switch-label-checked">{{
                    this.checkedLabel
                }}</span>
                <span class="switch-label-unchecked">{{
                    this.uncheckedLabel
                }}</span>
            </span>
            <small [style.background]="getColor('switchColor')">
                <ng-content></ng-content>
            </small>
        </span>
    <div>
    `,
                providers: [UI_SWITCH_CONTROL_VALUE_ACCESSOR]
            }] }
];
/** @nocollapse */
SwitchComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [SWITCH_OPTIONS,] }, { type: Optional }] },
    { type: ChangeDetectorRef },
    { type: Injector }
];
SwitchComponent.propDecorators = {
    square: [{ type: Input }],
    size: [{ type: Input }],
    color: [{ type: Input }],
    switchOffColor: [{ type: Input }],
    switchColor: [{ type: Input }],
    defaultBgColor: [{ type: Input }],
    defaultBoColor: [{ type: Input }],
    checkedLabel: [{ type: Input }],
    uncheckedLabel: [{ type: Input }],
    checked: [{ type: Input }],
    readonly: [{ type: Input }],
    disabled: [{ type: Input }],
    editable: [{ type: Input }],
    reverse: [{ type: Input }],
    trueValue: [{ type: Input }],
    falseValue: [{ type: Input }],
    beforeChange: [{ type: Input }],
    changeEvent: [{ type: Output }],
    clickHandle: [{ type: Output }],
    valueChange: [{ type: Output }],
    switchElRef: [{ type: ViewChild, args: ['container',] }],
    onToggle: [{ type: HostListener, args: ['click', ['$event'],] }],
    onSpaceHandle: [{ type: HostListener, args: ['keydown.Space', ['$event'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    SwitchComponent.prototype._beforeChange;
    /** @type {?} */
    SwitchComponent.prototype.square;
    /** @type {?} */
    SwitchComponent.prototype.size;
    /** @type {?} */
    SwitchComponent.prototype.color;
    /** @type {?} */
    SwitchComponent.prototype.switchOffColor;
    /** @type {?} */
    SwitchComponent.prototype.switchColor;
    /** @type {?} */
    SwitchComponent.prototype.defaultBgColor;
    /** @type {?} */
    SwitchComponent.prototype.defaultBoColor;
    /** @type {?} */
    SwitchComponent.prototype.checkedLabel;
    /** @type {?} */
    SwitchComponent.prototype.uncheckedLabel;
    /** @type {?} */
    SwitchComponent.prototype.checked;
    /** @type {?} */
    SwitchComponent.prototype.readonly;
    /** @type {?} */
    SwitchComponent.prototype.disabled;
    /** @type {?} */
    SwitchComponent.prototype.editable;
    /** @type {?} */
    SwitchComponent.prototype.reverse;
    /** @type {?} */
    SwitchComponent.prototype.trueValue;
    /** @type {?} */
    SwitchComponent.prototype.falseValue;
    /** @type {?} */
    SwitchComponent.prototype.beforeChange;
    /**
     * @deprecated
     * @type {?}
     */
    SwitchComponent.prototype.changeEvent;
    /** @type {?} */
    SwitchComponent.prototype.clickHandle;
    /**
     * Emits changed value
     * @type {?}
     */
    SwitchComponent.prototype.valueChange;
    /** @type {?} */
    SwitchComponent.prototype.switchElRef;
    /**
     * @type {?}
     * @private
     */
    SwitchComponent.prototype.onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    SwitchComponent.prototype.onChangeCallback;
    /** @type {?} */
    SwitchComponent.prototype.config;
    /**
     * @type {?}
     * @private
     */
    SwitchComponent.prototype.cdr;
    /** @type {?} */
    SwitchComponent.prototype.injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dpdGNoLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmYXJyaXMvdWktc3dpdGNoLyIsInNvdXJjZXMiOlsibGliL3N3aXRjaC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFlBQVksRUFDWixVQUFVLEVBQ1YsTUFBTSxFQUNOLFFBQVEsRUFFUixRQUFRLEVBRVIsVUFBVSxFQUNWLFNBQVMsRUFFWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQW1DLE1BQU0sZ0JBQWdCLENBQUM7QUFFcEYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRWhELE9BQU8sRUFBRSxVQUFVLEVBQWdCLE1BQU0sTUFBTSxDQUFDOztNQUUxQyxnQ0FBZ0MsR0FBUTtJQUMxQyxPQUFPLEVBQUUsaUJBQWlCOztJQUUxQixXQUFXLEVBQUUsVUFBVTs7O0lBQUMsR0FBRyxFQUFFLENBQUMsZUFBZSxFQUFDO0lBQzlDLEtBQUssRUFBRSxJQUFJO0NBQ2Q7QUF3Q0QsTUFBTSxPQUFPLGVBQWU7Ozs7OztJQXFDeEIsWUFDK0MsU0FBNkIsRUFBRSxFQUNsRSxHQUFzQixFQUN2QixRQUFrQjtRQUZrQixXQUFNLEdBQU4sTUFBTSxDQUF5QjtRQUNsRSxRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQUN2QixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBcENwQixTQUFJLEdBQTBDLFFBQVEsQ0FBQztRQVl2RCxhQUFRLEdBQUcsSUFBSSxDQUFDO1FBR2hCLGNBQVMsR0FBUSxJQUFJLENBQUM7UUFDdEIsZUFBVSxHQUFRLEtBQUssQ0FBQzs7OztRQU92QixnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFPLENBQUM7UUFDdEMsZ0JBQVcsR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDOzs7O1FBS3RDLGdC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dCI6WyJpbXBvcnQge1xyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBJbnB1dCxcclxuICAgIE91dHB1dCxcclxuICAgIEV2ZW50RW1pdHRlcixcclxuICAgIEhvc3RMaXN0ZW5lcixcclxuICAgIGZvcndhcmRSZWYsXHJcbiAgICBJbmplY3QsXHJcbiAgICBPcHRpb25hbCxcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gICAgSW5qZWN0b3IsXHJcbiAgICBPbkluaXQsXHJcbiAgICBFbGVtZW50UmVmLFxyXG4gICAgVmlld0NoaWxkLFxyXG4gICAgT25EZXN0cm95XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5cclxuaW1wb3J0IHsgU1dJVENIX09QVElPTlMgfSBmcm9tICcuL3N3aXRjaC50b2tlbic7XHJcbmltcG9ydCB7IFN3aXRjaE1vZHVsZUNvbmZpZyB9IGZyb20gJy4vc3dpdGNoLmNvbmZpZyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5cclxuY29uc3QgVUlfU1dJVENIX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcclxuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11c2UtYmVmb3JlLWRlY2xhcmUgKi9cclxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFN3aXRjaENvbXBvbmVudCksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGNvbXBvbmVudC1zZWxlY3RvclxyXG4gICAgLy8gYnVnTnVtMjo0NjIxMzQgJiYgNTA2ODUyXHJcbiAgICAvLyBzdHlsZT1cImRpc3BsYXk6ZmxleDtoZWlnaHQ6MTAwJTthbGlnbi1pdGVtczpjZW50ZXI7XCJcclxuICAgIHNlbGVjdG9yOiAnZmFycmlzLXN3aXRjaCcsXHJcbiAgICB0ZW1wbGF0ZTogYFxyXG4gICAgPGRpdiBjbGFzcz1cImZhcnJpcy1zd2l0Y2gtb3V0bGF5ZXJcIj5cclxuICAgICAgICA8c3BhbiAjY29udGFpbmVyIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIiBoaWRlZm9jdXM9XCJ0cnVlXCIgY2xhc3M9XCJzd2l0Y2ggZi1jbXAtc3dpdGNoXCJcclxuICAgICAgICAgICAgW25nQ2xhc3NdPVwie1xyXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogY2hlY2tlZCxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCB8fCAhZWRpdGFibGUsXHJcbiAgICAgICAgICAgICAgICBzcXVhcmU6IHNxdWFyZSxcclxuICAgICAgICAgICAgICAgICdzd2l0Y2gtbGFyZ2UnOiBzaXplID09PSAnbGFyZ2UnLFxyXG4gICAgICAgICAgICAgICAgJ3N3aXRjaC1tZWRpdW0nOiBzaXplID09PSAnbWVkaXVtJyxcclxuICAgICAgICAgICAgICAgICdzd2l0Y2gtc21hbGwnOiBzaXplID09PSAnc21hbGwnXHJcbiAgICAgICAgICAgIH1cIlxyXG4gICAgICAgICAgICBbbmdTdHlsZV09XCJ7XHJcbiAgICAgICAgICAgICAgICAnb3V0bGluZSc6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogZ2V0Q29sb3IoKSxcclxuICAgICAgICAgICAgICAgICdib3JkZXItY29sb3InOiBnZXRDb2xvcignYm9yZGVyQ29sb3InKVxyXG4gICAgICAgICAgICB9XCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3dpdGNoLXBhbmVcIiAqbmdJZj1cImNoZWNrZWRMYWJlbCB8fCB1bmNoZWNrZWRMYWJlbFwiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzd2l0Y2gtbGFiZWwtY2hlY2tlZFwiPnt7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkTGFiZWxcclxuICAgICAgICAgICAgICAgIH19PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzd2l0Y2gtbGFiZWwtdW5jaGVja2VkXCI+e3tcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuY2hlY2tlZExhYmVsXHJcbiAgICAgICAgICAgICAgICB9fTwvc3Bhbj5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICA8c21hbGwgW3N0eWxlLmJhY2tncm91bmRdPVwiZ2V0Q29sb3IoJ3N3aXRjaENvbG9yJylcIj5cclxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICAgICAgICAgICAgPC9zbWFsbD5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICA8ZGl2PlxyXG4gICAgYCxcclxuICAgIHByb3ZpZGVyczogW1VJX1NXSVRDSF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU3dpdGNoQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uRGVzdHJveSB7XHJcbiAgICBwcml2YXRlIF9iZWZvcmVDaGFuZ2U6IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBASW5wdXQoKSBzcXVhcmU6IGJvb2xlYW47XHJcbiAgICBASW5wdXQoKSBzaXplOiBzdHJpbmcgfCAnc21hbGwnIHwgJ21lZGl1bScgfCAnbGFyZ2UnID0gJ21lZGl1bSc7XHJcbiAgICBASW5wdXQoKSBjb2xvcjogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgc3dpdGNoT2ZmQ29sb3I6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIHN3aXRjaENvbG9yOiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBkZWZhdWx0QmdDb2xvcjogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgZGVmYXVsdEJvQ29sb3I6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGNoZWNrZWRMYWJlbDogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgdW5jaGVja2VkTGFiZWw6IHN0cmluZztcclxuXHJcbiAgICBASW5wdXQoKSBjaGVja2VkOiBib29sZWFuO1xyXG4gICAgQElucHV0KCkgcmVhZG9ubHk6IGJvb2xlYW47XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIEBJbnB1dCgpIGVkaXRhYmxlID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIHJldmVyc2U6IGJvb2xlYW47XHJcblxyXG4gICAgQElucHV0KCkgdHJ1ZVZhbHVlOiBhbnkgPSB0cnVlO1xyXG4gICAgQElucHV0KCkgZmFsc2VWYWx1ZTogYW55ID0gZmFsc2U7XHJcblxyXG4gICAgQElucHV0KCkgYmVmb3JlQ2hhbmdlOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIGNoYW5nZUV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgY2xpY2tIYW5kbGUgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGNoYW5nZWQgdmFsdWVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicpIHN3aXRjaEVsUmVmOiBFbGVtZW50UmVmPGFueT47XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgQEluamVjdChTV0lUQ0hfT1BUSU9OUykgQE9wdGlvbmFsKCkgcHVibGljIGNvbmZpZzogU3dpdGNoTW9kdWxlQ29uZmlnID0ge30sXHJcbiAgICAgICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgICAgIHB1YmxpYyBpbmplY3RvcjogSW5qZWN0b3JcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMuc3F1YXJlID0gKGNvbmZpZyAmJiBjb25maWcuc3F1YXJlKSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLnNpemUgPSAoY29uZmlnICYmIGNvbmZpZy5zaXplKSB8fCB0aGlzLnNpemU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbmZpZyAmJiBjb25maWcuY29sb3I7XHJcbiAgICAgICAgdGhpcy5zd2l0Y2hPZmZDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuc3dpdGNoT2ZmQ29sb3I7XHJcbiAgICAgICAgdGhpcy5zd2l0Y2hDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuc3dpdGNoQ29sb3I7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0QmdDb2xvciA9IGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdEJnQ29sb3I7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Qm9Db2xvciA9IGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdEJvQ29sb3I7XHJcbiAgICAgICAgdGhpcy5jaGVja2VkTGFiZWwgPSBjb25maWcgJiYgY29uZmlnLmNoZWNrZWRMYWJlbDtcclxuICAgICAgICB0aGlzLnVuY2hlY2tlZExhYmVsID0gY29uZmlnICYmIGNvbmZpZy51bmNoZWNrZWRMYWJlbDtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fYmVmb3JlQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JlZm9yZUNoYW5nZS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRDb2xvcihmbGFnID0gJycpIHtcclxuICAgICAgICBpZiAoZmxhZyA9PT0gJ2JvcmRlckNvbG9yJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0Qm9Db2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZsYWcgPT09ICdzd2l0Y2hDb2xvcicpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmNoZWNrZWRcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc3dpdGNoQ29sb3JcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuc3dpdGNoT2ZmQ29sb3IgfHwgdGhpcy5zd2l0Y2hDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VkXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMuc3dpdGNoQ29sb3JcclxuICAgICAgICAgICAgICAgIDogdGhpcy5zd2l0Y2hPZmZDb2xvciB8fCB0aGlzLnN3aXRjaENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZXZlcnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5jaGVja2VkID8gdGhpcy5jb2xvciA6IHRoaXMuZGVmYXVsdEJnQ29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrZWQgPyB0aGlzLmNvbG9yIDogdGhpcy5kZWZhdWx0QmdDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZUNoZWNrZWQoZXZlbnQ6IGFueSwgaXNDbGljayA9IHRydWUpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5lZGl0YWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcclxuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmdldFZhbHVlKHRoaXMuY2hlY2tlZCk7XHJcbiAgICAgICAgLy8gQ29tcG9uZW50IGV2ZW50c1xyXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWwpO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRXZlbnQuZW1pdChldmVudCk7XHJcbiAgICAgICAgaWYgKGlzQ2xpY2spIHtcclxuICAgICAgICAgICAgdGhpcy5jbGlja0hhbmRsZS5lbWl0KHsgZXZlbnQsIGNoZWNrZWQ6IHRoaXMuY2hlY2tlZCwgdmFsdWU6IHZhbCwgaW5zdGFuY2U6IHRoaXMgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsKTtcclxuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKHZhbCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNkclsnZGVzdHJveWVkJ10pIHtcclxuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXHJcbiAgICBvblRvZ2dsZShldmVudDogTW91c2VFdmVudCkge1xyXG5cclxuICAgICAgICBjb25zdCBzcGFuID0gKDxhbnk+ZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuZi1jbXAtc3dpdGNoJylcclxuXHJcbiAgICAgICAgaWYgKCFzcGFuIHx8IHNwYW4gIT09IHRoaXMuc3dpdGNoRWxSZWYubmF0aXZlRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmVmb3JlQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JlZm9yZUNoYW5nZSA9IHRoaXMuYmVmb3JlQ2hhbmdlLnN1YnNjcmliZSgoY29uZmlybTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrZWQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrZWQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLlNwYWNlJywgWyckZXZlbnQnXSlcclxuICAgIG9uU3BhY2VIYW5kbGUoJGV2ZW50OiBhbnkpIHtcclxuICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDaGVja2VkKCRldmVudCwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0VmFsdWUoY2hlY2tlZDogYm9vbGVhbikge1xyXG4gICAgICAgIGlmICh0aGlzLnRydWVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmFsc2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGVja2VkID8gdGhpcy50cnVlVmFsdWUgOiB0aGlzLmZhbHNlVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGVja2VkO1xyXG4gICAgfVxyXG5cclxuICAgIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy50cnVlVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZhbHNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSBvYmogPT0gdGhpcy50cnVlVmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG9iaiAhPT0gdGhpcy5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSAhIW9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2RyICYmICF0aGlzLmNkclsnZGVzdHJveWVkJ10pIHtcclxuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25Ub3VjaGVkQ2FsbGJhY2sgPSAodjogYW55KSA9PiB7IH07XHJcbiAgICBwcml2YXRlIG9uQ2hhbmdlQ2FsbGJhY2sgPSAodjogYW55KSA9PiB7IH07XHJcbn1cclxuIl19