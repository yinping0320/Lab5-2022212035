import { Observable } from 'rxjs';
import { HttpClient } from '@farris/mobile-devkit';
import { FrameworkSessionService } from '../../framework_session_service';
import { BeSessionStorageStrategy } from '../storage-strategies/index';
import { BefSessionHandlingStrategy } from './handling_strategy';
/**
 * 统一的Session处理策略
 * @todo
 * 1、目前Session其实还是隔离的，因为使用了beBaseUrl做了缓存；
 * 2、将来框架token问题解决了之后，使用token或者表单基url做缓存key；
 * 3、基于2缓存之后，如何closeSession，成为问题，除非appAcontext是一颗树，只有根AppContext初始化的时候，才去closeSession。
 */
declare class BefUnifiedSessionHandlingStrategy extends BefSessionHandlingStrategy {
    /**
     * 构造函数
     */
    constructor(storageStrategy: BeSessionStorageStrategy, frmSessionService: FrameworkSessionService, httpClient: HttpClient, beBaseUrl: string);
    /**
     * 获取BeSession
     */
    getSessionId(): Observable<string>;
    /**
     * 设置BeSessionId
     */
    setSessionId(sessionId: string): void;
    /**
     * 清空Sessionid
     */
    clearSessionId(): void;
    /**
     * 扩展Session相关头信息
     */
    handleRequestHeaders(headers: any): any;
    /**
     * 处理服务器端返回的headers
     */
    handleReponseHeaders(headers: any): void;
    /**
     * 获取某个Repository对应的BeSession的唯一key
     */
    protected getSessionStorageKey(): string;
}
export { BefUnifiedSessionHandlingStrategy };
