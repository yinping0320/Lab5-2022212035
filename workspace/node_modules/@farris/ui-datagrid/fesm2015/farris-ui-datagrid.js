import { InjectionToken, EventEmitter, Injectable, Injector, NgModule, Directive, NgZone, KeyValueDiffers, ElementRef, Inject, PLATFORM_ID, Optional, Input, Output, Component, ViewEncapsulation, ChangeDetectorRef, HostBinding, ViewChild, TemplateRef, ContentChild, Renderer2, ChangeDetectionStrategy, ApplicationRef, ContentChildren, HostListener, LOCALE_ID, Pipe, forwardRef, Self, ComponentFactoryResolver, ViewContainerRef, defineInjectable, ErrorHandler } from '@angular/core';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { bindCallback, of, BehaviorSubject, Subject, fromEvent, merge, noop } from 'rxjs';
import { filter, map, switchMap, distinctUntilChanged, debounceTime, takeUntil, auditTime, mapTo, delay } from 'rxjs/operators';
import { cloneDeep, flatten, groupBy, isPlainObject, trim } from 'lodash-es';
import { BigNumber } from 'bignumber.js';
import { IdService, CommonUtils, FarrisComponentInstanceService, DebugService, WEBAPI_PREFIX_TOKEN, OverLayHiddenService, FarrisCommonModule } from '@farris/ui-common';
import { LocaleService, LocaleModule } from '@farris/ui-locale';
import { Compare } from '@farris/ui-common/types';
import { CommonModule, isPlatformBrowser } from '@angular/common';
import PerfectScrollbar from 'perfect-scrollbar';
import ResizeObserver from 'resize-observer-polyfill';
import { FilterPanelService, FilterPanelModule } from '@farris/ui-filter-panel';
import { DomSanitizer } from '@angular/platform-browser';
import { ColumnFormatService, DataColumnModule } from '@farris/ui-common/column';
import { FormGroup, Validators, FormBuilder, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { NotifyService, NotifyModule } from '@farris/ui-notify';
import { PaginationModule } from '@farris/ui-pagination';
import { SimpleFilterModule } from '@farris/ui-filter';
import { smoothDnD, dropHandlers } from '@farris/smooth-dnd';
import { FarrisContextMenuModule } from '@farris/ui-context-menu';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ColumnFilterType = {
    string: 0,
    number: 1,
    boolean: 2,
    date: 3,
    time: 4,
    datetime: 5,
    enum: 6,
    fromdata: 7,
};
ColumnFilterType[ColumnFilterType.string] = 'string';
ColumnFilterType[ColumnFilterType.number] = 'number';
ColumnFilterType[ColumnFilterType.boolean] = 'boolean';
ColumnFilterType[ColumnFilterType.date] = 'date';
ColumnFilterType[ColumnFilterType.time] = 'time';
ColumnFilterType[ColumnFilterType.datetime] = 'datetime';
ColumnFilterType[ColumnFilterType.enum] = 'enum';
ColumnFilterType[ColumnFilterType.fromdata] = 'fromdata';
/** @enum {number} */
const CalculationType = {
    /** 无 */
    none: -1,
    /** 最大值 */
    max: 0,
    /** 最小值 */
    min: 1,
    /** 求和 */
    sum: 2,
    /** 平均数 */
    average: 3,
    /** 总记录数 */
    count: 4,
};
CalculationType[CalculationType.none] = 'none';
CalculationType[CalculationType.max] = 'max';
CalculationType[CalculationType.min] = 'min';
CalculationType[CalculationType.sum] = 'sum';
CalculationType[CalculationType.average] = 'average';
CalculationType[CalculationType.count] = 'count';
/** @type {?} */
const defaultPaginationInfo = {
    enable: true,
    pageIndex: 1,
    pageSize: 10
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const GRID_EDITORS = new InjectionToken('Farris DataGrid Editors.');
/** @type {?} */
const GRID_VALIDATORS = new InjectionToken('Farris DataGrid Validators.');
/** @type {?} */
const GRID_FILTER_ROW = new InjectionToken('Farris DataGrid Filter-Row Component.');
/** @type {?} */
const GRID_SETTINGS_PANEL = new InjectionToken('Farris DataGrid Setting Panel Component.');
/** @type {?} */
const GRID_SETTINGS_SERVICE = new InjectionToken('Farris DataGrid Setting Service.');
/** @type {?} */
const GRID_SETTINGS_HTTP = new InjectionToken(' Datagrid Settings HttpClient.');
/** @type {?} */
const SCROLL_Y_ACTION = 'psScrollY';
/** @type {?} */
const SCROLL_X_ACTION = 'psScrollX';
/** @type {?} */
const SCROLL_UP_ACTION = 'psScrollUp';
/** @type {?} */
const SCROLL_DOWN_ACTION = 'psScrollDown';
/** @type {?} */
const SCROLL_LEFT_ACTION = 'psScrollLeft';
/** @type {?} */
const SCROLL_RIGHT_ACTION = 'psScrollRight';
/** @type {?} */
const SCROLL_Y_REACH_END_ACTION = 'psYReachEnd';
/** @type {?} */
const SCROLL_Y_REACH_START_ACTION = 'psYReachStart';
/** @type {?} */
const SCROLL_X_REACH_END_ACTION = 'psXReachEnd';
/** @type {?} */
const SCROLL_X_REACH_START_ACTION = 'psXReachStart';
/** @type {?} */
const DATAGRID_SETTING_FIELDNAME = '_DATAGRID_CONTROL_PANEL_';
/**
 * 左侧固定列阴影样式名称
 * @type {?}
 */
const FIXED_LEFT_SHADOW_CLS = 'f-datagrid-fixed-left-shadow';
/** @type {?} */
const FIXED_RIGHT_SHADOW_CLS = 'f-datagrid-fixed-right-shadow';
/** @type {?} */
const ROW_HOVER_CLS = 'f-datagrid-row-hover';
/** @type {?} */
const ROW_SELECTED_CLS = 'f-datagrid-row-selected';
/** @type {?} */
const CELL_SELECTED_CLS = 'f-datagrid-cell-selected';
/** @type {?} */
const CELL_EDITING_CLS = 'f-datagrid-cell-editing';
/**
 * 行高尺寸定义
 * @type {?}
 */
const SIZE_TYPE = {
    sm: {
        row: 29,
        // 行高
        header: 35,
        // 表头行高
        pager: 40 // 分页条高度
    },
    md: {
        row: 36,
        header: 40,
        pager: 44
    },
    lg: {
        row: 46,
        header: 40,
        pager: 44
    },
    xl: {
        row: 60,
        header: 40,
        pager: 44
    },
};
/**
 * 允许编辑时，醒目显示可编辑单元格的样式
 * @type {?}
 */
const ALLOW_EDIT_CELL_HIGHLIGHT_CLS = {
    datagrid: 'highlight-allowedit-cell',
    textarea: 'cell-textarea',
    textbox: 'cell-textbox',
    checkbox: 'cell-checkbox',
    datepicker: 'cell-datepicker',
    'input-group': 'cell-input-group',
    select: 'cell-combolist',
    lookup: 'cell-lookup',
    numberbox: 'cell-numberbox',
    combolist: 'cell-combolist',
    'combo-lookup': 'cell-combolist',
    switch: 'cell-switch',
    timepicker: 'cell-timepicker',
    'language-textbox': 'cell-language-textbox',
    'enum-editor': 'cell-enum-editor'
};
/** @type {?} */
const TR_PREFIX = 'row_';
/** @type {?} */
const TR_ID_PREFIX = 'row_';
/** @type {?} */
const CUSTOM_CELL_CLS = 'customcellcls_';
/** @type {?} */
const CUSTOM_GROUP_ROW_CLS = 'customgrouprowcls_';
/** @type {?} */
const CUSTOM_ROW_CLS = 'customrowcls_';
/**
 * 折行高度cls 前缀 wrap_row_height_
 * @type {?}
 */
const WORDWRAP_ROW_HEIGHT_CLS = 'wrap_row_height_';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const initDataGridState = {
    idField: 'id',
    showLineNumber: false,
    selections: [],
    checkedRows: [],
    currentRow: null,
    columnsGroup: null,
    columns: [],
    fitColumns: false,
    onlySelectSelf: true,
    selectOnCheck: true,
    checkOnSelect: true,
    pageIndex: 1,
    pageSize: 20,
    pagerHeight: 40,
    checkboxColumnWidth: 36,
    pagination: false,
    virtual: {
        rowIndex: 0,
        scrollTop: 0,
        topHideHeight: 0,
        bottomHideHeight: 0,
        isScrollChange: false
    },
    sortName: undefined,
    sortOrder: undefined,
    multiSort: false,
    remoteSort: true,
    changes: null,
    showGroupColumn: false
};
/**
 * 行索引
 * @type {?}
 */
const ROW_INDEX_FIELD = '__row_index__';
/**
 * 是否为分组行
 * @type {?}
 */
const IS_GROUP_ROW_FIELD = '__group__';
/**
 * 引用的分组行属性
 * @type {?}
 */
const GROUP_ROW_FIELD = '__group_parent_id__';
/**
 * 是否为分组合计行
 * @type {?}
 */
const IS_GROUP_FOOTER_ROW_FIELD = '__group_footer__';
/** @type {?} */
const GROUP_VISIBLE_FIELD = '__group_visible__';
/** @type {?} */
const GROUP_LEVEL_FIELD = '__group_level__';
/** @type {?} */
const IgnoreProperties = [
    'afterEdit',
    'app',
    'beforeCheck',
    'beforeClickCell',
    'beforeEdit',
    'beforeSelect',
    'beforeSortColumn',
    'beforeUncheck',
    'beforeUnselect',
    'beginEdit',
    'cancelEdited',
    'cd',
    'cellClick',
    'checkAll',
    'checkValuesChange',
    'checked',
    'checkedChange',
    'clientFilterService',
    'colFormatSer',
    'columnMoved',
    'columnSorted',
    'componentType',
    'dataChange',
    'dblclickRow',
    'destroy$',
    'dfs',
    'dgColumns',
    'dgContainer',
    'dgPager',
    'dgs',
    'domSanitizer',
    'editors',
    'el',
    'endEdit',
    'farrisInstances',
    'filterChanged',
    'footerTemplate',
    'groupFieldChange',
    'groupFields$',
    'inject',
    'lastCellEnterHandle',
    'loadSuccess',
    'localeService',
    'longTextArea',
    'rowAppended',
    'rowClick',
    'rowDeleted',
    'render2',
    'pageSizeChanged',
    'onDocumentMouseDown',
    'pageChanged',
    'resizeProxy',
    'resizeProxyBg',
    'ro',
    'rowUpdated',
    'scrollInstance',
    'scrollY',
    'scrollYLoad',
    'selectAll',
    'selectChanged',
    'sms',
    'selectValueChange',
    'selectValuesChange',
    'settingService',
    'smartFilterService',
    'subscriptions',
    'trackByRows',
    'unCheckAll',
    'unChecked',
    'unSelect',
    'unSelectAll',
    'zone',
    '__component_type__',
    '__pagination',
    '_active_datagrid_cls',
    '_autoFitColumns',
    '_blured_datagrid_cls',
    '_columns',
    '_custom_datagrid_cls',
    '_editable',
    '_fields',
    '_fit',
    '_fitColumns',
    '_footerData',
    '_groupField',
    '_isResized',
    '_loading',
    '_lockPagination',
    '_selectedRow',
    '_showRowGroupPanel',
    '_sizeType',
    '_total',
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * @Author: 疯狂秀才(Lucas Huang)
 * @Date: 2019-08-06 07:43:53
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-11-19 20:31:27
 * @QQ: 1055818239
 * @Version: v0.0.1
 */
class Utils {
    /**
     * @return {?}
     */
    static uuid() {
        /**
         * @return {?}
         */
        function S4() {
            // tslint:disable-next-line: no-bitwise
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());
    }
    /**
     * @param {?} field
     * @param {?} data
     * @return {?}
     */
    static keysInData(field, data) {
        /** @type {?} */
        const noProperty = 'no property';
        /** @type {?} */
        const val = field.split('.').reduce((/**
         * @param {?} obj
         * @param {?} key
         * @return {?}
         */
        (obj, key) => {
            if (obj && obj.hasOwnProperty(key)) {
                return obj[key];
            }
            else {
                return noProperty;
            }
        }), data);
        return val != noProperty;
    }
    /**
     * 获取对象中指定字段的值。 field: 可以为带有层级结构的路径，如： user.firstName | name 等
     * @param {?} field
     * @param {?} data
     * @param {?=} safe
     * @return {?}
     */
    static getValue(field, data, safe = false) {
        if (!data) {
            return '';
        }
        /** @type {?} */
        let resultVal = '';
        if (field.indexOf('.') === -1 || data.hasOwnProperty(field)) {
            resultVal = data[field];
        }
        else {
            resultVal = field.split('.').reduce((/**
             * @param {?} obj
             * @param {?} key
             * @return {?}
             */
            (obj, key) => {
                if (obj) {
                    return obj[key];
                }
                else {
                    return null;
                }
            }), data);
        }
        if (safe) {
            return this.escapeValue(resultVal);
        }
        return resultVal;
    }
    /**
     * @param {?} field
     * @param {?} val
     * @param {?} obj
     * @param {?=} nest
     * @return {?}
     */
    static setValue(field, val, obj, nest = true) {
        if (field) {
            if (field.indexOf('.') > -1 && nest) {
                /** @type {?} */
                let lastObj = null;
                /** @type {?} */
                const _fields = field.split('.');
                _fields.reduce((/**
                 * @param {?} c
                 * @param {?} p
                 * @return {?}
                 */
                (c, p) => {
                    lastObj = c;
                    return c[p];
                }), obj);
                if (lastObj) {
                    lastObj[_fields.pop()] = val;
                }
            }
            else {
                obj[field] = val;
            }
        }
    }
    /**
     * 获取多语值
     * @param {?} valObj
     * @param {?} localeId
     * @return {?}
     */
    static getMultilingualValue(valObj, localeId) {
        if (valObj && typeof valObj === 'object' && Object.keys(valObj).length > 0) {
            localeId = localeId || 'zh-CHS';
            /** @type {?} */
            const val = valObj[localeId];
            if (val !== undefined) {
                return val;
            }
            else {
                return '';
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    static escapeValue(val) {
        if (val === null || val === undefined || val === '') {
            return '';
        }
        /** @type {?} */
        const escapeHTML = (/**
         * @param {?} unsafe_str
         * @return {?}
         */
        (unsafe_str) => {
            return unsafe_str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\"/g, '&quot;')
                .replace(/\'/g, '&#39;')
                .replace(/\//g, '&#x2F;');
            // .replace('src','drc');
        });
        if (typeof val === 'string') {
            return escapeHTML(val);
        }
        return val;
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    static eventPath(evt) {
        /** @type {?} */
        const path = (evt.composedPath && evt.composedPath()) || evt.path;
        /** @type {?} */
        const target = evt.target;
        if (path != null) {
            return (path.indexOf(window) < 0) ? path.concat(window) : path;
        }
        if (target === window) {
            return [window];
        }
        /** @type {?} */
        const getParents = (/**
         * @param {?} node
         * @param {?=} memo
         * @return {?}
         */
        (node, memo = undefined) => {
            memo = memo || [];
            /** @type {?} */
            const parentNode = node.parentNode;
            if (!parentNode) {
                return memo;
            }
            else {
                return getParents(parentNode, memo.concat(parentNode));
            }
        });
        return [target].concat(getParents(target), window);
    }
    /**
     * @return {?}
     */
    static hasDialogOpen() {
        // return document.body.classList.value.indexOf('modal-open') > -1;
        // 兼容IE 11
        return document.body.className.indexOf('modal-open') > -1;
    }
    /**
     * @param {?} el
     * @param {?} evt
     * @param {?} fn
     * @param {?=} opts
     * @return {?}
     */
    static on(el, evt, fn, opts = {}) {
        /** @type {?} */
        const delegatorFn = (/**
         * @param {?} e
         * @return {?}
         */
        e => e.target.matches(opts.target) && fn.call(e.target, e));
        el.addEventListener(evt, opts.target ? delegatorFn : fn, opts.options || false);
        return (/**
         * @return {?}
         */
        () => {
            el.removeEventListener(evt, delegatorFn, opts);
        });
    }
    /**
     * @param {?} el
     * @param {?} evt
     * @param {?=} fn
     * @param {?=} opts
     * @return {?}
     */
    static off(el, evt, fn = (/**
     * @return {?}
     */
    () => { }), opts = {}) {
        el.removeEventListener(evt, fn, opts);
    }
    /**
     * 获取字符长度，中文汉字占2个字符
     * @param {?} str
     * @return {?}
     */
    static getBLen(str) {
        if (str == null) {
            return 0;
        }
        if (typeof str !== 'string') {
            str += '';
        }
        return str.replace(/[^\x00-\xff]/g, '01').length;
    }
    // static difference(first: any[], second: any[]): any[] {
    //     return first.filter(item => !second.includes(item));
    // }
    // static getDiffItems(arr1, arr2) {
    //     const diff1 = Utils.difference(arr1, arr2);
    //     const diff2 = Utils.difference(arr2, arr1);
    //     return diff1.concat(diff2);
    // }
    /**
     * @param {?} col
     * @param {?} localeId
     * @return {?}
     */
    static getWhenEmptyText(col, localeId) {
        /** @type {?} */
        const EMPTY_INPUT_TEXT = {
            'zh-CHS': '请输入',
            'zh-CHT': '請輸入',
            en: 'Please input'
        };
        /** @type {?} */
        const EMPTY_SELECT_TEXT = {
            'zh-CHS': '请选择',
            'zh-CHT': '請選擇',
            en: 'Please select'
        };
        if (col.editor) {
            switch (col.editor.type) {
                case 'datepicker':
                case 'select':
                case 'lookup':
                case 'combolist':
                case 'combo-lookup':
                    return EMPTY_SELECT_TEXT[localeId];
                default:
                    return EMPTY_INPUT_TEXT[localeId];
            }
        }
        // 控制面板列
        if (col.field === '_datagrid-setting-control_') {
            return '';
        }
        return EMPTY_INPUT_TEXT[localeId];
    }
    /**
     * @param {?} tr
     * @return {?}
     */
    static getRowIdByTr(tr) {
        if (tr) {
            /** @type {?} */
            let id = tr.getAttribute('id');
            if (id == null || id == undefined) {
                return null;
            }
            return id.replace(TR_PREFIX, '').replace('_fixedright', '').replace('_fixedleft', '').replace('_grouprow', '');
        }
        return null;
    }
    /**
     * @param {?} dataid
     * @param {?} parentElement
     * @return {?}
     */
    static getTrDomById(dataid, parentElement) {
        if (parentElement) {
            return parentElement.querySelector(`[id="${dataid}"]`);
        }
        return null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridColumnsHelper {
    /**
     * 获取总列数
     * @private
     * @param {?} firstCols
     * @return {?}
     */
    static getColumnTotal(firstCols) {
        /** @type {?} */
        let total = 0;
        firstCols.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            total += (n.colspan || 1);
        }));
        return total;
    }
    // 查找未赋值项的索引
    /**
     * @private
     * @param {?} arr
     * @return {?}
     */
    static findUndefinedItem(arr) {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] == undefined) {
                return i;
            }
        }
        return -1;
    }
    /**
     * @private
     * @param {?} columns
     * @return {?}
     */
    static getColumnFields(columns) {
        /** @type {?} */
        const aa = [];
        // 根据第一行计算总列数
        /** @type {?} */
        const colTotal = DatagridColumnsHelper.getColumnTotal(columns[0]);
        // 创建空数组
        for (let i = 0; i < columns.length; i++) {
            aa[i] = new Array(colTotal);
        }
        for (let i = 0; i < columns.length; i++) {
            columns[i].forEach((/**
             * @param {?} col
             * @return {?}
             */
            col => {
                /** @type {?} */
                let k = DatagridColumnsHelper.findUndefinedItem(aa[i]);
                if (k >= 0) {
                    /** @type {?} */
                    const field = col.field || col.id || '';
                    for (let c = 0; c < (col.colspan || 1); c++) {
                        for (let r = 0; r < (col.rowspan || 1); r++) {
                            aa[i + r][k] = field;
                        }
                        k++;
                    }
                }
            }));
        }
        return aa;
    }
    /**
     * @param {?} col
     * @param {?} ins
     * @return {?}
     */
    static columnIsVisible(col, ins) {
        if (col.visible === undefined) {
            col.visible = true;
        }
        /** @type {?} */
        const t = typeof col.visible;
        if (t === 'boolean') {
            return col.visible;
        }
        else if (t === 'function') {
            return col.visible({ instance: ins, column: col });
        }
        else {
            return true;
        }
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    static getFields(columns) {
        // 移除隐藏的列
        /** @type {?} */
        const _cols = columns.map((/**
         * @param {?} cols
         * @return {?}
         */
        cols => {
            cols = cols.filter((/**
             * @param {?} col
             * @return {?}
             */
            col => DatagridColumnsHelper.columnIsVisible(col, DatagridColumnsHelper.gridInstance)));
            return cols;
        }));
        /** @type {?} */
        const fields = DatagridColumnsHelper.getColumnFields(_cols);
        return fields.length ? fields[fields.length - 1] : fields;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    static getFilterEnumOptions(column) {
        /** @type {?} */
        let enumSetting = null;
        if (column.filter.type === ColumnFilterType.enum) {
            /** @type {?} */
            const fmt = (/** @type {?} */ (column.formatter));
            if (fmt) {
                enumSetting = fmt.options;
            }
            else {
                if (column.filter.options) {
                    enumSetting = column.filter.options;
                }
            }
        }
        return enumSetting;
    }
    /**
     * @param {?} enumOpts
     * @param {?} value1
     * @return {?}
     */
    static getEnumText(enumOpts, value1) {
        if (!enumOpts) {
            return '';
        }
        const { valueField, textField, data } = enumOpts;
        /** @type {?} */
        let str = '';
        if (value1) {
            str += ` ${value1.map((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                /** @type {?} */
                const enumItem = data.find((/**
                 * @param {?} d
                 * @return {?}
                 */
                d => d[valueField] === v));
                return enumItem[textField];
            })).join(',')}`;
        }
        return str;
    }
    /**
     * @param {?} col
     * @return {?}
     */
    static columnVisibleAsObservable(col) {
        if (typeof col.visible === 'function') {
            /** @type {?} */
            const visibleAsObservable = bindCallback(col.visible);
            return visibleAsObservable();
        }
        return of(col.visible);
    }
    /**
     * @param {?} col
     * @param {?} allCols
     * @return {?}
     */
    static getParentColumns(col, allCols) {
        /** @type {?} */
        const arr = [];
        /** @type {?} */
        const _getParents = (/**
         * @param {?} c
         * @return {?}
         */
        (c) => {
            if (c && c.parentId) {
                /** @type {?} */
                const parentCol = allCols.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id === c.parentId));
                // arr.splice(0, 0, parentCol);
                arr.push(parentCol);
                _getParents(parentCol);
            }
        });
        _getParents(col);
        return arr;
    }
    /**
     * @param {?} col
     * @param {?} allCols
     * @return {?}
     */
    static getChildColumns(col, allCols) {
        /** @type {?} */
        const arr = [];
        /** @type {?} */
        const _getChilds = (/**
         * @param {?} c
         * @return {?}
         */
        (c) => {
            if (c && c.parentId) {
                /** @type {?} */
                const childs = allCols.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.parentId === c.id));
                arr.splice(0, 0, ...childs);
                childs.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                child => {
                    _getChilds(child);
                }));
            }
        });
        _getChilds(col);
        return arr;
    }
    // 检查多表头时，设计器中将列设为隐藏
    /**
     * @param {?} allCols
     * @return {?}
     */
    static checkGroupHeaderColumnVisible(allCols) {
        /** @type {?} */
        const hiddenFields = allCols.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.visible === false)).map((/**
         * @param {?} n
         * @return {?}
         */
        n => n.field));
        hiddenFields.forEach((/**
         * @param {?} field
         * @return {?}
         */
        field => {
            /** @type {?} */
            const _col = allCols.find((/**
             * @param {?} col
             * @return {?}
             */
            col => col.field === field || col.id === field));
            if (_col) {
                /** @type {?} */
                const parents = DatagridColumnsHelper.getParentColumns(_col, allCols);
                parents.forEach((/**
                 * @param {?} p
                 * @return {?}
                 */
                p => {
                    /** @type {?} */
                    const _childs = allCols.filter((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n.parentId === p.id && (n.visible || n.visible === undefined)));
                    p.colspan = _childs.reduce((/**
                     * @param {?} r
                     * @param {?} c
                     * @return {?}
                     */
                    (r, c) => {
                        r = r + (c.colspan || 1);
                        return r;
                    }), 0);
                    p.visible = !!p.colspan;
                }));
            }
        }));
    }
    // 多表头下仅有一列显示
    /**
     * @return {?}
     */
    static onlyOneColumn() {
    }
}
DatagridColumnsHelper.gridInstance = null;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridFacadeService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        this.localId = 'zh-CHS';
        // public virtualizedService: VirtualizedLoaderService;
        this.store = new BehaviorSubject(null);
        this.virtualRowSubject = new BehaviorSubject(null);
        this.gridSizeSubject = new Subject();
        this.errorSubject = new Subject();
        this.selectRowSubject = new Subject();
        this.unSelectRowSubject = new Subject();
        this.columnResizeSubject = new Subject();
        this.clearSelectionSubject = new Subject();
        this.checkRowSubject = new Subject();
        this.unCheckRowSubject = new Subject();
        this.clearCheckedsSubject = new Subject();
        this.clearAllSubject = new Subject();
        this.checkAllSubject = new Subject();
        this.unCheckAllSubject = new Subject();
        this.selectAllSubject = new Subject();
        this.selectCellSubject = new Subject();
        this.error$ = this.errorSubject.asObservable();
        this.selectRow$ = this.selectRowSubject.asObservable();
        this.unSelectRow$ = this.unSelectRowSubject.asObservable();
        this.columnResize$ = this.columnResizeSubject.asObservable();
        this.clearSelections$ = this.clearSelectionSubject.asObservable();
        this.checkRow$ = this.checkRowSubject.asObservable();
        this.unCheckRow$ = this.unCheckRowSubject.asObservable();
        this.clearCheckeds$ = this.clearCheckedsSubject.asObservable();
        this.clearAll$ = this.clearAllSubject.asObservable();
        this.checkAll$ = this.checkAllSubject.asObservable();
        this.unCheckAll$ = this.unCheckAllSubject.asObservable();
        this.selectAll$ = this.selectAllSubject.asObservable();
        this.currentCell$ = this.selectCellSubject.asObservable();
        this.editCell$ = new EventEmitter();
        this.clientSort$ = new EventEmitter();
        this.rowAppend$ = new EventEmitter();
        this.rowUpdate$ = new EventEmitter();
        this.rowDelete$ = new EventEmitter();
        this.expandGroupRow = new EventEmitter();
        this.collapseGroupRow = new EventEmitter();
        this.updateCheckboxState$ = new EventEmitter();
        this.state$ = this.store.asObservable().pipe(filter((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state)));
        this.columnGroup$ = this.gridSizeSubject.asObservable().pipe(filter((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state)), map((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state.columnsGroup)), switchMap((/**
         * @param {?} colgroup
         * @return {?}
         */
        (colgroup) => {
            return of(colgroup);
        })), distinctUntilChanged());
        this.gridSize$ = this.gridSizeSubject.asObservable().pipe(filter((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state)), map((/**
         * @param {?} state
         * @return {?}
         */
        (state) => {
            const { headerHeight, pagerHeight, width, columnsGroup, height, rowHeight } = Object.assign({}, state);
            return { headerHeight, pagerHeight, width, columnsGroup, height, rowHeight };
        })), distinctUntilChanged());
        this.data$ = this.virtualRowSubject.pipe(filter((/**
         * @param {?} vs
         * @return {?}
         */
        vs => vs)), switchMap((/**
         * @param {?} vs
         * @return {?}
         */
        (vs) => {
            return of({
                index: vs.startIndex || 0,
                rows: vs.virtualRows || [],
                top: vs.topHideHeight,
                bottom: vs.bottomHideHeight,
                scrolling: vs.isScrollChange
            });
        })), distinctUntilChanged());
        this.difference = (/**
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        (first, second) => first.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => !second.includes(item))));
        this.differenceBy = (/**
         * @param {?} a
         * @param {?} b
         * @param {?} fn
         * @return {?}
         */
        (a, b, fn) => {
            /** @type {?} */
            const s = new Set(b.map(fn));
            return a.map(fn).filter((/**
             * @param {?} el
             * @return {?}
             */
            el => !s.has(el)));
        });
        this._state = cloneDeep(initDataGridState);
    }
    /**
     * @param {?} scrolltop
     * @param {?=} isScrollChange
     * @return {?}
     */
    updateVirthualRows(scrolltop, isScrollChange = false) {
        /** @type {?} */
        const virtual = this.getVirthualRows(scrolltop);
        virtual.isScrollChange = isScrollChange;
        this.updateState({ virtual }, false);
        this.virtualRowSubject.next(virtual);
    }
    /**
     * @param {?} scrolltop
     * @return {?}
     */
    getVirthualRows(scrolltop) {
        /** @type {?} */
        const data = this._state.data || [];
        /** @type {?} */
        const virtual = { rowIndex: 0, virtualRows: data, topHideHeight: 0, bottomHideHeight: 0 };
        if (data.length === 0 || (this._state.autoHeight && !this._state.groupRows)) {
            virtual.virtualRows = data;
            return virtual;
        }
        if (this._state.flatColumns && this._state.flatColumns.length) {
            // data = this._state.data;
            // if (!this._state.groupRows) {
            //     if (this._state.virtual && this._state.virtualized) {
            //         this.virtualizedService.state = this._state;
            //         const rows = this.virtualizedService.getRows(scrolltop);
            //         virtual = { ...this._state.virtual, ...rows };
            //     } else {
            //         virtual.virtualRows = data;
            //     }
            // } else {
            //     // 行分组数据处理
            //     const groupRows = this.groupRows2(cloneDeep(data));
            //     virtual.virtualRows = groupRows;
            // }
            if (this._state.groupRows) {
                // 行分组数据处理
                /** @type {?} */
                const groupRows = this.groupRows2(cloneDeep(data));
                virtual.virtualRows = groupRows;
            }
        }
        if (this._state.mergeCell && this._state.enableClientSortForMergeCell) {
            virtual.virtualRows = this.sort(virtual.virtualRows);
        }
        return virtual;
    }
    /**
     * @param {?=} original
     * @return {?}
     */
    getData(original = false) {
        if (original) {
            return this._state.originalData || [];
        }
        return this._state.data || [];
    }
    /**
     * @return {?}
     */
    getState() {
        return this._state;
    }
    /**
     * @return {?}
     */
    getVirtualState() {
        return this._state.virtual;
    }
    /**
     * @return {?}
     */
    getPageInfo() {
        const { pageIndex, pageSize } = Object.assign({}, this._state);
        return { pageIndex, pageSize };
    }
    /**
     * @param {?} state
     * @return {?}
     */
    initState(state) {
        this.updateState(state, false);
        this._state.originalData = cloneDeep(this._state.data);
        this.initColumns();
        this.gridSizeSubject.next(this._state);
        this.updateVirthualRows(0);
    }
    /**
     * 加载数据
     * @param {?} data
     * @param {?=} updateOriginalData 是否更新原始数据, 默认为 true
     * @param {?=} sortable
     * @return {?}
     */
    loadData(data, updateOriginalData = true, sortable = false) {
        data = data || [];
        this.updateState({ data }, false);
        if (updateOriginalData) {
            this._state.originalData = cloneDeep(this._state.data);
        }
        if (sortable && this._state.sortName) {
            /** @type {?} */
            const sortedData = this.sort(this._state.data);
            this.updateState({ data: sortedData }, false);
        }
        this.updateVirthualRows(this._state.virtual.scrollTop || 0);
        this._state.checkedRows = this.getCheckedRowsFromSource();
    }
    /**
     * 复原指定行的数据
     * @param {?} rowId
     * @return {?}
     */
    resetRow(rowId) {
        /** @type {?} */
        const origData = this._state.originalData;
        if (origData) {
            /** @type {?} */
            const origRowData = origData.find((/**
             * @param {?} r
             * @return {?}
             */
            r => this.primaryId(r) === rowId));
            this.getCurrentRow().data = cloneDeep(origRowData);
            this.updateRow(rowId, origRowData);
        }
    }
    // loadDataForVirtual(data: any) {
    //     this.updateState({ data }, false);
    //     // this.virtualizedService.state = this._state;
    //     const virtual = { ...this._state.virtual, ...this.virtualizedService.reload() };
    //     this.virtualRowSubject.next(virtual);
    //     this.updateState({virtual});
    // }
    /**
     * @param {?} url
     * @return {?}
     */
    fetchData(url) {
        return this.http.get(url).pipe(map((/**
         * @param {?} r
         * @return {?}
         */
        r => (/** @type {?} */ (r)))));
    }
    /**
     * @param {?} total
     * @return {?}
     */
    setTotal(total) {
        this.updateState({ total }, false);
    }
    /**
     * @param {?} property
     * @param {?} value
     * @return {?}
     */
    updateProperty(property, value) {
        this.updateState({ [property]: value }, false);
    }
    /**
     * @param {?} pageIndex
     * @param {?} pageSize
     * @param {?} total
     * @return {?}
     */
    setPagination(pageIndex, pageSize, total) {
        this.updateState({ pageIndex, pageSize, total }, false);
    }
    /**
     * @param {?} scrollTop
     * @return {?}
     */
    setScrollTop(scrollTop) {
        /** @type {?} */
        const virtual = Object.assign({}, this._state.virtual, { scrollTop });
        this.updateState({ virtual }, false);
    }
    /**
     * @return {?}
     */
    isMultiSelect() {
        return this._state.multiSelect;
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    _isRowSelected(id) {
        if (!id || !this._state.currentRow) {
            return false;
        }
        else {
            return this._state.currentRow.id.toString() === id.toString();
        }
    }
    /**
     * @param {?} id
     * @param {?=} selections
     * @return {?}
     */
    isRowSelected(id, selections = null) {
        /** @type {?} */
        const flag = this._isRowSelected(id);
        if (!this.isMultiSelect() || this._state.onlySelectSelf) {
            return flag;
        }
        else {
            if (!selections) {
                selections = this._state.selections;
            }
            if (this._canCancelSelectWhenMulti()) {
                return flag;
            }
            if (!selections || selections.length === 0) {
                return false;
            }
            else {
                return selections.findIndex((/**
                 * @param {?} sr
                 * @return {?}
                 */
                sr => sr.id == id)) > -1;
            }
        }
    }
    /**
     * @param {?} id
     * @param {?=} checkeds
     * @return {?}
     */
    isRowChecked(id, checkeds = null) {
        if (!checkeds) {
            checkeds = this.getCheckeds();
        }
        if (!id || !checkeds.length) {
            return false;
        }
        return checkeds.findIndex((/**
         * @param {?} sr
         * @return {?}
         */
        sr => sr.id.toString() === id.toString())) > -1;
    }
    /**
     * @return {?}
     */
    isCheckAll() {
        /** @type {?} */
        const allRows = this.getAllRowsForLive().map((/**
         * @param {?} r
         * @return {?}
         */
        r => this.primaryId(r)));
        /** @type {?} */
        const checkIds = this._state.checkedRows.map((/**
         * @param {?} r
         * @return {?}
         */
        r => r.id));
        if (this.difference(allRows, checkIds).length) {
            return false; // this._state.checkedRows.length === allRows.length;
        }
        else {
            return true;
        }
    }
    /**
     * @return {?}
     */
    getCurrentPageCheckeds() {
        /** @type {?} */
        const allRows = this.getAllRowsForLive().map((/**
         * @param {?} r
         * @return {?}
         */
        r => this.primaryId(r)));
        return this._state.checkedRows.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => allRows.indexOf(n.id) > -1));
    }
    /**
     * @return {?}
     */
    getCurrentRow() {
        return this._state.currentRow || undefined;
    }
    /**
     * @return {?}
     */
    getSelections() {
        // 如果数据源变了，需要重新计算
        /** @type {?} */
        const data = this._state.data;
        if (this._state.selections && this._state.selections.length) {
            if (!data || !data.length) {
                this._state.selections = [];
            }
            else {
                /** @type {?} */
                const temp = data.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => this.primaryId(n)));
                this._state.selections = this._state.selections.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    return temp.includes(n.id);
                }));
            }
        }
        return this._state.selections || [];
    }
    /**
     * @private
     * @return {?}
     */
    getCheckedRowsFromSource() {
        return (this._state.checkedRows || []).map((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            /** @type {?} */
            const d = this.findRow(n.id);
            if (d && d.data) {
                n.data = d.data;
            }
            return n;
        }));
    }
    /**
     * @param {?=} fromDataSource
     * @return {?}
     */
    getCheckeds(fromDataSource = false) {
        if (fromDataSource) {
            this._state.checkedRows = this.getCheckedRowsFromSource();
        }
        return this._state.checkedRows || [];
    }
    /**
     * @param {?} rowid
     * @param {?} rowData
     * @return {?}
     */
    updateCheckedData(rowid, rowData) {
        /** @type {?} */
        const checkeds = this.getCheckeds();
        if (checkeds.length) {
            /** @type {?} */
            const item = checkeds.find((/**
             * @param {?} n
             * @return {?}
             */
            n => this.primaryId(n) == rowid));
            if (item) {
                Object.keys(rowData).forEach((/**
                 * @param {?} k
                 * @return {?}
                 */
                k => {
                    Utils.setValue(k, rowData[k], item.data);
                }));
            }
        }
    }
    /**
     * @param {?} ids
     * @param {?=} checked
     * @return {?}
     */
    setCheckedRows(ids, checked = true) {
        if (ids && ids.length) {
            /** @type {?} */
            let checkeds = this._state.checkedRows || [];
            ids.forEach((/**
             * @param {?} id
             * @return {?}
             */
            id => {
                /** @type {?} */
                const row = this.findRow(id);
                if (checked && row) {
                    if (!this.isRowChecked(id, checkeds)) {
                        /** @type {?} */
                        const srow = { id: this.primaryId(row.data), data: row.data, index: row.index };
                        checkeds.push(srow);
                    }
                }
                else {
                    if (!this._state.enableMorePageSelect || !checked) {
                        checkeds = checkeds.filter((/**
                         * @param {?} sr
                         * @return {?}
                         */
                        sr => sr.id !== id));
                    }
                }
            }));
            this._state.checkedRows = checkeds;
        }
        else {
            this._clearCheckeds();
        }
    }
    /**
     * @param {?} id
     * @param {?=} checked
     * @return {?}
     */
    checkRecord(id, checked = true) {
        if (id) {
            /** @type {?} */
            const row = this.findRow(id);
            if (row) {
                const { index: rowIndex, data: rowData } = Object.assign({}, row);
                if (checked) {
                    this.checkRow(rowIndex, rowData);
                }
                else {
                    this.unCheckRow(rowIndex, rowData);
                }
            }
            else {
                this.errorSubject.next(`未找到ID为${id}的数据。`);
            }
        }
        else {
            this.errorSubject.next(`参数id 不能为空。`);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @param {?=} grid
     * @return {?}
     */
    checkRow(rowIndex, rowData, grid = null) {
        if (!this._state.multiSelect) {
            this._clearCheckeds();
        }
        /** @type {?} */
        const id = this.primaryId(rowData);
        /** @type {?} */
        const checkeds = this._state.checkedRows || [];
        /** @type {?} */
        const srow = { id, data: rowData, index: rowIndex };
        if (id && !this.isRowChecked(id, checkeds)) {
            checkeds.push(srow);
            this._state.checkedRows = checkeds;
            if (this._state.selectOnCheck) {
                if (grid && grid.instance && grid.instance.beforeSelect) {
                    grid.instance.beforeSelect({ rowIndex, rowData, gridInstance: grid.instance }).subscribe((/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        if (e) {
                            this.selectRow(rowIndex, rowData);
                        }
                    }));
                }
                else {
                    this.selectRow(rowIndex, rowData);
                }
            }
            this.checkRowSubject.next(srow);
        }
        this.updateCheckboxState$.emit(Object.assign({}, srow, { checked: true }));
    }
    /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @param {?=} grid
     * @return {?}
     */
    unCheckRow(rowIndex, rowData, grid = null) {
        /** @type {?} */
        const id = this.primaryId(rowData);
        /** @type {?} */
        let checkeds = this._state.checkedRows || [];
        /** @type {?} */
        const srow = { id, data: rowData, index: rowIndex };
        if (this.isRowChecked(id, checkeds)) {
            checkeds = checkeds.filter((/**
             * @param {?} sr
             * @return {?}
             */
            sr => '' + sr.id !== '' + id));
            this._state.checkedRows = checkeds;
            if (this._state.selectOnCheck) {
                if (grid && grid.instance && grid.instance.beforeUnselect) {
                    grid.instance.beforeUnselect({ rowIndex, rowData, gridInstance: grid.instance }).subscribe((/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        if (e) {
                            this.unSelectRow(rowIndex, rowData);
                        }
                    }));
                }
                else {
                    this.unSelectRow(rowIndex, rowData);
                }
            }
            this.unCheckRowSubject.next(srow);
        }
        this.updateCheckboxState$.emit(Object.assign({}, srow, { checked: false }));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    setCurrentPageData(data) {
        this._state.currentPageData = data;
    }
    /**
     * @return {?}
     */
    getCurrentPageData() {
        return this._state.currentPageData || [];
    }
    /**
     * 获取所有可以操作的行
     * @private
     * @return {?}
     */
    getAllRowsForLive() {
        /** @type {?} */
        let allData = this._state.data || [];
        if (this._state.pagination && !this._state.pagerOnServer) {
            // 获取当前页数据
            allData = this.getCurrentPageData();
        }
        // 排除掉禁用的行
        if (this._state.disableRow) {
            allData = allData.filter((/**
             * @param {?} n
             * @param {?} i
             * @return {?}
             */
            (n, i) => !this._state.disableRow(n, i)));
        }
        return allData;
    }
    /**
     * @return {?}
     */
    checkAll() {
        this._state.checkedRows = this._state.checkedRows || [];
        /** @type {?} */
        const allData = this.getAllRowsForLive();
        /** @type {?} */
        const allCheckeds = allData.map((/**
         * @param {?} r
         * @param {?} i
         * @return {?}
         */
        (r, i) => {
            return {
                id: this.primaryId(r),
                index: i,
                data: r
            };
        }));
        if (!this._state.checkedRows.length) {
            this._state.checkedRows = allCheckeds;
        }
        else {
            /** @type {?} */
            const _checkeds = [];
            allCheckeds.forEach((/**
             * @param {?} element
             * @return {?}
             */
            element => {
                if (!this._state.checkedRows.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.id == element.id))) {
                    _checkeds.push(element);
                }
            }));
            this._state.checkedRows = this._state.checkedRows.concat(_checkeds);
        }
        if (this._state.selectOnCheck && !this._state.onlySelectSelf) {
            this._state.selections = [];
            this._state.selections = allData.map((/**
             * @param {?} r
             * @param {?} i
             * @return {?}
             */
            (r, i) => {
                return {
                    id: this.primaryId(r),
                    index: i,
                    data: r
                };
            }));
        }
        this.checkAllSubject.next(this._state.checkedRows);
    }
    /**
     * @return {?}
     */
    selectAll() {
        this._state.selections = [];
        /** @type {?} */
        const allData = this.getAllRowsForLive();
        this._state.selections = allData.map((/**
         * @param {?} r
         * @param {?} i
         * @return {?}
         */
        (r, i) => {
            return {
                id: this.primaryId(r),
                index: i,
                data: r
            };
        }));
        if (this._state.checkOnSelect) {
            this._state.checkedRows = [];
            this._state.checkedRows = allData.map((/**
             * @param {?} r
             * @param {?} i
             * @return {?}
             */
            (r, i) => {
                return {
                    id: this.primaryId(r),
                    index: i,
                    data: r
                };
            }));
        }
        this.selectAllSubject.next(this._state.selections);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    findRow(id) {
        if (this._state.data && this._state.data.length) {
            /** @type {?} */
            let index = -1;
            /** @type {?} */
            const data = this._state.data.find((/**
             * @param {?} n
             * @param {?} i
             * @return {?}
             */
            (n, i) => {
                /** @type {?} */
                const r = this.primaryId(n) == id;
                if (r) {
                    index = i;
                }
                return r;
            }));
            if (index === -1) {
                return null;
            }
            return { index, data };
        }
        return null;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    findRowIndex(id) {
        if (this._state.data && this._state.data.length) {
            return this._state.data.findIndex((/**
             * @param {?} n
             * @return {?}
             */
            n => this.primaryId(n) === id));
        }
        return -1;
    }
    /**
     * 设置选中行，不触发grid 选中事件，取消选中事件
     * @param {?} id
     * @param {?=} select
     * @param {?=} emit
     * @return {?}
     */
    setSelectRow(id, select = true, emit = true) {
        /** @type {?} */
        const row = this.findRow(id);
        const { index: rowIndex, data: rowData } = Object.assign({}, row);
        /** @type {?} */
        const srow = { id, data: rowData, index: rowIndex };
        if (this.isMultiSelect()) {
            if (select) {
                this.selectRowForMulti(srow, false, emit);
            }
            else {
                this.unSelectRowForMulti(srow, false, emit);
            }
        }
        /** @type {?} */
        const _sr = select ? srow : null;
        this.updateState({ currentRow: _sr }, false);
    }
    /**
     * @param {?} id
     * @param {?=} select
     * @return {?}
     */
    selectRecord(id, select = true) {
        if (id) {
            /** @type {?} */
            const row = this.findRow(id);
            if (row) {
                const { index: rowIndex, data: rowData } = Object.assign({}, row);
                if (select) {
                    this.selectRow(rowIndex, rowData);
                }
                else {
                    this.unSelectRow(rowIndex, rowData);
                }
            }
            else {
                this.errorSubject.next(`未找到ID为${id}的数据。`);
            }
        }
        else {
            this.errorSubject.next(`参数id 不能为空。`);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @param {?=} gridOpts
     * @return {?}
     */
    selectRow(rowIndex, rowData, gridOpts = null) {
        /** @type {?} */
        const isMultiSelect = this.isMultiSelect();
        /** @type {?} */
        const id = this.primaryId(rowData);
        /** @type {?} */
        const srow = { id, data: rowData, index: rowIndex };
        if (!this.isRowSelected(id) || !this._state.currentRow) {
            if (!isMultiSelect) {
                this.updateState({ currentRow: srow }, false);
                this.selectRowSubject.next(this._state.currentRow);
                if (this._state.showCheckbox && this._state.checkOnSelect) {
                    this._state.checkedRows = [srow];
                    if (gridOpts && gridOpts.instance && gridOpts.instance.beforeCheck) {
                        gridOpts.instance.beforeCheck({ rowIndex, rowData, gridInstance: gridOpts.instance }).subscribe((/**
                         * @return {?}
                         */
                        () => {
                            this.checkRowSubject.next(srow);
                        }));
                    }
                    else {
                        this.checkRowSubject.next(srow);
                    }
                }
            }
            else {
                this.selectRowForMulti(srow, true, gridOpts);
            }
        }
    }
    /**
     * @private
     * @param {?} srow
     * @param {?=} emit
     * @param {?=} gridOpts
     * @return {?}
     */
    selectRowForMulti(srow, emit = true, gridOpts = null) {
        if (this._state.onlySelectSelf) {
            this._clearSelections();
            this.updateState({ currentRow: srow, selections: [srow] }, false);
        }
        else {
            this._state.selections = this._state.selections || [];
            this._state.selections = this._state.selections.filter((/**
             * @param {?} sr
             * @return {?}
             */
            sr => sr.id !== srow.id));
            this._state.selections.push(srow);
        }
        if (emit) {
            this.selectRowSubject.next(srow);
        }
        if (this._state.checkOnSelect) {
            this.checkRow(srow.index, srow.data, gridOpts);
        }
    }
    /**
     * @private
     * @param {?} srow
     * @param {?=} emit
     * @param {?=} gridOpts
     * @return {?}
     */
    unSelectRowForMulti(srow, emit = true, gridOpts = null) {
        this._state.selections = this._state.selections.filter((/**
         * @param {?} sr
         * @return {?}
         */
        sr => sr.id !== srow.id));
        if (this._canCancelSelectWhenMulti() || (this._state.currentRow && this._state.currentRow.id === srow.id)) {
            this.updateState({ currentRow: null });
        }
        if (this._state.checkOnSelect) {
            this.unCheckRow(srow.index, srow.data, gridOpts);
        }
        if (emit) {
            this.unSelectRowSubject.next(srow);
        }
    }
    /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @param {?=} gridOpts
     * @return {?}
     */
    unSelectRow(rowIndex, rowData, gridOpts = null) {
        /** @type {?} */
        const id = this.primaryId(rowData);
        /** @type {?} */
        const isMultiSelect = this.isMultiSelect();
        /** @type {?} */
        const srow = { id, index: rowIndex, data: rowData };
        if (!isMultiSelect) {
            if (this._state.currentRow) {
                this.updateState({ currentRow: null });
                this.unSelectRowSubject.next(srow);
                if (this._state.showCheckbox) {
                    this.unCheckRow(srow.index, srow.data, gridOpts);
                }
            }
        }
        else {
            this.unSelectRowForMulti(srow, true, gridOpts);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _canCancelSelectWhenMulti() {
        return !this._state.keepSelect && this._state.onlySelectSelf;
    }
    /**
     * @private
     * @param {?=} excludeIds
     * @return {?}
     */
    _clearSelections(excludeIds) {
        this._state.currentRow = null;
        if (!excludeIds || !excludeIds.length) {
            this._state.selections = [];
        }
        else {
            this._state.selections = this._state.selections.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                return excludeIds.findIndex((/**
                 * @param {?} i
                 * @return {?}
                 */
                i => i == n.id)) > -1;
            }));
        }
    }
    /**
     * @private
     * @param {?=} rows
     * @return {?}
     */
    _clearCheckeds(rows = []) {
        if (!rows.length) {
            this._state.checkedRows = [];
        }
        else {
            this._state.checkedRows = this._state.checkedRows.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => rows.findIndex((/**
             * @param {?} r
             * @return {?}
             */
            r => this.primaryId(r) === n.id)) == -1));
        }
    }
    /**
     * @param {?=} excludeIds
     * @return {?}
     */
    clearSelections(excludeIds) {
        /** @type {?} */
        const rows = this._state.selections;
        excludeIds = excludeIds || [];
        this._clearSelections(excludeIds);
        /** @type {?} */
        const unCheckRows = rows.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => excludeIds.findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i == n.id)) == -1));
        if (this._state.checkOnSelect || (!this._state.multiSelect && this._state.showCheckbox)) {
            // this._state.checkedRows = [];
            // this.clearCheckedsSubject.next(rows);
            this._state.checkedRows = this._state.checkedRows.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                return !rows.find((/**
                 * @param {?} t1
                 * @return {?}
                 */
                t1 => t1.id == n.id && excludeIds.findIndex((/**
                 * @param {?} i
                 * @return {?}
                 */
                i => i == n.id)) == -1));
            }));
            this.clearCheckedsSubject.next(unCheckRows);
        }
        this.clearSelectionSubject.next(unCheckRows);
    }
    /**
     * @param {?=} clearAll
     * @return {?}
     */
    clearCheckeds(clearAll = true) {
        /** @type {?} */
        const rows = this.getAllRowsForLive();
        /** @type {?} */
        const _rows = clearAll ? [] : rows;
        this._clearCheckeds(_rows);
        if (this._state.selectOnCheck) {
            this._clearSelections();
        }
        this.clearCheckedsSubject.next(rows);
    }
    /**
     * @return {?}
     */
    clearAll() {
        this._clearCheckeds();
        this._clearSelections();
        this.clearAllSubject.next();
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    setMultiSelect(flag) {
        this._state.multiSelect = flag;
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    setCheckOnSelect(flag) {
        this._state.checkOnSelect = flag;
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    setSelectOnCheck(flag) {
        this._state.selectOnCheck = flag;
    }
    /**
     * @param {?} dr
     * @param {?} field
     * @param {?=} cellElement
     * @param {?=} cellRef
     * @return {?}
     */
    setCurrentCell(dr, field, cellElement, cellRef) {
        const { rowIndex, rowData } = Object.assign({}, dr);
        /** @type {?} */
        let currentCell = Object.assign({}, this._state.currentCell, { rowIndex, rowData, field, rowId: this.primaryId(rowData), cellElement });
        if (field !== this._state.ControlPanelFeild) {
            if (cellRef) {
                currentCell.cellRef = cellRef;
            }
            if (field) {
                currentCell.column = this.getColumn(field);
            }
            /** @type {?} */
            const isLastRow = rowIndex === this.getData().length - 1;
            currentCell['lastRow'] = isLastRow;
        }
        else {
            currentCell = null;
        }
        this._state.currentCell = null;
        this.updateState({ currentCell }, false);
        this.selectRow(rowIndex, rowData);
        if (this._state.currentRow) {
            this._state.currentRow.dr = dr;
        }
        this.selectCellSubject.next(currentCell);
    }
    /**
     * @return {?}
     */
    cancelSelectCell() {
        if (this._state.currentCell) {
            this._state.currentCell = null;
            this.updateState({ currentCell: null }, false);
            this.selectCellSubject.next(null);
        }
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    primaryId(rowData) {
        return rowData[this._state.idField];
    }
    /**
     * @return {?}
     */
    getCurrentCell() {
        return this._state.currentCell;
    }
    /**
     * @return {?}
     */
    editCell() {
        if (this._state.currentCell) {
            if (!this._state.currentCell.isEditing) {
                /** @type {?} */
                const cei = Object.assign({}, this._state.currentCell, { isEditing: true });
                this.updateState({ currentCell: cei }, false);
                this.selectCellSubject.next(cei);
                // this.editCell$.next(cei);
            }
        }
    }
    /**
     * @return {?}
     */
    endEditCell() {
        if (this._state.currentCell && this._state.currentCell.isEditing) {
            /** @type {?} */
            const cei = Object.assign({}, this._state.currentCell, { isEditing: false });
            this.updateState({ currentCell: cei }, false);
            this.selectCellSubject.next(cei);
            // this.editCell$.next(cei);
        }
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    appendRow(rowData) {
        if (rowData && this.primaryId(rowData)) {
            /** @type {?} */
            const pid = this.primaryId(rowData);
            if (this.findRowIndex(pid) === -1) {
                this._state.data.push(rowData);
                /** @type {?} */
                const newData = [...this._state.data];
                this.updateState({ data: newData }, false);
                this._state.originalData = cloneDeep(this._state.data);
                this.refresh();
                this.rowAppend$.emit(rowData);
            }
            else {
                throw new Error(`主键ID 已存在！ID: ${pid}`);
            }
        }
        else {
            throw new Error(`主键标识字段不能为空。`);
        }
    }
    /**
     * @param {?} rowid
     * @param {?} rowData
     * @return {?}
     */
    updateRow(rowid, rowData) {
        /** @type {?} */
        const row = this.findRow(rowid);
        if (row && row.data) {
            if (rowData) {
                /** @type {?} */
                const keys = Object.keys(rowData);
                keys.forEach((/**
                 * @param {?} field
                 * @return {?}
                 */
                field => {
                    Utils.setValue(field, rowData[field], row.data);
                }));
                // 更新已勾选的数据
                this.updateCheckedData(rowid, rowData);
                /** @type {?} */
                const rowUpdateParam = Object.assign({}, row, { keyID: rowid });
                this.rowUpdate$.emit(rowUpdateParam);
            }
        }
    }
    /**
     * @param {?} rowid
     * @return {?}
     */
    deleteRow(rowid) {
        /** @type {?} */
        const row = this.findRow(rowid);
        if (row) {
            /** @type {?} */
            const newData = this.removeRow(this._state.data, rowid);
            this.updateState({ data: newData }, false);
            this._state.originalData = cloneDeep(this._state.data);
            this.refresh();
            this.rowDelete$.emit(rowid);
            return row;
        }
    }
    /**
     * 从数组中删除指定的ID
     * @param {?} data 数组
     * @param {?} rowId 要删除的ID
     * @return {?}
     */
    removeRow(data, rowId) {
        /** @type {?} */
        const newData = data.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            /** @type {?} */
            const id = this.primaryId(n);
            return rowId !== id;
        }));
        return newData;
    }
    /**
     * @param {?} cellInfo
     * @return {?}
     */
    isCellSelected(cellInfo) {
        /** @type {?} */
        const cc = this.getCurrentCell();
        if (!cc) {
            return false;
        }
        else {
            if (this._state.currentRow.index === cc.rowIndex) {
                return cc.field === cellInfo.field;
            }
            return false;
        }
    }
    /**
     * @protected
     * @param {?} state
     * @param {?=} emit
     * @return {?}
     */
    updateState(state, emit = true) {
        /** @type {?} */
        const newState = Object.assign({}, this._state, state);
        this._state = newState;
        if (emit) {
            this.store.next(this._state);
        }
    }
    /**
     * @param {?=} newSize
     * @return {?}
     */
    resize(newSize) {
        if (newSize) {
            this.updateState(newSize, false);
        }
        this.resetColumnsSize();
        if (!this._state.groupRows) {
            this.updateVirthualRows(this._state.virtual.scrollTop);
        }
    }
    /**
     * @param {?} fit
     * @return {?}
     */
    fitColumns(fit) {
        this.updateState({ fitColumns: fit }, false);
        // const r = this.useUserSetColumnSize();
        // this.setFitColumnsWidth(this._state.columnsGroup, true, r);
        // this.gridSizeSubject.next(this._state);
        this.resetColumnsSize();
    }
    /**
     * @private
     * @return {?}
     */
    useUserSetColumnSize() {
        if (this._state.autoFitColumns) {
            /** @type {?} */
            const gridWidth = this._state.width;
            const { leftFixedWidth, rightFixedWidth, originalTotalWidth } = this._state.columnsGroup;
            return originalTotalWidth > gridWidth - leftFixedWidth - rightFixedWidth;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    resetColumnsSize() {
        if (this._state.fitColumns) {
            // 20200421
            /** @type {?} */
            const r = this.useUserSetColumnSize();
            this.setFitColumnsWidth(this._state.columnsGroup, r, r);
        }
        this.gridSizeSubject.next(this._state);
    }
    /**
     * 更新列设置
     * @param {?} columns 新的列集合
     * @param {?=} restitute 是否还原初始宽度 默认为 false
     * @param {?=} emit
     * @return {?}
     */
    updateColumns(columns, restitute = false, emit = false) {
        this._state.columns = columns;
        this.initColumns(emit, restitute);
        this.resizeColumns(restitute);
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    getGroupColumns(columns) {
        /** @type {?} */
        let arr = [];
        /** @type {?} */
        const allCols = this.getAllFlatColumns();
        columns.forEach((/**
         * @param {?} c
         * @return {?}
         */
        c => {
            if (!c.colspan || c.colspan == 1) {
                if (!arr.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.field === c.field))) {
                    arr.push(c);
                }
            }
            else {
                arr = arr.concat(this.getGroupColumns(allCols.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.parentId == c.id))));
            }
        }));
        return arr;
    }
    /**
     * @param {?=} emit
     * @param {?=} restColumnWidth
     * @return {?}
     */
    initColumns(emit = false, restColumnWidth = false) {
        /** @type {?} */
        const columns = this._state.flatColumns;
        /** @type {?} */
        let colgroup = {
            leftFixed: [],
            rightFixed: [],
            normalColumns: [],
            columns: []
        };
        if (columns && columns.length) {
            /** @type {?} */
            const leftFixedCols = this.getFixedCols('left');
            /** @type {?} */
            const rightFixedCols = this.getFixedCols('right');
            /** @type {?} */
            const normalCols = this.getFixedCols();
            columns.forEach((/**
             * @param {?} c
             * @return {?}
             */
            c => {
                if (!c.originalWidth) {
                    c.originalWidth = c.width;
                }
                else {
                    if (restColumnWidth) {
                        c.width = c.originalWidth;
                    }
                }
            }));
            colgroup = {
                leftFixed: leftFixedCols,
                rightFixed: rightFixedCols,
                normalColumns: normalCols,
                columns: leftFixedCols.concat(normalCols).concat(rightFixedCols)
            };
            this.initColumnsWidth(colgroup, restColumnWidth);
            if (this._state.fitColumns) {
                this.setFitColumnsWidth(colgroup, true);
            }
            this.updateState({ columnsGroup: colgroup }, emit);
        }
        else {
            colgroup.leftFixedWidth = 0;
            colgroup.rightFixedWidth = 0;
            colgroup.normalWidth = 0;
            colgroup.totalWidth = 0;
            this.updateState({ columnsGroup: colgroup }, emit);
        }
    }
    /**
     * @param {?} field
     * @param {?=} fixed
     * @return {?}
     */
    getColumnIndex(field, fixed = '') {
        /** @type {?} */
        const colgroup = this._state.columnsGroup;
        if (!fixed || this._state.fast) {
            return colgroup.normalColumns.findIndex((/**
             * @param {?} n
             * @return {?}
             */
            n => n.field === field));
        }
        else {
            if (fixed === 'left') {
                return colgroup.leftFixed.findIndex((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.field === field));
            }
            else if (fixed === 'right') {
                return colgroup.rightFixed.findIndex((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.field === field));
            }
        }
    }
    /**
     * @return {?}
     */
    columnResizeEnd() {
        // const colgroup = this._state.columnsGroup;
        // this.initColumnsWidth(colgroup, false);
        // this.updateState({ columnsGroup:  {...colgroup} }, false);
        // this.gridSizeSubject.next(this._state);
        this.resizeColumns();
    }
    /**
     * @param {?=} restitute
     * @return {?}
     */
    resizeColumns(restitute = false) {
        /** @type {?} */
        const colgroup = this._state.columnsGroup;
        this.initColumnsWidth(colgroup, restitute);
        if (this._state.fitColumns) {
            /** @type {?} */
            const r = this.useUserSetColumnSize();
            if (r) {
                this.setFitColumnsWidth(colgroup, restitute, r);
            }
            else {
                this.setFitColumnsWidth(colgroup, restitute);
            }
        }
        this.updateState({ columnsGroup: Object.assign({}, colgroup) }, false);
        this.gridSizeSubject.next(this._state);
    }
    /**
     * @return {?}
     */
    getAllFlatColumns() {
        return flatten(this._state.columns);
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    getColumn(fieldName) {
        return this.getAllFlatColumns().find((/**
         * @param {?} n
         * @return {?}
         */
        n => n.field === fieldName));
    }
    /**
     * @param {?} colgroup
     * @param {?=} restitute
     * @param {?=} useUserSetColumnSize
     * @return {?}
     */
    setFitColumnsWidth(colgroup, restitute = false, useUserSetColumnSize = false) {
        if (!colgroup) {
            return;
        }
        colgroup.normalWidth = this._state.width - colgroup.leftFixedWidth - colgroup.rightFixedWidth;
        if (this._state['scrollbarY']) {
            colgroup.normalWidth -= this._state['scrollbarY'];
        }
        // tfs 613060
        if (this._state.showBorder) {
            colgroup.normalWidth -= 2;
        }
        if (useUserSetColumnSize) {
            colgroup.totalWidth = colgroup.originalTotalWidth;
            if (restitute) {
                colgroup.normalColumns.forEach((/**
                 * @param {?} col
                 * @return {?}
                 */
                col => {
                    col.width = col.originalWidth;
                }));
            }
            // 更新 normalColumns width
            colgroup.normalWidth = colgroup.normalColumns.reduce((/**
             * @param {?} totalWidth
             * @param {?} col
             * @return {?}
             */
            (totalWidth, col) => {
                if (!restitute && col.width) {
                    return totalWidth += col.width;
                }
                else {
                    return totalWidth += col.originalWidth;
                }
            }), 0);
            colgroup.totalWidth = colgroup.leftFixedWidth + colgroup.rightFixedWidth + colgroup.normalWidth;
        }
        else {
            /** @type {?} */
            const minWidth = colgroup.normalColumns.reduce((/**
             * @param {?} totalWidth
             * @param {?} col
             * @return {?}
             */
            (totalWidth, col) => {
                if (!restitute) {
                    return totalWidth += col.width;
                }
                else {
                    return totalWidth += col.originalWidth;
                }
            }), 0);
            // colgroup.normalWidth = colgroup.normalWidth - 2;
            colgroup.normalColumns.forEach((/**
             * @param {?} col
             * @return {?}
             */
            col => {
                if (!restitute) {
                    // col.width = Math.floor( col.width / minWidth * colgroup.normalWidth );
                    col.width = Number((col.width / minWidth * colgroup.normalWidth).toFixed(2));
                }
                else {
                    // col.width = Math.floor( col.originalWidth / minWidth * colgroup.normalWidth );
                    col.width = Number((col.originalWidth / minWidth * colgroup.normalWidth).toFixed(2));
                }
            }));
            colgroup.totalWidth = colgroup.leftFixedWidth + colgroup.rightFixedWidth + colgroup.normalWidth;
        }
    }
    /**
     * @private
     * @param {?=} direction
     * @return {?}
     */
    getFixedCols(direction = '') {
        /** @type {?} */
        let cols = [];
        if (!direction) {
            cols = this._state.flatColumns.filter((/**
             * @param {?} col
             * @return {?}
             */
            col => col.fixed !== 'left' && col.fixed !== 'right'));
        }
        else {
            cols = this._state.flatColumns.filter((/**
             * @param {?} col
             * @return {?}
             */
            col => col.fixed === direction));
        }
        // 多表头，重新计算列的顺序
        if (this._state.columns.length > 1 && cols.length) {
            /** @type {?} */
            const fields = DatagridColumnsHelper.getFields(this._state.columns);
            /** @type {?} */
            const newcols = [];
            fields.forEach((/**
             * @param {?} f
             * @return {?}
             */
            f => {
                /** @type {?} */
                const c = cols.find((/**
                 * @param {?} col
                 * @return {?}
                 */
                col => (col.field || '') === f));
                if (c) {
                    newcols.push(c);
                }
            }));
            return newcols;
        }
        return cols;
    }
    // restitute: 还原初始宽度，默认 false
    /**
     * @private
     * @param {?} colgroup
     * @param {?=} restitute
     * @return {?}
     */
    initColumnsWidth(colgroup, restitute = false) {
        /** @type {?} */
        let offset = 0;
        offset = this._state.showLineNumber ? offset + this._state.lineNumberWidth : offset;
        offset = this._state.showCheckbox ? offset + this._state.checkboxColumnWidth : offset;
        /** @type {?} */
        const getColsWidth = (/**
         * @param {?} cols
         * @param {?} val
         * @param {?} reset
         * @return {?}
         */
        (cols, val, reset) => {
            return cols.reduce((/**
             * @param {?} r
             * @param {?} c
             * @return {?}
             */
            (r, c) => {
                c.left = r;
                if (!reset) {
                    return r + c.width;
                }
                else {
                    return r + c.originalWidth;
                }
            }), val);
        });
        colgroup.leftFixedWidth = offset;
        if (colgroup.leftFixed && colgroup.leftFixed.length) {
            colgroup.leftFixedWidth = getColsWidth(colgroup.leftFixed, offset, restitute);
        }
        colgroup.rightFixedWidth = 0;
        if (colgroup.rightFixed && colgroup.rightFixed.length) {
            colgroup.rightFixedWidth = getColsWidth(colgroup.rightFixed, 0, restitute);
        }
        colgroup.normalWidth = 0;
        if (this._state.columns && this._state.columns.length) {
            colgroup.normalWidth = getColsWidth(colgroup.normalColumns, 0, restitute);
            colgroup.originalTotalWidth = getColsWidth(colgroup.normalColumns, 0, true);
        }
        colgroup.totalWidth = colgroup.leftFixedWidth + colgroup.rightFixedWidth + colgroup.normalWidth;
    }
    /**
     * @param {?=} isShow
     * @return {?}
     */
    showCheckbox(isShow = true) {
        /** @type {?} */
        const colgroup = this._state.columnsGroup;
        this.updateState({ showCheckbox: isShow }, false);
        if (isShow) {
            colgroup.leftFixedWidth = colgroup.leftFixedWidth + this._state.checkboxColumnWidth;
        }
        else {
            colgroup.leftFixedWidth = colgroup.leftFixedWidth - this._state.checkboxColumnWidth;
        }
        this.columnResizeSubject.next(colgroup);
    }
    /**
     * @return {?}
     */
    hideCheckbox() {
        this.showCheckbox(false);
    }
    /**
     * @param {?=} isShow
     * @return {?}
     */
    showLineNumber(isShow = true) {
        /** @type {?} */
        const colgroup = this._state.columnsGroup;
        this.updateState({ showLineNumber: isShow }, false);
        if (isShow) {
            colgroup.leftFixedWidth = colgroup.leftFixedWidth + this._state.lineNumberWidth;
        }
        else {
            colgroup.leftFixedWidth = colgroup.leftFixedWidth - this._state.lineNumberWidth;
        }
        this.columnResizeSubject.next(colgroup);
    }
    /**
     * @return {?}
     */
    hideLineNumber() {
        this.showLineNumber(false);
    }
    /**
     * @param {?} sortName
     * @param {?} sortOrder
     * @return {?}
     */
    setSortInfo(sortName, sortOrder) {
        sortName = sortName || '';
        sortOrder = sortOrder || '';
        /** @type {?} */
        const fields = sortName.split(',');
        /** @type {?} */
        const orders = sortOrder.split(',');
        // if (!this._state.multiSort) {
        /** @type {?} */
        const colgroup = this._state.columnsGroup;
        /** @type {?} */
        const updateFieldOrder = (/**
         * @param {?} cols
         * @return {?}
         */
        (cols) => {
            if (!cols || !cols.length) {
                return;
            }
            cols.forEach((/**
             * @param {?} col
             * @return {?}
             */
            col => {
                col.order = undefined;
                /** @type {?} */
                const i = fields.findIndex((/**
                 * @param {?} f
                 * @return {?}
                 */
                f => f === col.field));
                if (i > -1) {
                    col.order = orders[i];
                }
            }));
        });
        updateFieldOrder(colgroup.normalColumns);
        updateFieldOrder(colgroup.leftFixed);
        updateFieldOrder(colgroup.rightFixed);
        // }
        this.updateState({ sortName, sortOrder }, false);
    }
    /**
     * @param {?} arr
     * @param {?} props
     * @param {?} orders
     * @return {?}
     */
    orderBy(arr, props, orders) {
        /** @type {?} */
        const colObj = props.reduce((/**
         * @param {?} c
         * @param {?} n
         * @return {?}
         */
        (c, n) => {
            c[n] = this.getColumn(n);
            return c;
        }), {});
        return [...arr].sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => props.reduce((/**
         * @param {?} acc
         * @param {?} prop
         * @param {?} i
         * @return {?}
         */
        (acc, prop, i) => {
            if (acc === 0) {
                /** @type {?} */
                let valA = Utils.getValue(prop, a);
                /** @type {?} */
                let valB = Utils.getValue(prop, b);
                if (colObj[prop] && colObj[prop]['isMultilingualField']) {
                    valA = Utils.getMultilingualValue(valA, this.localId);
                    valB = Utils.getMultilingualValue(valB, this.localId);
                }
                if (valA === undefined || valA === null) {
                    valA = '';
                }
                if (valB === undefined || valB === null) {
                    valB = '';
                }
                const [p1, p2] = orders && orders[i] === 'desc' ? [valB, valA] : [valA, valB];
                if (typeof p1 === 'string') {
                    acc = p1.localeCompare(p2);
                }
                else {
                    acc = p1 > p2 ? 1 : p1 < p2 ? -1 : 0;
                }
            }
            return acc;
        }), 0)));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    sort(data) {
        /** @type {?} */
        const orders = this._state.sortOrder.split(',');
        /** @type {?} */
        const fields = this._state.sortName.split(',');
        if (this._state.mergeCell && this._state.mergeFields && this._state.mergeFields.length) {
            /** @type {?} */
            const newOrders = [];
            /** @type {?} */
            const newFields = [...this._state.mergeFields];
            fields.forEach((/**
             * @param {?} f
             * @param {?} i
             * @return {?}
             */
            (f, i) => {
                /** @type {?} */
                let k = newFields.indexOf(f);
                if (k == -1) {
                    newFields.push(f);
                    k = newFields.length - 1;
                }
                newOrders[k] = orders[i];
            }));
            return this.orderBy(data, newFields, newOrders);
        }
        return this.orderBy(data, fields, orders);
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    clientSort(data) {
        if (this._state.sortName) {
            if (data) {
                this.updateState({ data }, false);
            }
            /** @type {?} */
            const sortedData = this.sort(this._state.data);
            this.loadData(sortedData, false);
        }
        else {
            this.clearSort();
        }
        this.clientSort$.emit({ sortName: this._state.sortName, sortOrder: this._state.sortOrder });
    }
    /**
     * @return {?}
     */
    clearSort() {
        this.loadData(this._state.originalData, false);
    }
    /**
     * @param {?} filterData
     * @return {?}
     */
    loadFilterData(filterData) {
        this.loadData(filterData, false);
    }
    //#region 变更集
    /**
     * @private
     * @param {?} rowid
     * @return {?}
     */
    hasRowChanges(rowid) {
        /** @type {?} */
        const _changes = this._state.changes;
        if (!_changes) {
            return false;
        }
        return _changes[rowid];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    appendChanges(changes) {
        if (!changes) {
            return;
        }
        /** @type {?} */
        const id = changes[this._state.idField];
        if (!id) {
            return;
        }
        /** @type {?} */
        const _id = '' + id;
        if (!this.hasRowChanges(_id)) {
            this._state.changes = this._state.changes || {};
            this._state.changes[_id] = changes;
        }
        else {
            this._state.changes[_id] = Object.assign(this._state.changes[_id], changes);
        }
    }
    /**
     * @return {?}
     */
    acceptChanges() {
        /** @type {?} */
        const changes = this._state.changes;
        if (changes) {
            /** @type {?} */
            const keys = Object.keys(changes);
            keys.forEach((/**
             * @param {?} id
             * @return {?}
             */
            id => {
                this.updateRow(id, changes[id]);
            }));
            this._state.originalData = cloneDeep(this._state.data);
        }
    }
    /**
     * @param {?=} rowid
     * @return {?}
     */
    rejectChanges(rowid = null) {
        /** @type {?} */
        const changes = this._state.changes;
        if (changes) {
            if (!rowid) {
                this._state.data = cloneDeep(this._state.originalData);
                this._state.changes = null;
            }
            else {
                /** @type {?} */
                const rowChanges = this._state.changes['' + rowid];
                if (rowChanges) {
                    /** @type {?} */
                    const orgiRow = this._state.originalData.find((/**
                     * @param {?} r
                     * @return {?}
                     */
                    r => this.primaryId(r) === rowid));
                    this._state.data.forEach((/**
                     * @param {?} r
                     * @return {?}
                     */
                    r => {
                        if (this.primaryId(r) === rowid) {
                            r = cloneDeep(orgiRow);
                        }
                    }));
                }
            }
            this.refresh();
        }
    }
    /**
     * @return {?}
     */
    getChanges() {
        return this._state.changes;
    }
    /**
     * @return {?}
     */
    refresh() {
        /** @type {?} */
        const data = cloneDeep(this._state.data);
        this.loadData(data);
    }
    //#endregion
    /**
     * 构造合计行
     * @param {?} data 数据集合
     * @return {?}
     */
    getFooterData(data) {
        if (!data || !data.length) {
            return [];
        }
        // const columns = this._state.flatColumns;
        /** @type {?} */
        const columns = flatten(this._state.columns).filter((/**
         * @param {?} col
         * @return {?}
         */
        (col) => !col.colspan || col.colspan == 1));
        /** @type {?} */
        const footerRow = {};
        columns.forEach((/**
         * @param {?} col
         * @return {?}
         */
        col => {
            if (col.footer && col.footer.options) {
                /** @type {?} */
                const options = col.footer.options;
                /** @type {?} */
                const text = options.text;
                /** @type {?} */
                const typ = (/** @type {?} */ (options.calculationType));
                if (typ !== undefined && typ != -1) {
                    /** @type {?} */
                    const val = this.calculation(data, typ, col);
                    footerRow[col.field] = val;
                }
                else {
                    footerRow[col.field] = text || '';
                }
            }
            else {
                footerRow[col.field] = '';
            }
        }));
        return [footerRow];
    }
    /**
     * @private
     * @param {?} items
     * @param {?} fields
     * @return {?}
     */
    arrToGroup(items, fields) {
        if (fields.length) {
            /** @type {?} */
            const first = fields.shift();
            /** @type {?} */
            const g1 = groupBy(items, (/**
             * @param {?} n
             * @return {?}
             */
            (n) => Utils.getValue(first, n)));
            this.toGroup(g1, fields);
            return g1;
        }
    }
    /**
     * @private
     * @param {?} g1
     * @param {?} fieldArr
     * @return {?}
     */
    toGroup(g1, fieldArr) {
        if (fieldArr.length) {
            Object.keys(g1).forEach((/**
             * @param {?} k
             * @return {?}
             */
            (k) => {
                /** @type {?} */
                const items = g1[k];
                /** @type {?} */
                const _nextFields = fieldArr.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                (n) => n));
                /** @type {?} */
                const _f = _nextFields.shift();
                g1[k] = groupBy(items, (/**
                 * @param {?} n
                 * @return {?}
                 */
                (n) => Utils.getValue(_f, n)));
                if (_nextFields.length) {
                    this.toGroup(g1[k], _nextFields);
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} groupRows
     * @param {?} initLevel
     * @param {?} parent
     * @return {?}
     */
    groupRows2Flat(groupRows, initLevel, parent) {
        /** @type {?} */
        let results = [];
        if (initLevel === undefined) {
            initLevel = 0;
        }
        /** @type {?} */
        const idfield = this._state.idField;
        /** @type {?} */
        const columns = this._state.flatColumns;
        /** @type {?} */
        const data = this._state.data;
        /** @type {?} */
        const groupFieldArr = this._state.groupField.split(',');
        /** @type {?} */
        const pid = parent ? parent[idfield] : null;
        /** @type {?} */
        const colspan = this._state.columnsGroup.normalColumns.length;
        /** @type {?} */
        const expandGroupRows = this._state.expandGroupRows;
        Object.keys(groupRows).forEach((/**
         * @param {?} k
         * @param {?} m
         * @return {?}
         */
        (k, m) => {
            /** @type {?} */
            const groupItem = { [idfield]: Utils.uuid(),
                [IS_GROUP_ROW_FIELD]: true, [GROUP_LEVEL_FIELD]: initLevel, data: {}, value: k,
                [GROUP_VISIBLE_FIELD]: true, expanded: expandGroupRows, field: groupFieldArr[initLevel],
                colspan, total: 0, rows: [], [GROUP_ROW_FIELD]: pid };
            // TFS: 356955
            if (parent) {
                groupItem.rows = parent.rows.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => !n[IS_GROUP_ROW_FIELD] &&
                    !n[IS_GROUP_FOOTER_ROW_FIELD] && Utils.getValue(groupFieldArr[initLevel], n) === k));
                groupItem[GROUP_VISIBLE_FIELD] = expandGroupRows;
            }
            else {
                groupItem.rows = data.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => '' + Utils.getValue(groupFieldArr[initLevel], n) === k));
            }
            if (parent) {
                parent.rows.push(groupItem);
            }
            groupItem.total = groupItem.rows.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => !n[IS_GROUP_ROW_FIELD] && !n[IS_GROUP_FOOTER_ROW_FIELD])).length;
            results.push(groupItem);
            /** @type {?} */
            let items = groupRows[k];
            if (isPlainObject(items)) {
                /** @type {?} */
                const level = initLevel + 1;
                results = results.concat(this.groupRows2Flat(items, level, groupItem));
            }
            else {
                groupItem.total = items.length;
                items = items.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    n[GROUP_ROW_FIELD] = groupItem[idfield];
                    n[GROUP_VISIBLE_FIELD] = expandGroupRows;
                    n[GROUP_LEVEL_FIELD] = groupItem[GROUP_LEVEL_FIELD] + 1;
                    return n;
                }));
                groupItem.rows = items;
                results = results.concat(items);
            }
            if (this._state.groupFooter) {
                /** @type {?} */
                const footerItem = {
                    [IS_GROUP_FOOTER_ROW_FIELD]: true,
                    [GROUP_ROW_FIELD]: groupItem[idfield],
                    [GROUP_VISIBLE_FIELD]: expandGroupRows,
                    [GROUP_LEVEL_FIELD]: initLevel,
                    data: {}
                };
                groupItem.rows.push(footerItem);
                results.push(footerItem);
            }
        }));
        return results;
    }
    /**
     * 更新分组合计行数据
     * @private
     * @param {?} groupFooterRow
     * @param {?} columns
     * @param {?} groupRows
     * @return {?}
     */
    updateGroupFooterData(groupFooterRow, columns, groupRows) {
        columns.forEach((/**
         * @param {?} col
         * @return {?}
         */
        col => {
            if (col.groupFooter && col.groupFooter.options) {
                /** @type {?} */
                const options = col.groupFooter.options;
                /** @type {?} */
                const text = options.text;
                /** @type {?} */
                const typ = (/** @type {?} */ (options.calculationType));
                if (typ !== undefined && typ != -1) {
                    /** @type {?} */
                    const val = this.calculation(groupRows, typ, col);
                    groupFooterRow.data[col.field] = val;
                }
                else {
                    groupFooterRow.data[col.field] = text || '';
                }
            }
            else {
                groupFooterRow.data[col.field] = '';
            }
        }));
    }
    /**
     * 多字段分组
     * groupField 以逗号分隔，从左到右依次进行分组
     * @private
     * @param {?} data
     * @return {?}
     */
    groupRows2(data) {
        if (data && data.length) {
            /** @type {?} */
            const columns = this._state.flatColumns;
            /** @type {?} */
            const groupField = this._state.groupField || '';
            if (!groupField) {
                return data;
            }
            /** @type {?} */
            const groupData = this.arrToGroup(data, groupField.split(','));
            /** @type {?} */
            const result = this.groupRows2Flat(groupData, 0, null);
            /** @type {?} */
            let k = 0;
            /** @type {?} */
            const prow = (/**
             * @param {?} pid
             * @return {?}
             */
            (pid) => result.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n[this._state.idField] === pid)));
            result.map((/**
             * @param {?} n
             * @param {?} i
             * @return {?}
             */
            (n, i) => {
                if (!n[IS_GROUP_ROW_FIELD] && !n[IS_GROUP_FOOTER_ROW_FIELD]) {
                    n[ROW_INDEX_FIELD] = k;
                    k++;
                }
                // 更新合计行数据
                if (n[IS_GROUP_FOOTER_ROW_FIELD]) {
                    /** @type {?} */
                    const rows = prow(n[GROUP_ROW_FIELD]).rows.filter((/**
                     * @param {?} r
                     * @return {?}
                     */
                    (r) => !r[IS_GROUP_ROW_FIELD] && !r[IS_GROUP_FOOTER_ROW_FIELD]));
                    this.updateGroupFooterData(n, columns, rows);
                }
                return n;
            }));
            return result;
        }
        return [];
    }
    /**
     * @param {?} groupFooter
     * @return {?}
     */
    showGroupFooter(groupFooter) {
        this.updateState({ groupFooter }, false);
        this.updateVirthualRows(0);
    }
    /**
     * @param {?} groupRowId
     * @return {?}
     */
    updateGroupFooter(groupRowId) {
        /** @type {?} */
        const groupRow = this._state.virtual.virtualRows.find((/**
         * @param {?} n
         * @return {?}
         */
        (n) => {
            return n['id'] === groupRowId;
        }));
        // tfs 574567
        if (groupRow && groupRow.rows) {
            /** @type {?} */
            const groupRows = groupRow.rows;
            /** @type {?} */
            const groupFooterRows = groupRows.filter((/**
             * @param {?} n
             * @return {?}
             */
            (n) => n['__group_footer__']));
            /** @type {?} */
            const columns = this._state.flatColumns;
            /** @type {?} */
            const rows = groupRows.filter((/**
             * @param {?} n
             * @return {?}
             */
            (n) => !n['__group_footer__']));
            groupFooterRows.forEach((/**
             * @param {?} n
             * @return {?}
             */
            (n) => {
                this.updateGroupFooterData(n, columns, rows);
            }));
            if (groupRow['__group_parent_id__']) {
                this.updateGroupFooter(groupRow['__group_parent_id__']);
            }
        }
    }
    /**
     * @private
     * @param {?} data
     * @param {?} typ
     * @param {?} col
     * @return {?}
     */
    calculation(data, typ, col) {
        /** @type {?} */
        let val = '';
        // TFS: 357000
        // http://10.24.1.11:8080/tfs/GSP/GSPCloud/web/_queries?id=357000&triage=true&fullScreen=false&_a=edit
        if (!data || !data.length) {
            return '';
        }
        /** @type {?} */
        const field = col.field;
        /** @type {?} */
        const arr = data.map((/**
         * @param {?} o
         * @return {?}
         */
        (o) => Utils.getValue(field, o) || 0));
        switch (typ) {
            case CalculationType.sum:
                // val = sumBy(data, (o) => Utils.getValue(field, o));
                val = BigNumber.sum.apply(null, arr).toFixed();
                break;
            case CalculationType.max:
                // const maxObj = maxBy(data, (o) => Utils.getValue(field, o));
                // val = Utils.getValue(field, maxObj);
                val = BigNumber.max.apply(null, arr).toFixed();
                break;
            case CalculationType.min:
                // const minObj = minBy(data, (o) => Utils.getValue(field, o));
                // val = Utils.getValue(field, minObj);
                val = BigNumber.min.apply(null, arr).toFixed();
                break;
            case CalculationType.average:
                // val = meanBy(data, (o) => Utils.getValue(field, o));
                val = BigNumber.sum.apply(null, arr).div(arr.length).toFixed();
                break;
            case CalculationType.count:
                val = data.length;
                break;
        }
        return val;
    }
    /**
     * @param {?} row
     * @param {?} open
     * @param {?=} emit
     * @return {?}
     */
    setGroupRowsVisible(row, open, emit = true) {
        if (row.rows) {
            // if (!this._state.virtualized) {
            /** @type {?} */
            const groupRows = row.rows.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n[IS_GROUP_ROW_FIELD]));
            /** @type {?} */
            const footerRows = row.rows.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n[IS_GROUP_FOOTER_ROW_FIELD]));
            if (footerRows && footerRows.length) {
                footerRows.forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    n[GROUP_VISIBLE_FIELD] = open && row.expanded;
                }));
            }
            groupRows.forEach((/**
             * @param {?} t
             * @return {?}
             */
            t => {
                t[GROUP_VISIBLE_FIELD] = open && row.expanded && row[GROUP_VISIBLE_FIELD];
                this.setGroupRowsVisible(t, open, false);
            }));
            if (!groupRows.length) {
                row.rows.forEach((/**
                 * @param {?} t
                 * @return {?}
                 */
                t => {
                    t[GROUP_VISIBLE_FIELD] = open && row.expanded && row[GROUP_VISIBLE_FIELD];
                }));
            }
            // }
            // 触发行展开或折叠事件
            if (emit) {
                if (open) {
                    this.expandGroupRow.emit({ data: row });
                }
                else {
                    this.collapseGroupRow.emit({ data: row });
                }
            }
        }
    }
    //#region 组件初始属性
    /**
     * @param {?} opts
     * @return {?}
     */
    setinitialOptions(opts) {
        this._state.initialOptions = {};
        // 分组
        this._state.initialOptions['groupField'] = opts.groupField;
        this._state.initialOptions['expandGroupRows'] = opts.expandGroupRows;
        // 排序
        this._state.initialOptions['sort'] = {
            sortName: opts.sortName,
            sortOrder: opts.sortOrder
        };
        /** @type {?} */
        const fieldInfo = (/**
         * @param {?} n
         * @return {?}
         */
        (n) => {
            if (n.field === "_datagrid-setting-control_") {
                return null;
            }
            return {
                field: n.field,
                title: n.title,
                colspan: n.colspan,
                rowspan: n.rowspan,
                fixed: n.fixed,
                width: n.width || 100,
                sortable: n.sortable,
                order: n.order,
                halign: n.halign,
                align: n.align,
                visible: n.visible,
                allowGrouping: n.allowGrouping,
                groupFooter: cloneDeep(n.groupFooter || {}),
                footer: cloneDeep(n.footer || {}),
                dataType: n.dataType || 'string'
            };
        })
        // 列显示隐藏、对齐方式
        ;
        // 列显示隐藏、对齐方式
        if (opts.columns) {
            if (opts.columns.length === 1) {
                this._state.initialOptions['columnFields'] = ((/** @type {?} */ (opts.columns[0]))).map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    return fieldInfo(n);
                })).filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n));
            }
            else {
                this._state.initialOptions['groupHeaderFields'] = opts.columns.map((/**
                 * @param {?} cols
                 * @return {?}
                 */
                cols => {
                    return cols.map((/**
                     * @param {?} n
                     * @return {?}
                     */
                    (n) => {
                        return fieldInfo(n);
                    })).filter((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n));
                }));
            }
            this._state.initialOptions['designerColumns'] = [...opts.columns.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    return [...n];
                }))];
        }
    }
}
DatagridFacadeService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DatagridFacadeService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridService {
    constructor() {
        this.scorllSubject = new Subject();
        this.scrollX = new BehaviorSubject(0);
        this.rowHoverSubject = new Subject();
        this.rowSelectSubject = new Subject();
        this.dataSourceChangedSubject = new Subject();
        /**
         * 编辑单元格
         */
        this.editCellSubject = new Subject();
        /**
         * 选中单元格
         */
        this.selectCellSubject = new Subject();
        /**
         * 结束单元编辑
         */
        this.endCellEdit = new Subject();
        this.changeCheckedRows = new Subject();
        /**
         * 结束行编辑
         */
        // private endRowEdit = new BehaviorSubject(true);
        this.scorll$ = this.scorllSubject.asObservable();
        this.scrollX$ = this.scorll$.pipe(filter((/**
         * @param {?} p
         * @return {?}
         */
        (p) => p.type === 'psScrollX')), map((/**
         * @param {?} t
         * @return {?}
         */
        t => t.x)), debounceTime(50));
        this.scrollY$ = this.scorll$.pipe(filter((/**
         * @param {?} p
         * @return {?}
         */
        (p) => p.type === 'psScrollY')), map((/**
         * @param {?} t
         * @return {?}
         */
        t => t.x)), debounceTime(50));
        this.rowHover$ = this.rowHoverSubject.asObservable();
        this.rowClick$ = this.rowSelectSubject.asObservable();
        this.onDataSourceChange = this.dataSourceChangedSubject.asObservable();
        this.cellEdit$ = this.editCellSubject.asObservable();
        this.endCellEdit$ = this.endCellEdit.asObservable();
        this.checkedRowsTotalChanged$ = this.changeCheckedRows.asObservable();
        this.updateEmptyStyle$ = new EventEmitter();
        this.showGridHeader = new EventEmitter();
        // 取消全选
        this.uncheckAll = new EventEmitter();
        // 全部选中
        this.checkAll = new EventEmitter();
        this.columnResized = new EventEmitter();
        this.rowHeightChanged = new EventEmitter();
        this.loadVirtualData = new EventEmitter();
        /**
         * 显示固定列隐影
         */
        this.showFixedShadow = new EventEmitter();
        // public endRowEdit$ = this.endRowEdit.asObservable();
        this.setSelecedRow = new EventEmitter();
        this.setCheckedRows = new EventEmitter();
        this.scrollToCurrentRow = new EventEmitter();
        this.columnsChanged = new EventEmitter();
        this.cellContentWrapChanged = new EventEmitter();
        this.onFilterChanged = new EventEmitter();
        this.clearFilter = new EventEmitter();
        this.filterTextChange = new EventEmitter();
        this.toggleFilterRow = new EventEmitter();
        this.closeFilterPanel = new EventEmitter();
        this.refreshFooterData = new EventEmitter();
        this.disableHeader = new EventEmitter();
        /**
         * 更新全选复选框状态
         */
        this.changeCheckAllStatus = new EventEmitter();
        this.setScrollbarPosition = new EventEmitter();
        this.smartFilterBarExpand = new EventEmitter();
        this.smartFilterDataChange = new EventEmitter();
        this.scrollbarUpdate = new EventEmitter();
        this.footerPositionChanged = new EventEmitter();
        this.styleElement = null;
        this.commonUtils = null;
        this.idService = null;
        // 单元格编辑器创建完成
        this.cellEditorCreated = new EventEmitter();
        // 单元格编辑器销毁
        this.cellEditorDestory = new EventEmitter();
        // 焦点行切换
        this.focusRowChanged = new EventEmitter();
        this.dataloaded = new EventEmitter();
        this.toggleGroupRow$ = new EventEmitter();
        this.toggleAllGroupRows$ = new EventEmitter();
        // CSS 文本缓存
        this.cssTextCache = [];
        this.groupBy = (/**
         * @param {?} arr
         * @param {?} fn
         * @return {?}
         */
        (arr, fn) => arr.map(typeof fn === 'function' ? fn : (/**
         * @param {?} val
         * @return {?}
         */
        val => Utils.getValue(fn, val))).reduce((/**
         * @param {?} acc
         * @param {?} val
         * @param {?} i
         * @return {?}
         */
        (acc, val, i) => {
            acc[val] = (acc[val] || []).concat(arr[i]);
            return acc;
        }), {}));
    }
    /**
     * @param {?} x
     * @param {?} action
     * @return {?}
     */
    onScrollMove(x, action) {
        this.scorllSubject.next({ x, type: action });
    }
    /**
     * @return {?}
     */
    dataSourceChanged() {
        this.dataSourceChangedSubject.next();
    }
    /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @param {?} mouseEnter
     * @return {?}
     */
    onRowHover(rowIndex, rowData, mouseEnter) {
        this.rowHoverSubject.next({ index: rowIndex, data: rowData, mouseenter: mouseEnter });
    }
    /**
     * @param {?} rowIndex
     * @param {?} rowData
     * @return {?}
     */
    onRowClick(rowIndex, rowData) {
        this.rowSelectSubject.next({ index: rowIndex, data: rowData });
    }
    /**
     * @param {?} tdElement
     * @return {?}
     */
    onCellEdit(tdElement) {
        this.editCellSubject.next(tdElement);
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    onEndCellEdit(cell) {
        this.endCellEdit.next(cell);
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    onSelectCell(cell) {
        this.selectCellSubject.next(cell);
    }
    /**
     * @return {?}
     */
    onCheckedRowsCountChange() {
        this.changeCheckedRows.next();
    }
    /**
     * @param {?} rowHeight
     * @return {?}
     */
    onRowHeightChange(rowHeight) {
        this.rowHeightChanged.emit(rowHeight);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onLoadVirtualData(data) {
        this.loadVirtualData.emit({ data });
    }
    /**
     * @return {?}
     */
    onClearFilter() {
        this.clearFilter.emit();
        this.filterTextChange.emit('');
    }
    /**
     * @param {?} txt
     * @return {?}
     */
    onFilterTextChange(txt) {
        this.filterTextChange.emit(txt);
    }
    /**
     * @return {?}
     */
    restoreScrollbarPosition() {
        this.setScrollbarPosition.emit();
    }
    /**
     * @return {?}
     */
    updateEmptyStyle() {
        this.updateEmptyStyle$.emit();
    }
    /**
     * @param {?} data
     * @param {?} mergeFields
     * @return {?}
     */
    getMergeCellInfo(data, mergeFields) {
        /** @type {?} */
        const result = {};
        /** @type {?} */
        let firstVal = null;
        /** @type {?} */
        let currVal;
        mergeFields.forEach((/**
         * @param {?} f
         * @param {?} i
         * @return {?}
         */
        (f, i) => {
            if (i === 0) {
                data.forEach((/**
                 * @param {?} d
                 * @param {?} j
                 * @return {?}
                 */
                (d, j) => {
                    /** @type {?} */
                    const item = { [f]: { show: true, rowspan: 1 } };
                    if (!result[j]) {
                        result[j] = item;
                    }
                    else {
                        if (!result[j][f]) {
                            result[j] = Object.assign(result[j], item);
                        }
                    }
                    /** @type {?} */
                    const _item = result[j];
                    currVal = d[f];
                    if (firstVal === null || firstVal !== currVal) {
                        firstVal = currVal;
                        _item[f].show = true;
                        _item[f].startIndex = j;
                    }
                    else {
                        /** @type {?} */
                        const strIndex = result[j - 1][f].startIndex;
                        _item[f].startIndex = strIndex;
                        _item[f].show = false;
                        result[strIndex][f].rowspan++;
                    }
                }));
            }
        }));
        return result;
    }
    /**
     * @param {?} data
     * @param {?} field
     * @return {?}
     */
    getMergeCellInfo0(data, field) {
        /** @type {?} */
        const result = {};
        /** @type {?} */
        let firstVal;
        /** @type {?} */
        let currVal;
        data.forEach((/**
         * @param {?} d
         * @param {?} j
         * @return {?}
         */
        (d, j) => {
            /** @type {?} */
            const item = { [field]: { show: true, rowspan: 1, value: '' } };
            if (!result[j]) {
                result[j] = item;
            }
            /** @type {?} */
            const _item = result[j];
            currVal = Utils.getValue(field, d);
            _item[field].value = currVal;
            if (firstVal === undefined || firstVal !== currVal) {
                firstVal = currVal;
                _item[field].show = true;
                _item[field].startIndex = j;
            }
            else {
                /** @type {?} */
                const strIndex = result[j - 1][field].startIndex;
                _item[field].startIndex = strIndex;
                _item[field].show = false;
                result[strIndex][field].rowspan++;
            }
        }));
        return result;
    }
    /**
     * @param {?} data
     * @param {?} mergeFields
     * @return {?}
     */
    getMergeCellInfo2(data, mergeFields) {
        /** @type {?} */
        let result = {};
        /** @type {?} */
        let firstVal = null;
        result = this.getMergeCellInfo0(data, mergeFields.splice(0, 1)[0]);
        /** @type {?} */
        const groupData = this.groupBy(data, mergeFields[0]);
        /** @type {?} */
        const groupKeys = Object.keys(groupData);
        /** @type {?} */
        let startRowIndex = 0;
        mergeFields.forEach((/**
         * @param {?} f
         * @param {?} i
         * @return {?}
         */
        (f, i) => {
            groupKeys.forEach((/**
             * @param {?} k
             * @param {?} j
             * @return {?}
             */
            (k, j) => {
                /** @type {?} */
                let currVal;
                groupData[k].forEach((/**
                 * @param {?} d
                 * @param {?} n
                 * @return {?}
                 */
                (d, n) => {
                    if (result[startRowIndex] && !result[startRowIndex][f]) {
                        result[startRowIndex] = Object.assign(result[startRowIndex], { [f]: { show: true, rowspan: 1, value: '' } });
                    }
                    /** @type {?} */
                    const _item = result[startRowIndex];
                    currVal = Utils.getValue(f, d);
                    _item[f].value = currVal;
                    if (firstVal === null || firstVal !== currVal) {
                        firstVal = currVal;
                        _item[f].show = true;
                        _item[f].startIndex = startRowIndex;
                    }
                    else {
                        /** @type {?} */
                        const strIndex = result[startRowIndex - 1][f].startIndex;
                        _item[f].startIndex = strIndex;
                        _item[f].show = false;
                        result[strIndex][f].rowspan++;
                    }
                    startRowIndex++;
                }));
            }));
        }));
        return result;
    }
    /**
     * @param {?} data
     * @param {?} mergeFields
     * @return {?}
     */
    getMergeCellInfo3(data, mergeFields) {
        /** @type {?} */
        let result = {};
        /** @type {?} */
        const firstField = mergeFields.splice(0, 1)[0];
        result = this.getMergeCellInfo0(data, firstField);
        /** @type {?} */
        let prevGroupField = firstField;
        // const groupData = this.groupBy(data, firstField);
        // const groupKeys = Object.keys(groupData);
        mergeFields.forEach((/**
         * @param {?} f
         * @param {?} i
         * @return {?}
         */
        (f, i) => {
            /** @type {?} */
            let startRowIndex = 0;
            /** @type {?} */
            let firstVal;
            /** @type {?} */
            let currVal;
            if (i > 0) {
                prevGroupField = mergeFields[i - 1];
            }
            data.forEach((/**
             * @param {?} d
             * @param {?} n
             * @return {?}
             */
            (d, n) => {
                if (result[startRowIndex] && !result[startRowIndex][f]) {
                    result[startRowIndex] = Object.assign(result[startRowIndex], { [f]: { show: true, rowspan: 1, value: '' } });
                }
                /** @type {?} */
                const _item = result[startRowIndex];
                currVal = Utils.getValue(f, d);
                _item[f].value = currVal;
                if (startRowIndex > 0) {
                    /** @type {?} */
                    const prevItem = result[startRowIndex - 1];
                    /** @type {?} */
                    const _c = Object.keys(_item).map((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => '' + _item[c].value)).join(',');
                    /** @type {?} */
                    const _p = Object.keys(prevItem).map((/**
                     * @param {?} p
                     * @return {?}
                     */
                    p => '' + prevItem[p].value)).join(',');
                    if (_c !== _p) {
                        firstVal = undefined;
                    }
                }
                if ((firstVal === undefined || firstVal !== currVal)) {
                    firstVal = currVal;
                    _item[f].show = true;
                    _item[f].startIndex = startRowIndex;
                }
                else {
                    /** @type {?} */
                    const startIndex = result[startRowIndex - 1][f].startIndex;
                    _item[f].startIndex = startIndex;
                    _item[f].show = false;
                    result[startIndex][f].rowspan++;
                }
                if (data.length - 1 > startRowIndex) {
                    startRowIndex++;
                }
            }));
        }));
        return result;
    }
    /**
     * @param {?} rowIndex
     * @param {?} field
     * @param {?} mergeCellInfo
     * @return {?}
     */
    getMergeInfo(rowIndex, field, mergeCellInfo) {
        if (field && mergeCellInfo && mergeCellInfo[rowIndex] && mergeCellInfo[rowIndex][field]) {
            return mergeCellInfo[rowIndex][field];
        }
        return null;
    }
    /**
     * @return {?}
     */
    removeStyleSheet() {
        if (this.styleElement) {
            this.styleElement.remove();
            this.styleElement = null;
            // 清空缓存
            this.cssTextCache = [];
        }
    }
    /**
     * @param {?} styleSheetId
     * @return {?}
     */
    createStyleElement(styleSheetId) {
        this.styleElement = this._createStyleSheet(styleSheetId);
    }
    /**
     * @param {?} rules
     * @return {?}
     */
    appendCssRules(rules) {
        if (this.styleElement) {
            this._appendCssRules(rules, this.styleElement.sheet);
        }
    }
    /**
     * @param {?} ruleName
     * @return {?}
     */
    removeCssRule(ruleName) {
        if (this.styleElement) {
            if (typeof ruleName === 'string') {
                this._removeCssRule(ruleName, this.styleElement.sheet);
                this.cssTextCache = this.cssTextCache.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.indexOf(ruleName) == -1));
            }
            else {
                if (Array.isArray(ruleName)) {
                    ruleName.forEach((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => {
                        this._removeCssRule(n, this.styleElement.sheet);
                        this.cssTextCache = this.cssTextCache.filter((/**
                         * @param {?} n
                         * @return {?}
                         */
                        n => n.indexOf(n) == -1));
                    }));
                }
            }
        }
    }
    /**
     * @private
     * @param {?} styleSheetId
     * @return {?}
     */
    _createStyleSheet(styleSheetId) {
        /** @type {?} */
        const htmlHead = document.querySelector('head');
        /** @type {?} */
        const styleEleId = styleSheetId;
        /** @type {?} */
        let styleElement = null;
        if (document.querySelector('#' + styleEleId)) {
            styleElement = document.querySelector('#' + styleEleId);
            styleElement.innerText = '';
        }
        else {
            styleElement = document.createElement('style');
            styleElement.id = styleEleId;
            styleElement.type = 'text/css';
            htmlHead.appendChild(styleElement);
        }
        return styleElement;
    }
    /**
     * @private
     * @param {?} rules
     * @param {?} styleSheet
     * @return {?}
     */
    _appendCssRules(rules, styleSheet) {
        /** @type {?} */
        let allCssText = '';
        for (const rule of rules) {
            /** @type {?} */
            const ruleName = rule.slice(0, rule.indexOf('{')).trim();
            // const removedCssRule = this._removeCssRule(ruleName, styleSheet);
            /** @type {?} */
            const removedCssRule = this._getCssTextBySelector(ruleName, styleSheet);
            /** @type {?} */
            let cssText = '';
            if (removedCssRule && ruleName.indexOf(CUSTOM_CELL_CLS) == -1 && ruleName.indexOf(CUSTOM_GROUP_ROW_CLS) == -1 && ruleName.indexOf(CUSTOM_ROW_CLS) == -1) {
                cssText += removedCssRule.cssText.slice(removedCssRule.cssText.indexOf('{') + 1, removedCssRule.cssText.indexOf('}'));
            }
            cssText += rule.slice(rule.indexOf('{') + 1, rule.indexOf('}')).replace(/"/g, '').replace(/,/g, ';') + ';';
            /** @type {?} */
            const _newRule = `${ruleName}{ ${cssText} }`;
            allCssText += _newRule;
            if (!this.cssTextCache.includes(_newRule)) {
                // 将合并后CSS文本添加到缓存
                this.cssTextCache.push(_newRule);
                if (styleSheet.addRule) {
                    styleSheet.addRule(ruleName, cssText, 0);
                }
                else {
                    styleSheet.insertRule(_newRule, 0);
                }
            }
        }
        return allCssText;
    }
    /**
     * @private
     * @param {?} ruleName
     * @param {?} styleSheet
     * @return {?}
     */
    _removeCssRule(ruleName, styleSheet) {
        if (!styleSheet) {
            return;
        }
        /** @type {?} */
        const cssRules = (/** @type {?} */ ((styleSheet.cssRules || styleSheet.rules)));
        /** @type {?} */
        let ii = 0;
        /** @type {?} */
        let cssRule = false;
        do {
            cssRule = cssRules[ii];
            if (cssRule) {
                if (cssRule.selectorText.toLowerCase() == ruleName.toLowerCase()) {
                    if (styleSheet.cssRules) {
                        styleSheet.deleteRule(ii);
                    }
                    else {
                        styleSheet.removeRule(ii);
                    }
                    return cssRule;
                }
            }
            ii++;
        } while (cssRule);
    }
    /**
     * @param {?} gridID
     * @return {?}
     */
    createConfigKey(gridID) {
        const { host, hash, href, pathname } = location;
        /** @type {?} */
        let formCode = '';
        /** @type {?} */
        let menuId = '';
        if (hash) {
            /** @type {?} */
            const _searchArr = hash.split('?');
            formCode = _searchArr[0];
            /** @type {?} */
            const searchObj = {};
            if (_searchArr[1]) {
                _searchArr[1].split('&').map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    searchObj[n.split('=')[0]] = n.split('=')[1];
                }));
            }
            /** @type {?} */
            const catchFuncIdKEY = `${pathname}`;
            if (searchObj && Object.keys(searchObj).length) {
                menuId = searchObj.funcId || '';
                if (menuId) {
                    localStorage.setItem(catchFuncIdKEY, menuId);
                }
            }
            if (!menuId) {
                menuId = localStorage.getItem(catchFuncIdKEY);
            }
        }
        /** @type {?} */
        const key = formCode + '_' + menuId + '_' + gridID;
        if (!this.idService) {
            this.idService = new IdService();
        }
        return this.idService.encrypt(key);
    }
    /**
     * @param {?} styler
     * @param {?} args
     * @return {?}
     */
    getCustomStyle(styler, args) {
        if (typeof styler === 'object') {
            return styler;
        }
        else {
            if (typeof styler === 'function') {
                /** @type {?} */
                const p = args || [];
                return styler(...p);
            }
        }
    }
    /**
     * @param {?} nextTr
     * @param {?} dir
     * @return {?}
     */
    findNextTr(nextTr, dir) {
        /** @type {?} */
        const getNextElement = (/**
         * @param {?} target
         * @return {?}
         */
        (target) => {
            if (target && target.className.indexOf('f-datagrid-disable-row') == -1) {
                return target;
            }
            return false;
        });
        /** @type {?} */
        const m = dir === 'down' ? 'nextElementSibling' : 'previousElementSibling';
        /** @type {?} */
        const getEle = (/**
         * @param {?} t
         * @return {?}
         */
        (t) => {
            /** @type {?} */
            let n = null;
            /** @type {?} */
            let next = true;
            while (next) {
                n = getNextElement(t);
                if (n) {
                    next = false;
                }
                else {
                    if (t && t[m]) {
                        n = getNextElement(t[m]);
                        if (n) {
                            break;
                        }
                    }
                    else {
                        next = false;
                    }
                }
            }
            return n;
        });
        return getEle(nextTr);
    }
    /**
     * @private
     * @param {?} selector
     * @param {?} styleSheet
     * @return {?}
     */
    _getCssTextBySelector(selector, styleSheet) {
        if (!styleSheet) {
            return;
        }
        /** @type {?} */
        const cssRules = (/** @type {?} */ ((styleSheet.cssRules || styleSheet.rules)));
        /** @type {?} */
        let ii = 0;
        /** @type {?} */
        let cssRule = false;
        do {
            cssRule = cssRules[ii];
            if (cssRule) {
                if (cssRule.selectorText.toLowerCase() == selector.toLowerCase()) {
                    return cssRule;
                }
            }
            ii++;
        } while (cssRule);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DATAGRID_REST_SERVICEE = new InjectionToken('DataGrid Request Data Service.');
/**
 * @abstract
 */
class RestService {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DefaultDatagridValidatorMessager = {
    required: '此字段不能为空。',
    min: '最小值不能小于${0}',
    max: '最大值不能大于${0}',
    minlength: '至少输入${0}个字符',
    maxlength: '字符长度不能大于${0}',
    email: 'Email 格式不正确',
    requriedtrue: '务必选中',
    pattern: '输入的格式不正确。'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidatorMessagerService {
    /**
     * @param {?} validatorName
     * @param {?} validators
     * @return {?}
     */
    getValidatorErrorMessage(validatorName, validators) {
        validatorName = validatorName.toLowerCase();
        /** @type {?} */
        const validator = validators.find((/**
         * @param {?} v
         * @return {?}
         */
        v => v.type.toLowerCase() === validatorName));
        if (validator && validator.messager) {
            return validator.messager;
        }
        else {
            return DefaultDatagridValidatorMessager[validatorName] ? DefaultDatagridValidatorMessager[validatorName] : '验证不通过！';
        }
    }
}
ValidatorMessagerService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * @Author: 疯狂秀才(Lucas Huang)
 * @Date: 2019-08-06 07:43:07
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-08-21 15:13:50
 * @QQ: 1055818239
 * @Version: v0.0.1
 */
class DomHandler {
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    static hasClass(element, className) {
        if (element) {
            if (element.classList) {
                return Array.from(element.classList).filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n === className)).length > 0;
            }
            else {
                return element.className.indexOf(className) > -1;
            }
        }
        return false;
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    static removeClass(element, className) {
        if (element) {
            if (element.classList) {
                element.classList.remove(className);
            }
            else {
                element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
            }
        }
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    static findSingle(element, selector) {
        if (element) {
            return element.querySelector(selector);
        }
        return null;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getOffset(el) {
        /** @type {?} */
        const rect = el.getBoundingClientRect();
        return {
            top: rect.top + document.body.scrollTop,
            left: rect.left + document.body.scrollLeft
        };
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    static getOuterHeight(el, margin) {
        /** @type {?} */
        let height = el.offsetHeight;
        if (margin) {
            /** @type {?} */
            const style = getComputedStyle(el);
            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }
        return height;
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    static getOuterWidth(el, margin) {
        /** @type {?} */
        let width = el.offsetWidth;
        if (margin) {
            /** @type {?} */
            const style = getComputedStyle(el);
            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }
        return width;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridFilterService {
    /**
     * @param {?} dfs
     * @param {?} localeSer
     * @param {?} inject
     */
    constructor(dfs, localeSer, inject) {
        this.dfs = dfs;
        this.localeSer = localeSer;
        this.inject = inject;
        this.removeField = new EventEmitter();
    }
    /**
     * @param {?} rowData
     * @param {?} conditions
     * @return {?}
     */
    validateRowData(rowData, conditions) {
        if (!conditions || Object.keys(conditions).length === 0) {
            return true;
        }
        return this.checkAllFieldInRowData(rowData, conditions);
    }
    /**
     * @param {?} data
     * @param {?} conditions
     * @return {?}
     */
    executeFilter(data, conditions) {
        if (this.dfs.getState().enableSmartFilter) {
            return this.executeSmartFilter(data, conditions);
        }
        if (data && data.length) {
            return data.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => this.validateRowData(n, conditions)));
        }
        return data;
    }
    /**
     * @private
     * @param {?} fieldDataValue
     * @param {?} operator
     * @param {?} targetValue
     * @return {?}
     */
    getCompareResult(fieldDataValue, operator, targetValue) {
        /** @type {?} */
        const op = parseInt('' + operator, 10);
        switch (op) {
            case Compare.Equal:
                return fieldDataValue == targetValue;
            case Compare.NotEqual:
                return ('' + fieldDataValue).toLowerCase() !== ('' + targetValue).toLowerCase();
            case Compare.Greater:
                return fieldDataValue > targetValue;
            case Compare.GreaterOrEqual:
                return fieldDataValue >= targetValue;
            case Compare.Less:
                return fieldDataValue < targetValue;
            case Compare.LessOrEqual:
                return fieldDataValue <= targetValue;
            case Compare.Like:
                if (fieldDataValue == null) {
                    fieldDataValue = '';
                }
                return ('' + fieldDataValue).toLowerCase().indexOf(targetValue.toLowerCase()) > -1;
            case Compare.NotLike:
                return ('' + fieldDataValue).toLowerCase().indexOf(targetValue.toLowerCase()) === -1;
            case Compare.In:
                targetValue = targetValue || [];
                return targetValue.findIndex((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n == fieldDataValue)) > -1;
            case 1001: // Empty
                return trim(fieldDataValue) === '' || fieldDataValue === null || fieldDataValue === undefined;
            case 1002: // NotEmpty
                return trim(fieldDataValue) !== '' && fieldDataValue !== null && fieldDataValue !== undefined;
            case 1003: // Null
                return fieldDataValue === null;
            case 1004: // NotNull
                return fieldDataValue !== null;
        }
    }
    /**
     * @private
     * @param {?} result1
     * @param {?} relation
     * @param {?} result2
     * @return {?}
     */
    getRelationResult(result1, relation, result2) {
        /** @type {?} */
        const _relation = relation.toLowerCase();
        if (_relation === 'and') {
            return result1 && result2;
        }
        else {
            return result1 || result2;
        }
    }
    /**
     * @private
     * @param {?} resultObj
     * @return {?}
     */
    checkAllFieldResult(resultObj) {
        if (!resultObj) {
            return true;
        }
        return Object.values(resultObj).reduce((/**
         * @param {?} c
         * @param {?} n
         * @return {?}
         */
        (c, n) => {
            return c && n;
        }), true);
    }
    /**
     * @private
     * @param {?} rowData
     * @param {?} conditions
     * @return {?}
     */
    checkAllFieldInRowData(rowData, conditions) {
        // this.state = conditions;
        /** @type {?} */
        let resultObj = null;
        if (conditions) {
            /** @type {?} */
            const fields = Object.keys(conditions);
            resultObj = {};
            fields.forEach((/**
             * @param {?} field
             * @return {?}
             */
            field => {
                /** @type {?} */
                let fieldValue = Utils.getValue(field, rowData);
                /** @type {?} */
                const columnObj = this.dfs.getColumn(field);
                if (columnObj && columnObj.isMultilingualField) {
                    fieldValue = Utils.getMultilingualValue(fieldValue, this.localeSer.localeId);
                }
                /** @type {?} */
                const where = conditions[field];
                const { value1, operator1, relation, operator2, value2 } = where;
                if (where) {
                    /** @type {?} */
                    const result = this.getCompareResult(fieldValue, operator1, value1);
                    resultObj[field] = result;
                    if (relation) {
                        /** @type {?} */
                        const result2 = this.getCompareResult(fieldValue, operator2, value2);
                        resultObj[field] = this.getRelationResult(result, relation, result2);
                    }
                }
            }));
        }
        return this.checkAllFieldResult(resultObj);
    }
    /**
     * @param {?} field
     * @return {?}
     */
    removeFilterField(field) {
        this.removeField.emit(field);
    }
    /**
     * @param {?} conditions
     * @return {?}
     */
    convertFilterCondition2String(conditions) {
        if (!conditions) {
            return '';
        }
        /** @type {?} */
        let str = '';
        /** @type {?} */
        const andText = this.localeSer.getValue('datagrid.filter.and');
        /** @type {?} */
        const orText = this.localeSer.getValue('datagrid.filter.or');
        /** @type {?} */
        const and = `<span class='badge badge-success'>${andText}</span>`;
        /** @type {?} */
        const and2 = `<span class='badge badge-info'>${andText}</span>`;
        /** @type {?} */
        const or = `<span class='badge badge-warning'>${orText}</span>`;
        /** @type {?} */
        const lbracket = `<b>〔</b>`;
        /** @type {?} */
        const rbracket = `<b>〕</b>`;
        /** @type {?} */
        const ellipsis = `[ <span class="ellipsis" title="$title$">  $value$<i class="f-icon f-icon-lookup"></i></span> ]`;
        str = Object.keys(conditions).reduce((/**
         * @param {?} c
         * @param {?} r
         * @return {?}
         */
        (c, r) => {
            /** @type {?} */
            const filter = conditions[r];
            /** @type {?} */
            const col = this.dfs.getColumn(r);
            /** @type {?} */
            const t = `<b>${col.title}</b>`;
            /** @type {?} */
            let s = ` ${t} ${this.getCompareString(filter.operator1)} ${Utils.escapeValue(filter.value1)}  `;
            if (filter.operator1 == Compare.In) {
                /** @type {?} */
                let txt = filter.value1;
                /** @type {?} */
                let txt2 = txt;
                if (col.filter.type === ColumnFilterType.enum) {
                    /** @type {?} */
                    const enumOpts = DatagridColumnsHelper.getFilterEnumOptions(col);
                    txt = DatagridColumnsHelper.getEnumText(enumOpts, filter.value1);
                    txt2 = txt.split(',').slice(0, 2).join(',');
                }
                else {
                    txt2 = txt.slice(0, 2).join(',');
                }
                s = ` ${t} ${this.getCompareString(filter.operator1)} [ ${txt} ]  `;
                if (filter.value1.length > 2) {
                    s = ` ${t} ${this.getCompareString(filter.operator1)} ${ellipsis.replace('$title$', txt).replace('$value$', txt2)}  `;
                }
            }
            else {
                if (filter.operator1 == Compare.Equal && Array.isArray(filter.value1)) {
                    if (!filter.value1.length) {
                        s = ` ${t} ${this.getCompareString(filter.operator1)} ''  `;
                    }
                }
            }
            if (filter.relation) {
                /** @type {?} */
                const s2 = `${t} ${this.getCompareString(filter.operator2)} ${filter.value2}`;
                s = `${lbracket} ${s} ${filter.relation === 'and' ? and2 : or} ${s2} ${rbracket}`;
            }
            return `${c} <span class="filter-field filter-column-${r}"> ${s} AND </span>`;
        }), '');
        /** @type {?} */
        const lastANDidx = str.lastIndexOf('AND');
        /** @type {?} */
        let resultStr = str.substr(0, lastANDidx);
        resultStr += str.substr(lastANDidx + 3);
        return resultStr.replace(/AND/g, and).replace(/OR/g, or);
    }
    /**
     * @private
     * @param {?} operator
     * @return {?}
     */
    getCompareString(operator) {
        /** @type {?} */
        const op = parseInt('' + operator, 10);
        /** @type {?} */
        let code = '';
        switch (op) {
            case Compare.Equal:
            case Compare.NotEqual:
            case Compare.Greater:
            case Compare.GreaterOrEqual:
            case Compare.Less:
            case Compare.LessOrEqual:
            case Compare.Like:
            case Compare.NotLike:
            case Compare.In:
                code = Compare[op];
                code = code[0].toLowerCase() + code.substr(1);
                return this.localeSer.getValue('datagrid.filter.operators.' + code);
            case 1001: // Empty
                return ' ' + this.localeSer.getValue('datagrid.filter.operators.empty');
            case 1002: // NotEmpty
                return ' ' + this.localeSer.getValue('datagrid.filter.operators.notEmpty');
            case 1003: // Null
                return ' ' + this.localeSer.getValue('datagrid.filter.operators.null');
            case 1004: // NotNull
                return ' ' + this.localeSer.getValue('datagrid.filter.operators.notNull');
        }
    }
    /**
     * @param {?} condition
     * @return {?}
     */
    convert2FilterArray(condition) {
        /** @type {?} */
        const filterArr = [];
        /** @type {?} */
        const excludeDataTypes = ['number', 'date', 'datetime'];
        if (condition) {
            /** @type {?} */
            const fields = Object.keys(condition);
            if (fields && fields.length) {
                fields.forEach((/**
                 * @param {?} field
                 * @return {?}
                 */
                field => {
                    /** @type {?} */
                    const columnInfo = this.dfs.getColumn(field);
                    /** @type {?} */
                    const dataType = columnInfo.dataType || 'string';
                    /** @type {?} */
                    const obj = { filterField: field, value: '', lbracket: '', rbracket: '', relation: 1, compare: 0 };
                    /** @type {?} */
                    const conditionVal = condition[field];
                    if (typeof conditionVal === 'object') {
                        // tfs 568484
                        /** @type {?} */
                        const operator1 = parseInt('' + conditionVal.operator1, 10);
                        if (operator1 === 1001 || operator1 === 1002) {
                            obj.compare = operator1 === 1001 ? Compare.Equal : Compare.NotEqual;
                            obj.lbracket = '(';
                            obj.relation = operator1 === 1002 ? 1 : 2;
                            filterArr.push(obj);
                            if (excludeDataTypes.includes(dataType)) {
                                obj.value = null;
                                obj.lbracket = '';
                                obj.relation = 1;
                                obj.compare = operator1 === 1002 ? Compare.IsNot : Compare.Is;
                                return;
                            }
                            /** @type {?} */
                            const obj2 = { filterField: field, value: null, lbracket: '', rbracket: ')', relation: 1, compare: 0 };
                            if (operator1 === 1002) {
                                obj2.compare = Compare.IsNot;
                            }
                            else {
                                obj2.compare = Compare.Is;
                            }
                            filterArr.push(obj2);
                            return;
                        }
                        obj.compare = conditionVal.operator1;
                        obj.value = conditionVal.value1;
                        filterArr.push(obj);
                        if (conditionVal.value2) {
                            obj.lbracket = '(';
                            obj.relation = conditionVal.relation === 'and' ? 1 : 2;
                            /** @type {?} */
                            const obj2 = { filterField: field, value: '', lbracket: '', rbracket: ')', relation: 1, compare: 0 };
                            obj2.compare = conditionVal.operator2;
                            obj2.value = conditionVal.value2;
                            filterArr.push(obj2);
                        }
                        else {
                            if (conditionVal.operator2) {
                                /** @type {?} */
                                const op2 = parseInt('' + conditionVal.operator2, 10);
                                if (op2 === 1001 || op2 === 1002) {
                                    obj.lbracket = '(';
                                    obj.relation = conditionVal.relation === 'and' ? 1 : 2;
                                    /** @type {?} */
                                    const obj2 = { filterField: field, value: '', lbracket: '(', rbracket: '', relation: 2, compare: 0 };
                                    obj2.compare = op2 === 1001 ? Compare.Equal : Compare.NotEqual;
                                    obj2.relation = op2 === 1002 ? 1 : 2;
                                    filterArr.push(obj2);
                                    if (excludeDataTypes.includes(dataType)) {
                                        obj2.value = null;
                                        obj2.lbracket = '';
                                        obj2.rbracket = ')';
                                        obj2.relation = 1;
                                        obj2.compare = op2 === 1002 ? Compare.IsNot : Compare.Is;
                                        return;
                                    }
                                    /** @type {?} */
                                    const obj21 = { filterField: field, value: null, lbracket: '', rbracket: '))', relation: 1, compare: 0 };
                                    obj21.compare = op2 === 1001 ? Compare.Is : Compare.IsNot;
                                    filterArr.push(obj21);
                                }
                            }
                        }
                    }
                    return obj;
                }));
            }
        }
        if (filterArr.length) {
            this.checkEnumTypeFilters(filterArr);
            filterArr[filterArr.length - 1].relation = 0;
        }
        return filterArr;
    }
    /**
     * @private
     * @param {?} filterArr
     * @return {?}
     */
    checkEnumTypeFilters(filterArr) {
        /** @type {?} */
        const enumFilters = {};
        filterArr.forEach((/**
         * @param {?} f
         * @param {?} i
         * @return {?}
         */
        (f, i) => {
            /** @type {?} */
            const enumFilterArr = this.convertEnumTypeFilter(f);
            if (enumFilterArr && enumFilterArr.length) {
                enumFilters[f.filterField] = enumFilterArr;
            }
        }));
        /** @type {?} */
        const keys = Object.keys(enumFilters);
        if (keys.length) {
            keys.forEach((/**
             * @param {?} k
             * @return {?}
             */
            (k) => {
                /** @type {?} */
                const i = filterArr.findIndex((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.filterField === k));
                filterArr.splice(i, 1, ...enumFilters[k]);
            }));
        }
        return filterArr;
    }
    // 将enum 类型的条件转换多个条件
    /**
     * @private
     * @param {?} filter
     * @return {?}
     */
    convertEnumTypeFilter(filter) {
        if (filter) {
            /** @type {?} */
            const col = (/** @type {?} */ (this.dfs.getColumn(filter.filterField)));
            if (col && col.filter && col.filter.type === ColumnFilterType.enum) {
                if (Array.isArray(filter.value) && filter.value.length) {
                    if (filter.value.length === 1) {
                        filter.compare = Compare.Equal;
                        filter.value = filter.value[0];
                        return [];
                    }
                    else {
                        // > 1
                        /** @type {?} */
                        let filterArr = filter.value.map((/**
                         * @param {?} val
                         * @return {?}
                         */
                        (val) => {
                            return {
                                filterField: filter.filterField,
                                value: val,
                                lbracket: '',
                                rbracket: '',
                                relation: 2,
                                // or
                                compare: 0
                            };
                        }));
                        filterArr[0].lbracket = '(';
                        filterArr[filter.value.length - 1].rbracket = ')';
                        filterArr[filter.value.length - 1].relation = 1;
                        return filterArr;
                    }
                }
            }
        }
        return [];
    }
    /**
     * @param {?} col
     * @return {?}
     */
    createColumnFilterOptions(col) {
        /** @type {?} */
        let filterTypeOptions = {
            type: ColumnFilterType.string,
            enableOperator: true
        };
        if (col.editor) {
            switch (col.editor.type) {
                case 'textarea':
                case 'textbox':
                case 'language-textbox':
                    filterTypeOptions = {
                        type: ColumnFilterType.string,
                        enableOperator: true
                    };
                    break;
                case 'checkbox':
                case 'switch':
                    filterTypeOptions = {
                        type: ColumnFilterType.boolean,
                        enableOperator: false
                    };
                    break;
                case 'numberbox':
                    filterTypeOptions = {
                        type: ColumnFilterType.number,
                        enableOperator: true
                    };
                    break;
                case 'combolist':
                case 'select':
                    filterTypeOptions = {
                        type: ColumnFilterType.enum,
                        enableOperator: true,
                        options: col.editor.options
                    };
                    break;
                case 'datepicker':
                    filterTypeOptions = {
                        type: col['dataType'] === 'datetime' ? ColumnFilterType.datetime : ColumnFilterType.date,
                        enableOperator: true,
                        options: {
                            dateFormat: col.editor.options.dateFormat,
                            returnFormat: col.editor.options.returnFormat
                        }
                    };
                    break;
                case 'timepicker':
                    filterTypeOptions = {
                        type: ColumnFilterType.time,
                        enableOperator: true
                    };
                    break;
            }
        }
        else if (col.formatter) {
            if (typeof col.formatter === 'object' && Object.keys(col.formatter).length) {
                /** @type {?} */
                const options = col.formatter['options'];
                switch (col.formatter['type']) {
                    case 'number':
                        filterTypeOptions = {
                            type: ColumnFilterType.number,
                            enableOperator: true
                        };
                        break;
                    case 'enum':
                        filterTypeOptions = {
                            type: ColumnFilterType.enum,
                            enableOperator: true,
                            options
                        };
                        break;
                    case 'boolean':
                        filterTypeOptions = {
                            type: ColumnFilterType.boolean,
                            enableOperator: false
                        };
                        break;
                    case 'datetime':
                        /** @type {?} */
                        let tye = ColumnFilterType.datetime;
                        /** @type {?} */
                        let fmt = 'yyyy-MM-dd';
                        /** @type {?} */
                        let returnFmt = 'yyyy-MM-dd';
                        if (options && options.format) {
                            fmt = options.format;
                            if (fmt.indexOf('HH:') == -1) {
                                tye = ColumnFilterType.date;
                            }
                            else {
                                returnFmt += ' HH:mm';
                                if (fmt.indexOf('ss') > -1) {
                                    returnFmt += ':ss';
                                }
                            }
                        }
                        else {
                            tye = ColumnFilterType.date;
                        }
                        filterTypeOptions = {
                            type: tye,
                            enableOperator: true
                        };
                        filterTypeOptions.options = { dateFormat: fmt, returnFormat: returnFmt };
                        break;
                    default:
                        filterTypeOptions = {
                            type: ColumnFilterType.string,
                            enableOperator: true
                        };
                }
            }
        }
        else {
            filterTypeOptions = {
                type: ColumnFilterType.string,
                enableOperator: true
            };
        }
        return filterTypeOptions;
    }
    //#region  Smart Filter
    /**
     * @param {?} conditions
     * @return {?}
     */
    convertSmartFilter2EntityFilter(conditions) {
        if (conditions && conditions.length) {
            return conditions.map((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                return n;
            }));
        }
        return [];
    }
    /**
     * @private
     * @param {?} rowData
     * @param {?} conditions
     * @return {?}
     */
    validateRowData2(rowData, conditions) {
        if (!conditions || conditions.length === 0) {
            return true;
        }
        return this.checkRowDataWithCondition(rowData, conditions);
    }
    /**
     * @private
     * @param {?} rowData
     * @param {?} conditions
     * @return {?}
     */
    checkRowDataWithCondition(rowData, conditions) {
        /** @type {?} */
        let resultObj = null;
        if (conditions) {
            resultObj = {};
            conditions.forEach((/**
             * @param {?} condition
             * @return {?}
             */
            condition => {
                /** @type {?} */
                const field = condition.FilterField;
                /** @type {?} */
                let fieldValue = Utils.getValue(field, rowData);
                /** @type {?} */
                const columnObj = this.dfs.getColumn(field);
                if (columnObj && columnObj.isMultilingualField) {
                    fieldValue = Utils.getMultilingualValue(fieldValue, this.localeSer.localeId);
                }
                /** @type {?} */
                const where = condition;
                const { Value, Relation, Compare: operator1 } = where;
                if (where) {
                    /** @type {?} */
                    const r = this.getCompareResult(fieldValue, operator1, Value);
                    if (resultObj[field] === undefined) {
                        resultObj[field] = [r];
                    }
                    else {
                        resultObj[field].push(r);
                    }
                }
            }));
        }
        // return this.checkAllFieldResult(resultObj);
        /** @type {?} */
        const fields = Object.keys(resultObj);
        /** @type {?} */
        const result = [];
        fields.forEach((/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            /** @type {?} */
            const _filters = conditions.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.FilterField === f));
            if (resultObj[f].length === 1) {
                result.push(resultObj[f][0]);
            }
            else {
                if (_filters[0].Relation === 1 && resultObj[f].length === 2) { // and
                    result.push(resultObj[f][0] && resultObj[f][1]);
                }
                else { // or
                    result.push(resultObj[f].indexOf(true) > -1);
                }
            }
        }));
        return result.indexOf(false) === -1;
    }
    /**
     * @param {?} data
     * @param {?} conditions
     * @return {?}
     */
    executeSmartFilter(data, conditions) {
        if (data && data.length) {
            return data.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => this.validateRowData2(n, conditions)));
        }
        return data;
    }
}
DatagridFilterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DatagridFilterService.ctorParameters = () => [
    { type: DatagridFacadeService },
    { type: LocaleService },
    { type: Injector }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated 内部分组件已废弃，分页组件使用farris-ui 中的公共组件
 */
class NgxPaginationModule {
}
NgxPaginationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [CommonModule],
                exports: [],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationService {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SCROLLBAR_CONFIG = new InjectionToken('PERFECT_SCROLLBAR_CONFIG');
class Geometry {
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} w
     * @param {?} h
     */
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
}
class Position {
    /**
     * @param {?} x
     * @param {?} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
/** @type {?} */
const ScrollbarEvents = [
    'psScrollY',
    'psScrollX',
    'psScrollUp',
    'psScrollDown',
    'psScrollLeft',
    'psScrollRight',
    'psYReachEnd',
    'psYReachStart',
    'psXReachEnd',
    'psXReachStart'
];
class ScrollbarConfig {
    /**
     * @param {?=} config
     */
    constructor(config = {}) {
        this.assign(config);
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    assign(config = {}) {
        for (const key in config) {
            this[(/** @type {?} */ (key))] = config[(/** @type {?} */ (key))];
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollbarDirective {
    /**
     * @param {?} zone
     * @param {?} differs
     * @param {?} elementRef
     * @param {?} platformId
     * @param {?} defaults
     */
    constructor(zone, differs, elementRef, platformId, defaults) {
        this.zone = zone;
        this.differs = differs;
        this.elementRef = elementRef;
        this.platformId = platformId;
        this.defaults = defaults;
        this.instance = null;
        this.ro = null;
        this.timeout = null;
        this.animation = null;
        this.configDiff = null;
        this.ngDestroy = new Subject();
        this.disabled = false;
        this.psScrollY = new EventEmitter();
        this.psScrollX = new EventEmitter();
        this.psScrollUp = new EventEmitter();
        this.psScrollDown = new EventEmitter();
        this.psScrollLeft = new EventEmitter();
        this.psScrollRight = new EventEmitter();
        this.psYReachEnd = new EventEmitter();
        this.psYReachStart = new EventEmitter();
        this.psXReachEnd = new EventEmitter();
        this.psXReachStart = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.disabled && isPlatformBrowser(this.platformId)) {
            /** @type {?} */
            const config = new ScrollbarConfig(this.defaults);
            config.assign(this.config); // Custom configuration
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.instance = new PerfectScrollbar(this.elementRef.nativeElement, config);
                }));
            }));
            if (!this.configDiff) {
                this.configDiff = this.differs.find(this.config || {}).create();
                this.configDiff.diff(this.config || {});
            }
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.ro = new ResizeObserver((/**
                 * @return {?}
                 */
                () => {
                    this.update();
                }));
                if (this.elementRef.nativeElement.children[0]) {
                    this.ro.observe(this.elementRef.nativeElement.children[0]);
                }
                this.ro.observe(this.elementRef.nativeElement);
            }));
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                ScrollbarEvents.forEach((/**
                 * @param {?} eventName
                 * @return {?}
                 */
                (eventName) => {
                    /** @type {?} */
                    const eventType = eventName.replace(/([A-Z])/g, (/**
                     * @param {?} c
                     * @return {?}
                     */
                    (c) => `-${c.toLowerCase()}`));
                    if (eventName.indexOf('X') > -1 || eventName.indexOf('Left') > -1 || eventName.indexOf('Right') > -1) {
                        fromEvent(this.elementRef.nativeElement, eventType).subscribe((/**
                         * @param {?} event
                         * @return {?}
                         */
                        (event) => {
                            this[eventName].emit(event);
                        }));
                    }
                    else {
                        fromEvent(this.elementRef.nativeElement, eventType).pipe(takeUntil(this.ngDestroy)).pipe(
                        // debounceTime(20),
                        // throttle(ev => interval(20)),
                        auditTime(20))
                            .subscribe((/**
                         * @param {?} event
                         * @return {?}
                         */
                        (event) => {
                            this[eventName].emit(event);
                        }));
                    }
                }));
            }));
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // this.zone.runOutsideAngular(() => {
        //     this.instance = new PerfectScrollbar(this.elementRef.nativeElement, this.config);
        // });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (isPlatformBrowser(this.platformId)) {
            this.ngDestroy.next();
            this.ngDestroy.complete();
            if (this.ro) {
                this.ro.disconnect();
            }
            if (this.timeout && typeof window !== 'undefined') {
                window.clearTimeout(this.timeout);
            }
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                if (this.instance) {
                    this.instance.destroy();
                }
            }));
            this.instance = null;
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (!this.disabled && this.configDiff && isPlatformBrowser(this.platformId)) {
            /** @type {?} */
            const changes = this.configDiff.diff(this.config || {});
            if (changes) {
                this.ngOnDestroy();
                this.ngOnInit();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['disabled'] && !changes['disabled'].isFirstChange() && isPlatformBrowser(this.platformId)) {
            if (changes['disabled'].currentValue !== changes['disabled'].previousValue) {
                if (changes['disabled'].currentValue === true) {
                    this.ngOnDestroy();
                }
                else if (changes['disabled'].currentValue === false) {
                    this.ngOnInit();
                }
            }
        }
    }
    /**
     * @return {?}
     */
    ps() {
        return this.instance;
    }
    /**
     * @return {?}
     */
    update() {
        if (typeof window !== 'undefined') {
            if (this.timeout) {
                window.clearTimeout(this.timeout);
            }
            this.timeout = window.setTimeout((/**
             * @return {?}
             */
            () => {
                if (!this.disabled && this.configDiff) {
                    try {
                        this.zone.runOutsideAngular((/**
                         * @return {?}
                         */
                        () => {
                            if (this.instance) {
                                this.instance.update();
                            }
                        }));
                    }
                    catch (error) {
                        // Update can be finished after destroy so catch errors
                    }
                }
            }), 0);
        }
    }
    /**
     * @param {?=} prefix
     * @return {?}
     */
    geometry(prefix = 'scroll') {
        return new Geometry(this.elementRef.nativeElement[prefix + 'Left'], this.elementRef.nativeElement[prefix + 'Top'], this.elementRef.nativeElement[prefix + 'Width'], this.elementRef.nativeElement[prefix + 'Height']);
    }
    /**
     * @param {?=} absolute
     * @return {?}
     */
    position(absolute = false) {
        if (!absolute && this.instance) {
            return new Position(this.instance.reach.x || 0, this.instance.reach.y || 0);
        }
        else {
            return new Position(this.elementRef.nativeElement.scrollLeft, this.elementRef.nativeElement.scrollTop);
        }
    }
    /**
     * @param {?=} direction
     * @return {?}
     */
    scrollable(direction = 'any') {
        /** @type {?} */
        const element = this.elementRef.nativeElement;
        if (direction === 'any') {
            return element.classList.contains('ps--active-x') ||
                element.classList.contains('ps--active-y');
        }
        else if (direction === 'both') {
            return element.classList.contains('ps--active-x') &&
                element.classList.contains('ps--active-y');
        }
        else {
            return element.classList.contains('ps--active-' + direction);
        }
    }
    /**
     * @param {?} x
     * @param {?=} y
     * @param {?=} speed
     * @return {?}
     */
    scrollTo(x, y, speed) {
        if (!this.disabled) {
            if (y == null && speed == null) {
                this.animateScrolling('scrollTop', x, speed);
            }
            else {
                if (x != null) {
                    this.animateScrolling('scrollLeft', x, speed);
                }
                if (y != null) {
                    this.animateScrolling('scrollTop', y, speed);
                }
            }
        }
    }
    /**
     * @param {?} x
     * @param {?=} speed
     * @return {?}
     */
    scrollToX(x, speed) {
        this.animateScrolling('scrollLeft', x, speed);
    }
    /**
     * @param {?} y
     * @param {?=} speed
     * @return {?}
     */
    scrollToY(y, speed) {
        this.animateScrolling('scrollTop', y, speed);
    }
    /**
     * @param {?=} offset
     * @param {?=} speed
     * @return {?}
     */
    scrollToTop(offset, speed) {
        this.animateScrolling('scrollTop', (offset || 0), speed);
    }
    /**
     * @param {?=} offset
     * @param {?=} speed
     * @return {?}
     */
    scrollToLeft(offset, speed) {
        this.animateScrolling('scrollLeft', (offset || 0), speed);
    }
    /**
     * @param {?=} offset
     * @param {?=} speed
     * @return {?}
     */
    scrollToRight(offset, speed) {
        /** @type {?} */
        const left = this.elementRef.nativeElement.scrollWidth -
            this.elementRef.nativeElement.clientWidth;
        this.animateScrolling('scrollLeft', left - (offset || 0), speed);
    }
    /**
     * @param {?=} offset
     * @param {?=} speed
     * @return {?}
     */
    scrollToBottom(offset, speed) {
        /** @type {?} */
        const top = this.elementRef.nativeElement.scrollHeight -
            this.elementRef.nativeElement.clientHeight;
        this.animateScrolling('scrollTop', top - (offset || 0), speed);
    }
    /**
     * @param {?} qs
     * @param {?=} offset
     * @param {?=} speed
     * @return {?}
     */
    scrollToElement(qs, offset, speed) {
        /** @type {?} */
        const element = this.elementRef.nativeElement.querySelector(qs);
        if (element) {
            /** @type {?} */
            const elementPos = element.getBoundingClientRect();
            /** @type {?} */
            const scrollerPos = this.elementRef.nativeElement.getBoundingClientRect();
            if (this.elementRef.nativeElement.classList.contains('ps--active-x')) {
                /** @type {?} */
                const currentPos = this.elementRef.nativeElement['scrollLeft'];
                /** @type {?} */
                const position = elementPos.left - scrollerPos.left + currentPos;
                this.animateScrolling('scrollLeft', position + (offset || 0), speed);
            }
            if (this.elementRef.nativeElement.classList.contains('ps--active-y')) {
                /** @type {?} */
                const currentPos = this.elementRef.nativeElement['scrollTop'];
                /** @type {?} */
                const position = elementPos.top - scrollerPos.top + currentPos;
                this.animateScrolling('scrollTop', position + (offset || 0), speed);
            }
        }
    }
    /**
     * @private
     * @param {?} target
     * @param {?} value
     * @param {?=} speed
     * @return {?}
     */
    animateScrolling(target, value, speed) {
        if (this.animation) {
            window.cancelAnimationFrame(this.animation);
            this.animation = null;
        }
        if (!speed || typeof window === 'undefined') {
            this.elementRef.nativeElement[target] = value;
        }
        else if (value !== this.elementRef.nativeElement[target]) {
            /** @type {?} */
            let newValue = 0;
            /** @type {?} */
            let scrollCount = 0;
            /** @type {?} */
            let oldTimestamp = performance.now();
            /** @type {?} */
            let oldValue = this.elementRef.nativeElement[target];
            /** @type {?} */
            const cosParameter = (oldValue - value) / 2;
            /** @type {?} */
            const step = (/**
             * @param {?} newTimestamp
             * @return {?}
             */
            (newTimestamp) => {
                scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));
                newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));
                // Only continue animation if scroll position has not changed
                if (this.elementRef.nativeElement[target] === oldValue) {
                    if (scrollCount >= Math.PI) {
                        this.animateScrolling(target, value, 0);
                    }
                    else {
                        this.elementRef.nativeElement[target] = newValue;
                        // On a zoomed out page the resulting offset may differ
                        oldValue = this.elementRef.nativeElement[target];
                        oldTimestamp = newTimestamp;
                        this.animation = window.requestAnimationFrame(step);
                    }
                }
            });
            window.requestAnimationFrame(step);
        }
    }
}
ScrollbarDirective.decorators = [
    { type: Directive, args: [{
                selector: '[scrollbar]',
                exportAs: 'ngxScrollbar'
            },] }
];
/** @nocollapse */
ScrollbarDirective.ctorParameters = () => [
    { type: NgZone },
    { type: KeyValueDiffers },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SCROLLBAR_CONFIG,] }] }
];
ScrollbarDirective.propDecorators = {
    disabled: [{ type: Input }],
    config: [{ type: Input, args: ['scrollbar',] }],
    psScrollY: [{ type: Output }],
    psScrollX: [{ type: Output }],
    psScrollUp: [{ type: Output }],
    psScrollDown: [{ type: Output }],
    psScrollLeft: [{ type: Output }],
    psScrollRight: [{ type: Output }],
    psYReachEnd: [{ type: Output }],
    psYReachStart: [{ type: Output }],
    psXReachEnd: [{ type: Output }],
    psXReachStart: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// styleUrls: [
//     './scrollbar.component.css'
// ],
class ScrollbarComponent {
    /**
     * @param {?} zone
     * @param {?} cdRef
     * @param {?} platformId
     */
    constructor(zone, cdRef, platformId) {
        this.zone = zone;
        this.cdRef = cdRef;
        this.platformId = platformId;
        this.states = {};
        this.indicatorX = false;
        this.indicatorY = false;
        this.interaction = false;
        this.scrollPositionX = 0;
        this.scrollPositionY = 0;
        this.scrollDirectionX = 0;
        this.scrollDirectionY = 0;
        this.usePropagationX = false;
        this.usePropagationY = false;
        this.allowPropagationX = false;
        this.allowPropagationY = false;
        this.stateTimeout = null;
        this.ngDestroy = new Subject();
        this.stateUpdate = new Subject();
        this.disabled = false;
        this.usePSClass = true;
        this.autoPropagation = false;
        this.scrollIndicators = false;
        this.psScrollY = new EventEmitter();
        this.psScrollX = new EventEmitter();
        this.psScrollUp = new EventEmitter();
        this.psScrollDown = new EventEmitter();
        this.psScrollLeft = new EventEmitter();
        this.psScrollRight = new EventEmitter();
        this.psYReachEnd = new EventEmitter();
        this.psYReachStart = new EventEmitter();
        this.psXReachEnd = new EventEmitter();
        this.psXReachStart = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (isPlatformBrowser(this.platformId)) {
            this.stateUpdate
                .pipe(takeUntil(this.ngDestroy))
                .pipe(distinctUntilChanged((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => (a === b && !this.stateTimeout))))
                .subscribe((/**
             * @param {?} state
             * @return {?}
             */
            (state) => {
                if (this.stateTimeout && typeof window !== 'undefined') {
                    window.clearTimeout(this.stateTimeout);
                    this.stateTimeout = null;
                }
                if (state === 'x' || state === 'y') {
                    this.interaction = false;
                    if (state === 'x') {
                        this.indicatorX = false;
                        this.states.left = false;
                        this.states.right = false;
                        if (this.autoPropagation && this.usePropagationX) {
                            this.allowPropagationX = false;
                        }
                    }
                    else if (state === 'y') {
                        this.indicatorY = false;
                        this.states.top = false;
                        this.states.bottom = false;
                        if (this.autoPropagation && this.usePropagationY) {
                            this.allowPropagationY = false;
                        }
                    }
                }
                else {
                    if (state === 'left' || state === 'right') {
                        this.states.left = false;
                        this.states.right = false;
                        this.states[state] = true;
                        if (this.autoPropagation && this.usePropagationX) {
                            this.indicatorX = true;
                        }
                    }
                    else if (state === 'top' || state === 'bottom') {
                        this.states.top = false;
                        this.states.bottom = false;
                        this.states[state] = true;
                        if (this.autoPropagation && this.usePropagationY) {
                            this.indicatorY = true;
                        }
                    }
                    if (this.autoPropagation && typeof window !== 'undefined') {
                        this.stateTimeout = window.setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            this.indicatorX = false;
                            this.indicatorY = false;
                            this.stateTimeout = null;
                            if (this.interaction && (this.states.left || this.states.right)) {
                                this.allowPropagationX = true;
                            }
                            if (this.interaction && (this.states.top || this.states.bottom)) {
                                this.allowPropagationY = true;
                            }
                            this.cdRef.markForCheck();
                        }), 500);
                    }
                }
                this.cdRef.markForCheck();
                this.cdRef.detectChanges();
            }));
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                if (this.directiveRef) {
                    /** @type {?} */
                    const element = this.directiveRef.elementRef.nativeElement;
                    fromEvent(element, 'wheel')
                        .pipe(takeUntil(this.ngDestroy))
                        .subscribe((/**
                     * @param {?} event
                     * @return {?}
                     */
                    (event) => {
                        if (!this.disabled && this.autoPropagation) {
                            /** @type {?} */
                            const scrollDeltaX = event.deltaX;
                            /** @type {?} */
                            const scrollDeltaY = event.deltaY;
                            this.checkPropagation(event, scrollDeltaX, scrollDeltaY);
                        }
                    }));
                    fromEvent(element, 'touchmove')
                        .pipe(takeUntil(this.ngDestroy))
                        .subscribe((/**
                     * @param {?} event
                     * @return {?}
                     */
                    (event) => {
                        if (!this.disabled && this.autoPropagation) {
                            /** @type {?} */
                            const scrollPositionX = event.touches[0].clientX;
                            /** @type {?} */
                            const scrollPositionY = event.touches[0].clientY;
                            /** @type {?} */
                            const scrollDeltaX = scrollPositionX - this.scrollPositionX;
                            /** @type {?} */
                            const scrollDeltaY = scrollPositionY - this.scrollPositionY;
                            this.checkPropagation(event, scrollDeltaX, scrollDeltaY);
                            this.scrollPositionX = scrollPositionX;
                            this.scrollPositionY = scrollPositionY;
                        }
                    }));
                    merge(fromEvent(element, 'ps-scroll-x')
                        .pipe(mapTo('x')), fromEvent(element, 'ps-scroll-y')
                        .pipe(mapTo('y')), fromEvent(element, 'ps-x-reach-end')
                        .pipe(mapTo('right')), fromEvent(element, 'ps-y-reach-end')
                        .pipe(mapTo('bottom')), fromEvent(element, 'ps-x-reach-start')
                        .pipe(mapTo('left')), fromEvent(element, 'ps-y-reach-start')
                        .pipe(mapTo('top')))
                        .pipe(takeUntil(this.ngDestroy))
                        .subscribe((/**
                     * @param {?} state
                     * @return {?}
                     */
                    (state) => {
                        if (!this.disabled && (this.autoPropagation || this.scrollIndicators)) {
                            this.stateUpdate.next(state);
                        }
                    }));
                }
            }));
            window.setTimeout((/**
             * @return {?}
             */
            () => {
                ScrollbarEvents.forEach((/**
                 * @param {?} eventName
                 * @return {?}
                 */
                (eventName) => {
                    if (this.directiveRef) {
                        this.directiveRef[eventName] = this[eventName];
                    }
                }));
            }), 0);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (isPlatformBrowser(this.platformId)) {
            this.ngDestroy.next();
            this.ngDestroy.unsubscribe();
            if (this.stateTimeout && typeof window !== 'undefined') {
                window.clearTimeout(this.stateTimeout);
            }
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (isPlatformBrowser(this.platformId)) {
            if (!this.disabled && this.autoPropagation && this.directiveRef) {
                /** @type {?} */
                const element = this.directiveRef.elementRef.nativeElement;
                this.usePropagationX = element.classList.contains('ps--active-x');
                this.usePropagationY = element.classList.contains('ps--active-y');
            }
        }
    }
    /**
     * @private
     * @param {?} event
     * @param {?} deltaX
     * @param {?} deltaY
     * @return {?}
     */
    checkPropagation(event, deltaX, deltaY) {
        this.interaction = true;
        /** @type {?} */
        const scrollDirectionX = (deltaX < 0) ? -1 : 1;
        /** @type {?} */
        const scrollDirectionY = (deltaY < 0) ? -1 : 1;
        if ((this.usePropagationX && this.usePropagationY) ||
            (this.usePropagationX && (!this.allowPropagationX ||
                (this.scrollDirectionX !== scrollDirectionX))) ||
            (this.usePropagationY && (!this.allowPropagationY ||
                (this.scrollDirectionY !== scrollDirectionY)))) {
            event.preventDefault();
            event.stopPropagation();
        }
        if (!!deltaX) {
            this.scrollDirectionX = scrollDirectionX;
        }
        if (!!deltaY) {
            this.scrollDirectionY = scrollDirectionY;
        }
        this.stateUpdate.next('interaction');
        this.cdRef.detectChanges();
    }
}
ScrollbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'scrollbar',
                exportAs: 'ngxScrollbar',
                template: "<div style=\"position: static;\" [class.ps]=\"usePSClass\" [scrollbar]=\"config\" [disabled]=\"disabled\">\r\n    <div class=\"ps-content\">\r\n      <ng-content></ng-content>\r\n    </div>\r\n  \r\n    <div *ngIf=\"scrollIndicators\" class=\"ps-overlay\" [class.ps-at-top]=\"states.top\" [class.ps-at-left]=\"states.left\" [class.ps-at-right]=\"states.right\" [class.ps-at-bottom]=\"states.bottom\">\r\n      <div class=\"ps-indicator-top\" [class.ps-indicator-show]=\"indicatorY && interaction\"></div>\r\n      <div class=\"ps-indicator-left\" [class.ps-indicator-show]=\"indicatorX && interaction\"></div>\r\n      <div class=\"ps-indicator-right\" [class.ps-indicator-show]=\"indicatorX && interaction\"></div>\r\n      <div class=\"ps-indicator-bottom\" [class.ps-indicator-show]=\"indicatorY && interaction\"></div>\r\n    </div>\r\n  </div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
ScrollbarComponent.ctorParameters = () => [
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
ScrollbarComponent.propDecorators = {
    disabled: [{ type: Input }],
    usePSClass: [{ type: Input }],
    autoPropagation: [{ type: HostBinding, args: ['class.ps-show-limits',] }, { type: Input }],
    scrollIndicators: [{ type: HostBinding, args: ['class.ps-show-active',] }, { type: Input }],
    config: [{ type: Input }],
    psScrollY: [{ type: Output }],
    psScrollX: [{ type: Output }],
    psScrollUp: [{ type: Output }],
    psScrollDown: [{ type: Output }],
    psScrollLeft: [{ type: Output }],
    psScrollRight: [{ type: Output }],
    psYReachEnd: [{ type: Output }],
    psYReachStart: [{ type: Output }],
    psXReachEnd: [{ type: Output }],
    psXReachStart: [{ type: Output }],
    directiveRef: [{ type: ViewChild, args: [ScrollbarDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollbarArrowsComponent {
    constructor() {
        this.reachX = 'start';
        this.reachY = 'start';
        this.scrollbarXActive = false;
        this.scrollbarYActive = false;
        this.hasXScrollbar = new EventEmitter();
        this.hasYScrollbar = new EventEmitter();
        this.scrollMoveTo = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.scrollbarYActive && !changes.scrollbarYActive.isFirstChange()) {
            this.hasYScrollbar.emit(this.scrollbarYActive);
        }
    }
    /**
     * @param {?} $event
     * @param {?} dir
     * @return {?}
     */
    scrollTo($event, dir) {
        $event.stopPropagation();
        this.scrollMoveTo.emit({ dir, event: $event });
    }
}
ScrollbarArrowsComponent.decorators = [
    { type: Component, args: [{
                selector: 'scrollbar-arrows',
                template: "<ng-container *ngIf=\"scrollbarXActive\">\r\n    <div class=\"scrollbar-arrow scrollbar-arrow-left\" (click)=\"scrollTo($event, 'left')\" [class.scrollbar-arrow-disable]=\"reachX === 'start'\">\r\n        <span class=\"f-icon f-icon-arrow-60-left\"></span>\r\n    </div>\r\n    <div class=\"scrollbar-arrow scrollbar-arrow-right\" [class.scrollbar-y]=\"scrollbarYActive\" (click)=\"scrollTo($event, 'right')\"  [class.scrollbar-arrow-disable]=\"reachX === 'end'\">\r\n        <span class=\"f-icon f-icon-arrow-60-right\"></span>\r\n    </div>\r\n</ng-container>\r\n\r\n\r\n\r\n<ng-container *ngIf=\"scrollbarYActive\">\r\n    <div class=\"scrollbar-arrow scrollbar-arrow-top\" (click)=\"scrollTo($event, 'top')\"  [class.scrollbar-arrow-disable]=\"reachY === 'start'\">\r\n        <span class=\"f-icon f-icon-arrow-60-up\"></span>\r\n    </div>\r\n    <div class=\"scrollbar-arrow scrollbar-arrow-bottom\" [class.scrollbar-x]=\"scrollbarXActive\" (click)=\"scrollTo($event, 'bottom')\"  [class.scrollbar-arrow-disable]=\"reachY === 'end'\">\r\n        <span class=\"f-icon f-icon-arrow-60-down\"></span>\r\n    </div>\r\n</ng-container>\r\n\r\n<div class=\"scrollbar-arrow-block\" *ngIf=\"scrollbarYActive && scrollbarXActive\"></div>\r\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".scrollbar-allways-show .ps.ps--active-x>.ps__rail-x{margin-right:0!important}.scrollbar-allways-show .ps.ps--active-y>.ps__rail-y{margin-bottom:0!important}.scrollbar-allways-show .ps.ps--active-x.ps--active-y>.ps__rail-x{margin-right:18px!important}.scrollbar-allways-show .ps.ps--active-x.ps--active-y>.ps__rail-y{margin-bottom:18px!important}.scrollbar-allways-show.scroolbar-arrows .ps.ps--active-x>.ps__rail-x{margin-right:18px!important;margin-left:18px!important}.scrollbar-allways-show.scroolbar-arrows .ps.ps--active-y>.ps__rail-y{margin-top:18px!important;margin-bottom:18px!important}.scrollbar-allways-show.scroolbar-arrows .ps.ps--active-x.ps--active-y>.ps__rail-x{margin-right:36px!important}.scrollbar-allways-show.scroolbar-arrows .ps.ps--active-x.ps--active-y>.ps__rail-y{margin-bottom:36px!important}.scroolbar-arrows .scrollbar-arrow{position:absolute;width:18px;height:18px;z-index:1000;background:#f5f6f9;color:#505050}.scroolbar-arrows .scrollbar-arrow:hover:not(.scrollbar-arrow-disable){background:#d2d8e9}.scroolbar-arrows .scrollbar-arrow:active:not(.scrollbar-arrow-disable){background:#b2b2b2;color:#fff}.scroolbar-arrows .scrollbar-arrow-left{bottom:0;border-top:1px solid #dee4ed}.scroolbar-arrows .scrollbar-arrow-right{right:0;bottom:0;border-top:1px solid #dee4ed}.scroolbar-arrows .scrollbar-arrow-bottom,.scroolbar-arrows .scrollbar-arrow-left,.scroolbar-arrows .scrollbar-arrow-right,.scroolbar-arrows .scrollbar-arrow-top{display:flex;align-items:center;justify-content:center}.scroolbar-arrows .scrollbar-arrow-left .f-icon,.scroolbar-arrows .scrollbar-arrow-right .f-icon{position:relative;top:-1px;font-size:12px}.scroolbar-arrows .scrollbar-arrow-bottom .f-icon,.scroolbar-arrows .scrollbar-arrow-top .f-icon{font-size:12px}.scroolbar-arrows .scrollbar-arrow-right.scrollbar-y{right:18px}.scroolbar-arrows .scrollbar-arrow-top{top:0;right:0;border-left:1px solid #dee4ed}.scroolbar-arrows .scrollbar-arrow-bottom{bottom:0;right:0;border-left:1px solid #dee4ed}.scroolbar-arrows .scrollbar-arrow-bottom.scrollbar-x{bottom:18px}.scroolbar-arrows .scrollbar-arrow-block{width:18px;height:18px;position:absolute;right:0;bottom:0;background:#fff;z-index:1000}.scroolbar-arrows .scrollbar-arrow-disable{color:#dadada}"]
            }] }
];
/** @nocollapse */
ScrollbarArrowsComponent.ctorParameters = () => [];
ScrollbarArrowsComponent.propDecorators = {
    reachX: [{ type: Input }],
    reachY: [{ type: Input }],
    scrollbarXActive: [{ type: Input }],
    scrollbarYActive: [{ type: Input }],
    hasXScrollbar: [{ type: Output }],
    hasYScrollbar: [{ type: Output }],
    scrollMoveTo: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScrollbarModule {
}
ScrollbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [
                    ScrollbarComponent, ScrollbarDirective,
                    ScrollbarArrowsComponent,
                ],
                exports: [
                    CommonModule, ScrollbarComponent, ScrollbarDirective,
                    ScrollbarArrowsComponent,
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridCellEditorDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
}
DatagridCellEditorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[grid-cell-editor]',
            },] }
];
/** @nocollapse */
DatagridCellEditorDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridColumnDirective {
    constructor() {
        this.halign = 'left';
        this.align = 'left';
        this.readonly = true;
        this.editable = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
}
DatagridColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: 'farris-grid-column',
            },] }
];
/** @nocollapse */
DatagridColumnDirective.ctorParameters = () => [];
DatagridColumnDirective.propDecorators = {
    field: [{ type: Input }],
    title: [{ type: Input }],
    width: [{ type: Input }],
    halign: [{ type: Input }],
    align: [{ type: Input }],
    formatter: [{ type: Input }],
    readonly: [{ type: Input }],
    editable: [{ type: Input }],
    editor: [{ type: ContentChild, args: [DatagridCellEditorDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SmartFilterToolbarComponent {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} inject
     */
    constructor(el, render, inject) {
        this.el = el;
        this.render = render;
        this.inject = inject;
        this.padding = '';
        this.height = 40;
        this.filterData = [];
        this.clearFilters = new EventEmitter();
        this.removeFilter = new EventEmitter();
        this.filterChange = new EventEmitter();
        this.resize = new EventEmitter();
        this.sk = '';
        this.destory$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dg = this.inject.get(DatagridComponent);
        this.sk = 'smartfilter_' + this.dg.dgs.createConfigKey(this.dg.id);
        this.dg.dgs.clearFilter.pipe(takeUntil(this.destory$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.clearFilters.emit(null);
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destory$.next();
        this.destory$.complete();
    }
    /**
     * 条件变化事件
     * @param {?} $event
     * @return {?}
     */
    onQuery($event) {
        const { data, filterItem } = $event;
        if (data && data.length) {
            /** @type {?} */
            const conditions = JSON.parse(data);
            if (conditions && conditions.length) {
                this.filterChange.emit({ conditions, filterItem });
            }
        }
    }
    /**
     * 清除所有条件
     * @param {?} $event
     * @return {?}
     */
    onResetFilter($event) {
        this.clearFilters.emit($event);
    }
    /**
     * 移除单个条件
     * @param {?} $event
     * @return {?}
     */
    onRemoveFilter($event) {
        this.removeFilter.emit($event);
    }
    /**
     * 展开折叠事件
     * @param {?} $event
     * @return {?}
     */
    onResize($event) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const smartFilterWrapper = this.el.nativeElement.querySelector('.f-filter-wrapper');
            if (smartFilterWrapper) {
                /** @type {?} */
                const h = smartFilterWrapper.offsetHeight;
                if (h) {
                    this.resize.emit(h + 6);
                }
            }
        }));
    }
}
SmartFilterToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'smart-filter-toolbar',
                template: "\r\n<div class=\"f-datagrid-filter-toolbar\" [style.height.px]=\"height\" \r\n[style.padding]=\"padding\" placeholder=\"\u6B64\u5904\u663E\u793A\u5217\u8FC7\u6EE4\u6761\u4EF6\" style=\"align-items: normal;\"\r\n[style.display]=\"filterData && filterData.length ? '' : 'none'\">\r\n<farris-filter [filterList]=\"filterData\" (query)=\"onQuery($event)\"  #farrisFilter\r\n    (resetChange)=\"onResetFilter($event)\" (clearFilter)=\"onRemoveFilter($event)\"\r\n    (filterResize)=\"onResize($event)\" (expandFilter)=\"onResize($event)\"\r\n    [localStorageKey]=\"sk\"\r\n>\r\n</farris-filter>\r\n\r\n</div>"
            }] }
];
/** @nocollapse */
SmartFilterToolbarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector }
];
SmartFilterToolbarComponent.propDecorators = {
    padding: [{ type: Input }],
    height: [{ type: Input }],
    filterData: [{ type: Input }],
    clearFilters: [{ type: Output }],
    removeFilter: [{ type: Output }],
    filterChange: [{ type: Output }],
    resize: [{ type: Output }],
    filtebar: [{ type: ViewChild, args: ['farrisFilter',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} col
 * @return {?}
 */
function TextFilterControl(col) {
    return {
        controltype: 'text'
    };
}
/**
 * @param {?} col
 * @return {?}
 */
function BooleanFilterControl(col) {
    return {
        controltype: 'bool-check',
    };
}
/**
 * @param {?} col
 * @param {?} enumopts
 * @return {?}
 */
function EnumFilterControl(col, enumopts) {
    /** @type {?} */
    const valueField = enumopts.valueField || enumopts.idField;
    /** @type {?} */
    const data = enumopts.data.map((/**
     * @param {?} n
     * @return {?}
     */
    n => {
        return {
            value: n[valueField],
            name: n[enumopts.textField]
        };
    }));
    return {
        controltype: 'checkboxgroup',
        enumValues: data,
    };
}
/**
 * @param {?} col
 * @param {?} options
 * @return {?}
 */
function DateFilterControl(col, options) {
    /** @type {?} */
    let tye = 'datetime';
    /** @type {?} */
    let fmt = 'yyyy-MM-dd';
    if (options && options.format) {
        fmt = options.format;
        if (fmt.indexOf('HH:') == -1) {
            tye = 'date';
        }
        else {
            if (fmt.indexOf('ss') > -1) ;
        }
    }
    else {
        tye = 'date';
    }
    // all = 1, 年月日
    // noDate = 2,  年月
    // noDateAndMonth = 3,  年
    return {
        controltype: 'flexibleDate',
        dateFormat: fmt,
        single: false,
        showType: 1,
        showTime: tye === 'datetime'
    };
}
/**
 * @param {?} col
 * @return {?}
 */
function NumberFilterControl(col) {
    return {
        controltype: 'flexibleNumber',
        single: false
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridSmartFilterService {
    constructor() {
        this.conditions = [];
        this.controlData = [];
        this.filterChanged = new Subject();
        this.removeFilter = new Subject();
        this.clearAllFilter = new Subject();
    }
    /**
     * @param {?} col
     * @return {?}
     */
    getColumnFilterData(col) {
        /** @type {?} */
        let filterControlData = {
            controltype: 'text',
        };
        if (col.filter !== undefined) {
            if (typeof col.filter === 'boolean') {
                if (col.formatter) {
                    if (typeof col.formatter === 'object' && Object.keys(col.formatter).length) {
                        /** @type {?} */
                        const options = col.formatter['options'];
                        switch (col.formatter['type']) {
                            case 'number':
                                return NumberFilterControl();
                            case 'enum':
                                return EnumFilterControl(col, options);
                            case 'boolean':
                                return BooleanFilterControl();
                            case 'datetime':
                                /** @type {?} */
                                let tye = 'datetime';
                                /** @type {?} */
                                let fmt = 'yyyy-MM-dd';
                                if (options && options.format) {
                                    fmt = options.format;
                                    if (fmt.indexOf('HH:') == -1) {
                                        tye = 'date';
                                    }
                                    else {
                                        if (fmt.indexOf('ss') > -1) ;
                                    }
                                }
                                else {
                                    tye = 'date';
                                }
                                filterControlData = {
                                    controltype: 'flexibleDate',
                                    dateFormat: fmt,
                                    single: false,
                                    showType: 3,
                                    showTime: tye === 'datetime'
                                };
                                break;
                            default:
                                return TextFilterControl();
                        }
                    }
                }
                return filterControlData;
            }
            else {
                switch (col.filter.type) {
                    case ColumnFilterType.enum:
                        return EnumFilterControl(col, col.filter.options);
                    case ColumnFilterType.date:
                    case ColumnFilterType.datetime:
                        return DateFilterControl(col, col.filter.options);
                    case ColumnFilterType.number:
                        return NumberFilterControl();
                    case ColumnFilterType.boolean:
                        return BooleanFilterControl();
                }
            }
        }
        return filterControlData;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    filterConditionChanged(e) {
        /** @type {?} */
        const items = e.conditions;
        if (!this.conditions || !this.conditions.length) {
            this.conditions.push(...items);
            this.controlData.push(Object.assign({}, e.controlData));
        }
        else {
            /// TODO, CONTROLDATA 的索引与conditions 的索引很可能不是1个
            if (e.from === 'toolbar') {
                this.conditions = [...items];
            }
            else {
                this.conditions = this.conditions.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.FilterField !== items[0].FilterField));
                if (items.length === 1) {
                    this.conditions.push(Object.assign({}, items[0]));
                }
                else {
                    this.conditions.push(...items);
                }
            }
            if (e.controlData) {
                /** @type {?} */
                const ctrlIdx = this.controlData.findIndex((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.labelCode === e.controlData.labelCode));
                if (ctrlIdx > -1) {
                    this.controlData[ctrlIdx] = Object.assign({}, e.controlData);
                }
                else {
                    this.controlData.push(Object.assign({}, e.controlData));
                }
            }
        }
        this.filterChanged.next({ conditions: [...this.conditions], controlData: [...this.controlData] });
    }
    /**
     * @param {?} e
     * @param {?=} emitRemove
     * @return {?}
     */
    removeCondition(e, emitRemove = false) {
        if (this.conditions && this.conditions.length) {
            this.conditions = this.conditions.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.FilterField !== e.labelCode));
            this.controlData = this.controlData.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.labelCode !== e.labelCode));
        }
        this.filterChanged.next({ conditions: [...this.conditions], controlData: [...this.controlData] });
        if (emitRemove) {
            this.removeFilter.next(e);
        }
    }
    /**
     * @return {?}
     */
    clearAll() {
        this.conditions = [];
        this.controlData = [];
        this.clearAllFilter.next(null);
    }
}
DatagridSmartFilterService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DatagridSmartFilterService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectionModeService {
    /**
     * @param {?} grid
     */
    constructor(grid) {
        this.dgRef = null;
        this.oldSettings = null;
        this.selectStartEvent = null;
        this.events = null;
        this.dgRef = grid;
        if (this.dgRef.selectionMode === 'default') {
            grid.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.removeEvents();
                this.events = this.registerStopSelectionEvent();
            }));
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        this.dgRef = null;
        this.removeEvents();
    }
    /**
     * @return {?}
     */
    removeEvents() {
        if (this.events && this.events.length) {
            this.events.forEach((/**
             * @param {?} e
             * @return {?}
             */
            e => {
                e();
            }));
            this.events = null;
        }
    }
    /**
     * @return {?}
     */
    toggleMode() {
        if (this.dgRef) {
            if (this.dgRef.selectionMode === 'default') {
                this.enableWindowsSelectionMode();
            }
            else {
                this.restoreSettings();
            }
        }
    }
    /**
     * @return {?}
     */
    enableWindowsSelectionMode() {
        if (this.dgRef) {
            this.oldSettings = {
                showCheckbox: this.dgRef.showCheckbox,
                keepSelect: this.dgRef.keepSelect,
                onlySelectSelf: this.dgRef.onlySelectSelf,
                selectOnCheck: this.dgRef.selectOnCheck,
                checkOnSelect: this.dgRef.checkOnSelect
            };
            this.dgRef.showCheckbox = true;
            this.dgRef.keepSelect = true;
            this.dgRef.onlySelectSelf = false;
            this.dgRef.selectOnCheck = true;
            this.dgRef.checkOnSelect = true;
            this.dgRef.dfs.updateProperty('keepSelect', true);
            this.dgRef.dfs.updateProperty('onlySelectSelf', false);
            this.dgRef.dfs.updateProperty('selectOnCheck', true);
            this.dgRef.dfs.updateProperty('checkOnSelect', true);
        }
    }
    /**
     * @return {?}
     */
    restoreSettings() {
        if (this.dgRef && this.oldSettings) {
            this.dgRef.showCheckbox = this.oldSettings.showCheckbox;
            this.dgRef.keepSelect = this.oldSettings.keepSelect;
            this.dgRef.onlySelectSelf = this.oldSettings.onlySelectSelf;
            this.dgRef.selectOnCheck = this.oldSettings.selectOnCheck;
            this.dgRef.checkOnSelect = this.oldSettings.checkOnSelect;
            this.dgRef.dfs.updateProperty('keepSelect', this.oldSettings.keepSelect);
            this.dgRef.dfs.updateProperty('onlySelectSelf', this.oldSettings.onlySelectSelf);
            this.dgRef.dfs.updateProperty('selectOnCheck', this.oldSettings.selectOnCheck);
            this.dgRef.dfs.updateProperty('checkOnSelect', this.oldSettings.checkOnSelect);
        }
    }
    /**
     * @private
     * @return {?}
     */
    registerStopSelectionEvent() {
        /** @type {?} */
        const kd = this.dgRef.render2.listen(document, 'keydown', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (event.ctrlKey || event.shiftKey) {
                this.unselectable();
            }
        }));
        /** @type {?} */
        const ku = this.dgRef.render2.listen(document, 'keyup', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (event.ctrlKey || event.shiftKey || event.keyCode === 17 || event.keyCode === 16) {
                this.enableSelectable();
            }
        }));
        return [kd, ku];
    }
    /**
     * @private
     * @return {?}
     */
    unselectable() {
        this.dgRef.render2.setAttribute(this.dgRef.dgContainer.nativeElement, 'unselectable', 'on');
        this.dgRef.render2.setAttribute(this.dgRef.dgContainer.nativeElement, 'onselectstart', 'return false');
        this.dgRef.render2.setStyle(this.dgRef.dgContainer.nativeElement, '-moz-user-select', 'none');
    }
    /**
     * @private
     * @return {?}
     */
    enableSelectable() {
        this.dgRef.render2.removeAttribute(this.dgRef.dgContainer.nativeElement, 'unselectable');
        this.dgRef.render2.removeAttribute(this.dgRef.dgContainer.nativeElement, 'onselectstart');
        this.dgRef.render2.removeStyle(this.dgRef.dgContainer.nativeElement, '-moz-user-select');
    }
    /**
     * @param {?} param
     * @return {?}
     */
    beforRowClick(param) {
        if (this.dgRef && this.dgRef.selectionMode === 'default') {
            /** @type {?} */
            const isSelected = this.dgRef.dfs.isRowSelected(param.id);
            /** @type {?} */
            const isCtrlKey = param.e.ctrlKey;
            /** @type {?} */
            const isShiftKey = param.e.shiftKey;
            this.dgRef.endEditing();
            if (!isCtrlKey && !isShiftKey) {
                if (!isSelected) {
                    this.dgRef.clearCheckeds();
                }
                else {
                    // 如果有多条选，移除其他选中行
                    /** @type {?} */
                    const currentPagerIds = this.dgRef.getRows().map((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n.id));
                    /** @type {?} */
                    const unCheckIDs = this.dgRef.checkValues.filter((/**
                     * @param {?} i
                     * @return {?}
                     */
                    i => currentPagerIds.includes(i) && i != param.id));
                    /** @type {?} */
                    const unSelectIds = this.dgRef.checkValues.filter((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => !currentPagerIds.includes(n)));
                    // const unCheckIDs = this.dgRef.checkValues.filter(n => n != param.id);
                    if (unCheckIDs && unCheckIDs.length) {
                        this.dgRef.unCheckRows(unCheckIDs, true);
                        this.dgRef.clearSelections([param.id, ...unSelectIds]);
                    }
                }
            }
            else {
                if (isShiftKey) {
                    /** @type {?} */
                    let focusIndex = this.dgRef.focusRowIndex;
                    if (focusIndex === -1) {
                        focusIndex = 0;
                    }
                    /** @type {?} */
                    const endIndex = param.rowIndex;
                    /** @type {?} */
                    let start = focusIndex;
                    /** @type {?} */
                    let end = endIndex;
                    if (focusIndex > endIndex) {
                        start = endIndex;
                        end = focusIndex;
                    }
                    /** @type {?} */
                    const data = this.dgRef.getRows();
                    /** @type {?} */
                    const checkedItems = [...data].splice(start, end - start + 1);
                    /** @type {?} */
                    const willCheckIds = checkedItems.map((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => {
                        return this.dgRef.dfs.primaryId(n);
                    }));
                    if (!isCtrlKey) {
                        this.dgRef.clearCheckeds(false, false);
                    }
                    // this.dgRef.selectValues = willCheckIds;
                    this.dgRef.checkRows(willCheckIds, true);
                    return true;
                }
            }
            if (isSelected && isCtrlKey) {
                param.e.stopPropagation();
                // 执行取消选择
                this.dgRef.unCheckRow(param.id);
                return true;
            }
            /** @type {?} */
            const zoneClick = param.cellref ? param.cellref['zoneClick'] : '';
            /** @type {?} */
            const _timer = zoneClick && zoneClick.length ? 100 : 0;
            /** @type {?} */
            let r$ = of(true);
            if (this.dgRef.beforeSelect) {
                /** @type {?} */
                const r = this.dgRef.beforeSelect(param);
                if (r && r.subscribe) {
                    r$ = r;
                }
            }
            r$.pipe(delay(_timer)).subscribe((/**
             * @param {?} canSelect
             * @return {?}
             */
            (canSelect) => {
                if (canSelect) {
                    this.dgRef.dfs.selectRow(param.rowIndex, param.rowData);
                    if (this.dgRef.selectedRow) {
                        this.dgRef.selectedRow.dr = param.dr;
                    }
                }
                this.dgRef.rowClick.emit({ data: param.rowData, grid: this.dgRef, dblclick: false });
                this.dgRef.dgs.setSelecedRow.emit({ selected: true, id: this.dgRef.dfs.primaryId(param.rowData) });
                if (_timer) {
                    if (param.cellref && param.cellref.runZoneClick) {
                        param.cellref.runZoneClick(param.e);
                    }
                }
            }));
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    endRowClick() {
        if (this.dgRef && this.dgRef.selectionMode === 'default') {
            this.dgRef.checkOnSelect = false;
        }
    }
}
SelectionModeService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SelectionModeService.ctorParameters = () => [
    { type: DatagridComponent }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridComponent {
    /**
     * @param {?} cd
     * @param {?} el
     * @param {?} inject
     * @param {?} zone
     * @param {?} dfs
     * @param {?} dgs
     * @param {?} app
     * @param {?} domSanitizer
     * @param {?} render2
     */
    constructor(cd, el, inject, zone, dfs, dgs, app, domSanitizer, render2) {
        this.cd = cd;
        this.el = el;
        this.inject = inject;
        this.zone = zone;
        this.dfs = dfs;
        this.dgs = dgs;
        this.app = app;
        this.domSanitizer = domSanitizer;
        this.render2 = render2;
        this.auther = `Lucas Huang - QQ:1055818239`;
        this.version = '0.8.x';
        this.__component_type__ = 'DatagridComponent';
        /**
         * 启用性能优化版，默认为 false
         */
        this.fast = false;
        this.pos = 'relative';
        this.hostCls = false;
        /**
         * 使用主题
         */
        this.useThemes = true;
        // 用于存储用户个性化设置
        this.id = '';
        /**
         * 自动高度 - 启用此属性后，就是一个普普通通的 table , 不能编辑，不能排序，不能分页，不能... 就是一凡胎
         */
        this.useHtmlTable = false;
        /**
         * 自动高度
         */
        this.autoHeight = false;
        /**
         * 配合 autoHeight 一起使用，当此值大于0 时，且autoHeight 为true时，数据总行高达到最大高度时，将停止自动高度并使用内部滚动条
         */
        this.maxHeight = 0;
        /**
         * 显示边框
         */
        this.showBorder = false;
        /**
         * 启用斑马线
         */
        this.striped = true;
        /**
         * 宽度
         */
        this.width = 800;
        /**
         * 高度
         */
        this.height = 300;
        /**
         * 显示表头
         */
        this.showHeader = true;
        /**
         * 表头-单行高度
         */
        this.headerHeight = 35;
        /**
         * 表头折行
         */
        this.headerWrap = false;
        /**
         * 显示页脚
         */
        this.showFooter = false;
        /**
         * 页脚默认行高
         */
        this.footerHeight = 29;
        /**
         * 页脚数据来源, 默认为 client
         */
        this.footerDataFrom = 'client';
        /**
         * 合计行显示位置，默认为底部
         */
        this.footerPosition = 'bottom';
        /**
         * 行高
         */
        this.rowHeight = 29;
        /**
         * 设置grid 行高尺寸
         * sm: 小，md: 正常， lg: 大，xl: 超大
         */
        this._sizeType = 'sm';
        /**
         * 填充容器
         */
        this._fit = false;
        /**
         * 如果为真，则自动展开/收缩列的大小以适合网格宽度并防止水平滚动。
         */
        this._fitColumns = false;
        /**
         * 根据grid的宽度自动调整列宽度
         */
        this._autoFitColumns = false;
        /**
         * 禁用
         */
        this.disabled = false;
        /**
         * 滚动条显示模式，默认为 auto
         */
        this.scrollBarShowMode = 'auto';
        this.scrollBarOptions = {
            width: 18,
            height: 18
        };
        /**
         * 当滚动一直显示时，是否显示两端的箭头
         */
        this.showScrollArrow = false;
        /**
         * 可拖动列设置列宽
         */
        this.resizeColumn = true;
        /**
         * 显示行号
         */
        this.showLineNumber = false;
        /**
         * 行号表头字符
         */
        this.lineNumberTitle = '';
        /**
         * 行号宽度
         */
        this.lineNumberWidth = 36;
        /**
         * 复选框列宽度，默认 36px
         */
        this.checkboxColumnWidth = 36;
        /**
         * 鼠标滑过效果开关，默认开启
         */
        this.rowHover = true;
        /**
         * 允许编辑时，单击进入编辑状态; false为双击进入编辑
         */
        this.clickToEdit = true;
        this._lockPagination = false;
        /**
         * 分页信息
         */
        this.__pagination = true;
        /**
         * 分页组件自定义内容区模板
         */
        this.pagerContentTemplate = null;
        /**
         * 分页条对齐展示方式， left, right, center   默认为 right
         */
        this.pagerPos = 'right';
        /**
         * 分页条显示模式， default, simple
         */
        this.pagerViewMode = 'default';
        /**
         * 启用服务器端分页
         */
        this.pagerOnServer = true;
        /**
         * 每页记录数
         */
        this.pageList = [10, 20, 30, 50, 100];
        /**
         * 当前页码
         */
        this.pageIndex = 1;
        /**
         * 每页记录数
         */
        this.pageSize = 20;
        /**
         * 分页区高度
         */
        this.pagerHeight = 56;
        /**
         * 显示每页记录数
         */
        this.showPageList = false;
        /**
         * 显示分页信息
         */
        this.showPageInfo = true;
        /**
         * 显示页码
         */
        this.showPageNumber = true;
        /**
         * 显示页码最大数量
         */
        this.pagerLabelSize = 7;
        /**
         * 显示转至指定页码输入框
         */
        this.showGotoInput = false;
        /**
         * 启用跨页多选
         */
        this.enableMorePageSelect = false;
        /**
         * 显示选中列表
         */
        this.showSelectedList = false;
        /**
         * 单元格信息提示延时，默认 1000ms
         */
        this.cellTipTimer = 1000;
        /**
         * grid 内部处理分页状态
         */
        this.controlPaginationState = true;
        /**
         * 总记录数
         */
        this._total = 0;
        /**
         * 启用选中行
         */
        this.enableSelectRow = true;
        /**
         * 启用多选
         */
        this.multiSelect = false;
        /**
         * 启用多选时，是否显示checkbox
         */
        this.showCheckbox = false;
        /**
         * 显示全选checkbox
         */
        this.showAllCheckbox = false;
        /**
         * 当启用多选时，点击行选中，只允许且只有一行被选中。, 默认为 true
         */
        this.onlySelectSelf = true;
        /**
         * 启用多选且显示checkbox, 选中行同时钩选, 默认为 false
         */
        this.checkOnSelect = false;
        /**
         * 启用多选且显示checkbox, 钩选后选中行, 默认为 false
         */
        this.selectOnCheck = false;
        /**
         * 行选中模式，custom: 自定义， default: 仿Windows资源管理器选中
         * 注意： 此属性仅多选，显示复选框有效
         * 默认值： custom
         * addTime: 2021-12-14 by LUCAS HUANG
         */
        this.selectionMode = 'custom';
        /**
         * 单击行选中后，在次点击不会被取消选中状态;
         */
        this.keepSelect = true;
        /**
         * 当数据为空时，使用空白显示，且高度为一行的高度。 默认为 false
         */
        this.useBlankWhenDataIsEmpty = false;
        /**
         * 数据为空时的高度
         */
        this.emptyDataHeight = 240;
        /**
         * 空数据时，显示的提示文本
         */
        this.emptyMessage = '暂无数据';
        /**
         * 无数据时的模板
         */
        this.emptyTemplate = null;
        this.emptyComponentType = null;
        /**
         * 主键字段
         */
        this.idField = 'id';
        /**
         * 页脚数据
         */
        this._footerData = of([]);
        /**
         * 验证不通过时可以结束编辑
         */
        this.endEditByInvalid = true;
        /**
         * 列集合
         */
        this._columns = [];
        this._fields = [];
        /**
         * 禁止数据折行，默认值：true,即在一行显示，不折行。
         */
        this.nowrap = true;
        /**
         * 虚拟加载
         */
        this.virtualized = false;
        /**
         * 是否启用异步加载数据
         */
        this.virtualizedAsyncLoad = false;
        /**
         * 编辑方式： row(整行编辑)、cell(单元格编辑)；默认为 row
         */
        this.editMode = 'row';
        /**
         * 编辑状态
         */
        this._editable = false;
        /**
         * 启用可编辑单元格样式。
         */
        this.enableEditCellStyle = false;
        /**
         * 进入编辑状态时选是否选中文本；默认为 false
         * 仅文本框支持此特性
         */
        this.selectOnEditing = false;
        /**
         * 编辑器高度
         */
        this.editorHeight = 30;
        /**
         * 启用远端排序
         */
        this.remoteSort = false;
        this.hoverRowCls = 'f-datagrid-row-hover';
        /**
         * 允许拖拽列顺序
         */
        this.enableDragColumn = false;
        /**
         * 行分组面板高度，默认 50PX
         */
        this.rowGroupPanelHeight = 50;
        /**
         * 启用分组行
         */
        this.groupRows = false;
        /**
         * 启用行分组合计行
         */
        this.groupFooter = false;
        /**
         * 分组行是否展开，默认为 展开
         */
        this.expandGroupRows = true;
        /**
         * 合计数据显示位置
         * inGroupRow: 与分组在同一行，分别相关合计字段对齐
         * groupFooterRow: 在分组数据最后增加一行
         * 默认为 groupFooterRow
         */
        this.groupSummaryPosition = 'groupFooterRow';
        /**
         * 分组信息合并列数
         * 默认为 1
         */
        this.groupCellColSpan = 1;
        /**
         * 分组字段名称, 多字段分组以英文逗号分隔
         */
        this._groupField = '';
        this.groupFields$ = new BehaviorSubject([]);
        /**
         * 显示分组列
         */
        this.showGroupColumn = true;
        /**
         * 显示分组列面板。默认为 false
         */
        this._showRowGroupPanel = false;
        /**
         * 双击表头适应内容宽度
         */
        this.AutoColumnWidthUseDblclick = true;
        /**
         * 使用内部过滤器; 默认为 false
         */
        this.useDefaultFilter = false;
        /**
         * 过滤图标与排序图标合并，此属性与 enableFilterRow 互斥
         */
        this.enableSmartFilter = false;
        /**
         * 显示过滤行
         */
        this.enableFilterRow = false;
        /**
         * 服务器端过滤
         */
        this.remoteFilter = false;
        /**
         * 启用过滤条件显示条
         */
        this.showFilterBar = false;
        /**
         * 过滤条件汇总条高度，默认 32px
         */
        this.filterBarHeight = 32;
        this.filterRowHeight = 40;
        this.conditions = {};
        this.selectValue = null;
        this.checkValues = [];
        this.selectValues = [];
        /**
         * 合并单元格；先支持纵向合并
         */
        this.mergeCell = false;
        this.mergeFields = [];
        /**
         * 合并单元格数据启用客户端排序
         */
        this.enableClientSortForMergeCell = false;
        /**
         * 使用高级控制面板(列设置)
         */
        this.useControlPanel = false;
        /**
         * 启用简洁控制面板模式。默认为 false
         */
        this.enableSimpleMode = false;
        /**
         * 点击列设置图标，默认打开的控制面板
         */
        this.controlPanelMode = 'advanced';
        /**
         * 启用列设置方案
         */
        this.enableScheme = false;
        /**
         * 系统预制方案名称
         */
        this.defaultSchemeName = '系统预制';
        /**
         * 多表头启用列设置; 默认 false
         */
        this.enableSetMultiHeaders = false;
        /**
         * 允许运行时列设置中可设置的最大表头数（包含数据列）；默认为 3层
         */
        this.maxMultiHeaders = 3;
        /**
         * 列设置方案变化后，弹出方案变更提示，默认为false,修改保存到当前方案中
         */
        this.showConfirmWhenSchemeChanged = false;
        /**
         * 阻止click 事件冒泡
         */
        this.stopPropagation = true;
        /**
         * (202105 弃用)
         * 点击单元格进行编辑状态时，关闭其他Grid的编辑器。默认 false，
         * 多个列表存时，仅有一个列表中有编辑状态，其他列表结束编辑
         */
        this.closeOtherGridEditor = false;
        /**
         * 当数据源为空时，清空已选记录, 默认 true
         */
        this.clearSelectionsWhenDataIsEmpty = true;
        /**
         * 启用右键菜单，默认为 false
         */
        this.enableContextMenu = false;
        /**
         * 右键菜单数据
         */
        this.contextMenus = null;
        this.selectValueChange = new EventEmitter();
        this.checkValuesChange = new EventEmitter();
        this.selectValuesChange = new EventEmitter();
        this.beginEdit = new EventEmitter();
        this.endEdit = new EventEmitter();
        this.cancelEdited = new EventEmitter();
        this.scrollY = new EventEmitter();
        this.pageSizeChanged = new EventEmitter();
        this.pageChanged = new EventEmitter();
        this.loadSuccess = new EventEmitter();
        this.emptyData = new EventEmitter();
        this.filterChanged = new EventEmitter();
        /**
         * 启用选中单元格高亮显示
         */
        this.enableHighlightCell = false;
        /**
         * 选中的数据始终从数据源中获取. 默认为 false
         */
        this.checkedRowsDataFromSource = false;
        /**
         * 当前单元格为只读时，使用tab 键跳到下个单元格时，是否允许进入编辑状态，默认为 false;
         * 默认情况下，当前单元格只读，按TAB跳到下个CELL 时，选中CELL ，回车进入编辑。
         * 开启后，下个单元格自动进入编辑状态。
         */
        this.editcellWhenTabKeydwon = false;
        /**
         * 单元格点击前事件
         */
        this.beforeClickCell = new EventEmitter();
        this.dblclickRow = new EventEmitter();
        this.selectChanged = new EventEmitter();
        this.unSelect = new EventEmitter();
        this.selectAll = new EventEmitter();
        this.unSelectAll = new EventEmitter();
        /**
         * 异步请求虚拟加载
         */
        this.scrollYLoad = new EventEmitter();
        this.checked = new EventEmitter();
        this.unChecked = new EventEmitter();
        this.checkAll = new EventEmitter();
        this.unCheckAll = new EventEmitter();
        this.checkedChange = new EventEmitter();
        this.columnSorted = new EventEmitter();
        this.rowClick = new EventEmitter();
        this.rowAppended = new EventEmitter();
        this.rowDeleted = new EventEmitter();
        this.rowUpdated = new EventEmitter();
        this.dataChange = new EventEmitter();
        /**
         * 最后一行的最后单元格回车处理事件
         */
        this.lastCellEnterHandler = new EventEmitter();
        /**
         * 分组字段变化后
         */
        this.groupFieldChange = new EventEmitter();
        /**
         * 拖动列改变列显示位置后触发
         */
        this.columnMoved = new EventEmitter();
        /**
         * 单元格点击事件
         */
        this.cellClick = new EventEmitter();
        this.resized = new EventEmitter();
        this._loading = false;
        this._selectedRow = null;
        this.ds = {
            index: 0,
            rows: [],
            top: 0,
            bottom: 0,
            scrolling: false // 是否由滚动条触发
        };
        this.pagerOpts = {};
        this.editors = {};
        this.validators = [];
        this.footerWidth = 0;
        this.clickDelay = 150;
        this.resizeColumnInfo = {
            proxyLineEdge: 0,
            startWidth: 0,
            startX: 0,
            left: 0
        };
        this.ro = null;
        this.subscriptions = [];
        this.realHeaderHeight = 0;
        // 弹窗中使用时，窗口点击事件处理
        this.modalClickEvent = null;
        this.pending = false;
        this.scrollInstance = null;
        // 合并单元辅助信息
        this.mergeCellInfo = {};
        this.ignoreTarget = ['INPUT', 'SELECT', 'TEXTAREA'];
        this.clientFilterService = null;
        // DatagridSettingsService;
        /**
         * 控制列字段名称: _datagrid-setting-control_
         *
         */
        this.ControlPanelFeild = '_datagrid-setting-control_';
        this._isResized = false;
        this.gridSize = { width: this.width + 'px', height: this.height + 'px' };
        // 客户端过滤时，是否过滤行发生变化
        this.clientFilterChanged = false;
        // style's ID
        this.styleSheetId = '';
        this.groupRowPanelPlaceholder = '';
        this.commonUtils = null;
        this.smartFilterService = null;
        this.smartFilterResult = { controlData: [], conditions: [] };
        this.smartFilterBarHeight = 32;
        this._active_datagrid_cls = 'datagrid-active';
        this._blured_datagrid_cls = 'datagrid-blurred';
        // 自定义grid样式，列表初始后，会添加一个自定义名称的样式
        this._custom_datagrid_cls = 'datagrid';
        // 焦点行索引，每次行点击后更新
        this.focusRowIndex = -1;
        this.documentBodyMouseDown = null;
        this.farrisInstances = null;
        this.currentPagerData = [];
        this.resizeTimer = null;
        this.debugSer = null;
        this.DATA_CHANGED_TIMER = null;
        /**
         * 当bodyclick 时，是否退出行编辑状态，默认为 false
         */
        this.exitRowEditingWhenBodyClick = false;
        this.formValidations = null;
        this.isFF = false;
        this._footerRowHeight = this.footerHeight;
        this.trackByRows = (/**
         * @param {?} index
         * @param {?} row
         * @return {?}
         */
        (index, row) => {
            if (row) {
                return row[this.idField] || index;
            }
            return index;
        });
        this.onDocumentMouseDown = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const dgrid = event.target.closest('.f-datagrid');
            if (this.pending) {
                return false;
            }
            if (!dgrid) {
                this.activeDataGrid(false);
            }
            else {
                if (dgrid.id === this.id) {
                    if (this.isEditing() && (this.exitRowEditingWhenBodyClick || this.editMode == 'cell')) {
                        this.endEditing();
                    }
                    return;
                }
            }
            if (Utils.hasDialogOpen()) {
                /** @type {?} */
                const indlg = this.inDialog();
                /** @type {?} */
                const currentTargetInDialog = event.target.closest('.modal-body');
                if (indlg && currentTargetInDialog) {
                    if (indlg != currentTargetInDialog) {
                        return;
                    }
                }
                else {
                    return;
                }
            }
            if (this.currentCell) {
                if (!this.currentCell.cellElement) {
                    return;
                }
                if (this.currentCell.isEditing) {
                    /** @type {?} */
                    const zoneClick = event.target['__zone_symbol__clickfalse'];
                    /** @type {?} */
                    const isBeBtn = event.target.closest('.bedesigner-toolbar');
                    /** @type {?} */
                    const isOldBeBtn = event.target.className.indexOf('beEleGridButton') > -1;
                    /** @type {?} */
                    const disableClickEvent = zoneClick && zoneClick.length && (event.target.closest('.f-section-in-mainsubcard') || isOldBeBtn || isBeBtn || event.target.closest('.datagrid-toolbars'));
                    if (disableClickEvent && !dgrid) {
                        event.target.style.pointerEvents = 'none';
                        event.stopPropagation();
                    }
                    /** @type {?} */
                    const _timer = disableClickEvent ? ((isBeBtn || isOldBeBtn) ? 50 : 200) : 0;
                    /** @type {?} */
                    const stopEditingRowIndex = this.currentCell.rowIndex;
                    this.currentCell.cellElement.closeEdit().pipe(debounceTime(_timer)).subscribe((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => {
                        if (this.currentCell && stopEditingRowIndex !== this.currentCell.rowIndex) {
                            return;
                        }
                        if (f) {
                            if (this.currentCell && this.currentCell.cellElement) {
                                DomHandler.removeClass(this.currentCell.cellElement, CELL_SELECTED_CLS);
                                DomHandler.removeClass(this.currentCell.cellElement, CELL_EDITING_CLS);
                            }
                            this.dfs.cancelSelectCell();
                            this.unbindDocumentEditListener();
                            this.currentCell = null;
                            if (disableClickEvent) {
                                zoneClick.forEach((/**
                                 * @param {?} n
                                 * @return {?}
                                 */
                                n => {
                                    n.callback(event);
                                }));
                                event.target.style.pointerEvents = 'auto';
                                if (isBeBtn || isOldBeBtn) {
                                    this.app.tick();
                                }
                            }
                        }
                    }));
                }
            }
            else {
                if (this.isEditing()) {
                    if (this.editMode == 'cell' || this.exitRowEditingWhenBodyClick) {
                        this.endEditing();
                    }
                }
            }
        });
        this.styleSheetId = 'DATAGRID-' + Utils.uuid();
        this.localeService = this.inject.get(LocaleService);
        this.restService = this.inject.get(DATAGRID_REST_SERVICEE, null);
        this.colFormatSer = this.inject.get(ColumnFormatService);
        this.commonUtils = this.inject.get(CommonUtils, null);
        this.clientFilterService = new DatagridFilterService(dfs, this.localeService, inject);
        this.farrisInstances = this.inject.get(FarrisComponentInstanceService, null);
        this.debugSer = this.inject.get(DebugService, null);
        /** @type {?} */
        let perfixStr = '';
        if (WEBAPI_PREFIX_TOKEN) {
            perfixStr = this.inject.get(WEBAPI_PREFIX_TOKEN, '');
        }
        if (!this.debugSer) {
            this.debugSer = new DebugService();
        }
        if (this.debugSer.useDebugMode) {
            this.debugSer.useDebugMode();
        }
        this.smartFilterService = this.inject.get(DatagridSmartFilterService, null);
        this.idService = this.inject.get(IdService, null);
        this.dfs.localId = this.localeService.localeId;
        this.settingService = this.inject.get(GRID_SETTINGS_SERVICE, null);
        if (this.settingService) {
            this.settingService.setUriPerfixStr(perfixStr);
            /** @type {?} */
            const settingsHttp = this.inject.get(GRID_SETTINGS_HTTP, null);
            this.settingService.httpRestService = settingsHttp;
        }
        // ilink 367849
        /** @type {?} */
        const dataSubscription = this.dfs.data$.pipe(switchMap((/**
         * @param {?} ds
         * @return {?}
         */
        (ds) => {
            if (this.beforeLoad) {
                return this.beforeLoad({ data: ds.rows, instance: this }).pipe(map((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    if (e && e.data) {
                        ds.rows = e.data;
                    }
                    return ds;
                })));
            }
            return of(ds);
        }))).subscribe((/**
         * @param {?} dataSource
         * @return {?}
         */
        (dataSource) => {
            this.cleanDom();
            /** @type {?} */
            const ds = Object.assign({}, dataSource);
            if (this.conditions && Object.keys(this.conditions).length && !this.remoteFilter && this.useDefaultFilter) {
                ds.rows = this.clientFilterService.executeFilter(ds.rows, this.conditions);
            }
            this.ds = ds;
            if (this.ds.rows && this.ds.rows.length) {
                this.data = this.dfs.getData();
                if (this.mergeCell && this.mergeFields && this.mergeFields.length) {
                    this.mergeCellInfo = this.dgs.getMergeCellInfo3(this.ds.rows, [...this.mergeFields]);
                }
                this.setPagerTotal();
                this.loadSuccess.emit(this.ds.rows);
            }
            else {
                this.data = [];
                this.currentCell = null;
                if (this.clearSelectionsWhenDataIsEmpty) {
                    this.clearAll();
                }
                this.emptyData.emit();
            }
            if (!this.ds.scrolling) {
                this.updateFooterData();
            }
            // 性能优化
            this.cd.detectChanges();
            if (this.DATA_CHANGED_TIMER) {
                clearTimeout(this.DATA_CHANGED_TIMER);
            }
            this.DATA_CHANGED_TIMER = setTimeout((/**
             * @return {?}
             */
            () => {
                if (this.autoHeight && this.maxHeight) {
                    if (this.maxHeight < 55) {
                        this.maxHeight = 60;
                    }
                    /** @type {?} */
                    const gridContainerEl = this.el.nativeElement.parentElement;
                    if (gridContainerEl.nodeName !== 'DIV') {
                        this.writeConsole('Datagrid父容器必须为DIV。');
                    }
                }
                if (this.useBlankWhenDataIsEmpty) {
                    this.calculateGridSize(this.fit);
                }
                this.dgs.dataloaded.emit();
                // TFS 577078
                this.updateAllCheckboxStatus();
                // if (!this.nowrap && this.data && this.data.length) {
                //     this.setRowHeight(false);
                //     this.dgs.cellContentWrapChanged.emit();
                // }
            }), 100);
        }));
        this.subscriptions.push(dataSubscription);
        /** @type {?} */
        const columnGroupSubscription = this.dfs.columnGroup$.pipe(debounceTime(60)).subscribe((/**
         * @param {?} cg
         * @return {?}
         */
        cg => {
            if (cg) {
                this.colGroup = cg;
                this.footerWidth = cg.totalWidth;
                this.cd.detectChanges();
            }
        }));
        this.subscriptions.push(columnGroupSubscription);
        this.subscriptions.push(this.dfs.gridSize$.subscribe((/**
         * @param {?} cg
         * @return {?}
         */
        (cg) => {
            if (cg && cg.columnsGroup) {
                this.colGroup = cg.columnsGroup;
                if (!this.nowrap) {
                    this.setFooterHeight();
                }
                this.cd.detectChanges();
            }
        })));
        this.initEditorAndValidator();
        /** @type {?} */
        const currentCellSubscription = this.dfs.currentCell$.subscribe((/**
         * @param {?} cell
         * @return {?}
         */
        (cell) => {
            this.currentCell = cell;
            if (cell && cell.cellRef) {
                cell.cellRef.isEditing = cell.isEditing;
            }
            this.unbindMoveSelectRowEvent();
            this.bindDocumentEditListener();
        }));
        this.dfs.selectRow$.subscribe((/**
         * @param {?} sr
         * @return {?}
         */
        (sr) => {
            if (!this.currentCell) {
                this.bindDocumentMoveSelectRowEvent();
            }
            this.selectedRow = sr;
        }));
        this.subscriptions.push(currentCellSubscription);
        DatagridColumnsHelper.gridInstance = this;
        /** @type {?} */
        const filterChangedSubscription = this.dgs.onFilterChanged.pipe(debounceTime(200)).subscribe((/**
         * @param {?} conditions
         * @return {?}
         */
        (conditions) => {
            // 更新缓存过滤条件
            this.conditions = conditions;
            this.clientFilterChanged = true;
            this.filterData(this.conditions);
        }));
        this.subscriptions.push(filterChangedSubscription);
        // this.initPaginationOptions();
        /** @type {?} */
        const footerDataSubscription = this.dgs.refreshFooterData.subscribe((/**
         * @return {?}
         */
        () => {
            this.updateFooterData();
            // this.cd.detectChanges();
        }));
        this.subscriptions.push(footerDataSubscription);
        this.dgs.commonUtils = this.commonUtils;
        this.dgs.focusRowChanged.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e) {
                this.focusRowIndex = e.rowIndex;
            }
        }));
    }
    /**
     * @return {?}
     */
    get autoHeightCls() {
        return this.autoHeight;
    }
    /**
     * @return {?}
     */
    get sizeType() {
        return this._sizeType;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set sizeType(val) {
        this._sizeType = val;
    }
    /**
     * @return {?}
     */
    get fit() {
        return this._fit;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set fit(val) {
        this._fit = val;
        this.hostCls = val;
    }
    /**
     * @return {?}
     */
    get fitColumns() {
        return this._fitColumns;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set fitColumns(val) {
        if (this._fitColumns !== val) {
            this._fitColumns = val;
            if (val) {
                this.setFitColumns(val);
            }
            else {
                this.dfs.fitColumns(false);
                this.dfs.initColumns(false, true);
                this.restituteColumnsSize();
            }
        }
    }
    /**
     * @return {?}
     */
    get autoFitColumns() {
        return this._autoFitColumns;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set autoFitColumns(val) {
        this._autoFitColumns = val;
        this.dfs.updateProperty('autoFitColumns', val);
    }
    /**
     * 锁定分页条，锁定后页码点击无效
     * @return {?}
     */
    get lockPagination() {
        return this._lockPagination;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set lockPagination(val) {
        this._lockPagination = val;
        if (this.dgPager) {
            this.dgPager[val ? 'lock' : 'unlock']();
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set pagination(val) {
        if (this.__pagination !== val) {
            this.__pagination = val;
            this.dfs.updateProperty('pagination', val);
            this.dgs.showGridHeader.emit();
        }
    }
    /**
     * @return {?}
     */
    get pagination() {
        return this.__pagination;
    }
    /**
     * @return {?}
     */
    get total() {
        return this._total;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set total(val) {
        this._total = val;
        this.pagerOpts.totalItems = val;
        if (!this.pagination) {
            this.pagerOpts.itemsPerPage = val;
        }
        this.dfs.setTotal(val);
    }
    /**
     * @return {?}
     */
    get footerData() {
        return this._footerData;
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    set footerData(rows) {
        if (rows && rows.subscribe) {
            this._footerData = rows;
        }
        else {
            this._footerData = of(rows || []);
        }
        if (rows) {
            this.setFooterHeight();
        }
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    get columns() {
        return this._columns;
    }
    /**
     * @param {?} values
     * @return {?}
     */
    set columns(values) {
        this._columns = this.correctColumns(values);
        this.dfs.updateProperty('columns', this._columns);
    }
    /**
     * @return {?}
     */
    get fields() {
        return this._fields;
    }
    /**
     * @param {?} cols
     * @return {?}
     */
    set fields(cols) {
        this._fields = cols;
        this.columns = cols;
        if (this.data) {
            this.columnsChanged(false, true);
        }
    }
    /**
     * @return {?}
     */
    get editable() {
        return this._editable;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set editable(v) {
        if (this._editable !== v) {
            this._editable = v;
            this.cd.detectChanges();
            this.dgs.updateEmptyStyle();
        }
    }
    /**
     * @return {?}
     */
    get groupField() {
        return this._groupField;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set groupField(val) {
        this._groupField = val || '';
        if (Array.isArray(this._groupField)) {
            this._groupField = this._groupField.join(',');
        }
        if (this._groupField) {
            this.groupFields$.next(this._groupField.split(','));
        }
        else {
            this.groupFields$.next([]);
        }
        this.dfs.updateProperty('groupField', this._groupField);
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set showRowGroupPanel(val) {
        this._showRowGroupPanel = val;
    }
    /**
     * @return {?}
     */
    get showRowGroupPanel() {
        return this.groupRows && this._showRowGroupPanel;
    }
    /**
     * @return {?}
     */
    get loading() {
        return this._loading;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set loading(val) {
        this._loading = val;
        if (!this.cd['destroyed']) {
            this.cd.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    get selections() {
        return this.dfs.getSelections();
    }
    /**
     * @return {?}
     */
    get checkeds() {
        return this.checkedRows;
    }
    /**
     * @return {?}
     */
    get checkedRows() {
        /** @type {?} */
        const chkeds = this.dfs.getCheckeds();
        if (this.enableMorePageSelect) {
            if (chkeds && chkeds.length) {
                if (!this.checkedRowsDataFromSource) {
                    return [...chkeds];
                }
                // 从数据源中获取最新数据
                return chkeds.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    /** @type {?} */
                    const d = this.dfs.findRow(n.id);
                    if (d) {
                        n.data = d.data;
                    }
                    return n;
                }));
            }
        }
        else {
            if (this.data && this.data.length) {
                /** @type {?} */
                const temp = this.data.map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n[this.idField]));
                if (!this.checkedRowsDataFromSource) {
                    return chkeds.filter((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => temp.includes(n.id)));
                }
                // 从数据源中获取最新数据
                return chkeds.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => temp.includes(n.id))).map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    /** @type {?} */
                    const d = this.dfs.findRow(n.id);
                    if (d) {
                        n.data = d.data;
                    }
                    return n;
                }));
            }
        }
        return [];
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    set checkedRows(rows) {
        if (rows && rows.length) {
            rows = rows.map((/**
             * @param {?} r
             * @return {?}
             */
            r => {
                if (r.data) {
                    return r;
                }
                return {
                    id: r[this.idField],
                    data: r
                };
            }));
        }
        this.dfs.updateProperty('checkedRows', rows || []);
        this.initSelectOrChecked();
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    get selectedRow() {
        return this._selectedRow;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    set selectedRow(row) {
        if (row) {
            if (this.selectValue != row.id) {
                this._selectedRow = row;
                this.selectValue = row.id;
                this.selectValueChange.emit(row.id);
                this.selectChanged.emit(row);
            }
        }
        else {
            this.unSelect.emit(this._selectedRow);
            this.selectValue = null;
            this.selectValueChange.emit('');
            this._selectedRow = null;
        }
        // this.cd.detectChanges();
    }
    /**
     * @param {?} $data
     * @return {?}
     */
    setCurrentPagerData($data) {
        this.currentPagerData = $data;
    }
    /**
     * @param {?} msg
     * @param {?=} type
     * @return {?}
     */
    writeConsole(msg, type = 'warn') {
        if (this.debugSer) {
            if (this.debugSer[type]) {
                this.debugSer[type](msg);
            }
            else {
                console[type](msg);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateFooterData() {
        if ((this.showFooter || this.pagerContentTemplate) && this.footerDataFrom === 'client') {
            /** @type {?} */
            const fdata = this.dfs.getFooterData(this.data);
            if (JSON.stringify(this._footerData['value']) !== JSON.stringify(fdata)) {
                this.footerData = of(fdata);
            }
        }
    }
    //#region Ng Event
    /**
     * @return {?}
     */
    ngDoCheck() {
        // if (!this.checkValues) {
        //     this.checkValues = [];
        // }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.sms = new SelectionModeService(this);
        this.checkFilterStyle();
        if (this.useThemes) {
            this._checkSize();
        }
        this.checkOptions();
        this.groupRowPanelPlaceholder = this.localeService.getValue('datagrid.groupRow.tips');
        if (this.smartFilterService) {
            if (this.enableSmartFilter && this.showFilterBar) {
                if (this.smartFilterResult && this.smartFilterResult.controlData && this.smartFilterResult.controlData.length) {
                    this.filterBarHeight = this.smartFilterBarHeight;
                }
                else {
                    this.filterBarHeight = 0;
                }
            }
            this.smartFilterService.filterChanged.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (!this.smartFilterResult && !e) {
                    return;
                }
                if (JSON.stringify(this.smartFilterResult) !== JSON.stringify(e)) {
                    this.smartFilterResult = e;
                    this.clientFilterChanged = true;
                    this.filterData(e.conditions);
                    if (!this.smartFilterResult || (this.smartFilterResult.controlData && !this.smartFilterResult.controlData.length)) {
                        this.onFilterBarResize(0);
                    }
                    else {
                        if (!this.filterBarHeight) {
                            this.onFilterBarResize(this.smartFilterBarHeight);
                        }
                    }
                }
            }));
        }
        this.isFF = this.commonUtils.getBrowserType().ff;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // 创建自定义style 容器
        // 
        this.setHeaderHeight();
        this.setPagerHeight();
        // this.setRowHeight();
        this.initBeforeEvents();
        if (this.fit) {
            this.setGridNewSizeWhenFit();
        }
        this.initState();
        if (this.el && this.farrisInstances) {
            this.farrisInstances.add(this.el.nativeElement, this);
        }
        if (!this.data || !this.data.length) {
            this.fetchData(1, this.pageSize).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => {
                if (!res) {
                    return;
                }
                this.total = res.total;
                if (res.footer) {
                    this.footerData = res.footer;
                }
                this.loadData(res.items);
            }));
        }
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.render2.addClass(this.dgContainer.nativeElement, this._custom_datagrid_cls);
            this.ro = new ResizeObserver((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                /** @type {?} */
                const target = (/** @type {?} */ (e[0].target));
                if (target.style.display === 'none') {
                    return;
                }
                /** @type {?} */
                const _w = e[0].contentRect.width;
                if (!_w) {
                    return;
                }
                /** @type {?} */
                const _h = e[0].contentRect.height;
                /** @type {?} */
                const _floowW = Math.floor(_w);
                /** @type {?} */
                const _floorH = Math.floor(_h);
                /** @type {?} */
                const _roundW = Math.round(_w);
                /** @type {?} */
                const _roundH = Math.round(_h);
                /** @type {?} */
                const _ceilW = Math.ceil(_w);
                /** @type {?} */
                const _ceilH = Math.ceil(_h);
                if ((this.width === _floowW || this.width === _roundW || this.width === _ceilW) && (this.height === _floorH || this.height === _roundH || this.height === _ceilH)) {
                    this.dgs.restoreScrollbarPosition();
                    return;
                }
                if (this.resizeTimer) {
                    clearTimeout(this.resizeTimer);
                }
                this.resizeTimer = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.calculateGridSize(this.fit);
                    this.resized.emit();
                }), 100);
            }));
            this.ro.observe(this.el.nativeElement.parentElement);
            document.body.removeEventListener('mousedown', this.documentBodyMouseDown, true);
            document.body.addEventListener('mousedown', this.documentBodyMouseDown = (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (!this.isEditing()) {
                    return;
                }
                /** @type {?} */
                const target = (/** @type {?} */ (e.target));
                if ((target.closest('td.f-datagrid-cell') && !target.closest('.f-datagrid-footer-row')) ||
                    target.closest('.date-overlay-container') ||
                    target.closest('.time-picker-overlay') ||
                    target.closest('.language-textbox-panel') ||
                    target.closest('.farris-notify') ||
                    target.closest('.comboPanel')
                // || target.closest('.f-multi-select-date')  //日期多选
                ) {
                    return;
                }
                this.onDocumentMouseDown(e);
            }), true);
        }));
        if (this.showFooter) {
            if (this.footerTemplate) {
                /** @type {?} */
                const footerDom = this.el.nativeElement.querySelector('.f-datagrid-footer');
                if (footerDom) {
                    this.footerHeight = this.el.nativeElement.querySelector('.f-datagrid-footer').offsetHeight;
                }
            }
        }
        if (this.fit) {
            if (this.el.nativeElement.parentElement) {
                this.el.nativeElement.parentElement.style.position = 'relative';
            }
            this.calculateGridSize(this.fit);
        }
        // 检查是否启用仿windows资源管理器中的多选模式
        if (this.selectionMode && this.selectionMode === 'default' && this.multiSelect) {
            this.sms.enableWindowsSelectionMode();
        }
        this.setCellStyle();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.dgColumns && this.dgColumns.length) {
            this.columns = this.dgColumns.map((/**
             * @param {?} dgc
             * @return {?}
             */
            dgc => {
                return Object.assign({}, dgc);
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.data && !changes.data.isFirstChange()) {
            this.dfs.loadData(changes.data.currentValue);
            this.dgs.dataSourceChanged();
        }
        if (changes.showAllCheckbox !== undefined && !changes.showAllCheckbox.isFirstChange()) {
            if (changes.showAllCheckbox.currentValue != changes.showAllCheckbox.previousValue) {
                this.columnsChanged(false);
            }
        }
        if (changes.showCheckbox !== undefined && !changes.showCheckbox.isFirstChange()) {
            this.dfs.showCheckbox(changes.showCheckbox.currentValue);
        }
        if (changes.showLineNumber !== undefined && !changes.showLineNumber.isFirstChange()) {
            this.dfs.showLineNumber(changes.showLineNumber.currentValue);
        }
        if (changes.multiSelect !== undefined && !changes.multiSelect.isFirstChange()) {
            this.dfs.setMultiSelect(changes.multiSelect.currentValue);
            this.columnsChanged();
        }
        if (changes.checkOnSelect !== undefined && !changes.checkOnSelect.isFirstChange()) {
            this.dfs.setCheckOnSelect(changes.checkOnSelect.currentValue);
        }
        if (changes.selectOnCheck !== undefined && !changes.selectOnCheck.isFirstChange()) {
            this.dfs.setSelectOnCheck(changes.selectOnCheck.currentValue);
        }
        if (changes.onlySelectSelf !== undefined && !changes.onlySelectSelf.isFirstChange()) {
            this.dfs.updateProperty('onlySelectSelf', changes.onlySelectSelf.currentValue);
        }
        if (changes.keepSelect !== undefined && !changes.keepSelect.isFirstChange()) {
            this.dfs.updateProperty('keepSelect', changes.keepSelect.currentValue);
        }
        if (changes.headerWrap !== undefined && !changes.headerWrap.isFirstChange()) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.setHeaderHeight();
                this.cd.detectChanges();
                this.dfs.columnResizeEnd();
            }));
        }
        if (changes.nowrap !== undefined && !changes.nowrap.isFirstChange()) {
            this.checkNowrap();
            this.setRowHeight(false);
            this.dgs.cellContentWrapChanged.emit();
            this.dfs.updateProperty('nowrap', changes.nowrap.currentValue);
        }
        if (changes.multiSort !== undefined && !changes.multiSort.isFirstChange()) {
            this.dfs.updateProperty('multiSort', changes.multiSort.currentValue);
        }
        if (changes.editable !== undefined && !changes.editable.isFirstChange()) {
            this.dfs.updateProperty('editable', changes.editable.currentValue);
            if (!changes.editable.currentValue) {
                this.endCellEdit();
            }
            this.isSingleClick = null;
            this.cd.detectChanges();
        }
        if (changes.showHeader !== undefined && !changes.showHeader.isFirstChange()) {
            this.dfs.updateProperty('showHeader', changes.showHeader.currentValue);
            this.headerHeightChange();
            this.cd.detectChanges();
        }
        if (changes.showFilterBar !== undefined && !changes.showFilterBar.isFirstChange()) {
            this.dfs.updateProperty('showFilterBar', changes.showFilterBar.currentValue);
            this.dgs.showGridHeader.emit(this.realHeaderHeight);
            // this.dgs.smartFilterBarExpand.emit();
            /** @type {?} */
            let fh = 0;
            if (this.conditions && this.conditions.length) {
                fh = 32;
            }
            this.onFilterBarResize(fh);
        }
        if (changes.showFooter !== undefined && !changes.showFooter.isFirstChange()) {
            this.dfs.updateProperty('showFooter', changes.showFooter.currentValue);
            // this.cd.detectChanges();
            this.calculateGridSize(this.fit);
        }
        if (changes.pagerOnServer !== undefined && !changes.pagerOnServer.isFirstChange()) {
            this.dfs.updateProperty('pagerOnServer', changes.pagerOnServer.currentValue);
            this.pagerOpts = Object.assign(this.pagerOpts, {
                remote: this.pagerOnServer
            });
        }
        if (changes.pageIndex !== undefined && !changes.pageIndex.isFirstChange()) {
            this.dfs.updateProperty('pageIndex', changes.pageIndex.currentValue);
            this.pagerOpts = Object.assign(this.pagerOpts, {
                currentPage: this.pageIndex
            });
        }
        if (changes.pageSize !== undefined && !changes.pageSize.isFirstChange()) {
            this.dfs.updateProperty('pageSize', changes.pageSize.currentValue);
            this.pagerOpts = Object.assign(this.pagerOpts, {
                itemsPerPage: this.pageSize
            });
        }
        if (changes.pageList !== undefined && !changes.pageList.isFirstChange()) {
            this.dfs.updateProperty('pageList', changes.pageList.currentValue);
            this.pagerOpts = Object.assign(this.pagerOpts, {
                pageList: this.pageList
            });
        }
        if (changes.columns !== undefined && !changes.columns.isFirstChange()) {
            this.columnsChanged();
        }
        if (changes.sizeType !== undefined && !changes.sizeType.isFirstChange()) {
            this._sizeType = changes.sizeType.currentValue;
            this.setRowHeight(true);
            // this.setHeaderHeight();
            this.dfs.updateProperty('rowHeight', this.rowHeight);
            this.setFooterHeight();
            this.refresh();
            this.dgs.onRowHeightChange(this.rowHeight);
        }
        if (changes.rowHeight && !changes.rowHeight.isFirstChange()) {
            this.setRowHeight(false);
        }
        if (changes.selectValue && !changes.selectValue.isFirstChange()) {
            this.selectRow(this.selectValue, false);
        }
        if (changes.checkValues && !changes.checkValues.isFirstChange()) {
            /** @type {?} */
            const checkIds = this.dfs.differenceBy(changes.checkValues.currentValue || [], changes.checkValues.previousValue || [], (/**
             * @param {?} v
             * @return {?}
             */
            (v) => v));
            if (checkIds && checkIds.length) {
                this.checkRows(checkIds, false);
            }
            /** @type {?} */
            const uncheckIds = this.dfs.differenceBy(changes.checkValues.previousValue || [], changes.checkValues.currentValue || [], (/**
             * @param {?} v
             * @return {?}
             */
            (v) => v));
            if (uncheckIds && uncheckIds.length) {
                this.unCheckRows(uncheckIds, false);
            }
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.checkValues = this.checkeds.map((/**
                     * @param {?} r
                     * @return {?}
                     */
                    r => r.id));
                    this.checkValuesChange.emit(this.checkValues);
                    this.checkedChange.emit(this.checkeds);
                    this.updateAllCheckboxStatus();
                }), 10);
            }));
        }
        if (changes.showGroupColumn && !changes.showGroupColumn.isFirstChange()) {
            this.toggleVisibleColumn(this.groupField.split(','), changes.showGroupColumn.currentValue);
            this.columnsChanged();
        }
        if (changes.autoFitColumns && !changes.autoFitColumns.isFirstChange()) {
            this.dfs.updateProperty('autoFitColumns', changes.autoFitColumns.currentValue);
        }
        // if (changes.fitColumns && !changes.fitColumns.isFirstChange()) {
        //     this.fitColumns = changes.fitColumns.currentValue;
        // }
        if (changes.groupRows && !changes.groupRows.isFirstChange()) {
            this.dfs.updateProperty('groupRows', changes.groupRows.currentValue);
            this.refresh();
        }
        if (changes.mergeCell && !changes.mergeCell.isFirstChange()) {
            this.refresh();
        }
        if (changes.mergeFields && !changes.mergeFields.isFirstChange()) {
            this.refresh();
        }
        if (changes.enableFilterRow && !changes.enableFilterRow.isFirstChange()) {
            this.dfs.updateProperty('enableFilterRow', changes.enableFilterRow.currentValue);
            if (this.showHeader) {
                this.setHeaderHeight();
                this.filterBarHeight = 32;
                this.dgs.toggleFilterRow.emit(this.enableFilterRow);
                this.dgs.showGridHeader.emit(this.realHeaderHeight);
                this.cd.detectChanges();
            }
        }
        if (changes.enableSmartFilter && !changes.enableSmartFilter.isFirstChange()) {
            this.dfs.updateProperty('enableSmartFilter', changes.enableSmartFilter.currentValue);
        }
        if (changes.enableDragColumn && !changes.enableDragColumn.isFirstChange()) {
            this.checkDragColumns();
        }
        if (changes.showRowGroupPanel && !changes.showRowGroupPanel.isFirstChange()) {
            this.dgs.smartFilterBarExpand.emit();
            this.dgs.showGridHeader.emit(this.realHeaderHeight);
        }
        if (changes.selectionMode && !changes.selectionMode.isFirstChange()) {
            this.sms.toggleMode();
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkFilterStyle() {
        // 过滤行与智能过滤 同时启用时，将过滤行禁用
        if (this.enableFilterRow && this.enableSmartFilter) {
            this.enableFilterRow = false;
        }
    }
    /**
     * @private
     * @return {?}
     */
    _checkSize() {
        /** @type {?} */
        const themesKey = localStorage.getItem('gsp_rtf_themSKey');
        /** @type {?} */
        let st = 'sm';
        switch (themesKey) {
            case 'default':
                st = 'sm';
                break;
            case 'loose':
                st = 'md';
                break;
        }
        this.sizeType = st;
    }
    /**
     * @private
     * @return {?}
     */
    checkDragColumns() {
        if (this.isMultiHeader()) {
            this.enableDragColumn = false;
            // this.cd.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    enableSettings() {
        return this.useControlPanel && (!this.isMultiHeader() || (this.isMultiHeader() && this.enableSetMultiHeaders));
    }
    /**
     * @private
     * @return {?}
     */
    checkOptions() {
        this.gridSize = { width: this.width + 'px', height: this.height + 'px' };
        if (!this.id) {
            this.id = 'FarrisDataGrid' + Utils.uuid().replace(/-/g, '').substr(0, 10);
            if (this.useControlPanel) {
                this.useControlPanel = false;
                this.writeConsole('启用列配置属性，未设置ID，此功能将禁用。');
            }
            this._custom_datagrid_cls = this.id;
        }
        else {
            this.styleSheetId = this.id + '_' + Utils.uuid().replace(/-/g, '').substr(0, 10);
            this._custom_datagrid_cls = this.styleSheetId;
        }
        if (this.settingService && this.useControlPanel) {
            this.settingService.registerGridInstance(this);
        }
        this.dgs.createStyleElement(this.styleSheetId);
        if (!this.idField) {
            throw new Error('The Datagrid\'s idField can\'t be Null. ');
        }
        this.checkNowrap();
        this.checkSortInfo();
        this.checkMergeCell();
        this.setCheckboxBehavior();
        this.initPaginationOptions();
        if (!this.columns) {
            this.columns = this.fields;
        }
        this.checkGroupHeaderColumns();
        // TFS: 356956
        this.checkGroupRowSetting();
        this.checkColumnsType();
        this.checkDragColumns();
        /** @type {?} */
        const _defaultSetting = (/**
         * @return {?}
         */
        () => {
            this._flatColumns();
            this.setRowHeight();
        });
        this.dfs.setinitialOptions({
            columns: this.columns,
            groupField: this.groupField,
            sortName: this.sortName,
            sortOrder: this.sortOrder,
            expandGroupRows: this.expandGroupRows
        });
        if (!this.isMultiHeader()) {
            this.enableSetMultiHeaders = false;
        }
        // 加载用户个性化设置 --》 列显示与列排序
        if (this.settingService && this.enableSettings()) {
            /** @type {?} */
            const settings$ = this.settingService.getSettings(this.id);
            if (!settings$) {
                _defaultSetting();
                return;
            }
            settings$.subscribe((/**
             * @param {?} sets
             * @return {?}
             */
            (sets) => {
                if (sets) {
                    if (this.enableScheme && this.settingService['schemeService']) {
                        /** @type {?} */
                        const schemalist = this.settingService['schemeService'].getStateValue(this.id, 'list');
                        if (schemalist && schemalist.length) {
                            this.userProfileSetting(sets);
                        }
                    }
                    else {
                        this.userProfileSetting(sets);
                    }
                    this.setRowHeight(false);
                }
                if (this.data && this.data.length) {
                    this.dfs.updateProperty('data', this.data);
                }
                this.columnsChanged(this.groupRows && (this.data && !!this.data.length));
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                _defaultSetting();
                this.writeConsole(err, 'error');
            }));
        }
        else {
            _defaultSetting();
        }
    }
    /**
     * @return {?}
     */
    refreshSelectedData() {
        if (this.selectedRow && this.selectedRow.id) {
            if (this.data && this.data.length) {
                /** @type {?} */
                const rd = this.data.find((/**
                 * @param {?} d
                 * @return {?}
                 */
                d => d[this.idField] === this.selectedRow.id));
                this.selectedRow.data = rd;
            }
            else {
                this.selectedRow = null;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribes();
        if (this.ro) {
            if (this.el.nativeElement.parentElement) {
                this.ro.unobserve(this.el.nativeElement.parentElement);
            }
            this.ro.disconnect();
        }
        if (this.documentRowKeydownHandler) {
            this.documentRowKeydownHandler();
        }
        this.currentCell = null;
        this.clientFilterService = null;
        this.cleanDom();
        // 移除动态的style
        this.dgs.removeStyleSheet();
        if (this.settingService && this.settingService.destroy) {
            this.settingService.destroy(this.id);
        }
        if (this.sms) {
            this.sms.destroy();
            this.sms = null;
        }
        document.body.removeEventListener('mousedown', this.documentBodyMouseDown, true);
        if (this.farrisInstances) {
            this.farrisInstances.destroy(this.el.nativeElement);
        }
        this._selectedRow = null;
        this.editors = {};
        DatagridColumnsHelper.gridInstance = null;
        this.unbindMoveSelectRowEvent();
        this.unbindDocumentEditListener();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.showSelectedList && this.dgPager) {
            this.dgPager.closeSelectedList();
        }
        if (this.pending) {
            return;
        }
        /** @type {?} */
        const target = (/** @type {?} */ (event.target));
        if (target.nodeName === 'TEXTAREA' || target.nodeName === 'INPUT') {
            event.stopPropagation();
            return;
        }
        if (this.currentCell && this.currentCell.editor && this.currentCell.editor._editorClickEvent) {
            event.stopPropagation();
            return;
        }
        /*
        this.endCellEdit(event);
        this.dfs.cancelSelectCell();
        */
        if (this.stopPropagation) {
            event.stopPropagation();
            return;
        }
    }
    /**
     * @private
     * @return {?}
     */
    initPaginationOptions() {
        this.pagerOpts = {
            id: this.id ? this.id + '-pager_' + Utils.uuid() : 'farris-datagrid-pager_' + Utils.uuid(),
            itemsPerPage: this.pagination ? this.pageSize : this.total,
            currentPage: this.pageIndex,
            totalItems: this.total,
            pageList: this.pageList,
            remote: this.pagerOnServer
        };
    }
    /**
     * @private
     * @return {?}
     */
    updatePagerOptions() {
        this.pagerOpts = Object.assign(this.pagerOpts, {
            itemsPerPage: this.pageSize,
            currentPage: this.pageIndex,
            totalItems: this.total
        });
    }
    /**
     * @private
     * @return {?}
     */
    setPagerTotal() {
        /** @type {?} */
        const _total = this.data.length;
        if (this.pagination && this.total === 0 && this.virtualized) {
            this.pagerOpts.totalItems = _total;
        }
        else {
            if (!this.pagination) {
                this.pagerOpts.itemsPerPage = _total;
            }
        }
    }
    /**
     * @private
     * @param {?=} rows
     * @return {?}
     */
    setFooterHeight(rows) {
        if (this.showFooter && !this.footerTemplate) {
            rows = rows || this._footerData['value'];
            if (!rows || !rows.length) {
                return;
            }
            if (this.nowrap) {
                this.dgs.removeCssRule(`${this.customStyleKey()} .f-datagrid-footer .f-datagrid-footer-row`);
                this.renderCustomStyle2({ style: { height: `${this._footerRowHeight}px!important` } }, null, 'f-datagrid-footer .f-datagrid-footer-row');
                /** @type {?} */
                const clsName = 'f-datagrid-footer-row .f-datagrid-cell-content,f-datagrid-group-footer .f-datagrid-cell-content,f-datagrid-footer-row .f-datagrid-cell';
                clsName.split(',').forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    this.dgs.removeCssRule(`${this.customStyleKey()} .${n}`);
                }));
                /** @type {?} */
                let fh = this._footerRowHeight - 1;
                clsName.split(',').forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    this.renderCustomStyle2({ style: { height: `${fh}px!important`, "line-height": `${fh}px!important` } }, null, n);
                }));
                this.footerHeight = rows.length * this._footerRowHeight;
            }
            else {
                if (this['_footer_height_timer_']) {
                    clearTimeout(this['_footer_height_timer_']);
                }
                this['_footer_height_timer_'] = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    /** @type {?} */
                    const topFooter = document.querySelector('.f-datagrid-footer-top');
                    /** @type {?} */
                    const bottomFooter = document.querySelector('.f-datagrid-footer-bottom');
                    /** @type {?} */
                    let _footHeight = rows.length * this._footerRowHeight;
                    /** @type {?} */
                    const minFooterRowHeight = `min_footer_row_height_${this._footerRowHeight}`;
                    if (topFooter) {
                        topFooter.querySelectorAll('tr').forEach((/**
                         * @param {?} tr
                         * @return {?}
                         */
                        tr => {
                            this.render2.addClass(tr, minFooterRowHeight);
                        }));
                        this.render2.setStyle(topFooter, 'height', _footHeight + 'px');
                        _footHeight = Math.max(...Array.from(topFooter.querySelectorAll('table')).map((/**
                         * @param {?} n
                         * @return {?}
                         */
                        n => n.offsetHeight)));
                        this.render2.setStyle(topFooter, 'height', _footHeight + 'px');
                    }
                    else {
                        if (bottomFooter) {
                            bottomFooter.querySelectorAll('tr').forEach((/**
                             * @param {?} tr
                             * @return {?}
                             */
                            tr => {
                                this.render2.addClass(tr, minFooterRowHeight);
                            }));
                            this.render2.setStyle(bottomFooter, 'height', _footHeight + 'px');
                            _footHeight = Math.max(...Array.from(bottomFooter.querySelectorAll('table')).map((/**
                             * @param {?} n
                             * @return {?}
                             */
                            n => n.offsetHeight)));
                            this.render2.setStyle(bottomFooter, 'height', _footHeight + 'px');
                        }
                    }
                    if (_footHeight !== this.footerHeight) {
                        this.footerHeight = _footHeight;
                        if (rows.length * this._footerRowHeight > this.footerHeight) {
                            this.footerHeight = rows.length * this._footerRowHeight;
                        }
                        this.dfs.columnResizeEnd();
                    }
                }), 100);
            }
        }
    }
    /**
     * @return {?}
     */
    customStyleKey() {
        return `.${this._custom_datagrid_cls}`;
    }
    /**
     * @private
     * @param {?=} useSizeType
     * @return {?}
     */
    setRowHeight(useSizeType = false) {
        /** @type {?} */
        const _rowHeight = SIZE_TYPE[this._sizeType].row;
        /** @type {?} */
        const _rh = 29;
        if (useSizeType) {
            this.rowHeight = _rowHeight;
            this.filterRowHeight = SIZE_TYPE[this._sizeType].pager;
        }
        else {
            this.rowHeight = _rowHeight > this.rowHeight ? _rowHeight : this.rowHeight;
        }
        /** @type {?} */
        const key1 = `${this.customStyleKey()}.f-datagrid-body-row, ${this.customStyleKey()} .f-datagrid-cell`;
        /** @type {?} */
        const key2 = `${this.customStyleKey()} .f-datagrid-cell-content`;
        this.dgs.removeCssRule(key1);
        this.dgs.removeCssRule(key2);
        if (this.rowHeight !== _rh && this.nowrap) {
            /** @type {?} */
            const rowHeightCSS = [
                `${key1} { height: ${this.rowHeight}px }`,
                `${key2} { height: ${this.rowHeight}px; line-height: ${this.rowHeight}px }`
            ];
            this.dgs.appendCssRules(rowHeightCSS);
        }
    }
    /**
     * @return {?}
     */
    initSelectOrChecked() {
        /** @type {?} */
        const _data = this.dfs.getCurrentPageData();
        if (!this.enableMorePageSelect && this.multiSelect) {
            // this.clearAll();
            if (this.checkeds && this.checkeds.length) {
                this.checkeds.forEach((/**
                 * @param {?} r
                 * @return {?}
                 */
                r => {
                    if (!_data.find((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n[this.idField] == r.id))) {
                        this.unCheckRow(r.id, false);
                    }
                }));
            }
            else {
                this.clearCheckeds();
            }
        }
        if (this.selectValue) {
            if (_data.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n[this.idField] == this.selectValue))) {
                this.selectRow(this.selectValue, false);
                this.refreshSelectedData();
            }
        }
        if (this.multiSelect) {
            if (this.checkValues && this.checkValues.length) {
                /** @type {?} */
                const chkids = this.checkeds.map((/**
                 * @param {?} r
                 * @return {?}
                 */
                r => r.id));
                /** @type {?} */
                const diffIds = this.dfs.difference(chkids, this.checkValues);
                if (diffIds.length) {
                    this.checkRows(diffIds, false);
                }
                else {
                    this.checkValues = [];
                }
            }
            else {
                this.checkValues = [];
            }
            this.checkValues = this.checkeds.map((/**
             * @param {?} r
             * @return {?}
             */
            r => r.id));
            if (!this._isResized || this.virtualized) {
                this.checkValuesChange.emit(this.checkValues);
                this.checkedChange.emit(this.checkeds);
            }
            this.updateAllCheckboxStatus(_data);
        }
    }
    /**
     * @private
     * @param {?=} _data
     * @return {?}
     */
    updateAllCheckboxStatus(_data) {
        if (!_data) {
            _data = this.dfs.getCurrentPageData();
        }
        /** @type {?} */
        let checkAllStatus = 0;
        if (this.showAllCheckbox) {
            /** @type {?} */
            const allDataIDs = _data.map((/**
             * @param {?} r
             * @return {?}
             */
            r => r[this.idField]));
            /** @type {?} */
            const newCheckValues = allDataIDs.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => this.checkValues.includes(n)));
            if (newCheckValues && newCheckValues.length) {
                /** @type {?} */
                const isSame = !this.dfs.difference(allDataIDs, this.checkValues).length;
                if (!this.checkValues || !this.checkValues.length) {
                    // 没有选中的数据
                    checkAllStatus = 0;
                }
                else if (isSame) { // this.checkValues.length === this.data.length ||
                    // 全部选中
                    checkAllStatus = 1;
                }
                else if (!isSame) { // this.checkValues.length !== this.data.length &&
                    // 有选中的数据，但不是全部选中
                    checkAllStatus = 2;
                }
            }
        }
        this.dgs.changeCheckAllStatus.emit(checkAllStatus);
    }
    // 当单选并显示复选框时，默认将 checkOnSelect, selectOnCheck 设置为 true;
    /**
     * @private
     * @return {?}
     */
    setCheckboxBehavior() {
        if (!this.multiSelect && this.showCheckbox) ;
    }
    /**
     * @private
     * @param {?} columns
     * @return {?}
     */
    _cancelColumnFixed(columns) {
        if (!columns.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => (!n.fixed || (n.fixed !== 'left' && n.fixed !== 'right')) && (n.visible || n.visible === undefined))).length) {
            /** @type {?} */
            const colsCount = columns.length;
            /** @type {?} */
            const rightCols = columns.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.fixed === 'right'));
            /** @type {?} */
            const leftCols = columns.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.fixed === 'left'));
            if (leftCols.length == colsCount || rightCols.length == colsCount) {
                columns.forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    n.fixed = '';
                }));
            }
            else {
                if (rightCols.length === 1) {
                    leftCols.forEach((/**
                     * @param {?} t
                     * @return {?}
                     */
                    t => {
                        t.fixed = '';
                    }));
                }
                else {
                    rightCols.forEach((/**
                     * @param {?} t
                     * @return {?}
                     */
                    t => {
                        t.fixed = '';
                    }));
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    _flatColumns() {
        if (!this.columns || !this.columns.length) {
            return;
        }
        // 检查列是否为全固定
        this._cancelColumnFixed(this.columns[0].filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.field !== this.ControlPanelFeild)));
        if (this.isMultiHeader()) {
            if (this.fast) {
                this.flatColumns = this.dfs.getGroupColumns(this.columns[0]);
            }
            else {
                /** @type {?} */
                const _cols = flatten(this.columns);
                _cols.forEach((/**
                 * @param {?} col
                 * @return {?}
                 */
                col => {
                    if (col.parentId) {
                        /** @type {?} */
                        const t = _cols.find((/**
                         * @param {?} n
                         * @return {?}
                         */
                        n => n.id === col.parentId));
                        if (t) {
                            col.fixed = t.fixed;
                        }
                    }
                }));
                this.flatColumns = _cols.filter((/**
                 * @param {?} col
                 * @return {?}
                 */
                (col) => (!col.colspan || col.colspan == 1) && this.columnIsVisible(col)));
            }
        }
        else {
            this.flatColumns = flatten(this.columns).filter((/**
             * @param {?} col
             * @return {?}
             */
            (col) => (!col.colspan || col.colspan == 1) && this.columnIsVisible(col)));
        }
    }
    /**
     * @param {?} col
     * @return {?}
     */
    columnIsVisible(col) {
        return DatagridColumnsHelper.columnIsVisible(col, this);
    }
    // 添加列设置
    /**
     * @private
     * @return {?}
     */
    addControlCol() {
        if (this.enableSettings()) {
            /** @type {?} */
            const controlCol = this.columns[0].find((/**
             * @param {?} n
             * @return {?}
             */
            n => n.field === this.ControlPanelFeild));
            if (!controlCol) {
                /** @type {?} */
                const cp = { field: this.ControlPanelFeild, width: 24, rowspan: this.columns.length, fixed: 'right', visible: true };
                // 2021-05-24 启用过滤行后出错
                // if (this.enableFilterRow) {
                //     cp.rowspan += 1;
                // }
                this.columns[0].push(cp);
            }
            else {
                controlCol.visible = true;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkGroupHeaderColumns() {
        if (this.isMultiHeader()) {
            /** @type {?} */
            const allCols = flatten(this.columns);
            DatagridColumnsHelper.checkGroupHeaderColumnVisible(allCols);
        }
    }
    // 检查列集合: [] -> [[]]
    /**
     * @private
     * @param {?} values
     * @return {?}
     */
    correctColumns(values) {
        if (values && values.length && !Array.isArray(values[0])) {
            return [values];
        }
        else {
            return values || [];
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkColumnsType() {
        if (this.columns && this.columns.length) {
            // if (!Array.isArray(this.columns[0])) {
            //     this.columns = [ this.columns ];
            // }
            this.addControlCol();
            this.columns.forEach((/**
             * @param {?} cols
             * @param {?} columnsIndex
             * @return {?}
             */
            (cols, columnsIndex) => {
                cols.forEach((/**
                 * @param {?} col
                 * @param {?} index
                 * @return {?}
                 */
                (col, index) => {
                    if (!col.field) {
                        col.field = `farris-datagrid-column_${columnsIndex}_${index}`;
                    }
                    if (!col.valign) {
                        col.valign = 'middle';
                    }
                    if (col.width === undefined || col.width === null) {
                        col.width = 100;
                    }
                    else {
                        if (typeof col.width === 'string') {
                            col.width = parseInt(col.width, 10);
                        }
                    }
                    // 记录原始宽度
                    if (!col.originalWidth) {
                        col.originalWidth = col.width;
                    }
                    if (col.formatter && typeof col.formatter !== 'function' && Object.keys(col.formatter).length === 0) {
                        col.formatter = null;
                    }
                    if (!this.showGroupColumn && this.groupRows) {
                        this.toggleVisibleColumn(this.groupField.split(','), false);
                    }
                    // 过滤行检查
                    if (col.filter) {
                        if (typeof col.filter === 'boolean') {
                            if (col.field) {
                                col.filter = this.clientFilterService.createColumnFilterOptions(col);
                            }
                            else {
                                col.filter = false;
                            }
                        }
                        else {
                            if (!col.filter.options || !Object.keys(col.filter.options).length) {
                                switch (col.filter.type) {
                                    case ColumnFilterType.enum:
                                        col.filter.options = col.formatter['options'];
                                        break;
                                    case ColumnFilterType.date:
                                        col.filter.options = { dateFormat: 'yyyy-MM-dd', returnFormat: 'yyyy-MM-dd' };
                                        break;
                                    case ColumnFilterType.datetime:
                                        col.filter.options = { dateFormat: 'yyyy-MM-dd HH:mm:ss', returnFormat: 'yyyy-MM-dd HH:mm:ss' };
                                        break;
                                }
                            }
                        }
                    }
                    // 兼容 hidden 2021-05-31
                    if (col['hidden'] !== undefined && col.visible === undefined) {
                        if (typeof col['hidden'] === 'boolean') {
                            col.visible = !col['hidden'];
                        }
                        else {
                            if (typeof col['hidden'] === 'function') {
                                col.visible = (/**
                                 * @return {?}
                                 */
                                () => {
                                    /** @type {?} */
                                    const r = col['hidden'].bind(this);
                                    return !r;
                                });
                            }
                        }
                    }
                    // 多表头禁用过滤
                    if (!col.field || col.field.indexOf('farris-datagrid-column_') > -1) {
                        col.filter = false;
                    }
                }));
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkGroupRowSetting() {
        // 如果启用分组行，但未设置分组字段时，将关闭分组行功能
        // if (this.groupRows) {
        //     if (!this.groupField) {
        //         this.groupRows = false;
        //     }
        // }
    }
    /**
     * @private
     * @return {?}
     */
    checkMergeCell() {
        if (this.mergeCell) {
            if (!this.mergeFields || !this.mergeFields.length) {
                this.mergeCell = false;
            }
            else {
                this.virtualized = false;
                this.virtualizedAsyncLoad = false;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkSortInfo() {
        if (this.sortName) {
            if (!this.sortOrder) {
                this.sortOrder = this.sortName.split(',').map((/**
                 * @return {?}
                 */
                () => 'asc')).join(',');
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkNowrap() {
        // 启用折行后，虚拟加载特性失效
        if (!this.nowrap) {
            this.virtualized = false;
        }
    }
    /**
     * @return {?}
     */
    setHeaderHeight() {
        this.realHeaderHeight = 0;
        if (this.showHeader) {
            /** @type {?} */
            const gridHeaderEl = this.el.nativeElement.querySelector('.f-datagrid-header');
            if (!this.headerWrap) {
                const { header: hh, pager: ph } = SIZE_TYPE[this._sizeType];
                if (this.useThemes) {
                    this.headerHeight = hh;
                    this.filterRowHeight = ph;
                }
                this.realHeaderHeight = this.columns.length * this.headerHeight;
                if (this.enableFilterRow) {
                    this.realHeaderHeight += this.filterRowHeight;
                }
                if (gridHeaderEl) {
                    gridHeaderEl.style.minHeight = this.realHeaderHeight + 'px';
                }
            }
            else {
                if (gridHeaderEl) {
                    this.render2.removeStyle(gridHeaderEl, 'minHeight');
                    /** @type {?} */
                    const fixedLeftHeader = gridHeaderEl.querySelector('.f-datagrid-header-fixed-left');
                    if (fixedLeftHeader) {
                        this.render2.setStyle(fixedLeftHeader, 'height', 'auto');
                    }
                    /** @type {?} */
                    const fixedRightHeader = gridHeaderEl.querySelector('.f-datagrid-header-fixed-right');
                    if (fixedRightHeader) {
                        this.render2.setStyle(fixedRightHeader, 'height', 'auto');
                    }
                    /** @type {?} */
                    const trs = gridHeaderEl.querySelectorAll('table tr:not(.f-datagrid-filter-row)');
                    trs.forEach((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => {
                        n.style.height = 'auto';
                        Array.from(n.children).forEach((/**
                         * @param {?} a
                         * @return {?}
                         */
                        (a) => a.style.height = 'auto'));
                    }));
                    /** @type {?} */
                    const tableEls = Array.from(gridHeaderEl.querySelectorAll('table'));
                    if (tableEls) {
                        /** @type {?} */
                        const heights = tableEls.map((/**
                         * @param {?} t
                         * @return {?}
                         */
                        (t) => t.offsetHeight));
                        /** @type {?} */
                        const maxHeight = Math.max(...heights);
                        this.realHeaderHeight = maxHeight;
                        gridHeaderEl.style.minHeight = this.realHeaderHeight + 'px';
                    }
                    if (fixedLeftHeader) {
                        this.render2.setStyle(fixedLeftHeader, 'height', this.realHeaderHeight + 'px');
                    }
                    if (fixedRightHeader) {
                        this.render2.setStyle(fixedRightHeader, 'height', this.realHeaderHeight + 'px');
                    }
                }
            }
        }
        return this.realHeaderHeight;
    }
    // 列集合变化
    /**
     * @param {?=} reloadData
     * @param {?=} useColumnSettingWidth
     * @param {?=} rebuildFilterBar
     * @return {?}
     */
    columnsChanged(reloadData = true, useColumnSettingWidth = null, rebuildFilterBar = true) {
        /** @type {?} */
        const _useColumnSettingWidth = useColumnSettingWidth === null ? this.fitColumns : useColumnSettingWidth;
        this.dfs.updateProperty('expandGroupRows', this.expandGroupRows);
        this.checkColumnsType();
        this._flatColumns();
        this.headerHeightChange();
        this.dfs.updateProperty('flatColumns', this.flatColumns);
        this.dfs.updateColumns(this.columns, _useColumnSettingWidth, true);
        // this.colGroup = this.dfs.getState().columnsGroup;
        // 动态列合计行
        this.updateFooterData();
        this.dgs.columnsChanged.emit({ scrollToLeft: reloadData, rebuildFilterBar });
        if (reloadData) {
            if (this['_COLUMNS_CHANAGED_TIMER_']) {
                clearTimeout(this['_COLUMNS_CHANAGED_TIMER_']);
            }
            this['_COLUMNS_CHANAGED_TIMER_'] = setTimeout((/**
             * @return {?}
             */
            () => {
                this.refresh();
            }), 60);
        }
        this.setCellStyle();
    }
    // 列头变化
    /**
     * @private
     * @return {?}
     */
    headerHeightChange() {
        this.setHeaderHeight();
        this.dgs.showGridHeader.emit(this.realHeaderHeight);
    }
    /**
     * 判断是否在弹出的窗口中；返回undefind 说明没有在弹出的窗口，否则视为当前列表在弹出窗口使用
     * @return {?}
     */
    inDialog() {
        return this.el.nativeElement.closest('.modal-body');
    }
    //#endregion
    //#region Init
    /**
     * 初始编辑器与验证器
     * @private
     * @return {?}
     */
    initEditorAndValidator() {
        /** @type {?} */
        const Editors = this.inject.get(GRID_EDITORS, []);
        if (Editors.length) {
            Editors.forEach((/**
             * @param {?} ed
             * @return {?}
             */
            ed => {
                this.editors[ed.name] = ed.value;
            }));
        }
        /** @type {?} */
        const _validators = this.inject.get(GRID_VALIDATORS, []);
        if (_validators && _validators.length) {
            // _validators.forEach(vr => {
            //     this.validators[vr.name] = vr.value;
            // });
            this.validators = _validators;
        }
    }
    /**
     * @return {?}
     */
    setPagerHeight() {
        if (!this.useHtmlTable) {
            if (!this.pagination) {
                this.pagerHeight = 0;
            }
            else {
                this.pagerHeight = this.dgPager && this.dgPager.outerHeight || 40;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    initState() {
        this.data = this.data || [];
        /** @type {?} */
        let sta = {};
        Object.keys(this).forEach((/**
         * @param {?} k
         * @return {?}
         */
        (k) => {
            if (!IgnoreProperties.includes(k)) {
                sta[k] = this[k];
            }
        }));
        this.dfs.initState(Object.assign({}, sta, { fitColumns: this.fitColumns, fit: this.fit, groupField: this._groupField }));
        sta = null;
    }
    /**
     * @private
     * @param {?=} fitColumns
     * @return {?}
     */
    setFitColumns(fitColumns = true) {
        if (this.columns) {
            this.dfs.fitColumns(fitColumns);
        }
    }
    /**
     * @private
     * @return {?}
     */
    setGridNewSizeWhenFit() {
        /** @type {?} */
        const parent = this.el.nativeElement.parentElement;
        if (parent) {
            const { width, height } = parent.getBoundingClientRect();
            /** @type {?} */
            const padding = this.getElementPadding(parent);
            /** @type {?} */
            const border = this.getElementBorderWidth(parent);
            /** @type {?} */
            let m = 'floor';
            if (this.maxHeight && this.autoHeight) {
                m = 'ceil';
            }
            this.width = Math[m](Math.floor(width) - border.left - border.right - padding.left - padding.right);
            this.height = Math[m](Math.floor(height) - border.top - border.bottom - padding.top - padding.bottom);
            if (this.maxHeight && this.autoHeight) {
                this.height += 1;
            }
            if (!this.height) {
                this.height = this.dfs.getState().height || 300;
            }
            if (!this.width) {
                this.width = this.dfs.getState().width || 800;
            }
        }
    }
    /**
     * @param {?=} fit
     * @return {?}
     */
    calculateGridSize(fit = true) {
        if (this.useHtmlTable) {
            return;
        }
        /** @type {?} */
        const setNewSize = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            let h = this.height;
            if (this.useBlankWhenDataIsEmpty && (!this.data || !this.data.length)) {
                h = this.emptyDataHeight + this.realHeaderHeight;
                if (this.showRowGroupPanel) {
                    h += this.rowGroupPanelHeight;
                }
                if (this.showFilterBar) {
                    h += this.filterBarHeight;
                }
                if (this.showFooter && this.footerData['value'].length) {
                    h += this.footerHeight;
                }
                if (this.pagination) {
                    /** @type {?} */
                    const ph = this.pagerHeight || 40;
                    h += ph;
                }
            }
            if (this.gridSize.height === h + 'px' && this.gridSize.width === this.width + 'px') {
                return;
            }
            this.gridSize = { width: this.width + 'px', height: h + 'px' };
            this.dfs.resize({ width: this.width, height: h });
        });
        if (fit) {
            this.setGridNewSizeWhenFit();
            if (this.width && this.height) {
                this._isResized = true;
                setNewSize();
                this._isResized = false;
                if (!this.cd['destroyed']) {
                    this.cd.detectChanges();
                }
            }
        }
        else {
            setNewSize();
        }
    }
    /**
     * @private
     * @return {?}
     */
    initBeforeEvents() {
        if (!this.beforeSelect) {
            this.beforeSelect = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.beforeUnselect) {
            this.beforeUnselect = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.beforeCheck) {
            this.beforeCheck = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.beforeUncheck) {
            this.beforeUncheck = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.beforeSortColumn) {
            this.beforeSortColumn = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.beforeEdit) {
            this.beforeEdit = (/**
             * @return {?}
             */
            () => of(true));
        }
        if (!this.afterEdit) {
            this.afterEdit = (/**
             * @return {?}
             */
            () => of(true));
        }
    }
    //#endregion
    //#region 快捷键
    /**
     * @private
     * @return {?}
     */
    unbindMoveSelectRowEvent() {
        if (this.documentRowKeydownHandler) {
            this.documentRowKeydownHandler();
            this.documentRowKeydownHandler = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    bindDocumentMoveSelectRowEvent() {
        this.unbindMoveSelectRowEvent();
        this.unbindDocumentEditListener();
        this.documentRowKeydownHandler = this.render2.listen(document, 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            // e.preventDefault();
            if (!this.isActived()) {
                return;
            }
            // has loading
            if (document.querySelectorAll('farris-loading').length) {
                return;
            }
            if (e.target) {
                /** @type {?} */
                const targetName = ((/** @type {?} */ (e.target))).nodeName;
                if (this.ignoreTarget.indexOf(targetName) > -1) {
                    return;
                }
            }
            if (e.keyCode === 40 || e.keyCode === 38) {
                e.preventDefault();
            }
            switch (e.keyCode) {
                case 40:
                    this.selectNextRow();
                    break;
                case 38:
                    this.selectPrevRow();
                    break;
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    bindEditListenerInModal() {
        // 弹窗中事件处理
        if (Utils.hasDialogOpen()) {
            /** @type {?} */
            const modalElement = this.inDialog();
            if (modalElement) {
                /** @type {?} */
                const _fmodal = modalElement.closest('.farris-modal');
                if (_fmodal) {
                    this.modalClickEvent = this.render2.listen(_fmodal, 'click', (/**
                     * @return {?}
                     */
                    () => {
                        this.endEditing();
                        this.currentCell = null;
                    }));
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    bindDocumentEditListener() {
        this.unbindDocumentEditListener();
        /*
               if (!this.documentCellClickHandler) {
                   this.bindEditListenerInModal();
                   this.documentCellClickHandler = (event) => {
                       if (this.pending) {
                           return false;
                       }
                       if (this.currentCell) {
                           if (Utils.hasDialogOpen()) {
                               const indlg = this.inDialog();
                               const currentTargetInDialog = event.target.closest('.modal-body');
                               if (indlg && currentTargetInDialog) {
                                   if (indlg != currentTargetInDialog) {
                                       return;
                                   }
                               } else {
                                   return;
                               }
                           }
                           // DomHandler.removeClass(this.currentCell.cellElement, CELL_SELECTED_CLS);
       
                           // if (this.currentCell.isEditing) {
                           //     // this.dfs.endEditCell();
                           //     this.currentCell.cellElement.closeEdit();
                           // }
                           // this.dfs.cancelSelectCell();
                           // this.unbindDocumentEditListener();
       
                           if (this.currentCell.isEditing) {
                               // this.dfs.endEditCell();
                               this.currentCell.cellElement.closeEdit().subscribe(f => {
                                   if (f) {
                                       DomHandler.removeClass(this.currentCell.cellElement, CELL_SELECTED_CLS);
                                       DomHandler.removeClass(this.currentCell.cellElement, CELL_EDITING_CLS);
                                       this.dfs.cancelSelectCell();
                                       this.unbindDocumentEditListener();
                                       this.currentCell = null;
                                   }
                               });
                           }
                       }
                   };
                   this.docuemntCellClickEvents = this.render2.listen(document, 'click', this.documentCellClickHandler);
               }
       */
        if (!this.documentCellKeydownHandler) {
            this.documentCellKeydownHandler = (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                if (!event.target.closest('.f-datagrid') && event.target.nodeName !== 'BODY') {
                    return;
                }
                if (this.isActived()) {
                    this.onKeyDownEvent(event);
                }
            });
            this.documentCellKeydownEvents = this.render2.listen(document, 'keydown', this.documentCellKeydownHandler);
        }
    }
    /**
     * @private
     * @return {?}
     */
    unbindDocumentEditListener() {
        if (this.documentCellClickHandler) {
            this.docuemntCellClickEvents();
            this.documentCellClickHandler = null;
        }
        if (this.documentCellKeydownHandler) {
            this.documentCellKeydownEvents();
            this.documentCellKeydownHandler = null;
        }
        if (this.modalClickEvent) {
            this.modalClickEvent();
            this.modalClickEvent = null;
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    onKeyDownEvent(e) {
        // if (e.ctrlKey || e.shiftKey || !this.editable) {
        //     return;
        // }
        // if (!e.target.closest('.f-datagrid')) {
        //     return;
        // }
        if (this.disabled) {
            return;
        }
        /** @type {?} */
        const keyCode = e.keyCode;
        if (this.currentCell && !this.currentCell.isEditing) {
            if ([13, 40, 37, 38, 39, 9].indexOf(keyCode) > -1) {
                e.preventDefault();
            }
            switch (keyCode) {
                case 32: // 空格
                    if (this.currentCell && this.currentCell.column.onSpaceHandler) {
                        e.stopPropagation();
                        this.currentCell.column.onSpaceHandler({ grid: this, cell: this.currentCell, event: e });
                    }
                    break;
                case 13: // Enter
                    if (this.currentCell) {
                        /** @type {?} */
                        const fn = this.currentCell.cellElement['editCell'];
                        if (fn) {
                            fn.apply(this.currentCell.cellElement);
                        }
                        else {
                            if (this.currentCell.column.onEnterHandler) {
                                e.stopPropagation();
                                this.currentCell.column.onEnterHandler({ grid: this, cell: this.currentCell, event: e });
                            }
                        }
                    }
                    break;
                case 40: // ↓
                    this.selectNextCell('down', e);
                    break;
                case 38: // ↑
                    this.selectNextCell('up', e);
                    break;
                case 39: // →
                    this.selectNextCell('right', e);
                    break;
                case 37: // ←
                    this.selectNextCell('left', e);
                    break;
                case 9: // Tab
                    if (e.shiftKey) {
                        this.selectNextCell('left', e);
                    }
                    else {
                        this.selectNextCell('right', e);
                    }
                    break;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    unsubscribes() {
        this.subscriptions.forEach((/**
         * @param {?} ss
         * @return {?}
         */
        ss => {
            if (ss) {
                ss.unsubscribe();
                ss = null;
            }
        }));
        this.subscriptions = [];
        if (this.docuemntCellClickEvents) {
            this.docuemntCellClickEvents();
        }
    }
    //#endregion
    //#region Editing
    /**
     * @return {?}
     */
    isRowEditing() {
        if (!this.selectedRow || this.selectedRow.index === -1) {
            return false;
        }
        else {
            if (this.editMode === 'row') {
                return this.selectedRow.editors && this.selectedRow.editors.length;
            }
            else {
                return false;
            }
        }
    }
    /**
     * @return {?}
     */
    isCellEditing() {
        if (this.currentCell && this.editMode === 'cell') {
            if (!this.currentCell.editor && this.currentCell.column && !this.currentCell.column.editorTemplate) {
                this.currentCell.isEditing = false;
                if (this.currentCell.cellRef) {
                    this.currentCell.cellRef.isEditing = false;
                }
            }
            return this.currentCell.isEditing;
        }
        return false;
    }
    /**
     * @return {?}
     */
    isEditing() {
        if (this.editMode === 'row') {
            return this.isRowEditing();
        }
        else {
            return this.isCellEditing();
        }
    }
    /**
     * @return {?}
     */
    endEditing() {
        if (this.editMode === 'row') {
            this.endRowEdit();
        }
        else if (this.editMode === 'cell') {
            this.endCellEdit();
        }
    }
    /**
     * @return {?}
     */
    getEditors() {
        return this.selectedRow.editors;
    }
    /**
     * @param {?} rowId
     * @param {?} field
     * @param {?=} validation
     * @return {?}
     */
    editCell(rowId, field, validation = null) {
        this.activeDataGrid();
        /** @type {?} */
        const rowIndex = this.dfs.findRowIndex(rowId);
        if (rowIndex > -1) {
            this.endCellEdit();
            /** @type {?} */
            const trId = TR_PREFIX + rowId;
            // const trDom = this.el.nativeElement.querySelector('#' + trId);
            /** @type {?} */
            const trDom = Utils.getTrDomById(trId, this.el.nativeElement);
            /** @type {?} */
            let tdDom = null;
            if (trDom) {
                tdDom = trDom.querySelector(`[field="${field}"]`);
            }
            /** @type {?} */
            const col = this.getColumn(field);
            if (!tdDom && col.fixed) {
                if (col.fixed === 'left') {
                    // const trDomL = this.el.nativeElement.querySelector('#' + trId + '_fixedleft');
                    /** @type {?} */
                    const trDomL = Utils.getTrDomById(trId + '_fixedleft', this.el.nativeElement);
                    tdDom = trDomL && trDomL.querySelector(`[field="${field}"]`);
                }
                else if (col.fixed === 'right') {
                    // const trDomR = this.el.nativeElement.querySelector('#' + trId + '_fixedright');
                    /** @type {?} */
                    const trDomR = Utils.getTrDomById(trId + '_fixedright', this.el.nativeElement);
                    tdDom = trDomR && trDomR.querySelector(`[field="${field}"]`);
                }
            }
            if (validation) {
                this.formValidations = Object.assign(this.formValidations || {}, { [field]: validation });
            }
            if (tdDom && tdDom['editCell']) {
                this.currentCell = null;
                if (this['EDITCELL_TIMER']) {
                    clearTimeout(this['EDITCELL_TIMER']);
                }
                this['EDITCELL_TIMER'] = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    tdDom.editCell();
                }), 0);
            }
        }
    }
    /**
     * @param {?=} event
     * @return {?}
     */
    endCellEdit(event) {
        // document.body.click();
        if (this.currentCell) {
            DomHandler.removeClass(this.currentCell.cellElement, CELL_SELECTED_CLS);
            if (this.currentCell.isEditing) {
                // this.dfs.endEditCell();
                if (this.currentCell.cellEditorRef) {
                    this.currentCell.cellEditorRef.hideCover();
                }
                /** @type {?} */
                const stopEdit = this.currentCell.cellElement.closeEdit();
                if (stopEdit) {
                    stopEdit.subscribe();
                }
            }
        }
    }
    /**
     * @param {?=} rowId
     * @return {?}
     */
    editRow(rowId) {
        if (!this.editable || this.editMode !== 'row') {
            return false;
        }
        if (rowId) {
            this.selectRow(rowId);
        }
        if (!this.selectedRow || this.selectedRow.index === -1) {
            this.writeConsole('Please select a row.');
            return false;
        }
        const { index: rowIndex, data: rowData } = Object.assign({}, this.selectedRow);
        /** @type {?} */
        const beforeEditEvent = this.beforeEdit({ rowIndex, rowData, gridInstance: this });
        if (!beforeEditEvent || !beforeEditEvent.subscribe) {
            this.writeConsole('please return an Observable Type.');
            return;
        }
        /** @type {?} */
        const trId = TR_PREFIX + rowId;
        // const trDom = this.el.nativeElement.querySelector('#' + trId);
        /** @type {?} */
        const trDom = Utils.getTrDomById(trId, this.el.nativeElement);
        if (!this.selectedRow.dr) {
            trDom.click();
        }
        beforeEditEvent.subscribe((/**
         * @param {?} flag
         * @return {?}
         */
        (flag) => {
            if (flag) {
                if (this.selectedRow.dr && this.selectedRow.dr.cells) {
                    /** @type {?} */
                    const cells = this.selectedRow.dr.cells.toArray();
                    if (!cells || !cells.length) {
                        return;
                    }
                    cells.forEach((/**
                     * @param {?} cell
                     * @return {?}
                     */
                    cell => {
                        if (cell.column.editor) {
                            cell.isEditing = true;
                        }
                    }));
                    this.selectedRow.dr.cd.detectChanges();
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        /** @type {?} */
                        const editors = cells.map((/**
                         * @param {?} cell
                         * @return {?}
                         */
                        cell => {
                            if (cell.cellEditor) {
                                return cell.cellEditor.componentRef;
                            }
                        })).filter((/**
                         * @param {?} editor
                         * @return {?}
                         */
                        editor => editor));
                        this.selectedRow.editors = editors;
                        if (editors && editors.length) {
                            if (editors[0].instance.inputElement) {
                                editors[0].instance.inputElement.focus();
                            }
                        }
                        // 绑定键盘事件
                        this.bindRowEditorKeydownEvent();
                        if (!this.cd['destroyed']) {
                            this.cd.detectChanges();
                        }
                        this.beginEdit.emit({ rowIndex, rowData, gridInstance: this, editor: editors });
                    }));
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    endRowEdit() {
        if (!this.isRowEditing()) {
            return { canEnd: true };
        }
        if (!this.selectedRow || this.selectedRow.index === -1) {
            this.writeConsole('Please select a row.');
            return;
        }
        const { index: rowIndex, data: rowData, dr } = Object.assign({}, this.selectedRow);
        const { editor: currentEditor, column } = Object.assign({}, this.currentCell);
        // blur
        document.body.click();
        if (this.pending) {
            return { canEnd: false };
        }
        if (!dr.form) {
            return { canEnd: true };
        }
        /** @type {?} */
        const rowForm = (/** @type {?} */ (dr.form));
        rowForm.markAsTouched();
        if (rowForm.invalid && !this.endEditByInvalid) {
            return { canEnd: false };
        }
        // afterEdit 要传递相关参数，在编辑状态时，移动滚动条会出事
        /** @type {?} */
        const afterEditEvent = this.afterEdit(rowIndex, rowData, column, currentEditor);
        if (!afterEditEvent || !afterEditEvent.subscribe) {
            this.writeConsole('please return an Observable Type.');
            return { canEnd: false };
        }
        afterEditEvent.subscribe((/**
         * @param {?} flag
         * @return {?}
         */
        (flag) => {
            if (flag) {
                this.closeAllCellEditor();
                if (this.selectedRow.dr.form) {
                    this.selectedRow.dr.rowData = Object.assign(this.selectedRow.dr.rowData, this.selectedRow.dr.form.value);
                    this.dfs.updateRow(this.selectedRow.id, this.selectedRow.dr.rowData);
                    this.cd.detectChanges();
                }
                /** @type {?} */
                let val = '';
                if (currentEditor && currentEditor.formControl) {
                    val = currentEditor.formControl.value;
                }
                this.endEdit.emit({ rowIndex, rowData, column, value: val });
                this.dgs.refreshFooterData.emit();
            }
        }));
    }
    /**
     * @param {?} rowId
     * @param {?=} emit
     * @return {?}
     */
    cancelEdit(rowId, emit = true) {
        if (!this.isEditing()) {
            return;
        }
        this.closeAllCellEditor();
        if (rowId) {
            this.dfs.rejectChanges(rowId);
        }
        this.cd.detectChanges();
        if (emit) {
            this.cancelEdited.emit();
        }
    }
    /**
     * @return {?}
     */
    closeAllCellEditor() {
        if (this.selectedRow && this.selectedRow.dr) {
            /** @type {?} */
            const cells = this.selectedRow.dr.cells;
            if (cells) {
                cells.forEach((/**
                 * @param {?} cell
                 * @return {?}
                 */
                cell => cell.isEditing = false));
                if (this.currentCell) {
                    this.currentCell.isEditing = false;
                }
            }
            this.selectedRow.editors = null;
        }
        // 取消键盘事件
        this.unbindRowEditorKeydownEvent();
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    rowEditTabKeydwonEvent(e) {
        /** @type {?} */
        const keyCode = e.which || e.keyCode;
        if (keyCode === 9) { // tab
            // tab
            /** @type {?} */
            const td = e.target.closest('td');
            /** @type {?} */
            const tr = e.target.closest('tr');
            /** @type {?} */
            const nextTd = td.nextElementSibling;
            /** @type {?} */
            const hasNoEditor = (/**
             * @param {?} _td
             * @return {?}
             */
            (_td) => {
                return !_td.querySelector('input') && !_td.querySelector('textarea') && !_td.querySelector('select');
            });
            /** @type {?} */
            const editNextRow = (/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const nextTr = tr.nextElementSibling;
                if (nextTr) {
                    nextTr.click();
                    /** @type {?} */
                    const nextRowid = nextTr.getAttribute('id').replace(TR_PREFIX, '');
                    if (nextRowid) {
                        this.editRow(nextRowid);
                    }
                }
            });
            if (nextTd) {
                if (hasNoEditor(nextTd)) {
                    /** @type {?} */
                    const tds = tr.querySelectorAll('td');
                    /** @type {?} */
                    let tdIdx = -1;
                    tds.forEach((/**
                     * @param {?} t
                     * @param {?} i
                     * @return {?}
                     */
                    (t, i) => {
                        if (t === nextTd) {
                            tdIdx = i;
                        }
                    }));
                    /** @type {?} */
                    let nextTrEdit = true;
                    while (tdIdx < tds.length) {
                        /** @type {?} */
                        const _ntd = tds[tdIdx];
                        if (hasNoEditor(_ntd)) {
                            tdIdx++;
                        }
                        else {
                            nextTrEdit = false;
                            break;
                        }
                    }
                    if (nextTrEdit) {
                        editNextRow();
                    }
                }
            }
            else {
                editNextRow();
            }
        }
        e.stopPropagation();
    }
    /**
     * @private
     * @return {?}
     */
    bindRowEditorKeydownEvent() {
        if (!this.documentRowEditKeydownHanlder) {
            this.documentRowEditKeydownHanlder = this.render2.listen(document, 'keydown', this.rowEditTabKeydwonEvent.bind(this));
        }
        this.documentClickEndRowEditHandler = this.render2.listen(document, 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (this.pending) {
                return false;
            }
            if (Utils.hasDialogOpen()) {
                return;
            }
            if (this.isRowEditing()) ;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    unbindRowEditorKeydownEvent() {
        // 取消键盘事件
        if (this.documentRowEditKeydownHanlder) {
            this.documentRowEditKeydownHanlder();
            this.documentRowEditKeydownHanlder = null;
        }
        if (this.documentClickEndRowEditHandler) {
            this.documentClickEndRowEditHandler();
            this.documentClickEndRowEditHandler = null;
        }
    }
    //#endregion
    //#region Load Data
    /**
     * @private
     * @param {?} conditions
     * @param {?=} excuteLocaleFilter
     * @return {?}
     */
    _clientFilter(conditions, excuteLocaleFilter = false) {
        // 客户端过滤
        if (excuteLocaleFilter) {
            /** @type {?} */
            const allClientData = this.dfs.getData(true);
            if (conditions && Object.keys(conditions).length) {
                /** @type {?} */
                const _data = this.clientFilterService.executeFilter(allClientData, conditions);
                this.dfs.loadFilterData(_data);
            }
            else {
                this.loadData(allClientData, false, true);
            }
        }
        if (!this.virtualized) {
            this.scrollToTop();
        }
        /** @type {?} */
        const _conditions = this.checkFilterValues(conditions);
        this.filterChanged.emit(_conditions);
    }
    /**
     * @private
     * @param {?} conditions
     * @return {?}
     */
    smartFilterData(conditions) {
        if (this.remoteFilter) { // 服务器端过滤
            // 服务器端过滤
            /** @type {?} */
            let entityFilters = this.clientFilterService.convertSmartFilter2EntityFilter(conditions);
            entityFilters = this.checkFilterValues(entityFilters);
            this.filterChanged.emit(entityFilters);
        }
        else {
            // 客户端过滤
            this._clientFilter(conditions, this.useDefaultFilter);
        }
    }
    // smart fitler 清空查询条件
    /**
     * @param {?=} $event
     * @return {?}
     */
    onClearSmartFilters($event) {
        this.smartFilterResult = { conditions: [], controlData: [] };
        this.conditions = [];
        this.smartFilterData([]);
        this.smartFilterService.clearAll();
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.onFilterBarResize(0);
        }));
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onRemoveSmartFilterItem($event) {
        if ($event) {
            /** @type {?} */
            const e = Object.assign({}, $event);
            e['labelCode'] = $event.fieldCode;
            this.smartFilterService.removeCondition(e, true);
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onFilterBarResize($event) {
        this.filterBarHeight = $event;
        /** @type {?} */
        const smartFilterEl = this.el.nativeElement.querySelector('.f-datagrid-column-drop-panel');
        if (smartFilterEl && !$event) {
            smartFilterEl.style.top = '0px';
        }
        this.dgs.showGridHeader.emit(this.realHeaderHeight);
        this.dgs.smartFilterBarExpand.emit();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onSmartFilterChange($event) {
        const { conditions, filterItem } = $event;
        this.smartFilterService.filterConditionChanged({ conditions, controlData: filterItem, from: 'toolbar' });
        // this.smartFilterData(conditions);
        this.dgs.smartFilterDataChange.emit(filterItem);
    }
    /**
     * @param {?=} conditions
     * @return {?}
     */
    filterData(conditions) {
        if (!conditions) {
            conditions = this.conditions;
        }
        else {
            this.conditions = conditions;
        }
        this.scrollToTop();
        if (this.enableSmartFilter) {
            this.smartFilterData(conditions);
            return;
        }
        if (this.remoteFilter) {
            /** @type {?} */
            const entityFilters = this.clientFilterService.convert2FilterArray(conditions);
            this.filterChanged.emit(entityFilters);
        }
        else {
            // 客户端过滤
            this._clientFilter(conditions, true);
        }
    }
    /**
     * 清空过滤条件
     * @return {?}
     */
    clearCondition() {
        this.dgs.onClearFilter();
        if (!this.enableFilterRow && !this.enableSmartFilter) {
            return;
        }
        /** @type {?} */
        let isFilterChange = false;
        if (this.conditions) {
            if (Array.isArray(this.conditions)) {
                isFilterChange = !!this.conditions.length;
            }
            else {
                isFilterChange = !!Object.keys(this.conditions).length;
            }
        }
        if (!isFilterChange) {
            return;
        }
        this.conditions = this.enableSmartFilter ? [] : {};
        this.clientFilterChanged = true;
        this.filterData(this.conditions);
    }
    /**
     * @private
     * @param {?=} data
     * @param {?=} keepSortState
     * @param {?=} keepScrollPosition
     * @return {?}
     */
    _loadData(data, keepSortState = false, keepScrollPosition = true) {
        if (this.loading) {
            this.closeLoading(!this.pagination);
        }
        data = data || [];
        if (keepScrollPosition && this.scrollInstance && this.scrollInstance.instance) {
            /** @type {?} */
            const lst = this.scrollInstance.instance.lastScrollTop;
            /** @type {?} */
            const lsl = this.scrollInstance.instance.lastScrollLeft;
            this.dfs.updateProperty('scrollInfo', { y: lst, x: lsl });
        }
        else {
            this.dfs.updateProperty('scrollInfo', { y: 0, x: 0 });
        }
        if (this.pagination) {
            this.dfs.setPagination(this.pageIndex, this.pageSize, this.total);
            this.updatePagerOptions();
            if (!this.cd['destroyed']) {
                this.cd.detectChanges();
            }
        }
        // 重新加载数据时，移除所有编辑列
        // this.closeAllCellEditor();
        this.data = data;
        if (keepSortState) {
            if (this.remoteSort) {
                this.dfs.loadData(data);
            }
            else {
                this.dfs.loadData(data, true, true);
            }
        }
        else {
            this.dfs.loadData(data);
        }
        this.setPagerHeight();
        this.dgs.dataSourceChanged();
    }
    /**
     * @param {?=} data
     * @param {?=} keepSortState
     * @param {?=} keepScrollPosition
     * @return {?}
     */
    loadData(data, keepSortState = false, keepScrollPosition = true) {
        this._loadData(data, keepSortState, keepScrollPosition);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    loadVirtualData(data) {
        if (this.groupRows) {
            this.writeConsole('if you using GROUPROWS, please set [virtualized]="false" [virtualizedAsyncLoad]="false"');
            return;
        }
        if (this.virtualizedAsyncLoad) {
            this.dgs.onLoadVirtualData(data);
        }
    }
    /**
     * @param {?} pageIndex
     * @param {?} pageSize
     * @return {?}
     */
    fetchData(pageIndex, pageSize) {
        if (this.restService) {
            this.showLoading();
            /** @type {?} */
            const params = { pageIndex, pageSize };
            if (this.sortName) {
                params['sortName'] = this.sortName;
            }
            if (this.sortOrder) {
                params['sortOrder'] = this.sortOrder;
            }
            return this.restService.getData(this.url, params);
        }
        return of(undefined);
    }
    /**
     * @return {?}
     */
    refresh() {
        this.dfs.refresh();
    }
    /**
     * @return {?}
     */
    reload() {
        this.fetchData(1, this.pageSize).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            if (res) {
                this.pageIndex = 1;
                this.total = res.total;
                this.loadData(res.items);
            }
        }));
    }
    /**
     * 获取当前页数据
     * @return {?}
     */
    getRows() {
        if (this.groupRows || this.virtualized) {
            if (this.pagerOnServer) {
                return this.ds.rows;
            }
            else {
                return this.currentPagerData;
            }
        }
        else {
            if (this.pagerOnServer) {
                return this.data;
            }
            else {
                return this.currentPagerData;
            }
        }
    }
    /**
     * @param {?} groupRowId
     * @return {?}
     */
    getGroupRow(groupRowId) {
        /** @type {?} */
        const _allrows = (this.getRows() || []).filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n[IS_GROUP_ROW_FIELD]));
        /** @type {?} */
        const rowIndex = _allrows.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => n.id == groupRowId));
        return {
            data: _allrows[rowIndex],
            index: rowIndex
        };
    }
    //#endregion
    //#region Pagination
    /**
     * @param {?} pageIndex
     * @param {?=} detectChanges
     * @return {?}
     */
    setPageIndex(pageIndex, detectChanges = true) {
        this.pageIndex = pageIndex;
        this.pagerOpts.currentPage = pageIndex;
        if (detectChanges) {
            this.cd.detectChanges();
        }
    }
    // 更新每页
    /**
     * @param {?} pageList
     * @param {?=} detectChanges
     * @return {?}
     */
    setPageList(pageList, detectChanges = true) {
        this.pageList = pageList;
        this.pagerOpts.pageList = pageList;
        if (detectChanges) {
            this.cd.detectChanges();
        }
    }
    /**
     * @param {?} pageIndex
     * @return {?}
     */
    onPageChange(pageIndex) {
        if (this.lockPagination) {
            return;
        }
        if (this.controlPaginationState) {
            this.setPageIndex(pageIndex, false);
        }
        this.fetchData(pageIndex, this.pageSize).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            if (res) {
                this.loadData(res.items);
            }
        }));
        this.focusRowIndex = -1;
        this.scrollToTop();
        this.pageChanged.emit({ pageIndex, pageSize: this.pageSize });
    }
    /**
     * @param {?} pageSize
     * @return {?}
     */
    onPageSizeChange(pageSize) {
        if (this.lockPagination) {
            return;
        }
        this.focusRowIndex = -1;
        this.scrollToTop();
        this.pageSize = pageSize;
        this.pagerOpts.itemsPerPage = pageSize;
        this.fetchData(1, pageSize).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            if (res) {
                this.pageIndex = 1;
                this.loadData(res.items);
            }
        }));
        this.pageSizeChanged.emit({ pageSize, pageIndex: this.pageIndex });
    }
    /**
     * @param {?} id
     * @return {?}
     */
    onRemoveSelectedItem(id) {
        if (this.dfs.findRowIndex(id) > -1) {
            this.unCheckRow(id);
            this.cd.detectChanges();
        }
        else {
            this.unCheckRow(id, false);
            this.checkValues = this.checkeds.map((/**
             * @param {?} r
             * @return {?}
             */
            r => r.id));
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClearSelectedItem($event) {
        // this.clearAll();
        if (this.selectOnCheck) {
            this.selectValue = '';
        }
        this.clearCheckeds(true);
    }
    //#endregion
    //#region Loading
    /**
     * @return {?}
     */
    showLoading() {
        this.loading = true;
        this.cd.detectChanges();
    }
    /**
     * @param {?=} detectChanges
     * @return {?}
     */
    closeLoading(detectChanges = true) {
        this.loading = false;
        if (detectChanges) {
            this.cd.detectChanges();
        }
    }
    //#endregion
    //#region Dom
    /**
     * @private
     * @param {?} strNum
     * @return {?}
     */
    replacePX2Empty(strNum) {
        if (strNum) {
            return Number.parseInt(strNum.replace('px', ''), 10);
        }
        return 0;
    }
    /**
     * @param {?} cls
     * @param {?} dom
     * @return {?}
     */
    renderCustomCls(cls, dom) {
        if (cls) {
            if (cls[0] === '!') {
                /** @type {?} */
                const _cls = cls.slice(1).split(' ').filter((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => c));
                _cls.forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => {
                    if (c) {
                        this.render2.removeClass(dom, c);
                    }
                }));
            }
            else {
                cls.split(' ').filter((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => c)).forEach((/**
                 * @param {?} c
                 * @return {?}
                 */
                c => {
                    if (c) {
                        this.render2.addClass(dom, c);
                    }
                }));
            }
        }
    }
    /**
     * @param {?} cs
     * @param {?} dom
     * @param {?=} cssRuleText
     * @return {?}
     */
    renderCustomStyle(cs, dom, cssRuleText = null) {
        if (!cs) {
            return;
        }
        if (cs.cls) {
            this.renderCustomCls(cs.cls, dom);
        }
        if (cs.style) {
            if (!cssRuleText) {
                Object.keys(cs.style).forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    if (n.toLowerCase() === 'color' && cs.style[n] && cs.style[n].indexOf('!important') === -1) {
                        cs.style[n] = cs.style[n] + '!important';
                    }
                }));
                cssRuleText = `${this.customStyleKey()} #${dom.id} ${JSON.stringify(cs.style)}`;
            }
            this.dgs.appendCssRules([cssRuleText]);
        }
    }
    /**
     * @param {?} cs
     * @param {?} dom
     * @param {?} cssClassName
     * @return {?}
     */
    renderCustomStyle2(cs, dom, cssClassName) {
        if (!cs) {
            return;
        }
        if (cs.cls && dom) {
            this.renderCustomCls(cs.cls, dom);
        }
        if (cs.style) {
            Object.keys(cs.style).forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if ((n.toLowerCase().indexOf('background') > -1 || n.toLowerCase() === 'color') && cs.style[n] && cs.style[n].indexOf('!important') === -1) {
                    cs.style[n] = cs.style[n] + '!important';
                }
            }));
            /** @type {?} */
            let cssRuleText = `${this.customStyleKey()} .${cssClassName} ${JSON.stringify(cs.style)}`;
            if (cssClassName.indexOf(this.customStyleKey()) > -1) {
                cssRuleText = `${cssClassName} ${JSON.stringify(cs.style)}`;
            }
            this.dgs.appendCssRules([cssRuleText]);
        }
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getBoundingClientRect(el) {
        return el.nativeElement.getBoundingClientRect();
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getElementPadding(el) {
        /** @type {?} */
        const style = getComputedStyle(el);
        return {
            top: this.replacePX2Empty(style.paddingTop),
            left: this.replacePX2Empty(style.paddingLeft),
            bottom: this.replacePX2Empty(style.paddingBottom),
            right: this.replacePX2Empty(style.paddingRight)
        };
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getElementBorderWidth(el) {
        /** @type {?} */
        const style = getComputedStyle(el);
        return {
            top: this.replacePX2Empty(style.borderTopWidth),
            bottom: this.replacePX2Empty(style.borderBottomWidth),
            right: this.replacePX2Empty(style.borderRightWidth),
            left: this.replacePX2Empty(style.borderLeftWidth)
        };
    }
    /**
     * @param {?} field
     * @param {?} data
     * @param {?} formatter
     * @return {?}
     */
    formatData(field, data, formatter) {
        /** @type {?} */
        const value = this.getFieldValue(field, data);
        return this.colFormatSer.format(value, data, formatter);
    }
    /**
     * @param {?} field
     * @param {?} rowData
     * @return {?}
     */
    getFieldValue(field, rowData) {
        return Utils.getValue(field, rowData);
    }
    //#endregion
    //#region Select
    /**
     * @private
     * @return {?}
     */
    canOperateCheckbox() {
        return this.multiSelect && this.showCheckbox;
    }
    /**
     * @param {?} nextColumn
     * @return {?}
     */
    findNextTd(nextColumn) {
        if (!nextColumn) {
            return null;
        }
        /** @type {?} */
        const rowid = TR_ID_PREFIX + this.selectedRow.id;
        /** @type {?} */
        const leftTrID = TR_ID_PREFIX + this.selectedRow.id + '_fixedleft';
        /** @type {?} */
        const rightTrID = TR_ID_PREFIX + this.selectedRow.id + '_fixedright';
        /** @type {?} */
        let _tr = null;
        /** @type {?} */
        let _td = null;
        if (nextColumn.fixed === 'left') {
            // _tr = document.querySelector(leftTrID);
            _tr = Utils.getTrDomById(leftTrID, document);
            if (_tr) {
                _td = _tr.querySelector(`[field="${nextColumn.field}"]`);
            }
        }
        else if (nextColumn.fixed === 'right') {
            // _tr = document.querySelector(rightTrID);
            _tr = Utils.getTrDomById(rightTrID, document);
            if (_tr) {
                _td = _tr.querySelector(`[field="${nextColumn.field}"]`);
            }
        }
        else {
            // _tr = document.querySelector(rowid);
            _tr = Utils.getTrDomById(rowid, document);
            if (_tr) {
                _td = _tr.querySelector(`[field="${nextColumn.field}"]`);
            }
        }
        return _td;
    }
    /**
     * 依据当前字段查询下个字段的TD DOM
     * @param {?} field 当前字段名称
     * @param {?} dir 移动方向
     * @return {?} TD element
     */
    findNextCell(field, dir) {
        /** @type {?} */
        let td = null;
        if (this.currentCell && this.currentCell.cellElement) {
            /** @type {?} */
            const col = this.dfs.getColumn(field);
            /** @type {?} */
            const fixed = col.fixed || '';
            // let cellIndex = this.dfs.getColumnIndex(field, fixed);
            /** @type {?} */
            let cellIndex = this.colGroup.columns.findIndex((/**
             * @param {?} n
             * @return {?}
             */
            n => (n.id && n.id === col.id) || n.field === col.field));
            // if (fixed === 'left' || this.fast) {
            //     if (this.showCheckbox) {
            //         cellIndex += 1;
            //     }
            //     if (this.showLineNumber) {
            //         cellIndex += 1;
            //     }
            // }
            /** @type {?} */
            const currCellEl = this.currentCell.cellElement;
            /** @type {?} */
            const tdSelector = `[field="${field}"]`;
            if (dir === 'up') {
                /** @type {?} */
                const prevTr = this.dgs.findNextTr(currCellEl.parentElement.previousElementSibling, 'up');
                if (prevTr) {
                    td = prevTr.querySelector(tdSelector);
                }
            }
            else if (dir === 'down') {
                /** @type {?} */
                const nextTr = this.dgs.findNextTr(currCellEl.parentElement.nextElementSibling, 'down');
                if (nextTr) {
                    td = nextTr.querySelector(tdSelector);
                }
            }
            else if (dir === 'left') {
                /** @type {?} */
                const nextColumn = this.colGroup.columns[cellIndex - 1];
                if (nextColumn) {
                    td = this.findNextTd(nextColumn);
                }
            }
            else if (dir === 'right') {
                /** @type {?} */
                const nextColumn = this.colGroup.columns[cellIndex + 1];
                if (nextColumn) {
                    td = this.findNextTd(nextColumn);
                }
            }
        }
        return td;
    }
    /**
     * @param {?} dir
     * @param {?} event
     * @return {?}
     */
    selectNextCell(dir, event) {
        /** @type {?} */
        const nextTd = this.findNextCell(this.currentCell.field, dir);
        if (dir === 'up' && !nextTd) {
            return;
        }
        if (nextTd && nextTd.className.indexOf('f-datagrid-cell-rownumber') == -1 && nextTd.className.indexOf('f-datagrid-cell-checkbox') == -1) {
            if (event['code'] === 'Tab' && this.editable && this.editcellWhenTabKeydwon) {
                nextTd['click'].apply(nextTd, [event]);
            }
            else {
                if (nextTd.selectCell) {
                    if (this.selectionMode === 'default') {
                        this.clearCheckeds();
                    }
                    nextTd['selectCell'](event, nextTd);
                }
            }
            // nextTd['selectCell'](event, nextTd);
            return nextTd;
        }
        else {
            /** @type {?} */
            const nextCol = this.colGroup.columns[0];
            /** @type {?} */
            const tdSeletor = `td[field="${nextCol.field}"]`;
            /** @type {?} */
            const tr = this.currentCell.cellElement.parentElement;
            /** @type {?} */
            let _next = tr.nextElementSibling;
            if (dir === 'left') {
                _next = tr.previousElementSibling;
            }
            if (!_next) {
                return;
            }
            // const trDomId = _next.id.replace('_fixedleft','').replace('_fixedright','');
            /** @type {?} */
            const trDomId = Utils.getRowIdByTr(_next);
            /** @type {?} */
            const leftTrSelector = trDomId + '_fixedleft';
            if (_next.id.indexOf('_fixedright') > -1) {
                if (this.colGroup.leftFixed && this.colGroup.leftFixed.length) {
                    // _next = document.querySelector(leftTrSelector);
                    _next = Utils.getTrDomById(leftTrSelector, document);
                }
            }
            if (dir === 'left') {
                if (_next.id.indexOf('_fixedleft') > -1) {
                    // _next = document.querySelector(leftTrSelector);
                    _next = Utils.getTrDomById(leftTrSelector, document);
                }
            }
            /** @type {?} */
            const nextTd = _next.querySelector(tdSeletor);
            if (nextTd && nextTd.selectCell) {
                if (this.selectionMode === 'default') {
                    this.clearCheckeds();
                }
                nextTd.selectCell(event, nextTd);
            }
            /*
            const nextTr = this.dgs.findNextTr(_next, dir === 'left' ? 'up' : 'down');
            if (nextTr && nextTr.tagName === 'TR') {
                // nextTr.children.find(td => td.editCell).editCell();
                let firstEditor = false;
                let i = 0;
                while (!firstEditor) {
                    firstEditor = !!nextTr.children[i].selectCell;
                    if (!firstEditor) {
                        i++;
                    }
                }
                if (nextTr.children[i] && nextTr.children[i].selectCell) {
                    if (this.selectionMode === 'default' ) {
                        this.clearCheckeds();
                    }
                    nextTr.children[i].selectCell(event, nextTr.children[i]);
                }
            }
            */
        }
    }
    /**
     * @param {?} tr
     * @return {?}
     */
    getRowIdByTr(tr) {
        if (tr && tr.className.indexOf('f-datagrid-group-row') > -1) {
            return null;
        }
        // let id = tr.getAttribute('id');
        /** @type {?} */
        let id = Utils.getRowIdByTr(tr);
        if (id == null || id == undefined) {
            return null;
        }
        // id = id.replace('row_', '').replace('_fixedright', '').replace('_fixedleft', '');
        /** @type {?} */
        const rowInfo = this.dfs.findRow(id);
        if (rowInfo) {
            return Object.assign({}, this.dfs.findRow(id), { id });
        }
        return null;
    }
    /**
     * @param {?} index
     * @param {?} data
     * @param {?} id
     * @return {?}
     */
    _beforeSelectRow$(index, data, id) {
        /** @type {?} */
        const beforEventParam = {
            rowIndex: index,
            rowData: data,
            gridInstance: this,
            id: id,
            dr: null
        };
        /** @type {?} */
        let b$ = of(true);
        if (this.beforeSelect) {
            /** @type {?} */
            const rowisSelected = this.dfs.isRowSelected(id);
            if (!rowisSelected) {
                /** @type {?} */
                const _b$ = this.beforeSelect(beforEventParam);
                if (_b$ && _b$.subscribe) {
                    b$ = _b$;
                }
            }
        }
        return b$;
    }
    /**
     * @return {?}
     */
    selectNextRow() {
        if (this.selectedRow) {
            /** @type {?} */
            const tr = this.selectedRow.dr.el.nativeElement;
            if (tr.nextElementSibling) {
                const { id, data, index } = this.getRowIdByTr(tr.nextElementSibling);
                if (id) {
                    this._beforeSelectRow$(index, data, id).subscribe((/**
                     * @param {?} t
                     * @return {?}
                     */
                    (t) => {
                        if (t) {
                            this.selectRow(id, true);
                        }
                    }));
                }
                // tr.nextElementSibling.click();
            }
        }
    }
    /**
     * @return {?}
     */
    selectPrevRow() {
        if (this.selectedRow) {
            /** @type {?} */
            const tr = this.selectedRow.dr.el.nativeElement;
            if (tr.previousElementSibling) {
                // tr.previousElementSibling.click();
                const { id, data, index } = this.getRowIdByTr(tr.previousElementSibling);
                if (id) {
                    this._beforeSelectRow$(index, data, id).subscribe((/**
                     * @param {?} t
                     * @return {?}
                     */
                    (t) => {
                        if (t) {
                            this.selectRow(id, true);
                        }
                    }));
                }
            }
        }
    }
    /**
     * @return {?}
     */
    removeCellSelectedCls() {
        if (this.currentCell && this.currentCell.cellElement) {
            DomHandler.removeClass(this.currentCell.cellElement, CELL_SELECTED_CLS);
            this.render2.removeClass(this.currentCell.cellElement, CELL_EDITING_CLS);
        }
        /** @type {?} */
        const selectedCell = this.el.nativeElement.querySelectorAll('.' + CELL_SELECTED_CLS);
        if (selectedCell.length) {
            selectedCell.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                this.render2.removeClass(n, CELL_SELECTED_CLS);
            }));
        }
    }
    /**
     * 选中行
     * @param {?} id 选中行ID
     * @param {?=} emit 触发select 事件
     * @param {?=} toCurrentPosition 滚动条定位到当前选择中行
     * @return {?}
     */
    selectRow(id, emit = true, toCurrentPosition = false) {
        if (this.selectedRow && this.selectedRow.id === id) {
            if (emit) {
                this.dfs.selectRecord(id);
            }
            if (toCurrentPosition) {
                this.scrollToCurrentRow();
            }
            return;
        }
        /** @type {?} */
        const _selectRow = (/**
         * @return {?}
         */
        () => {
            this.removeCellSelectedCls();
            if (!this.enableSelectRow) {
                return;
            }
            if (!this.multiSelect && this.showCheckbox) {
                this.clearCheckeds(false, false);
            }
            if (this.multiSelect && this.selectionMode === 'default' && !this.enableMorePageSelect) {
                this.clearAll();
            }
            if (id && (!this.selectedRow || this.selectedRow.id != id)) {
                /** @type {?} */
                const row = this.dfs.findRow(id);
                if (row && this.disableRow) {
                    if (this.disableRow(row.data, row.index)) {
                        return;
                    }
                }
                if (emit) {
                    this.dfs.selectRecord(id);
                }
                else {
                    this.dfs.setSelectRow(id, emit);
                    this.selectedRow = this.dfs.getCurrentRow();
                    if (this.checkOnSelect) {
                        this.checkRows([id]);
                    }
                    this.dgs.setSelecedRow.emit({ id, selected: true });
                }
            }
            else {
                if (this.checkOnSelect) {
                    this.checkRows([id]);
                }
            }
            if (toCurrentPosition) {
                this.scrollToCurrentRow();
            }
        });
        if (this.isEditing()) {
            if (this.editMode === 'cell') {
                /** @type {?} */
                const stopEdit = this.currentCell.cellElement.closeEdit();
                if (stopEdit) {
                    stopEdit.subscribe(_selectRow);
                }
            }
            else {
                this.endRowEdit();
                _selectRow();
            }
        }
        else {
            _selectRow();
        }
    }
    /**
     * 滚动条滚动到当前行的位置
     * @return {?}
     */
    scrollToCurrentRow() {
        this.dgs.scrollToCurrentRow.next();
    }
    /**
     * @param {?} id
     * @param {?=} emit
     * @return {?}
     */
    unSelectRow(id, emit = true) {
        if (id) {
            this.closeAllCellEditor();
            if (this.currentCell && this.currentCell.rowId == id) {
                this.cancelSelectCell();
            }
            if (emit) {
                this.dfs.selectRecord(id, false);
            }
            else {
                this.dfs.setSelectRow(id, false);
                this.selectedRow = null;
                this.dgs.setSelecedRow.emit({ id, selected: false });
            }
        }
    }
    /**
     * @return {?}
     */
    selectAllRows() {
        if (this.multiSelect && this.enableSelectRow) {
            this.dfs.selectAll();
        }
    }
    /**
     * @return {?}
     */
    cancelSelectCell() {
        if (this.currentCell) {
            if (this.currentCell.cellElement) {
                this.currentCell.cellElement.cancelSelected();
            }
            if (!this.currentCell.isEditing) {
                this.currentCell = null;
                this.dfs.cancelSelectCell();
            }
        }
    }
    /**
     * @param {?=} excludeIds
     * @return {?}
     */
    clearSelections(excludeIds) {
        this.dfs.clearSelections(excludeIds);
        this.selectedRow = null;
        this.cancelSelectCell();
        this.cd.detectChanges();
    }
    /**
     * @param {?} id
     * @param {?=} emit
     * @return {?}
     */
    checkRow(id, emit = true) {
        if (this.canOperateCheckbox()) {
            if (emit) {
                this.dfs.checkRecord(id);
            }
            else {
                this.checkRows([id]);
            }
        }
    }
    /**
     * 钩选行，不触发选中事件
     * @param {?} ids
     * @param {?=} emit
     * @return {?}
     */
    checkRows(ids, emit = false) {
        if (ids && ids.length) {
            this.dfs.setCheckedRows(ids, true);
            this.dgs.setCheckedRows.next({ ids, checked: true });
            if (this.selectionMode === 'default') {
                this.dfs.updateProperty('selections', this.checkeds);
            }
            // this.cd.detectChanges();
            if (emit) {
                this.checkValues = this.checkeds.map((/**
                 * @param {?} r
                 * @return {?}
                 */
                r => r.id));
                this.checkValuesChange.emit(this.checkValues);
                this.checkedChange.emit(this.checkeds);
            }
            this.updateAllCheckboxStatus();
        }
    }
    /**
     * 取消钩选，不触发选中事件
     * @param {?} ids
     * @param {?=} emit
     * @return {?}
     */
    unCheckRows(ids, emit = false) {
        if (ids && ids.length) {
            this.dfs.setCheckedRows(ids, false);
            this.dgs.setCheckedRows.next({ ids, checked: false });
            // this.cd.detectChanges();
            if (emit) {
                this.checkValues = this.checkeds.map((/**
                 * @param {?} r
                 * @return {?}
                 */
                r => r.id));
                this.checkValuesChange.emit(this.checkValues);
                this.checkedChange.emit(this.checkeds);
            }
            this.updateAllCheckboxStatus();
        }
    }
    /**
     * @param {?=} emit
     * @return {?}
     */
    checkAllRows(emit = true) {
        if (this.canOperateCheckbox()) {
            this.dfs.checkAll();
            this.dgs.checkAll.emit();
            if (emit) {
                this.checkAll.emit();
            }
        }
    }
    /**
     * @param {?} id
     * @param {?=} emit
     * @return {?}
     */
    unCheckRow(id, emit = true) {
        if (this.canOperateCheckbox()) {
            if (this.currentCell && this.currentCell.rowId == id) {
                this.cancelSelectCell();
            }
            if (emit) {
                this.dfs.checkRecord(id, false);
            }
            else {
                this.unCheckRows([id]);
            }
            this.updateAllCheckboxStatus();
        }
    }
    /**
     * 清空钩选行，默认只清空当前页的钩选
     * clearAll: 清空所有 默认为 false; 否则仅清空当前页的钩选数据。
     * @param {?=} clearAll
     * @param {?=} emitUnCheckAll
     * @return {?}
     */
    clearCheckeds(clearAll = false, emitUnCheckAll = true) {
        this.dfs.clearCheckeds(clearAll);
        this.checkValues = [];
        this.cancelSelectCell();
        if (emitUnCheckAll) {
            this.dgs.uncheckAll.emit();
        }
    }
    /**
     * @return {?}
     */
    clearAll() {
        this.selectedRow = null;
        this.checkValues = [];
        this.dfs.clearAll();
        this.dgs.uncheckAll.emit();
        this.updateAllCheckboxStatus();
    }
    //#endregion
    //#region Resize Column
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    getResizeProxyPosLeft(e) {
        /** @type {?} */
        const target = (/** @type {?} */ (e.target));
        /** @type {?} */
        const dgRect = this.getBoundingClientRect(this.dgContainer);
        /** @type {?} */
        const td = target.parentElement;
        /** @type {?} */
        const tdLeft = td.getBoundingClientRect().left;
        /** @type {?} */
        const deltaEdge = td.offsetWidth - (e.pageX - tdLeft);
        this.resizeColumnInfo.proxyLineEdge = deltaEdge;
        this.resizeColumnInfo.startWidth = td.offsetWidth;
        this.resizeColumnInfo.startX = e.pageX;
        this.resizeColumnInfo.left = tdLeft - dgRect.left - 1 + deltaEdge;
        return e.pageX - dgRect.left - 1 + deltaEdge;
    }
    /**
     * @private
     * @param {?=} show
     * @return {?}
     */
    toggleResizeProxy(show = true) {
        /** @type {?} */
        let display = 'block';
        if (!show) {
            display = 'none';
        }
        this.render2.setStyle(this.resizeProxyBg.nativeElement, 'display', display);
        this.render2.setStyle(this.resizeProxy.nativeElement, 'display', display);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onColumnResizeBegin(e) {
        if (this.resizeProxy) {
            this.render2.setStyle(document.body, 'cursor', 'e-resize');
            /** @type {?} */
            const proxy = this.resizeProxy.nativeElement;
            /** @type {?} */
            const proxyPosLeft = this.getResizeProxyPosLeft(e);
            this.render2.setStyle(proxy, 'left', proxyPosLeft + 'px');
            /** @type {?} */
            let top = 0;
            if ((this.enableFilterRow || this.enableSmartFilter) && this.showFilterBar) {
                top += this.filterBarHeight;
            }
            if (this.showRowGroupPanel) {
                top += this.rowGroupPanelHeight;
            }
            this.render2.setStyle(proxy, 'top', `${top}px`);
            if (!this.autoHeight) {
                this.render2.setStyle(proxy, 'height', (this.height - this.pagerHeight) + 'px');
            }
            else {
                /** @type {?} */
                let bottomH = 0;
                if (this.pagination) {
                    bottomH += this.pagerHeight;
                }
                if (this.showFooter) {
                    bottomH += this.footerHeight;
                }
                this.render2.setStyle(proxy, 'height', `calc(100% - ${bottomH}px)`);
            }
            this.toggleResizeProxy();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onColumnResize(e) {
        /** @type {?} */
        const proxy = this.resizeProxy.nativeElement;
        /** @type {?} */
        const dgRect = this.getBoundingClientRect(this.dgContainer);
        /** @type {?} */
        const proxyPosLeft = e.pageX - dgRect.left - 1 + this.resizeColumnInfo.proxyLineEdge;
        if (proxyPosLeft - this.resizeColumnInfo.left > 20) {
            this.render2.setStyle(proxy, 'left', proxyPosLeft + 'px');
        }
        else {
            this.render2.setStyle(proxy, 'left', (this.resizeColumnInfo.left + 20) + 'px');
        }
        e.stopPropagation();
        e.preventDefault();
    }
    /**
     * @param {?} e
     * @param {?} col
     * @return {?}
     */
    onColumnResizeEnd(e, col) {
        this.render2.removeStyle(document.body, 'cursor');
        this.toggleResizeProxy(false);
        this.resizeColumnInfo.proxyLineEdge = 0;
        /** @type {?} */
        let newColWidth = this.resizeColumnInfo.startWidth + e.pageX - this.resizeColumnInfo.startX;
        if (newColWidth < 20) {
            newColWidth = 20;
        }
        if (col.width > newColWidth) {
            /** @type {?} */
            const t = col.width - newColWidth;
            if (!this.fitColumns && this.scrollInstance.elementRef.nativeElement.scrollLeft) {
                /** @type {?} */
                const moveLeft = this.scrollInstance.elementRef.nativeElement.scrollLeft - t;
                this.scrollInstance.scrollToX(moveLeft);
            }
        }
        if (col.width != newColWidth) {
            col.width = newColWidth;
            if (!this.nowrap && this.showFooter) {
                this.setFooterHeight();
            }
            if (this.useControlPanel && this.settingService) {
                this.settingService.saveUserConfig(this.id).subscribe((/**
                 * @return {?}
                 */
                () => {
                    this.dfs.columnResizeEnd();
                    this.dgs.columnResized.emit();
                }));
                return;
            }
            this.dfs.columnResizeEnd();
            this.dgs.columnResized.emit();
            this.updateFixedColumnCssForFastMode(col);
        }
    }
    /**
     * 还原列宽
     * @return {?}
     */
    restituteColumnsSize() {
        this.dfs.resizeColumns(true);
        this.dgs.columnResized.emit();
    }
    /**
     * 单元格内容自适应列宽
     * @param {?} col
     * @param {?} th
     * @return {?}
     */
    sizeToContent(col, th) {
        if (!this.AutoColumnWidthUseDblclick) {
            return false;
        }
        /** @type {?} */
        let longestText = '';
        /** @type {?} */
        const items = this.data;
        for (let i = items.length - 1; i >= 0; i--) {
            // TFS: 356964 20200203
            /** @type {?} */
            let value = Utils.getValue(col.field, items[i]);
            if (value !== 0) {
                value = value || '';
            }
            /** @type {?} */
            let text = '' + value;
            if (col.formatter && value !== undefined) {
                text = this.colFormatSer.format(value, items[i], col.formatter);
            }
            if (Utils.getBLen(text) > Utils.getBLen(longestText)) {
                longestText = text;
            }
            else {
                this.longTextArea.nativeElement.innerHTML = text;
                /** @type {?} */
                const w1 = this.longTextArea.nativeElement.offsetWidth;
                this.longTextArea.nativeElement.innerHTML = longestText;
                /** @type {?} */
                const w2 = this.longTextArea.nativeElement.offsetWidth;
                if (w1 > w2) {
                    longestText = text;
                }
            }
        }
        this.longTextArea.nativeElement.innerHTML = longestText;
        /** @type {?} */
        const maxWidth = this.longTextArea.nativeElement.offsetWidth + 26;
        this.longTextArea.nativeElement.innerHTML = th.nativeElement.innerText;
        /** @type {?} */
        let thMinWidth = this.longTextArea.nativeElement.offsetWidth + 26;
        if (col.sortable) {
            thMinWidth += 24;
        }
        /** @type {?} */
        let newColWidth = (maxWidth > thMinWidth ? maxWidth : thMinWidth);
        /** @type {?} */
        const colIndex = this.flatColumns.findIndex((/**
         * @param {?} c
         * @return {?}
         */
        c => c.field === col.field));
        if (colIndex === this.flatColumns.length - 1) {
            newColWidth += 6;
        }
        if (col.width > newColWidth) {
            /** @type {?} */
            const t = col.width - newColWidth;
            if (this.scrollInstance.elementRef.nativeElement.scrollLeft) {
                /** @type {?} */
                const moveLeft = this.scrollInstance.elementRef.nativeElement.scrollLeft - t;
                this.scrollInstance.scrollToX(moveLeft < 0 ? 0 : moveLeft);
            }
        }
        if (col.width != newColWidth) {
            col.width = newColWidth;
            this.dfs.resizeColumns();
            this.dgs.columnResized.emit();
        }
    }
    //#endregion
    //#region Changes
    /**
     * @return {?}
     */
    getChanges() {
        return this.dfs.getChanges();
    }
    /**
     * @return {?}
     */
    acceptChanges() {
        this.dfs.acceptChanges();
    }
    /**
     * @return {?}
     */
    rejectChanges() {
        this.dfs.rejectChanges();
    }
    //#endregion
    //#region CRUD
    /**
     * @param {?} row
     * @return {?}
     */
    appendRow(row) {
        this.cancelEdit(null);
        this.dfs.appendRow(row);
        this.dataChange.emit(this.dfs.getData());
        this.rowAppended.emit();
    }
    /**
     * @param {?} rowId
     * @param {?} newData
     * @return {?}
     */
    updateRow(rowId, newData) {
        this.dfs.updateRow(rowId, newData);
        // 更新当前数据源中对应的行数据
        this._updateRow(rowId, newData);
        if (this.currentCell && this.currentCell.isEditing && newData) {
            const { column, cellRef } = this.currentCell;
            if (cellRef && column && column.field && column.editor && column.editor.type.toLowerCase() == 'input-group' && Utils.keysInData(column.field, newData)) {
                /** @type {?} */
                const currendRowData = cellRef.rowData;
                /** @type {?} */
                const val = this.commonUtils.getValue(column.field, currendRowData);
                if (cellRef.formControl) {
                    cellRef.formControl.patchValue(val);
                }
            }
        }
        // 更新合计行数据
        this.updateFooterData();
        this.dataChange.emit(this.dfs.getData());
        this.rowUpdated.emit();
        // 启用合并单元格，允许编辑时，合并数据不准确
        if (this.mergeCell) {
            this.refresh();
        }
    }
    /**
     * @private
     * @param {?} rowId
     * @param {?} newData
     * @return {?}
     */
    _updateRow(rowId, newData) {
        /** @type {?} */
        const row = this.getRows().find((/**
         * @param {?} n
         * @return {?}
         */
        (n) => {
            return this.dfs.primaryId(n) === rowId;
        }));
        if (row) {
            if (newData) {
                /** @type {?} */
                const keys = Object.keys(newData);
                keys.forEach((/**
                 * @param {?} field
                 * @return {?}
                 */
                field => {
                    Utils.setValue(field, newData[field], row);
                }));
            }
        }
    }
    /**
     * @param {?} rowId
     * @return {?}
     */
    refreshRow(rowId) {
        /** @type {?} */
        const row = this.dfs.findRow(rowId);
        if (row && row.data) {
            this.dfs.rowUpdate$.emit(row);
        }
        else {
            this.writeConsole('Can not found row by id. id: ' + rowId);
        }
    }
    /**
     * @param {?=} rowId
     * @return {?}
     */
    deleteRow(rowId) {
        this.cancelEdit(rowId, false);
        if (!rowId) {
            if (this.selectValue) {
                rowId = this.selectValue;
            }
            else {
                throw new Error(`删除行时主键标识ID 不能为空。`);
            }
        }
        /** @type {?} */
        const deleteRow = this.dfs.deleteRow(rowId);
        this.dataChange.emit(this.dfs.getData());
        this.currentCell = null;
        this.dfs.updateProperty('currentCell', null);
        this.cd.detectChanges();
        this.rowDeleted.emit(deleteRow);
    }
    /**
     * @return {?}
     */
    validateRow() { }
    /**
     * @return {?}
     */
    insertRow() { }
    //#endregion
    //#region Scrolling
    /**
     * @return {?}
     */
    scrollToLeft() {
        if (this.scrollInstance) {
            this.scrollInstance.scrollToLeft(0, 200);
        }
    }
    /**
     * @return {?}
     */
    scrollToRight() {
        if (this.scrollInstance) {
            this.scrollInstance.scrollToRight(0, 200);
        }
    }
    /**
     * @return {?}
     */
    scrollToTop() {
        if (this.scrollInstance) {
            this.scrollInstance.scrollToTop(0, 100);
            /** @type {?} */
            const scrollInfo = this.dfs.getState().scrollInfo;
            if (scrollInfo) {
                scrollInfo.y = 0;
                this.dfs.updateProperty('scrollInfo', scrollInfo);
            }
        }
    }
    /**
     * @return {?}
     */
    scrollToBottom() {
        if (this.scrollInstance) {
            this.scrollInstance.scrollToBottom(0, 100);
        }
    }
    //#endregion
    /**
     * @private
     * @param {?} cols
     * @param {?} field
     * @param {?=} readonly
     * @return {?}
     */
    _setColumnReadonly(cols, field, readonly = true) {
        if (cols && cols.length && field) {
            /** @type {?} */
            const col = cols.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n.field === field));
            if (col) {
                col.readonly = readonly;
            }
        }
    }
    /**
     * @param {?} field
     * @param {?=} readonly
     * @return {?}
     */
    setColumnReadonly(field, readonly = true) {
        this._setColumnReadonly(this.colGroup.leftFixed, field, readonly);
        this._setColumnReadonly(this.colGroup.rightFixed, field, readonly);
        this._setColumnReadonly(this.colGroup.normalColumns, field, readonly);
    }
    // 是否为多表头
    /**
     * @return {?}
     */
    isMultiHeader() {
        return this.columns && this.columns.length > 1 && Array.isArray(this.columns[1]);
    }
    /**
     * @param {?} fields
     * @param {?=} visible
     * @return {?}
     */
    toggleVisibleColumn(fields, visible = true) {
        if (!this.isMultiHeader()) {
            this.columns.forEach((/**
             * @param {?} cols
             * @return {?}
             */
            (cols) => {
                fields.forEach((/**
                 * @param {?} field
                 * @return {?}
                 */
                field => {
                    /** @type {?} */
                    const col = cols.find((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => c.field === field || c.id === field));
                    if (col) {
                        col.visible = visible;
                    }
                }));
            }));
        }
        else {
            // 多表头
            /** @type {?} */
            const allCols = flatten(this.columns);
            allCols.forEach((/**
             * @param {?} p
             * @return {?}
             */
            p => {
                if (p.origianlColSpan === undefined) {
                    p.origianlColSpan = p.colspan;
                }
            }));
            fields.forEach((/**
             * @param {?} field
             * @return {?}
             */
            field => {
                /** @type {?} */
                const _col = allCols.find((/**
                 * @param {?} col
                 * @return {?}
                 */
                col => col.field === field || col.id === field));
                if (_col) {
                    if (_col.visible === visible) {
                        return;
                    }
                    _col.visible = visible;
                    /** @type {?} */
                    const parents = DatagridColumnsHelper.getParentColumns(_col, allCols);
                    /** @type {?} */
                    const childs = DatagridColumnsHelper.getChildColumns(_col, allCols);
                    childs.forEach((/**
                     * @param {?} c
                     * @return {?}
                     */
                    c => {
                        c.visible = visible;
                    }));
                    if (visible && childs.length) {
                        _col.colspan = _col.origianlColSpan;
                    }
                    /** @type {?} */
                    const _colspan = _col.colspan || 1;
                    parents.forEach((/**
                     * @param {?} p
                     * @return {?}
                     */
                    p => {
                        if (!visible) {
                            p.colspan = p.colspan - _colspan;
                        }
                        else {
                            /** @type {?} */
                            const _childs = allCols.filter((/**
                             * @param {?} n
                             * @return {?}
                             */
                            n => n.parentId === p.id && n.visible));
                            p.colspan = _childs.reduce((/**
                             * @param {?} r
                             * @param {?} c
                             * @return {?}
                             */
                            (r, c) => {
                                r = r + (c.colspan || 1);
                                return r;
                            }), 0);
                        }
                        p.visible = !!p.colspan;
                    }));
                }
            }));
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getColumn(field) {
        /** @type {?} */
        const allCols = flatten(this.columns);
        return allCols.find((/**
         * @param {?} n
         * @return {?}
         */
        n => n.field === field || n.id === field));
    }
    /**
     * @param {?} field
     * @param {?=} reload
     * @return {?}
     */
    showColumn(field, reload = true) {
        if (typeof field === 'string') {
            this.toggleVisibleColumn([field], true);
        }
        else {
            this.toggleVisibleColumn(field, true);
        }
        this.columnsChanged(reload);
    }
    /**
     * @param {?} field
     * @param {?=} reload
     * @return {?}
     */
    hideColumn(field, reload = true) {
        if (typeof field === 'string') {
            this.toggleVisibleColumn([field], false);
        }
        else {
            this.toggleVisibleColumn(field, false);
        }
        this.columnsChanged(reload);
    }
    /**
     * @param {?} field
     * @param {?} columnObject
     * @param {?=} detectChange
     * @return {?}
     */
    updateColumn(field, columnObject, detectChange = true) {
        this.columns.forEach((/**
         * @param {?} cols
         * @return {?}
         */
        (cols) => {
            /** @type {?} */
            let column = cols.find((/**
             * @param {?} col
             * @return {?}
             */
            col => col.field === field));
            if (column) {
                column = Object.assign(column, columnObject);
            }
        }));
        if (detectChange) {
            this.columnsChanged();
        }
    }
    /**
     * @param {?} field
     * @param {?} formatter
     * @param {?=} detectChange
     * @return {?}
     */
    setColumnFormatter(field, formatter, detectChange = true) {
        this.columns.forEach((/**
         * @param {?} cols
         * @return {?}
         */
        (cols) => {
            /** @type {?} */
            const column = cols.find((/**
             * @param {?} col
             * @return {?}
             */
            col => col.field === field));
            if (column) {
                column.formatter = formatter;
            }
        }));
        if (detectChange) {
            this.columnsChanged();
        }
    }
    /**
     * @param {?} field
     * @param {?} formatterOptions
     * @param {?=} detectChange
     * @return {?}
     */
    updateColumnFormatterOptions(field, formatterOptions, detectChange = true) {
        this.columns.forEach((/**
         * @param {?} cols
         * @return {?}
         */
        (cols) => {
            /** @type {?} */
            const column = cols.find((/**
             * @param {?} col
             * @return {?}
             */
            col => col.field === field));
            if (column && column.formatter) {
                /** @type {?} */
                const colFormatter = (/** @type {?} */ (column.formatter));
                colFormatter.options = colFormatter.options || {};
                colFormatter.options = Object.assign(colFormatter.options, formatterOptions || {});
            }
        }));
        if (detectChange) {
            this.columnsChanged();
        }
    }
    /**
     * @param {?} field
     * @param {?} title
     * @param {?=} detectChange
     * @return {?}
     */
    setColumnTitle(field, title, detectChange = true) {
        this.columns.forEach((/**
         * @param {?} cols
         * @return {?}
         */
        (cols) => {
            /** @type {?} */
            const column = cols.find((/**
             * @param {?} col
             * @return {?}
             */
            col => col.field === field));
            if (column) {
                column.title = title;
            }
        }));
        if (detectChange) {
            this.columnsChanged();
        }
    }
    /**
     * 排序
     * @param {?=} sortName 排序字段，如： 'name,age'
     * @param {?=} sortOrder 排序方式，如：'desc, asc'
     * @return {?}
     */
    sort(sortName, sortOrder) {
        if (sortName === null || sortName === '' || sortOrder === null || sortOrder === '') {
            this.clearSort();
        }
        else {
            if (sortName && sortOrder) {
                // this.updateSortInfo(sortName, sortOrder);
                this.sortName = sortName;
                this.sortOrder = sortOrder;
                this.dfs.setSortInfo(this.sortName, this.sortOrder);
            }
            if (!this.remoteSort) {
                this.dfs.clientSort();
            }
            this.onColumnSorted();
        }
    }
    /**
     * @return {?}
     */
    clearSort() {
        this.sortName = '';
        this.sortOrder = '';
        this.dfs.setSortInfo('', '');
        if (!this.remoteSort) {
            if (this.data && this.data.length) {
                this.dfs.clearSort();
            }
        }
        this.onColumnSorted();
    }
    /**
     * @return {?}
     */
    onColumnSorted() {
        /** @type {?} */
        let params = null;
        if (this.sortName && this.sortOrder) {
            /** @type {?} */
            const orders = this.sortOrder.split(',');
            params = this.sortName.split(',').reduce((/**
             * @param {?} r
             * @param {?} n
             * @param {?} i
             * @return {?}
             */
            (r, n, i) => {
                r[n] = orders[i] || 'asc';
                return r;
            }), {});
        }
        if (!this.remoteSort) {
            this.dfs.clientSort();
        }
        this.columnSorted.emit(params);
    }
    /**
     * @param {?} newSortName
     * @param {?} newSortOrder
     * @return {?}
     */
    updateSortInfo(newSortName, newSortOrder) {
        /** @type {?} */
        const sortName = this.sortName;
        /** @type {?} */
        const sortOrder = this.sortOrder;
        /** @type {?} */
        let sortFields = [];
        /** @type {?} */
        let sortOrders = [];
        if (sortName) {
            sortFields = sortName.split(',');
            sortOrders = sortOrder.split(',');
        }
        /** @type {?} */
        const _sortFields = newSortName.split(',');
        /** @type {?} */
        const _sortOrders = newSortOrder.split(',');
        _sortFields.forEach((/**
         * @param {?} nField
         * @param {?} nIndex
         * @return {?}
         */
        (nField, nIndex) => {
            /** @type {?} */
            const colOrder = _sortOrders[nIndex] || 'asc';
            /** @type {?} */
            let newOrder = colOrder;
            /** @type {?} */
            const i = sortFields.findIndex((/**
             * @param {?} n
             * @return {?}
             */
            n => n === nField));
            if (i >= 0) {
                /** @type {?} */
                const _order = sortOrders[i] === 'asc' ? 'desc' : 'asc';
                newOrder = _order;
                if (this.multiSort && newOrder === 'asc') {
                    newOrder = undefined;
                    sortFields.splice(i, 1);
                    sortOrders.splice(i, 1);
                }
                else {
                    sortOrders[i] = _order;
                }
            }
            else {
                if (this.multiSort) {
                    sortFields.push(nField);
                    sortOrders.push(colOrder);
                }
                else {
                    sortFields = [nField];
                    sortOrders = [colOrder];
                }
            }
        }));
        this.sortName = sortFields.join(',');
        this.sortOrder = sortOrders.join(',');
    }
    /**
     * 列设置
     * @param {?} $event
     * @return {?}
     */
    showControlPanel($event) {
        $event.stopPropagation();
        /** @type {?} */
        const self = this;
        if (this.useControlPanel && this.settingService) {
            this.checkSettingHttp();
            this.settingService.show(self);
        }
    }
    /**
     * @return {?}
     */
    checkSettingHttp() {
        if (!this.settingService.httpRestService || !this.settingService.httpRestService.befRepository) {
            /** @type {?} */
            const settingsHttp = this.inject.get(GRID_SETTINGS_HTTP, null);
            this.settingService.httpRestService = settingsHttp;
        }
    }
    /**
     * @param {?=} flag
     * @return {?}
     */
    disableHeader(flag = true) {
        this.dgs.disableHeader.emit(flag);
    }
    /**
     * 获取用户个性化设置
     * @private
     * @param {?} settings
     * @return {?}
     */
    userProfileSetting(settings) {
        const { sortInfo, viewColumns, groupField, columnFormat, expandGroupRows, multiHeaders } = settings;
        /** @type {?} */
        let _sortName;
        /** @type {?} */
        let _sortOrder;
        if (sortInfo) {
            const { sortName, sortOrder } = sortInfo;
            _sortName = sortName;
            _sortOrder = sortOrder;
            if (sortName && sortName.length) {
                this.sortName = sortName.join(',');
                if (sortOrder) {
                    this.sortOrder = sortOrder.join(',');
                }
            }
            this['__sortInfo'] = sortInfo;
        }
        if (this.enableSetMultiHeaders && multiHeaders && (multiHeaders.viewCols || []).length) {
            /** @type {?} */
            const gridInitOptions = this.dfs['_state'].initialOptions;
            /** @type {?} */
            const _cols = this.settingService.getMultiHeaderColumns(multiHeaders.viewCols, gridInitOptions);
            if (_cols) {
                this.columns = _cols;
                this.addControlCol();
            }
        }
        else {
            if (viewColumns && viewColumns.length) {
                this.columns = this.columns.map((/**
                 * @param {?} cols
                 * @return {?}
                 */
                cols => {
                    this.settingService.updateColumnFormat(cols, columnFormat, this);
                    return this.settingService.newVisibleOrderColumns(cols, viewColumns, columnFormat, this);
                }));
                this.addControlCol();
            }
        }
        this.columns.forEach((/**
         * @param {?} cols
         * @return {?}
         */
        cols => {
            cols.forEach((/**
             * @param {?} col
             * @return {?}
             */
            col => {
                if (_sortName && _sortName.length) {
                    /** @type {?} */
                    const i = _sortName.indexOf(col.field);
                    if (i > -1) {
                        col.order = _sortOrder[i];
                    }
                }
                if (!col.field || col.field.indexOf('farris-datagrid-column_') > -1) {
                    col.filter = false;
                }
            }));
        }));
        if (this.groupRows && (groupField !== null && groupField !== undefined)) {
            this.groupField = groupField;
            this.expandGroupRows = expandGroupRows === undefined ? this.expandGroupRows : expandGroupRows;
        }
        this.settingService.setCurrentConfigs(settings);
    }
    // 是否为当前活动的表格
    /**
     * @private
     * @return {?}
     */
    isActived() {
        // 判断grid是否为活动且可见的，避免SPA 下多个grid一起进行相关的操作；比如上下方向键移动
        return DomHandler.hasClass(this.dgContainer.nativeElement, this._active_datagrid_cls) && this.dgContainer.nativeElement.offsetParent;
    }
    // 清理无效的DOM
    /**
     * @private
     * @return {?}
     */
    cleanDom() {
        // 清理 TOOL-TIP
        /** @type {?} */
        const tips = document.querySelectorAll('.datagrid-cell-tooltip');
        if (tips && tips.length) {
            tips.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                n.remove();
            }));
        }
    }
    /**
     * @param {?} col
     * @param {?} rowData
     * @return {?}
     */
    cellIsReadOnly(col, rowData) {
        /** @type {?} */
        let readOnly = false;
        if (this.disableRow) {
            readOnly = this.disableRow(rowData);
        }
        if (!readOnly) {
            if (col.readonly !== undefined) {
                if (typeof col.readonly === 'boolean') {
                    readOnly = col.readonly;
                }
                else if (typeof col.readonly === 'function') {
                    readOnly = col.readonly(rowData);
                }
            }
        }
        return readOnly;
    }
    /**
     * @private
     * @return {?}
     */
    groupFieldChanged() {
        this.columnsChanged();
        if (this.settingService) {
            this.checkSettingHttp();
            this.settingService.saveUserConfig(this.id).subscribe();
        }
        this.groupFieldChange.emit({ newGroupField: this.groupField, grid: this });
    }
    /**
     * @param {?} field
     * @return {?}
     */
    removeGroupField(field) {
        /** @type {?} */
        const fields = this.groupField.split(',');
        /** @type {?} */
        const delIdx = fields.indexOf(field);
        if (delIdx > -1) {
            fields.splice(delIdx, 1).join(',');
        }
        this.groupField = fields.join(',');
        this.toggleVisibleColumn([field], true);
        this.groupFieldChanged();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    clearAllGrouppingField($event) {
        this.showLoading();
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const fields = this.groupField.split(',');
            this.groupField = '';
            this.toggleVisibleColumn(fields, true);
            this.groupFieldChanged();
            this.closeLoading();
        }));
    }
    /**
     * @param {?} groupFields
     * @return {?}
     */
    setGroupFields(groupFields) {
        this.groupField = groupFields;
        this.columnsChanged();
    }
    /**
     * @param {?=} active
     * @return {?}
     */
    activeDataGrid(active = true) {
        /** @type {?} */
        const grids = document.querySelectorAll('.f-datagrid.datagrid-active');
        if (grids.length) {
            grids.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                this.render2.removeClass(n, this._active_datagrid_cls);
            }));
        }
        if (active) {
            this.render2.addClass(this.dgContainer.nativeElement, this._active_datagrid_cls);
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDatagridContainerFocus($event) {
        if (!this.disabled) {
            this.activeDataGrid();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setShadowColumnForFastMode() {
        if (this.fast) {
            /** @type {?} */
            const fixedLeft = this.flatColumns.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.fixed === 'left'));
            /** @type {?} */
            const fixedRight = this.flatColumns.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n.fixed === 'right'));
            if (fixedLeft && fixedLeft.length) {
                /** @type {?} */
                let leftWidthTotal = 0;
                if (this.showCheckbox) {
                    leftWidthTotal += 36;
                }
                if (this.showLineNumber) {
                    leftWidthTotal += this.lineNumberWidth;
                }
                fixedLeft.forEach((/**
                 * @param {?} n
                 * @param {?} index
                 * @return {?}
                 */
                (n, index) => {
                    leftWidthTotal += index ? fixedLeft[index - 1].width : 0;
                    n.left = leftWidthTotal;
                }));
                fixedLeft[fixedLeft.length - 1]['leftShadowCol'] = true;
                this.dfs.getColumn(fixedLeft[fixedLeft.length - 1].field)['leftShadowCol'] = true;
            }
            if (fixedRight && fixedRight.length) {
                fixedRight[0]['rightShadowCol'] = true;
                /** @type {?} */
                let rightWidthTotal = fixedRight.reduce((/**
                 * @param {?} r
                 * @param {?} c
                 * @return {?}
                 */
                (r, c) => {
                    return r + c.width;
                }), 0);
                fixedRight.forEach((/**
                 * @param {?} n
                 * @param {?} index
                 * @return {?}
                 */
                (n, index) => {
                    rightWidthTotal -= n.width;
                    n.right = rightWidthTotal;
                }));
                this.dfs.getColumn(fixedRight[0].field)['rightShadowCol'] = true;
            }
        }
    }
    // 单元对齐方式样式动态生成
    /**
     * @private
     * @return {?}
     */
    setCellStyle() {
        if (!this.flatColumns || !this.flatColumns.length) {
            return;
        }
        /** @type {?} */
        const cssarr = [];
        /** @type {?} */
        const verticalAlign = (/**
         * @param {?} column
         * @return {?}
         */
        (column) => {
            /** @type {?} */
            let va = 'center';
            switch (column.valign) {
                case 'top':
                    va = 'flex-start';
                    break;
                case 'bottom':
                    va = 'flex-end';
                    break;
                default:
                    va = 'center';
                    break;
            }
            return va;
        });
        /** @type {?} */
        const horizontalAlign = (/**
         * @param {?} column
         * @return {?}
         */
        (column) => {
            /** @type {?} */
            let ha = 'flex-start';
            if (column.align === 'right') {
                ha = 'flex-end';
            }
            else if (column.align === 'center') {
                ha = 'center';
            }
            return ha;
        });
        this.setShadowColumnForFastMode();
        this.flatColumns.forEach((/**
         * @param {?} col
         * @return {?}
         */
        col => {
            /** @type {?} */
            const css = `${this.customStyleKey()} .cell-text-align__${col.field.replace(/\./g, '_')} {align-items: ${verticalAlign(col)}, justify-content: ${horizontalAlign(col)}}`;
            cssarr.push(css);
            if (this.fast) {
                if (col.fixed === 'left' || col.fixed === 'right') {
                    /** @type {?} */
                    let fixed = `${this.customStyleKey()} .f-datagrid-fast__fixed-${col.fixed}[field="${col.field}"]{`;
                    if (col.fixed === 'left') {
                        fixed += `left: ${col.left}px}`;
                    }
                    if (col.fixed === 'right') {
                        fixed += `right: ${col.right}px}`;
                    }
                    cssarr.push(fixed);
                }
            }
        }));
        this.dgs.appendCssRules(cssarr);
    }
    /**
     * @private
     * @param {?} col
     * @return {?}
     */
    updateFixedColumnCssForFastMode(col) {
        if (this.fast) {
            // update css.
            /** @type {?} */
            const colIndex = this.flatColumns.findIndex((/**
             * @param {?} n
             * @return {?}
             */
            n => n.field === col.field));
            /** @type {?} */
            const nextColumn = this.flatColumns[colIndex + 1];
            this.setShadowColumnForFastMode();
            if (nextColumn && nextColumn.fixed) {
                /** @type {?} */
                const ruleName = `${this.customStyleKey()} .f-datagrid-fast__fixed-${nextColumn.fixed}[field="${nextColumn.field}"]`;
                /** @type {?} */
                const stylecss = ruleName + '{' + nextColumn.fixed + ':' + nextColumn[nextColumn.fixed] + 'px}';
                this.dgs.appendCssRules([stylecss]);
            }
        }
    }
    /**
     * @param {?} groupRowIndex
     * @return {?}
     */
    expandGroupRow(groupRowIndex) {
        this.dgs.toggleGroupRow$.emit({ expand: true, groupRowIndex });
    }
    /**
     * @param {?} groupRowIndex
     * @return {?}
     */
    collapseGroupRow(groupRowIndex) {
        this.dgs.toggleGroupRow$.emit({ expand: false, groupRowIndex });
    }
    /**
     * @return {?}
     */
    expandAllGroupRows() {
        this.dgs.toggleAllGroupRows$.emit({ expand: true });
    }
    /**
     * @return {?}
     */
    collapseAllGroupRows() {
        this.dgs.toggleAllGroupRows$.emit({ expand: false });
    }
    // #382788 
    /**
     * @private
     * @param {?} conditions
     * @return {?}
     */
    checkFilterValues(conditions) {
        /** @type {?} */
        const _conditions = cloneDeep(conditions);
        if (this.enableSmartFilter) {
            /** @type {?} */
            const filterFields = Array.from(new Set(_conditions.map((/**
             * @param {?} n
             * @return {?}
             */
            n => n.FilterField))));
            filterFields.forEach((/**
             * @param {?} n
             * @return {?}
             */
            (n) => {
                /** @type {?} */
                const col = this.dfs.getColumn(n);
                if (col && col.dataType === 'datetime') {
                    /** @type {?} */
                    const dateFilters = _conditions.filter((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => f.FilterField === n));
                    /** @type {?} */
                    const contrlData = this.smartFilterService.controlData.find((/**
                     * @param {?} ctrl
                     * @return {?}
                     */
                    ctrl => ctrl.labelCode == n));
                    /** @type {?} */
                    const val = dateFilters[0].Value;
                    if (val.indexOf(':') === -1) {
                        if (dateFilters.length === 1) {
                            dateFilters[0].Value = val + ' 00:00:00';
                            // 非区间
                            if (contrlData.value.single) {
                                dateFilters[0].Compare = Compare.GreaterOrEqual;
                                /** @type {?} */
                                const less = cloneDeep(dateFilters[0]);
                                less.Value = val + ' 23:59:59';
                                less.Compare = Compare.LessOrEqual;
                                /** @type {?} */
                                const index = _conditions.findIndex((/**
                                 * @param {?} f
                                 * @return {?}
                                 */
                                f => f.FilterField === n));
                                _conditions.splice(index + 1, 0, less);
                            }
                            else {
                                if (contrlData.value.endValue) {
                                    dateFilters[0].Value = val + ' 23:59:59';
                                }
                            }
                        }
                        else {
                            dateFilters[0].Value = dateFilters[0].Value + ' 00:00:00';
                            dateFilters[1].Value = dateFilters[1].Value + ' 23:59:59';
                        }
                    }
                }
            }));
        }
        return _conditions;
    }
    /**
     * @return {?}
     */
    getActionColumn() {
        // 操作列id 由 列表标识_caozuolie
        return flatten(this.dfs.getState().initialOptions.designerColumns).find((/**
         * @param {?} n
         * @return {?}
         */
        (n) => n.id && n.id.indexOf('_caozuolie') > -1));
    }
    /**
     * @return {?}
     */
    hideActionColumn() {
        /** @type {?} */
        const czl = this.getActionColumn();
        if (czl) {
            this.hideColumn(czl.field);
        }
    }
    /**
     * @return {?}
     */
    showActionColumn() {
        /** @type {?} */
        const czl = this.getActionColumn();
        if (czl) {
            this.showColumn(czl.field);
        }
    }
    /**
     * 支持全局设置表头、合计行、数据行、行号列宽、复选框列宽
     * 分页条高度可通过配置样式实现，如：
     *  .f-datagrid-pager {
     * height: 60px!important;
     * }
     *
     * @param {?} sizeConfig
     * @return {?}
     */
    applyNewSize(sizeConfig) {
        if (!sizeConfig || Array.isArray(sizeConfig) || typeof sizeConfig === 'boolean') {
            this.writeConsole('传入的参数类型不匹配！The parameter type is incorrect!', 'warn');
            return;
        }
        /** @type {?} */
        const _maxNum = 100;
        // 默认值
        /** @type {?} */
        const defautlValues = {
            'headerHeight': 35,
            'footerHeight': 31,
            'rowHeight': 31,
            'checkboxColumnWidth': 36,
            'lineNumberWidth': 36,
            'filterRowHeight': 40
        };
        // 有效属性名称
        /** @type {?} */
        const props = ['headerHeight', 'footerHeight', 'rowHeight',
            'checkboxColumnWidth', 'lineNumberWidth', 'filterRowHeight'];
        /** @type {?} */
        const keys = Object.keys(sizeConfig);
        if (keys && keys.length) {
            // 清理不支持的属性；
            keys.forEach((/**
             * @param {?} k
             * @return {?}
             */
            k => {
                if (props.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n === k))) {
                    /** @type {?} */
                    let v = sizeConfig[k];
                    if (v == null || isNaN(v)) {
                        delete sizeConfig[k];
                    }
                    else {
                        if (typeof v === 'string' && !!parseInt(v, 10)) {
                            v = parseInt(v, 10);
                        }
                        else if (typeof v === 'number') {
                            v = Math.floor(v);
                        }
                        // 值设值
                        if (isNaN(v) || v <= 0 || v < defautlValues[k]) {
                            sizeConfig[k] = defautlValues[k];
                        }
                        else {
                            sizeConfig[k] = v > _maxNum ? _maxNum : v;
                        }
                    }
                }
                else {
                    delete sizeConfig[k];
                }
            }));
        }
        /** @type {?} */
        const propKeys = Object.keys(sizeConfig);
        if (propKeys.length) {
            this.useThemes = false;
            Object.assign(this, sizeConfig);
            this._footerRowHeight = this.footerHeight;
            /** @type {?} */
            const minRowHeight = `min_row_height_${this.rowHeight}`;
            this.dgs.removeCssRule(`${this.customStyleKey()} .${minRowHeight}`);
            this.renderCustomStyle2({ style: { "min-height": this.rowHeight + 'px', height: this.rowHeight + 'px' } }, null, minRowHeight);
            /** @type {?} */
            const minFooterRowHeight = `min_footer_row_height_${this._footerRowHeight}`;
            this.dgs.removeCssRule(`${this.customStyleKey()} .${minFooterRowHeight}`);
            this.renderCustomStyle2({ style: { "min-height": `${this._footerRowHeight}px`, height: this.rowHeight + 'px' } }, null, minFooterRowHeight);
            this.dfs['updateState'](sizeConfig, false);
            of(1).pipe(debounceTime(200)).subscribe((/**
             * @return {?}
             */
            () => {
                this.setHeaderHeight();
                this.setRowHeight();
                this.setFooterHeight();
                this.columnsChanged();
                if (!this.nowrap) {
                    this.dgs.cellContentWrapChanged.emit();
                }
            }));
        }
    }
}
DatagridComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-datagrid',
                template: "<!--\r\n * @Author: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @Date: 2019-08-10 11:02:50\r\n * @LastEditors: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @LastEditTime: 2019-11-18 15:48:39\r\n * @QQ: 1055818239\r\n * @Version: v0.0.1\r\n -->\r\n\r\n<div #datagridContainer *ngIf=\"!useHtmlTable\"  tabindex=\"0\" style=\"outline: 0;\" hidefocus=\"true\" class=\"f-datagrid\" [ngStyle]=\"gridSize\"  [attr.id]=\"id\"\r\n    [class.f-datagrid-rowhover]=\"rowHover\" [class.f-datagrid-bordered]=\"showBorder\" [class.f-datagrid-wrap]=\"!nowrap\" [class.f-datagrid-strip]=\"striped\"\r\n    [class.f-datagrid-mergecell]=\"mergeCell\" [class.f-datagrid-enable-highlight]=\"enableHighlightCell\" [class.f-datagrid-fast]=\"fast\" \r\n    [class.highlight-allowedit-cell]=\"enableEditCellStyle && editable\" [class.scrollbar-allways-show]=\"scrollBarShowMode === 'allways'\" [class.scroolbar-arrows]=\"showScrollArrow\"\r\n    [class.f-datagrid-sm]=\"sizeType === 'sm'\" [class.f-datagrid-lg]=\"sizeType === 'lg'\" [class.f-datagrid-xl]=\"sizeType === 'xl'\"\r\n    (focus)=\"onDatagridContainerFocus($event)\" >\r\n    <div class=\"f-datagrid-column-drop-panel d-flex flex-row\" *ngIf=\"showRowGroupPanel\"\r\n        [style.height.px]=\"rowGroupPanelHeight\" [style.top.px]=\"showFilterBar ? (filterBarHeight): 0\"\r\n        [attr.placeholder]=\"groupField ? '': groupRowPanelPlaceholder\" [style.pointer-events]=\"editable ? 'none': ''\">\r\n        <div class=\"row-group-fields flex-fill\" drop-column style=\"display: inline-block!important;\">\r\n            <div class=\"group-field smooth-dnd-draggable-wrapper\" *ngFor=\"let f of groupFields$ | async\">{{ dfs.getColumn(f)?.title }}\r\n                <span class=\"f-icon f-icon-x\" title=\"{{ 'datagrid.groupRow.removeColumn'| locale }}\" (click)=\"removeGroupField(f)\"></span>\r\n            </div>\r\n        </div>\r\n        <button class=\"f-datagrid-clear-group-field btn btn-light ml-auto\"\r\n        title=\"{{'datagrid.groupRow.clearTip' | locale}}\" (click)=\"clearAllGrouppingField($event)\" [style.display]=\"groupField ? '' : 'none'\">\r\n            <span class=\"f-icon f-icon-remove\"></span> {{'datagrid.groupRow.clear' | locale}}\r\n        </button>\r\n    </div>\r\n    \r\n    <filter-toolbar #filterText *ngIf=\"enableFilterRow && showFilterBar\"></filter-toolbar>\r\n    <smart-filter-toolbar #smartfiltertoolbar *ngIf=\"enableSmartFilter && showFilterBar\"\r\n    [height]=\"filterBarHeight\"\r\n    [filterData]=\"smartFilterResult?.controlData || []\" \r\n    (clearFilters)=\"onClearSmartFilters($event)\"\r\n    (removeFilter)=\"onRemoveSmartFilterItem($event)\"\r\n    [padding]=\"showBorder && filterBarHeight ? '3px': ''\"\r\n    (resize)=\"onFilterBarResize($event)\"\r\n    (filterChange)=\"onSmartFilterChange($event)\"></smart-filter-toolbar>\r\n\r\n    <datagrid-header class=\"d-flex flex-fill\" *ngIf=\"showHeader\" #header [fast]=\"fast\"\r\n    [columns]=\"columns\" [columnsGroup]=\"colGroup\" [height]=\"realHeaderHeight\"\r\n    [style.height.px]=\"realHeaderHeight\" style=\"position: relative;width:100%;\" \r\n    [enableDragColumn]=\"enableDragColumn\" [wrapHeader]=\"headerWrap\"\r\n    [enableFilterRow]=\"enableFilterRow\" [scrollbarMode]=\"scrollBarShowMode\"></datagrid-header>\r\n\r\n\r\n    <datagrid-footer [height]=\"footerHeight\" [width]=\"footerWidth\" [columnsGroup]=\"colGroup\" [position]=\"'top'\"\r\n    [columns]=\"colGroup?.normalColumns\" [data]=\"footerData | async\" \r\n    [hasFixedColumns]=\"colGroup?.leftFixed && colGroup?.leftFixed?.length\" [fast]=\"fast\"\r\n    *ngIf=\"(footerPosition==='top' || footerPosition === 'both') && showFooter && ((ds && ds.rows && ds.rows.length) || (footerData | async).length)\"></datagrid-footer>\r\n\r\n    <datagrid-body [columnsGroup]=\"colGroup\" [data]=\"ds.rows | paginate: pagerOpts\" (dataChange)=\"setCurrentPagerData($event)\"\r\n        [startRowIndex]=\"ds.index\" [checkedRows]=\"checkedRows\" cell-tooltip [canvasWidth]=\"colGroup?.totalWidth\"\r\n        [topHideHeight]=\"ds.top\" [bottomHideHeight]=\"ds.bottom\" [footerHeight]=\"footerHeight\"\r\n        [scrollBarMode]=\"scrollBarShowMode\" [contextMenuItems]=\"contextMenus\"  [fast]=\"fast\"></datagrid-body>\r\n\r\n    <datagrid-footer [height]=\"footerHeight\" [width]=\"footerWidth\" [columnsGroup]=\"colGroup\" [position]=\"'bottom'\"\r\n    [columns]=\"colGroup?.normalColumns\" [data]=\"footerData | async\"  [fast]=\"fast\"\r\n    [hasFixedColumns]=\"colGroup?.leftFixed && colGroup?.leftFixed?.length\" \r\n    *ngIf=\"(footerPosition==='bottom' || footerPosition === 'both') && showFooter && ((ds && ds.rows && ds.rows.length) || (footerData | async).length)\"></datagrid-footer>\r\n    \r\n    <datagrid-pager *ngIf=\"pagination\" #dgPager \r\n        [showPageList]=\"showPageList\"\r\n        [id]=\"pagerOpts.id\" [locked]=\"lockPagination\"\r\n        [showPageInfo]=\"showPageInfo\"\r\n        [viewMode]=\"pagerViewMode\"\r\n        [showPageNumber] = \"showPageNumber\"\r\n        [maxSize]=\"pagerLabelSize\"\r\n        [showSelectedList]=\"showSelectedList && multiSelect\"\r\n        [selectedData]=\"checkedRows\"\r\n        [showGotoInput]=\"showGotoInput\"\r\n        (pageChange)=\"onPageChange($event)\"\r\n        (pageSizeChange)=\"onPageSizeChange($event)\"\r\n        (removeSelectedItem)=\"onRemoveSelectedItem($event)\"\r\n        (clearSelectedItem)=\"onClearSelectedItem($event)\"\r\n        [listItemFormatter]=\"selectedItemFormatter\"\r\n        [contentTemplate]=\"pagerContentTemplate\"\r\n        [data]=\"footerData | async\"\r\n        [pagerPos]=\"pagerPos\"\r\n        ></datagrid-pager>\r\n\r\n    <div class=\"f-datagrid-resize-bg\" #resizeProxyBg></div>\r\n    <div #resizeProxy class=\"f-datagrid-resize-proxy\" *ngIf=\"resizeColumn\"></div>\r\n    \r\n    <datagrid-loading *ngIf=\"loading\"></datagrid-loading>\r\n    <div style=\"position: absolute; left: -1000px; top: -1000px;visibility: hidden;\" #longTextArea></div>\r\n    <div class=\"f-datagrid-disabled\" style=\"position: absolute;\r\n        background: #fff;\r\n        height: 100%;\r\n        width: 100%;\r\n        z-index: 99;\r\n        opacity: .3;\" *ngIf=\"disabled\">\r\n    </div>\r\n</div>\r\n\r\n\r\n<div #datagridContainer\r\nclass=\"f-datagrid f-datagrid-htmltable\" [attr.id]=\"id\"\r\n[class.f-datagrid-rowhover]=\"rowHover\"\r\n[class.f-datagrid-bordered]=\"showBorder\"\r\n[class.f-datagrid-wrap]=\"!nowrap\"\r\n[class.f-datagrid-strip]=\"striped\" \r\n[class.f-datagrid-md]=\"sizeType === 'md'\"\r\n[class.f-datagrid-sm]=\"sizeType === 'sm'\" [class.f-datagrid-lg]=\"sizeType === 'lg'\" [class.f-datagrid-xl]=\"sizeType === 'xl'\"\r\n*ngIf=\"useHtmlTable\" style=\"border-right: 0px; border-bottom: 0px; overflow: auto\">\r\n\r\n    <auto-height [columnsGroup]=\"colGroup\" [columns]=\"columns\" [data]=\"ds.rows\"></auto-height>\r\n</div>\r\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    DatagridFacadeService,
                    DatagridService,
                    DatagridSmartFilterService
                ],
                exportAs: 'datagrid',
                styles: [`.f-datagrid-header table{
            background-color: #F1F3F7;
        }
        .scrollbar-allways-show .ps.ps--active-x > .ps__rail-x {
            margin-right: 0px!important;
        }
        .scrollbar-allways-show .ps.ps--active-y > .ps__rail-y {
            margin-bottom: 0px!important;
        }
        .scrollbar-allways-show .ps.ps--active-x.ps--active-y > .ps__rail-x {
            margin-right: 18px!important;
        }
        .scrollbar-allways-show .ps.ps--active-x.ps--active-y > .ps__rail-y {
            margin-bottom: 18px!important;
        }

        `]
            }] }
];
/** @nocollapse */
DatagridComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Injector },
    { type: NgZone },
    { type: DatagridFacadeService },
    { type: DatagridService },
    { type: ApplicationRef },
    { type: DomSanitizer },
    { type: Renderer2 }
];
DatagridComponent.propDecorators = {
    fast: [{ type: Input }],
    pos: [{ type: HostBinding, args: ['style.position',] }],
    hostCls: [{ type: HostBinding, args: ['class.f-datagrid-full',] }],
    autoHeightCls: [{ type: HostBinding, args: ['class.f-datagrid-auto-height',] }],
    useThemes: [{ type: Input }],
    id: [{ type: Input }],
    useHtmlTable: [{ type: Input }],
    autoHeight: [{ type: Input }],
    maxHeight: [{ type: Input }],
    showBorder: [{ type: Input }],
    striped: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    showHeader: [{ type: Input }],
    headerHeight: [{ type: Input }],
    headerWrap: [{ type: Input }],
    showFooter: [{ type: Input }],
    footerHeight: [{ type: Input }],
    footerDataFrom: [{ type: Input }],
    footerTemplate: [{ type: Input }],
    footerComponentType: [{ type: Input }],
    footerPosition: [{ type: Input }],
    footerStyler: [{ type: Input }],
    rowHeight: [{ type: Input }],
    sizeType: [{ type: Input }],
    fit: [{ type: Input }],
    fitColumns: [{ type: Input }],
    autoFitColumns: [{ type: Input }],
    disabled: [{ type: Input }],
    scrollBarShowMode: [{ type: Input }],
    scrollBarOptions: [{ type: Input }],
    showScrollArrow: [{ type: Input }],
    resizeColumn: [{ type: Input }],
    showLineNumber: [{ type: Input }],
    lineNumberTitle: [{ type: Input }],
    lineNumberWidth: [{ type: Input }],
    checkboxColumnWidth: [{ type: Input }],
    rowHover: [{ type: Input }],
    clickToEdit: [{ type: Input }],
    lockPagination: [{ type: Input }],
    pagination: [{ type: Input }],
    pagerContentTemplate: [{ type: Input }],
    pagerPos: [{ type: Input }],
    pagerViewMode: [{ type: Input }],
    pagerOnServer: [{ type: Input }],
    pageList: [{ type: Input }],
    pageIndex: [{ type: Input }],
    pageSize: [{ type: Input }],
    pagerHeight: [{ type: Input }],
    showPageList: [{ type: Input }],
    showPageInfo: [{ type: Input }],
    showPageNumber: [{ type: Input }],
    pagerLabelSize: [{ type: Input }],
    showGotoInput: [{ type: Input }],
    enableMorePageSelect: [{ type: Input }],
    showSelectedList: [{ type: Input }],
    selectedItemFormatter: [{ type: Input }],
    cellTipTimer: [{ type: Input }],
    controlPaginationState: [{ type: Input }],
    total: [{ type: Input }],
    enableSelectRow: [{ type: Input }],
    multiSelect: [{ type: Input }],
    showCheckbox: [{ type: Input }],
    showAllCheckbox: [{ type: Input }],
    onlySelectSelf: [{ type: Input }],
    checkOnSelect: [{ type: Input }],
    selectOnCheck: [{ type: Input }],
    selectionMode: [{ type: Input }],
    keepSelect: [{ type: Input }],
    useBlankWhenDataIsEmpty: [{ type: Input }],
    emptyDataHeight: [{ type: Input }],
    emptyMessage: [{ type: Input }],
    emptyTemplate: [{ type: Input }],
    emptyComponentType: [{ type: Input }],
    idField: [{ type: Input }],
    url: [{ type: Input }],
    data: [{ type: Input }],
    footerData: [{ type: Input }],
    endEditByInvalid: [{ type: Input }],
    columns: [{ type: Input }],
    fields: [{ type: Input }],
    nowrap: [{ type: Input }],
    virtualized: [{ type: Input }],
    virtualizedAsyncLoad: [{ type: Input }],
    rowStyler: [{ type: Input }],
    editMode: [{ type: Input }],
    editable: [{ type: Input }],
    enableEditCellStyle: [{ type: Input }],
    selectOnEditing: [{ type: Input }],
    editorHeight: [{ type: Input }],
    remoteSort: [{ type: Input }],
    sortName: [{ type: Input }],
    sortOrder: [{ type: Input }],
    multiSort: [{ type: Input }],
    hoverRowCls: [{ type: Input }],
    enableDragColumn: [{ type: Input }],
    rowGroupPanelHeight: [{ type: Input }],
    groupRows: [{ type: Input }],
    groupFooter: [{ type: Input }],
    expandGroupRows: [{ type: Input }],
    groupFooterStyler: [{ type: Input }],
    groupSummaryPosition: [{ type: Input }],
    groupCellColSpan: [{ type: Input }],
    groupField: [{ type: Input }],
    showGroupColumn: [{ type: Input }],
    groupFormatter: [{ type: Input }],
    groupStyler: [{ type: Input }],
    showRowGroupPanel: [{ type: Input }],
    AutoColumnWidthUseDblclick: [{ type: Input }],
    disableRow: [{ type: Input }],
    useDefaultFilter: [{ type: Input }],
    enableSmartFilter: [{ type: Input }],
    enableFilterRow: [{ type: Input }],
    remoteFilter: [{ type: Input }],
    showFilterBar: [{ type: Input }],
    filterBarHeight: [{ type: Input }],
    filterRowHeight: [{ type: Input }],
    conditions: [{ type: Input }],
    selectValue: [{ type: Input }],
    checkValues: [{ type: Input }],
    selectValues: [{ type: Input }],
    mergeCell: [{ type: Input }],
    mergeFields: [{ type: Input }],
    enableClientSortForMergeCell: [{ type: Input }],
    useControlPanel: [{ type: Input }],
    enableSimpleMode: [{ type: Input }],
    controlPanelMode: [{ type: Input }],
    enableScheme: [{ type: Input }],
    defaultSchemeName: [{ type: Input }],
    enableSetMultiHeaders: [{ type: Input }],
    maxMultiHeaders: [{ type: Input }],
    showConfirmWhenSchemeChanged: [{ type: Input }],
    stopPropagation: [{ type: Input }],
    closeOtherGridEditor: [{ type: Input }],
    clearSelectionsWhenDataIsEmpty: [{ type: Input }],
    enableContextMenu: [{ type: Input }],
    contextMenus: [{ type: Input }],
    beforeShowContextMenus: [{ type: Input }],
    selectValueChange: [{ type: Output }],
    checkValuesChange: [{ type: Output }],
    selectValuesChange: [{ type: Output }],
    beforeEdit: [{ type: Input }],
    beginEdit: [{ type: Output }],
    afterEdit: [{ type: Input }],
    endEdit: [{ type: Output }],
    cancelEdited: [{ type: Output }],
    scrollY: [{ type: Output }],
    pageSizeChanged: [{ type: Output }],
    pageChanged: [{ type: Output }],
    loadSuccess: [{ type: Output }],
    emptyData: [{ type: Output }],
    filterChanged: [{ type: Output }],
    beforeSelect: [{ type: Input }],
    beforeUnselect: [{ type: Input }],
    beforeCheck: [{ type: Input }],
    beforeUncheck: [{ type: Input }],
    beforeSortColumn: [{ type: Input }],
    beforeLoad: [{ type: Input }],
    enableHighlightCell: [{ type: Input }],
    checkedRowsDataFromSource: [{ type: Input }],
    editcellWhenTabKeydwon: [{ type: Input }],
    beforeClickCell: [{ type: Output }],
    dblclickRow: [{ type: Output }],
    selectChanged: [{ type: Output }],
    unSelect: [{ type: Output }],
    selectAll: [{ type: Output }],
    unSelectAll: [{ type: Output }],
    scrollYLoad: [{ type: Output }],
    checked: [{ type: Output }],
    unChecked: [{ type: Output }],
    checkAll: [{ type: Output }],
    unCheckAll: [{ type: Output }],
    checkedChange: [{ type: Output }],
    columnSorted: [{ type: Output }],
    rowClick: [{ type: Output }],
    rowAppended: [{ type: Output }],
    rowDeleted: [{ type: Output }],
    rowUpdated: [{ type: Output }],
    dataChange: [{ type: Output }],
    lastCellEnterHandler: [{ type: Output }],
    groupFieldChange: [{ type: Output }],
    columnMoved: [{ type: Output }],
    cellClick: [{ type: Output }],
    resized: [{ type: Output }],
    dgColumns: [{ type: ContentChildren, args: [DatagridColumnDirective,] }],
    dgPager: [{ type: ViewChild, args: ['dgPager',] }],
    resizeProxy: [{ type: ViewChild, args: ['resizeProxy',] }],
    resizeProxyBg: [{ type: ViewChild, args: ['resizeProxyBg',] }],
    dgContainer: [{ type: ViewChild, args: ['datagridContainer',] }],
    longTextArea: [{ type: ViewChild, args: ['longTextArea',] }],
    smartFilterToolbar: [{ type: ViewChild, args: ['smartfiltertoolbar',] }],
    exitRowEditingWhenBodyClick: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridSmartFilterComponent {
    /**
     * @param {?} render
     * @param {?} el
     * @param {?} zone
     * @param {?} inject
     * @param {?} filterPanelService
     * @param {?} smartFilterSer
     * @param {?} dg
     */
    constructor(render, el, zone, inject, filterPanelService, smartFilterSer, dg) {
        this.render = render;
        this.el = el;
        this.zone = zone;
        this.inject = inject;
        this.filterPanelService = filterPanelService;
        this.smartFilterSer = smartFilterSer;
        this.dg = dg;
        this.filterData = null;
        this.disabled = false;
        this.smartFilterDataChanged$ = null;
        this.removeFilter$ = null;
        this.clearAllFilter$ = null;
        this.smartFilterEvents = [];
        this.idService = this.inject.get(IdService, null);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.removeFilter$) {
            this.removeFilter$ = this.smartFilterSer.removeFilter.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e && e.labelCode === this.column.field) {
                    this.filterData = null;
                    this.render.removeClass(this.el.nativeElement, 'active');
                }
            }));
            this.smartFilterEvents.push(this.removeFilter$);
        }
        if (!this.clearAllFilter$) {
            this.clearAllFilter$ = this.smartFilterSer.clearAllFilter.subscribe((/**
             * @return {?}
             */
            () => {
                this.filterData = null;
                this.render.removeClass(this.el.nativeElement, 'active');
            }));
            this.smartFilterEvents.push(this.clearAllFilter$);
        }
        if (this.dg && !this.smartFilterDataChanged$) {
            this.smartFilterDataChanged$ = this.dg.dgs['smartFilterDataChange'].subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e && this.column.field === e.fieldCode) {
                    this.filterData.value = e.value;
                    this.filterData.control.single = e.control.single;
                }
            }));
            this.smartFilterEvents.push(this.smartFilterDataChanged$);
        }
        this.dg.dgs.clearFilter.subscribe((/**
         * @return {?}
         */
        () => {
            this.filterData = null;
            this.dg.smartFilterResult = { controlData: [], conditions: [] };
            this.smartFilterSer.clearAll();
            this.render.removeClass(this.el.nativeElement, 'active');
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.filterPanelRef) {
            this.filterPanelService.hidePanel();
            this.filterPanelRef = null;
        }
        if (this.smartFilterEvents && this.smartFilterEvents.length) {
            this.smartFilterEvents.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                n.unsubscribe();
                n = null;
            }));
            this.smartFilterEvents = [];
        }
    }
    /**
     * @private
     * @return {?}
     */
    getFilterData() {
        const { field, title } = this.column;
        if (!this.filterData) {
            this.filterData = this.smartFilterSer.controlData.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n.id === field));
        }
        if (!this.filterData) {
            this.filterData = {
                id: field,
                labelCode: field,
                code: field,
                name: title,
                control: this.smartFilterSer.getColumnFilterData(this.column),
                placeHolder: '',
                value: {
                    value: ''
                }
            };
        }
        // tfs 578285
        if (this.filterData.value && this.filterData.control.controltype.indexOf('flexible') > -1) {
            if (this.filterData.value.single) {
                delete this.filterData.value.startValue;
                delete this.filterData.value.endValue;
            }
            else {
                this.filterData.value.value = '';
            }
        }
        return cloneDeep(this.filterData);
    }
    /**
     * @private
     * @param {?} $event
     * @return {?}
     */
    getPanelPosition($event) {
        /** @type {?} */
        let x = $event.pageX - 33;
        /** @type {?} */
        const y = $event.pageY + 9;
        /** @type {?} */
        const targetRect = $event.target.getBoundingClientRect();
        /** @type {?} */
        let moveArrow = 0;
        if (window.innerWidth - x < 380) {
            /** @type {?} */
            const i = 380 - (window.innerWidth - x);
            x = x - i - 20;
            moveArrow = targetRect.left - x;
        }
        return { x, y, moveArrow };
    }
    /**
     * @private
     * @return {?}
     */
    hideFilterPanel() {
        if (this.filterPanelRef) {
            this.filterPanelService.hidePanel();
            this.filterPanelRef = null;
            if (!this.filterData || (this.filterData.control.controltype === 'bool-check' ? !this.filterData.value.value : !this.filterData.valueText)) {
                this.render.removeClass(this.el.nativeElement, 'active');
            }
        }
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    clearColumnFilter(e) {
        this.filterData = null;
        this.hideFilterPanel();
        this.smartFilterSer.removeCondition(e);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    showFilterPanel($event) {
        $event.stopPropagation();
        this.render.addClass(this.el.nativeElement, 'active');
        const { x, y, moveArrow } = this.getPanelPosition($event);
        this.filterPanelRef = this.filterPanelService.showPanel({
            left: x,
            top: y,
            item: this.getFilterData(),
            panelExtendTemplate: this.column.sortable ? this.sortTmp : null,
            localStorageKey: 'smartfilter_' + this.dg.dgs.createConfigKey(this.dg.id),
            target: $event.target
        });
        if (moveArrow) {
            /** @type {?} */
            const arrowEl = this.filterPanelRef['el'].querySelector('.f-filter-panel-arrow');
            if (arrowEl) {
                this.render.setStyle(arrowEl, 'left', `${moveArrow}px`);
            }
        }
        this.filterPanelRef.dataChange.subscribe((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            if (this.filterData && this.filterData.id == item.id) {
                if (item.value && item.value.single !== undefined) {
                    this.filterData.value = item.value;
                    this.filterData.control.single = item.value.single;
                }
            }
        }));
        this.filterPanelRef.hidePanel.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        e => {
            this.hideFilterPanel();
        }));
        this.filterPanelRef.filterSubmit.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        e => {
            if (e.filter && e.filter.length) {
                this.filterData = e.item || null;
                this.hideFilterPanel();
                this.smartFilterSer.filterConditionChanged({ conditions: e.filter, controlData: e.item, from: 'panel' });
            }
            else {
                this.clearColumnFilter(e.item);
            }
        }));
        this.filterPanelRef.clearFilter.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.clearColumnFilter(e);
        }));
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClick($event) {
        $event.stopPropagation();
        if (this.disabled) {
            return;
        }
        this.showFilterPanel($event);
        return false;
    }
    /**
     * @param {?} $event
     * @param {?} order
     * @return {?}
     */
    onSort($event, order) {
        $event.stopPropagation();
        if (this.column.order === order) {
            this.column.order = '';
        }
        else {
            this.column.order = order;
        }
        /** @type {?} */
        const sortName = this.dg.sortName;
        /** @type {?} */
        const sortOrder = this.dg.sortOrder;
        /** @type {?} */
        let sortFields = [];
        /** @type {?} */
        let sortOrders = [];
        if (sortName) {
            sortFields = sortName.split(',');
            sortOrders = sortOrder.split(',');
        }
        /** @type {?} */
        let newOrder = this.column.order;
        /** @type {?} */
        const i = sortFields.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => n === this.column.field));
        if (i >= 0) {
            if (newOrder === '') {
                newOrder = undefined;
                sortFields.splice(i, 1);
                sortOrders.splice(i, 1);
            }
            else {
                sortOrders[i] = newOrder;
            }
        }
        else {
            if (this.dg.multiSort) {
                sortFields.push(this.column.field);
                sortOrders.push(newOrder);
            }
            else {
                sortFields = [this.column.field];
                sortOrders = [newOrder];
            }
        }
        this.hideFilterPanel();
        this.dg.sortName = sortFields.join(',');
        this.dg.sortOrder = sortOrders.join(',');
        this.dg.dfs.setSortInfo(this.dg.sortName, this.dg.sortOrder);
        this.dg.beforeSortColumn(this.dg.sortName, this.dg.sortOrder, this.dg).subscribe((/**
         * @return {?}
         */
        () => {
            this.dg.onColumnSorted();
        }));
    }
}
DatagridSmartFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-smart-filter, [datagrid-smart-filter]',
                template: "<ng-template #sort>\r\n    <div class=\"f-filter-panel-sort-wrapper f-filter-panel-sort-wrapper-hasfilter\">\r\n        <div class=\"f-filter-panel-sort\">\r\n            <div class=\"panel-sort-up panel-sort-item\" [class.active]=\"column?.order === 'asc'\" (click)=\"onSort($event, 'asc')\">\r\n                <span class=\"panel-sort-item-icon f-icon f-icon-col-ascendingorder\"></span>\r\n                <span class=\"panel-sort-item-text\">{{ 'datagrid.settings.asc' | locale: '\u5347\u5E8F' }}</span>\r\n            </div>\r\n            <div class=\"panel-sort-down panel-sort-item\" [class.active]=\"column?.order === 'desc'\"  (click)=\"onSort($event, 'desc')\">\r\n                <span class=\"panel-sort-item-icon f-icon f-icon-col-descendingorder\"></span>\r\n                <span class=\"panel-sort-item-text\">{{ 'datagrid.settings.desc' | locale: '\u964D\u5E8F' }}</span>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</ng-template>",
                providers: [
                    FilterPanelService
                ]
            }] }
];
/** @nocollapse */
DatagridSmartFilterComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone },
    { type: Injector },
    { type: FilterPanelService },
    { type: DatagridSmartFilterService },
    { type: DatagridComponent, decorators: [{ type: Optional }] }
];
DatagridSmartFilterComponent.propDecorators = {
    column: [{ type: Input }],
    filterData: [{ type: Input }],
    disabled: [{ type: Input }],
    sortTmp: [{ type: ViewChild, args: ['sort',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridSmartFilterModule {
}
DatagridSmartFilterModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DatagridSmartFilterComponent
                ],
                imports: [
                    FilterPanelModule,
                    LocaleModule.forRoot(),
                ],
                exports: [
                    DatagridSmartFilterComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormatCellDataPipe {
    /**
     * @param {?} cfs
     * @param {?=} injector
     */
    constructor(cfs, injector) {
        this.cfs = cfs;
        this.injector = injector;
        this.localeId = 'ZH-CHS';
        this.localeId = this.injector.get(LOCALE_ID);
    }
    /**
     * @param {?} col
     * @param {?} rowData
     * @param {?=} groupFooter
     * @param {?=} footer
     * @return {?}
     */
    transform(col, rowData, groupFooter = false, footer = false) {
        if (rowData && col && col.field) {
            /** @type {?} */
            const value = Utils.getValue(col.field, rowData);
            if (col.editor && col.editor.options && col.editor.options.isPassword && !col.formatter) {
                return value ? '******' : '';
            }
            /** @type {?} */
            let formatterFn = col.formatter;
            if (groupFooter) {
                formatterFn = col.groupFooter ? col.groupFooter.formatter : undefined;
            }
            else if (footer) {
                formatterFn = col.footer ? col.footer.formatter : undefined;
                if (typeof formatterFn === 'object') {
                    if (!formatterFn.options) {
                        /** @type {?} */
                        const opts = { type: formatterFn.type, options: formatterFn };
                        formatterFn = opts;
                    }
                }
            }
            if (!formatterFn) {
                /** @type {?} */
                let resoultStr = value;
                if (col.isMultilingualField) {
                    resoultStr = this.getMultilingualValue(value);
                }
                else {
                    if (value !== null && value !== undefined && value !== '0' && typeof value === 'string') {
                        this.getDatagridInstance();
                        if (value.indexOf('\n') > -1) {
                            // return value.replace(/\n/g, '<br>');
                            if (this.dataGrid && this.dataGrid.nowrap) {
                                resoultStr = value.replace(/\n/g, ' ');
                            }
                        }
                        this.setFooterCellTitle(resoultStr, footer, col.field);
                    }
                    // value.replace(/ /g, '&ensp;');
                }
                return this.setPlaceHolderWhenEnableEditCellStyle(col, resoultStr, rowData, groupFooter || footer);
            }
            else {
                if (formatterFn) {
                    if (formatterFn.type === 'number') {
                        if (!formatterFn.options || !Object.keys(formatterFn.options).length) {
                            formatterFn.options = {
                                thousand: ',',
                                precision: 2
                            };
                        }
                    }
                    if (formatterFn.type === 'datetime') {
                        if (formatterFn.options) {
                            if (col.editor && col.editor.options) {
                                const { dateRange, dateRangeDatesDelimiter } = col.editor.options;
                                formatterFn.options = Object.assign({ dateRange, dateRangeDatesDelimiter }, formatterFn.options);
                            }
                        }
                    }
                    if (formatterFn.type === 'timeago') {
                        if (formatterFn.options) {
                            formatterFn.options.locale = formatterFn.options.locale || this.localeId;
                        }
                        else {
                            formatterFn.options = {
                                locale: this.localeId
                            };
                        }
                    }
                }
                this.getDatagridInstance();
                /** @type {?} */
                let r = '';
                if (this.dataGrid) {
                    r = this.cfs.format(value, rowData, formatterFn, { utils: this.dataGrid.commonUtils, locale: this.localeId });
                    this.setFooterCellTitle(r, footer, col.field);
                    return this.setPlaceHolderWhenEnableEditCellStyle(col, r, rowData, groupFooter || footer);
                }
                else {
                    r = this.cfs.format(value, rowData, formatterFn, { locale: this.localeId });
                    this.setFooterCellTitle(r, footer, col.field);
                    return r;
                }
            }
        }
        return '';
    }
    /**
     * @private
     * @param {?} text
     * @param {?} isFooter
     * @param {?} field
     * @return {?}
     */
    setFooterCellTitle(text, isFooter, field) {
        if (text && isFooter && this.elRef) {
            /** @type {?} */
            const span = this.elRef.nativeElement.querySelector(`td[field="${field}"] .f-datagrid-footer-cell`);
            if (span) {
                span.title = text;
            }
        }
    }
    // 获取多语数据
    /**
     * @private
     * @param {?} valObj
     * @return {?}
     */
    getMultilingualValue(valObj) {
        if (valObj && typeof valObj === 'object' && Object.keys(valObj).length > 0) {
            if (this.injector) {
                this.localeService = this.injector.get(LocaleService);
            }
            if (this.localeService) {
                /** @type {?} */
                const localeId = this.localeService.localeId;
                return Utils.getMultilingualValue(valObj, localeId);
            }
            else {
                return valObj['zh-CHS'];
            }
        }
        else {
            return '';
        }
    }
    // 启用标识可编辑单元格时，内容为空时设置提示语
    /**
     * @private
     * @param {?} col
     * @param {?} val
     * @param {?} rowData
     * @param {?} isFooter
     * @return {?}
     */
    setPlaceHolderWhenEnableEditCellStyle(col, val, rowData, isFooter) {
        this.getDatagridInstance();
        if (this.dataGrid) {
            /*
            if (!this.dataGrid.editable || (val !== null && val !== undefined && val !== '') || isFooter || this.cellIsReadOnly(col, rowData)) {
                if (this.elRef) {
                    const span = this.elRef.nativeElement.querySelector('.cell-text-box');
                    if (span && span.className.indexOf('cell-empty') > -1) {
                        span.className = span.className.replace('cell-empty', ' ');
                    }
                }

                return val;
            }
*/
            if (this.dataGrid.enableEditCellStyle) {
                if (!this.dataGrid.editable || (val !== null && val !== undefined && val !== '') || isFooter || this.cellIsReadOnly(col, rowData)) {
                    if (this.elRef) {
                        /** @type {?} */
                        const span = this.elRef.nativeElement.querySelector('.cell-text-box');
                        if (span && span.className.indexOf('cell-empty') > -1) {
                            span.className = span.className.replace('cell-empty', ' ');
                        }
                    }
                    return val;
                }
                if (this.elRef) {
                    /** @type {?} */
                    const span = this.elRef.nativeElement.querySelector('.cell-text-box');
                    if (span && span.className.indexOf('cell-empty') === -1) {
                        span.className = span.className + ' cell-empty';
                    }
                }
                return Utils.getWhenEmptyText(col, this.localeId);
            }
            return val;
        }
        return val;
    }
    /**
     * @private
     * @return {?}
     */
    getDatagridInstance() {
        if (!this.dataGrid) {
            this.dataGrid = this.injector.get(DatagridComponent, null);
        }
        if (!this.elRef) {
            this.elRef = this.injector.get(ElementRef, null);
        }
    }
    /**
     * @param {?} col
     * @param {?} rowData
     * @return {?}
     */
    cellIsReadOnly(col, rowData) {
        return this.dataGrid.cellIsReadOnly(col, rowData);
    }
}
FormatCellDataPipe.decorators = [
    { type: Pipe, args: [{ name: 'formatCellData', pure: false },] }
];
/** @nocollapse */
FormatCellDataPipe.ctorParameters = () => [
    { type: ColumnFormatService },
    { type: Injector, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridBodyComponent {
    /**
     * @param {?} injector
     * @param {?} app
     * @param {?} dg
     * @param {?} cd
     * @param {?} el
     */
    constructor(injector, app, dg, cd, el) {
        this.injector = injector;
        this.app = app;
        this.dg = dg;
        this.cd = cd;
        this.el = el;
        // 自动高度时，禁用纵向滚动条
        this.psConfig = { swipeEasing: false, minScrollbarLength: 15, handlers: ['click-rail', 'drag-thumb', 'wheel', 'touch'], suppressScrollY: this.dg.autoHeight && this.dg.maxHeight ? false : this.dg.autoHeight };
        this.scrollTop = 0;
        this.scrollLeft = 0;
        this.deltaTopHeight = 0;
        // wheelHeight = 0;
        this.wheelWidth = 0;
        this._fixedRightScrollLeft = 0;
        this.maxScrollLeft = 0;
        this.showRightShadow = false;
        this.footerHeight = 0;
        // 虚拟加载
        this.topHideHeight = 0;
        this.bottomHideHeight = 0;
        this.startRowIndex = 0;
        this.dataChange = new EventEmitter();
        this.scrollBarMode = 'auto';
        this.checkedRows = [];
        /**
         * 性能优化版，默认为 false
         */
        this.fast = false;
        this.visibleContextMenus = [];
        this.currentRowId = undefined;
        this._hoverRowIndex = -1;
        this.subscriptions = [];
        this.minRowBuffer = 3;
        this.vScrollDir = 1;
        this.rowsCache = {};
        this.lastRenderedScrollTop = 0;
        this.lastRenderedScrollLeft = 0;
        this.prevScrollTop = 0;
        this.prevScrollLeft = 0;
        this.rows = [];
        this.blankTopHeight = 0;
        this.blankBottomHeight = 0;
        this.cellContentFormatter = null;
        // 当启用多选且允许多选中，列表不能编辑时，取选中后禁止触发body 的click 事件
        this.__triggerBodyClickEvent = true;
        this.destroy$ = new Subject();
        this._onMouseClick = null;
        this._scrollTimer = 0;
        this._scrollXTimer = 0;
        this.ro = null;
        this.resizeObserverTimer = 0;
        this._clickCellWeakMap = new WeakMap();
        this.onBeforeShowContextMenu = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            // row_1_fixedleft  row_1  row_1_fixedright
            const { contextMenuDom, event } = e;
            if (event.target.closest('.datagrid-editor')) {
                return of({ show: false });
            }
            /** @type {?} */
            let rowID = event.target.id;
            if (contextMenuDom) {
                // 排除分组行、分组合计行
                if (contextMenuDom.className.indexOf('f-datagrid-group-row') === -1 && contextMenuDom.className.indexOf('f-datagrid-group-footer') === -1) {
                    rowID = Utils.getRowIdByTr(contextMenuDom);
                    /** @type {?} */
                    const rowData = this.dfs.findRow(rowID);
                    /** @type {?} */
                    const focusTargetWidth = this.viewportW > this.totalWidth ? this.totalWidth : this.viewportW;
                    /** @type {?} */
                    const td = event.target.closest('td');
                    /** @type {?} */
                    let colInfo = null;
                    if (td) {
                        /** @type {?} */
                        const fieldName = td.getAttribute('field');
                        colInfo = fieldName ? this.dfs.getColumn(fieldName) : null;
                    }
                    /** @type {?} */
                    let beforeShowContextMenus$ = of(true);
                    if (this.dg.beforeShowContextMenus) {
                        /** @type {?} */
                        const showContextMenu = this.dg.beforeShowContextMenus({ rowid: rowID, data: rowData.data, grid: this.dg, column: colInfo });
                        if (typeof showContextMenu === 'boolean') {
                            beforeShowContextMenus$ = of(showContextMenu);
                        }
                        else {
                            if (showContextMenu['subscribe']) {
                                beforeShowContextMenus$ = showContextMenu;
                            }
                        }
                    }
                    return beforeShowContextMenus$.pipe(switchMap((/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        /** @type {?} */
                        const params = { rowid: rowID, data: rowData.data, grid: this.dg, column: colInfo };
                        if (typeof e === 'object') {
                            const { show: isShow, customData } = e;
                            return of({ show: isShow, data: Object.assign(params, { customData: customData ? customData : null }), focusTargetWidth });
                        }
                        else {
                            return of({ show: e, data: params, focusTargetWidth });
                        }
                    })));
                }
            }
            return of({ show: false });
        });
        this.dfs = this.injector.get(DatagridFacadeService);
        this.dgs = this.injector.get(DatagridService);
        this.ngZone = this.injector.get(NgZone);
        this.render = this.injector.get(Renderer2);
        /** @type {?} */
        const columnFormatService = this.injector.get(ColumnFormatService);
        this.cellContentFormatter = new FormatCellDataPipe(columnFormatService, this.injector);
    }
    /**
     * @return {?}
     */
    get fixedRightScrollLeft() {
        return this._fixedRightScrollLeft;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set fixedRightScrollLeft(val) {
        this._fixedRightScrollLeft = val;
    }
    /**
     * @return {?}
     */
    get hoverRowIndex() {
        return this._hoverRowIndex;
    }
    /**
     * @param {?} rowIdx
     * @return {?}
     */
    set hoverRowIndex(rowIdx) {
        this._hoverRowIndex = rowIdx;
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    get selectedRows() {
        return this.dg.selections;
    }
    //////////////////////////////////////////////////////////////////////////
    /**
     * @return {?}
     */
    get scrollbarXHeight() {
        if (this.dg && this.ps && this.ps.instance) {
            /** @type {?} */
            const h = this.dg.scrollBarShowMode === 'allways' && this.ps.instance['scrollbarXActive'] ? 22 : 0;
            if (this.ps.instance['scrollbarYActive'] && h) {
                return h + 18; // + (this.dg.showScrollArrow && this.ps.instance['scrollbarYActive'] ? 18 : 0);
            }
        }
    }
    /**
     * @return {?}
     */
    get scrollbarYWidth() {
        if (this.dg && this.ps && this.ps.instance) {
            return this.dg.scrollBarShowMode === 'allways' && this.ps.instance['scrollbarYActive'] && this.showRightShadow ? 18 : 0;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.listenSubjects();
        this.dg.scrollInstance = this.ps;
        /** @type {?} */
        const s1 = this.dgs.showGridHeader.subscribe((/**
         * @param {?} headerHeight
         * @return {?}
         */
        headerHeight => {
            this.updateContainerSize(headerHeight);
        }));
        this.subscriptions.push(s1);
        /** @type {?} */
        const s10 = this.dgs.footerPositionChanged.subscribe((/**
         * @return {?}
         */
        () => {
            this.updateContainerSize();
        }));
        this.subscriptions.push(s10);
        /** @type {?} */
        const s2 = this.dgs.rowHeightChanged.subscribe((/**
         * @return {?}
         */
        () => {
            this.cd.detectChanges();
        }));
        this.subscriptions.push(s2);
        /** @type {?} */
        const s3 = this.dfs.clientSort$.subscribe((/**
         * @return {?}
         */
        () => {
            this.checkScrollbarPosition(true);
            this.cd.detectChanges();
            // this.dg.columnSorted.emit();
        }));
        this.subscriptions.push(s3);
        /** @type {?} */
        const s5 = this.dg.dgs.columnsChanged.pipe(delay(50)).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e && e.scrollToLeft) {
                this.ps.elementRef.nativeElement.scrollTo(0, 0);
                this.ps.scrollToLeft(0, 100);
            }
        }));
        this.subscriptions.push(s5);
        this.viewScrollContainer.nativeElement.addEventListener('click', this._onMouseClick = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.onMouseClick(e);
        }));
        if (!this.dg.nowrap) {
            this.dgs.dataloaded.subscribe((/**
             * @return {?}
             */
            () => {
                this.updateRowHeight();
            }));
        }
    }
    /**
     * @private
     * @param {?=} headerHeight
     * @return {?}
     */
    updateContainerSize(headerHeight) {
        /** @type {?} */
        const hh = headerHeight || this.dg.realHeaderHeight;
        this.setPositionTop(hh);
        this.height = this.dg.height - this.top;
        this.bodyStyle = this.getBodyStyle();
        this.cd.detectChanges();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.data && !changes.data.isFirstChange()) {
            this.bodyStyle = this.getBodyStyle();
            this.dfs.setCurrentPageData(changes.data.currentValue);
            /** @type {?} */
            const isDiffrentDataSource = !!changes.data.currentValue.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => !n['__group__'])).map((/**
             * @param {?} n
             * @return {?}
             */
            n => n.id)).filter((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                return !changes.data.previousValue.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => !n['__group__'])).find((/**
                 * @param {?} p
                 * @return {?}
                 */
                p => p.id === n));
            })).length;
            /** @type {?} */
            const isSameLength = changes.data.currentValue.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => !n['__group__'])).length >= changes.data.previousValue.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => !n['__group__'])).length;
            this.onDataChanged(isSameLength, isDiffrentDataSource);
            if (!changes.data.currentValue || !changes.data.currentValue.length) {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.setPositionTop(this.dg.realHeaderHeight);
                }));
            }
        }
        if (changes.footerHeight !== undefined && !changes.footerHeight.isFirstChange()) {
            this.bodyStyle = this.getBodyStyle();
        }
        if (changes.scrollBarMode !== undefined && !changes.scrollBarMode.isFirstChange()) {
            if (this.ps && this.ps.instance && this.scrollBarMode === 'allways' && this.ps.instance.scrollbarYActive) {
                this.rightFixedWidth += this.showRightShadow ? 18 : 0;
            }
            else {
                this.rightFixedWidth = this.columnsGroup.rightFixedWidth;
            }
            if (this.dg.scrollBarShowMode === 'allways' && this.ps && this.ps.instance && this.ps.instance.scrollbarXActive) {
                this.blankBottomHeight += 22;
            }
        }
        if (changes.showScrollArrow && !changes.showScrollArrow.isFirstChange()) {
            this.ps && this.ps.update();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.cellContentFormatter = null;
        this.dg.scrollInstance = null;
        this.destroySubscriptions();
        this.viewScrollContainer.nativeElement.removeEventListener('click', this._onMouseClick);
        if (this.ro) {
            this.ro.unobserve(this.viewScrollContainer.nativeElement);
            this.ro.disconnect();
        }
        if (this.resizeObserverTimer) {
            clearTimeout(this.resizeObserverTimer);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.ro = new ResizeObserver((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (this.viewScrollContainer.nativeElement.offsetParent) {
                if (this.resizeObserverTimer) {
                    clearTimeout(this.resizeObserverTimer);
                }
                this.resizeObserverTimer = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.updateCanvasHeight();
                    if (this.scrollBarMode === 'allways') {
                        this.ps.update();
                    }
                    // this.setFixedRightWidth();
                    this.cd.detectChanges();
                    this.dgs.scrollbarUpdate.emit({ scrollbarRef: this.ps.instance, rightWidth: this.rightFixedWidth, showRightShadow: this.showRightShadow });
                }), 100);
            }
        }));
        this.ro.observe(this.viewScrollContainer.nativeElement);
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
    }
    /**
     * @private
     * @param {?} headerHeight
     * @return {?}
     */
    setPositionTop(headerHeight) {
        this.top = headerHeight;
        if ((this.dg.enableFilterRow || this.dg.enableSmartFilter) && this.dg.showFilterBar) {
            this.top += this.dg.filterBarHeight;
        }
        if (this.dg.showRowGroupPanel) {
            this.top += this.dg.rowGroupPanelHeight;
        }
        if (this.dg.showFooter && (this.dg.footerPosition === 'top' || this.dg.footerPosition === 'both')) {
            // headerHeight 已包括过滤行的高度 tfs 542471
            if (this.data && this.data.length) {
                this.top += this.dg.footerHeight;
            }
        }
    }
    /**
     * @private
     * @param {?=} toTop
     * @return {?}
     */
    checkScrollbarPosition(toTop = false) {
        if (!this.dg.data || !this.dg.data.length) {
            return;
        }
        /** @type {?} */
        const scrollBar = this.ps.instance;
        /** @type {?} */
        const scrollElRef = this.ps.elementRef.nativeElement;
        // scrollBar.update();
        /** @type {?} */
        const lastScrollLeft = scrollBar ? scrollBar.lastScrollLeft : 0;
        /** @type {?} */
        const lastScrollTop = scrollBar ? scrollBar.lastScrollTop : 0;
        // const lastScrollLeft = this.scrollLeft;
        // const lastScrollTop = this.scrollTop;
        /** @type {?} */
        const scrollTop = scrollElRef.scrollTop;
        /** @type {?} */
        const scrollLeft = scrollElRef.scrollLeft;
        if (!toTop) {
            if (scrollTop != lastScrollTop) {
                this.ps.scrollToTop(lastScrollTop);
                this.dgs.onScrollMove(lastScrollTop, SCROLL_Y_ACTION);
            }
        }
        else {
            this.ps.scrollToTop();
            this.dgs.onScrollMove(lastScrollTop, SCROLL_Y_ACTION);
        }
        this.scrollLeft = lastScrollLeft;
        if (scrollLeft != lastScrollLeft) {
            this.ps.scrollToX(lastScrollLeft);
            this.dgs.onScrollMove(lastScrollLeft, SCROLL_X_ACTION);
        }
        else {
            if (lastScrollLeft) {
                this.dgs.onScrollMove(lastScrollLeft, SCROLL_X_ACTION);
            }
        }
    }
    /**
     * 数据发生变化，重新加载数据时执行
     * 重置滚动条位置
     * @private
     * @param {?=} isSameLength
     * @param {?=} isDiffrentDataSource
     * @return {?}
     */
    onDataChanged(isSameLength = true, isDiffrentDataSource = false) {
        this.dg.setPagerHeight();
        this.viewportH = this.getViewPortHeight();
        this.bodyStyle = this.getBodyStyle();
        /**
         * update:
         * node_modules\perfect-scrollbar\types\perfect-scrollbar.d.ts
         * lastScrollTop: number
         */
        if (this.ps && this.ps.instance && !this.dg.isEditing() && !this.dg.clientFilterChanged && !this.dg.autoHeight) {
            this.scrollTop = 0;
            this.lastRenderedScrollTop = 0;
            this.ps.scrollToTop();
            this.scrollLeft = 0;
            this.ps.scrollToLeft();
        }
        this.rowsCache = {};
        /** @type {?} */
        const keepscrollPos = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const scrollInfo = this.dg.dfs.getState().scrollInfo;
            if (scrollInfo) {
                if (scrollInfo.y) {
                    this.scrollTop = scrollInfo.y;
                    this.dg.scrollInstance.scrollToY(scrollInfo.y);
                    this.dgs.onScrollMove(scrollInfo.y, SCROLL_Y_ACTION);
                }
                if (scrollInfo.x) {
                    this.scrollLeft = scrollInfo.x;
                    this.dg.scrollInstance.scrollToX(scrollInfo.x);
                    this.dg.dgs.onScrollMove(scrollInfo.x, SCROLL_X_ACTION);
                }
            }
        });
        if (!this.dg.nowrap || this.dg.autoHeight) {
            this.renderData(false);
            this.dgs.cellContentWrapChanged.next(this.width);
        }
        else {
            if (isSameLength) {
                keepscrollPos();
            }
            this.renderData(false);
            this.ps.update();
        }
        if (isDiffrentDataSource) {
            this.dg.initSelectOrChecked();
        }
        else {
            this.dg.refreshSelectedData();
        }
        this.dg.clientFilterChanged = false;
        this.dataChange.emit(this.data);
        if (this.dg.scrollBarShowMode === 'allways' && this.ps.instance && !this.dg.showScrollArrow) {
            this.hasYScrollbar();
        }
    }
    /**
     * @private
     * @return {?}
     */
    destroySubscriptions() {
        if (this.subscriptions && this.subscriptions.length) {
            this.subscriptions.forEach((/**
             * @param {?} sub
             * @return {?}
             */
            (sub) => {
                if (sub) {
                    sub.unsubscribe();
                    sub = null;
                }
            }));
            this.subscriptions = [];
        }
    }
    /**
     * @private
     * @return {?}
     */
    listenSubjects() {
        this.destroySubscriptions();
        this.gridSizeSubscribe = this.dfs.gridSize$.pipe(takeUntil(this.destroy$)).pipe(debounceTime(50)).subscribe((/**
         * @param {?} state
         * @return {?}
         */
        state => {
            if (state) {
                this.dg.setPagerHeight();
                /** @type {?} */
                const hh = this.dg.setHeaderHeight();
                this.setPositionTop(hh);
                this.height = state.height - this.top;
                /** @type {?} */
                const oldWidth = this.width;
                this.width = Math.floor(state.width);
                this.rowHeight = state.rowHeight;
                if (this.dg.showBorder) {
                    this.width -= 2;
                }
                this.viewportW = this.width;
                this.viewportH = this.getViewPortHeight();
                this.canvasHeight = this.getCanvasHeight();
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => {
                    this.columnsGroup = state.columnsGroup;
                    this.checkScrollbarPosition();
                    // this.setFixedRightPosition();
                    this.updateColumnSize(state.columnsGroup);
                    this.dgs.showFixedShadow.emit({ showRightShadow: this.showRightShadow, x: this.fixedRightScrollLeft });
                    this.renderData(false);
                    if ((!this.dg.nowrap || this.dg.autoHeight) && this.rows && this.rows.length) {
                        if (oldWidth !== this.width) {
                            this.dgs.cellContentWrapChanged.next(oldWidth);
                        }
                        else {
                            this.keepScrollbarPosition(oldWidth);
                        }
                    }
                    else {
                        if (this._scrollXTimer) {
                            clearTimeout(this._scrollXTimer);
                        }
                        this._scrollXTimer = setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            this.keepScrollbarPosition(oldWidth);
                        }), 100);
                    }
                }));
            }
        }));
        this.subscriptions.push(this.gridSizeSubscribe);
        this.columnResizeSubscribe = this.dfs.columnResize$.subscribe((/**
         * @param {?} cg
         * @return {?}
         */
        (cg) => {
            this.updateColumnSize(cg);
            this.cd.detectChanges();
        }));
        this.subscriptions.push(this.columnResizeSubscribe);
        this.dgs.setSelecedRow.subscribe((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            if (r && r.selected) {
                this.currentRowId = r.id;
            }
            else {
                this.currentRowId = undefined;
            }
        }));
        this.selectRowSubscribe = this.dfs.selectRow$.subscribe((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            if (row) {
                this.currentRowId = row.id;
                // 20210817 方向键移动后刷新视图状态
                this.cd.detectChanges();
            }
        }));
        this.subscriptions.push(this.selectRowSubscribe);
        this.unselectRowSubscribe = this.dfs.unSelectRow$.subscribe((/**
         * @param {?} prevRow
         * @return {?}
         */
        (prevRow) => {
            if (prevRow && prevRow.id === this.currentRowId) {
                this.currentRowId = undefined;
                this.dg.selectedRow = null;
            }
            if (!this.dg.editable && this.dg.multiSelect) {
                this.__triggerBodyClickEvent = this.dg.selectionMode === 'default';
            }
            this.cd.detectChanges();
        }));
        this.subscriptions.push(this.unselectRowSubscribe);
        this.selectAllSubscribe = this.dfs.selectAll$.subscribe((/**
         * @param {?} rows
         * @return {?}
         */
        (rows) => {
            this.dg.selectAll.emit(rows);
            this.cd.detectChanges();
        }));
        this.subscriptions.push(this.selectAllSubscribe);
        this.checkRowSubscribe = this.dfs.checkRow$.subscribe((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            this.dg.checked.emit(row);
            this.checkedRowsChanged();
            // this.cd.detectChanges();
        }));
        this.subscriptions.push(this.checkRowSubscribe);
        this.clearSelectionsSubscribe = this.dfs.clearSelections$.subscribe((/**
         * @return {?}
         */
        () => {
            this.currentRowId = undefined;
            if (this.dg.checkOnSelect) {
                this.checkedRowsChanged();
            }
            this.dg.unSelectAll.emit();
        }));
        this.subscriptions.push(this.clearSelectionsSubscribe);
        this.uncheckRowSubscribe = this.dfs.unCheckRow$.subscribe((/**
         * @param {?} prevRow
         * @return {?}
         */
        (prevRow) => {
            this.dg.unChecked.emit(prevRow);
            this.checkedRowsChanged();
            // this.cd.detectChanges();
        }));
        this.subscriptions.push(this.uncheckRowSubscribe);
        this.checkAllSubscribe = this.dfs.checkAll$.subscribe((/**
         * @param {?} rows
         * @return {?}
         */
        (rows) => {
            this.dg.checkAll.emit(rows);
            this.checkedRowsChanged();
            // this.cd.detectChanges();
        }));
        this.subscriptions.push(this.checkAllSubscribe);
        this.clearCheckedsSubscribe = this.dfs.clearCheckeds$.subscribe((/**
         * @param {?} rows
         * @return {?}
         */
        (rows) => {
            if (this.dg.selectOnCheck) {
                this.currentRowId = undefined;
            }
            this.dg.unCheckAll.emit(rows);
            this.checkedRowsChanged();
            this.cd.detectChanges();
        }));
        this.subscriptions.push(this.clearCheckedsSubscribe);
        this.subscriptions.push(this.dgs.setScrollbarPosition.subscribe((/**
         * @return {?}
         */
        () => {
            this.checkScrollbarPosition();
            this.updateScrollPosition(this.scrollLeft);
        })));
        this.dgs.columnResized.pipe(delay(100)).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (!this.dg.nowrap ||
                (this.dg.currentCell && this.dg.currentCell.isEditing && this.dg.currentCell.column &&
                    this.dg.currentCell.column.editor && this.dg.currentCell.column.editor.type === 'textarea')) {
                /** @type {?} */
                const trdoms = this.dg.dgContainer.nativeElement.querySelectorAll('.f-datagrid-body-row:not(.f-datagrid-footer-row)');
                trdoms.forEach((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    this.render.setStyle(n, 'height', 'auto');
                }));
                /** @type {?} */
                let trID = '';
                if (e) {
                    /** @type {?} */
                    const rowId = e.id;
                    trID = TR_PREFIX + rowId;
                }
                this.updateRowHeight(trID);
            }
            if (this.dg.headerWrap) {
                this.dg.setHeaderHeight();
                this.dfs.columnResizeEnd();
            }
        }));
        this.dgs.cellContentWrapChanged.pipe(takeUntil(this.destroy$), debounceTime(100)).subscribe((/**
         * @param {?} oldWidth
         * @return {?}
         */
        (oldWidth) => {
            this.updateRowHeight();
            if (oldWidth != null) {
                this.keepScrollbarPosition(oldWidth);
            }
            else {
                this.ps && this.ps.instance && this.ps.instance.update();
            }
        }));
        this.dg.dfs.rowUpdate$.subscribe((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            if (row && row.data) {
                this.buildCustomCellStyle(row);
            }
        }));
        if (this.dg.groupRows) {
            this.dfs.expandGroupRow.pipe(takeUntil(this.destroy$)).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e && e.data) {
                    this.groupRowStateChanged(e.data, true);
                    setTimeout((/**
                     * @return {?}
                     */
                    () => { this.updateRowHeight(); }));
                }
            }));
            this.dfs.collapseGroupRow.pipe(takeUntil(this.destroy$)).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e && e.data) {
                    this.groupRowStateChanged(e.data, false);
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} groupRow
     * @param {?} isExpand
     * @return {?}
     */
    groupRowExpandUpdate(groupRow, isExpand) {
        if (groupRow.rows && groupRow.rows.length) {
            groupRow.rows.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                if (n[IS_GROUP_FOOTER_ROW_FIELD]) {
                    this.data.filter((/**
                     * @param {?} t
                     * @return {?}
                     */
                    t => t[GROUP_ROW_FIELD] === n[GROUP_ROW_FIELD])).forEach((/**
                     * @param {?} d
                     * @return {?}
                     */
                    d => {
                        d[GROUP_VISIBLE_FIELD] = isExpand && groupRow.expanded;
                    }));
                }
                else {
                    /** @type {?} */
                    const item = this.data.find((/**
                     * @param {?} e
                     * @return {?}
                     */
                    e => e.id === n.id));
                    if (item) {
                        item[GROUP_VISIBLE_FIELD] = isExpand && groupRow.expanded;
                        if (item.rows && item.rows.length) {
                            this.groupRowExpandUpdate(item, isExpand);
                        }
                    }
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} rowData
     * @param {?} expand
     * @return {?}
     */
    groupRowStateChanged(rowData, expand) {
        if (this.dg.virtualized) {
            /** @type {?} */
            const gr = this.data.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n.id === rowData.id));
            this.groupRowExpandUpdate(gr, expand);
            this.renderData(false);
        }
        else {
            this.getCanvasHeight();
        }
        if (this['_psUpdateTimer_']) {
            clearTimeout(this['_psUpdateTimer_']);
        }
        this['_psUpdateTimer_'] = setTimeout((/**
         * @return {?}
         */
        () => {
            this.ps.update();
            this.cd.detectChanges();
        }), 100);
    }
    /**
     * @private
     * @param {?} oldWidth
     * @return {?}
     */
    keepScrollbarPosition(oldWidth) {
        if (!this.cd["destroyed"]) {
            this.cd.detectChanges();
        }
        if (!this.ps.instance) {
            return;
        }
        if (this["keepScrollbarPositionTIMER"]) {
            clearTimeout(this["keepScrollbarPositionTIMER"]);
        }
        this["keepScrollbarPositionTIMER"] = setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.width > oldWidth) {
                /** @type {?} */
                const x = this.scrollLeft - (this.width - oldWidth);
                this.ps.elementRef.nativeElement.scrollLeft = x < 0 ? 0 : x;
            }
            if (!this.dg.nowrap || this.dg.autoHeight) {
                this.updateCanvasHeight();
            }
            this.ps.update();
            this.updateScrollPosition(this.ps.elementRef.nativeElement.scrollLeft);
            this.dgs.scrollbarUpdate.emit({ scrollbarRef: this.ps.instance, rightWidth: this.rightFixedWidth, showRightShadow: this.showRightShadow });
        }), 50);
    }
    /**
     * @private
     * @param {?} cg
     * @return {?}
     */
    updateColumnSize(cg) {
        if (cg) {
            this.columnsGroup = cg;
            this.leftFixedWidth = this.columnsGroup.leftFixedWidth;
            this.colsWidth = this.columnsGroup.normalWidth;
            this.scrollLeft = this.ps.elementRef.nativeElement.scrollLeft;
            this.maxScrollLeft = this.colsWidth + this.leftFixedWidth;
            this.fixedRightScrollLeft = this.maxScrollLeft;
            // grid 容器宽度
            /** @type {?} */
            const dgContainerWidth = this.dg.dgContainer.nativeElement.offsetWidth;
            // 所有列宽之和
            /** @type {?} */
            const allColsWidth = Math.floor(this.columnsGroup.totalWidth);
            this.bodyStyle = this.getBodyStyle();
            if (dgContainerWidth > allColsWidth || dgContainerWidth === allColsWidth) {
                this.showRightShadow = false;
            }
            else {
                this.showRightShadow = true;
                // 右侧固定列的位置
                this.fixedRightScrollLeft = this.width + this.scrollLeft;
            }
            this.setFixedRightWidth();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setFixedRightWidth() {
        this.rightFixedWidth = this.columnsGroup.rightFixedWidth;
        this.totalWidth = this.columnsGroup.totalWidth;
        if (this.ps && this.ps.instance && this.dg.scrollBarShowMode === 'allways') {
            if (this.ps.instance.scrollbarYActive) {
                this.rightFixedWidth += 18;
            }
        }
    }
    /**
     * @private
     * @param {?} row
     * @return {?}
     */
    buildCustomCellStyle(row) {
        /** @type {?} */
        let rightTrs = [];
        /** @type {?} */
        let leftTrs = [];
        if (this.fixedRightEl) {
            rightTrs = this.fixedRightEl.nativeElement.querySelectorAll('tr');
        }
        if (this.fixedLeftEl) {
            leftTrs = this.fixedLeftEl.nativeElement.querySelectorAll('.fixed-left-row');
        }
        /** @type {?} */
        const trs = this.mainArea.nativeElement.querySelectorAll('tr.f-datagrid-body-row');
        /** @type {?} */
        const updateCellStyle = (/**
         * @param {?} arr
         * @param {?} col
         * @param {?} style
         * @return {?}
         */
        (arr, col, style) => {
            if (arr.length) {
                /** @type {?} */
                const td = arr[row.index].querySelector(`[field="${col.field}"]`);
                if (td) {
                    this.dg.renderCustomStyle(style, td);
                }
            }
        });
        this.dg.flatColumns.forEach((/**
         * @param {?} col
         * @return {?}
         */
        col => {
            if (col.styler) {
                /** @type {?} */
                const _rd = row.data;
                /** @type {?} */
                const val = Utils.getValue(col.field, _rd);
                /** @type {?} */
                const cs = col.styler(val, _rd, row.index);
                if (cs && Object.keys(cs).length) {
                    updateCellStyle(leftTrs, col, cs);
                    updateCellStyle(rightTrs, col, cs);
                    updateCellStyle(trs, col, cs);
                }
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    checkedRowsChanged() {
        this.dgs.onCheckedRowsCountChange();
        /** @type {?} */
        const checkedRows = this.dg.checkeds;
        this.dg.checkValues = checkedRows.map((/**
         * @param {?} r
         * @return {?}
         */
        r => r.id));
        this.dg.checkValuesChange.emit(this.dg.checkValues);
        this.dg.checkedChange.emit(checkedRows);
    }
    /**
     * @private
     * @return {?}
     */
    getTrDomHeight() {
        /** @type {?} */
        const list = [];
        /** @type {?} */
        let rightTrs = [];
        /** @type {?} */
        let leftTrs = [];
        /** @type {?} */
        let trdoms = [];
        if (this.fixedRightEl) {
            rightTrs = this.fixedRightEl.nativeElement.querySelectorAll('tr');
        }
        if (this.fixedLeftEl) {
            leftTrs = this.fixedLeftEl.nativeElement.querySelectorAll('.fixed-left-row');
        }
        if (this.mainArea) {
            trdoms = this.mainArea.nativeElement.querySelectorAll('tr.f-datagrid-body-row');
        }
        trdoms.forEach((/**
         * @param {?} tr
         * @param {?} i
         * @return {?}
         */
        (tr, i) => {
            /** @type {?} */
            let t1 = 0;
            /** @type {?} */
            const t2 = Math.ceil(tr.offsetHeight);
            /** @type {?} */
            let t3 = 0;
            if (leftTrs && leftTrs.length) {
                t1 = Math.ceil(leftTrs[i].offsetHeight);
            }
            if (rightTrs && rightTrs.length) {
                t3 = Math.ceil(rightTrs[i].offsetHeight);
            }
            /** @type {?} */
            const _h = Math.max(t1, t2, t3, this.dg.rowHeight);
            list.push(_h);
        }));
        return list;
    }
    /**
     * @return {?}
     */
    updateRowHeight2() {
        /** @type {?} */
        let rightTrs = [];
        /** @type {?} */
        let leftTrs = [];
        /** @type {?} */
        let trdoms = [];
        if (this.fixedRightEl) {
            rightTrs = this.fixedRightEl.nativeElement.querySelectorAll('tr');
        }
        if (this.fixedLeftEl) {
            leftTrs = this.fixedLeftEl.nativeElement.querySelectorAll('.fixed-left-row');
        }
        if (this.mainArea) {
            trdoms = this.mainArea.nativeElement.querySelectorAll('tr.f-datagrid-body-row');
        }
        trdoms.forEach((/**
         * @param {?} tr
         * @param {?} i
         * @return {?}
         */
        (tr, i) => {
            this.removeRowHeightCls(tr);
            if (leftTrs && leftTrs[i]) {
                this.removeRowHeightCls(leftTrs[i]);
            }
            if (rightTrs && rightTrs[i]) {
                this.removeRowHeightCls(rightTrs[i]);
            }
        }));
        if (this['UPDATE_ROW_HEIGHT_TIMER']) {
            clearTimeout(this['UPDATE_ROW_HEIGHT_TIMER']);
        }
        this['UPDATE_ROW_HEIGHT_TIMER'] = setTimeout((/**
         * @return {?}
         */
        () => {
            trdoms.forEach((/**
             * @param {?} tr
             * @param {?} i
             * @return {?}
             */
            (tr, i) => {
                /** @type {?} */
                let t1 = 0;
                /** @type {?} */
                const t2 = Math.ceil(tr.offsetHeight);
                /** @type {?} */
                let t3 = 0;
                /** @type {?} */
                let leftTr = null;
                /** @type {?} */
                let rightTr = null;
                if (leftTrs && leftTrs.length) {
                    t1 = Math.ceil(leftTrs[i].offsetHeight);
                    leftTr = leftTrs[i];
                }
                if (rightTrs && rightTrs.length) {
                    t3 = Math.ceil(rightTrs[i].offsetHeight);
                    rightTr = rightTrs[i];
                }
                /** @type {?} */
                const _h = Math.max(t1, t2, t3, this.dg.rowHeight);
                if (!this.dg.nowrap || this.dg.autoHeight) {
                    /** @type {?} */
                    const heightClsName = WORDWRAP_ROW_HEIGHT_CLS + '_' + _h;
                    /** @type {?} */
                    const minRowHeightClsName = 'min_row_height_' + this.rowHeight;
                    /** @type {?} */
                    const _addRowHeightClsToDom = (/**
                     * @param {?} trdom
                     * @return {?}
                     */
                    (trdom) => {
                        this.removeRowHeightCls(trdom);
                        this.render.addClass(trdom, heightClsName);
                        this.render.addClass(trdom, minRowHeightClsName);
                    });
                    this.addRowHeightCls(heightClsName, _h);
                    _addRowHeightClsToDom(tr);
                    if (leftTr) {
                        _addRowHeightClsToDom(leftTr);
                    }
                    if (rightTr) {
                        _addRowHeightClsToDom(rightTr);
                    }
                }
            }));
        }), 100);
    }
    /**
     * @private
     * @param {?} tr
     * @return {?}
     */
    removeRowHeightCls(tr) {
        if (!tr) {
            return;
        }
        /** @type {?} */
        const _cls = Array.from(tr.classList).find((/**
         * @param {?} n
         * @return {?}
         */
        (n) => n.indexOf(WORDWRAP_ROW_HEIGHT_CLS) > -1));
        if (_cls) {
            tr.classList.remove(_cls);
        }
    }
    /**
     * @private
     * @param {?} heightClsName
     * @param {?} _h
     * @return {?}
     */
    addRowHeightCls(heightClsName, _h) {
        this.dgs.removeCssRule(`${this.dg.customStyleKey()} .${heightClsName}`);
        this.dg.renderCustomStyle2({ style: { height: _h + 'px!important' } }, null, heightClsName);
    }
    /**
     * 允许数据折行时，计算行号的行高
     * @param {?=} trDomId
     * @return {?}
     */
    updateRowHeight(trDomId = null) {
        if (this.fast) {
            return;
        }
        if (!this.mainArea) {
            return;
        }
        /** @type {?} */
        const dgBody = this.el.nativeElement.querySelector('div.f-datagrid-body');
        if (dgBody) {
            if (!this.dg.nowrap || this.dg.autoHeight) {
                this.render.addClass(dgBody, 'data-wrap');
            }
            else {
                this.render.removeClass(dgBody, 'data-wrap');
            }
        }
        if (!trDomId) {
            this.updateRowHeight2();
        }
        else {
            /** @type {?} */
            const tr = Utils.getTrDomById(trDomId, document);
            if (!tr) {
                return;
            }
            /** @type {?} */
            const leftTrId = trDomId + '_fixedleft';
            /** @type {?} */
            const rightTrId = trDomId + '_fixedright';
            /** @type {?} */
            const leftTr = Utils.getTrDomById(leftTrId, document);
            /** @type {?} */
            const rightTr = Utils.getTrDomById(rightTrId, document);
            this.removeRowHeightCls(tr);
            this.removeRowHeightCls(leftTr);
            this.removeRowHeightCls(rightTr);
            /** @type {?} */
            const _arr = [];
            if (this.fixedRightEl) {
                /** @type {?} */
                const rtr = Utils.getTrDomById(trDomId, this.fixedRightEl.nativeElement);
                if (rtr) {
                    _arr.push(Math.ceil(rtr.offsetHeight));
                }
            }
            if (this.fixedLeftEl) {
                /** @type {?} */
                const ltr = Utils.getTrDomById(trDomId, this.fixedLeftEl.nativeElement);
                if (ltr) {
                    _arr.push(Math.ceil(ltr.offsetHeight));
                }
            }
            if (this.mainArea) {
                /** @type {?} */
                const tr = Utils.getTrDomById(trDomId, this.mainArea.nativeElement);
                if (tr) {
                    _arr.push(Math.ceil(tr.offsetHeight));
                }
            }
            /** @type {?} */
            const _h = Math.max(..._arr);
            /** @type {?} */
            const heightClsName = WORDWRAP_ROW_HEIGHT_CLS + '_' + _h;
            if (!this.dg.nowrap || this.dg.autoHeight) {
                this.render.addClass(tr, heightClsName);
                this.addRowHeightCls(heightClsName, _h);
                if (leftTr) {
                    this.render.addClass(leftTr, heightClsName);
                }
                if (rightTr) {
                    this.render.addClass(rightTr, heightClsName);
                }
            }
        }
        this.updateCanvasHeight();
        // 移除height: auto
        /** @type {?} */
        const trdoms = this.dg.dgContainer.nativeElement.querySelectorAll('.f-datagrid-body-row:not(f-datagrid-footer-row)');
        trdoms.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => n.style.height = ''));
        if (!this.cd['destroyed']) {
            this.cd.detectChanges();
        }
    }
    /**
     * @private
     * @return {?}
     */
    getBodyStyle() {
        /** @type {?} */
        let h = this.getViewPortHeight();
        if (!this.data.length) {
            if (this.dg.useBlankWhenDataIsEmpty) {
                h = this.dg.emptyDataHeight;
            }
            else {
                if (this.dg.autoHeight) {
                    h = this.dg.emptyDataHeight;
                }
                if (this.dg.footerData && this.dg.showFooter) {
                    /** @type {?} */
                    let fd = this.dg.footerData;
                    if (this.dg.footerData.subscribe) {
                        fd = this.dg.footerData['value'];
                    }
                    if (fd && Array.isArray(fd) && fd.length) {
                        h = h - this.dg.footerHeight;
                        if (this.dg.footerPosition === 'both') {
                            h = h - this.dg.footerHeight;
                        }
                    }
                }
            }
        }
        else {
            if (this.dg.showFooter && this.dg.footerPosition === 'both') {
                h = h - this.dg.footerHeight;
            }
        }
        return {
            height: `${Math.floor(h) + 1}px`
        };
    }
    /**
     * @private
     * @param {?} scrollLeft
     * @return {?}
     */
    updateScrollPosition(scrollLeft) {
        this.scrollLeft = scrollLeft;
        this.fixedRightScrollLeft = this.scrollLeft + this.width - this.rightFixedWidth;
        if (this.fixedRightScrollLeft === this.maxScrollLeft || this.fixedRightScrollLeft > this.maxScrollLeft) {
            this.fixedRightScrollLeft = this.maxScrollLeft;
            this.showRightShadow = false;
        }
        else {
            this.showRightShadow = true;
        }
        if (this.fixedLeftEl) {
            this.render.setStyle(this.fixedLeftEl.nativeElement, 'transform', `translate3d(${this.scrollLeft}px, 0px, 0px)`);
        }
        if (this.fixedRightEl) {
            /** @type {?} */
            let l = this.dg.width - (this.dg.showBorder ? 2 : 0) - this.columnsGroup.rightFixedWidth;
            if (this.ps && this.ps.instance && this.ps.instance.scrollbarYActive && this.dg.scrollBarShowMode === 'allways') {
                l -= 18;
            }
            /** @type {?} */
            let realWidth = this.columnsGroup.leftFixedWidth + this.columnsGroup.normalWidth + this.columnsGroup.rightFixedWidth;
            if (this.dg.width - (this.dg.showBorder ? 2 : 0) > realWidth) {
                l = this.columnsGroup.leftFixedWidth + this.columnsGroup.normalWidth;
            }
            l += this.scrollLeft;
            this.fixedRightScrollLeft = l;
            this.render.setStyle(this.fixedRightEl.nativeElement, 'transform', `translate3d(${this.fixedRightScrollLeft}px, 0px, 0px)`);
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onScrollToX($event) {
        /** @type {?} */
        const x = $event.target.scrollLeft;
        this.updateScrollPosition(x);
        // this.cd.detectChanges();
        this.dgs.onScrollMove(x, SCROLL_X_ACTION);
        this.dfs.updateProperty('scrollInfo', { y: $event.target.scrollTop, x });
        this.dgs.showFixedShadow.emit({ showRightShadow: this.showRightShadow, x: this.fixedRightScrollLeft });
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onScrollToY($event) {
        if (this._scrollTimer) {
            clearTimeout(this._scrollTimer);
        }
        this._scrollTimer = setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const y = $event.target.scrollTop;
            if (this.dg.virtualized) {
                this.handleScroll();
            }
            this.scrollTop = y;
            this.dfs.updateProperty('scrollInfo', { y, x: $event.target.scrollLeft });
            this.dg.scrollY.emit(y);
            this.dgs.onScrollMove(y, SCROLL_Y_ACTION);
        }), 100);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPsXReachStart($event) {
        /** @type {?} */
        const x = $event.target.scrollLeft;
        this.updateScrollPosition(x);
        this.dgs.onScrollMove(x, SCROLL_X_REACH_START_ACTION);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPsXReachEnd($event) {
        this.showRightShadow = false;
        // const x = $event.target.scrollLeft;
        // this.updateScrollPosition(x);
        // this.cd.detectChanges();
        // // this.dgs.onShowFixedShadow(this.showRightShadow);
        // this.dgs.onScrollMove(x, SCROLL_X_REACH_END_ACTION);
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    isChecked(rowData) {
        if (rowData) {
            return this.dfs.isRowChecked(rowData[this.dg.idField]);
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    isSelected(rowData) {
        if (rowData) {
            return this.dfs.isRowSelected(rowData[this.dg.idField]);
        }
        return false;
    }
    /**
     * @param {?} row
     * @param {?=} open
     * @return {?}
     */
    toggleGroupRow(row, open = true) {
        row.expanded = open;
        this.ps.update();
    }
    /** =================================== 分 ====== 隔 ====== 线 =================================== */
    /**
     * 获取可视区域高度
     * @return {?}
     */
    getViewPortHeight() {
        /** @type {?} */
        let viewPortHeight = this.dg.height;
        if (this.dg.showHeader) {
            viewPortHeight = viewPortHeight - this.dg.realHeaderHeight;
        }
        if ((this.dg.enableFilterRow || this.dg.enableSmartFilter) && this.dg.showFilterBar) {
            viewPortHeight -= this.dg.filterBarHeight;
        }
        if (this.dg.showRowGroupPanel) {
            viewPortHeight -= this.dg.rowGroupPanelHeight;
        }
        if (this.dg.showFooter && this.data.length) {
            viewPortHeight = viewPortHeight - this.dg.footerHeight;
        }
        if (this.dg.pagination) {
            viewPortHeight = viewPortHeight - this.dg.pagerHeight - 2;
        }
        if (this.dg.showBorder) {
            viewPortHeight -= 2;
        }
        this.viewportH = viewPortHeight;
        return viewPortHeight;
    }
    // 不折行时，所有数据的高度
    /**
     * @private
     * @return {?}
     */
    allRowsHeight() {
        /** @type {?} */
        const rowHeightpatch = 1;
        // this.dg.autoHeight ? 2 : 1;
        /** @type {?} */
        const rowHeight = this.dg.rowHeight + rowHeightpatch;
        /** @type {?} */
        let itemsCount = 0;
        if (this.dg.groupRows) {
            /** @type {?} */
            const data = this.data.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n['__group_visible__'] || n['__group_visible__'] === undefined));
            if (this.dg.groupSummaryPosition === 'inGroupRow') {
                itemsCount = data.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => !n['__group_footer__'])).length;
            }
            else {
                itemsCount = data.length;
            }
        }
        else {
            itemsCount = this.data.length;
        }
        /** @type {?} */
        let h = itemsCount * rowHeight;
        if (this.dg.autoHeight) {
            h += itemsCount;
        }
        else {
            h += 2;
        }
        return h;
    }
    /**
     * @private
     * @return {?}
     */
    getCanvasHeight() {
        /** @type {?} */
        let canvasHeight = 0;
        if (!this.data || !this.data.length) {
            this.canvasHeight = 0;
            return 0;
        }
        if (this.dg.nowrap) {
            // tfs 572022
            if (this.dg.maxHeight && this.dg.autoHeight && this.mainArea) {
                canvasHeight = Math.floor(this.mainArea.nativeElement.getBoundingClientRect().height);
            }
            else {
                canvasHeight = this.allRowsHeight();
            }
        }
        else {
            canvasHeight = this.getTrDomHeight().reduce((/**
             * @param {?} r
             * @param {?} c
             * @return {?}
             */
            (r, c) => r + c), 0);
        }
        if (!canvasHeight) {
            canvasHeight = this.viewportH;
        }
        canvasHeight = canvasHeight + (this.dg.scrollBarShowMode === 'allways' && (this.ps.instance && this.ps.instance['scrollbarXActive']) ? 18 : 0);
        this.canvasHeight = canvasHeight;
        return canvasHeight;
    }
    /**
     * @return {?}
     */
    updateCanvasHeight() {
        this.canvasHeight = this.getCanvasHeight();
    }
    /**
     * @private
     * @param {?} y
     * @return {?}
     */
    getRowFromPosition(y) {
        return Math.floor(y / (this.dg.rowHeight + 1));
    }
    /**
     * @param {?=} viewportTop
     * @param {?=} viewportLeft
     * @return {?}
     */
    getVisibleRange(viewportTop, viewportLeft) {
        if (viewportTop == null) {
            viewportTop = this.scrollTop;
        }
        if (viewportLeft == null) {
            viewportLeft = this.scrollLeft;
        }
        return {
            top: this.getRowFromPosition(viewportTop),
            bottom: this.getRowFromPosition(viewportTop + this.viewportH) + 1,
            leftPx: viewportLeft,
            rightPx: viewportLeft + this.viewportW
        };
    }
    /**
     * @private
     * @param {?=} viewportTop
     * @param {?=} viewportLeft
     * @return {?}
     */
    getRenderedRange(viewportTop, viewportLeft) {
        /** @type {?} */
        const range = this.getVisibleRange(viewportTop, viewportLeft);
        /** @type {?} */
        const buffer = Math.round(this.viewportH / (this.dg.rowHeight + 1));
        /** @type {?} */
        const minBuffer = this.minRowBuffer;
        if (this.vScrollDir == -1) {
            range.top -= buffer;
            range.bottom += minBuffer;
        }
        else if (this.vScrollDir == 1) {
            range.top -= minBuffer;
            range.bottom += buffer;
        }
        else {
            range.top -= minBuffer;
            range.bottom += minBuffer;
        }
        range.top = Math.max(0, range.top);
        range.bottom = Math.min(this.data.length - 1, range.bottom);
        range.leftPx -= this.viewportW;
        range.rightPx += this.viewportW;
        range.leftPx = Math.max(0, range.leftPx);
        range.rightPx = Math.min(this.canvasWidth, range.rightPx);
        return range;
    }
    /**
     * @private
     * @param {?} range
     * @return {?}
     */
    renderRows(range) {
        /** @type {?} */
        const rows = [];
        /** @type {?} */
        let dataLength = this.data.length;
        /** @type {?} */
        let _data = this.data;
        // 启用分组
        if (this.dg.groupRows && this.dg.groupField) {
            _data = _data.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n['__group_visible__'] || n['__group_visible__'] === undefined));
            if (this.dg.groupSummaryPosition === 'inGroupRow') {
                _data = _data.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => !n['__group_footer__']));
            }
            dataLength = _data.length;
            this.rowsCache = {};
        }
        for (let i = range.top; i <= range.bottom; i++) {
            if (this.rowsCache[i] || (i == dataLength)) {
                continue;
            }
            rows.push(i);
            // Create an entry right away so that appendRowHtml() can
            // start populatating it.
            this.rowsCache[i] = {
                rowNode: null,
                // ColSpans of rendered cells (by column idx).
                // Can also be used for checking whether a cell has been rendered.
                cellColSpans: [],
                // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().
                cellNodesByColumnIdx: [],
                // Column indices of cell nodes that have been rendered, but not yet indexed in
                // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the
                // end of the row.
                cellRenderQueue: []
            };
        }
        for (let i = 0, ii = rows.length; i < ii; i++) {
            this.rowsCache[rows[i]].rowNode = _data[rows[i]];
        }
        return Object.keys(this.rowsCache).map((/**
         * @param {?} n
         * @return {?}
         */
        n => this.rowsCache[n].rowNode)).filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n));
    }
    /**
     * @private
     * @param {?} row
     * @return {?}
     */
    removeRowFromCache(row) {
        /** @type {?} */
        const cacheEntry = this.rowsCache[row];
        if (!cacheEntry) {
            return;
        }
        delete this.rowsCache[row];
    }
    /**
     * @private
     * @param {?} rangeToKeep
     * @return {?}
     */
    cleanupRows(rangeToKeep) {
        for (const i in this.rowsCache) {
            if (i < rangeToKeep.top || i > rangeToKeep.bottom) {
                this.removeRowFromCache(i);
            }
        }
    }
    /**
     * @param {?=} showYscrollbar
     * @return {?}
     */
    hasYScrollbar(showYscrollbar) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            showYscrollbar = showYscrollbar == undefined ? this.ps.instance.scrollbarYActive : showYscrollbar;
            /** @type {?} */
            const hasY = showYscrollbar && this.dg.scrollBarShowMode === 'allways' ? 18 : 0;
            this.dfs.updateProperty('scrollbarY', hasY);
            this.dfs.resize();
        }), 60);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClickScrollArrow($event) {
        const { dir, event } = $event;
        if (this.ps && this.ps.instance) {
            const { x, y } = this.ps.instance.reach;
            switch (dir) {
                case 'left':
                    if (x !== 'start') {
                        this.viewScrollContainer.nativeElement.scrollLeft = this.viewScrollContainer.nativeElement.scrollLeft - 40;
                    }
                    break;
                case 'right':
                    if (x !== 'end') {
                        this.viewScrollContainer.nativeElement.scrollLeft = this.viewScrollContainer.nativeElement.scrollLeft + 40;
                    }
                    break;
                case 'top':
                    if (y !== 'start') {
                        this.viewScrollContainer.nativeElement.scrollTop = this.viewScrollContainer.nativeElement.scrollTop - 40;
                    }
                    break;
                case 'bottom':
                    if (y !== 'end') {
                        this.viewScrollContainer.nativeElement.scrollTop = this.viewScrollContainer.nativeElement.scrollTop + 40;
                    }
                    break;
            }
            this.ps.update();
        }
    }
    /**
     * @private
     * @param {?=} detectchanges
     * @return {?}
     */
    renderData(detectchanges = true) {
        this.canvasHeight = this.getCanvasHeight();
        if (!this.dg.virtualized || this.dg.autoHeight) {
            this.rows = this.data;
        }
        else {
            /** @type {?} */
            const visible = this.getVisibleRange();
            /** @type {?} */
            const rendered = this.getRenderedRange();
            // remove rows no longer in the viewport
            this.cleanupRows(rendered);
            // render missing rows
            this.rows = this.renderRows(rendered);
            this.startRowIndex = rendered.top;
            this.lastRenderedScrollTop = this.scrollTop;
            this.lastRenderedScrollLeft = this.scrollLeft;
            this.blankTopHeight = this.startRowIndex * (this.dg.rowHeight + 1);
            this.blankBottomHeight = this.canvasHeight - this.blankTopHeight - (this.rows.length * (this.dg.rowHeight + 1));
            if (this.dg.scrollBarShowMode === 'allways' && this.ps && this.ps.instance && this.ps.instance.scrollbarXActive) {
                this.blankBottomHeight += 22;
            }
            if (detectchanges) {
                this.cd.detectChanges();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    handleScroll() {
        this.scrollTop = this.ps.elementRef.nativeElement.scrollTop;
        this.scrollLeft = this.ps.elementRef.nativeElement.scrollLeft;
        return this._handleScroll();
    }
    /**
     * @private
     * @return {?}
     */
    _handleScroll() {
        /** @type {?} */
        const viewportContainer = this.viewScrollContainer.nativeElement;
        /** @type {?} */
        let maxScrollDistanceY = viewportContainer.scrollHeight - viewportContainer.clientHeight;
        /** @type {?} */
        let maxScrollDistanceX = viewportContainer.scrollWidth - viewportContainer.clientWidth;
        // Protect against erroneous clientHeight/Width greater than scrollHeight/Width.
        // Sometimes seen in Chrome.
        maxScrollDistanceY = Math.max(0, maxScrollDistanceY);
        maxScrollDistanceX = Math.max(0, maxScrollDistanceX);
        // Ceiling the max scroll values
        if (this.scrollTop > maxScrollDistanceY) {
            this.scrollTop = maxScrollDistanceY;
        }
        if (this.scrollLeft > maxScrollDistanceX) {
            this.scrollLeft = maxScrollDistanceX;
        }
        /** @type {?} */
        const vScrollDist = Math.abs(this.scrollTop - this.prevScrollTop);
        /** @type {?} */
        const hScrollDist = Math.abs(this.scrollLeft - this.prevScrollLeft);
        if (hScrollDist) {
            this.prevScrollLeft = this.scrollLeft;
            // $viewportScrollContainerX[0].scrollLeft = scrollLeft;
            // if (hasFrozenColumns()) {
            //     if (hasFrozenRows) {
            //         $viewportTopR[0].scrollLeft = scrollLeft;
            //     }
            // } else {
            //     if (hasFrozenRows) {
            //         $viewportTopL[0].scrollLeft = scrollLeft;
            //     }
            // }
        }
        /** @type {?} */
        const lastScrollTop = this.lastRenderedScrollTop;
        if (vScrollDist) {
            this.vScrollDir = this.prevScrollTop < this.scrollTop ? 1 : -1;
            this.prevScrollTop = this.scrollTop;
            // if (hasFrozenColumns()) {
            //     if (hasFrozenRows && !options.frozenBottom) {
            //         $viewportBottomL[0].scrollTop = scrollTop;
            //     } else {
            //         $viewportTopL[0].scrollTop = scrollTop;
            //     }
            // }
            // switch virtual pages if needed
            if (vScrollDist < this.viewportH) {
                this._scrollTo(this.scrollTop);
            }
        }
        if (hScrollDist || vScrollDist) {
            /** @type {?} */
            const dx = Math.abs(this.lastRenderedScrollLeft - this.scrollLeft);
            /** @type {?} */
            const dy = Math.abs(lastScrollTop - this.scrollTop);
            if (dx > 20 || dy > 20) {
                // if rendering is forced or scrolling is small enough to be "easy", just render
                if (dy < this.viewportH && dx < this.viewportW) {
                    this.renderData();
                }
                else {
                    this.renderData();
                }
            }
        }
        if (hScrollDist || vScrollDist) {
            return true;
        }
        return false;
    }
    /**
     * @private
     * @param {?} y
     * @return {?}
     */
    _scrollTo(y) {
        /** @type {?} */
        const $viewportScrollContainerY = this.viewScrollContainer.nativeElement;
        y = Math.max(y, 0);
        y = Math.min(y, this.canvasHeight - this.viewportH);
        /** @type {?} */
        const newScrollTop = y;
        if (this.prevScrollTop != newScrollTop) {
            this.vScrollDir = (this.prevScrollTop < newScrollTop) ? 1 : -1;
            this.lastRenderedScrollTop = (this.scrollTop = this.prevScrollTop = newScrollTop);
            // if (hasFrozenColumns()) {
            //     $viewportTopL[0].scrollTop = newScrollTop;
            // }
            // if (hasFrozenRows) {
            //     $viewportBottomL[0].scrollTop = $viewportBottomR[0].scrollTop = newScrollTop;
            // }
            // $viewportScrollContainerY.scrollTop = newScrollTop;
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMouseClick($event) {
        // document.body.click();
        /** @type {?} */
        const target = (/** @type {?} */ ($event.target));
        if (target.nodeName === 'TEXTAREA' || target.nodeName === 'INPUT') {
            return;
        }
        /** @type {?} */
        let td = target;
        if (target.nodeName !== 'TD') {
            td = target.closest('TD');
        }
        if (!td) {
            if (this.dg.isEditing() && (this.dg.exitRowEditingWhenBodyClick || this.dg.editMode == 'cell')) {
                this.dg.endEditing();
            }
            return;
        }
        /** @type {?} */
        let curT = new Date().getTime()
        //上一次时间戳
        ;
        //上一次时间戳
        /** @type {?} */
        let lastT = this['lastTapDiffTime'] || 0;
        //对上一次时间戳重新赋值
        this['lastTapDiffTime'] = curT;
        //做差
        /** @type {?} */
        let diff = curT - lastT;
        /** @type {?} */
        const isClickSameRow = (/**
         * @return {?}
         */
        () => {
            if (this._clickCellWeakMap.has(this.el.nativeElement) && td && td.parentElement === this._clickCellWeakMap.get(this.el.nativeElement)) {
                this._clickCellWeakMap.delete(this.el.nativeElement);
                return true;
            }
            return false;
        });
        /** @type {?} */
        const runTdClick = (/**
         * @return {?}
         */
        () => {
            if (td && td.selectCell) {
                td.selectCell($event, td);
            }
            else {
                this._selectRow(td, (/**
                 * @param {?} id
                 * @param {?} rowSelected
                 * @return {?}
                 */
                (id, rowSelected) => {
                    /** @type {?} */
                    let emit = !rowSelected;
                    if (this.dg.selectionMode === 'default') {
                        this.dg.clearCheckeds();
                        emit = true;
                    }
                    this.dg.selectRow(id, emit, false);
                    this.dg['updateAllCheckboxStatus']();
                }));
            }
        });
        /** @type {?} */
        const runSelectRow = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const dblclickTimer = this.dg.dblclickRow.observers.length ? 200 : 0;
            if (isClickSameRow()) {
                if (diff < dblclickTimer) {
                    this.dg.writeConsole('双击');
                    //清除上一次单击的定时器ID
                    clearTimeout(this['lastTapTimeFunc']);
                }
                else {
                    //定时器id
                    this['lastTapTimeFunc'] = setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        runTdClick();
                    }), dblclickTimer);
                }
            }
            else {
                this['lastTapTimeFunc'] = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    runTdClick();
                }), dblclickTimer ? 180 : 0);
            }
            this._clickCellWeakMap.set(this.el.nativeElement, td.parentElement);
        });
        if (!this.dg.editable && td) {
            // 解决超链点击事件，要先执行选中行
            $event.stopPropagation();
            runSelectRow();
            return;
        }
        if (this.dg.editMode === 'row') {
            if (this.dg.exitRowEditingWhenBodyClick && this.dg.isEditing()) {
                this.dg.endEditing();
            }
            this._selectRow(td, (/**
             * @param {?} id
             * @param {?} rowSelected
             * @return {?}
             */
            (id, rowSelected) => {
                this.dg.selectRow(id, !rowSelected, false);
            }));
            return;
        }
        if (!td && this.dg.currentCell) {
            td = this.dg.currentCell.cellElement;
            if (td && td.closeEdit) {
                $event.stopPropagation();
                td.closeEdit();
                return;
            }
        }
        if (td) {
            // 行禁用时
            if (this.dg.disableRow) {
                /** @type {?} */
                let rowData = null;
                /** @type {?} */
                let rowIndex = -1;
                if (td.gridCellData) {
                    rowData = td.gridCellData.rowData;
                    rowIndex = td.gridCellData.rowIndex;
                }
                else {
                    /** @type {?} */
                    const rowInfo = this.dg.getRowIdByTr(td.parentElement);
                    if (rowInfo) {
                        rowData = rowInfo.data;
                        rowIndex = rowInfo.index;
                    }
                }
                if (rowData) {
                    if (this.dg.disableRow(rowData, rowIndex)) {
                        this.dg.endEditing();
                        return;
                    }
                }
                else {
                    this.dg.writeConsole('未获取到行数据。');
                    return;
                }
            }
            $event.stopPropagation();
            if (this.dg.editable && this.dg.editMode === 'cell') {
                if (td.edit) {
                    this._selectRow(td, (/**
                     * @return {?}
                     */
                    () => {
                        td.edit($event);
                    }));
                }
                else {
                    // 允许编辑点击行号时，可以选中行
                    if (td.selectCell || td.className.indexOf('f-datagrid-cell-rownumber') > -1) {
                        runSelectRow();
                    }
                    else {
                        // 当点分组行或合计行时，须结束编辑
                        this.dg.isEditing() && this.dg.endEditing();
                    }
                }
            }
            else {
                if (td.selectCell) {
                    runSelectRow();
                }
                else {
                    if (this.dg.isEditing() && (this.dg.exitRowEditingWhenBodyClick || this.dg.editMode === 'cell')) {
                        this.dg.endEditing();
                    }
                    // this._selectRow(td, (id, rowSelected) => {
                    //     this.dg.selectRow(id, !rowSelected, false);
                    // });
                    runTdClick();
                }
            }
        }
    }
    /**
     * @private
     * @param {?} tdEl
     * @param {?} callback
     * @return {?}
     */
    _selectRow(tdEl, callback) {
        if (tdEl) {
            /** @type {?} */
            const tr = tdEl.parentElement;
            /** @type {?} */
            const rowInfo = this.dg.getRowIdByTr(tr);
            if (!rowInfo) {
                return;
            }
            const { data, index, id } = rowInfo;
            /** @type {?} */
            const rowisSelected = this.dfs.isRowSelected(id);
            this.dg._beforeSelectRow$(index, data, id).pipe(takeUntil(this.destroy$)).subscribe((/**
             * @param {?} t
             * @return {?}
             */
            (t) => {
                if (t) {
                    callback(id, rowisSelected);
                }
            }));
        }
    }
}
DatagridBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-body',
                template: "<!--\r\n * @Author: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @Date: 2019-08-06 07:43:07\r\n * @LastEditors: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @LastEditTime: 2019-11-26 08:20:46\r\n * @QQ: 1055818239\r\n * @Version: v0.0.1\r\n -->\r\n\r\n<ng-container  *ngIf=\"(!data || !data.length) && !dg.useBlankWhenDataIsEmpty\" >\r\n\r\n    <div *ngIf=\"!dg.emptyTemplate && !dg.emptyComponentType\" class=\"d-flex flex-column f-datagrid-norecords\"\r\n        style=\"position:absolute; margin:0;left: 0; z-index: 1;justify-content: center; align-items: center;pointer-events: none;\" \r\n        [ngStyle]=\"bodyStyle\" [style.top.px]=\"top\" [style.width.px]=\"viewportW\" >\r\n        <div class=\"f-datagrid-norecords-content\" style=\"margin: 0;width: 100%;position: relative; top: 0\">\r\n            {{ 'datagrid.emptyMessage' | locale }}\r\n        </div>\r\n    </div>\r\n    <div class=\"f-datagrid-body\" [ngStyle]=\"bodyStyle\" [style.top.px]=\"top\" [style.width.px]=\"viewportW\" style=\"z-index: 1;\"  *ngIf=\"dg.emptyTemplate && !dg.emptyComponentType\">\r\n        <ng-container #emptyTemplate [ngTemplateOutlet]=\"dg.emptyTemplate\" ></ng-container>\r\n    </div>\r\n    <div class=\"f-datagrid-body\" [ngStyle]=\"bodyStyle\" [style.top.px]=\"top\" [style.width.px]=\"viewportW\" style=\"z-index: 1;\"  *ngIf=\"dg.emptyComponentType\"\r\n    component-template [ctx]=\"{ instance: dg }\" [cmpRef]=\"dg.emptyComponentType\">\r\n    </div>\r\n   \r\n</ng-container>\r\n\r\n\r\n\r\n<div class=\"f-datagrid-body\" [ngStyle]=\"bodyStyle\" [style.top.px]=\"top\" [style.width.px]=\"viewportW\" \r\n[farris-context-menus]=\"contextMenuItems\" [disabled]=\"!dg.enableContextMenu\" [activeDomName]=\"'tr'\" [beforeShowContextMenu]=\"onBeforeShowContextMenu\"\r\n[menuClass]=\"'f-datagrid-context-menu'\">\r\n\r\n    <div #viewScrollContainer [scrollbar]=\"psConfig\" #ps=\"ngxScrollbar\"\r\n        class=\"ps f-datagrid-body-wheel-area\" \r\n        style=\"width: 100%;\"\r\n        [ngStyle]=\"bodyStyle\"\r\n        (psXReachEnd)=\"onPsXReachEnd($event)\"\r\n        (psScrollY)=\"onScrollToY($event)\"\r\n        (psScrollX)=\"onScrollToX($event)\" (psXReachStart)=\"onPsXReachStart($event)\"\r\n        [style.paddingRight.px]=\"scrollbarYWidth\">\r\n       \r\n        <div class=\"f-datagrid-norecords\"  [auto-height]=\"dg.autoHeight\" [wheelHeight]=\"dg.emptyDataHeight || 240\" style=\"height: 100%\" [style.width.px]=\"canvasWidth - 2\"  *ngIf=\"!data || !data.length\">\r\n            <!-- <div *ngIf=\"!dg.emptyTemplate\" class=\"f-datagrid-norecords-content\" style=\"width: 100%\" >{{ 'datagrid.emptyMessage' | locale }}</div>\r\n            <ng-container #emptyTemplate *ngIf=\"dg.emptyTemplate\" [ngTemplateOutlet]=\"dg.emptyTemplate\" ></ng-container> -->\r\n        </div>\r\n\r\n        <div [style.display]=\"dg.flatColumns?.length ? '': 'none'\"  *ngIf=\"data && data.length && !fast\"\r\n            class=\"f-datagrid-bg\" [auto-height]=\"dg.autoHeight\" [wheelHeight]=\"canvasHeight\"\r\n            [style.height.px]=\"canvasHeight\" [style.width.px]=\"totalWidth\" >\r\n            \r\n                <div #blankTop hidefocus style=\"width: 100%\" [style.height.px]=\"blankTopHeight\"></div>\r\n                \r\n                <div #fixedLeft class=\"f-datagrid-table f-datagrid-body-fixed-left\" style=\"z-index:999\" [class.f-datagrid-fixed-left-shadow]=\"!!scrollLeft && !dg.groupRows\"\r\n                    *ngIf=\"dg.showLineNumber || dg.showCheckbox || (columnsGroup?.leftFixed && columnsGroup?.leftFixed.length)\"  [style.width.px]=\"leftFixedWidth\" \r\n                    [style.transform]=\"'translate3d('+ scrollLeft +'px, 0px, 0px)'\">\r\n\r\n                    <fixed-left-rows [columns]=\"columnsGroup?.leftFixed\" [checkedRows]=\"checkedRows\" [selectedRows]=\"selectedRows\" [data]=\"rows\"></fixed-left-rows>\r\n                </div>\r\n\r\n                <div #fixedRight class=\"f-datagrid-table f-datagrid-body-fixed-right\" \r\n                    *ngIf=\"columnsGroup?.rightFixed && columnsGroup?.rightFixed.length\"\r\n                    [class.f-datagrid-fixed-right-shadow]=\"showRightShadow\" \r\n                    style=\"border: 0\" [style.width.px]=\"rightFixedWidth\" \r\n                    [style.transform]=\"'translate3d('+ fixedRightScrollLeft +'px, 0px, 0px)'\">\r\n                    \r\n                    <datagrid-rows #rightRows [fixedRight]=\"true\" [startRowIndex]=\"startRowIndex\" \r\n                    [width]=\"columnsGroup?.rightFixedWidth\"\r\n                    [columns]=\"columnsGroup?.rightFixed\" [data]=\"rows\"></datagrid-rows>\r\n                </div>\r\n\r\n                <div #main [style.width.px]=\"colsWidth\" style=\"position: relative;\" [style.left.px]=\"leftFixedWidth\" class=\"f-datagrid-table f-datagrid-body-center\">\r\n                    <datagrid-rows #mainRows [hasFixedColumns]=\"columnsGroup?.leftFixed && columnsGroup?.leftFixed?.length\" [startRowIndex]=\"startRowIndex\" [columns]=\"columnsGroup?.normalColumns\" [data]=\"rows\"></datagrid-rows>\r\n                </div>\r\n\r\n                <div hidefocus style=\"width: 100%\" [style.height.px]=\"blankBottomHeight\"></div>\r\n\r\n        </div>\r\n\r\n\r\n        <div [style.display]=\"dg.flatColumns?.length ? '': 'none'\"  *ngIf=\"data && data.length && fast\"\r\n        class=\"f-datagrid-bg\" [auto-height]=\"dg.autoHeight\" [wheelHeight]=\"canvasHeight\"\r\n        [style.height.px]=\"canvasHeight\" [style.width.px]=\"totalWidth\" >\r\n        \r\n                <div #blankTop hidefocus style=\"width: 100%\" [style.height.px]=\"blankTopHeight\"></div>\r\n\r\n                <div #main style=\"position: relative;\"  class=\"f-datagrid-table f-datagrid-body-center\">\r\n                    <datagrid-rows #mainRows [hasFixedColumns]=\"columnsGroup?.leftFixed && columnsGroup?.leftFixed?.length\"  [startRowIndex]=\"startRowIndex\" [columns]=\"columnsGroup?.columns\" [data]=\"rows\"></datagrid-rows>\r\n                </div>\r\n\r\n                <div hidefocus style=\"width: 100%\" [style.height.px]=\"blankBottomHeight\"></div>\r\n\r\n        </div>\r\n    </div>\r\n\r\n    <scrollbar-arrows [scrollbarXActive]=\"ps.instance && ps.instance.scrollbarXActive\" [scrollbarYActive]=\"ps.instance && ps.instance.scrollbarYActive\" \r\n    *ngIf=\"dg.scrollBarShowMode === 'allways' && dg.showScrollArrow\" (hasYScrollbar)=\"hasYScrollbar($event)\" (scrollMoveTo)=\"onClickScrollArrow($event)\"\r\n    [reachX]=\"ps.instance && ps.instance.reach.x\" [reachY]=\"ps.instance && ps.instance.reach.y\"></scrollbar-arrows>\r\n\r\n\r\n</div>\r\n\r\n\r\n\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
DatagridBodyComponent.ctorParameters = () => [
    { type: Injector },
    { type: ApplicationRef },
    { type: DatagridComponent, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
DatagridBodyComponent.propDecorators = {
    footerHeight: [{ type: Input }],
    canvasWidth: [{ type: Input }],
    columnsGroup: [{ type: Input }],
    topHideHeight: [{ type: Input }],
    bottomHideHeight: [{ type: Input }],
    startRowIndex: [{ type: Input }],
    data: [{ type: Input }],
    dataChange: [{ type: Output }],
    scrollBarMode: [{ type: Input }],
    contextMenuItems: [{ type: Input }],
    checkedRows: [{ type: Input }],
    fast: [{ type: Input }],
    ps: [{ type: ViewChild, args: ['ps',] }],
    tableRowsCmp: [{ type: ViewChild, args: ['mainRows',] }],
    rightRowsCmp: [{ type: ViewChild, args: ['rightRows',] }],
    fixedLeftEl: [{ type: ViewChild, args: ['fixedLeft',] }],
    fixedRightEl: [{ type: ViewChild, args: ['fixedRight',] }],
    mainArea: [{ type: ViewChild, args: ['main',] }],
    viewScrollContainer: [{ type: ViewChild, args: ['viewScrollContainer',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridRowHoverDirective {
    /**
     * @param {?} dg
     * @param {?} dgb
     * @param {?} cd
     * @param {?} el
     * @param {?} zone
     * @param {?} render
     */
    constructor(dg, dgb, cd, el, zone, render) {
        this.dg = dg;
        this.dgb = dgb;
        this.cd = cd;
        this.el = el;
        this.zone = zone;
        this.render = render;
        this._mouseenter = null;
        this._mouseleave = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.dg.rowHover && !this.dg.fast) {
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this._mouseenter = Utils.on(this.el.nativeElement, 'mouseenter', this.onmouseenter.bind(this), { target: '.f-datagrid-body-row', options: { capture: true } });
                this._mouseleave = Utils.on(this.el.nativeElement, 'mouseleave', this.onmouseleave.bind(this), { target: '.f-datagrid-body-row', options: { capture: true } });
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._mouseenter) {
            this._mouseenter();
        }
        if (this._mouseleave) {
            this._mouseleave();
        }
    }
    // @HostListener('mouseenter')
    /**
     * @param {?} event
     * @return {?}
     */
    onmouseenter(event) {
        this.setRowHoverCls(event);
    }
    // @HostListener('mouseleave')
    /**
     * @param {?} event
     * @return {?}
     */
    onmouseleave(event) {
        this.setRowHoverCls(event, false);
    }
    /**
     * @param {?} event
     * @param {?=} hover
     * @return {?}
     */
    setRowHoverCls(event, hover = true) {
        if (!this.dg.rowHover) {
            return;
        }
        if (!event.target.matches('.f-datagrid-body-row')) {
            return;
        }
        this.rowIndex = event.target.getAttribute('index');
        /** @type {?} */
        const leftTableCls = 'f-datagrid-body-fixed-left';
        /** @type {?} */
        const rightTableCls = 'f-datagrid-body-fixed-right';
        /** @type {?} */
        const centerTableCls = 'f-datagrid-body-center';
        /** @type {?} */
        const body = this.dg.el.nativeElement.querySelector('.f-datagrid-body');
        if (!body) {
            return;
        }
        /** @type {?} */
        const leftTableDom = body.querySelector(`.${leftTableCls}`);
        /** @type {?} */
        const rightTableDom = body.querySelector(`.${rightTableCls}`);
        /** @type {?} */
        const centerTableDom = body.querySelector(`.${centerTableCls}`);
        /** @type {?} */
        const method = hover ? 'addClass' : 'removeClass';
        /** @type {?} */
        const trSelector = `tr[index="${this.rowIndex}"]`;
        /** @type {?} */
        const dom = this.el.nativeElement.closest('div');
        if (dom && dom.className) {
            /** @type {?} */
            const trDom = centerTableDom.querySelector(trSelector);
            if (!trDom) {
                return;
            }
            if (trDom.className.indexOf('f-datagrid-disable-row') > -1) {
                return;
            }
            /** @type {?} */
            let ltr = null;
            /** @type {?} */
            let rtr = null;
            if (rightTableDom) {
                rtr = rightTableDom.querySelector(trSelector);
            }
            if (leftTableDom) {
                ltr = leftTableDom.querySelector(trSelector);
            }
            if (leftTableDom && ltr) {
                this.render[method](ltr, this.dg.hoverRowCls);
            }
            if (rightTableDom && rtr) {
                this.render[method](rtr, this.dg.hoverRowCls);
            }
            this.render[method](trDom, this.dg.hoverRowCls);
        }
    }
}
DatagridRowHoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[row-hover]',
                exportAs: 'rowHover'
            },] }
];
/** @nocollapse */
DatagridRowHoverDirective.ctorParameters = () => [
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] },
    { type: DatagridBodyComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridBodyComponent)),] }] },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
DatagridRowHoverDirective.propDecorators = {
    rowIndex: [{ type: Input }],
    rowData: [{ type: Input, args: ['row-hover',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridRowDirective {
    /**
     * @param {?} dg
     * @param {?} injector
     * @param {?} fb
     * @param {?} el
     * @param {?} render
     * @param {?} drHover
     */
    constructor(dg, injector, fb, el, render, drHover) {
        this.dg = dg;
        this.injector = injector;
        this.fb = fb;
        this.el = el;
        this.render = render;
        this.drHover = drHover;
        this.editable = false;
        this.clickHandler = new EventEmitter();
        this.rowUpdated = new EventEmitter();
        this.form = new FormGroup({});
        this.documentRowDblclickEvent = null;
        this.columnsChangedSubscription = null;
        this.datasourceChangedSubscription = null;
        this.subscriptions = [];
        this.destroy$ = new Subject();
        this.dfs = this.injector.get(DatagridFacadeService);
        this.ngZone = this.injector.get(NgZone);
        this.cd = this.injector.get(ChangeDetectorRef);
        this.dgb = this.injector.get(DatagridBodyComponent);
    }
    /**
     * @return {?}
     */
    get rowId() {
        if (this.rowData) {
            return this.dfs.primaryId(this.rowData);
        }
        return null;
    }
    /**
     * @return {?}
     */
    get disabled() {
        if (this.dg.disableRow) {
            return this.dg.disableRow(this.rowData, this.rowIndex);
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.datasourceChangedSubscription = this.dg.dgs.onDataSourceChange.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.renderCustomStyle();
        }));
        this.columnsChangedSubscription = this.dg.dgs.columnsChanged.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.createControl();
        }));
        /** @type {?} */
        const s$ = this.dg.dfs.rowUpdate$.pipe(takeUntil(this.destroy$), filter((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            return row.keyID === this.rowId;
        }))).subscribe((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            if (row && row.data) {
                // this.rowData = cloneDeep(row.data);
                if (this.dfs.primaryId(row.data) === this.rowId) {
                    this.renderCustomStyle(row.data);
                }
                // 此处会导至rowData 与数据源的引用不一致
                // this.rowData = {...row.data};
                // 更新当前数据
                Object.assign(this.rowData, row.data);
                this.updateCellEmptyStyle();
                this.rowUpdated.emit(this.rowData);
                this.cd.detectChanges();
            }
        }));
        this.subscriptions.push(s$);
        /** @type {?} */
        const s1$ = this.dg.dgs.updateEmptyStyle$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.updateCellEmptyStyle();
        }));
        this.subscriptions.push(s1$);
        /** @type {?} */
        const s2$ = this.dg.dfs.selectRow$.pipe(takeUntil(this.destroy$)).pipe(filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            return r.id === this.rowId;
        }))).subscribe((/**
         * @return {?}
         */
        () => {
            if (this.dg.selectedRow && !this.dg.selectedRow.dr) {
                /** @type {?} */
                const p = this.getRowPosition();
                if (p === 'left') {
                    this.dg.selectedRow.drl = this;
                }
                else if (p === 'right') {
                    this.dg.selectedRow.drr = this;
                }
                else {
                    this.dg.selectedRow.dr = this;
                }
            }
        }));
        this.subscriptions.push(s2$);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        if (this.columnsChangedSubscription) {
            this.columnsChangedSubscription.unsubscribe();
            this.columnsChangedSubscription = null;
        }
        if (this.datasourceChangedSubscription) {
            this.datasourceChangedSubscription.unsubscribe();
            this.datasourceChangedSubscription = null;
        }
        if (this.subscriptions && this.subscriptions.length) {
            this.subscriptions.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => n.unsubscribe()));
            this.subscriptions = [];
        }
        if (this.form) {
            this.form = null;
        }
        this.cells = null;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.rowData && !changes.rowData.isFirstChange()) {
            this.updateCellEmptyStyle();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.renderCustomStyle();
        this.updateCellEmptyStyle();
    }
    /**
     * @private
     * @return {?}
     */
    getRowPosition() {
        /** @type {?} */
        const id = this.el.nativeElement.id;
        if (id.indexOf('fixedleft') > -1) {
            return 'left';
        }
        else if (id.indexOf('fixedright') > -1) {
            return 'right';
        }
        else {
            return 'center';
        }
    }
    /**
     * @param {?=} rowData
     * @return {?}
     */
    renderCustomStyle(rowData = null) {
        if (this.dg.rowStyler) {
            /** @type {?} */
            const _rd = rowData || this.rowData;
            /** @type {?} */
            const trStyle = this.dg.rowStyler(_rd, this.rowIndex);
            /** @type {?} */
            const tr = this.el.nativeElement;
            /** @type {?} */
            const _cls = Array.from(tr.classList).find((/**
             * @param {?} n
             * @return {?}
             */
            (n) => n.indexOf(CUSTOM_ROW_CLS) > -1));
            if (_cls) {
                tr.classList.remove(_cls);
            }
            if (trStyle && Object.keys(trStyle).length) {
                /** @type {?} */
                const str = CUSTOM_ROW_CLS + this.dg.idService.encrypt(JSON.stringify(trStyle));
                this.dg.renderCustomStyle2(trStyle, this.el.nativeElement, 'f-datagrid-body .' + str);
                this.render.addClass(this.el.nativeElement, str);
            }
        }
    }
    // @HostListener('click', ['$event'])
    /**
     * @param {?} event
     * @return {?}
     */
    onRowClick(event) {
        /*
                if (event.target['className'] && event.target['className'].indexOf('checkbox-column') > -1) {
                    return;
                }
        
                if (!this.dg.enableSelectRow) {
                    return;
                }
        
                if (this.dg.disabled) {
                    return;
                }
        
                if (this.dg.currentCell && this.dg.currentCell.isEditing && this.rowId !== this.dg.currentCell.rowId ) {
                    return;
                }
        
        
                if (this.dg.disableRow) {
                    if (this.dg.disableRow(this.rowData, this.rowIndex)) {
                        event.stopPropagation();
                        return false;
                    }
                }
        
                // if (!this.dg.editable) {
                //     event.stopPropagation();
                // }
        
                const rowId = this.dfs.primaryId(this.rowData);
        
                if (!rowId) {
                    this.dg.writeConsole(`在第 ${this.rowIndex + 1} 行，主键字段[${this.dg.idField}]的值为 空，请检查相关数据。`);
                }
        
                const beforEventParam = {
                    rowIndex: this.rowIndex,
                    rowData: this.rowData,
                    gridInstance: this.dg
                };
        
                if (!event.shiftKey) {
                    this.dg.dgs.focusRowChanged.emit({
                        rowIndex: this.rowIndex,
                        rowData: this.rowData
                    });
                }
                const useNewSelectionMode = this.dg.sms.beforRowClick({ ...beforEventParam, e: event, id: rowId, dr: this });
                if (useNewSelectionMode) {
                    return;
                }
        
                if (!this.dfs.isRowSelected(rowId)) {
                    const canendedit = this.dg.endRowEdit();
        
                    if (!canendedit || canendedit.canEnd) {
                        this.dg.beforeSelect(beforEventParam).pipe( takeUntil(this.destroy$)).pipe(
                            delay(200)
                        ).subscribe((canSelect: boolean) => {
                            if (canSelect) {
                                this.dg.removeCellSelectedCls();
                                this.dfs.selectRow(this.rowIndex, this.rowData, {instance: this.dg});
                                if (this.dg.selectedRow) {
                                    this.dg.selectedRow.dr = this;
                                }
                                const trCLS = this.el.nativeElement.className;
                                if (trCLS.indexOf('f-datagrid-row-selected') === -1) {
                                    this.el.nativeElement.className = trCLS + ' f-datagrid-row-selected';
                                }
                                // this.drHover.setRowHoverCls(false);
                                // this.dg.selectChanged.emit(this.dg.selectedRow);
                                this.clickHandler.emit();
                            }
                            this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
                            this.dg.dgs.setSelecedRow.emit({ selected: true, id: this.dfs.primaryId(this.rowData) });
                        });
                    }
                } else {
                    if (this.dg.selectedRow && !this.dg.selectedRow.dr) {
                        this.dg.selectedRow.dr = this;
                    }
        
                    if (!this.dg.keepSelect) {
                        this.dg.beforeUnselect(beforEventParam).pipe(
                            takeUntil(this.destroy$),
                        ).subscribe((canUnselect: boolean) => {
                            if (canUnselect) {
                                // this.dg.unSelect.emit(this.dg.selectedRow);
                                this.dfs.unSelectRow(this.rowIndex, this.rowData, {instance: this.dg});
        
                                const trCLS = this.el.nativeElement.className;
                                if (trCLS.indexOf('f-datagrid-row-selected') > -1) {
                                    this.el.nativeElement.className = trCLS.replace('f-datagrid-row-selected', '');
                                }
                            }
                            this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
                            this.dg.dgs.setSelecedRow.emit();
                        });
                    } else {
                        this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
                    }
                }
                    */
        // this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
    }
    /**
     * @return {?}
     */
    initFormControl() {
        this.form = this.fb.group({});
        this.createControl();
        this.form['bindingData'] = this.rowData;
    }
    /**
     * @return {?}
     */
    createControl() {
        if (this.dg && this.dg.flatColumns) {
            this.dg.flatColumns.forEach((/**
             * @param {?} col
             * @return {?}
             */
            col => {
                if (!col.editor && !col.editorTemplate) {
                    return;
                }
                if (!this.form.controls[col.field]) {
                    /** @type {?} */
                    const control = this.createFormControl(col);
                    this.form.addControl(col.field, control);
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} col
     * @return {?}
     */
    createFormControl(col) {
        return this.fb.control(Utils.getValue(col.field, this.rowData), {
            validators: col.editor ? this.bindValidations(col.editor.validators) : null
        });
    }
    /**
     * @private
     * @param {?} validators
     * @return {?}
     */
    bindValidations(validators) {
        /** @type {?} */
        const validations = [];
        if (validators && validators.length) {
            validators.forEach((/**
             * @param {?} v
             * @return {?}
             */
            (v) => {
                /** @type {?} */
                let validation = null;
                switch (v.type) {
                    case 'required':
                        validation = Validators.required;
                        break;
                    case 'min':
                        validation = Validators.min(v.value);
                        break;
                    case 'max':
                        validation = Validators.max(v.value);
                        break;
                    case 'minLength':
                        validation = Validators.minLength(v.value);
                        break;
                    case 'maxLength':
                        validation = Validators.maxLength(v.value);
                        break;
                    case 'email':
                        validation = Validators.email;
                        break;
                    case 'requiredTrue':
                        validation = Validators.requiredTrue;
                        break;
                    case 'pattern':
                        validation = Validators.pattern(v.value);
                        break;
                }
                if (validation) {
                    validations.push(validation);
                }
                else {
                    if (this.dg.validators && this.dg.validators.length) {
                        /** @type {?} */
                        const vfn = this.dg.validators.find((/**
                         * @param {?} vr
                         * @return {?}
                         */
                        vr => vr.name === v.type));
                        if (vfn) {
                            validation = vfn.value(this.rowData);
                            validations.push(validation);
                        }
                    }
                }
            }));
        }
        return validations;
    }
    /**
     * @return {?}
     */
    refresh() {
        this.updateRowHeight();
        this.updateCellEmptyStyle();
    }
    /**
     * @return {?}
     */
    updateRowHeight() {
        if (!this.dg.nowrap) {
            /** @type {?} */
            const centerTr = this.dgb.mainArea.nativeElement.querySelector('tr[index="' + this.rowIndex + '"]');
            centerTr.style.height = 'auto';
            /** @type {?} */
            const trHeight = centerTr.offsetHeight;
            /** @type {?} */
            let leftTrDom = null;
            /** @type {?} */
            let rightTrDom = null;
            /** @type {?} */
            const heightSizeList = [trHeight];
            if (this.dgb) {
                if (this.dgb.fixedLeftEl) {
                    leftTrDom = this.dgb.fixedLeftEl.nativeElement.querySelector('tr[index="' + this.rowIndex + '"]');
                    if (leftTrDom) {
                        leftTrDom.style.height = 'auto';
                        heightSizeList.push(leftTrDom.offsetHeight);
                    }
                }
                if (this.dgb.fixedRightEl) {
                    rightTrDom = this.dgb.fixedRightEl.nativeElement.querySelector('tr[index="' + this.rowIndex + '"]');
                    if (rightTrDom) {
                        rightTrDom.style.height = 'auto';
                        heightSizeList.push(rightTrDom.offsetHeight);
                    }
                }
                /** @type {?} */
                const maxHeight = Math.max(...heightSizeList);
                centerTr.style.height = `${maxHeight}px`;
                if (leftTrDom) {
                    leftTrDom.style.height = `${maxHeight}px`;
                }
                if (rightTrDom) {
                    rightTrDom.style.height = `${maxHeight}px`;
                }
                this.cd.markForCheck();
                this.dgb.updateCanvasHeight();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateCellEmptyStyle() {
        if (!this.dg.enableEditCellStyle) {
            return;
        }
        /** @type {?} */
        let rowIsDisabled = false;
        if (this.dg.disableRow) {
            rowIsDisabled = this.dg.disableRow(this.rowData, this.rowIndex);
        }
        /** @type {?} */
        const updateCellEmptyText = (/**
         * @param {?} cells
         * @return {?}
         */
        (cells) => {
            if (cells.length) {
                for (let k = 0; k < cells.length; k++) {
                    /** @type {?} */
                    const field = cells[k].getAttribute('field');
                    if (field) {
                        /** @type {?} */
                        const col = this.dfs.getColumn(field);
                        if (col) {
                            if (!col.editor) {
                                continue;
                            }
                            /** @type {?} */
                            const cls = col.align === 'right' ? 'allow-edit-cell-left' : 'allow-edit-cell';
                            /** @type {?} */
                            const emptyicon_cls = ALLOW_EDIT_CELL_HIGHLIGHT_CLS[col.editor.type];
                            /** @type {?} */
                            const span = cells[k].querySelector('.cell-text-box');
                            /** @type {?} */
                            const colVal = Utils.getValue(field, this.rowData);
                            /** @type {?} */
                            const fmtVal = this.dg.colFormatSer.format(colVal, this.rowData, col.formatter);
                            if (!this.dg.editable || rowIsDisabled || this.dg.cellIsReadOnly(col, this.rowData)) {
                                cells[k].className = cells[k].className.replace(cls, '');
                                cells[k].className = cells[k].className.replace(emptyicon_cls, '');
                                if (span) {
                                    if (span.className.indexOf('cell-empty') > -1) {
                                        span.className = span.className.replace('cell-empty', '');
                                    }
                                    if (colVal === '' || colVal === null || colVal === undefined) {
                                        span.innerHTML = '';
                                    }
                                    else {
                                        span.innerHTML = fmtVal;
                                    }
                                }
                            }
                            else {
                                if (span) {
                                    if (colVal === '' || colVal === null || colVal === undefined) {
                                        if (span.className.indexOf('cell-empty') === -1) {
                                            span.className = span.className + ' cell-empty';
                                        }
                                        span.innerHTML = Utils.getWhenEmptyText(col, this.dg.localeService.localeId);
                                    }
                                    else {
                                        span.innerHTML = fmtVal;
                                    }
                                }
                                if (cells[k].className.indexOf('cell-readonly') > -1) {
                                    cells[k].className = cells[k].className.replace('cell-readonly', '');
                                }
                                if (cells[k].className.indexOf(cls) === -1) {
                                    this.render.addClass(cells[k], cls);
                                }
                                if (cells[k].className.indexOf(emptyicon_cls) === -1) {
                                    this.render.addClass(cells[k], emptyicon_cls);
                                }
                            }
                        }
                    }
                }
            }
        });
        // if (this.dgb.fixedLeftEl) {
        //     const leftTrDom = this.dgb.fixedLeftEl.nativeElement.querySelector('tr[index="' + this.rowIndex + '"]');
        //     if (leftTrDom) {
        //         updateCellEmptyText(leftTrDom.querySelectorAll('td[field]'));
        //     }
        // }
        /** @type {?} */
        const cells = this.el.nativeElement.querySelectorAll('td[field]:not([field="_datagrid-setting-control_"])');
        updateCellEmptyText(cells);
    }
}
DatagridRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[grid-row]',
                exportAs: 'gridRow'
            },] }
];
/** @nocollapse */
DatagridRowDirective.ctorParameters = () => [
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] },
    { type: Injector },
    { type: FormBuilder },
    { type: ElementRef },
    { type: Renderer2 },
    { type: DatagridRowHoverDirective, decorators: [{ type: Optional }, { type: Self }] }
];
DatagridRowDirective.propDecorators = {
    editable: [{ type: Input }],
    rowData: [{ type: Input, args: ['grid-row',] }],
    rowIndex: [{ type: Input }],
    clickHandler: [{ type: Output }],
    rowUpdated: [{ type: Output }],
    cells: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => DatagridCellComponent)), { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GridCellEditorDirective {
    /**
     * @param {?} resolver
     * @param {?} container
     * @param {?} app
     * @param {?} fb
     * @param {?} dg
     */
    constructor(resolver, container, app, fb, dg) {
        this.resolver = resolver;
        this.container = container;
        this.app = app;
        this.fb = fb;
        this.dg = dg;
        this.cfs = null;
        this.timer = null;
        this.cfs = this.dg.inject.get(ColumnFormatService);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.column.editor) {
            this.createCellEditor();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.dg.dgs.cellEditorCreated.emit({ editorRef: this.componentRef, column: this.column, cellEditorRef: this });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dg.dgs.cellEditorDestory.emit({ editorRef: this.componentRef, column: this.column, cellEditorRef: this });
        if (this.componentRef) {
            this.componentRef.destroy();
        }
        this.componentRef = null;
        if (this.timer) {
            clearTimeout(this.timer);
        }
    }
    /**
     * @private
     * @return {?}
     */
    createCellEditor() {
        /** @type {?} */
        const editorType = this.column.editor.type;
        if (!this.dg.editors[editorType]) {
            this.dg.writeConsole(`找不到名称为 ${editorType} 对应的类。`, 'error');
            return;
        }
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(this.dg.editors[editorType]);
        this.componentRef = this.container.createComponent(factory);
        // this.componentRef.instance.dg = this.dg;
        // this.app.attachView(this.componentRef.hostView);
        this.componentRef.instance.column = this.column;
        this.componentRef.instance.group = this.group;
        this.componentRef.instance.height = this.height;
        this.componentRef.instance.controlId = (this.dg.id || 'DATAGRID_EDITOR') + '_' + this.column.field;
        this.updateControlValue();
        this.componentRef.changeDetectorRef.markForCheck();
        this.componentRef.changeDetectorRef.detectChanges();
        // this.app.tick();
        if (this.timer) {
            clearTimeout(this.timer);
        }
        this.timer = setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.componentRef.instance.instance) {
                if (editorType === 'lookup') {
                    if (!this.componentRef.instance.instance.changeDetector.destroyed) {
                        this.componentRef.instance.instance.changeDetector.detectChanges();
                    }
                    // this.componentRef.instance['bindingData'] = this.rowData;
                }
                // if (editorType === 'textarea') {
                //     const textareaEl = this.componentRef.instance.inputElement;
                //     textareaEl.style.height = textareaEl.closest('tr').style.height;
                // }
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    updateControlValue() {
        if (this.group) {
            this.group['bindingData'] = this.rowData;
            if (this.group.controls[this.column.field]) {
                // if (this.column.editor.type === 'datepicker') {
                //     const dateRef = this.componentRef.instance.instance;
                //     if (dateRef) {
                //         setTimeout(() => {
                //             const { dateFormat } = dateRef.dateOpts;
                //             const val = this.cfs.format(this.value, this.rowData, {type: 'datetime', options: { format: dateFormat}});
                //             this.group.controls[this.column.field].setValue(val, { emitEvent: true });
                //         });
                //     }
                // } else {
                //     this.group.controls[this.column.field].setValue(this.value, { emitEvent: true });
                // }
                this.group.controls[this.column.field].setValue(this.value, { emitEvent: true });
            }
        }
    }
    /**
     * @return {?}
     */
    hideCover() {
        if (this.componentRef && this.column.editor && (this.column.editor.type === 'combolist' || this.column.editor.type === 'combo-lookup')) {
            this.componentRef.instance.hide(!1);
        }
    }
}
GridCellEditorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cell-editor]',
            },] }
];
/** @nocollapse */
GridCellEditorDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: ApplicationRef },
    { type: FormBuilder },
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] }
];
GridCellEditorDirective.propDecorators = {
    column: [{ type: Input }],
    group: [{ type: Input }],
    rowData: [{ type: Input }],
    value: [{ type: Input }],
    height: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SafePipe {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.dangerWords = ['<script', 'onerror', 'alert('];
    }
    /**
     * @param {?} value
     * @param {?} type
     * @return {?}
     */
    transform(value, type) {
        switch (type) {
            case 'html': {
                if (value === '' || value === null || value === undefined) {
                    return value;
                }
                // if (!this.hasDanger(value)) {
                //     return value;
                // }
                return this.sanitizer.bypassSecurityTrustHtml(value);
            }
            case 'style': return this.sanitizer.bypassSecurityTrustStyle(value);
            case 'script': return this.sanitizer.bypassSecurityTrustScript(value);
            case 'url': return this.sanitizer.bypassSecurityTrustUrl(value);
            case 'resourceUrl': return this.sanitizer.bypassSecurityTrustResourceUrl(value);
            default: throw new Error(`Invalid safe type specified: ${type}`);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    hasDanger(value) {
        if (typeof value === 'number' || typeof value === 'boolean') {
            return false;
        }
        /** @type {?} */
        let r = 0;
        this.dangerWords.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (value.indexOf(n) > -1) {
                r++;
            }
        }));
        return r !== 0;
    }
}
SafePipe.decorators = [
    { type: Pipe, args: [{
                name: 'safe'
            },] }
];
/** @nocollapse */
SafePipe.ctorParameters = () => [
    { type: DomSanitizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridCellComponent {
    /**
     * @param {?} dg
     * @param {?} dr
     * @param {?} el
     * @param {?} cd
     * @param {?} injector
     * @param {?} colFormatSer
     * @param {?} domSanitizer
     */
    constructor(dg, dr, el, cd, injector, colFormatSer, domSanitizer) {
        this.dg = dg;
        this.dr = dr;
        this.el = el;
        this.cd = cd;
        this.injector = injector;
        this.colFormatSer = colFormatSer;
        this.domSanitizer = domSanitizer;
        this.cls = '';
        this.lastColumn = false;
        // @ViewChild('celltip') celltip: DatagridCellTooltipDirective;
        this._isEditing = false;
        this.controlHeight = 'auto';
        this.isSelected = false;
        this._cellEditorTemplate = null;
        this.cellClick = new EventEmitter();
        this.cellDblClick = new EventEmitter();
        this.cellContext = {};
        this.cellStyler = {};
        this.safePipe = null;
        this.ro = null;
        this.canEdit = (/**
         * @return {?}
         */
        () => this.dg.editable && this.dg.editMode === 'cell' && this.column.editor);
        this.dfs = this.injector.get(DatagridFacadeService);
        this.dgs = this.injector.get(DatagridService);
        this.safePipe = new SafePipe(this.domSanitizer);
        this.render = this.injector.get(Renderer2);
        this.cfr = this.injector.get(ComponentFactoryResolver);
    }
    /**
     * @return {?}
     */
    get isEditing() {
        return this._isEditing;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set isEditing(v) {
        if (this._isEditing === v) {
            return;
        }
        this._isEditing = v;
        if (v) {
            if (!this.dr.form || !Object.keys(this.dr.form.controls).length) {
                this.dr.initFormControl();
            }
            if (this.column.editorTemplate && this.column.editorTemplate.elementRef) {
                this.cellContext.formGroup = this.dr.form;
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    if (this.el) {
                        /** @type {?} */
                        const input = this.el.nativeElement.querySelector('input,textarea');
                        if (input) {
                            input.focus();
                        }
                    }
                }), 10);
            }
        }
        if (this.column.editor && this.column.editor.type === 'textarea') {
            if (!this.dg.nowrap) {
                this.controlHeight = this.dr.el.nativeElement.offsetHeight;
            }
        }
        if (!this.cd['destroyed']) {
            this.cd.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    get cellEditorTemplate() {
        return this._cellEditorTemplate;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set cellEditorTemplate(v) {
        this._cellEditorTemplate = v;
        if (v) {
            this.dg.dgs.cellEditorCreated.emit({ editorRef: null, column: this.column, cellEditorRef: null, templateRef: v });
        }
    }
    /**
     * @return {?}
     */
    get value() {
        if (this.rowData && this.column && this.column.field) {
            return Utils.getValue(this.column.field, this.rowData);
        }
        return '';
    }
    /**
     * @return {?}
     */
    get formControl() {
        if (this.cellEditor && this.cellEditor.componentRef) {
            return this.cellEditor.componentRef.instance.formControl;
        }
        else if (this.column.editorTemplate) {
            return this.dr.form.get(this.column.field);
        }
        return null;
    }
    /**
     * @return {?}
     */
    get cellFormatterIsFn() {
        return typeof this.column.formatter === 'function' || this.column.formatter.type === 'boolean';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initCellTemplateContext();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.rowData && !changes.rowData.isFirstChange()) {
            this.initCellTemplateContext();
            this.buildCustomCellStyle();
            if (this.formControl) {
                /** @type {?} */
                const val = Utils.getValue(this.column.field, this.rowData);
                this.formControl.setValue(val);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    initCellTemplateContext() {
        this.cellContext = {
            field: this.column.field,
            rowIndex: this.rowIndex,
            rowData: this.rowData,
            column: this.column,
            instance: this,
            formGroup: this.dr.form,
            tools: {
                utils: this.dg.commonUtils,
                format: this.dg.colFormatSer,
                number: this.dg.colFormatSer['numberhelper'],
                date: this.dg.colFormatSer['datehelper']
            },
        };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.buildCustomCellStyle();
        /** @type {?} */
        const fieldClsName = 'cell-text-align__' + this.column.field.replace(/\./g, '_');
        this.render.addClass(this.cellContainer.nativeElement, fieldClsName);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.cellSubscription) {
            this.cellSubscription.unsubscribe();
            this.cellSubscription = null;
        }
        if (this.rowUpdateSubscription) {
            this.rowUpdateSubscription.unsubscribe();
            this.rowUpdateSubscription = null;
        }
        this.cellContext = null;
    }
    /**
     * @private
     * @param {?=} rowData
     * @return {?}
     */
    buildCustomCellStyle(rowData = null) {
        /** @type {?} */
        const td = this.el.nativeElement.parentNode;
        /** @type {?} */
        const fieldName = this.column.field.replace(/\./g, '_');
        if (!td.id) {
            td.id = TR_PREFIX + this.dr.rowId + '_' + this.rowIndex + '-' + fieldName;
        }
        // td.id = td.id.replace(/\./g, '_');
        /** @type {?} */
        let clsName = 'customcellcls_' + fieldName + '_';
        /** @type {?} */
        const removeCls = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const _cls = Array.from(td.classList).find((/**
             * @param {?} n
             * @return {?}
             */
            (n) => n.indexOf('customcellcls_') > -1));
            if (_cls) {
                td.classList.remove(_cls);
            }
        });
        if (this.column.styler) {
            /** @type {?} */
            const _rd = rowData || this.rowData;
            /** @type {?} */
            const fieldValue = Utils.getValue(this.column.field, _rd);
            /** @type {?} */
            const cs = this.column.styler(fieldValue, _rd, this.rowIndex);
            if (cs && Object.keys(cs).length) {
                removeCls();
                // clsName = clsName.replace(/\./g, '_');
                clsName = clsName + this.dg.idService.encrypt(JSON.stringify(cs));
                this.render.addClass(td, clsName);
                this.dg.renderCustomStyle2(cs, td, clsName);
            }
        }
        else {
            removeCls();
        }
    }
    /**
     * @param {?=} val
     * @return {?}
     */
    updateValue(val) {
        if (this.dr.form) {
            // this.rowData = Object.assign(this.rowData, this.dr.form.value);
            Utils.setValue(this.column.field, val, this.rowData);
            // this.rowData = {...this.rowData};
            /** @type {?} */
            const rowid = this.rowData[this.dg.idField];
            /** @type {?} */
            const item = this.dg.data.find((/**
             * @param {?} n
             * @return {?}
             */
            n => n[this.dg.idField] === rowid));
            if (item) {
                Utils.setValue(this.column.field, val, item);
            }
            this.dfs.updateCheckedData(rowid, { [this.column.field]: val });
            if (!this.cd['destroyed']) {
                this.cd.detectChanges();
            }
        }
    }
}
DatagridCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'grid-body-cell',
                template: `
    <div
     [cell-tooltip]="column.showTips && !isEditing"   [attr.tipMode]=" column.tipMode || 'auto'"
     [attr.message]="column | tipmsg: rowData"  [attr.position]=" column?.tipOptions?.position || 'top-left'"
     [attr.tipWidth]="column?.tipOptions?.width" [attr.tipHeight]="column?.tipOptions?.height"
     class="f-datagrid-cell-content" #cellContainer  [component-template]="column" [ctx]="cellContext"
    >
        <ng-container *ngIf="!isEditing && !column.template && !column.componentType">
            <ng-container *ngIf="column.formatter">
                <span class="cell-text-box" *ngIf="cellFormatterIsFn" [innerHtml]=" column | formatCellData: rowData | safe: 'html'"></span>
                <span class="cell-text-box" *ngIf="!cellFormatterIsFn">{{  column | formatCellData: rowData }}</span>
            </ng-container>
            <span *ngIf="!column.formatter" class="cell-text-box" [class.grid-cell-nowrap]="dg.nowrap" [class.grid-cell-wrap]="!dg.nowrap">{{  column | formatCellData: rowData }}</span>
        </ng-container>

        <ng-container #cellTemplate *ngIf="!isEditing && column.template && !column.componentType" [ngTemplateOutlet]="column.template" [ngTemplateOutletContext]="{$implicit: cellContext}"></ng-container>
        <ng-container #cellEditorTemplate *ngIf="isEditing && column.editorTemplate" [ngTemplateOutlet]="column.editorTemplate" [ngTemplateOutletContext]="{$implicit: cellContext}"></ng-container>
        <ng-container #editorTemplate *ngIf="isEditing && !column.editorTemplate" cell-editor [height]="controlHeight" [rowData]="rowData" [value]="value" [column]="column" [group]="dr.form"></ng-container>
    </div>
    `,
                changeDetection: ChangeDetectionStrategy.Default
            }] }
];
/** @nocollapse */
DatagridCellComponent.ctorParameters = () => [
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] },
    { type: DatagridRowDirective, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridRowDirective)),] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Injector },
    { type: ColumnFormatService },
    { type: DomSanitizer }
];
DatagridCellComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    cls: [{ type: Input }],
    column: [{ type: Input }],
    rowData: [{ type: Input }],
    rowIndex: [{ type: Input }],
    lastColumn: [{ type: Input }],
    isEditing: [{ type: Input }],
    isSelected: [{ type: Input }],
    cellContainer: [{ type: ViewChild, args: ['cellContainer',] }],
    cellTemplateVcr: [{ type: ViewChild, args: ['cellTemplate', { read: ViewContainerRef },] }],
    cellEditorTemplate: [{ type: ViewChild, args: ['cellEditorTemplate', { read: ViewContainerRef },] }],
    cellEditor: [{ type: ViewChild, args: [GridCellEditorDirective,] }],
    cellClick: [{ type: Output }],
    cellDblClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridCellEditableDirective {
    /**
     * @param {?} injector
     * @param {?} el
     * @param {?} render
     * @param {?} dg
     * @param {?} ngZone
     */
    constructor(injector, el, render, dg, ngZone) {
        this.injector = injector;
        this.el = el;
        this.render = render;
        this.dg = dg;
        this.ngZone = ngZone;
        // private _readonly$ = null;
        this.cellEditorCreatedSubscription = null;
        this.cellEditorDestorySubscription = null;
        this.destroy$ = new Subject();
        this.validMessageEle = null;
        this.dgb = this.injector.get(DatagridBodyComponent);
        this.dr = this.injector.get(DatagridRowDirective);
        this.dfs = this.injector.get(DatagridFacadeService);
        this.dgs = this.injector.get(DatagridService);
        if (!this.cellEditorCreatedSubscription) {
            this.cellEditorCreatedSubscription = this.dgs.cellEditorCreated.pipe(takeUntil(this.destroy$)).pipe(filter((/**
             * @param {?} __0
             * @return {?}
             */
            ({ column, editorRef, cellEditorRef, templateRef }) => {
                return column.field === this.column.field && this.dg.selectedRow.id === this.dr.rowId;
            }))).subscribe((/**
             * @param {?} __0
             * @return {?}
             */
            ({ editorRef, cellEditorRef, templateRef }) => {
                if (editorRef) {
                    this['editor'] = editorRef.instance;
                    this['formControl'] = (/** @type {?} */ (this.editor.formControl));
                    this.cellEditorRef = cellEditorRef;
                    this.emitBeginEdit();
                }
                else {
                    this['formControl'] = (/** @type {?} */ (this.dr.form.get(this.column.field)));
                    this.bindEditorInputEvent();
                    this.dg.beginEdit.emit({ editor: null, column: this.column, rowData: this.rowData, gridInstance: this.dg, template: templateRef });
                }
                this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
            }));
        }
        this.dg.dgs.cellEditorDestory.pipe(takeUntil(this.destroy$)).pipe(filter((/**
         * @param {?} __0
         * @return {?}
         */
        ({ column }) => {
            return this.dg.selectedRow && column.field === this.column.field && this.dg.selectedRow.id === this.dr.rowId;
        }))).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (this.dg.editMode === 'cell') {
                this.dg.selectedRow.editors = [];
                if (this.dg.currentCell) {
                    this.dg.currentCell.editor = null;
                    this.dg.currentCell.cellEditorRef = null;
                }
            }
            this.unBindEditorInputEvent();
            this.cellEditorRef = null;
            this.formControl = null;
            this.editor = null;
            this.removeValidMessage();
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.rowData && !changes.rowData.isFirstChange()) {
            this.initCellEvent();
            this.setCellClsWithEditorType();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initCellEvent();
        this.setCellClsWithEditorType();
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    runZoneClick(e) {
        if (this['zoneClick']) {
            Object.assign(e, { rowData: this.rowData });
            this['zoneClick'].forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                n.target.style.pointerEvents = 'auto';
                if (n.callback) {
                    n.callback(e);
                }
                else if (n.handler) {
                    n.handler(e);
                }
            }));
            if (this.dg.isFF) {
                e.target['__zone_symbol__clickfalse'] = this['zoneClick'];
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    initCellEvent() {
        if (this.column && (this.column.editor || this.column.editorTemplate)) {
            if (!this.dg.clickToEdit) {
                this.celldblclick = this.render.listen(this.el.nativeElement, 'dblclick', (/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    this.onDblClickCell(e);
                }));
            }
            this.el.nativeElement.edit = (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.closeEditingCell().subscribe((/**
                 * @param {?} canEdit
                 * @return {?}
                 */
                (canEdit) => {
                    if (canEdit) {
                        this.onClickCell(e);
                        if (!this.dg.selectedRow || this.dg.selectedRow.id !== this.dr.rowId) {
                            this.dg.selectRow(this.dr.rowId, true, false);
                        }
                        this.runZoneClick(e);
                    }
                }));
            });
            this.el.nativeElement.editCell = (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.openCellEditor();
            });
        }
        else {
            this.clickTimer = 0;
        }
        /** @type {?} */
        const excludeTarget = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            return e.target.parentElement.nodeName !== 'GRID-BODY-CELL' &&
                e.target.nodeName !== 'INPUT' && e.target.nodeName !== 'TEXTAREA' &&
                !(e.target.className.indexOf('custom-control-label') > -1 &&
                    e.target.parentElement && e.target.parentElement.className.indexOf('custom-control') > -1) &&
                !e.target.closest('input-group') && !e.target.closest('farris-switch') &&
                !e.target.closest('farris-number-spinner') &&
                !e.target.closest('farris-datepicker') &&
                !e.target.closest('farris-time-picker') &&
                !e.target.closest('grid-editor-textarea') &&
                !e.target.closest('farris-checkboxgroup') &&
                !e.target.closest('grid-editor-checkbox') && !e.target.closest('farris-radiogroup') &&
                !e.target.closest('farris-organization-selector') && !e.target.closest('farris-personnel-selector');
        });
        if (this.column.proxyClick === undefined) {
            this.column.proxyClick = true;
        }
        if (this.column.template && this.column.proxyClick) {
            if (this['_tdmousedown_']) {
                this.el.nativeElement.removeEventListener('mousedown', this['_tdmousedown_'], true);
                this['_tdmousedown_'] = null;
            }
            this.el.nativeElement.addEventListener('mousedown', this['_tdmousedown_'] = (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (excludeTarget(e)) {
                    this['zoneClick'] = e.target['__zone_symbol__clickfalse'] || e.target['__zone_symbol__ANGULARclickFALSE'];
                    if (this['zoneClick'] && this['zoneClick'].length) {
                        if (!this.dg.isFF) {
                            e.target.style.pointerEvents = 'none';
                        }
                        else {
                            if (e.target['__zone_symbol__clickfalse']) {
                                delete (e.target['__zone_symbol__clickfalse']);
                            }
                            if (e.target['__zone_symbol__ANGULARclickFALSE']) {
                                delete (e.target['__zone_symbol__ANGULARclickFALSE']);
                            }
                        }
                        this['zoneClick'].forEach(((/**
                         * @param {?} proxyClick
                         * @return {?}
                         */
                        proxyClick => {
                            if (!proxyClick.target) {
                                proxyClick.target = e.target;
                            }
                        })));
                    }
                }
            }), true);
            /*
            this['_tdmousedown_'] = this.render.listen(this.el.nativeElement, 'mousedown', (e: any) => {
                if (excludeTarget(e)) {
                    this['zoneClick'] = e.target['__zone_symbol__clickfalse'] || e.target['__zone_symbol__ANGULARclickFALSE'];
                    if (this['zoneClick'] && this['zoneClick'].length) {
                        e.target.style.pointerEvents = 'none';
                        this['zoneClick'].forEach((proxyClick => {
                            if (!proxyClick.target) {
                                proxyClick.target = e.target;
                            }
                        }));
                    }
                }
            });
            */
        }
        this.el.nativeElement.gridCellData = { rowData: this.rowData, rowIndex: this.dr.rowIndex };
        this.el.nativeElement.closeEdit = (/**
         * @return {?}
         */
        () => this.closeEditingCell());
        this.el.nativeElement.selectCell = (/**
         * @param {?} e
         * @param {?} el
         * @return {?}
         */
        (e, el) => {
            if (this.dg.disableRow && this.dg.disableRow(this.rowData, this.dr.rowIndex)) {
                return;
            }
            /** @type {?} */
            const beforEventParam = {
                rowIndex: this.dr.rowIndex,
                rowData: this.rowData,
                gridInstance: this.dg
            };
            /** @type {?} */
            const runTemplateClickEvent = (/**
             * @return {?}
             */
            () => {
                if (!this.dg.currentCell) {
                    this.selectCell(this.column.field, el);
                    if (!this.dg.currentCell) {
                        this.dg.currentCell = { rowData: this.rowData };
                    }
                    else {
                        if (!this.dg.currentCell.rowData) {
                            this.dg.currentCell.rowData = this.rowData;
                        }
                    }
                }
                if (this['zoneClick']) {
                    this.runZoneClick(e);
                }
                this.dg.cellClick.emit({ column: this.column, rowData: this.rowData, gridInstance: this.dg, event: e });
            });
            /** @type {?} */
            const useNewSelectionMode = this.dg.sms.beforRowClick(Object.assign({}, beforEventParam, { e, id: this.dr.rowId, dr: this.dr, cellref: this }));
            if (useNewSelectionMode) {
                this.selectCell(this.column.field, el);
                if (!this.dg.currentCell) {
                    this.dg.currentCell = { rowData: this.rowData };
                }
                else {
                    if (!this.dg.currentCell.rowData) {
                        this.dg.currentCell.rowData = this.rowData;
                    }
                }
                this.dg.cellClick.emit({ column: this.column, rowData: this.rowData, gridInstance: this.dg, event: e });
                return;
            }
            if (this.dfs.isRowSelected(this.dr.rowId)) {
                if (!this.dg.keepSelect && !this.column.template) {
                    if (this.dg.currentCell && this.dg.currentCell.cellElement && this.dg.currentCell.cellElement.id === el.id) {
                        this.dg.cancelSelectCell();
                    }
                    this.dg.beforeUnselect(beforEventParam).pipe(takeUntil(this.destroy$)).subscribe((/**
                     * @param {?} canUnselect
                     * @return {?}
                     */
                    (canUnselect) => {
                        if (canUnselect) {
                            // this.dg.unSelect.emit(this.dg.selectedRow);
                            this.dfs.unSelectRow(this.dr.rowIndex, this.rowData, { instance: this.dg });
                            /** @type {?} */
                            const trCLS = this.el.nativeElement.className;
                            if (trCLS.indexOf('f-datagrid-row-selected') > -1) {
                                this.el.nativeElement.className = trCLS.replace('f-datagrid-row-selected', '');
                            }
                        }
                        this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
                        this.dg.dgs.setSelecedRow.emit();
                    }));
                }
                else {
                    this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
                    runTemplateClickEvent();
                }
            }
            else {
                /** @type {?} */
                let r$ = of(true);
                if (this.dg.beforeSelect) {
                    /** @type {?} */
                    const r = this.dg.beforeSelect({ rowIndex: this.dr.rowIndex, rowData: this.rowData, gridInstance: this.dg });
                    if (r && r.subscribe) {
                        r$ = r;
                    }
                }
                /** @type {?} */
                const zoneClick = this['zoneClick'];
                /** @type {?} */
                const _timer = zoneClick && zoneClick.length ? 100 : 0;
                r$.pipe(debounceTime(_timer)).subscribe((/**
                 * @param {?} t
                 * @return {?}
                 */
                (t) => {
                    if (t) {
                        this.selectCell(this.column.field, el);
                        this.dg.cellClick.emit({ column: this.column, rowData: this.rowData, gridInstance: this.dg, event: e });
                        if (_timer) {
                            this.runZoneClick(e);
                        }
                    }
                    this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
                    this.dg.dgs.setSelecedRow.emit();
                }));
            }
        });
        this.el.nativeElement.cancelSelected = (/**
         * @return {?}
         */
        () => {
            this.render.removeClass(this.el.nativeElement, CELL_SELECTED_CLS);
            this.render.removeClass(this.el.nativeElement, CELL_EDITING_CLS);
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        if (this.cellclick) {
            this.cellclick();
        }
        if (this.celldblclick) {
            this.celldblclick();
        }
        this.unBindEditorInputEvent();
        if (this.bindCellEventSubscription) {
            this.bindCellEventSubscription.unsubscribe();
            this.bindCellEventSubscription = null;
        }
        if (this.cellEditorCreatedSubscription) {
            this.cellEditorCreatedSubscription.unsubscribe();
            this.cellEditorCreatedSubscription = null;
        }
        if (this.cellEditorDestorySubscription) {
            this.cellEditorDestorySubscription.unsubscribe();
            this.cellEditorDestorySubscription = null;
        }
        this.editor = null;
        this.cellEditorRef = null;
        this.formControl = null;
        if (this.el) {
            this.el.nativeElement.cancelSelected = noop;
            this.el.nativeElement.selectCell = noop;
            this.el.nativeElement.closeEdit = noop;
            this.el.nativeElement.gridCellData = noop;
            this.el.nativeElement.edit = noop;
            this.el.nativeElement.selectCell = noop;
            if (this['_tdmousedown_']) {
                this.el.nativeElement.removeEventListener('mousedown', this['_tdmousedown_'], true);
                this['_tdmousedown_'] = null;
            }
            this.el = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    isDifferentCell() {
        if (!this.dg.currentCell) {
            return true;
        }
        else {
            if (!this.dg.selectedRow || this.dg.selectedRow.index !== this.dr.rowIndex) {
                return true;
            }
            else {
                if (this.dr.rowIndex !== this.dg.currentCell.rowIndex) {
                    return true;
                }
                else {
                    return this.dg.currentCell.field !== this.column.field;
                }
            }
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onClickCell(event) {
        // 关闭其他Grid 的编辑器
        document.body.click();
        this.dg.beforeClickCell.emit({ rowIndex: this.dr.rowIndex, rowData: this.rowData, column: this.column, gridInstance: this.dg });
        if (this.dr.disabled) {
            return;
        }
        if (this.dg.disabled) {
            return;
        }
        else {
            if (!this.dg.editable || this.isReadonly()) {
                if (this.dg.enableHighlightCell) {
                    event.stopPropagation();
                    this.dg.endEditing();
                    this.selectCell(this.column.field);
                }
                // 只读单元格，点击后须触发行点击事件 tfs 574551
                this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
                return;
            }
            else {
                if (this.dg.editMode === 'row') {
                    return;
                }
            }
        }
        if (this.dg.selectionMode === 'default' && event) {
            if (event.ctrlKey || event.shiftKey) {
                return;
            }
        }
        event.stopPropagation();
        if (event.target['nodeName'] === 'INPUT') {
            return;
        }
        // if (this.dg.clickToEdit && !this.dg.dblclickRow.observers.length) {
        //     this.dg.clickDelay = 0;
        // }
        this.render.addClass(this.dg.el.nativeElement, 'f-datagrid-unselect');
        if (!this.dg.isSingleClick && this.dg.editMode) {
            this.dg.isSingleClick = true;
            if (this.clickTimer) {
                clearTimeout(this.clickTimer);
            }
            this.clickTimer = setTimeout((/**
             * @return {?}
             */
            () => {
                if (this.dg.isSingleClick && this.dg.editable && this.dg.editMode === 'cell') {
                    this.dg.isSingleClick = false;
                    clearTimeout(this.clickTimer);
                    // if (!this.closeEditingCell()) {
                    //     return;
                    // }
                    this.closeEditingCell().pipe(takeUntil(this.destroy$)).subscribe((/**
                     * @param {?} f
                     * @return {?}
                     */
                    (f) => {
                        if (f) {
                            if (this.dg.clickToEdit) {
                                !this.dg.nowrap && this.dgb.updateRowHeight();
                                this.openCellEditor();
                            }
                            else {
                                this.selectCell(this.column.field);
                            }
                            this.render.removeClass(this.dg.el.nativeElement, 'f-datagrid-unselect');
                            event.preventDefault();
                        }
                    }));
                }
            }), this.dg.clickDelay);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onDblClickCell(event) {
        if (this.dg.disabled || this.isReadonly()) {
            return;
        }
        if (event.target['nodeName'] === 'INPUT' || event.target['nodeName'] === 'TEXTAREA') {
            return;
        }
        if (this.dg.editable && this.dg.editMode === 'cell') {
            if (this.clickTimer) {
                this.dg.isSingleClick = false;
                clearTimeout(this.clickTimer);
                this.clickTimer = null;
            }
            this.closeEditingCell().pipe(takeUntil(this.destroy$)).subscribe((/**
             * @param {?} f
             * @return {?}
             */
            f => {
                if (f) {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this.openCellEditor();
                    }));
                }
            }));
        }
    }
    /**
     * @param {?=} col
     * @return {?}
     */
    isReadonly(col = this.column) {
        if (this.dg.editable) {
            // 参与合并的单元格不允许编辑
            if (this.dg.mergeCell && this.dg.mergeFields.indexOf(col.field) > -1) {
                return true;
            }
            return this.getReadonlyValue(col);
        }
        else {
            return true;
        }
    }
    /**
     * @private
     * @param {?=} col
     * @return {?}
     */
    getReadonlyValue(col = this.column) {
        if (col.readonly !== undefined) {
            if (typeof col.readonly === 'boolean') {
                return col.readonly;
            }
            else if (typeof col.readonly === 'function') {
                return col.readonly(this.rowData);
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    openCellEditor() {
        // 当前行禁用，不允许编辑。
        if (this.dr.disabled) {
            return;
        }
        if ((!this.column.editor && !this.column.editorTemplate) || !this.dg.editable || this.isReadonly()) {
            if (this.dg.selectionMode === 'default' && this.dg.multiSelect) {
                this.dg.clearCheckeds();
            }
            this.selectCell(this.column.field);
            return;
        }
        /** @type {?} */
        const beforeEditEvent = this.dg.beforeEdit({ rowIndex: this.dr.rowIndex, rowData: this.rowData, column: this.column, gridInstance: this.dg });
        if (!beforeEditEvent || !beforeEditEvent.subscribe) {
            this.dg.writeConsole('please return an Observable Type.');
            return;
        }
        if (this.dg.currentCell) {
            if (!this.dg.currentCell.cellRef || this.dg.currentCell.cellRef.column.field !== this.column.field) {
                this.dg.currentCell.cellRef = this.dc;
            }
        }
        beforeEditEvent.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} flag
         * @return {?}
         */
        (flag) => {
            if (flag) {
                if (this.isDifferentCell()) {
                    if (this.dg.selectionMode === 'default' && this.dg.multiSelect) {
                        this.dg.clearCheckeds();
                    }
                    this.selectCell(this.column.field);
                }
                this.dfs.editCell();
            }
            else {
                this.selectCell(this.column.field);
                // tfs 574612
                this.dg.rowClick.emit({ data: this.rowData, grid: this.dg, dblclick: false });
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    emitBeginEdit() {
        /** @type {?} */
        const _cellEditorRef = this.cellEditorRef || this.dc.cellEditor;
        this.render.removeClass(this.dg.el.nativeElement, 'f-datagrid-unselect');
        if (this.dg.editMode === 'cell') {
            this.dg.selectedRow.editors = [this.editor];
            this.dg.currentCell.editor = this.editor;
            this.dg.currentCell.cellEditorRef = _cellEditorRef;
            this.bindEditorInputEvent();
            this.render.addClass(this.el.nativeElement, CELL_EDITING_CLS);
            // this.formControl.setValue(this.dc.value);
            this.dg.beginEdit.emit({ editor: _cellEditorRef, column: this.column, rowData: this.rowData, gridInstance: this.dg });
            if (this.column.editor.type === 'textarea' && this.column.editor.options && this.column.editor.options.editType === 'dialog') {
                this.editor.showDialog();
            }
        }
        if (this.dr && !this.dg.nowrap) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.dr.updateRowHeight();
            }));
        }
        if (this.editor) {
            this.validMessageEle = this.showValidMessage();
        }
    }
    /**
     * @return {?}
     */
    removeValidMessage() {
        // 移除验证信息
        if (this.validMessageEle) {
            this.validMessageEle.remove();
            this.validMessageEle = null;
            if (this.dg.formValidations) {
                delete this.dg.formValidations[this.column.field];
            }
        }
    }
    /**
     * @return {?}
     */
    showValidMessage() {
        if (this.dg.formValidations && this.dg.formValidations[this.column.field]) {
            const { isValid, message } = this.dg.formValidations[this.column.field];
            if (!isValid && message) {
                /** @type {?} */
                const tr = this.editor.el.nativeElement.closest('tr');
                /** @type {?} */
                const td = this.editor.el.nativeElement.closest('td');
                /** @type {?} */
                const parentContainver = this.editor.el.nativeElement.closest('.f-datagrid-table');
                /** @type {?} */
                const box = document.createElement('div');
                /** @type {?} */
                const msgWrap = document.createElement('span');
                box.appendChild(msgWrap);
                msgWrap.innerText = message;
                box.style.position = 'absolute';
                box.style.background = '#FDEFEF';
                box.style.color = '#F46160';
                /** @type {?} */
                let top = tr.offsetTop - 21;
                if (tr.getAttribute('index') == '0') {
                    top = tr.offsetHeight;
                }
                box.style.top = `${top}px`;
                box.style.left = `${td.offsetLeft + 5}px`;
                box.style.zIndex = '996';
                box.style.padding = '0.1875rem 0.5rem';
                box.style.fontSize = '.8125rem';
                box.style.lineHeight = '14px';
                // document.body.append(box);
                parentContainver.append(box);
                return box;
            }
            return null;
        }
    }
    /**
     * @return {?}
     */
    closeEditingCell() {
        if (!this.dg.isCellEditing()) {
            return of(true);
        }
        /** @type {?} */
        let currentCell = null;
        /** @type {?} */
        let editor = null;
        if (this.dg.currentCell) {
            currentCell = (/** @type {?} */ (this.dg.currentCell.cellRef));
            if (currentCell) {
                if (!currentCell.isEditing) {
                    return of(true);
                }
                if (currentCell.cellEditor && currentCell.cellEditor.componentRef && !currentCell.column.editorTemplate) {
                    editor = currentCell.cellEditor.componentRef.instance;
                    if (editor) {
                        // 执行blur 事件
                        if (editor.inputElement) {
                            /** @type {?} */
                            const domName = editor.inputElement.nodeName;
                            /** @type {?} */
                            const blurFn = editor.options && editor.options.onBlur;
                            if (blurFn) {
                                if ((domName === 'INPUT' || domName === 'TEXTAREA') && this.dg['focusElement'] === editor.inputElement) {
                                    blurFn({ editorRef: editor, rowData: currentCell.rowData });
                                }
                            }
                            if (editor.inputElement.blur) {
                                editor.inputElement.blur();
                            }
                            this.dg['focusElement'] = null;
                        }
                        if (editor.blur) {
                            editor.blur();
                        }
                        if (editor.pending) {
                            return of(false);
                        }
                        if (editor.formControl) {
                            if (editor.formControl.pending) {
                                return of(false);
                            }
                            if (editor.formControl && editor.formControl.invalid && !this.dg.endEditByInvalid) {
                                return of(false);
                            }
                        }
                        else {
                            return of(true);
                        }
                    }
                    else {
                        return of(true);
                    }
                }
            }
        }
        else {
            return of(true);
        }
        this.dg.isSingleClick = false;
        /** @type {?} */
        const _col_ = (editor || currentCell).column;
        /** @type {?} */
        const afterEditEvent = this.dg.afterEdit(currentCell.rowIndex, currentCell.rowData, _col_, editor);
        if (!afterEditEvent || !afterEditEvent.subscribe) {
            this.dg.writeConsole('please return an Observable Type.');
            return of(undefined);
        }
        // let cellEndEdit = of(undefined);
        /** @type {?} */
        let cellEndEdit = new Subject();
        afterEditEvent.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} flag
         * @return {?}
         */
        (flag) => {
            if (flag) {
                /** @type {?} */
                let val = currentCell.value === undefined ? '' : currentCell.value;
                if (currentCell && currentCell.formControl && currentCell.formControl.value !== undefined && val !== currentCell.formControl.value) {
                    val = currentCell.formControl.value;
                    currentCell.isEditing = false;
                    currentCell.updateValue(val);
                }
                this.dfs.endEditCell();
                this.dgs.onEndCellEdit(this.dfs.getCurrentCell());
                this.unBindEditorInputEvent();
                // 移除编辑样式
                this.render.removeClass(this.el.nativeElement, CELL_EDITING_CLS);
                if (this.dg.selectedRow) {
                    this.dg.selectedRow.editors = [];
                }
                // this.dg.selectedRow.data = this.rowData;
                // 更新行样式或者单元格样式
                /** @type {?} */
                const _rid = this.dfs.primaryId(currentCell.rowData);
                this.dfs.rowUpdate$.next({ index: currentCell.rowIndex, data: currentCell.rowData, cellRef: currentCell, keyID: _rid });
                if (this.dg.showFooter) {
                    // 更新footerData
                    this.dgs.refreshFooterData.emit();
                }
                // 刷新行数据
                // this.dr.refresh();
                if (this.dg.selectedRow && this.dg.selectedRow.dr) {
                    this.dg.selectedRow.dr.refresh();
                }
                if (this['ENDEDIT_TIMER']) {
                    clearTimeout(this['ENDEDIT_TIMER']);
                }
                const { rowIndex, rowData } = currentCell;
                this['ENDEDIT_TIMER'] = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.dg.endEdit.emit({ rowIndex, rowData, column: _col_, value: val });
                    // cellEndEdit = of(true);
                    cellEndEdit.next(true);
                }), 100);
            }
            else {
                if (currentCell && currentCell.cellEditor && currentCell.cellEditor.componentRef && currentCell.cellEditor.componentRef.instance) {
                    editor = currentCell.cellEditor.componentRef.instance;
                    editor.inputElement.focus();
                    // cellEndEdit = of(false);
                    cellEndEdit.next(false);
                }
                else {
                    // cellEndEdit = of(true);
                    cellEndEdit.next(true);
                }
            }
        }));
        return cellEndEdit.asObservable();
    }
    /**
     * @return {?}
     */
    cancelCellEditing() {
        if (this.dg.currentCell && this.dg.currentCell.isEditing && this.dg.selectedRow.index > -1) {
            // this.dfs.resetRow(this.dg.selectedRow.id);
            this.dc.rowData = this.dg.selectedRow.data;
            this.formControl.reset(Utils.getValue(this.column.field, this.dc.rowData));
            this.closeEditingCell();
        }
    }
    /**
     * @return {?}
     */
    bindEditorInputEvent() {
        /** @type {?} */
        const ceRef = this.cellEditorRef || this.dc.cellEditor;
        /** @type {?} */
        let input = null;
        if (ceRef) {
            input = ceRef.componentRef.instance.inputElement;
        }
        else {
            if (this.column.editorTemplate) {
                input = this.dc.el.nativeElement.querySelector('input,textarea');
            }
        }
        if (input) {
            input.focus();
            if (this.dg.selectOnEditing && this.column.editorTemplate) {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    if (input.select) {
                        input.select();
                    }
                }));
            }
            this.editorInputKeydownEvent = this.render.listen(input, 'keydown', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.onKeyDownForInput(e);
            }));
        }
    }
    /**
     * @return {?}
     */
    unBindEditorInputEvent() {
        if (this.editorInputKeydownEvent) {
            this.editorInputKeydownEvent();
            this.editorInputKeydownEvent = null;
        }
    }
    // private isLastCell() {
    //     let i = this.dg.flatColumns.length;
    //     while(i <= ) {
    //         if (this.dg.flatColumns[i])
    //     }
    // }
    /**
     * @return {?}
     */
    findLastEditCell() {
        /** @type {?} */
        let i = this.dg.colGroup.columns.length - 1;
        /** @type {?} */
        let _col = null;
        while (i >= 0) {
            /** @type {?} */
            const col = this.dg.colGroup.columns[i];
            if (col.editor || col.editorTemplate) {
                _col = col;
                break;
            }
            else {
                i--;
            }
        }
        return _col;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDownForInput(e) {
        /** @type {?} */
        const keyCode = e.keyCode;
        if (e.altKey || e.ctrlKey) {
            return;
        }
        if ((this.editor && this.editor.stopPropagation) || keyCode === 13 || this.column.editorTemplate) {
            e.stopPropagation();
        }
        switch (keyCode) {
            case 32: // SPACE
                if (this.column.editor.type === 'switch') {
                    e.preventDefault();
                    this.editor.instance.updateChecked(e, false);
                }
                break;
            case 13: // Enter
                this.closeEditingCell().pipe(takeUntil(this.destroy$)).pipe(debounceTime(100)).subscribe((/**
                 * @param {?} f
                 * @return {?}
                 */
                f => {
                    if (f) {
                        this.dg.dgContainer.nativeElement.focus();
                        /** @type {?} */
                        const lastEditCell = this.findLastEditCell();
                        /** @type {?} */
                        const enterParam = { gird: this.dg, cell: this.dg.currentCell, event: e, lastCell: lastEditCell.field === this.column.field };
                        if (this.column.onEnterHandler) {
                            this.column.onEnterHandler(enterParam);
                        }
                        else {
                            /** @type {?} */
                            const nextTd = this.dg.findNextCell(this.column.field, 'right');
                            if (this.dg.currentCell.lastRow && (!nextTd || lastEditCell.field === this.column.field)) {
                                this.dg.lastCellEnterHandler.emit(enterParam);
                            }
                        }
                    }
                }));
                break;
            case 27: // ESC
                this.cancelCellEditing();
                break;
            case 9: // Tab
                e.stopPropagation();
                this.dg.clickDelay = 0;
                if (e.shiftKey) {
                    this.closeEditingCell().pipe(takeUntil(this.destroy$)).subscribe((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => {
                        if (f) {
                            this.movePrevCellAndEdit();
                        }
                    }));
                }
                else {
                    this.closeEditingCell().pipe(takeUntil(this.destroy$)).subscribe((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => {
                        if (f) {
                            this.moveNextCellAndEdit(e);
                        }
                    }));
                    e.preventDefault();
                }
                break;
            case 40: // ↓
                /** 选中下一行，且当前列进入编辑态; 仅普通文本输入框支持 */
                if (this.column.editor.type === 'textbox') {
                    this.closeEditingCell().pipe(takeUntil(this.destroy$)).subscribe((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => {
                        if (f) {
                            this.selectNextRowAndEditCell(this.column.field, 'down');
                        }
                    }));
                    e.preventDefault();
                }
                break;
            case 38: // ↑
                /** 选中上一行，且当前列进入编辑态; 仅普通文本输入框支持 */
                if (this.column.editor.type === 'textbox') {
                    this.closeEditingCell().pipe(takeUntil(this.destroy$)).subscribe((/**
                     * @param {?} f
                     * @return {?}
                     */
                    f => {
                        if (f) {
                            this.selectNextRowAndEditCell(this.column.field, 'up');
                        }
                    }));
                    e.preventDefault();
                }
                break;
        }
    }
    /**
     * @private
     * @param {?} field
     * @param {?=} tdElement
     * @return {?}
     */
    selectCell(field, tdElement) {
        this.closeEditingCell().subscribe((/**
         * @param {?} t
         * @return {?}
         */
        t => {
            if (!t) {
                return;
            }
            tdElement = tdElement || this.el.nativeElement;
            this.clearCellSelectedClass();
            if (field && field !== this.dg.ControlPanelFeild && field.indexOf('farris-datagrid-column') === -1) {
                this.render.addClass(tdElement, CELL_SELECTED_CLS);
            }
            // this.dr.drHover.setRowHoverCls(false);
            this.dfs.setCurrentCell(this.dr, field, tdElement, this.dc);
            if (!this.dg.fast && this.column.fixed !== 'left' && this.column.fixed !== 'right') {
                this.moveScrollbar(tdElement);
            }
        }));
    }
    /**
     * @private
     * @param {?} td
     * @return {?}
     */
    moveScrollbar(td) {
        /** @type {?} */
        const tdPosLeft = td.offsetLeft + td.offsetWidth;
        /** @type {?} */
        const containerWidth = this.dg.width - this.dgb.columnsGroup.leftFixedWidth - this.dgb.columnsGroup.rightFixedWidth;
        /** @type {?} */
        const tdRect = td.getBoundingClientRect();
        /** @type {?} */
        const scrollContainer = this.dgb.ps.elementRef.nativeElement;
        /** @type {?} */
        const psContainer = scrollContainer.getBoundingClientRect();
        /** @type {?} */
        const scrollTop = scrollContainer.scrollTop;
        /** @type {?} */
        const scrollLeft = scrollContainer.scrollLeft;
        /** @type {?} */
        const scrollbarXLeft = this.dgb.ps.elementRef.nativeElement.scrollLeft;
        if (tdPosLeft > containerWidth) {
            /** @type {?} */
            const x = tdPosLeft - containerWidth + 2;
            // const x = tdPosLeft - this.dgb.ps.instance.scrollbarXWidth + 2;
            if (x > scrollbarXLeft) {
                this.dgb.ps.scrollToX(x);
            }
        }
        else {
            // if (tdRect.x < psContainer.x) {
            //     const x = scrollLeft - tdRect.x;
            //     this.dgb.ps.scrollToX(x);
            // }
            if (td.offsetLeft < scrollLeft) {
                this.dgb.ps.scrollToX(td.offsetLeft);
            }
        }
        /** @type {?} */
        const tdPosTop = tdRect.top - psContainer.top + tdRect.height;
        if (tdPosTop > psContainer.height) {
            /** @type {?} */
            const y = tdPosTop - psContainer.height;
            this.dgb.ps.scrollToY(scrollTop + y);
        }
        else {
            if (tdRect.y < psContainer.y) {
                this.dgb.ps.scrollToY(scrollTop - (psContainer.y - tdRect.y));
            }
        }
    }
    /**
     * @private
     * @param {?=} event
     * @return {?}
     */
    moveNextCellAndEdit(event) {
        // if (!this.closeEditingCell()) {
        //     return;
        // }
        // const fieldIndex = this.dfs.getColumnIndex(this.column.field);
        /** @type {?} */
        const fieldIndex = this.dg.colGroup.columns.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => (n.id && n.id === this.column.id) || n.field === this.column.field));
        if (fieldIndex + 1 < this.dgb.columnsGroup.columns.length) {
            /** @type {?} */
            const nextColumn = this.dgb.columnsGroup.columns[fieldIndex + 1];
            /** @type {?} */
            const nextTd = this.dg.findNextTd(nextColumn);
            if (nextTd && (!nextColumn.fixed || nextColumn.fixed === 'center')) {
                this.moveScrollbar(nextTd);
            }
            // const nextTd = this.dg.currentCell.cellElement.nextElementSibling;
            if (nextColumn && ((!nextColumn.editor && !nextColumn.editorTemplate) || this.isReadonly(nextColumn))) {
                if (nextTd) {
                    nextTd.selectCell(event, nextTd);
                }
                return;
            }
            if (nextTd) {
                nextTd.focus();
                if (nextColumn.editor || nextColumn.editorTemplate) {
                    nextTd.editCell();
                    this.dgs.onCellEdit(nextTd);
                }
            }
        }
        else {
            // next row's first cell to editing
            /** @type {?} */
            const nextTr = this.dg.currentCell.cellElement.parentElement.nextElementSibling;
            if (nextTr && nextTr.tagName === 'TR') {
                // nextTr.children.find(td => td.editCell).editCell();
                /** @type {?} */
                let firstEditor = false;
                /** @type {?} */
                let i = 0;
                while (!firstEditor) {
                    firstEditor = !!nextTr.children[i].editCell;
                    if (!firstEditor) {
                        i++;
                    }
                }
                if (this.dg.selectionMode === 'default') {
                    this.dg.clearCheckeds();
                }
                nextTr.children[i].editCell();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    movePrevCellAndEdit() {
        // if (!this.closeEditingCell()) {
        //     return;
        // }
        /** @type {?} */
        const fieldIndex = this.dfs.getColumnIndex(this.column.field);
        if (fieldIndex - 1 >= 0) {
            /** @type {?} */
            const nextColumn = this.dgb.columnsGroup.normalColumns[fieldIndex - 1];
            if (nextColumn && this.isReadonly(nextColumn)) {
                return;
            }
            /** @type {?} */
            const nextTd = this.dg.currentCell.cellElement.previousElementSibling;
            if (nextTd) {
                // this.selectCell(nextColumn.field, nextTd);
                nextTd.focus();
                if (nextColumn.editor) {
                    // this.dfs.editCell();
                    nextTd.click();
                    this.dgs.onCellEdit(nextTd);
                }
            }
        }
    }
    /**
     * @private
     * @param {?} cellFieldName
     * @param {?} dir
     * @return {?}
     */
    selectNextRowAndEditCell(cellFieldName, dir) {
        if (!this.dg.currentCell) {
            this.dg.writeConsole('当前选中单元格为空');
            return;
        }
        /** @type {?} */
        const p = dir === 'down' ? 'nextElementSibling' : 'previousElementSibling';
        /** @type {?} */
        const nextTr = this.dg.currentCell.cellElement.parentElement[p];
        if (nextTr && nextTr.tagName === 'TR') {
            /** @type {?} */
            const td = Array.from(nextTr.children).find((/**
             * @param {?} td
             * @return {?}
             */
            (td) => td.getAttribute('field') == cellFieldName));
            if (td && td.editCell) {
                if (this.dg.selectionMode === 'default') {
                    this.dg.clearCheckeds();
                }
                td.editCell();
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    clearCellSelectedClass() {
        this.dg.removeCellSelectedCls();
    }
    /**
     * @private
     * @return {?}
     */
    setCellClsWithEditorType() {
        // 设置当前选中单元格样式
        if (this.dg.currentCell && this.dg.enableHighlightCell) {
            if (this.dg.currentCell.field === this.column.field && this.dg.currentCell.rowId === this.rowData[this.dg.idField] && !this.dc.isEditing) {
                this.clearCellSelectedClass();
                this.render.addClass(this.el.nativeElement, CELL_SELECTED_CLS);
            }
        }
        if (!this.dg.enableEditCellStyle) {
            return;
        }
        /** @type {?} */
        const td = this.el.nativeElement;
        this.cleanOtherEditorIcon(td);
        // 当前行禁用，不允许编辑。
        if (this.dr.disabled) {
            return;
        }
        if (!this.column.editor) {
            return;
        }
        if (this.isReadonly()) {
            return;
        }
        /** @type {?} */
        const editorType = this.column.editor.type;
        /** @type {?} */
        const cls = this.column.align === 'right' ? 'allow-edit-cell-left' : 'allow-edit-cell';
        this.render.addClass(td, cls);
        this.render.addClass(td, ALLOW_EDIT_CELL_HIGHLIGHT_CLS[editorType]);
    }
    /**
     * @private
     * @param {?} td
     * @return {?}
     */
    cleanOtherEditorIcon(td) {
        /** @type {?} */
        const values = Object.values(ALLOW_EDIT_CELL_HIGHLIGHT_CLS);
        values.forEach((/**
         * @param {?} v
         * @return {?}
         */
        v => {
            if (td.className.indexOf(v) > -1) {
                td.className = td.className.replace('allow-edit-cell-left', '').replace('allow-edit-cell', '');
                td.className = td.className.replace(v, '');
            }
        }));
    }
}
DatagridCellEditableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cell-editable]',
                exportAs: 'cellEditable'
            },] }
];
/** @nocollapse */
DatagridCellEditableDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: Renderer2 },
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] },
    { type: NgZone }
];
DatagridCellEditableDirective.propDecorators = {
    rowData: [{ type: Input, args: ['cell-editable',] }],
    column: [{ type: Input }],
    dc: [{ type: ContentChild, args: [DatagridCellComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridRowsComponent {
    /**
     * @param {?} cd
     * @param {?} dg
     * @param {?} dgb
     * @param {?} el
     * @param {?} injector
     * @param {?} ngZone
     */
    constructor(cd, dg, dgb, el, injector, ngZone) {
        this.cd = cd;
        this.dg = dg;
        this.dgb = dgb;
        this.el = el;
        this.injector = injector;
        this.ngZone = ngZone;
        /**
         * 是否为右侧固定列。默认为 false
         */
        this.fixedRight = false;
        /**
         * 是否有左侧固定列
         */
        this.hasFixedColumns = false;
        this.isGroupRow = IS_GROUP_ROW_FIELD;
        /**
         * 分组行父ID字段
         */
        this.groupRow = GROUP_ROW_FIELD;
        this.isGroupFooter = IS_GROUP_FOOTER_ROW_FIELD;
        this.visible = GROUP_VISIBLE_FIELD;
        this.groupLevelField = GROUP_LEVEL_FIELD;
        this.filterConditions = '';
        this.checkedRows = [];
        this.ro = null;
        this.subscriptions = [];
        this.destroy$ = new Subject();
    }
    /**
     * @return {?}
     */
    get groupSummaryDataInGroupRow() {
        return this.dg.groupSummaryPosition === 'inGroupRow';
    }
    /**
     * @private
     * @return {?}
     */
    listenEvent() {
        /** @type {?} */
        const _s3 = this.dg.dgs.setSelecedRow.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            this.detectChanges();
        }));
        this.subscriptions.push(_s3);
        /** @type {?} */
        const _s4 = this.dg.dfs.rowAppend$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.detectChanges();
        }));
        this.subscriptions.push(_s4);
        /** @type {?} */
        const _s5 = this.dg.dfs.rowUpdate$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            if (row) {
                if (this.dg.groupRows && this.dg.groupFooter && this.dg.groupField) {
                    /** @type {?} */
                    let groupRowId = row.data[this.groupRow];
                    if (groupRowId === undefined) {
                        /** @type {?} */
                        const _row = this.dg.getRows().find((/**
                         * @param {?} n
                         * @return {?}
                         */
                        n => n.id === this.dg.dfs.primaryId(row.data)));
                        if (_row) {
                            groupRowId = this.dg.commonUtils.getValue(this.groupRow, _row);
                        }
                    }
                    if (groupRowId !== '' && groupRowId !== null) {
                        this.dg.dfs.updateGroupFooter(groupRowId);
                    }
                    else {
                        this.dg.writeConsole('未获取到groupRowId。', 'error');
                    }
                }
            }
        }));
        this.subscriptions.push(_s5);
        this.scrollToCurrentRowSubscription = this.dg.dgs.scrollToCurrentRow.pipe(delay(50)).subscribe((/**
         * @return {?}
         */
        () => {
            this.scrollToFirstSelectedRow();
            /** @type {?} */
            const scrollInfo = this.dg.dfs.getState().scrollInfo;
            this.dg.scrollInstance.scrollToLeft();
            if (this.dg.enableFilterRow && scrollInfo && scrollInfo.x) {
                this.dg.dgs.closeFilterPanel.emit();
            }
        }));
        this.dg.dfs.checkRow$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.checkedRows = this.dg.dfs.getCheckeds();
            this.detectChanges();
        }));
        this.dg.dfs.clearCheckeds$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.checkedRows = this.dg.dfs.getCheckeds();
            this.detectChanges();
        }));
        this.dg.dgs.toggleGroupRow$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ({ expand, groupRowIndex }) => {
            this._toggleGroupRow(groupRowIndex, expand);
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (this.dgb.ps) {
                    this.dgb.ps.update();
                }
            }), 10);
        }));
        this.dg.dgs.toggleAllGroupRows$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} __0
         * @return {?}
         */
        ({ expand }) => {
            this.toggleAllGroupRows(expand);
            // setTimeout(() => {
            //     this.dg.scrollToTop();
            // });
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (this.dgb.ps) {
                    this.dgb.ps.update();
                }
            }), 10);
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.listenEvent();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unSubscriptions();
    }
    /**
     * @private
     * @param {?} groupRowIndex
     * @param {?=} expand
     * @return {?}
     */
    _toggleGroupRow(groupRowIndex, expand = true) {
        if (groupRowIndex > -1) {
            /** @type {?} */
            const allRows = this.dg.getRows();
            /** @type {?} */
            const groupRows = allRows.filter((/**
             * @param {?} n
             * @return {?}
             */
            n => n[IS_GROUP_ROW_FIELD]));
            /** @type {?} */
            let gr = groupRows[groupRowIndex];
            if (!gr) {
                gr = allRows[groupRowIndex];
            }
            if (gr) {
                this.toggleGroupRow(gr, groupRowIndex, expand);
            }
        }
    }
    /**
     * @private
     * @param {?=} expand
     * @return {?}
     */
    toggleAllGroupRows(expand = true) {
        /** @type {?} */
        const groupRows = this.data.filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n[IS_GROUP_ROW_FIELD]));
        groupRows.forEach((/**
         * @param {?} gr
         * @return {?}
         */
        gr => {
            gr.expanded = expand;
            this.dg.dfs.setGroupRowsVisible(gr, expand, false);
        }));
        this.cd.detectChanges();
        if (expand) {
            this.dg.dfs.expandGroupRow.emit();
        }
        else {
            this.dg.dfs.collapseGroupRow.emit();
        }
    }
    /**
     * @private
     * @return {?}
     */
    unSubscriptions() {
        this.destroy$.next();
        this.destroy$.complete();
        if (this.scrollToCurrentRowSubscription) {
            this.scrollToCurrentRowSubscription.unsubscribe();
            this.scrollToCurrentRowSubscription = null;
        }
        if (this.subscriptions && this.subscriptions.length) {
            this.subscriptions.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => n.unsubscribe));
            this.subscriptions = [];
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (!this.dg.nowrap) {
                    // this.dgb.updateRowHeight();
                    this.dg.calculateGridSize();
                }
            }), 100);
        }));
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getGroupColumn(field) {
        return this.dg.flatColumns.find((/**
         * @param {?} col
         * @return {?}
         */
        col => col.field === field));
    }
    /**
     * @private
     * @return {?}
     */
    detectChanges() {
        if (!this.cd['destroyed']) {
            this.cd.detectChanges();
        }
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByField(index, item) {
        return item.field;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    isElementInViewport(el) {
        /** @type {?} */
        const container = this.dgb.ps.instance.element.getBoundingClientRect();
        /** @type {?} */
        const box = el.getBoundingClientRect();
        /** @type {?} */
        const top = (box.top <= container.height + container.top);
        /** @type {?} */
        const bottom = (box.bottom <= (container.bottom));
        return (top && bottom);
    }
    /**
     * @private
     * @param {?} tr
     * @param {?} rowIndex
     * @return {?}
     */
    _elementIntoView(tr, rowIndex) {
        if (tr) {
            if (tr.scrollIntoViewIfNeeded) {
                tr.scrollIntoViewIfNeeded(false);
            }
            else {
                tr.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
        }
        else {
            /** @type {?} */
            const currentTrTop = rowIndex * this.dg.rowHeight;
            if (currentTrTop) {
                this.dg.scrollInstance.scrollToY(currentTrTop);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    scrollToFirstSelectedRow() {
        if (this.dg.selectedRow) {
            /** @type {?} */
            const rowIndex = this.dg.selectedRow.index;
            /** @type {?} */
            const rowId = TR_ID_PREFIX + this.dg.selectedRow.id;
            // const tr: any = document.querySelector(rowId);
            /** @type {?} */
            const tr = Utils.getTrDomById(rowId, document);
            if (rowIndex === 0) {
                if (this.dgb.ps && this.dgb.ps.instance) {
                    if (this.dgb.ps.instance.element.scrollTop === 0) {
                        return;
                    }
                    else {
                        this.dg.scrollInstance.scrollToY(0);
                        return;
                    }
                }
            }
            const { top, bottom } = this.dgb.getVisibleRange();
            if (rowIndex === top || rowIndex === bottom) {
                this._elementIntoView(tr, rowIndex);
                return;
            }
            else {
                if (rowIndex > top && rowIndex < bottom && tr && this.isElementInViewport(tr)) {
                    return;
                }
            }
            this._elementIntoView(tr, rowIndex);
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @param {?} open
     * @param {?=} $event
     * @return {?}
     */
    toggleGroupRow(row, index, open, $event) {
        if ($event) {
            $event.stopPropagation();
        }
        row.expanded = open;
        this.dg.dfs.setGroupRowsVisible(row, open);
    }
    /**
     * @private
     * @param {?} field
     * @param {?} rowIndex
     * @return {?}
     */
    mergeInfo(field, rowIndex) {
        return this.dg.dgs.getMergeInfo(rowIndex, field, this.dg.mergeCellInfo);
    }
    /**
     * @param {?} col
     * @param {?} rowIndex
     * @return {?}
     */
    showCell(col, rowIndex) {
        /** @type {?} */
        const mergeInfo = this.mergeInfo(col.field, rowIndex);
        /** @type {?} */
        let show = true;
        if (mergeInfo) {
            show = mergeInfo.show;
        }
        return show;
    }
    /**
     * @param {?} col
     * @param {?} rowIndex
     * @return {?}
     */
    getRowSpan(col, rowIndex) {
        /** @type {?} */
        const mergeInfo = this.mergeInfo(col.field, rowIndex);
        if (!mergeInfo) {
            return 1;
        }
        if (this.showCell(col, rowIndex)) {
            col.readonly = true;
            return mergeInfo.rowspan;
        }
        else {
            return 1;
        }
    }
    /**
     * @param {?} groupId
     * @return {?}
     */
    getGroupSummaryData(groupId) {
        /** @type {?} */
        const _data = this.dg.getRows();
        if (_data && _data.length) {
            /** @type {?} */
            const row = this.dg.getRows().find((/**
             * @param {?} n
             * @return {?}
             */
            n => n['__group_parent_id__'] === groupId && n['__group_footer__']));
            if (row) {
                return row.data;
            }
        }
        return null;
    }
}
DatagridRowsComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-rows',
                template: "<!--\r\n * @Author: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @Date: 2019-08-06 07:43:07\r\n * @LastEditors: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @LastEditTime: 2019-11-19 20:34:12\r\n * @QQ: 1055818239\r\n * @Version: v0.0.1\r\n -->\r\n<!-- [class.f-datagrid-row-hover]=\"dg.rowHover && dgb.hoverRowIndex === hoverRow.rowIndex\" \r\n        [class.f-datagrid-row-odd]=\"odd && dg.striped\"\r\n        [class.f-datagrid-row-even]=\"!odd && dg.striped\"\r\n-->\r\n\r\n<ng-template #grouprowControl let-ctx>\r\n    <div class=\"d-flex flex-row\" style=\"align-items: center; white-space: nowrap;\">\r\n        <span class=\"f-icon f-datagrid-group-expanded ml-1 mr-1\" *ngIf=\"!ctx.row.expanded\" (click)=\"toggleGroupRow(ctx.row, ctx.index, true, $event)\"></span>\r\n        <span class=\"f-icon f-datagrid-group-collapsed ml-1 mr-1\" *ngIf=\"ctx.row.expanded\" (click)=\"toggleGroupRow(ctx.row, ctx.index, false, $event)\"></span>\r\n        <span class=\"f-utils-fill group-row-text\" *ngIf=\"dg.groupFormatter\" [innerHTML]=\"ctx.row | formatGroupRow: '': dg.groupFormatter| safe: 'html' \"></span>\r\n        <span class=\"f-utils-fill group-row-text\" *ngIf=\"!dg.groupFormatter\"> {{ ctx.row | formatGroupRow: getGroupColumn(ctx.row.field)  }} </span>\r\n    </div>\r\n</ng-template>\r\n\r\n<table #tableEl style=\"border:0; width: 100%\" class=\"f-datagrid-rows\" cellpadding=0 cellspacing=\"0\" row-hover row-dblclick\r\n[ngStyle]=\"fixedRight && width ? { width: width +'px' }: {}\">\r\n    <colgroup>\r\n        <col width=\"36px\" *ngIf=\"dg.showCheckbox && dg.fast\">\r\n        <col [width]=\"dg?.lineNumberWidth + 'px'\" *ngIf=\"dg.showLineNumber && dg.fast\">\r\n        <col *ngFor=\"let col of columns\" [width]=\"col.width + 'px'\" />\r\n    </colgroup>\r\n\r\n    <tbody *ngIf=\"dg.groupRows && dg.groupField\" id=\"{{'row-group-tbody_'+ dg.id}}\" >\r\n        <ng-container *ngFor=\"let row of data; trackBy: dg.trackByRows; let i = index\">\r\n            <tr *ngIf=\"row[isGroupRow]\" class=\"f-datagrid-body-row f-datagrid-group-row\" [style.display]=\"row[visible] ? '': 'none'\" [group-row]=\"row\" [attr.group-index]=\"i\" [attr.expand]=\"row.expanded || true\" [attr.id]=\"row | rowDataId: false:false: true\">\r\n                <td *ngIf=\"dg.showCheckbox && dg.fast\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center; left: 0\"\r\n                    [class.f-datagrid-fast__fixed-left]=\"dg.fast\" [class.l-shadow-col]=\"dg.fast && !dg.showLineNumber && !hasFixedColumns\">\r\n                    <div class=\"f-datagrid-cell-content checkbox-column\" style=\"text-overflow: unset;\">\r\n                        <datagrid-checkbox [disabled]=\"row | disableRow: dgb.startRowIndex + i: dg.disableRow\" [rowData]=\"row\"\r\n                            [rowIndex]=\"dgb.startRowIndex + i\" [checked]=\"row | rowIsChecked: checkedRows\"></datagrid-checkbox>\r\n                    </div>\r\n                </td>\r\n        \r\n                <td *ngIf=\"dg.showLineNumber && dg.fast\" [style.width.px]=\"dg.lineNumberWidth\"  class=\"f-datagrid-cell f-datagrid-cell-rownumber\"\r\n                    [class.f-datagrid-fast__fixed-left]=\"dg.fast\"  [style.left.px]=\"dg.showCheckbox ? 36: 0\" [class.l-shadow-col]=\"dg.fast && !hasFixedColumns\">\r\n                    <div class=\"f-datagrid-cell-content\">\r\n                        {{ dg.pageSize * (dg.pageIndex-1) + dgb.startRowIndex + i + 1 }}\r\n                    </div>\r\n                </td>\r\n\r\n\r\n                <td *ngIf=\"!fixedRight && !groupSummaryDataInGroupRow && !hasFixedColumns\" class=\"f-datagrid-cell f-dg-groupcell\" [attr.colspan]=\"hasFixedColumns? columns.length: row['colspan']\" [style.paddingLeft.px]=\"row[groupLevelField] * 15\">\r\n                    <ng-container [ngTemplateOutlet]=\"grouprowControl\" [ngTemplateOutletContext]=\"{$implicit: { row: row, index: i }}\"></ng-container>\r\n                </td>\r\n                \r\n                <td *ngIf=\"!fixedRight && !groupSummaryDataInGroupRow && hasFixedColumns\" class=\"f-datagrid-cell f-dg-groupcell\" [attr.colspan]=\"hasFixedColumns? columns.length: row['colspan']\" [style.paddingLeft.px]=\"row[groupLevelField] * 15\">\r\n                </td>\r\n\r\n                <ng-container *ngIf=\"groupSummaryDataInGroupRow && !fixedRight\">\r\n\r\n                    <ng-container *ngFor=\"let col of columns; trackBy: trackByField; let ci = index;\">\r\n                        <td *ngIf=\"!fixedRight && ci === 0 && !hasFixedColumns\" class=\"f-datagrid-cell\" [style.paddingLeft.px]=\"row[groupLevelField] * 15\" [attr.colspan]=\"dg.groupCellColSpan\">\r\n                            <ng-container [ngTemplateOutlet]=\"grouprowControl\" [ngTemplateOutletContext]=\"{$implicit: { row: row, index: i }}\"></ng-container>\r\n                        </td>\r\n                             \r\n                        <td class=\"f-datagrid-cell\"  \r\n                            *ngIf=\"!hasFixedColumns ?ci > 0 && ci >= dg.groupCellColSpan: true\"\r\n                            [attr.field]=\"col.field\" \r\n                            [attr.align]=\" col.groupFooter?.align || col.align\">\r\n                            <div class=\"f-datagrid-cell-content\" [innerHTML]=\"col | formatCellData: getGroupSummaryData(row.id) : true: false | safe: 'html'\"></div>\r\n                        </td>\r\n                    </ng-container>\r\n                </ng-container>\r\n\r\n                <td *ngIf=\"fixedRight\" class=\"f-datagrid-cell\" [attr.colspan]=\"columns.length\"></td>\r\n            </tr>\r\n\r\n            <ng-container *ngIf=\"!row[isGroupRow]\">\r\n                <ng-container *ngIf=\"!row[isGroupFooter]\">\r\n                    <tr class=\"f-datagrid-body-row\"\r\n                        [attr.id]=\"row | rowDataId:fixedRight\"\r\n                        [attr.index]=\"startRowIndex + i\"\r\n                        [grid-row]=\"row\"\r\n                        [editable]=\"dg.editable\"\r\n                        [rowIndex]=\"startRowIndex + i\" #dr=\"gridRow\"\r\n                        [formGroup]=\"dr.form\"\r\n                        [class.f-datagrid-row-selected]=\"row | rowIsSelected\"\r\n                        [style.display]=\"row[visible] ? '': 'none'\"\r\n                        [class.f-datagrid-disable-row]=\"dr.disabled\">\r\n\r\n                        <td *ngIf=\"dg.showCheckbox && dg.fast\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center; left: 0\"\r\n                        [class.f-datagrid-fast__fixed-left]=\"dg.fast\" [class.l-shadow-col]=\"dg.fast && !dg.showLineNumber && !hasFixedColumns\">\r\n                            <div class=\"f-datagrid-cell-content checkbox-column\" style=\"text-overflow: unset;\">\r\n                            <datagrid-checkbox [disabled]=\"row | disableRow: dgb.startRowIndex + i: dg.disableRow\" [rowData]=\"row\"\r\n                                [rowIndex]=\"dgb.startRowIndex + i\" [checked]=\"row | rowIsChecked: checkedRows\"></datagrid-checkbox>\r\n                            </div>\r\n                        </td>\r\n            \r\n                        <td *ngIf=\"dg.showLineNumber && dg.fast\" [style.width.px]=\"dg.lineNumberWidth\"  class=\"f-datagrid-cell f-datagrid-cell-rownumber\"\r\n                        [class.f-datagrid-fast__fixed-left]=\"dg.fast\"  [style.left.px]=\"dg.showCheckbox ? 36: 0\" [class.l-shadow-col]=\"dg.fast && !hasFixedColumns\">\r\n                            <div class=\"f-datagrid-cell-content\">\r\n                                {{ dg.pageSize * (dg.pageIndex-1) + dgb.startRowIndex + i + 1 }}\r\n                            </div>\r\n                        </td>\r\n\r\n\r\n                        <td class=\"f-datagrid-cell\"\r\n                            [cell-editable]=\"row\"\r\n                            [column]=\"col\"\r\n                            [attr.field]=\"col.field\" #cell\r\n                            [style.paddingLeft.px]=\"(ci === 0 && !fixedRight && !hasFixedColumns) ? row[groupLevelField] * 10 + 25 : 0\"\r\n                            [attr.align]=\"col.align\"\r\n                            [class.f-datagrid-fast__fixed-left]=\"dg.fast && col.fixed && col.fixed === 'left'\"\r\n                            [class.f-datagrid-fast__fixed-right]=\"dg.fast && col.fixed && col.fixed === 'right'\"\r\n                            [class.r-shadow-col]=\"col.rightShadowCol\"\r\n                            [class.l-shadow-col]=\"col.leftShadowCol\"\r\n                            *ngFor=\"let col of columns; trackBy: trackByField; let ci = index;\">\r\n                            <grid-body-cell\r\n                                [width]=\"col.width\"\r\n                                [height]=\"dg.rowHeight\"\r\n                                [column]=\"col\"\r\n                                [rowData]=\"row\"\r\n                                [rowIndex]=\"startRowIndex + i\">\r\n                            </grid-body-cell>\r\n                        </td>\r\n                    </tr>\r\n                </ng-container>\r\n\r\n                <ng-container *ngIf=\"row[isGroupFooter] && !groupSummaryDataInGroupRow\">\r\n                    <tr class=\"f-datagrid-body-row f-datagrid-group-footer\" \r\n                        *ngIf=\"!row[isGroupRow]\"\r\n                        [attr.index]=\"startRowIndex + i\"\r\n                        [group-footer-row-styler]=\"row\"\r\n                        [style.display]=\"row[visible] ? '': 'none'\">\r\n                        <td class=\"f-datagrid-cell\"\r\n                            [attr.field]=\"col.field\" \r\n                            [attr.colspan]=\"col.groupFooter?.colspan || 1\"\r\n                            [attr.align]=\" col.groupFooter?.align || col.align\"\r\n                            [style.display]=\"col.groupFooter?.visible === false ? 'none': ''\"\r\n                            [style.paddingLeft.px]=\"(ci === 0 && !fixedRight && !hasFixedColumns)? row[groupLevelField] * 10 + 25 : 0\"\r\n                            footer-cell-styler [column]=\"col\" [rowData]=\"row\" [isGroupFooter]=\"true\"\r\n                            *ngFor=\"let col of columns; trackBy: trackByField; let ci = index;\">\r\n                            <div class=\"f-datagrid-cell-content\" [innerHTML]=\"col | formatCellData: row.data : true: false | safe: 'html'\"></div>\r\n                        </td>\r\n                    </tr>\r\n                </ng-container>\r\n\r\n            </ng-container>\r\n        </ng-container>\r\n\r\n    </tbody>\r\n    <tbody *ngIf=\"!dg.groupRows || !dg.groupField\" id=\"{{ (fixedRight? 'right-tbody_' : 'normal-rows-tbody_')+ dg.id}}\">\r\n\r\n        <ng-container *ngIf=\"!dg.mergeCell\">\r\n            <tr class=\"f-datagrid-body-row\"\r\n                [attr.id]=\"row | rowDataId: fixedRight\"\r\n                [attr.index]=\"startRowIndex + i\"\r\n                [grid-row]=\"row\"\r\n                [editable]=\"dg.editable\"\r\n                [rowIndex]=\"startRowIndex + i\" #dr=\"gridRow\"\r\n                [formGroup]=\"dr.form\"\r\n                #tr\r\n                [class.f-datagrid-row-selected]=\"row | rowIsSelected\"\r\n                [class.f-datagrid-disable-row]=\"dr.disabled\"\r\n                *ngFor=\"let row of data; trackBy: dg.trackByRows; let i = index\"\r\n                >\r\n\r\n                    <td *ngIf=\"dg.showCheckbox && dg.fast\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center; left: 0\"\r\n                    [class.f-datagrid-fast__fixed-left]=\"dg.fast\" [class.l-shadow-col]=\"dg.fast && !dg.showLineNumber && !hasFixedColumns\">\r\n                        <div class=\"f-datagrid-cell-content checkbox-column\" style=\"text-overflow: unset;\">\r\n                        <datagrid-checkbox [disabled]=\"row | disableRow: dgb.startRowIndex + i: dg.disableRow\" [rowData]=\"row\"\r\n                            [rowIndex]=\"dgb.startRowIndex + i\" [checked]=\"row | rowIsChecked: checkedRows\"></datagrid-checkbox>\r\n                        </div>\r\n                    </td>\r\n        \r\n                    <td *ngIf=\"dg.showLineNumber && dg.fast\" [style.width.px]=\"dg.lineNumberWidth\"  class=\"f-datagrid-cell f-datagrid-cell-rownumber\"\r\n                    [class.f-datagrid-fast__fixed-left]=\"dg.fast\"  [style.left.px]=\"dg.showCheckbox ? 36: 0\" [class.l-shadow-col]=\"dg.fast && !hasFixedColumns\">\r\n                        <div class=\"f-datagrid-cell-content\">\r\n                            {{ dg.pageSize * (dg.pageIndex-1) + dgb.startRowIndex + i + 1 }}\r\n                        </div>\r\n                    </td>\r\n\r\n                    <td class=\"f-datagrid-cell\"\r\n                        [attr.field]=\"col.field\" \r\n                        [attr.align]=\"col.align\"\r\n                        [style.vertical-align]=\"col.valign\"\r\n                        [cell-editable]=\"row\"\r\n                        [column]=\"col\"  #editorcell=\"cellEditable\"\r\n                        [class.cell-readonly]=\"col | cellReadonly: row: dg\"\r\n                        [style.display]=\"dg.columnIsVisible(col) ? '': 'none'\"\r\n                        [class.f-datagrid-fast__fixed-left]=\"dg.fast && col.fixed && col.fixed === 'left'\"\r\n                        [class.f-datagrid-fast__fixed-right]=\"dg.fast && col.fixed && col.fixed === 'right'\"\r\n                        [class.r-shadow-col]=\"col.rightShadowCol\"\r\n                        [class.l-shadow-col]=\"col.leftShadowCol\"\r\n                        *ngFor=\"let col of columns;trackBy: dg.trackByRows; index as ci; last as islast;\">\r\n                        <grid-body-cell\r\n                            [width]=\"col.width\"\r\n                            [height]=\"dg.rowHeight\"\r\n                            [lastColumn]=\"islast\"\r\n                            [column]=\"col\"\r\n                            [rowData]=\"row\"\r\n                            [rowIndex]=\"startRowIndex + i\">\r\n                        </grid-body-cell>\r\n                    </td>\r\n                </tr>\r\n            </ng-container>\r\n            <ng-container *ngIf=\"dg.mergeCell\">\r\n                <tr class=\"f-datagrid-body-row\"\r\n                    [attr.id]=\"row | rowDataId: fixedRight \"\r\n                    [attr.index]=\"startRowIndex + i\"\r\n                    [grid-row]=\"row\"\r\n                    [editable]=\"dg.editable\"\r\n                    [rowIndex]=\"startRowIndex + i\"\r\n                    #dr=\"gridRow\" [formGroup]=\"dr.form\"\r\n                    [class.f-datagrid-row-selected]=\"row | rowIsSelected\"\r\n                    [class.f-datagrid-disable-row]=\"dr.disabled\"\r\n                    #tr\r\n                    *ngFor=\"let row of data; trackBy: dg.trackByRows; let i = index\">\r\n\r\n                        <td *ngIf=\"dg.showCheckbox && dg.fast\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center;left:0\" \r\n                            [class.f-datagrid-fast__fixed-left]=\"dg.fast\" [class.l-shadow-col]=\"dg.fast && !dg.showLineNumber && !hasFixedColumns\">\r\n                            <div class=\"f-datagrid-cell-content checkbox-column\" style=\"text-overflow: unset;\">\r\n                            <datagrid-checkbox [disabled]=\"row | disableRow: startRowIndex + i: dg.disableRow\" [rowData]=\"row\"\r\n                                [rowIndex]=\"startRowIndex + i\" [checked]=\"row | rowIsChecked: checkedRows\"></datagrid-checkbox>\r\n                            </div>\r\n                        </td>\r\n            \r\n                        <td *ngIf=\"dg.showLineNumber  && dg.fast\" [style.width.px]=\"dg.lineNumberWidth\" class=\"f-datagrid-cell f-datagrid-cell-rownumber\"\r\n                        [class.f-datagrid-fast__fixed-left]=\"dg.fast\" [style.left.px]=\"dg.showCheckbox ? 36: 0\"\r\n                        [class.l-shadow-col]=\"dg.fast && !hasFixedColumns\">\r\n                            <div class=\"f-datagrid-cell-content\">\r\n                                {{ dg.pageSize * (dg.pageIndex-1) + startRowIndex + i + 1 }}\r\n                            </div>\r\n                        </td>\r\n\r\n                        <td *ngFor=\"let column of columns; trackBy: trackByField; index as ci; last as islast;\"\r\n                            [attr.field]=\"column.field\"\r\n                            class=\"f-datagrid-cell\" \r\n                            [attr.align]=\"column.align\"\r\n                            [style.display]=\" showCell(column, startRowIndex + i) ? '': 'none' \"\r\n                            [style.vertical-align]=\"column.valign\"\r\n                            [attr.rowspan]=\" getRowSpan(column, startRowIndex + i)\"\r\n                            [cell-editable]=\"row\"\r\n                            [column]=\"column\" #td \r\n                            [class.f-datagrid-td-merged]=\"td.rowSpan > 1\"\r\n                            [class.f-datagrid-fast__fixed-left]=\"dg.fast && column.fixed && column.fixed === 'left'\"\r\n                            [class.f-datagrid-fast__fixed-right]=\"dg.fast && column.fixed && column.fixed === 'right'\"\r\n                            [class.r-shadow-col]=\"column.rightShadowCol\"\r\n                            [class.l-shadow-col]=\"column.leftShadowCol\">\r\n                            <grid-body-cell \r\n                                [width]=\"column.width\"\r\n                                [height]=\"dg.rowHeight\" \r\n                                [lastColumn]=\"islast\"\r\n                                [column]=\"column\"\r\n                                [rowData]=\"row\"\r\n                                [rowIndex]=\"startRowIndex + i\">\r\n                            </grid-body-cell>\r\n                        </td>\r\n                </tr>\r\n            </ng-container>\r\n    </tbody>\r\n\r\n</table>"
            }] }
];
/** @nocollapse */
DatagridRowsComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] },
    { type: DatagridBodyComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridBodyComponent)),] }] },
    { type: ElementRef },
    { type: Injector },
    { type: NgZone }
];
DatagridRowsComponent.propDecorators = {
    startRowIndex: [{ type: Input }],
    data: [{ type: Input }],
    columns: [{ type: Input }],
    tableEl: [{ type: ViewChild, args: ['tableEl',] }],
    fixedRight: [{ type: Input }],
    hasFixedColumns: [{ type: Input }],
    width: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * @Author: 疯狂秀才(Lucas Huang)
 * @Date: 2019-09-06 08:30:18
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-09-06 08:34:35
 * @QQ: 1055818239
 * @Version: v0.0.1
 */
/**
 * 兼容老版本，xxxxxxx
 */
class TextboxEditorComponent {
}
TextboxEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'grid-editor-textbox',
                template: ''
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridHeaderComponent {
    /**
     * @param {?} render2
     * @param {?} injector
     * @param {?} dg
     * @param {?} ngZone
     */
    constructor(render2, injector, dg, ngZone) {
        this.render2 = render2;
        this.injector = injector;
        this.dg = dg;
        this.ngZone = ngZone;
        this.height = 35;
        this.columns = [];
        this.enableDragColumn = false;
        this.wrapHeader = false;
        this.enableFilterRow = false;
        this.scrollbarMode = 'auto';
        /**
         * 启用性能优化版
         */
        this.fast = false;
        this.ro = null;
        this.rightFixedColumnWidth = 0;
        this.normalColumnWidth = 0;
        this.showOverlay = false;
        this.disableSort = false;
        this.scrollX = 0;
        this.showShadowCls = false;
        this.top = 0;
        this.hasFixedLeftColumns = false;
        this.destroy$ = new Subject();
        this.lineNumberTitle = '序号';
        this.dfs = this.injector.get(DatagridFacadeService);
        this.dgs = this.injector.get(DatagridService);
        this.cfr = this.injector.get(ComponentFactoryResolver);
        this.cd = this.injector.get(ChangeDetectorRef);
        this.el = this.injector.get(ElementRef);
        this.dfrs = this.dg.clientFilterService;
        this.dgs.scorll$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} d
         * @return {?}
         */
        (d) => {
            if (d.type === SCROLL_X_ACTION || d.type === SCROLL_X_REACH_END_ACTION || d.type === SCROLL_X_REACH_START_ACTION) {
                this.scrollX = d.x;
                this.render2.setStyle(this.headerColumnsTable.nativeElement, 'transform', `translate3d(-${d.x}px, 0px, 0px)`);
                if (!this.dg.groupRows) {
                    if (this.fixedLeft) {
                        if (d.x) {
                            this.render2.addClass(this.fixedLeft.nativeElement, FIXED_LEFT_SHADOW_CLS);
                        }
                        else {
                            this.render2.removeClass(this.fixedLeft.nativeElement, FIXED_LEFT_SHADOW_CLS);
                        }
                    }
                }
            }
            if (d.type === SCROLL_X_REACH_START_ACTION) {
                if (this.fixedLeft) {
                    this.render2.removeClass(this.fixedLeft.nativeElement, FIXED_LEFT_SHADOW_CLS);
                }
            }
        }));
        this.dgs.showFixedShadow.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (this.fixedRight) {
                this.setFixedColumnPosition(e.showRightShadow, e.x);
            }
        }));
        this.dgs.disableHeader.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} flag
         * @return {?}
         */
        (flag) => {
            this.showOverlay = flag;
            this.disableSort = flag;
            this.cd.detectChanges();
        }));
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set chkAll(v) {
        this._chkall = v;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set fr(val) {
        if (val) {
            this.fixedRight = val;
        }
    }
    // 行号 、 复选框，在多表头下的合并行数
    /**
     * @return {?}
     */
    get rowSpan() {
        // TFS 495872
        // return this.columns.length + (this.dg.enableFilterRow ? 1 : 0);
        return this.columns.length;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dgs.checkedRowsTotalChanged$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this._chkall) {
                /** @type {?} */
                const checkedsCount = this.dfs.getCurrentPageCheckeds().length;
                /** @type {?} */
                const isCheckAll = this.dfs.isCheckAll();
                /** @type {?} */
                const isIndeterminate = isCheckAll || !checkedsCount;
                this._chkall.chk.nativeElement.indeterminate = !isIndeterminate;
                /** @type {?} */
                const _checked = isCheckAll && checkedsCount > 0;
                this._chkall.updateStatus(_checked);
            }
        }));
        this.dgs.uncheckAll.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this.dg.showAllCheckbox && this._chkall) {
                this._chkall.chk.nativeElement.indeterminate = false;
                this._chkall.chk.nativeElement.checked = false;
            }
        }));
        this.dgs.checkAll.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this._chkall) {
                this._chkall.chk.nativeElement.checked = true;
            }
        }));
        this.dgs.scrollbarUpdate.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} ps
         * @return {?}
         */
        (ps) => {
            this.ps = ps.scrollbarRef;
            // const rw = ps.rightWidth || 0;
            // if (!rw) {
            //     this.rightFixedColumnWidth = this.getRightFixedColWidth(this.ps);
            // } else {
            //     this.rightFixedColumnWidth = rw;
            // }
            this.rightFixedColumnWidth = this.getRightFixedColWidth(this.ps);
            if (this.fixedRight) {
                this.setFixedColumnPosition(ps.showRightShadow, 0);
            }
            this.cd.detectChanges();
        }));
        this.dgs.showGridHeader.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.setHeaderPosition();
        }));
        this.dgs.smartFilterBarExpand.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.setHeaderPosition();
        }));
        this.rightFixedColumnWidth = this.getRightFixedColWidth(this.ps);
        this.hasFixedLeftColumns = this.columnsGroup && this.columnsGroup.leftFixed && !!this.columnsGroup.leftFixed.length;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.setHeaderPosition();
        }));
        this.lineNumberTitle = this.getLineNumberTitle();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.columnsGroup && !changes.columnsGroup.isFirstChange()) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.rightFixedColumnWidth = this.getRightFixedColWidth(this.ps);
                this.hasFixedLeftColumns = this.columnsGroup && this.columnsGroup.leftFixed && !!this.columnsGroup.leftFixed.length;
                if (!this.cd['destroyed']) {
                    this.cd.detectChanges();
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.fixedRight = null;
    }
    /**
     * @private
     * @return {?}
     */
    getLineNumberTitle() {
        if (this.dg.lineNumberTitle) {
            return this.dg.lineNumberTitle;
        }
        else {
            return this.dg.localeService.getValue('datagrid.lineNumberTitle');
        }
    }
    /**
     * @private
     * @param {?=} ps
     * @return {?}
     */
    getRightFixedColWidth(ps = null) {
        if (!this.columnsGroup) {
            return 0;
        }
        /** @type {?} */
        let w = this.columnsGroup.rightFixedWidth;
        ps = this.dg.scrollInstance ? this.dg.scrollInstance.instance : null;
        if (ps && ps.scrollbarYActive && this.scrollbarMode === 'allways') {
            return w += 18;
        }
        return w;
    }
    /**
     * @private
     * @return {?}
     */
    setHeaderPosition() {
        /** @type {?} */
        let top = 0;
        if ((this.dg.enableFilterRow || this.dg.enableSmartFilter) && this.dg.showFilterBar) {
            top += this.dg.filterBarHeight;
        }
        if (this.dg.showRowGroupPanel) {
            top += this.dg.rowGroupPanelHeight;
        }
        this.top = top;
        this.render2.setStyle(this.el.nativeElement, 'top', `${top}px`);
        /** @type {?} */
        const headerCellHeight = `${this.dg.customStyleKey()} .f-datagrid-header .f-datagrid-header-cell-content`;
        this.dgs.removeCssRule(headerCellHeight);
        this.dg.renderCustomStyle2({ style: { 'min-height': this.dg.headerHeight + 'px' } }, this.el.nativeElement, headerCellHeight);
        /** @type {?} */
        const filterRowCls = `${this.dg.customStyleKey()} .f-datagrid-header-row.f-datagrid-filter-row .f-datagrid-header-cell-content`;
        this.dgs.removeCssRule(filterRowCls);
        if (this.dg.enableFilterRow) {
            this.dgs.appendCssRules([`${filterRowCls} { height: ${this.dg.filterRowHeight}px;min-height:${this.dg.filterRowHeight}px }`]);
        }
    }
    /**
     * @param {?} fixedLeftWidth
     * @return {?}
     */
    isShowShadow(fixedLeftWidth) {
        /** @type {?} */
        const dgContainerWidth = this.dg.dgContainer.nativeElement.offsetWidth;
        return dgContainerWidth < this.dg.colGroup.totalWidth;
    }
    /**
     * @param {?} left
     * @param {?} right
     * @param {?} col
     * @param {?=} isdatafield
     * @return {?}
     */
    isColspan(left, right, col, isdatafield = false) {
        // if (this.fast) {
        //     if (isdatafield) {
        //         return !col.colspan;
        //     } else {
        //         return col.colspan;
        //     }
        // }
        // if (this.fast) {
        //     if (isdatafield) {
        //         return !col.colspan;
        //     } else {
        //         return col.colspan;
        //     }
        // }
        /** @type {?} */
        const _iscolspan = (/**
         * @param {?} fixed
         * @return {?}
         */
        (fixed) => {
            if (!fixed || fixed == 'none') {
                if (isdatafield) {
                    return (!col.colspan || col.colspan === 1) && (!col.fixed || col.fixed === 'none');
                }
                else {
                    return col.colspan && col.colspan > 1 && (!col.fixed || col.fixed === 'none');
                }
            }
            else {
                if (isdatafield) {
                    return (!col.colspan || col.colspan === 1) && col.fixed === fixed;
                }
                else {
                    return col.colspan && col.colspan > 1 && col.fixed && col.fixed === fixed;
                }
            }
        });
        if (!left && !right) {
            return _iscolspan('none');
        }
        else if (left) {
            return _iscolspan('left');
        }
        else if (right) {
            return _iscolspan('right');
        }
    }
    /**
     * @param {?} isShow
     * @param {?} scrollLeft
     * @return {?}
     */
    setFixedColumnPosition(isShow, scrollLeft) {
        this.showShadowCls = isShow;
        /** @type {?} */
        const method = isShow ? 'addClass' : 'removeClass';
        this.render2[method](this.fixedRight.nativeElement, FIXED_RIGHT_SHADOW_CLS);
        /** @type {?} */
        const realWidth = this.columnsGroup.leftFixedWidth + this.columnsGroup.normalWidth + this.rightFixedColumnWidth;
        /** @type {?} */
        const gridWidth = this.dg.width;
        /** @type {?} */
        let l = this.dg.width - (this.dg.showBorder ? 2 : 0) - this.rightFixedColumnWidth;
        if (gridWidth > realWidth) {
            l = this.columnsGroup.leftFixedWidth + this.columnsGroup.normalWidth;
            // if (this.dg.showBorder) {
            //     l-= 2;
            // }
        }
        this.render2.setStyle(this.fixedRight.nativeElement, 'left', l + 'px');
    }
    /**
     * @param {?} e
     * @param {?} rntd
     * @return {?}
     */
    onRowNumerColumnDblClick(e, rntd) {
        /** @type {?} */
        let maxRowNumber = this.dg.getRows().length;
        if (this.dg.pagination) {
            /** @type {?} */
            const pageSize = this.dg.pageSize;
            /** @type {?} */
            const pageIndex = this.dg.pageIndex;
            maxRowNumber = pageSize * pageIndex + pageSize;
        }
        this.dg.longTextArea.nativeElement.innerHTML = maxRowNumber;
        /** @type {?} */
        const w1 = this.dg.longTextArea.nativeElement.offsetWidth;
        /** @type {?} */
        const currentWidth = rntd.offsetWidth;
        if (w1 > currentWidth) {
            this.dg.lineNumberWidth = w1 + 10;
            this.dfs.updateProperty('lineNumberWidth', this.dg.lineNumberWidth);
            this.dfs.resizeColumns();
        }
    }
    /**
     * @param {?} e
     * @param {?} col
     * @return {?}
     */
    onSortColumnClick(e, col) {
        if (this['SORT_CLICK_TIMER']) {
            clearTimeout(this['SORT_CLICK_TIMER']);
        }
        this['SORT_CLICK_TIMER'] = setTimeout((/**
         * @return {?}
         */
        () => {
            this._onSortClick(e, col);
        }), 250);
    }
    /**
     * @private
     * @param {?} e
     * @param {?} col
     * @return {?}
     */
    _onSortClick(e, col) {
        e.stopPropagation();
        if (this.disableSort) {
            return;
        }
        if (!col.sortable) {
            return;
        }
        // 结束编辑
        this.dg.cancelEdit(null);
        /** @type {?} */
        const sortName = this.dg.sortName;
        /** @type {?} */
        const sortOrder = this.dg.sortOrder;
        /** @type {?} */
        let sortFields = [];
        /** @type {?} */
        let sortOrders = [];
        if (sortName) {
            sortFields = sortName.split(',');
            sortOrders = sortOrder.split(',');
        }
        /** @type {?} */
        const colOrder = col.order || 'asc';
        /** @type {?} */
        let newOrder = colOrder;
        /** @type {?} */
        const i = sortFields.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => n === col.field));
        if (i >= 0) {
            /** @type {?} */
            const _order = sortOrders[i] === 'asc' ? 'desc' : 'asc';
            newOrder = _order;
            // if (this.dg.multiSort && newOrder === 'asc') {
            if (newOrder === 'asc') {
                newOrder = undefined;
                sortFields.splice(i, 1);
                sortOrders.splice(i, 1);
            }
            else {
                sortOrders[i] = _order;
            }
        }
        else {
            if (this.dg.multiSort) {
                sortFields.push(col.field);
                sortOrders.push(colOrder);
            }
            else {
                sortFields = [col.field];
                sortOrders = [colOrder];
            }
        }
        col.order = newOrder;
        this.dg.sortName = sortFields.join(',');
        this.dg.sortOrder = sortOrders.join(',');
        this.dfs.setSortInfo(this.dg.sortName, this.dg.sortOrder);
        this.dg.beforeSortColumn(this.dg.sortName, this.dg.sortOrder, this.dg).subscribe((/**
         * @return {?}
         */
        () => {
            this.dg.onColumnSorted();
        }));
    }
}
DatagridHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-header',
                template: "<!--\r\n * @Author: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @Date: 2019-08-06 07:43:53\r\n * @LastEditors: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @LastEditTime: 2019-11-05 08:53:26\r\n * @QQ: 1055818239\r\n * @Version: v0.0.1\r\n -->\r\n <!-- [style.maxWidth.px]=\"col.width - 44\"   =>  style=\"width: 100%\"    -->\r\n<ng-template #filterAndSort let-col>\r\n    <ng-container *ngIf=\"col.filter\">\r\n        <span style=\"width: 100%\" class=\"f-datagrid-header-cell-title\" [header-style]=\"col\"><span class=\"text-danger\" *ngIf=\" col.validators | showStar \">*</span>{{col.title}}</span>\r\n        <ng-container *ngIf=\"col.sortable \">\r\n            <span class=\"f-datagrid-sort\" [class.f-datagrid-filter-sort-asc]=\"col.order === 'asc'\"\r\n                [class.f-datagrid-filter-sort-desc]=\"col.order === 'desc'\"\r\n                [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\" *ngIf=\"col.order\"\r\n                datagrid-smart-filter [disabled]=\"disableSort\" [column]=\"col\"> </span>\r\n            <span class=\"f-datagrid-sort f-datagrid-filter-sort\" [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\"\r\n                datagrid-smart-filter [disabled]=\"disableSort\" [column]=\"col\" *ngIf=\"!col.order\"></span>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!col.sortable\">\r\n            <span class=\"f-datagrid-sort f-datagrid-filter\" datagrid-smart-filter  [disabled]=\"disableSort\"  [column]=\"col\"></span>\r\n        </ng-container>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"!col.filter\" [ngTemplateOutlet]=\"column_title\" [ngTemplateOutletContext]=\"{$implicit: col}\">\r\n    </ng-container>\r\n</ng-template>\r\n\r\n<ng-template #column_title let-col>\r\n    <ng-container *ngIf=\"!col.sortable\">\r\n        <span [style.width.px]=\"col.width - 20\" class=\"f-datagrid-header-cell-title\" [header-style]=\"col\" \r\n            *ngIf=\"col.field !== dg.ControlPanelFeild\"><span class=\"text-danger\" *ngIf=\" col.validators | showStar \">*</span>{{col.title}}</span>\r\n        <span *ngIf=\"col.field === dg.ControlPanelFeild\" class=\"f-datagrid-header-cell-title\"\r\n            style=\"position: absolute; left: 3px; cursor: pointer;\"\r\n            (click)=\"dg.showControlPanel($event)\">\r\n            <span class=\"f-icon f-icon-home-setup\"></span>\r\n        </span>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"col.sortable\">\r\n        <span style=\"width: 100%\"  class=\"f-datagrid-header-cell-title\" [header-style]=\"col\"><span class=\"text-danger\" *ngIf=\" col.validators | showStar \">*</span>{{col.title}}</span>\r\n        <span class=\"f-datagrid-sort\" [class.f-datagrid-sort-asc]=\"col.order === 'asc'\"\r\n            [class.f-datagrid-sort-desc]=\"col.order === 'desc'\"\r\n            [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\"\r\n            (click)=\"onSortColumnClick($event, col)\" *ngIf=\"col.order\"> </span>\r\n        <span class=\"f-datagrid-sort\" [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\"\r\n            (click)=\"onSortColumnClick($event, col)\" *ngIf=\"!col.order \"></span>\r\n    </ng-container>\r\n</ng-template>\r\n\r\n<!-- \u4F7F\u7528\u8868\u5934\u6A21\u677F\u65F6\uFF0C\u6392\u5E8F\u6A21\u677F -->\r\n<ng-template #column_sort let-col>\r\n    <ng-container *ngIf=\"!col.sortable\">\r\n        <span *ngIf=\"col.field === dg.ControlPanelFeild\" class=\"f-datagrid-header-cell-title\"\r\n            style=\"position: absolute; left: 3px; cursor: pointer;\"\r\n            (click)=\"dg.showControlPanel($event)\">\r\n            <span class=\"f-icon f-icon-home-setup\"></span>\r\n        </span>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"col.sortable\">\r\n        <span class=\"f-datagrid-sort\" [class.f-datagrid-sort-asc]=\"col.order === 'asc'\"\r\n            [class.f-datagrid-sort-desc]=\"col.order === 'desc'\"\r\n            [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\"\r\n            (click)=\"onSortColumnClick($event, col)\" *ngIf=\"col.order\"> </span>\r\n        <span class=\"f-datagrid-sort\" [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\"\r\n            (click)=\"onSortColumnClick($event, col)\" *ngIf=\"!col.order \"></span>\r\n    </ng-container>\r\n</ng-template>\r\n\r\n<!-- \u4F7F\u7528\u8868\u5934\u6A21\u677F\u65F6\uFF0C\u667A\u80FD\u8FC7\u6EE4\u6A21\u677F -->\r\n<ng-template #smartfilter let-col>\r\n    <ng-container *ngIf=\"col.filter\">\r\n        <ng-container *ngIf=\"col.sortable \">\r\n            <span class=\"f-datagrid-sort\" [class.f-datagrid-filter-sort-asc]=\"col.order === 'asc'\"\r\n                [class.f-datagrid-filter-sort-desc]=\"col.order === 'desc'\"\r\n                [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\" *ngIf=\"col.order\"\r\n                datagrid-smart-filter [disabled]=\"disableSort\" [column]=\"col\"> </span>\r\n            <span class=\"f-datagrid-sort f-datagrid-filter-sort\" [style.cursor]=\"disableSort ? 'not-allowed': 'pointer'\"\r\n                datagrid-smart-filter [disabled]=\"disableSort\" [column]=\"col\" *ngIf=\"!col.order\"></span>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!col.sortable\">\r\n            <span class=\"f-datagrid-sort f-datagrid-filter\" datagrid-smart-filter  [disabled]=\"disableSort\"  [column]=\"col\"></span>\r\n        </ng-container>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"!col.filter\" [ngTemplateOutlet]=\"column_sort\" [ngTemplateOutletContext]=\"{$implicit: col}\"></ng-container>\r\n</ng-template>\r\n\r\n\r\n<ng-template #column_template let-col let-left=\"left\" let-right=\"right\">\r\n    <ng-container *ngIf=\"isColspan(left, right, col, false) \">\r\n        <td [resize-column]=\"col\" class=\"f-datagrid-header-cell f-datagrid-header-cell-group\" [attr.align]=\"col.halign\"\r\n            [attr.colspan]=\"col.colspan\" [attr.title]=\"col.title\"\r\n            [class.r-shadow-col]=\"col.rightShadowCol\"\r\n            [class.l-shadow-col]=\"col.leftShadowCol\" [header-style]=\"col\">\r\n            <div class=\"f-datagrid-header-cell-content  d-flex align-items-center\" [header-style]=\"col\" [groupHeader]=\"true\">{{col.title}}</div>\r\n        </td>\r\n    </ng-container>\r\n    <ng-container *ngIf=\"isColspan(left, right, col, true)\">\r\n        <td [resize-column]=\"col\" class=\"f-datagrid-header-cell\" [attr.align]=\"col.halign\" [attr.field]=\"col.field\"\r\n            [attr.rowspan]=\"col.rowspan\" [attr.title]=\"col.title\"\r\n            *ngIf=\"dg.columnIsVisible(col)\"\r\n            [style.display]=\"dg.columnIsVisible(col) ? '': 'none'\"\r\n            [class.f-datagrid-header-cell-sort]=\"col.sortable\"\r\n            [class.smooth-dnd-draggable-wrapper]=\"enableDragColumn && col.field !== dg.ControlPanelFeild \"\r\n            [header-style]=\"col\">\r\n            <div class=\"f-datagrid-header-cell-content  d-flex flex-row align-items-center\" [style.width.px]=\"col.width\" >\r\n                <span class=\"drag-column-bar f-icon f-icon-more-vertical\" *ngIf=\"col.field !== dg.ControlPanelFeild && enableDragColumn && !dg.editable\"></span>\r\n                \r\n                <ng-container *ngIf=\"col.headerTemplate && !col.headerComponentType\">\r\n                    <span class=\"text-danger pr-1\" *ngIf=\" col.validators | showStar \">*</span>\r\n                    <ng-container [ngTemplateOutlet]=\"col.headerTemplate\" [ngTemplateOutletContext]=\"{$implicit: col}\"></ng-container>\r\n                    <ng-container [ngTemplateOutlet]=\" !dg.enableSmartFilter ? column_sort : smartfilter \" [ngTemplateOutletContext]=\"{$implicit: col}\"></ng-container>\r\n                </ng-container>\r\n                <ng-container *ngIf=\"!col.headerTemplate && !col.headerComponentType\" [ngTemplateOutlet]=\" !dg.enableSmartFilter ? column_title : filterAndSort \" [ngTemplateOutletContext]=\"{$implicit: col}\"></ng-container>\r\n                <ng-container  *ngIf=\"col.headerComponentType\">\r\n                    <span class=\"text-danger\" *ngIf=\" col.validators | showStar \">*</span>\r\n                    <ng-container component-template [ctx]=\"{ col: col }\"></ng-container>\r\n                    <ng-container [ngTemplateOutlet]=\" !dg.enableSmartFilter ? column_sort : smartfilter \" [ngTemplateOutletContext]=\"{$implicit: col}\"></ng-container>\r\n                </ng-container>\r\n            </div>\r\n        </td>\r\n    </ng-container>\r\n</ng-template>\r\n\r\n<ng-template #header_template_inner let-columns let-left=\"left\" let-right=\"right\" let-groupCols=\"groupCols\">\r\n    <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"height: 100%; \">\r\n        <colgroup>\r\n            <col [style.width.px]=\"dg.checkboxColumnWidth || 36\" *ngIf=\"dg.showCheckbox && left\">\r\n            <col [width]=\"dg?.lineNumberWidth + 'px'\" *ngIf=\"dg.showLineNumber && left\">\r\n            <ng-container *ngFor=\"let col of groupCols\">\r\n                <col [width]=\"col.width + 'px'\" *ngIf=\"col.width && col.field\">\r\n            </ng-container>\r\n        </colgroup>\r\n        <thead [class.header-wrap]=\"wrapHeader\">\r\n            <tr class=\"f-datagrid-header-row\" *ngFor=\"let cols of columns; index as colsIdx; first as isFirst\"\r\n                [drag-column]=\"enableDragColumn\" [groupName]=\"left?'left': right ? 'right': 'center'\">\r\n                <!-- \u590D\u9009\u6846 -->\r\n                <td *ngIf=\"dg.showCheckbox && isFirst && left\" #chktd\r\n                    class=\"f-datagrid-header-cell f-datagrid-header-checkbox\" \r\n                    [attr.rowspan]=\"rowSpan\">\r\n                    <div class=\"f-datagrid-header-cell-content\" style=\"overflow:hidden;text-align:center\" [style.width.px]=\"dg.checkboxColumnWidth || 36\">\r\n                        <datagrid-header-checkbox #chkAll *ngIf=\"dg.showAllCheckbox && dg.multiSelect\" ></datagrid-header-checkbox>\r\n                    </div>\r\n                </td>\r\n                <!-- \u884C\u53F7 -->\r\n                <td *ngIf=\"dg.showLineNumber && isFirst && left\" #rntd\r\n                    class=\"f-datagrid-header-cell f-datagrid-cell-rownumber\" [attr.rowspan]=\"rowSpan\"\r\n                    (dblclick)=\"onRowNumerColumnDblClick($event, rntd)\">\r\n                    <div class=\"f-datagrid-header-cell-content  d-flex align-items-center\" style=\"padding: 0px;\"  [style.width.px]=\"dg?.lineNumberWidth\">\r\n                        \r\n                        <span style=\"width: 100%\" class=\"f-datagrid-header-cell-title\">\r\n                            {{ lineNumberTitle }}\r\n                        </span>\r\n                    </div>\r\n                </td>\r\n                <ng-container *ngFor=\"let col of cols; last as isLast\">\r\n                    <ng-container\r\n                        *ngTemplateOutlet=\"column_template; context: {$implicit: col, left: left, right: right}\">\r\n                    </ng-container>\r\n                </ng-container>\r\n            </tr>\r\n            <tr *ngIf=\"enableFilterRow\" [style.height.px]=\"dg.filterRowHeight\" class=\"f-datagrid-header-row f-datagrid-filter-row\">\r\n                <!-- \u590D\u9009\u6846 -->\r\n                <td *ngIf=\"dg.showCheckbox && left\" class=\"f-datagrid-header-cell f-datagrid-header-checkbox\" >\r\n                </td>\r\n                <!-- \u884C\u53F7 -->\r\n                <td *ngIf=\"dg.showLineNumber && left\" class=\"f-datagrid-header-cell f-datagrid-cell-rownumber\" >\r\n                </td>\r\n                \r\n                <ng-container filter-row-creator [left]=\"left\" [right]=\"right\">\r\n                </ng-container>\r\n            </tr>\r\n        </thead>\r\n    </table>\r\n</ng-template>\r\n\r\n\r\n<ng-template #header_template_inner_right let-columns let-left=\"left\" let-right=\"right\" let-groupCols=\"groupCols\">\r\n    <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"height: 100%; \" [style.width.px]=\"columnsGroup.rightFixedWidth\">\r\n        <colgroup>\r\n            <col [style.width.px]=\"dg.checkboxColumnWidth || 36\" *ngIf=\"dg.showCheckbox && left\">\r\n            <col [width]=\"dg?.lineNumberWidth + 'px'\" *ngIf=\"dg.showLineNumber && left\">\r\n            <ng-container *ngFor=\"let col of groupCols\">\r\n                <col [width]=\"col.width + 'px'\" *ngIf=\"col.width && col.field\">\r\n            </ng-container>\r\n        </colgroup>\r\n        <thead [class.header-wrap]=\"wrapHeader\">\r\n            <tr class=\"f-datagrid-header-row\" *ngFor=\"let cols of columns; index as colsIdx; first as isFirst\"\r\n                [drag-column]=\"enableDragColumn\" [groupName]=\"left?'left': right ? 'right': 'center'\">\r\n                <!-- \u590D\u9009\u6846 -->\r\n                <td *ngIf=\"dg.showCheckbox && isFirst && left\" #chktd\r\n                    class=\"f-datagrid-header-cell f-datagrid-header-checkbox\" \r\n                    [attr.rowspan]=\"rowSpan\">\r\n                    <div class=\"f-datagrid-header-cell-content\" style=\"width: 36px; text-align: center;overflow:hidden; \">\r\n                        <datagrid-header-checkbox #chkAll *ngIf=\"dg.showAllCheckbox && dg.multiSelect\" ></datagrid-header-checkbox>\r\n                    </div>\r\n                </td>\r\n                <!-- \u884C\u53F7 -->\r\n                <td *ngIf=\"dg.showLineNumber && isFirst && left\" #rntd\r\n                    class=\"f-datagrid-header-cell f-datagrid-cell-rownumber\" [attr.rowspan]=\"rowSpan\"\r\n                    (dblclick)=\"onRowNumerColumnDblClick($event, rntd)\">\r\n                    <div class=\"f-datagrid-header-cell-content\" style=\"padding: 0px;\"  [style.width.px]=\"dg?.lineNumberWidth\">\r\n                        \r\n                        <span style=\"width: 100%\" class=\"f-datagrid-header-cell-title\">\r\n                            {{ lineNumberTitle }}\r\n                        </span>\r\n                    </div>\r\n                </td>\r\n                <ng-container *ngFor=\"let col of cols; last as isLast\">\r\n                    <ng-container\r\n                        *ngTemplateOutlet=\"column_template; context: {$implicit: col, left: left, right: right}\">\r\n                    </ng-container>\r\n                </ng-container>\r\n            </tr>\r\n            <tr *ngIf=\"enableFilterRow\" [style.height.px]=\"dg.filterRowHeight\" class=\"f-datagrid-header-row f-datagrid-filter-row\">\r\n                <!-- \u590D\u9009\u6846 -->\r\n                <td *ngIf=\"dg.showCheckbox && left\" class=\"f-datagrid-header-cell f-datagrid-header-checkbox\" >\r\n                </td>\r\n                <!-- \u884C\u53F7 -->\r\n                <td *ngIf=\"dg.showLineNumber && left\" class=\"f-datagrid-header-cell f-datagrid-cell-rownumber\" >\r\n                </td>\r\n                \r\n                <ng-container filter-row-creator [left]=\"left\" [right]=\"right\">\r\n                </ng-container>\r\n            </tr>\r\n        </thead>\r\n    </table>\r\n</ng-template>\r\n\r\n\r\n\r\n<div class=\"f-datagrid-header\" #header [style.width.px]=\"dg.width\">\r\n\r\n            \r\n        <!--\u5DE6\u4FA7\u56FA\u5B9A\u5217-->\r\n        <div #fixedLeft class=\"f-datagrid-header-fixed-left\"\r\n            *ngIf=\"columnsGroup?.leftFixed && columnsGroup?.leftFixed.length  || dg?.showLineNumber || dg?.showCheckbox \"\r\n            [style.width.px]=\"columnsGroup?.leftFixedWidth\"\r\n            [style.height.px]=\"height\">\r\n            <ng-container *ngTemplateOutlet=\"header_template_inner; context: { $implicit: columns, left: true, right: false,\r\n                groupCols:  columnsGroup?.leftFixed}\">\r\n            </ng-container>\r\n        </div>\r\n\r\n        <!--\u6B63\u5E38\u5217-->\r\n        <div #headerContainer class=\"f-datagrid-header-center\" \r\n            [style.left.px]=\"columnsGroup?.leftFixedWidth\"\r\n            [style.width.px]=\"columnsGroup?.normalWidth\"\r\n            style=\"position: absolute;height: 100%\">\r\n            <ng-container *ngTemplateOutlet=\"header_template_inner; context: {$implicit: columns, left: false, right: false,\r\n                groupCols:  columnsGroup?.normalColumns}\">\r\n            </ng-container>\r\n        </div>\r\n        <!--\u53F3\u4FA7\u56FA\u5B9A\u5217-->\r\n        <div #fixedRight class=\"f-datagrid-header-fixed-right\"\r\n            *ngIf=\"columnsGroup?.rightFixed && columnsGroup?.rightFixed.length\"\r\n            [style.width.px]=\"dg.showBorder?  rightFixedColumnWidth : rightFixedColumnWidth + 1\"\r\n            [style.height.px]=\"height\" style=\"border: 0; background-color: #F1F3F7;\">\r\n            <ng-container *ngTemplateOutlet=\"header_template_inner_right; context: {$implicit: columns, left: false, right: true,\r\n                groupCols: columnsGroup?.rightFixed}\">\r\n            </ng-container>\r\n        </div>\r\n\r\n    <div class=\"filter-row-disabled\"\r\n        style=\"position: absolute;background: rgb(255, 255, 255);width: 100%;z-index: 9;height: 40px; bottom:0;opacity: 0;\"\r\n        [style.left.px]=\"dg.showAllCheckbox ? 36 : 0\" *ngIf=\"showOverlay && dg.enableFilterRow\">\r\n    </div>\r\n</div>\r\n\r\n",
                encapsulation: ViewEncapsulation.None,
                exportAs: 'dgHeader',
                styles: [`
        .f-datagrid-header-cell:hover>div>div {
            width: calc(100% - 15px);
        }

        .drag-column-bar.f-icon-more-vertical:before {
            position: relative;
            top: -2px;
        }
        .f-datagrid-header-cell-content .f-datagrid-sort:before {
            position: relative;
            top: -1px;
        }
    `]
            }] }
];
/** @nocollapse */
DatagridHeaderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: Injector },
    { type: DatagridComponent, decorators: [{ type: Optional }] },
    { type: NgZone }
];
DatagridHeaderComponent.propDecorators = {
    height: [{ type: Input }],
    columns: [{ type: Input }],
    columnsGroup: [{ type: Input }],
    enableDragColumn: [{ type: Input }],
    wrapHeader: [{ type: Input }],
    enableFilterRow: [{ type: Input }],
    scrollbarMode: [{ type: Input }],
    fast: [{ type: Input }],
    header: [{ type: ViewChild, args: ['header',] }],
    headerColumnsTable: [{ type: ViewChild, args: ['headerContainer',] }],
    fixedLeft: [{ type: ViewChild, args: ['fixedLeft',] }],
    chkAll: [{ type: ViewChild, args: ['chkAll',] }],
    fr: [{ type: ViewChild, args: ['fixedRight',] }]
};
class FilterRowCreateDirective {
    /**
     * @param {?} vc
     * @param {?} injector
     * @param {?} dg
     * @param {?} ngZone
     */
    constructor(vc, injector, dg, ngZone) {
        this.vc = vc;
        this.injector = injector;
        this.dg = dg;
        this.ngZone = ngZone;
        this.destroy$ = new Subject();
        this.dfs = this.injector.get(DatagridFacadeService);
        this.dgs = this.injector.get(DatagridService);
        this.cfr = this.injector.get(ComponentFactoryResolver);
        this.cd = this.injector.get(ChangeDetectorRef);
        this.dfrs = this.dg.clientFilterService;
        this.headeRef = this.injector.get(DatagridHeaderComponent);
        this.filterRowType = this.injector.get(GRID_FILTER_ROW, null);
        this.dgs.clearFilter.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            if (this.filterRowRef) {
                this.filterRowRef.instance.clearFilterValue(false);
            }
        }));
        this.dgs.columnsChanged.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            /** @type {?} */
            const rebuild = e ? e.rebuildFilterBar : true;
            this.createFilterRow(rebuild);
        }));
        if (this.dfrs) {
            this.dfrs.removeField.pipe(takeUntil(this.destroy$)).subscribe((/**
             * @param {?} f
             * @return {?}
             */
            (f) => {
                if (this.filterRowRef && f) {
                    this.filterRowRef.instance.removeField(f);
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.createFilterRow(true);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * 过滤行
     * @param {?=} rebuild
     * @return {?}
     */
    createFilterRow(rebuild = false) {
        if (rebuild && this.filterRowRef) {
            this.filterRowRef.destroy();
            this.filterRowRef = null;
        }
        if (this['_FILTERROW_CREATE_TIMER_']) {
            clearTimeout(this['_FILTERROW_CREATE_TIMER_']);
        }
        this['_FILTERROW_CREATE_TIMER_'] = setTimeout((/**
         * @return {?}
         */
        () => {
            this._createFilterRow();
            if (rebuild && !this.cd['destroyed']) {
                this.cd.detectChanges();
            }
        }), 50);
    }
    /**
     * @private
     * @return {?}
     */
    _createFilterRow() {
        if (this.dg.enableFilterRow) {
            if (!this.filterRowType) {
                return;
            }
            /** @type {?} */
            let columnsData = this.dg.colGroup.normalColumns;
            if (this.left) {
                columnsData = this.dg.colGroup.leftFixed;
            }
            else if (this.right) {
                columnsData = this.dg.colGroup.rightFixed;
            }
            if (!this.filterRowRef && this.vc) {
                /** @type {?} */
                const cf = this.cfr.resolveComponentFactory(this.filterRowType);
                this.filterRowRef = this.vc.createComponent(cf);
                this.filterRowRef.instance.fixedLeft = this.left;
                this.filterRowRef.instance.columns = columnsData;
                this.filterRowRef.instance.gridInstance = this.dg;
                this.dgs.closeFilterPanel.subscribe((/**
                 * @return {?}
                 */
                () => {
                    this.filterRowRef.instance.dfrs.closeFilterPanel();
                }));
                this.filterRowRef.instance.conditionChange.subscribe((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => {
                    /** @type {?} */
                    const _currentConditionsString = JSON.stringify(this.dg.conditions || {});
                    const { conditions, removedFields } = n;
                    if (removedFields) {
                        delete this.dg.conditions[removedFields];
                    }
                    /** @type {?} */
                    const _conditions = this.mergeFilterConditions(conditions || {});
                    if (_currentConditionsString !== JSON.stringify(_conditions || {})) {
                        // 清理不存在的列
                        Object.keys(_conditions).forEach((/**
                         * @param {?} k
                         * @return {?}
                         */
                        k => {
                            /** @type {?} */
                            const col = this.dg.dfs.getColumn(k);
                            if (!col) {
                                delete _conditions[k];
                            }
                        }));
                        this.dgs.onFilterChanged.emit(_conditions);
                    }
                }));
            }
        }
    }
    /**
     * @private
     * @param {?} conditions
     * @return {?}
     */
    mergeFilterConditions(conditions) {
        /** @type {?} */
        const _conditions = Object.assign(this.dg.conditions || {}, conditions || {});
        Object.keys(_conditions).forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (_conditions[n] === null) {
                delete _conditions[n];
            }
        }));
        return _conditions;
    }
}
FilterRowCreateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[filter-row-creator]'
            },] }
];
/** @nocollapse */
FilterRowCreateDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: DatagridComponent },
    { type: NgZone }
];
FilterRowCreateDirective.propDecorators = {
    left: [{ type: Input }],
    right: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * @Author: 疯狂秀才(Lucas Huang)
 * @Date: 2019-08-10 09:04:53
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-11-20 17:09:09
 * @QQ: 1055818239
 * @Version: v0.0.12
 */
class DatagridResizeColumnDirective {
    /**
     * @param {?} dh
     * @param {?} ngzone
     * @param {?} el
     * @param {?} render
     */
    constructor(dh, ngzone, el, render) {
        this.dh = dh;
        this.ngzone = ngzone;
        this.el = el;
        this.render = render;
        this.dg = this.dh.dg;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.isEnable()) {
            this.render.addClass(this.el.nativeElement, 'f-datagrid-header-cell-resize');
            this.resizer = document.createElement('span');
            this.resizer.className = 'column-resize-bar';
            this.el.nativeElement.appendChild(this.resizer);
            this.ngzone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                // this.resizerMouseDownListener = this.onMouseDown.bind(this);
                // this.resizer.addEventListener('mousedown', this.resizerMouseDownListener);
                /** @type {?} */
                const mouseUp$ = fromEvent(this.resizer, 'mouseup');
                this.resizerMouseDownListener = fromEvent(this.resizer, 'mousedown').pipe(
                // debounceTime(260),
                takeUntil(mouseUp$)).subscribe((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => this.onMouseDown(e)));
            }));
            // const mouse$ = fromEvent(this.resizer, 'click');
            // const buff$ = mouse$.pipe(
            //     debounceTime(250)
            // );
            // const click$ = mouse$.pipe(
            //     buffer(buff$),
            //     map(list => {
            //         return {event: list[0], count: list.length};
            //     }),
            //     filter(x => x.count === 2),
            //     map(x => x.event),
            //     takeUntil(mouseUp$)
            // );
            // click$.subscribe((e) => {
            //     this.onDblClickHandler(e);
            //     // this.onMouseUp(e);
            // });
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDblClickHandler($event) {
        if ($event && $event.target && $event.target.className.indexOf('f-datagrid-sort') > -1) {
            return;
        }
        if (this.col.field && this.col.field !== this.dg.ControlPanelFeild) {
            /** @type {?} */
            const thRef = this.el;
            this.dg.sizeToContent(this.col, thRef);
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    isEnable() {
        if (this.dg.resizeColumn) {
            if (this.col.field === this.dg.ControlPanelFeild) {
                this.col.resizable = false;
            }
            if (this.col.resizable === undefined) {
                this.col.resizable = true;
            }
            return this.col.resizable;
        }
        return false;
    }
    /**
     * @return {?}
     */
    bindDocumentEvents() {
        this.ngzone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.documentMouseMoveListener = this.onMouseMove.bind(this);
            document.addEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseUpListener = this.onMouseUp.bind(this);
            document.addEventListener('mouseup', this.documentMouseUpListener);
        }));
    }
    /**
     * @return {?}
     */
    unbindDocumentEvents() {
        if (this.documentMouseMoveListener) {
            document.removeEventListener('mousemove', this.documentMouseMoveListener);
            this.documentMouseMoveListener = null;
        }
        if (this.documentMouseUpListener) {
            document.removeEventListener('mouseup', this.documentMouseUpListener);
            this.documentMouseUpListener = null;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        event.stopPropagation();
        this.dg.onColumnResizeBegin(event);
        this.render.addClass(this.el.nativeElement, 'column-resizeing');
        this.bindDocumentEvents();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        this.dg.onColumnResize(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        this.dg.onColumnResizeEnd(event, this.col);
        this.render.removeClass(this.el.nativeElement, 'column-resizeing');
        this.unbindDocumentEvents();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.resizerMouseDownListener) {
            // this.resizer.removeEventListener('mousedown', this.resizerMouseDownListener);
            this.resizerMouseDownListener.unsubscribe();
        }
        this.unbindDocumentEvents();
        if (this.dblclickListener) {
            this.dblclickListener();
        }
        this.resizer = null;
    }
}
DatagridResizeColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: '[resize-column]',
            },] }
];
/** @nocollapse */
DatagridResizeColumnDirective.ctorParameters = () => [
    { type: DatagridHeaderComponent, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 }
];
DatagridResizeColumnDirective.propDecorators = {
    col: [{ type: Input, args: ['resize-column',] }],
    onDblClickHandler: [{ type: HostListener, args: ['dblclick', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridFooterComponent {
    /**
     * @param {?} render
     * @param {?} injector
     * @param {?} dg
     */
    constructor(render, injector, dg) {
        this.render = render;
        this.injector = injector;
        this.dg = dg;
        this._footerData = [];
        /**
         * 显示位置，默认为 底部
         */
        this.position = 'bottom';
        /**
         * 是否有左侧固定列
         */
        this.hasFixedColumns = false;
        this.fast = false;
        this.scrollX = 0;
        this.showShadowCls = false;
        this.rightFixedColumnWidth = 0;
        this.cdRef = null;
        this.destroy$ = new Subject();
        this.dg = this.injector.get(DatagridComponent);
        this.dgs = this.injector.get(DatagridService);
        this.cdRef = this.injector.get(ChangeDetectorRef);
    }
    /**
     * @return {?}
     */
    get data() {
        return this._footerData;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set data(val) {
        this._footerData = val;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set fr(val) {
        if (val) {
            this.fixedRight = val;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.scrollEvents();
        this.renderFooterStyle();
        this.setFooterPosition(false);
        this.rightFixedColumnWidth = this.getRightFixedColWidth();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.position) {
            this.setFooterPosition(true);
        }
        if (changes.columnsGroup && !changes.columnsGroup.isFirstChange()) {
            this.rightFixedColumnWidth = this.getRightFixedColWidth();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        if (this.scrollXSubscription) {
            this.scrollXSubscription.unsubscribe();
            this.scrollXSubscription = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    scrollEvents() {
        this.dgs.showGridHeader.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} hh
         * @return {?}
         */
        hh => {
            this.setFooterPosition(false);
        }));
        this.scrollXSubscription = this.dgs.scorll$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} d
         * @return {?}
         */
        (d) => {
            this.scrollX = d.x;
            if (this.fast) {
                if (d.type === SCROLL_X_ACTION && this.footerBody2) {
                    this.footerBody2.nativeElement.scrollLeft = d.x;
                }
            }
            else {
                if (d.type === SCROLL_X_ACTION || d.type === SCROLL_X_REACH_END_ACTION || d.type === SCROLL_X_REACH_START_ACTION) {
                    if (!this.dg.footerTemplate) {
                        this.render.setStyle(this.footerBody.nativeElement, 'transform', `translate3d(-${d.x}px, 0px, 0px)`);
                        if (this.fixedLeft) {
                            if (d.x) {
                                this.render.addClass(this.fixedLeft.nativeElement, FIXED_LEFT_SHADOW_CLS);
                            }
                            else {
                                this.render.removeClass(this.fixedLeft.nativeElement, FIXED_LEFT_SHADOW_CLS);
                            }
                        }
                    }
                }
                if (d.type === SCROLL_X_REACH_START_ACTION) {
                    if (this.fixedLeft) {
                        this.render.removeClass(this.fixedLeft.nativeElement, FIXED_LEFT_SHADOW_CLS);
                    }
                }
            }
        }));
        if (!this.fast) {
            this.dgs.showFixedShadow.pipe(takeUntil(this.destroy$)).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (this.fixedRight) {
                    this.setFixedColumnPosition(e.showRightShadow, e.x);
                }
            }));
            this.dgs.scrollbarUpdate.pipe(takeUntil(this.destroy$)).subscribe((/**
             * @param {?} ps
             * @return {?}
             */
            (ps) => {
                // const rw = ps.rightWidth || 0;
                // if (!rw) {
                //     this.rightFixedColumnWidth = this.getRightFixedColWidth(ps.scrollbarRef);
                // } else {
                //     this.rightFixedColumnWidth = rw;
                // }
                this.rightFixedColumnWidth = this.getRightFixedColWidth(ps.scrollbarRef);
                if (this.fixedRight) {
                    this.setFixedColumnPosition(ps.showRightShadow, 0);
                }
                if (this.cdRef) {
                    this.cdRef.detectChanges();
                }
            }));
        }
    }
    /**
     * @private
     * @param {?=} ps
     * @return {?}
     */
    getRightFixedColWidth(ps = null) {
        if (!this.columnsGroup) {
            return 0;
        }
        /** @type {?} */
        let w = this.columnsGroup.rightFixedWidth;
        ps = this.dg.scrollInstance ? this.dg.scrollInstance.instance : null;
        if (ps && ps.scrollbarYActive && this.dg.scrollBarShowMode === 'allways') {
            return w += 18;
        }
        return w;
    }
    /**
     * @private
     * @param {?=} emit
     * @return {?}
     */
    setFooterPosition(emit = true) {
        if (this.position === 'bottom') {
            /** @type {?} */
            let positionBottom = 0;
            if (this.dg.pagination) {
                positionBottom = this.dg.pagerHeight || 40;
            }
            this.render.removeStyle(this.footerContainer.nativeElement, 'top');
            this.render.setStyle(this.footerContainer.nativeElement, 'bottom', `${positionBottom}px`);
        }
        if (this.position === 'top') {
            /** @type {?} */
            let positionTop = 0;
            if (this.dg.showHeader) {
                positionTop = this.dg.realHeaderHeight || 35;
            }
            if (this.dg.showRowGroupPanel) {
                positionTop += this.dg.rowGroupPanelHeight;
            }
            if (this.dg.showFilterBar) {
                positionTop += this.dg.filterBarHeight;
            }
            this.render.removeStyle(this.footerContainer.nativeElement, 'bottom');
            this.render.setStyle(this.footerContainer.nativeElement, 'top', `${positionTop}px`);
        }
        if (emit) {
            this.dgs.footerPositionChanged.emit();
        }
    }
    /**
     * @private
     * @return {?}
     */
    renderFooterStyle() {
        if (this.dg.footerStyler) {
            /** @type {?} */
            const trStyleAndCls = this.dgs.getCustomStyle(this.dg.footerStyler, null);
            /** @type {?} */
            const cssRuleID = `${this.dg.customStyleKey()} .f-datagrid-footer`;
            /** @type {?} */
            const cssRuleId2 = `${this.dg.customStyleKey()} .f-datagrid-footer .f-datagrid-body-fixed-left,${this.dg.customStyleKey()} .f-datagrid-footer .f-datagrid-body-fixed-right`;
            /** @type {?} */
            const cssRuleId3 = `${this.dg.customStyleKey()}.f-datagrid-fast .f-datagrid-cell.f-datagrid-fast__fixed-left,${this.dg.customStyleKey()}.f-datagrid-fast .f-datagrid-cell.f-datagrid-fast__fixed-right`;
            if (trStyleAndCls && Object.keys(trStyleAndCls).length) {
                /** @type {?} */
                const cssRule = [];
                if (trStyleAndCls.style) {
                    cssRule.push(`${cssRuleID} ${JSON.stringify(trStyleAndCls.style)}`);
                    cssRule.push(`${cssRuleId2} ${JSON.stringify(trStyleAndCls.style)}`);
                    if (this.fast) {
                        cssRule.push(`${cssRuleId3} ${JSON.stringify(trStyleAndCls.style)}`);
                    }
                }
                this.dgs.appendCssRules(cssRule);
                // this.dg.renderCustomStyle(trStyleAndCls, this.footerContainer.nativeElement, cssRule);
            }
            else {
                this.dgs.removeCssRule([cssRuleID, cssRuleId2]);
            }
        }
    }
    /**
     * @param {?} isShow
     * @param {?} scrollLeft
     * @return {?}
     */
    setFixedColumnPosition(isShow, scrollLeft) {
        this.showShadowCls = isShow;
        /** @type {?} */
        const method = isShow ? 'addClass' : 'removeClass';
        this.render[method](this.fixedRight.nativeElement, FIXED_RIGHT_SHADOW_CLS);
        /** @type {?} */
        const realWidth = this.columnsGroup.leftFixedWidth + this.columnsGroup.normalWidth + this.rightFixedColumnWidth;
        /** @type {?} */
        const gridWidth = this.dg.width;
        /** @type {?} */
        let l = this.dg.width - (this.dg.showBorder ? 2 : 0) - this.rightFixedColumnWidth;
        if (gridWidth > realWidth) {
            l = this.columnsGroup.leftFixedWidth + this.columnsGroup.normalWidth;
            // if (this.dg.showBorder) {
            //     l-= 2;
            // }
        }
        this.render.setStyle(this.fixedRight.nativeElement, 'left', l + 'px');
    }
}
DatagridFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-footer',
                template: "<!--\r\n * @Author: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @Date: 2019-08-12 15:02:10\r\n * @LastEditors: \u75AF\u72C2\u79C0\u624D(Lucas Huang)\r\n * @LastEditTime: 2019-10-31 14:50:47\r\n * @QQ: 1055818239\r\n * @Version: v0.0.1\r\n -->\r\n\r\n <ng-template #footer_content_template_fast let-columns let-left=\"fixedLeft\" let-right=\"fixedRight\">\r\n    <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"border:0;\" class=\"f-datagrid-rows\" [style.width.px]=\"columnsGroup?.normalWidth\" >\r\n        <colgroup>\r\n            <col [style.width.px]=\"dg.checkboxColumnWidth || 36\" *ngIf=\"dg.showCheckbox\"/>\r\n            <col [width]=\"dg.lineNumberWidth + 'px'\" *ngIf=\"dg.showLineNumber\"/>\r\n            <col *ngFor=\"let col of columns\" [width]=\"col.width + 'px'\"/>\r\n        </colgroup>\r\n        <tbody>\r\n            <tr #tr class=\"f-datagrid-body-row f-datagrid-footer-row\"\r\n                *ngFor=\"let row of data;let rowIndex = index;trackBy: dg.trackByRows\" \r\n                [attr.index]=\"rowIndex\">\r\n\r\n                <td *ngIf=\"dg.showCheckbox\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center; left: 0\"\r\n                [class.f-datagrid-fast__fixed-left]=\"dg.fast\" [class.l-shadow-col]=\"!dg.showLineNumber && !hasFixedColumns\"></td>\r\n                <td *ngIf=\"dg.showLineNumber\" class=\"f-datagrid-cell f-datagrid-cell-rownumber\" \r\n                [class.f-datagrid-fast__fixed-left]=\"dg.fast\"  [style.left.px]=\"dg.showCheckbox ? 36: 0\" [class.l-shadow-col]=\"!hasFixedColumns\"></td>\r\n\r\n                <td class=\"f-datagrid-cell {{ 'footer-td-'+ col.field }}\"\r\n                    [style.width.px]=\"col.width\"\r\n                    [attr.colspan]=\"col.footer?.colspan || 1\"\r\n                    [style.display]=\"col.footer?.visible === false ? 'none': ''\"\r\n                    [attr.field]=\"col.field\" [attr.align]=\"col.footer?.align || col.align\"\r\n                    *ngFor=\"let col of columns; let ci = index;\"\r\n                    footer-cell-styler [column]=\"col\" [rowData]=\"row\" [rowIndex]=\"rowIndex\"\r\n                    [class.f-datagrid-fast__fixed-left]=\" col.fixed && col.fixed === 'left'\"\r\n                    [class.f-datagrid-fast__fixed-right]=\" col.fixed && col.fixed === 'right'\"\r\n                    [class.r-shadow-col]=\"col.rightShadowCol\"\r\n                    [class.l-shadow-col]=\"col.leftShadowCol\">\r\n                    <div class=\"f-datagrid-cell-content\" style=\"width: 100%\">\r\n                        <span *ngIf=\"col.footer && col.footer.formatter\" [innerHtml]=\"col | formatCellData: row : false: true | safe: 'html'\"></span>\r\n                        <span *ngIf=\"!col.footer || !col.footer.formatter\">{{ col | formatCellData: row : false: true }}</span>\r\n                    </div>\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</ng-template>\r\n<ng-template #footer_content_template let-columns let-left=\"fixedLeft\" let-right=\"fixedRight\">\r\n    <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\" style=\"border:0;height: 100%;\" class=\"f-datagrid-rows\" [style.width.px]=\"right? columnsGroup?.rightFixedWidth: left? columnsGroup?.leftFixedWidth: columnsGroup?.normalWidth\">\r\n        <colgroup>\r\n            <col [style.width.px]=\"dg.checkboxColumnWidth || 36\" *ngIf=\"dg.showCheckbox && left\"/>\r\n            <col [width]=\"dg.lineNumberWidth + 'px'\" *ngIf=\"dg.showLineNumber && left\"/>\r\n            <col *ngFor=\"let col of columns\" [width]=\"col.width + 'px'\"/>\r\n        </colgroup>\r\n        <tbody>\r\n            <tr #tr class=\"f-datagrid-body-row f-datagrid-footer-row\"\r\n                *ngFor=\"let row of data;let rowIndex = index;trackBy: dg.trackByRows\" \r\n                [attr.index]=\"rowIndex\">\r\n\r\n                <td *ngIf=\"dg.showCheckbox && left\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center\"></td>\r\n                <td *ngIf=\"dg.showLineNumber  && left\" class=\"f-datagrid-cell f-datagrid-cell-rownumber\" ></td>\r\n\r\n                <td class=\"f-datagrid-cell {{ 'footer-td-'+ col.field }}\"\r\n                    [style.width.px]=\"col.width\"\r\n                    [attr.colspan]=\"col.footer?.colspan || 1\"\r\n                    [style.display]=\"col.footer?.visible === false ? 'none': ''\"\r\n                    [attr.field]=\"col.field\" [attr.align]=\"col.footer?.align || col.align\"\r\n                    *ngFor=\"let col of columns; let ci = index;\"\r\n                    footer-cell-styler [column]=\"col\" [rowData]=\"row\" [rowIndex]=\"rowIndex\">\r\n                    <div class=\"f-datagrid-cell-content\" style=\"width: 100%\">\r\n                        <span class=\"f-datagrid-footer-cell\" *ngIf=\"col.footer && col.footer.formatter\" [innerHtml]=\"col | formatCellData: row : false: true | safe: 'html'\"></span>\r\n                        <span class=\"f-datagrid-footer-cell\" *ngIf=\"!col.footer || !col.footer.formatter\">{{ col | formatCellData: row : false: true }}</span>\r\n                    </div>\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</ng-template>\r\n\r\n<div #footerContainer class=\"f-datagrid-footer\" [style.height.px]=\"height\" style=\"overflow: hidden;\"\r\n    [style.width.px]=\"dg.width\"\r\n    [class.f-datagrid-footer-top]=\"position === 'top'\" [class.f-datagrid-footer-bottom]=\"position === 'bottom'\"\r\n    component-template [ctx]=\"{ footerData: data }\" [cmpRef]=\"dg.footerComponentType\"\r\n    [style.border-radius]=\"position === 'top'? '0': '0 0 7px 7px'\">\r\n    <ng-container *ngIf=\"!dg.footerTemplate && !dg.footerComponentType\">\r\n        \r\n        <div #fixedLeft class=\"f-datagrid-body-fixed-left\" \r\n            [style.width.px]=\"columnsGroup?.leftFixedWidth\" style=\"height: 100%;\"\r\n            *ngIf=\"!fast && (columnsGroup?.leftFixed && columnsGroup?.leftFixed.length  || dg?.showLineNumber || dg?.showCheckbox) \">\r\n\r\n            <ng-container *ngTemplateOutlet=\"footer_content_template; context: {$implicit: columnsGroup?.leftFixed, fixedLeft: true}\"></ng-container>\r\n            \r\n        </div>\r\n\r\n        <div #fixedRight class=\"f-datagrid-body-fixed-right\" style=\"position: absolute;border: 0;height: 100%;\"\r\n            [style.width.px]=\"dg.showBorder?  rightFixedColumnWidth : rightFixedColumnWidth + 1\" \r\n            *ngIf=\"!fast && columnsGroup?.rightFixed && columnsGroup?.rightFixed.length\">\r\n\r\n            <ng-container *ngTemplateOutlet=\"footer_content_template; context: {$implicit: columnsGroup?.rightFixed, fixedRight: true}\"></ng-container>\r\n            \r\n        </div>\r\n\r\n        <div #footerBody class=\"f-datagrid-footer-rows\" style=\"position: absolute; height: 100%;\" *ngIf=\"!fast\"\r\n            [style.left.px]=\"columnsGroup?.leftFixedWidth\" [style.width.px]=\"columnsGroup?.normalWidth\" >\r\n            <ng-container *ngTemplateOutlet=\"footer_content_template; context: {$implicit: columnsGroup?.normalColumns}\"></ng-container>\r\n        </div>\r\n\r\n\r\n        <div #footerBody2 class=\"f-datagrid-footer-rows\" style=\"position: absolute;width: 100%\" *ngIf=\"fast\">\r\n            <ng-container *ngTemplateOutlet=\"footer_content_template_fast; context: {$implicit: columnsGroup?.columns}\"></ng-container>\r\n        </div>\r\n\r\n\r\n    </ng-container>\r\n\r\n\r\n    <ng-container *ngIf=\"dg.footerTemplate && !dg.footerComponentType\" [ngTemplateOutlet]=\"dg.footerTemplate\" [ngTemplateOutletContext]=\"{footerData: data }\" ></ng-container>\r\n    \r\n</div>"
            }] }
];
/** @nocollapse */
DatagridFooterComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: Injector },
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] }
];
DatagridFooterComponent.propDecorators = {
    data: [{ type: Input }],
    height: [{ type: Input }],
    width: [{ type: Input }],
    columns: [{ type: Input }],
    columnsGroup: [{ type: Input }],
    position: [{ type: Input }],
    hasFixedColumns: [{ type: Input }],
    fast: [{ type: Input }],
    footerContainer: [{ type: ViewChild, args: ['footerContainer',] }],
    footerBody: [{ type: ViewChild, args: ['footerBody',] }],
    footerBody2: [{ type: ViewChild, args: ['footerBody2',] }],
    fixedLeft: [{ type: ViewChild, args: ['fixedLeft',] }],
    fr: [{ type: ViewChild, args: ['fixedRight',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridPagerComponent {
    /**
     * @param {?} el
     * @param {?} cd
     * @param {?} inject
     */
    constructor(el, cd, inject) {
        this.el = el;
        this.cd = cd;
        this.inject = inject;
        this.pagerPos = 'right';
        this.id = 'farris-datagrid-pager';
        /**
         * 显示页码的数量
         */
        this.maxSize = 7;
        /**
         * 是否显示页码
         */
        this.directionLinks = true;
        this.autoHide = false;
        this.responsive = false;
        /**
         * 上页标签
         */
        this.previousLabel = '上页';
        /**
         * 下页标签
         */
        this.nextLabel = '下页';
        this.showPageList = false;
        this.showPageInfo = true;
        this.showPageNumber = true;
        this.locked = false;
        this.selectedData = [];
        this.viewMode = 'default';
        this.showSelectedList = false;
        this.showGotoInput = false;
        /**
         * 分页条自定义内容区模板
         */
        this.contentTemplate = null;
        this.data = null;
        this.pageChange = new EventEmitter();
        this.pageSizeChange = new EventEmitter();
        this.removeSelectedItem = new EventEmitter();
        this.clearSelectedItem = new EventEmitter();
        this.styles = { opacity: 1 };
        this.mouseInSelectedList = false;
        this.openSelectedList = false;
        this.selectionDataChange$ = null;
        this.overLayService = null;
        if (this.inject) {
            this.notifySer = this.inject.get(NotifyService, null);
        }
        this.overLayService = new OverLayHiddenService();
    }
    /**
     * @return {?}
     */
    get pagination() {
        return this.pager.paginationDirective;
    }
    /**
     * @return {?}
     */
    get pageSize() {
        return this.pagination.getPageSize();
    }
    /**
     * @return {?}
     */
    get total() {
        return this.pagination.getTotalItems();
    }
    /**
     * @return {?}
     */
    get outerHeight() {
        if (this.pc) {
            return this.pc.nativeElement.offsetHeight;
        }
        return 40;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.listenCheckDataChanged();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.lockedStyles();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.selectedData && !changes.selectedData.isFirstChange()) {
            if (!this.selectedData || !this.selectedData.length) {
                this.closeSelectedList();
            }
        }
        if (changes.showSelectedList && !changes.showSelectedList.isFirstChange()) {
            this.listenCheckDataChanged();
        }
        if (changes.locked && !changes.locked.isFirstChange()) {
            this.lockedStyles();
        }
    }
    /**
     * @private
     * @return {?}
     */
    listenCheckDataChanged() {
        if (this.showSelectedList) {
            /** @type {?} */
            const dg = this.inject.get(DatagridComponent, null);
            if (dg) {
                this.selectionDataChange$ = dg.checkedChange.subscribe((/**
                 * @param {?} data
                 * @return {?}
                 */
                (data) => {
                    this.selectedData = data;
                    if (!this.cd['destroyed']) {
                        this.cd.detectChanges();
                    }
                }));
                this['resized$'] = dg.resized.subscribe((/**
                 * @return {?}
                 */
                () => {
                    this.closeSelectedList();
                }));
            }
        }
        else {
            if (this.selectionDataChange$) {
                this.selectionDataChange$.unsubscribe();
                this.selectionDataChange$ = null;
            }
        }
    }
    /**
     * @param {?} pageIndex
     * @return {?}
     */
    onPageChange(pageIndex) {
        if (typeof pageIndex === 'object') {
            pageIndex = pageIndex.pageIndex || 1;
        }
        this.pageChange.emit(Number.parseInt(pageIndex, 10));
    }
    /**
     * @param {?} pageSize
     * @return {?}
     */
    onPageSizeChange(pageSize) {
        this.pageSizeChange.emit(Number.parseInt(pageSize, 10));
    }
    /**
     * @return {?}
     */
    lock() {
        this.locked = true;
        this.lockedStyles();
    }
    /**
     * @return {?}
     */
    unlock() {
        this.locked = false;
        this.lockedStyles();
    }
    /**
     * @private
     * @return {?}
     */
    lockedStyles() {
        this.styles = { opacity: this.locked ? 0.5 : 1 };
        this.cd.detectChanges();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMouseEnter($event) {
        $event.stopPropagation();
        if (this.locked) {
            return;
        }
        this.mouseInSelectedList = true;
        if (this.selectedData && this.selectedData.length) {
            this.openSelectedList = !this.openSelectedList;
        }
        else {
            this.openSelectedList = false;
        }
        /** @type {?} */
        let target = $event.target;
        if (!target.classList.contains('selected-list-badge')) {
            target = $event.target.closest('.selected-list-badge');
        }
        if (this.openSelectedList) {
            /** @type {?} */
            const selectedListContainer = this.el.nativeElement.querySelector('.pager-overlay-container');
            /** @type {?} */
            const isInModal = target.closest('.modal-dialog');
            let { top, left } = target.getBoundingClientRect();
            if (selectedListContainer) {
                if (isInModal) {
                    const { top: mtop, left: mleft } = isInModal.getBoundingClientRect();
                    top = top - mtop;
                    left = left - mleft;
                }
                selectedListContainer.style.top = `${top}px`;
                selectedListContainer.style.left = `${left - 10}px`;
            }
            this.overLayService.registerMouseEvent(this.selectItemPanel.nativeElement, (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (this.selectItemPanel.nativeElement.contains(e.target) || e.target.classList.contains('selected-list-badge') || e.target.closest('.selected-list-badge')) {
                    return;
                }
                this.closeSelectedList();
                this.overLayService.destory(this.selectItemPanel.nativeElement);
            }));
        }
    }
    /**
     * @return {?}
     */
    closeSelectedList() {
        this.openSelectedList = false;
        this.mouseInSelectedList = false;
        if (!this.cd['destroyed']) {
            this.cd.detectChanges();
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    onDelSelectedItem(id) {
        this.removeSelectedItem.emit(id);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClearSelected($event) {
        this.clearSelectedItem.emit();
        this.closeSelectedList();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onSelectListPanelClose($event) {
        this.closeSelectedList();
    }
}
DatagridPagerComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-pager',
                template: "<div class=\"f-datagrid-pager\" #pagerContainer [ngStyle]=\"styles\">\r\n    <pagination-controls #pager [id]=\"id\" [maxSize]=\"maxSize\"\r\n        [directionLinks]=\"directionLinks\"\r\n        [showPageList]=\"showPageList\"\r\n        [showPageInfo]=\"showPageInfo\"\r\n        [showPageNumber]=\"showPageNumber\"\r\n        [autoHide]=\"autoHide\" [responsive]=\"responsive\"\r\n        [previousLabel]=\"previousLabel\" [nextLabel]=\"nextLabel\"\r\n        [showGotoInput]=\"showGotoInput\"\r\n        (pageChange)=\"onPageChange($event)\"\r\n        (pageSizeChange)=\"onPageSizeChange($event)\"\r\n        [position]=\"pagerPos\"\r\n        [viewMode]=\"viewMode\" [showSelectedList]=\"showSelectedList\">\r\n\r\n        <div class=\"pager-overlay-container\" style=\"position:fixed;z-index: 999999;\" #selectItemPanel>\r\n            <pager-selected-list *ngIf=\"openSelectedList\"\r\n                [data]=\"selectedData | selectedItem: listItemFormatter\"\r\n                (close)=\"onSelectListPanelClose($event)\"\r\n                (remove)=\"onDelSelectedItem($event)\"\r\n                (clear)=\"onClearSelected($event)\"\r\n            ></pager-selected-list>\r\n        </div>\r\n\r\n        <div class=\"flex-fill pager-pos-right\" style=\"left: 0\" [style.position]=\"pagerPos==='center'? 'absolute':'relative'\">\r\n            <div class=\"d-flex flex-row\" style=\"align-items: center;\">\r\n                <span class=\"badge badge-pill badge-light mr-2 selected-list-badge\" *ngIf=\"showSelectedList\"\r\n                    style=\"cursor:pointer\" [attr.title]=\"'datagrid.selectionData.tooltip' | locale\"\r\n                    [class.badge-primary]=\"mouseInSelectedList\"\r\n                    [innerHTML]=\"'datagrid.selectionData.currentLenth' | locale | replaceX: selectedData.length\"\r\n                    (click)=\"onMouseEnter($event)\">\r\n                </span>\r\n\r\n                <div class=\"f-utils-fill mr-2 content-template\" *ngIf=\"contentTemplate && pagerPos === 'right'\">\r\n                    <ng-container [ngTemplateOutlet]=\"contentTemplate\" [ngTemplateOutletContext]=\"{ footerData: data }\"></ng-container>\r\n                </div>\r\n\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"flex-fill pager-pos-left\" *ngIf=\"pagerPos === 'left'\">\r\n            <div class=\"d-flex flex-row\" style=\"align-items: center;\">\r\n                \r\n                <div class=\"f-utils-fill mr-2 content-template\" *ngIf=\"contentTemplate\">\r\n                    <ng-container [ngTemplateOutlet]=\"contentTemplate\" [ngTemplateOutletContext]=\"{ footerData: data }\"></ng-container>\r\n                </div>\r\n\r\n            </div>\r\n        </div>\r\n\r\n    </pagination-controls>\r\n</div>"
            }] }
];
/** @nocollapse */
DatagridPagerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Injector, decorators: [{ type: Optional }] }
];
DatagridPagerComponent.propDecorators = {
    pagerPos: [{ type: Input }],
    id: [{ type: Input }],
    maxSize: [{ type: Input }],
    directionLinks: [{ type: Input }],
    autoHide: [{ type: Input }],
    responsive: [{ type: Input }],
    previousLabel: [{ type: Input }],
    nextLabel: [{ type: Input }],
    showPageList: [{ type: Input }],
    showPageInfo: [{ type: Input }],
    showPageNumber: [{ type: Input }],
    locked: [{ type: Input }],
    selectedData: [{ type: Input }],
    viewMode: [{ type: Input }],
    listItemFormatter: [{ type: Input }],
    showSelectedList: [{ type: Input }],
    showGotoInput: [{ type: Input }],
    contentTemplate: [{ type: Input }],
    data: [{ type: Input }],
    pageChange: [{ type: Output }],
    pageSizeChange: [{ type: Output }],
    removeSelectedItem: [{ type: Output }],
    clearSelectedItem: [{ type: Output }],
    pc: [{ type: ViewChild, args: ['pagerContainer',] }],
    pager: [{ type: ViewChild, args: ['pager',] }],
    selectItemPanel: [{ type: ViewChild, args: ['selectItemPanel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const loading_style_ring = `<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
  <circle cx="50" cy="50" fill="none" r="30" stroke="#2c7dff" stroke-width="10"></circle>
  <circle cx="50" cy="50" fill="none" r="30" stroke="#d0eaff" stroke-width="10" stroke-linecap="square" transform="rotate(178.821 50 50)">
      <animateTransform attributeName="transform" type="rotate"
          calcMode="linear" values="0 50 50;180 50 50;720 50 50" keyTimes="0;0.5;1" dur="1.6s" begin="0s"
          repeatCount="indefinite"></animateTransform>
      <animate attributeName="stroke-dasharray" calcMode="linear"
          values="9.42477796076938 179.0707812546182;150.79644737231007 37.6991118430775;9.42477796076938 179.0707812546182"
          keyTimes="0;0.5;1" dur="1.6" begin="0s" repeatCount="indefinite"></animate>
  </circle>
</svg>`;
class DataGridLoadingComponent {
    /**
     * @param {?} domSanitizer
     */
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.loading) {
            this.loading = this.domSanitizer.bypassSecurityTrustHtml(this.loading);
        }
        else {
            this.loading = this.domSanitizer.bypassSecurityTrustHtml(loading_style_ring);
        }
    }
}
DataGridLoadingComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-loading',
                template: `
    <div style="width:100%;height:100%;position:absolute;top:0;left: 0;background:rgba(255,255,255,0);z-index: 90000000;pointer-events: unset;">
        <div style="width: 50px;height: 50px;position: relative;top: 50%;margin-top: -25px;left: 50%;margin-left: -25px;"
        [innerHTML]="loading" >
        </div>
    </div>
    `
            }] }
];
/** @nocollapse */
DataGridLoadingComponent.ctorParameters = () => [
    { type: DomSanitizer }
];
DataGridLoadingComponent.propDecorators = {
    loading: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PagerSelectedListComponent {
    constructor() {
        this.data = [];
        this.close = new EventEmitter();
        this.remove = new EventEmitter();
        this.clear = new EventEmitter();
        this.trackByFn = (/**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        (index, item) => {
            return item.id;
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClose($event) {
        $event.stopPropagation();
        this.close.emit();
    }
    /**
     * @param {?} $event
     * @param {?} id
     * @return {?}
     */
    onRemoveClick($event, id) {
        $event.stopPropagation();
        this.remove.emit(id);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClearClick($event) {
        $event.stopPropagation();
        this.clear.emit();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClick($event) {
        $event.stopPropagation();
        return false;
    }
}
PagerSelectedListComponent.decorators = [
    { type: Component, args: [{
                selector: 'pager-selected-list',
                template: "\r\n<div class=\"f-cmp-pager-selected-list-wrapper \" style=\"bottom: 10px\">\r\n\t<div class=\"selected-list--content\" (click)=\"onClick($event)\">\r\n\t\t<div class=\"selected-list--arrow\"></div>\r\n\t\t<div class=\"selected-list--title\">\r\n            <div class=\"btn-group\">\r\n                <button class=\"btn btn-link\" (click)=\"onClearClick($event)\"> \r\n                    <i class=\"f-icon f-icon-remove\"></i>\r\n                    <span class=\"btn-text\">{{ 'datagrid.selectionData.clearAll' | locale: '\u6E05\u7A7A' }}</span>\r\n                </button>\r\n            </div>\r\n            <div class=\"selected-list--close\"><span class=\"f-icon f-icon-close\" (click)=\"onClose($event)\"></span></div>\r\n        </div> <div class=\"selected-list--main\">\r\n            <ul class=\"selected-list\">  <!-- selected-list--wrap -->\r\n                <li class=\"selected-list--item ng-star-inserted\" *ngFor=\"let item of data; trackBy: trackByFn\"  style=\"min-height: 35px;\" title=\"{{item.text}}\">\r\n\t\t\t\t\t<span class=\"f-icon f-icon-close-outline list-icon list-error\" (click)=\"onRemoveClick($event, item.id)\"></span>\r\n                    <div class=\"list-con\" [innerHTML]=\"item.text\"></div>\r\n                </li>\r\n                \r\n            </ul>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n"
            }] }
];
/** @nocollapse */
PagerSelectedListComponent.ctorParameters = () => [];
PagerSelectedListComponent.propDecorators = {
    data: [{ type: Input }],
    close: [{ type: Output }],
    remove: [{ type: Output }],
    clear: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectedItemPipe {
    /**
     * @param {?} data
     * @param {?} formatter
     * @return {?}
     */
    transform(data, formatter) {
        if (data) {
            if (formatter) {
                data = data.map((/**
                 * @param {?} d
                 * @return {?}
                 */
                d => {
                    return { id: d.id, text: formatter(d.data) };
                }));
            }
            else {
                data = data.map((/**
                 * @param {?} d
                 * @return {?}
                 */
                d => {
                    /** @type {?} */
                    const txt = [];
                    /** @type {?} */
                    const keys = Object.keys(d.data);
                    keys.forEach((/**
                     * @param {?} k
                     * @return {?}
                     */
                    k => {
                        txt.push(d.data[k]);
                    }));
                    return { id: d.id, text: txt.join(', ') };
                }));
            }
            return data;
        }
    }
}
SelectedItemPipe.decorators = [
    { type: Pipe, args: [{ name: 'selectedItem' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridErrorHandler {
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error(error);
    }
}
class ɵs {
    /**
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        console.error(error);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridCheckboxComponent {
    /**
     * @param {?} injector
     * @param {?} dg
     */
    constructor(injector, dg) {
        this.injector = injector;
        this.dg = dg;
        this.indeterminate = false;
        this.checked$ = null;
        this.destroy$ = new Subject();
        this.subscriptions = [];
        this.dfs = this.injector.get(DatagridFacadeService);
        this.cd = this.injector.get(ChangeDetectorRef);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.indeterminate) {
            this.chk.nativeElement.indeterminate = true;
        }
        this.listenSubjects();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.checked && !changes.checked.isFirstChange()) {
            this.changeCheckedStatus(changes.checked.currentValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        if (this.subscriptions && this.subscriptions.length) {
            this.subscriptions.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => n.unsubscribe()));
            this.subscriptions = [];
        }
    }
    /**
     * @private
     * @return {?}
     */
    listenSubjects() {
        /** @type {?} */
        const rid = this.dfs.primaryId(this.rowData);
        this.subscriptions.push(this.dg.checkAll.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            let flag = true;
            if (this.dg.disableRow) {
                flag = !this.dg.disableRow(this.rowData, this.rowIndex);
                if (!flag) {
                    flag = this.dg.dfs.isRowChecked(rid);
                }
            }
            this.changeCheckedStatus(flag);
        })));
        this.subscriptions.push(this.dg.unCheckAll.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (e && e.length) {
                if (e.find((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n[this.dg.idField] === this.rowData[this.dg.idField]))) {
                    this.changeCheckedStatus(false);
                }
            }
            else {
                this.changeCheckedStatus(false);
            }
        })));
        /** @type {?} */
        const _setcheckrows = this.dg.dgs.setCheckedRows.pipe(takeUntil(this.destroy$)).pipe(filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            return r.ids.includes(rid) || r.ids.includes('' + rid);
        })), map((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            /** @type {?} */
            const flag = r.ids.includes(rid) || r.ids.includes('' + rid);
            if (flag) {
                return flag && r.checked;
            }
            return false;
        }))).subscribe((/**
         * @param {?} r
         * @return {?}
         */
        r => {
            this.checked = r;
            this.changeCheckedStatus(r);
        }));
        this.subscriptions.push(_setcheckrows);
        this.dfs.updateCheckboxState$.pipe(takeUntil(this.destroy$)).pipe(filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            return r.id === rid;
        })), map((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            return !!r.checked;
        }))).subscribe((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            this.checked = r;
            this.changeCheckedStatus(r);
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleClick(event) {
        if (!this.disabled) {
            /** @type {?} */
            const beforEventParam = {
                rowIndex: this.rowIndex,
                rowData: this.rowData,
                gridInstance: this.dg
            };
            this.dg.endCellEdit();
            /** @type {?} */
            const _checked = this.chk.nativeElement.checked;
            if (!_checked) {
                this.dg.beforeCheck(beforEventParam).subscribe((/**
                 * @param {?} canCheck
                 * @return {?}
                 */
                (canCheck) => {
                    if (canCheck) {
                        this.dfs.checkRow(this.rowIndex, this.rowData, { instance: this.dg });
                        this.checked = true;
                        this.changeCheckedStatus(true);
                    }
                }));
            }
            else {
                this.dg.beforeUncheck(beforEventParam).subscribe((/**
                 * @param {?} canUncheck
                 * @return {?}
                 */
                (canUncheck) => {
                    if (canUncheck) {
                        this.dfs.unCheckRow(this.rowIndex, this.rowData, { instance: this.dg });
                        this.checked = false;
                        this.changeCheckedStatus(false);
                        if (this.dg.showSelectedList) {
                            this.dg.cd.detectChanges();
                        }
                    }
                }));
            }
            // this.checked = !this.checked;
            // this.cd.detectChanges();
        }
        event.stopPropagation();
    }
    /**
     * @private
     * @param {?} status
     * @return {?}
     */
    changeCheckedStatus(status) {
        this.chk.nativeElement.checked = status;
    }
}
DatagridCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-checkbox',
                template: ` <div class="custom-control custom-checkbox f-checkradio-single">
        <input type="checkbox" #chk class="custom-control-input" [disabled]="disabled" [checked]="checked">
        <label class="custom-control-label" (click)="handleClick($event)"></label>
    </div>`,
                styles: [`
        :host {
            vertical-align: middle;
        }
        :host .custom-checkbox {
            opacity: 1;
            float: none;
            top: 2px;
        }
        `]
            }] }
];
/** @nocollapse */
DatagridCheckboxComponent.ctorParameters = () => [
    { type: Injector },
    { type: DatagridComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => DatagridComponent)),] }] }
];
DatagridCheckboxComponent.propDecorators = {
    rowData: [{ type: Input }],
    rowIndex: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    indeterminate: [{ type: Input }],
    chk: [{ type: ViewChild, args: ['chk',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridHeaderCheckboxComponent {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
        this.indeterminate = false;
        this.destroy$ = new Subject();
        this.dfs = this.injector.get(DatagridFacadeService);
        this.dg = this.injector.get(DatagridComponent);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.indeterminate) {
            this.chk.nativeElement.indeterminate = true;
        }
        this.dg.dgs.changeCheckAllStatus.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @param {?} status
         * @return {?}
         */
        (status) => {
            if (status === 2) {
                this.chk.nativeElement.indeterminate = true;
            }
            else {
                this.chk.nativeElement.indeterminate = false;
                this.updateStatus(!!status);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @param {?} checked
     * @return {?}
     */
    updateStatus(checked) {
        this.checked = checked;
        this.chk.nativeElement.checked = checked;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleClick(event) {
        if (!this.dg.data || !this.dg.data.length) {
            return;
        }
        if (!this.disabled) {
            this.checked = !this.checked;
            this.indeterminate = false;
            this.chk.nativeElement.indeterminate = false;
            if (this.checked) {
                this.dfs.checkAll();
                this.chk.nativeElement.checked = true;
                // this.dg.checkAll.emit();
            }
            else {
                this.dfs.clearCheckeds(!this.dg.enableMorePageSelect);
                if (this.dg.selectedRow && this.dg.checkOnSelect && this.dg.selectOnCheck) {
                    this.dg.unSelectRow(this.dg.selectedRow.id);
                }
                this.chk.nativeElement.checked = false;
                // this.dg.unCheckAll.emit();
            }
        }
        event.stopPropagation();
    }
}
DatagridHeaderCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'datagrid-header-checkbox',
                template: ` <div class="custom-control custom-checkbox f-checkradio-single">
        <input type="checkbox" #chk class="custom-control-input" [disabled]="disabled" [checked]="checked">
        <label class="custom-control-label" (click)="handleClick($event)"></label>
    </div>`,
                styles: [`
        :host {
            vertical-align: middle;
        }
        :host .custom-checkbox {
            opacity: 1;
            float: none;
            top: 4px;
        }
        `]
            }] }
];
/** @nocollapse */
DatagridHeaderCheckboxComponent.ctorParameters = () => [
    { type: Injector }
];
DatagridHeaderCheckboxComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    indeterminate: [{ type: Input }],
    chk: [{ type: ViewChild, args: ['chk',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RowDataIdPipe {
    /**
     * @param {?} dfs
     */
    constructor(dfs) {
        this.dfs = dfs;
    }
    /**
     * @param {?} rowData
     * @param {?=} fixedRight
     * @param {?=} fixedLeft
     * @param {?=} isGroupRow
     * @return {?}
     */
    transform(rowData, fixedRight = false, fixedLeft = false, isGroupRow = false) {
        if (rowData) {
            /** @type {?} */
            let rowID = TR_PREFIX + this.dfs.primaryId(rowData);
            if (fixedRight) {
                rowID += '_fixedright';
            }
            else if (fixedLeft) {
                rowID += '_fixedleft';
            }
            if (isGroupRow) {
                rowID += '_grouprow';
            }
            return rowID;
        }
        return null;
    }
}
RowDataIdPipe.decorators = [
    { type: Pipe, args: [{ name: 'rowDataId' },] }
];
/** @nocollapse */
RowDataIdPipe.ctorParameters = () => [
    { type: DatagridFacadeService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormatGroupRowPipe {
    /**
     * @param {?} dfs
     */
    constructor(dfs) {
        this.dfs = dfs;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @param {?=} fn
     * @return {?}
     */
    transform(row, col, fn) {
        if (row) {
            /** @type {?} */
            let val = row['value'];
            if (!col && this.dfs) {
                col = this.dfs.getColumn(row.field);
            }
            if (col && col.formatter) {
                if (col.formatter.type === 'enum') {
                    /** @type {?} */
                    const enumOpts = col.formatter.options;
                    const { valueField, textField, data } = Object.assign({}, enumOpts);
                    /** @type {?} */
                    const enumItem = data.find((/**
                     * @param {?} item
                     * @return {?}
                     */
                    item => item[valueField] === row['value']));
                    val = enumItem ? enumItem[textField] : '';
                }
            }
            return fn ? fn(row) : val;
        }
        return '';
    }
}
FormatGroupRowPipe.decorators = [
    { type: Pipe, args: [{ name: 'formatGroupRow' },] }
];
/** @nocollapse */
FormatGroupRowPipe.ctorParameters = () => [
    { type: DatagridFacadeService, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FixedLeftRowsComponent {
    /**
     * @param {?} cd
     * @param {?} dg
     * @param {?} dgb
     * @param {?} dfs
     * @param {?} el
     * @param {?} injector
     * @param {?} ngZone
     */
    constructor(cd, dg, dgb, dfs, el, injector, ngZone) {
        this.cd = cd;
        this.dg = dg;
        this.dgb = dgb;
        this.dfs = dfs;
        this.el = el;
        this.injector = injector;
        this.ngZone = ngZone;
        this.columns = [];
        this.toggle = new EventEmitter();
        this.checkedRows = [];
        this.selectedRows = [];
        this.data = [];
        /**
         * 启用分组时，数据源中自动设置行索引字段
         */
        this.groupRowIndex = ROW_INDEX_FIELD;
        this.isGroupRow = IS_GROUP_ROW_FIELD;
        this.groupRow = GROUP_ROW_FIELD;
        this.isGroupFooter = IS_GROUP_FOOTER_ROW_FIELD;
        this.visible = GROUP_VISIBLE_FIELD;
        this.groupLevelField = GROUP_LEVEL_FIELD;
        this.filterConditions = '';
        this.subscriptions = [];
        this.dgs = null;
        this.destroy$ = new Subject();
        this.dgs = this.injector.get(DatagridService);
        this.render2 = this.injector.get(Renderer2);
    }
    /**
     * @private
     * @return {?}
     */
    listenSubject() {
        // const _selectrow = this.dfs.selectRow$.subscribe(() => {
        //     this.detectChanges();
        // });
        // this.subscriptions.push(_selectrow);
        // const _selectrow = this.dfs.selectRow$.subscribe(() => {
        //     this.detectChanges();
        // });
        // this.subscriptions.push(_selectrow);
        // const _unselectrow = this.dfs.unSelectRow$.subscribe(() => {
        //     this.detectChanges();
        // });
        // this.subscriptions.push(_unselectrow);
        /** @type {?} */
        const _setselectrow = this.dgs.setSelecedRow.pipe(takeUntil(this.destroy$))
            .subscribe((/**
         * @param {?} r
         * @return {?}
         */
        (r) => {
            this.detectChanges();
        }));
        this.subscriptions.push(_setselectrow);
        this.dfs.checkRow$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.checkedRows = this.dfs.getCheckeds();
            this.detectChanges();
        }));
        this.dfs.clearCheckeds$.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.checkedRows = this.dfs.getCheckeds();
            this.detectChanges();
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.listenSubject();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        if (this.subscriptions && this.subscriptions.length) {
            this.subscriptions.forEach((/**
             * @param {?} n
             * @return {?}
             */
            n => n.unsubscribe()));
            this.subscriptions = [];
        }
    }
    /**
     * @private
     * @return {?}
     */
    detectChanges() {
        if (!this.cd['destroyed']) {
            // this.cd.markForCheck();
            this.cd.detectChanges();
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @param {?} open
     * @param {?=} $event
     * @return {?}
     */
    toggleGroupRow(row, index, open, $event) {
        if ($event) {
            $event.stopPropagation();
        }
        row.expanded = open;
        this.dg.dfs.setGroupRowsVisible(row, open);
    }
    /**
     * @param {?} groupId
     * @return {?}
     */
    getGroupSummaryData(groupId) {
        /** @type {?} */
        const _data = this.dg.getRows();
        if (_data && _data.length) {
            /** @type {?} */
            const row = this.dg.getRows().find((/**
             * @param {?} n
             * @return {?}
             */
            n => n['__group_parent_id__'] === groupId && n['__group_footer__']));
            if (row) {
                return row.data;
            }
        }
        return null;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    getGroupColumn(field) {
        return this.dg.flatColumns.find((/**
         * @param {?} col
         * @return {?}
         */
        col => col.field === field));
    }
}
FixedLeftRowsComponent.decorators = [
    { type: Component, args: [{
                selector: 'fixed-left-rows',
                template: "\r\n<ng-template #groupActionCell>\r\n    <td *ngIf=\"dg.showLineNumber || dg.showCheckbox\" class=\"f-datagrid-cell f-datagrid-group-action\"></td>\r\n</ng-template>\r\n\r\n<ng-template #grouprowControl let-ctx>\r\n    <div class=\"d-flex flex-row\" style=\"align-items: center; white-space: nowrap;\">\r\n        <span class=\"f-icon f-datagrid-group-expanded ml-1 mr-1\" *ngIf=\"!ctx.row.expanded\" (click)=\"toggleGroupRow(ctx.row, ctx.index, true, $event)\"></span>\r\n        <span class=\"f-icon f-datagrid-group-collapsed ml-1 mr-1\" *ngIf=\"ctx.row.expanded\" (click)=\"toggleGroupRow(ctx.row, ctx.index, false, $event)\"></span>\r\n        <span class=\"f-utils-fill group-row-text\" *ngIf=\"dg.groupFormatter\" [innerHTML]=\"ctx.row | formatGroupRow: '': dg.groupFormatter| safe: 'html' \"></span>\r\n        <span class=\"f-utils-fill  group-row-text\" *ngIf=\"!dg.groupFormatter\"> {{ ctx.row | formatGroupRow: getGroupColumn(ctx.row.field)  }} </span>\r\n    </div>\r\n</ng-template>\r\n\r\n\r\n<table class=\"f-datagrid-rows\" style=\"width: 100%\" cellpadding=\"0\" cellspacing=\"0\" row-hover row-dblclick>\r\n    <colgroup>\r\n        <col [style.width.px]=\"dg.checkboxColumnWidth || 36\" *ngIf=\"dg.showCheckbox\" />\r\n        <col [style.width.px]=\"dg.lineNumberWidth\" *ngIf=\"dg.showLineNumber\" />\r\n        <col *ngFor=\"let col of columns\" [style.width.px]=\"col.width\" />\r\n    </colgroup>\r\n\r\n\r\n    <tbody *ngIf=\"dg.groupRows && dg.groupField\">\r\n        <ng-container *ngFor=\"let row of data; trackBy: dg.trackByRows; let i = index\">\r\n            <tr *ngIf=\"row[isGroupRow]\" [style.display]=\"row[visible] ? '': 'none'\" [group-row]=\"row\" \r\n            [attr.id]=\"row | rowDataId: false: true \" class=\"f-datagrid-body-row fixed-left-row f-datagrid-group-row\" [attr.index]=\"dgb.startRowIndex + i\">\r\n\r\n                <!-- <ng-container *ngIf=\"dg.showLineNumber && dg.showCheckbox; else groupActionCell\">\r\n                    <td class=\"f-datagrid-cell f-datagrid-cell-checkbox\"></td>\r\n                    <td class=\"f-datagrid-cell f-datagrid-cell-rownumber\"></td>\r\n                    </ng-container>\r\n                    <td [cell-editable]=\"row\" [column]=\"col\" [attr.field]=\"col.field\" class=\"f-datagrid-cell\" [attr.align]=\"col.align\" *ngFor=\"let col of columns; let ci = index;\">\r\n                        <grid-body-cell [width]=\"col.width\" [height]=\"dg.rowHeight\" [column]=\"col\" [rowData]=\"row\" [rowIndex]=\"dgb.startRowIndex + i\"></grid-body-cell>\r\n                    </td> \r\n                -->\r\n                <td class=\"f-datagrid-cell f-datagrid-cell-checkbox\" *ngIf=\"dg.showCheckbox\"></td>\r\n                <td class=\"f-datagrid-cell f-datagrid-cell-rownumber\" *ngIf=\"dg.showLineNumber\"></td>\r\n\r\n                <td *ngIf=\"!(dg.groupSummaryPosition === 'inGroupRow')\" class=\"f-datagrid-cell\" [attr.colspan]=\"columns.length\" [style.paddingLeft.px]=\"row[groupLevelField] * 15\">\r\n\r\n                    <ng-container [ngTemplateOutlet]=\"grouprowControl\" [ngTemplateOutletContext]=\"{$implicit: { row: row, index: i }}\"></ng-container>\r\n                    \r\n                </td>\r\n\r\n                <ng-container *ngIf=\"dg.groupSummaryPosition === 'inGroupRow'\">\r\n\r\n                    <ng-container *ngFor=\"let col of columns; let ci = index;\">\r\n                        <td *ngIf=\"ci === 0\" class=\"f-datagrid-cell\" [style.paddingLeft.px]=\"row[groupLevelField] * 15\" [attr.colspan]=\"dg.groupCellColSpan\">\r\n\r\n                            <ng-container [ngTemplateOutlet]=\"grouprowControl\" [ngTemplateOutletContext]=\"{$implicit: { row: row, index: i }}\"></ng-container>\r\n\r\n                        </td>\r\n                             \r\n                        <td class=\"f-datagrid-cell\"  \r\n                            *ngIf=\"ci > 0 && ci >= dg.groupCellColSpan\"\r\n                            [attr.field]=\"col.field\" \r\n                            [attr.align]=\" col.groupFooter?.align || col.align\">\r\n                            <div class=\"f-datagrid-cell-content\" [innerHTML]=\"col | formatCellData: getGroupSummaryData(row.id) : true: false | safe: 'html'\"></div>\r\n                        </td>\r\n                    </ng-container>\r\n                </ng-container>\r\n            </tr>\r\n\r\n            <ng-container *ngIf=\"!row[isGroupRow]\">\r\n\r\n                <ng-container *ngIf=\"row[isGroupFooter] && dg.groupSummaryPosition === 'groupFooterRow'\">\r\n                    <tr class=\"f-datagrid-body-row fixed-left-row f-datagrid-group-footer\" [group-footer-row-styler]=\"row\"\r\n                        [attr.index]=\"dgb.startRowIndex + i\" [style.display]=\"row[visible] ? '': 'none'\">\r\n                        <td *ngIf=\"dg.showCheckbox\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\"></td>\r\n                        <td *ngIf=\"dg.showLineNumber\" class=\"f-datagrid-cell f-datagrid-cell-rownumber\"></td>\r\n                        \r\n                        <td class=\"f-datagrid-cell\"\r\n                            [attr.field]=\"col.field\" \r\n                            [attr.colspan]=\"col.groupFooter?.colspan || 1\"\r\n                            [attr.align]=\" col.groupFooter?.align || col.align\"\r\n                            [style.display]=\"col.groupFooter?.visible === false ? 'none': ''\"\r\n                            footer-cell-styler [column]=\"col\" [rowData]=\"row\" [isGroupFooter]=\"true\"\r\n                            *ngFor=\"let col of columns; let ci = index;\"\r\n                            [style.paddingLeft.px]=\"(ci === 0 ) ? row[groupLevelField] * 10 + 25 : 0\">\r\n                            <div class=\"f-datagrid-cell-content\" [innerHTML]=\"col | formatCellData: row.data : true: false | safe: 'html'\"></div>\r\n                        </td>\r\n                    </tr>\r\n                </ng-container>\r\n                <ng-container *ngIf=\"!row[isGroupFooter]\">\r\n                    <tr class=\"f-datagrid-body-row fixed-left-row\" [attr.index]=\"dgb.startRowIndex + i\"\r\n                        [class.f-datagrid-row-selected]=\"row | rowIsSelected: selectedRows\" [grid-row]=\"row\"\r\n                        [rowIndex]=\"dgb.startRowIndex + i\" [attr.id]=\"row | rowDataId: false: true \"\r\n                        [class.f-datagrid-disable-row]=\"row | disableRow: (dgb.startRowIndex + i) : dg.disableRow\"\r\n                        [style.display]=\"row[visible] ? '': 'none'\">\r\n\r\n                        <td *ngIf=\"dg.showCheckbox\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center\">\r\n                            <div class=\"f-datagrid-cell-content checkbox-column\"  style=\"text-overflow: unset;\">\r\n                                <datagrid-checkbox [disabled]=\"row | disableRow: dgb.startRowIndex + i: dg.disableRow\"\r\n                                    [rowData]=\"row\" [rowIndex]=\"dgb.startRowIndex + i\" [checked]=\"row | rowIsChecked: checkedRows\"></datagrid-checkbox>\r\n                            </div>\r\n                        </td>\r\n\r\n                        <td *ngIf=\"dg.showLineNumber\" class=\"f-datagrid-cell f-datagrid-cell-rownumber\">\r\n                            <div class=\"f-datagrid-cell-content\" *ngIf=\"dg.virtualized\">\r\n                                {{ dg.pageSize * (dg.pageIndex-1) + row[groupRowIndex] + 1 }}\r\n                            </div>\r\n                            <div class=\"f-datagrid-cell-content\" *ngIf=\"!dg.virtualized\">\r\n                                {{ dg.pageSize * (dg.pageIndex-1) + dgb.startRowIndex + row[groupRowIndex] + 1 }}\r\n                            </div>\r\n                        </td>\r\n                        <td [cell-editable]=\"row\" [column]=\"col\" [attr.field]=\"col.field\" class=\"f-datagrid-cell\"\r\n                            [attr.align]=\"col.align\" *ngFor=\"let col of columns; let ci = index;\"\r\n                            [style.paddingLeft.px]=\"(ci === 0 ) ? row[groupLevelField] * 10 + 25 : 0\">\r\n                            <grid-body-cell [width]=\"col.width\" [height]=\"dg.rowHeight\" [column]=\"col\" [rowData]=\"row\"\r\n                                [rowIndex]=\"dgb.startRowIndex + i\"></grid-body-cell>\r\n                        </td>\r\n                    </tr>\r\n\r\n                </ng-container>\r\n\r\n            </ng-container>\r\n\r\n        </ng-container>\r\n\r\n    </tbody>\r\n\r\n\r\n    <tbody *ngIf=\"!dg.groupRows || !dg.groupField\">\r\n        <tr class=\"f-datagrid-body-row fixed-left-row\" [attr.index]=\"dgb.startRowIndex + i\"\r\n            [class.f-datagrid-row-selected]=\"row | rowIsSelected\" [grid-row]=\"row\" \r\n            [rowIndex]=\"dgb.startRowIndex + i\" [attr.id]=\"row | rowDataId: false: true \"\r\n            [class.f-datagrid-disable-row]=\"row | disableRow: (dgb.startRowIndex + i) : dg.disableRow\"\r\n            *ngFor=\"let row of data; trackBy: dg.trackByRows; let i = index\"\r\n        >\r\n            <td *ngIf=\"dg.showCheckbox\" class=\"f-datagrid-cell f-datagrid-cell-checkbox\" style=\"text-align: center\">\r\n                <div class=\"f-datagrid-cell-content checkbox-column\" style=\"text-overflow: unset;\">\r\n                <datagrid-checkbox [disabled]=\"row | disableRow: dgb.startRowIndex + i: dg.disableRow\" [rowData]=\"row\"\r\n                    [rowIndex]=\"dgb.startRowIndex + i\" [checked]=\"row | rowIsChecked: checkedRows\"></datagrid-checkbox>\r\n                </div>\r\n            </td>\r\n\r\n            <td *ngIf=\"dg.showLineNumber\" [style.width.px]=\"dg.lineNumberWidth\"  class=\"f-datagrid-cell f-datagrid-cell-rownumber\">\r\n                <div class=\"f-datagrid-cell-content\">\r\n                    {{ dg.pageSize * (dg.pageIndex-1) + dgb.startRowIndex + i + 1 }}\r\n                </div>\r\n            </td>\r\n\r\n            <td [cell-editable]=\"row\" [column]=\"col\" [attr.field]=\"col.field\" class=\"f-datagrid-cell\"\r\n                [attr.align]=\"col.align\" *ngFor=\"let col of columns; let ci = index;\">\r\n                <grid-body-cell [width]=\"col.width\" [height]=\"dg.rowHeight\" [column]=\"col\" [rowData]=\"row\"\r\n                    [rowIndex]=\"dgb.startRowIndex + i\"></grid-body-cell>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n\r\n\r\n\r\n\r\n</table>"
            }] }
];
/** @nocollapse */
FixedLeftRowsComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DatagridComponent },
    { type: DatagridBodyComponent },
    { type: DatagridFacadeService },
    { type: ElementRef },
    { type: Injector },
    { type: NgZone }
];
FixedLeftRowsComponent.propDecorators = {
    columns: [{ type: Input }],
    toggle: [{ type: Output }],
    checkedRows: [{ type: Input }],
    selectedRows: [{ type: Input }],
    data: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 使用说明
 * let message = "今天天气 {0}，处处好 {1}。"
 * template:
 * <h1>{{ message| replaceX: '晴朗', '风光' }}</h1>
 * resule:
 * <h1>今天天气 晴朗，处处好 风光。</h1>
 */
class ReplaceXPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        args.forEach((/**
         * @param {?} v
         * @param {?} i
         * @return {?}
         */
        (v, i) => {
            value = value.replace(`{${i}}`, v);
        }));
        return value;
    }
}
ReplaceXPipe.decorators = [
    { type: Pipe, args: [{ name: 'replaceX' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridGroupRowDirective {
    /**
     * @param {?} injector
     * @param {?} render
     * @param {?} el
     * @param {?} dg
     */
    constructor(injector, render, el, dg) {
        this.injector = injector;
        this.render = render;
        this.el = el;
        this.dg = dg;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.dg && this.dg.groupStyler) {
                /** @type {?} */
                const tr = this.el.nativeElement;
                /** @type {?} */
                const _cls = Array.from(tr.classList).find((/**
                 * @param {?} n
                 * @return {?}
                 */
                (n) => n.indexOf(CUSTOM_GROUP_ROW_CLS) > -1));
                if (_cls) {
                    tr.classList.remove(_cls);
                }
                /** @type {?} */
                const styler = this.dg.groupStyler(this.groupRow);
                if (!styler) {
                    return;
                }
                if (!tr.id) {
                    tr.id = 'group-tr_' + this.groupRow.id;
                }
                /** @type {?} */
                const str = CUSTOM_GROUP_ROW_CLS + this.dg.idService.encrypt(JSON.stringify(styler));
                this.render.addClass(tr, str);
                this.dg.renderCustomStyle2(styler, tr, str);
                // this.dg.renderCustomStyle(styler, tr);
            }
        }));
    }
}
DatagridGroupRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[group-row]',
            },] }
];
/** @nocollapse */
DatagridGroupRowDirective.ctorParameters = () => [
    { type: Injector },
    { type: Renderer2 },
    { type: ElementRef },
    { type: DatagridComponent }
];
DatagridGroupRowDirective.propDecorators = {
    groupRow: [{ type: Input, args: ['group-row',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShowRequiredStarPipe {
    /**
     * @param {?} validators
     * @return {?}
     */
    transform(validators) {
        if (validators && validators.length) {
            /** @type {?} */
            const isRequired = validators.find((/**
             * @param {?} v
             * @return {?}
             */
            v => v.type === 'required'));
            return isRequired;
        }
        return false;
    }
}
ShowRequiredStarPipe.decorators = [
    { type: Pipe, args: [{ name: 'showStar' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DisableRowPipe {
    /**
     * @param {?} rowData
     * @param {?} rowIndex
     * @param {?} disableRowFn
     * @return {?}
     */
    transform(rowData, rowIndex, disableRowFn) {
        if (disableRowFn) {
            return disableRowFn(rowData, rowIndex);
        }
        return false;
    }
}
DisableRowPipe.decorators = [
    { type: Pipe, args: [{ name: 'disableRow' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SelectedRowPipe {
    /**
     * @param {?} dfs
     */
    constructor(dfs) {
        this.dfs = dfs;
    }
    /**
     * @param {?} rowId
     * @return {?}
     */
    transform(rowId) {
        return this.dfs.isRowSelected(rowId);
    }
}
SelectedRowPipe.decorators = [
    { type: Pipe, args: [{ name: 'selectedRow' },] }
];
/** @nocollapse */
SelectedRowPipe.ctorParameters = () => [
    { type: DatagridFacadeService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FieldValuePipe {
    /**
     * @param {?} field
     * @param {?} rowdata
     * @param {?=} safe
     * @return {?}
     */
    transform(field, rowdata, safe = false) {
        return Utils.getValue(field, rowdata, safe);
    }
}
FieldValuePipe.decorators = [
    { type: Pipe, args: [{ name: 'fieldvalue' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridCellTooltipDirective {
    /**
     * @param {?} el
     * @param {?} injector
     */
    constructor(el, injector) {
        this.el = el;
        this.injector = injector;
        this.position = 'top-left';
        this.delay = 1000;
        this.cls = '';
        this.type = 'info';
        this.tipMode = 'auto';
        this.showTipTimer = null;
        this._mouseenter = null;
        this._mouseleave = null;
        this._mouseclick = null;
        this.ngZone = null;
        this.render = null;
        if (this.injector) {
            this.commonUtils = this.injector.get(CommonUtils, new CommonUtils());
            this.ngZone = this.injector.get(NgZone);
            this.render = this.injector.get(Renderer2);
            this.dg = this.injector.get(DatagridComponent);
        }
        else {
            this.commonUtils = new CommonUtils();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.ngZone && this.enable) {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this._mouseenter = Utils.on(this.el.nativeElement, 'mouseenter', this.onMouseEnter.bind(this), { target: '.f-datagrid-cell-content', options: { capture: true } });
                this._mouseleave = Utils.on(this.el.nativeElement, 'mouseleave', this.onMouseLeave.bind(this), { target: '.f-datagrid-cell-content', options: { capture: true } });
                this._mouseclick = Utils.on(this.el.nativeElement, 'mousedown', this.onClick.bind(this));
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.hide();
        if (this._mouseenter) {
            this._mouseenter();
        }
        if (this._mouseleave) {
            this._mouseleave();
        }
        if (this._mouseclick) {
            this._mouseclick();
        }
        // this.dg = null;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMouseEnter($event) {
        if (!this.enable) {
            return;
        }
        if ($event.fromElement) {
            if (!$event.fromElement.closest('.f-datagrid')) {
                return;
            }
        }
        /** @type {?} */
        const cellTiptimer = this.dg ? this.dg.cellTipTimer : 1000;
        if (this.showTipTimer) {
            clearTimeout(this.showTipTimer);
            this.showTipTimer = null;
        }
        this.showTipTimer = setTimeout((/**
         * @return {?}
         */
        () => {
            this.show($event);
        }), cellTiptimer);
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        this.hide();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        // e.stopPropagation();
        this.hide();
    }
    /**
     * @private
     * @return {?}
     */
    getTextContainer() {
        return DomHandler.findSingle(this.container, '.f-tooltip-text');
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    donotShowTips(target) {
        /** @type {?} */
        const tdWidth = target.offsetWidth;
        /** @type {?} */
        const tagetSty = window.getComputedStyle(target);
        /** @type {?} */
        const txtWidth = this.commonUtils.getTextWidth(this.message, tagetSty.font);
        const { paddingLeft, paddingRight } = tagetSty;
        /** @type {?} */
        const _width = tdWidth - (Number(paddingLeft.replace('px', '')) || 0) - (Number(paddingRight.replace('px', '')) || 0);
        /** @type {?} */
        let tr = target.closest('tr');
        if (tr) {
            /** @type {?} */
            const trId = tr.id;
            // tr = document.querySelector('#'+ trId);
            tr = Utils.getTrDomById(trId, document);
        }
        if (this.tipMode === 'auto') {
            if (tr) {
                return _width && _width > txtWidth;
            }
            return true;
        }
        else {
            return tr ? false : true;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        if (!this.enable) {
            return;
        }
        if (this.showTipTimer) {
            clearTimeout(this.showTipTimer);
            this.showTipTimer = null;
        }
        if (this.container && this.container.parentElement) {
            document.body.removeChild(this.container);
        }
        this.container = null;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    show($event) {
        /** @type {?} */
        const cellEl = (/** @type {?} */ ($event.target));
        // this.enable = cellEl.getAttribute('cell-tooltip') === 'true';
        this.message = cellEl.getAttribute('message');
        this.tipMode = cellEl.getAttribute('tipMode') || 'auto';
        if (!this.enable || !this.message) {
            return;
        }
        /** @type {?} */
        const tipWidth = cellEl.getAttribute('tipWidth');
        /** @type {?} */
        const tipHeight = cellEl.getAttribute('tipHeight');
        this.position = cellEl.getAttribute('position') || 'top-left';
        // 检查下内容宽度是否超出列宽
        if (this.donotShowTips($event.target) && cellEl.innerText === this.message) {
            return;
        }
        // const boxEl = this.el.nativeElement;
        /** @type {?} */
        const boxEl = $event.target;
        /** @type {?} */
        const elSize = this.getBoxSizeObj(boxEl);
        /** 如果存在则不新建，只需要修改里面的内容 */
        if (!this.container) {
            this.create(elSize);
        }
        else {
            DomHandler.findSingle(this.container, '.f-tooltip-text').innerHTML = this.message;
        }
        this.container.style.maxWidth = `${window.innerWidth - 30}px`;
        this.container.style.minWidth = '35px';
        if (tipWidth) {
            this.container.style.width = tipWidth;
        }
        if (tipHeight) {
            this.container.style.height = tipHeight;
        }
        /** @type {?} */
        const offset = DomHandler.getOffset(boxEl);
        /** @type {?} */
        const targetTop = offset.top;
        /** @type {?} */
        const targetLeft = offset.left;
        /** @type {?} */
        let left;
        /** @type {?} */
        let top;
        this.container.style.display = 'block';
        this.changeTooltipPosition(boxEl);
        /** @type {?} */
        const arrow = DomHandler.findSingle(this.container, '.f-tooltip-arrow');
        /** @type {?} */
        const tooltipSize = this.getTooltipSize();
        // 检查内容高度
        if (window.innerHeight - 10 < tooltipSize.height) {
            this.container.style.height = `${window.innerHeight - 20}px`;
            tooltipSize.height = window.innerHeight - 25;
            /** @type {?} */
            const textContainer = this.getTextContainer();
            textContainer.style.height = `${tooltipSize.height}px`;
            textContainer.style.overflow = 'hidden';
        }
        /** @type {?} */
        const n = this.updateArrowPosition(arrow, offset, $event);
        switch (this.position) {
            case 'right':
                left = targetLeft + elSize.width;
                top = n;
                break;
            case 'left':
                left = targetLeft - tooltipSize.width;
                top = n;
                break;
            case 'top-left':
                top = targetTop - tooltipSize.height - 7;
                left = n;
                break;
        }
        if (left) {
            this.container.style.left = left + 'px';
        }
        this.container.style.top = top + 'px';
        this.container.style.zIndex = 999999;
    }
    /**
     * @private
     * @param {?} arrow
     * @param {?} elOffset
     * @param {?} $event
     * @return {?}
     */
    updateArrowPosition(arrow, elOffset, $event) {
        /** @type {?} */
        const tooltipSize = this.getTooltipSize();
        if (this.position === 'left' || this.position === 'right') {
            /** @type {?} */
            const targetTop = elOffset.top;
            /** @type {?} */
            const halfHeight = tooltipSize.height / 2;
            /** @type {?} */
            let top = 10;
            if (targetTop > halfHeight && window.innerHeight - targetTop > halfHeight) {
                top = targetTop - tooltipSize.height / 2;
            }
            // 调整箭头的位置
            if (arrow) {
                arrow.style.top = `${targetTop - top}px`;
            }
            return top;
        }
        else if (this.position === 'top-left') {
            /** @type {?} */
            let left = $event.pageX - tooltipSize.width / 2;
            if (left < 10) {
                left = elOffset.left;
            }
            if (left + tooltipSize.width > window.innerWidth) {
                left = window.innerWidth - tooltipSize.width - 20;
            }
            // 调整箭头的位置
            if (arrow) {
                if ($event.pageX - left > 28) {
                    if ($event.pageX - left + 28 > tooltipSize.width) {
                        arrow.style.left = `${tooltipSize.width - 28}px`;
                    }
                    else {
                        arrow.style.left = `${$event.pageX - left}px`;
                    }
                }
            }
            return left;
        }
    }
    /**
     * @param {?} elSize
     * @return {?}
     */
    create(elSize) {
        /** @type {?} */
        let styleClass = this.tooltipCls();
        this.container = document.createElement('div');
        if (this.tooltipStyleClass) {
            styleClass += ' ' + this.tooltipStyleClass;
        }
        this.container.className = styleClass;
        /** @type {?} */
        const tooltipArrow = document.createElement('div');
        tooltipArrow.className = 'f-tooltip-arrow ';
        this.container.appendChild(tooltipArrow);
        /** @type {?} */
        const tooltipText = document.createElement('div');
        tooltipText.className = 'f-tooltip-text ';
        tooltipText.innerHTML = this.message;
        /** @type {?} */
        const maxWidth = window.innerWidth - 50;
        tooltipText.style.maxWidth = `${maxWidth}px`;
        tooltipText.style.wordBreak = 'break-all';
        this.container.style.textAlign = 'center';
        if (this.positionStyle) {
            this.container.style.position = this.positionStyle;
        }
        this.container.appendChild(tooltipText);
        document.body.appendChild(this.container);
    }
    /**
     * @private
     * @return {?}
     */
    tooltipCls() {
        return 'datagrid-cell-tooltip f-tooltip ' + this.getThemeCls() + ' f-tooltip-' + this.position + ' ' + this.cls;
    }
    /**
     * @private
     * @return {?}
     */
    getThemeCls() {
        if (this.type) {
            return 'f-tooltip-' + this.type;
        }
        return '';
    }
    /**
     * 获取宿主尺寸
     * @private
     * @param {?} boxEl
     * @return {?}
     */
    getBoxSizeObj(boxEl) {
        /** @type {?} */
        const p = boxEl.getBoundingClientRect();
        return {
            width: DomHandler.getOuterWidth(boxEl),
            height: DomHandler.getOuterHeight(boxEl),
            left: p.left,
            right: p.right,
            top: p.top,
            bottom: p.bottom
        };
    }
    /**
     * 获取tooltip 容器尺寸
     * @private
     * @return {?}
     */
    getTooltipSize() {
        return {
            width: DomHandler.getOuterWidth(this.container),
            height: DomHandler.getOuterHeight(this.container)
        };
    }
    /**
     * 获取窗口尺寸
     * @private
     * @return {?}
     */
    getWindowSize() {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        };
    }
    /**
     * 根据内容的多少，自动更改tooltip 的位置
     * @private
     * @param {?} boxEl
     * @return {?}
     */
    changeTooltipPosition(boxEl) {
        /** @type {?} */
        const boxSize = this.getBoxSizeObj(boxEl);
        /** @type {?} */
        const tooltip = this.getTooltipSize();
        /** @type {?} */
        const winSize = this.getWindowSize();
        this.container.className = this.tooltipCls();
        if (tooltip.width < winSize.width && tooltip.height < boxSize.top) {
            // this.position = 'top-left';
            return;
        }
        else {
            /** @type {?} */
            const elOffset = DomHandler.getOffset(boxEl);
            /** @type {?} */
            const elLeft = elOffset.left;
            /** @type {?} */
            const elRight = winSize.width - elLeft - boxSize.width;
            if (elLeft > elRight) {
                this.position = 'left';
            }
            else {
                this.position = 'right';
            }
            /** @type {?} */
            const toolTipTextWidth = elLeft > elRight ? elLeft : elRight;
            /** @type {?} */
            const textEl = this.getTextContainer();
            textEl.style.maxWidth = `${toolTipTextWidth - 30}px`;
            this.container.style.maxWidth = `${toolTipTextWidth}px`;
        }
    }
}
DatagridCellTooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: '[cell-tooltip]',
                exportAs: 'cellTooltip'
            },] }
];
/** @nocollapse */
DatagridCellTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector }
];
DatagridCellTooltipDirective.propDecorators = {
    enable: [{ type: Input, args: ['cell-tooltip',] }],
    position: [{ type: Input }],
    positionStyle: [{ type: Input }],
    tooltipStyleClass: [{ type: Input }],
    message: [{ type: Input }],
    delay: [{ type: Input }],
    cls: [{ type: Input }],
    type: [{ type: Input }],
    tipMode: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CellTootipMessagePipe {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
    }
    /**
     * @param {?} col
     * @param {...?} args
     * @return {?}
     */
    transform(col, ...args) {
        if (col.showTips) {
            this.colFormatSer = this.injector.get(ColumnFormatService);
            /** @type {?} */
            const msg = this.getCellTooltipContent(col, args[0]);
            return msg;
        }
        return '';
    }
    /**
     * @private
     * @param {?} col
     * @param {?} rowData
     * @return {?}
     */
    getCellTooltipContent(col, rowData) {
        /** @type {?} */
        let txt = Utils.getValue(col.field, rowData);
        if (col.tipContent) {
            if (typeof col.tipContent === 'string') {
                txt = col.tipContent;
            }
            else {
                if (typeof col.tipContent === 'function') {
                    txt = col.tipContent(txt, rowData, col);
                }
            }
        }
        else {
            if (col.formatter && (typeof col.formatter === 'function' ||
                (typeof col.formatter === 'object' && Object.keys(col.formatter).length))) {
                txt = this.colFormatSer.format(txt, rowData, col.formatter);
            }
            else {
                txt = Utils.escapeValue(txt);
            }
        }
        return txt;
    }
}
CellTootipMessagePipe.decorators = [
    { type: Pipe, args: [{ name: 'tipmsg', pure: false },] }
];
/** @nocollapse */
CellTootipMessagePipe.ctorParameters = () => [
    { type: Injector }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridFilterToolbarComponent {
    /**
     * @param {?} inject
     * @param {?} el
     * @param {?} cd
     * @param {?} dgs
     * @param {?} render
     * @param {?} ngZone
     * @param {?} localeSer
     */
    constructor(inject, el, cd, dgs, render, ngZone, localeSer) {
        this.inject = inject;
        this.el = el;
        this.cd = cd;
        this.dgs = dgs;
        this.render = render;
        this.ngZone = ngZone;
        this.localeSer = localeSer;
        this.empty = '[ 无 ]';
        this.filterText = this.empty;
        this.openFilterPanel = false;
        this.showExpand = false;
        this.enableFilterSetting = false;
        this.windowResizeHandler = null;
        this.ro = null;
        this.destory$ = new Subject();
        this.empty = this.localeSer.getValue('datagrid.filter.nofilter');
        this.filterText = this.empty;
    }
    /**
     * @return {?}
     */
    get toolbarWidth() {
        return this.filterToolbarRef.nativeElement.offsetWidth;
    }
    /**
     * @return {?}
     */
    get filterTextContainerWidth() {
        /** @type {?} */
        let actionW = 52;
        if (this.enableFilterSetting) {
            actionW = 65;
        }
        return this.toolbarWidth - 85 - actionW;
    }
    /**
     * @return {?}
     */
    get filterTextRealWidth() {
        this.render.setStyle(this.filterPanelTextRef.nativeElement, 'white-space', 'nowrap');
        /** @type {?} */
        const w = this.filterPanelTextRef.nativeElement.scrollWidth;
        this.render.setStyle(this.filterPanelTextRef.nativeElement, 'white-space', 'normal');
        return w;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dg = this.inject.get(DatagridComponent);
        this.dfrs = this.dg.clientFilterService;
        this.dgs.clearFilter.pipe(takeUntil(this.destory$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.filterText = this.empty;
            this.openFilterPanel = false;
            this.dgs.onFilterTextChange(this.filterText);
            this.cd.detectChanges();
        }));
        this.filterChangeSubscription = this.dgs.onFilterChanged.pipe(takeUntil(this.destory$)).subscribe((/**
         * @param {?} n
         * @return {?}
         */
        (n) => {
            this.filterText = this.dfrs.convertFilterCondition2String(n);
            if (!this.filterText) {
                this.filterText = this.empty;
            }
            this.updateExpandState();
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.bindEvent();
            }), 100);
            if (!this.showExpand) {
                this.openFilterPanel = false;
            }
            this.cd.detectChanges();
            this.dgs.onFilterTextChange(this.filterText);
        }));
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this.ro = new ResizeObserver((/**
             * @return {?}
             */
            () => {
                if (this['_CONTAINER_SIZE_CHANGED_TIMER_']) {
                    clearTimeout(this['_CONTAINER_SIZE_CHANGED_TIMER_']);
                }
                this['_CONTAINER_SIZE_CHANGED_TIMER_'] = setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.updateExpandState();
                    this.cd.detectChanges();
                }), 100);
            }));
            this.ro.observe(this.el.nativeElement.closest('div.f-datagrid'));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destory$.next();
        this.destory$.complete();
        this.ro.disconnect();
        if (this.filterChangeSubscription) {
            this.filterChangeSubscription.unsubscribe();
            this.filterChangeSubscription = null;
        }
        if (this.windowResizeHandler) {
            this.windowResizeHandler();
            this.windowResizeHandler = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    bindEvent() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const filterFields = this.filterToolbarRef.nativeElement.querySelectorAll('.filter-field');
            this.bindFilterFieldHandler(filterFields);
            /** @type {?} */
            const dropdownFilterFields = this.filterPanelTextRef.nativeElement.querySelectorAll('.filter-field');
            this.bindFilterFieldHandler(dropdownFilterFields, false);
        }));
    }
    /**
     * @private
     * @param {?} filterFields
     * @param {?=} hidePanel
     * @return {?}
     */
    bindFilterFieldHandler(filterFields, hidePanel = true) {
        if (filterFields && filterFields.length) {
            filterFields.forEach((/**
             * @param {?} ff
             * @return {?}
             */
            ff => {
                this.render.listen(ff, 'click', (/**
                 * @return {?}
                 */
                () => {
                    this.removeFilterField(ff, hidePanel);
                }));
            }));
        }
    }
    /**
     * @private
     * @param {?} ff
     * @param {?=} hidePanel
     * @return {?}
     */
    removeFilterField(ff, hidePanel = true) {
        /** @type {?} */
        const field = ff.classList[1].replace('filter-column-', '');
        // delete this.dg.conditions[field];
        ff.remove();
        if (hidePanel) {
            this.openFilterPanel = false;
            this.updateExpandState();
        }
        this.dfrs.removeFilterField(field);
    }
    /**
     * @private
     * @return {?}
     */
    updateExpandState() {
        this.showExpand = this.isShowExpand();
    }
    /**
     * @return {?}
     */
    isShowExpand() {
        if (this.filterTextContainerWidth > this.filterTextRealWidth) {
            return false;
        }
        else if (this.filterTextRealWidth > this.filterTextContainerWidth) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    clearFilter($event) {
        this.filterText = this.empty;
        this.dgs.onClearFilter();
        this.dgs.onFilterChanged.emit({});
        return false;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    refreshFilter($event) {
        this.dg.filterData();
        return false;
    }
    /**
     * @return {?}
     */
    showFilterTextPanel() {
        this.openFilterPanel = !this.openFilterPanel;
        this.cd.detectChanges();
    }
}
DatagridFilterToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'filter-toolbar',
                template: `
        <div class="f-datagrid-filter-toolbar-panel" #filterPanel [class.show]="openFilterPanel" style="width: auto">
            <span class="filter-text" #filterPanelText [innerHTML]="filterText"></span>
        </div>
        <div class="f-datagrid-filter-toolbar" #filterToolbar>
            <span class="title">{{'datagrid.filter.title'| locale}}：</span>
            <span #filterbarTxt class="filter-text" [innerHTML]="filterText"> </span>
            <span class="filter-action" *ngIf="filterText !== empty ">
                <span *ngIf="showExpand" class="f-icon filter-action-item"
                    [class.f-icon-arrow-chevron-up]="openFilterPanel"
                    [class.f-icon-arrow-chevron-down]="!openFilterPanel"
                (click)="showFilterTextPanel()" title="{{'datagrid.filter.more'|locale}}"></span>
                <span title="{{'datagrid.filter.clearAll'|locale}}" class="f-icon f-icon-x filter-action-item filter-clear" (click)="clearFilter($event)"></span>
                <span title="refresh" class="f-icon f-icon-reload-sm filter-action-item filter-refresh" style="color: #388fff" (click)="refreshFilter($event)"></span>
                <span *ngIf="enableFilterSetting" class="f-icon f-icon-cog filter-action-item" title="{{'datagrid.filter.setting'|locale}}"></span>
            </span>
        </div>
    `,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
DatagridFilterToolbarComponent.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: DatagridService },
    { type: Renderer2 },
    { type: NgZone },
    { type: LocaleService }
];
DatagridFilterToolbarComponent.propDecorators = {
    enableFilterSetting: [{ type: Input }],
    filterPanelRef: [{ type: ViewChild, args: ['filterPanel',] }],
    filterPanelTextRef: [{ type: ViewChild, args: ['filterPanelText',] }],
    filterTextRef: [{ type: ViewChild, args: ['filterbarTxt',] }],
    filterToolbarRef: [{ type: ViewChild, args: ['filterToolbar',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HeaderStyleDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} inject
     */
    constructor(el, render, inject) {
        this.el = el;
        this.render = render;
        this.inject = inject;
        this.groupHeader = false;
        this.dg = null;
        this.dg = this.inject.get(DatagridComponent);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.renderCss2Element();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // 启用表头自提示
        if (this.column.halign && this.column.halign !== 'left') {
            /** @type {?} */
            const tipEl = this.el.nativeElement.querySelector('.farris-label-tips');
            if (tipEl && tipEl.parentElement && tipEl.parentElement.nodeName == 'DIV') {
                this.render.setStyle(tipEl.parentElement, 'width', '100%');
                if (this.column.halign === 'right') {
                    this.render.setStyle(tipEl.parentElement, 'justify-content', 'end');
                }
                else {
                    this.render.setStyle(tipEl.parentElement, 'justify-content', 'center');
                }
            }
            else {
                if (this.groupHeader) {
                    if (this.column.halign === 'right') {
                        this.render.setStyle(this.el.nativeElement, 'justify-content', 'end');
                    }
                    else {
                        this.render.setStyle(this.el.nativeElement, 'justify-content', 'center');
                    }
                }
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    renderCss2Element() {
        if (this.column && this.column.headerStyler) {
            /** @type {?} */
            const styler = this.column.headerStyler;
            /** @type {?} */
            const dom = this.el.nativeElement;
            /** @type {?} */
            const st = typeof this.column.headerStyler;
            if (st === 'string') {
                this.render.addClass(this.el.nativeElement, (/** @type {?} */ (styler)));
            }
            else if (st === 'function') {
                /** @type {?} */
                const r = ((/** @type {?} */ (this.column.headerStyler)))(this.column);
                if (r.cls) {
                    this.render.addClass(this.el.nativeElement, r.cls);
                }
                if (r.style) {
                    this.renderStyle(dom, r.style);
                }
            }
            else if (st === 'object' && Object.keys(st).length) {
                this.renderStyle(dom, styler);
            }
        }
    }
    /**
     * @private
     * @param {?} targetEl
     * @param {?} styleObj
     * @return {?}
     */
    renderStyle(targetEl, styleObj) {
        /** @type {?} */
        const clskey = `${this.dg.customStyleKey()} td[field="${this.column.field}"] span.f-datagrid-header-cell-title`;
        this.dg.renderCustomStyle2({ style: styleObj }, targetEl, clskey);
        /** @type {?} */
        const tdClskey = `${this.dg.customStyleKey()} td[field="${this.column.field}"].f-datagrid-header-cell`;
        this.dg.renderCustomStyle2({ style: styleObj }, targetEl, tdClskey);
        /** @type {?} */
        const bg = Object.keys(styleObj).filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.toLowerCase().indexOf('background') > -1));
        if (bg && bg.length) {
            /** @type {?} */
            const _bgcolor = styleObj[bg[bg.length - 1]];
            /** @type {?} */
            const tdClskey2 = `${this.dg.customStyleKey()} td[field="${this.column.field}"] div.f-datagrid-header-cell-content::after`;
            this.dg.renderCustomStyle2({ style: { 'background-color': _bgcolor } }, targetEl, tdClskey2);
        }
    }
}
HeaderStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[header-style]',
                exportAs: 'HeaderStyler'
            },] }
];
/** @nocollapse */
HeaderStyleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector }
];
HeaderStyleDirective.propDecorators = {
    column: [{ type: Input, args: ['header-style',] }],
    groupHeader: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * 自动高度
 * 禁用分页，禁用固定表头，禁用虚拟加载，禁用固定列
 * 支持单元格编辑, 支持排序, 支持拖动列宽
 */
class AutoHeightComponent {
    /**
     * @param {?} dg
     * @param {?} inject
     */
    constructor(dg, inject) {
        this.dg = dg;
        this.inject = inject;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
AutoHeightComponent.decorators = [
    { type: Component, args: [{
                selector: 'auto-height',
                template: "<table style=\"width:100%\" class=\"f-datagrid-ah\" cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\r\n    <colgroup>\r\n        <col *ngIf=\"dg.showLineNumber\" [width]=\"dg.lineNumberWidth + 'px'\">\r\n        <ng-container *ngFor=\"let col of columnsGroup?.normalColumns\">\r\n            <col [width]=\"col.width + 'px'\">\r\n        </ng-container>\r\n    </colgroup>\r\n    <thead>\r\n        <tr class=\"f-datagrid-header-row\" *ngFor=\"let cols of columns\">\r\n            <td class=\"f-datagrid-header-cell\" *ngIf=\"dg.showLineNumber\"></td>\r\n            <ng-container *ngFor=\"let col of cols\">\r\n                <ng-container *ngIf=\"col.colspan && !col.fixed\">\r\n                    <td class=\"f-datagrid-header-cell f-datagrid-header-cell-group\" \r\n                        [attr.align]=\"col.halign\"\r\n                        [attr.colspan]=\"col.colspan\">\r\n                        <div class=\"f-datagrid-header-cell-content\" >\r\n                            {{ col.title }}\r\n                        </div>\r\n                    </td>\r\n                </ng-container>\r\n                <ng-container *ngIf=\"!col.colspan && !col.fixed\">\r\n                    <td class=\"f-datagrid-header-cell\" \r\n                        [attr.align]=\"col.halign\" \r\n                        [attr.field]=\"col.field\"\r\n                        [attr.rowspan]=\"col.rowspan\">\r\n                        <div class=\"f-datagrid-header-cell-content\">\r\n                            {{ col.title }}\r\n                        </div>\r\n                    </td>\r\n                </ng-container>\r\n            </ng-container>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr class=\"f-datagrid-body-row\" [attr.id]=\"row | rowDataId\" *ngFor=\"let row of data; trackBy: dg.trackByRows; let i = index\">\r\n            <td class=\"f-datagrid-cell f-datagrid-cell-rownumber\" [style.width.px]=\"dg.lineNumberWidth\" *ngIf=\"dg.showLineNumber\">{{ i+1 }}</td>\r\n            <td class=\"f-datagrid-cell\" [attr.align]=\"col.align\" *ngFor=\"let col of columnsGroup?.normalColumns; let ci = index;\">\r\n                <span [innerHtml]=\" col | formatCellData: row | safe: 'html'\"></span>\r\n            </td>\r\n        </tr>\r\n        <ng-container *ngIf=\"dg.showFooter && data && data.length\">\r\n            <tr class=\"f-datagrid-body-row\" *ngFor=\"let row of dg.footerData\">\r\n                <td class=\"f-datagrid-cell f-datagrid-cell-rownumber\" [style.width.px]=\"dg.lineNumberWidth\" *ngIf=\"dg.showLineNumber\"></td>\r\n                <td class=\"f-datagrid-cell\" [attr.align]=\"col.align\" *ngFor=\"let col of columnsGroup?.normalColumns\" [attr.title]=\"col | formatCellData: row \">\r\n                    <div class=\"f-datagrid-cell-content\">\r\n                        <span *ngIf=\"col.footer && col.footer.formatter\" [innerHtml]=\" col | formatCellData: row : false: true | safe: 'html'\"></span>\r\n                        <span *ngIf=\"!col.footer || !col.footer.formatter\">{{ col | formatCellData: row: false: true }}</span>\r\n                    </div>\r\n                </td>\r\n            </tr>\r\n        </ng-container>\r\n    </tbody>\r\n</table>"
            }] }
];
/** @nocollapse */
AutoHeightComponent.ctorParameters = () => [
    { type: DatagridComponent },
    { type: Injector }
];
AutoHeightComponent.propDecorators = {
    columns: [{ type: Input }],
    columnsGroup: [{ type: Input }],
    data: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RowIsSelectedPipe {
    /**
     * @param {?} dfs
     */
    constructor(dfs) {
        this.dfs = dfs;
    }
    /**
     * @param {?} rowData
     * @param {?=} selections
     * @return {?}
     */
    transform(rowData, selections) {
        if (!rowData) {
            return false;
        }
        /** @type {?} */
        const id = this.dfs.primaryId(rowData);
        if (id) {
            return this.dfs.isRowSelected(id, selections);
        }
        else {
            return false;
        }
    }
}
RowIsSelectedPipe.decorators = [
    { type: Pipe, args: [{ name: 'rowIsSelected', pure: false },] }
];
/** @nocollapse */
RowIsSelectedPipe.ctorParameters = () => [
    { type: DatagridFacadeService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RowIsCheckedPipe {
    /**
     * @param {?} dfs
     */
    constructor(dfs) {
        this.dfs = dfs;
    }
    /**
     * @param {?} rowData
     * @param {?} checkeds
     * @return {?}
     */
    transform(rowData, checkeds) {
        if (!rowData) {
            return false;
        }
        /** @type {?} */
        const id = this.dfs.primaryId(rowData);
        if (id) {
            return this.dfs.isRowChecked(id, checkeds);
        }
        else {
            return false;
        }
    }
}
RowIsCheckedPipe.decorators = [
    { type: Pipe, args: [{ name: 'rowIsChecked', pure: false },] }
];
/** @nocollapse */
RowIsCheckedPipe.ctorParameters = () => [
    { type: DatagridFacadeService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GroupFooterRowStylerDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} inject
     * @param {?} dg
     */
    constructor(el, render, inject, dg) {
        this.el = el;
        this.render = render;
        this.inject = inject;
        this.dg = dg;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.buildCustomGroupFooterRowStyle(this.rowData);
    }
    /**
     * @private
     * @param {?} rowData
     * @return {?}
     */
    buildCustomGroupFooterRowStyle(rowData) {
        if (this.dg.groupFooterStyler) {
            /** @type {?} */
            const cs = this.dg.dgs.getCustomStyle(this.dg.groupFooterStyler, [rowData]);
            if (cs) {
                this.dg.renderCustomCls(cs.cls, this.el.nativeElement);
                if (cs.style) {
                    Object.keys(cs.style).forEach((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => {
                        this.el.nativeElement.style[n] = cs.style[n];
                    }));
                }
            }
        }
    }
}
GroupFooterRowStylerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[group-footer-row-styler]',
            },] }
];
/** @nocollapse */
GroupFooterRowStylerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector },
    { type: DatagridComponent }
];
GroupFooterRowStylerDirective.propDecorators = {
    column: [{ type: Input }],
    rowData: [{ type: Input, args: ['group-footer-row-styler',] }],
    rowIndex: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AutoHeightDirective {
    /**
     * @param {?} dg
     * @param {?} inject
     * @param {?} el
     */
    constructor(dg, inject, el) {
        this.dg = dg;
        this.inject = inject;
        this.el = el;
        this.autoHeight = false;
        this._timer = null;
        this._dgb = null;
        this._dgb = this.inject.get(DatagridBodyComponent);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // this.updateDatagridHeight(this.wheelHeight);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._updateDatagridHeight(this.wheelHeight);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.wheelHeight) {
            this._updateDatagridHeight(this.wheelHeight);
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        // this.checkScrollbarPosition();
    }
    /**
     * @private
     * @param {?} wheelHeight
     * @return {?}
     */
    updateDatagridHeight(wheelHeight) {
        if (this.el && this.el.nativeElement && this.el.nativeElement.parentElement) {
            if (this.autoHeight) {
                if (!wheelHeight) {
                    wheelHeight = 240;
                    if (!this.dg.ds || !this.dg.ds.rows || !this.dg.ds.rows.length) {
                        wheelHeight = (!this.dg.emptyDataHeight || this.dg.emptyDataHeight < 0) ? 240 : this.dg.emptyDataHeight;
                    }
                }
                /** @type {?} */
                let h = parseInt(wheelHeight, 10);
                if (this.dg.showHeader) {
                    if (!this.dg.realHeaderHeight) {
                        h += this.dg.setHeaderHeight();
                    }
                    else {
                        h += this.dg.realHeaderHeight;
                    }
                }
                if (this.dg.showFooter) {
                    h += this.dg.footerHeight;
                }
                if (this.dg.pagination) {
                    /** @type {?} */
                    const ph = this.dg.pagerHeight || 40;
                    h += ph;
                }
                if (this.dg.showFilterBar) {
                    h += this.dg.filterBarHeight;
                }
                if (this.dg.showRowGroupPanel) {
                    h += this.dg.rowGroupPanelHeight;
                }
                /** @type {?} */
                let wh = `${wheelHeight}px`;
                if (this.dg.maxHeight && h > this.dg.maxHeight) {
                    wh = this._dgb.getViewPortHeight();
                }
                this.el.nativeElement.parentElement.style.height = wh;
                this.el.nativeElement.parentElement.parentElement.style.height = wh;
                if (this.dg.dgContainer) {
                    if (this.dg.maxHeight && h > this.dg.maxHeight) {
                        h = this.dg.maxHeight;
                    }
                    /** @type {?} */
                    const dgHeight = `${h}px`;
                    // 更新grid 最外层的高度
                    this.dg.dgContainer.nativeElement.style.height = dgHeight;
                    // farris-datagrid 增加高度
                    this.dg.el.nativeElement.style.height = dgHeight;
                    this.dg.height = h;
                    if (this.dg.maxHeight) {
                        if (this.dg.maxHeight && this.dg.maxHeight < 55) {
                            this.dg.maxHeight = 60;
                        }
                        /** @type {?} */
                        const gridContainerEl = this.dg.el.nativeElement.parentElement;
                        gridContainerEl.style.height = 'unset';
                        gridContainerEl.style.maxHeight = this.dg.maxHeight + 'px';
                        gridContainerEl.style.minHeight = h + 'px';
                    }
                }
                else {
                    this.dg.el.nativeElement.querySelector('.f-datagrid').style.height = `${h}px`;
                }
            }
        }
    }
    /**
     * @private
     * @param {?} wheelHeight
     * @return {?}
     */
    _updateDatagridHeight(wheelHeight) {
        if (this.dg.autoHeight) {
            if (this.dg.el.nativeElement.parentElement.className.indexOf('f-utils-fill') > -1) {
                this.dg.el.nativeElement.parentElement.className = this.dg.el.nativeElement.parentElement.className.replace('f-utils-fill', '');
            }
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.updateDatagridHeight(wheelHeight);
            }), 50);
        }
    }
}
AutoHeightDirective.decorators = [
    { type: Directive, args: [{
                selector: '[auto-height]',
            },] }
];
/** @nocollapse */
AutoHeightDirective.ctorParameters = () => [
    { type: DatagridComponent },
    { type: Injector },
    { type: ElementRef }
];
AutoHeightDirective.propDecorators = {
    autoHeight: [{ type: Input, args: ['auto-height',] }],
    wheelHeight: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatagridRowDblClickDirective {
    /**
     * @param {?} el
     * @param {?} injector
     * @param {?} ngZone
     * @param {?} render
     * @param {?} dg
     */
    constructor(el, injector, ngZone, render, dg) {
        this.el = el;
        this.injector = injector;
        this.ngZone = ngZone;
        this.render = render;
        this.dg = dg;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dblclickRowEvent(event) {
        /** @type {?} */
        const tr = event.target.closest('tr');
        if (!tr) {
            return;
        }
        if (tr.id == null || tr.id == undefined) {
            return;
        }
        // const rowid = tr.id.replace(TR_PREFIX, '').replace('_fixedright', '').replace('_fixedleft', '').replace('');
        /** @type {?} */
        const rowid = Utils.getRowIdByTr(tr);
        if (tr.className.indexOf('f-datagrid-group-row') > -1) {
            /** @type {?} */
            const groupRowid = rowid.replace('group-tr_', '');
            const { data: groupData, index: groupIndex } = this.dg.getGroupRow(groupRowid);
            if (groupData && !isNaN(groupIndex)) {
                if (groupData.expanded) {
                    this.dg.collapseGroupRow(groupIndex);
                }
                else {
                    this.dg.expandGroupRow(groupIndex);
                }
            }
            return;
        }
        /** @type {?} */
        const rowIndex = tr.getAttribute('index');
        /** @type {?} */
        const rowData = this.dg.dfs.findRow(rowid);
        if (!rowData) {
            return;
        }
        if (this.dg.disableRow) {
            if (this.dg.disableRow(rowData.data, rowData.index)) {
                event.stopPropagation();
                return false;
            }
        }
        /** @type {?} */
        const handler = (/**
         * @return {?}
         */
        () => {
            if (!this.dg.dfs.isRowSelected(rowid)) {
                /** @type {?} */
                const r = this.dg.beforeSelect({ rowIndex: rowIndex, rowData: rowData.data, gridInstance: this.dg });
                /** @type {?} */
                let r$ = of(true);
                if (r && r.subscribe) {
                    r$ = r;
                }
                r$.subscribe((/**
                 * @param {?} t
                 * @return {?}
                 */
                (t) => {
                    if (t) {
                        this.dg.selectRow(rowid, true, false);
                        this.dg.dblclickRow.emit({ rowData, id: rowid, index: rowIndex, grid: this.dg, dblclick: true });
                    }
                }));
            }
            else {
                this.dg.dblclickRow.emit({ rowData, id: rowid, index: rowIndex, grid: this.dg, dblclick: true });
            }
        });
        if (this.dg.editable) {
            if (this.dg.editMode === 'row' && this.dg.clickToEdit) {
                this.dg.endRowEdit();
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.dg.editRow(rowid);
                }), 200);
            }
            else {
                this.dg.isSingleClick = false;
                // this.dg.dblclickRow.emit({ rowData, id: rowid, index: rowIndex, grid: this.dg, dblclick: true });
                handler();
            }
        }
        else {
            // this.dg.dblclickRow.emit({ rowData, id: rowid, index: rowIndex, grid: this.dg,  dblclick: true });
            handler();
        }
        event.stopPropagation();
        event.preventDefault();
    }
}
DatagridRowDblClickDirective.decorators = [
    { type: Directive, args: [{
                selector: '[row-dblclick]',
            },] }
];
/** @nocollapse */
DatagridRowDblClickDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector },
    { type: NgZone },
    { type: Renderer2 },
    { type: DatagridComponent }
];
DatagridRowDblClickDirective.propDecorators = {
    dblclickRowEvent: [{ type: HostListener, args: ['dblclick', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FooterCellStylerDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} inject
     * @param {?} dg
     */
    constructor(el, render, inject, dg) {
        this.el = el;
        this.render = render;
        this.inject = inject;
        this.dg = dg;
        this.isGroupFooter = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.isGroupFooter) {
            this.setGroupFooterCellStyle(this.column);
        }
        else {
            this.buildCustomCellStyle(this.column, this.rowData);
        }
    }
    /**
     * @private
     * @param {?} column
     * @param {?} rowData
     * @return {?}
     */
    buildCustomCellStyle(column, rowData) {
        /** @type {?} */
        const tr = this.el.nativeElement.parentNode;
        if (tr && !tr.id) {
            /** @type {?} */
            const rowdataid = this.dg.dfs.primaryId(rowData);
            /** @type {?} */
            let fixed = '';
            if (tr.closest('.f-datagrid-body-fixed-left')) {
                fixed = '-left';
            }
            else if (tr.closest('.f-datagrid-body-fixed-right')) {
                fixed = '-right';
            }
            /** @type {?} */
            const trID = 'footer-row' + fixed + '_' + (rowdataid || this.rowIndex);
            tr.id = trID;
        }
        if (!this.el.nativeElement.id) {
            this.el.nativeElement.id = 'footer-td_' + this.rowIndex + '_' + this.column.field.replace(/\./g, '_');
        }
        if (column && column.footer && column.footer.styler) {
            /** @type {?} */
            const _rd = rowData;
            /** @type {?} */
            const styler = column.footer.styler;
            /** @type {?} */
            const cs = styler(_rd[column.field], _rd);
            if (cs && Object.keys(cs).length) {
                this.dg.renderCustomStyle(cs, this.el.nativeElement);
            }
            else {
                this.dg.dgs.removeCssRule('#' + this.el.nativeElement.id);
            }
        }
    }
    /**
     * @private
     * @param {?} col
     * @return {?}
     */
    setGroupFooterCellStyle(col) {
        // 分组合计行自定义样式 20210909
        if (col.groupFooter && col.groupFooter.styler) {
            /** @type {?} */
            const val = this.dg.commonUtils.getValue(col.field, this.rowData);
            /** @type {?} */
            const _customStyles = this.dg.dgs.getCustomStyle(col.groupFooter.styler, [val, this.rowData]);
            if (_customStyles) {
                this.dg.renderCustomCls(_customStyles.cls, this.el.nativeElement);
                if (_customStyles.style) {
                    Object.keys(_customStyles.style).forEach((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => {
                        this.el.nativeElement.style[n] = _customStyles.style[n];
                    }));
                }
            }
        }
    }
}
FooterCellStylerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[footer-cell-styler]',
            },] }
];
/** @nocollapse */
FooterCellStylerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector },
    { type: DatagridComponent }
];
FooterCellStylerDirective.propDecorators = {
    column: [{ type: Input }],
    rowData: [{ type: Input }],
    rowIndex: [{ type: Input }],
    isGroupFooter: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragDropColumnService {
    constructor() { }
    /**
     * 元素位置调整
     * arr: 数组
     * newIndex: 新位置索引
     * removedIndex: 老位置索引
     * @param {?} arr
     * @param {?} newIndex
     * @param {?} removedIndex
     * @return {?}
     */
    moveItem(arr, newIndex, removedIndex) {
        /** @type {?} */
        const removedItem = arr.splice(removedIndex, 1);
        arr.splice(newIndex, 0, ...removedItem);
        return arr;
    }
    /**
     * @param {?} columns
     * @return {?}
     */
    backupColumns(columns) {
        this.initColumns = columns.map((/**
         * @param {?} cols
         * @return {?}
         */
        cols => {
            return cols.map((/**
             * @param {?} n
             * @return {?}
             */
            n => {
                return {
                    id: n.id,
                    field: n.field
                };
            }));
        }));
    }
}
DragDropColumnService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
DragDropColumnService.ctorParameters = () => [];
/** @nocollapse */ DragDropColumnService.ngInjectableDef = defineInjectable({ factory: function DragDropColumnService_Factory() { return new DragDropColumnService(); }, token: DragDropColumnService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
smoothDnD.dropHandler = dropHandlers.reactDropHandler().handler;
smoothDnD.wrapChild = false;
class DragColumnDirective {
    /**
     * @param {?} ngzone
     * @param {?} injector
     * @param {?} render
     * @param {?} el
     * @param {?} header
     * @param {?} dg
     * @param {?} dndSer
     */
    constructor(ngzone, injector, render, el, header, dg, dndSer) {
        this.ngzone = ngzone;
        this.injector = injector;
        this.render = render;
        this.el = el;
        this.header = header;
        this.dg = dg;
        this.dndSer = dndSer;
        this.enableDrag = true;
        this.groupName = '';
        this.options = {
            groupName: this.groupName,
            orientation: 'horizontal',
            behaviour: 'move',
            dragHandleSelector: '.drag-column-bar',
            dragClass: 'drag-column-moving',
            dropPlaceholder: {
                className: 'drop-group-field',
            },
            getGhostParent: (/**
             * @return {?}
             */
            () => {
                return document.body;
            }),
            getChildPayload: this.getChildPayload.bind(this),
            shouldAcceptDrop: (/**
             * @param {?} sourceContainerOptions
             * @param {?} payload
             * @return {?}
             */
            (sourceContainerOptions, payload) => {
                if (typeof payload === 'number') {
                    return false;
                }
                if (sourceContainerOptions.groupName !== this.groupName) {
                    return false;
                }
                return !this.dg.isMultiHeader();
            }),
            onDropReady: (/**
             * @param {?} dropResult
             * @return {?}
             */
            (dropResult) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDropReady(dropResult);
                }));
            }),
            onDrop: (/**
             * @param {?} dropResult
             * @return {?}
             */
            (dropResult) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDrop(dropResult);
                }));
            }),
            onDragEnter: (/**
             * @return {?}
             */
            () => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDragEnter();
                }));
            }),
            onDragStart: (/**
             * @param {?} info
             * @return {?}
             */
            (info) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDragStart(info);
                }));
            }),
            onDragEnd: (/**
             * @param {?} info
             * @return {?}
             */
            (info) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDragEnd(info);
                }));
            })
        };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.enableDrag && !changes.enableDrag.isFirstChange()) {
            if (this.enableDrag) {
                this.initDnD();
            }
            else {
                this.disposeDnd();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initDnD();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.disposeDnd();
    }
    /**
     * @private
     * @return {?}
     */
    disposeDnd() {
        if (this.container) {
            this.container.dispose();
            this.container = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    initDnD() {
        if (!this.dg.enableDragColumn) {
            return;
        }
        if (this.groupName === 'left' || this.groupName === 'right') {
            const { left, right } = this.columnsGroup();
            if (this.groupName === 'left' && !left.length) {
                return;
            }
            if (this.groupName === 'right' && (!right.length || (right.length === 1 && right[0].field === '_datagrid-setting-control_'))) {
                return;
            }
        }
        this.options.groupName = this.groupName;
        this.disposeDnd();
        if (this.enableDrag) {
            this.container = smoothDnD(this.el.nativeElement, this.options);
            this.dndSer.backupColumns(this.header.columns);
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    getChildPayload(index) {
        if (this.groupName === 'left') {
            if (this.dg.showCheckbox) {
                index--;
            }
            if (this.dg.showLineNumber) {
                index--;
            }
        }
        /** @type {?} */
        const groupColumns = this.columnsGroup();
        if (this.groupName === 'left') {
            return groupColumns.left.filter((/**
             * @param {?} n
             * @param {?} i
             * @return {?}
             */
            (n, i) => this.dg.columnIsVisible(n)))[index];
        }
        else if (this.groupName === 'right') {
            return groupColumns.right.filter((/**
             * @param {?} n
             * @param {?} i
             * @return {?}
             */
            (n, i) => this.dg.columnIsVisible(n)))[index];
        }
        else {
            return groupColumns.middle.filter((/**
             * @param {?} n
             * @param {?} i
             * @return {?}
             */
            (n, i) => this.dg.columnIsVisible(n)))[index];
        }
    }
    /**
     * @param {?} dropResult
     * @return {?}
     */
    onDropReady(dropResult) {
    }
    /**
     * @private
     * @param {?} dropResult
     * @return {?}
     */
    onDrop(dropResult) {
        const { addedIndex, payload, removedIndex } = dropResult;
        if (addedIndex === null) {
            return;
        }
        /** @type {?} */
        const groupColumns = this.columnsGroup();
        /** @type {?} */
        const cols = this.dg.columns[0];
        /** @type {?} */
        const currIndex = cols.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => n.field === payload.field));
        /** @type {?} */
        let newIndex = addedIndex;
        /** @type {?} */
        const moveColumn = (/**
         * @param {?} columns
         * @return {?}
         */
        (columns) => {
            if (columns) {
                /** @type {?} */
                const targetColumn = columns.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.visible || n.visible === undefined))[newIndex];
                if (targetColumn) {
                    /** @type {?} */
                    const realTagetIndex = cols.findIndex((/**
                     * @param {?} n
                     * @return {?}
                     */
                    n => n.field === targetColumn.field));
                    this.dg.columns[0] = this.dndSer.moveItem(this.dg.columns[0], realTagetIndex, currIndex);
                    return true;
                }
            }
            return false;
        });
        /** @type {?} */
        let columns = [];
        if (this.groupName === 'left') {
            if (this.dg.showCheckbox) {
                newIndex--;
            }
            if (this.dg.showLineNumber) {
                newIndex--;
            }
            columns = groupColumns.left;
        }
        else if (this.groupName === 'center') {
            columns = groupColumns.middle;
        }
        else if (this.groupName === 'right') {
            columns = groupColumns.right;
        }
        if (moveColumn(columns)) {
            this.dg.columnsChanged(false);
            if (this.dg.useControlPanel && this.dg.settingService) {
                this.dg.settingService.saveUserConfig(this.dg.id);
            }
            this.dg.columnMoved.emit({ newColumns: this.dg.columns, grid: this.dg });
        }
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    onDragStart(info) {
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    onDragEnd(info) {
    }
    /**
     * @private
     * @return {?}
     */
    onDragEnter() {
    }
    /**
     * @private
     * @return {?}
     */
    columnsGroup() {
        /** @type {?} */
        const leftColumns = this.dg.columns[0].filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'left'));
        /** @type {?} */
        const rightColumns = this.dg.columns[0].filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed === 'right'));
        /** @type {?} */
        const middleColumns = this.dg.columns[0].filter((/**
         * @param {?} n
         * @return {?}
         */
        n => n.fixed !== 'right' && n.fixed !== 'left'));
        return {
            left: leftColumns,
            right: rightColumns,
            middle: middleColumns
        };
    }
}
DragColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: '[drag-column]',
                providers: [
                    DragDropColumnService
                ]
            },] }
];
/** @nocollapse */
DragColumnDirective.ctorParameters = () => [
    { type: NgZone },
    { type: Injector },
    { type: Renderer2 },
    { type: ElementRef },
    { type: DatagridHeaderComponent },
    { type: DatagridComponent },
    { type: DragDropColumnService }
];
DragColumnDirective.propDecorators = {
    enableDrag: [{ type: Input, args: ['drag-column',] }],
    groupName: [{ type: Input }],
    options: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
smoothDnD.dropHandler = dropHandlers.reactDropHandler().handler;
smoothDnD.wrapChild = false;
class DropColumnDirective {
    /**
     * @param {?} ngzone
     * @param {?} injector
     * @param {?} render
     * @param {?} el
     * @param {?} dg
     * @param {?} dndSer
     */
    constructor(ngzone, injector, render, el, dg, dndSer) {
        this.ngzone = ngzone;
        this.injector = injector;
        this.render = render;
        this.el = el;
        this.dg = dg;
        this.dndSer = dndSer;
        this.options = {
            orientation: 'horizontal',
            behaviour: 'move',
            dragHandleSelector: '.group-field',
            dropPlaceholder: {
                className: 'drop-group-field',
            },
            getGhostParent: (/**
             * @return {?}
             */
            () => {
                return document.body;
            }),
            shouldAcceptDrop: (/**
             * @param {?} sourceContainerOptions
             * @param {?} payload
             * @return {?}
             */
            (sourceContainerOptions, payload) => {
                if (payload === undefined || payload === null) {
                    return false;
                }
                if (typeof payload === 'number') {
                    return true;
                }
                if (this.getGroupFields().length < 3) {
                    return payload.allowGrouping === undefined || payload.allowGrouping;
                }
                return false;
            }),
            getChildPayload: (/**
             * @param {?} index
             * @return {?}
             */
            (index) => {
                return index;
            }),
            // dragClass: 'drag-column-moving',
            onDropReady: (/**
             * @param {?} dropResult
             * @return {?}
             */
            (dropResult) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDropReady(dropResult);
                }));
            }),
            onDrop: (/**
             * @param {?} dropResult
             * @return {?}
             */
            (dropResult) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDrop(dropResult);
                }));
            }),
            onDragEnter: (/**
             * @return {?}
             */
            () => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDragEnter();
                }));
            }),
            onDragStart: (/**
             * @param {?} info
             * @return {?}
             */
            (info) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDragStart(info);
                }));
            }),
            onDragEnd: (/**
             * @param {?} info
             * @return {?}
             */
            (info) => {
                this.ngzone.run((/**
                 * @return {?}
                 */
                () => {
                    this.onDragEnd(info);
                }));
            })
        };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initDnD();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.disposeDnd();
    }
    /**
     * @private
     * @return {?}
     */
    disposeDnd() {
        if (this.container) {
            this.container.dispose();
            this.container = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    initDnD() {
        this.disposeDnd();
        if (this.dg.showRowGroupPanel) {
            this.container = smoothDnD(this.el.nativeElement, this.options);
        }
    }
    /**
     * @private
     * @param {?} dropResult
     * @return {?}
     */
    onDropReady(dropResult) {
    }
    /**
     * @private
     * @return {?}
     */
    getGroupFields() {
        return this.dg.groupField ? this.dg.groupField.split(',') : [];
    }
    /**
     * @private
     * @param {?} dropResult
     * @return {?}
     */
    onDrop(dropResult) {
        const { addedIndex, payload, removedIndex } = dropResult;
        if (addedIndex === null) {
            return;
        }
        /** @type {?} */
        const newGroupFields = this.getGroupFields();
        if (removedIndex === null) {
            if (!newGroupFields.some((/**
             * @param {?} v
             * @return {?}
             */
            (v) => v === payload.field))) {
                // newGroupFields.splice(0, 0, payload.field);
                newGroupFields.push(payload.field);
            }
        }
        else {
            this.dndSer.moveItem(newGroupFields, addedIndex, removedIndex);
        }
        this.dg.groupField = newGroupFields.join(',');
        // this.dg.toggleVisibleColumn([this.dg.groupField], false);
        if (this.dg.useControlPanel && this.dg.settingService) {
            this.dg.checkSettingHttp();
            this.dg.settingService.saveUserConfig(this.dg.id).subscribe((/**
             * @return {?}
             */
            () => {
                this.dg.columnsChanged();
            }));
        }
        else {
            this.dg.columnsChanged();
        }
        this.dg.groupFieldChange.emit({ newGroupField: this.dg.groupField, grid: this.dg });
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    onDragStart(info) {
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    onDragEnd(info) {
    }
    /**
     * @private
     * @return {?}
     */
    onDragEnter() {
    }
}
DropColumnDirective.decorators = [
    { type: Directive, args: [{
                selector: '[drop-column]',
                providers: [
                    DragDropColumnService
                ]
            },] }
];
/** @nocollapse */
DropColumnDirective.ctorParameters = () => [
    { type: NgZone },
    { type: Injector },
    { type: Renderer2 },
    { type: ElementRef },
    { type: DatagridComponent },
    { type: DragDropColumnService }
];
DropColumnDirective.propDecorators = {
    options: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CellIsReadonlyPipe {
    /**
     * @param {?} col
     * @param {...?} args
     * @return {?}
     */
    transform(col, ...args) {
        return this.isReadonly(col, args[0], args[1]);
    }
    /**
     * @private
     * @param {?} col
     * @param {?} rowData
     * @param {?} dg
     * @return {?}
     */
    isReadonly(col, rowData, dg) {
        if (dg.editable) {
            // 参与合并的单元格不允许编辑
            if (dg.mergeCell && dg.mergeFields.indexOf(col.field) > -1) {
                return true;
            }
            return this.getReadonlyValue(col, rowData);
        }
        else {
            return true;
        }
    }
    /**
     * @private
     * @param {?} col
     * @param {?} rowData
     * @return {?}
     */
    getReadonlyValue(col, rowData) {
        if (col.readonly !== undefined) {
            if (typeof col.readonly === 'boolean') {
                return col.readonly;
            }
            else if (typeof col.readonly === 'function') {
                return col.readonly(rowData);
            }
        }
        return false;
    }
}
CellIsReadonlyPipe.decorators = [
    { type: Pipe, args: [{
                name: 'cellReadonly'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_PERFECT_SCROLLBAR_CONFIG = {
    minScrollbarLength: 20
};
const ɵ0 = DEFAULT_PERFECT_SCROLLBAR_CONFIG;
class DatagridModule {
    /**
     * @param {?=} editors
     * @return {?}
     */
    static forRoot(editors) {
        return {
            ngModule: DatagridModule,
            providers: editors || []
        };
    }
}
DatagridModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    PaginationModule,
                    NgxPaginationModule,
                    ScrollbarModule,
                    LocaleModule.forRoot(),
                    DataColumnModule.forRoot(),
                    NotifyModule.forRoot(),
                    SimpleFilterModule,
                    DatagridSmartFilterModule,
                    FarrisContextMenuModule,
                    FarrisCommonModule.forRoot()
                ],
                declarations: [
                    SafePipe,
                    FormatCellDataPipe,
                    RowDataIdPipe,
                    FormatGroupRowPipe,
                    ShowRequiredStarPipe,
                    FieldValuePipe,
                    ReplaceXPipe,
                    DisableRowPipe,
                    SelectedRowPipe,
                    CellIsReadonlyPipe,
                    CellTootipMessagePipe,
                    DatagridComponent,
                    DatagridHeaderComponent,
                    DatagridFooterComponent,
                    DatagridResizeColumnDirective,
                    DatagridCellEditableDirective,
                    DatagridCellComponent,
                    DatagridRowDirective,
                    DatagridBodyComponent,
                    DatagridPagerComponent,
                    DatagridCellEditorDirective,
                    DatagridColumnDirective,
                    DatagridRowsComponent,
                    FixedLeftRowsComponent,
                    DatagridRowHoverDirective,
                    DataGridLoadingComponent,
                    DatagridCheckboxComponent,
                    DatagridHeaderCheckboxComponent,
                    GridCellEditorDirective,
                    TextboxEditorComponent,
                    DatagridGroupRowDirective,
                    DatagridCellTooltipDirective,
                    DatagridFilterToolbarComponent,
                    HeaderStyleDirective,
                    AutoHeightDirective,
                    AutoHeightComponent,
                    RowIsSelectedPipe,
                    RowIsCheckedPipe,
                    SelectedItemPipe,
                    PagerSelectedListComponent,
                    DatagridRowDblClickDirective,
                    FooterCellStylerDirective,
                    DragColumnDirective,
                    DropColumnDirective,
                    FilterRowCreateDirective,
                    SmartFilterToolbarComponent,
                    GroupFooterRowStylerDirective,
                ],
                providers: [
                    { provide: ErrorHandler, useClass: DatagridErrorHandler },
                    {
                        provide: SCROLLBAR_CONFIG,
                        useValue: ɵ0
                    },
                    ValidatorMessagerService
                ],
                exports: [
                    SafePipe,
                    DatagridComponent,
                    DatagridHeaderComponent,
                    DatagridColumnDirective,
                    DatagridCellEditorDirective,
                    DatagridCellEditableDirective,
                    DatagridRowHoverDirective,
                    DatagridResizeColumnDirective,
                    TextboxEditorComponent,
                    FormatCellDataPipe,
                    RowDataIdPipe,
                    ReplaceXPipe,
                    FieldValuePipe,
                    CellTootipMessagePipe,
                    ShowRequiredStarPipe,
                    DatagridCellTooltipDirective,
                    DatagridFilterToolbarComponent,
                    RowIsSelectedPipe,
                    RowIsCheckedPipe,
                    DatagridRowDblClickDirective,
                    FooterCellStylerDirective,
                    DragColumnDirective,
                    DropColumnDirective,
                    FilterRowCreateDirective,
                    SmartFilterToolbarComponent,
                    DatagridSmartFilterModule,
                    GroupFooterRowStylerDirective,
                    FarrisContextMenuModule,
                    CellIsReadonlyPipe
                ],
                entryComponents: [
                // FilterPanelComponent
                ]
            },] }
];

export { ALLOW_EDIT_CELL_HIGHLIGHT_CLS, AutoHeightDirective, CELL_EDITING_CLS, CELL_SELECTED_CLS, CUSTOM_CELL_CLS, CUSTOM_GROUP_ROW_CLS, CUSTOM_ROW_CLS, CalculationType, ColumnFilterType, DATAGRID_REST_SERVICEE, DATAGRID_SETTING_FIELDNAME, DataGridLoadingComponent, DatagridBodyComponent, DatagridCellComponent, DatagridCellEditableDirective, DatagridCellEditorDirective, DatagridColumnDirective, DatagridComponent, DatagridFacadeService, DatagridFilterService, DatagridFilterToolbarComponent, DatagridFooterComponent, DatagridHeaderComponent, DatagridModule, DatagridPagerComponent, DatagridResizeColumnDirective, DatagridRowDblClickDirective, DatagridRowDirective, DatagridRowHoverDirective, DatagridRowsComponent, DatagridService, DatagridSmartFilterComponent, DatagridSmartFilterModule, DatagridSmartFilterService, Utils as DatagridUtils, DomHandler, DragColumnDirective, DragDropColumnService, DropColumnDirective, FIXED_LEFT_SHADOW_CLS, FIXED_RIGHT_SHADOW_CLS, FilterRowCreateDirective, FooterCellStylerDirective, GRID_EDITORS, GRID_FILTER_ROW, GRID_SETTINGS_HTTP, GRID_SETTINGS_PANEL, GRID_SETTINGS_SERVICE, GRID_VALIDATORS, GridCellEditorDirective, GroupFooterRowStylerDirective, HeaderStyleDirective, NgxPaginationModule, PagerSelectedListComponent, PaginationService, ROW_HOVER_CLS, ROW_SELECTED_CLS, RestService, SCROLLBAR_CONFIG, SCROLL_DOWN_ACTION, SCROLL_LEFT_ACTION, SCROLL_RIGHT_ACTION, SCROLL_UP_ACTION, SCROLL_X_ACTION, SCROLL_X_REACH_END_ACTION, SCROLL_X_REACH_START_ACTION, SCROLL_Y_ACTION, SCROLL_Y_REACH_END_ACTION, SCROLL_Y_REACH_START_ACTION, SIZE_TYPE, ScrollbarArrowsComponent, ScrollbarComponent, ScrollbarDirective, ScrollbarModule, SelectedItemPipe, SmartFilterToolbarComponent, TR_ID_PREFIX, TR_PREFIX, TextboxEditorComponent, ValidatorMessagerService, WORDWRAP_ROW_HEIGHT_CLS, defaultPaginationInfo, SafePipe as ɵa, FormatCellDataPipe as ɵb, RowDataIdPipe as ɵc, FormatGroupRowPipe as ɵd, ShowRequiredStarPipe as ɵe, FieldValuePipe as ɵf, ReplaceXPipe as ɵg, DisableRowPipe as ɵh, SelectedRowPipe as ɵi, CellIsReadonlyPipe as ɵj, CellTootipMessagePipe as ɵk, FixedLeftRowsComponent as ɵl, DatagridCheckboxComponent as ɵm, DatagridHeaderCheckboxComponent as ɵn, DatagridGroupRowDirective as ɵo, DatagridCellTooltipDirective as ɵp, AutoHeightComponent as ɵq, RowIsSelectedPipe as ɵr, ɵs, DatagridErrorHandler as ɵt, RowIsCheckedPipe as ɵu };
//# sourceMappingURL=farris-ui-datagrid.js.map
