/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Optional, Pipe } from '@angular/core';
import { DatagridFacadeService } from './../services/datagrid-facade.service';
var FormatGroupRowPipe = /** @class */ (function () {
    function FormatGroupRowPipe(dfs) {
        this.dfs = dfs;
    }
    /**
     * @param {?} row
     * @param {?} col
     * @param {?=} fn
     * @return {?}
     */
    FormatGroupRowPipe.prototype.transform = /**
     * @param {?} row
     * @param {?} col
     * @param {?=} fn
     * @return {?}
     */
    function (row, col, fn) {
        if (row) {
            /** @type {?} */
            var val = row['value'];
            if (!col && this.dfs) {
                col = this.dfs.getColumn(row.field);
            }
            if (col && col.formatter) {
                if (col.formatter.type === 'enum') {
                    /** @type {?} */
                    var enumOpts = col.formatter.options;
                    var _a = tslib_1.__assign({}, enumOpts), valueField_1 = _a.valueField, textField = _a.textField, data = _a.data;
                    /** @type {?} */
                    var enumItem = data.find((/**
                     * @param {?} item
                     * @return {?}
                     */
                    function (item) { return item[valueField_1] === row['value']; }));
                    val = enumItem ? enumItem[textField] : '';
                }
            }
            return fn ? fn(row) : val;
        }
        return '';
    };
    FormatGroupRowPipe.decorators = [
        { type: Pipe, args: [{ name: 'formatGroupRow' },] }
    ];
    /** @nocollapse */
    FormatGroupRowPipe.ctorParameters = function () { return [
        { type: DatagridFacadeService, decorators: [{ type: Optional }] }
    ]; };
    return FormatGroupRowPipe;
}());
export { FormatGroupRowPipe };
if (false) {
    /**
     * @type {?}
     * @private
     */
    FormatGroupRowPipe.prototype.dfs;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0LWdyb3VwLXJvdy5waXBlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZhcnJpcy91aS1kYXRhZ3JpZC8iLCJzb3VyY2VzIjpbImxpYi91dGlscy9mb3JtYXQtZ3JvdXAtcm93LnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDOUQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFFOUU7SUFHSSw0QkFBZ0MsR0FBMEI7UUFBMUIsUUFBRyxHQUFILEdBQUcsQ0FBdUI7SUFBRyxDQUFDOzs7Ozs7O0lBRzlELHNDQUFTOzs7Ozs7SUFBVCxVQUFVLEdBQVEsRUFBRSxHQUFRLEVBQUUsRUFBUTtRQUNsQyxJQUFJLEdBQUcsRUFBRTs7Z0JBQ0QsR0FBRyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUM7WUFDdEIsSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNsQixHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3ZDO1lBRUQsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLFNBQVMsRUFBRTtnQkFDdEIsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUU7O3dCQUN6QixRQUFRLEdBQXVELEdBQUcsQ0FBQyxTQUFTLENBQUMsT0FBTztvQkFDcEYsSUFBQSxtQ0FBK0MsRUFBN0MsNEJBQVUsRUFBRSx3QkFBUyxFQUFFLGNBQXNCOzt3QkFDL0MsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJOzs7O29CQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsSUFBSSxDQUFDLFlBQVUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBakMsQ0FBaUMsRUFBQztvQkFDckUsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7aUJBQzdDO2FBQ0o7WUFFRCxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7U0FDN0I7UUFFRCxPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7O2dCQTFCSixJQUFJLFNBQUMsRUFBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUM7Ozs7Z0JBRnJCLHFCQUFxQix1QkFLYixRQUFROztJQXdCekIseUJBQUM7Q0FBQSxBQTNCRCxJQTJCQztTQTFCWSxrQkFBa0I7Ozs7OztJQUVmLGlDQUE4QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wdGlvbmFsLCBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERhdGFncmlkRmFjYWRlU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZGF0YWdyaWQtZmFjYWRlLnNlcnZpY2UnO1xyXG5cclxuQFBpcGUoe25hbWU6ICdmb3JtYXRHcm91cFJvdyd9KVxyXG5leHBvcnQgY2xhc3MgRm9ybWF0R3JvdXBSb3dQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSBkZnM6IERhdGFncmlkRmFjYWRlU2VydmljZSkge31cclxuXHJcblxyXG4gICAgdHJhbnNmb3JtKHJvdzogYW55LCBjb2w6IGFueSwgZm4/OiBhbnkpOiBhbnkge1xyXG4gICAgICAgIGlmIChyb3cpIHtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IHJvd1sndmFsdWUnXTtcclxuICAgICAgICAgICAgaWYgKCFjb2wgJiYgdGhpcy5kZnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbCA9IHRoaXMuZGZzLmdldENvbHVtbihyb3cuZmllbGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29sICYmIGNvbC5mb3JtYXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2wuZm9ybWF0dGVyLnR5cGUgPT09ICdlbnVtJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1PcHRzOiB7dmFsdWVGaWVsZDogc3RyaW5nLCB0ZXh0RmllbGQ6IHN0cmluZywgZGF0YTogYW55fSA9IGNvbC5mb3JtYXR0ZXIub3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlRmllbGQsIHRleHRGaWVsZCwgZGF0YSB9ID0gey4uLmVudW1PcHRzfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtSXRlbSA9IGRhdGEuZmluZChpdGVtID0+IGl0ZW1bdmFsdWVGaWVsZF0gPT09IHJvd1sndmFsdWUnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZW51bUl0ZW0gPyBlbnVtSXRlbVt0ZXh0RmllbGRdIDogJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmbiA/IGZuKHJvdykgOiB2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn1cclxuIl19