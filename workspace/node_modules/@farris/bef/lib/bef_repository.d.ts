import { Injector } from '@angular/core';
import { Observable } from 'rxjs';
import { Entity, AppContext } from '@farris/devkit';
import { DeprecatedBefRepository } from './deprecated/deprecated_bef_repository';
import { BefEntityManager } from './bef_entity_manager';
import { BefVariableManager } from './bef_variable_manager';
import { BefDataService } from './bef_data_service';
import { BefProxy } from './bef_proxy';
import { ChangeDetail } from './types';
/**
 * BEF实体仓储
 * @description
 * 负责与后端的业务实体框架交互，管理业务实体数据 \
 * apiUri示例如下：api/scm/sd/v1.0/empservice，前后均不带斜杠
 */
declare abstract class BefRepository<T extends Entity> extends DeprecatedBefRepository<T> {
    private injector;
    private befProxy;
    /**
     * @member {BefProxy} proxy
     * @description 每一个BefRepository都需要一个Bef代理，用来处理http请求
     */
    proxy: BefProxy;
    /**
     * 实体管理器
     * @internal
     */
    entityManager: BefEntityManager<T>;
    /**
     * 变量管理器
     * @internal
     */
    variableManager: BefVariableManager;
    appContext: AppContext;
    /**
     * 取数服务
     * @internal
     */
    protected dataService: BefDataService<T>;
    serverUri: string;
    /**
     * @param injector 依赖注入器
     */
    constructor(injector: Injector);
    /**
     * 获取实体列表
     * @param filter 过滤条件
     * @param sort 排序条件
     * @param pageSize 分页大小
     * @param pageIndex 页码
     * @description
     * 过滤条件的示例如下：（一般由筛选条件等组件生成，直接获取并传值即可）
     * ```json
     * [
     *   {
     *     "FilterField": "DomainID.DomainID_name",
     *     "Compare": 0,
     *     "Value": "人力资源部",
     *     "Relation": 1,
     *     "Expresstype": 0,
     *     "Lbracket": "(",
     *     "Rbracket": ")"
     *   }, {
     *     "FilterField": "BillDate",
     *     "Compare": 3,
     *     "Value": "2021-09-03",
     *     "Relation": 1,
     *     "Expresstype": 0
     *   }, {
     *     "FilterField": "BillDate",
     *     "Compare": 5,
     *     "Value": "2021-10-05",
     *     "Relation": 1,
     *     "Expresstype": 0
     *   }
     * ]
     * ```
     * 使用示例：
     * ```typescript
     * // 一般会以字符串的形式获取到过滤和排序条件，所以需要进行解析
     * const query$ = this.repository.getEntities(JSON.parse(filter), JSON.parse(sort), null, null);
     * ```
     */
    getEntities(filter: any[], sort: any[], pageSize: number | null, pageIndex: number | null): Observable<T[]>;
    /**
     * 获取实体列表
     * @param filter 过滤条件
     * @param sorts 排序条件
     * @param pageSize 分页大小
     * @param pageIndex 页码
     * @description
     * 与getEntities方法功能相近，用法相同 \
     * 区别是在发送请求时，本方法会将查询条件放到请求的body中，而getEntities方法会将查询条件扩展到请求的url上
     * @see {@link getEntities}
     */
    filter(filter: any[], sorts: any[], pageSize: number | null, pageIndex: number | null): Observable<T[]>;
    /**
     * 分页查询从表/从从表数据
     * @param paths 通用路径
     * @param pageIndex 页码
     * @param pageSize 分页大小
     * @param filter 过滤条件
     * @param sort 排序
     * @todo 目前并未应用排序和过滤条件
     * @description
     * 通用路径格式为：['id:主表主键值', '主表实体属性名', 'id:从表主键值', '从表实体属性名'] \
     * 通用路径的主键值前必须含有冒号，冒号之前的"id"则可以省略（因为通用路径除了指向从表，还可以指向从表关联等等，所以必须通过冒号来区别主键值和属性名） \
     * 通用路径示例：['id:Ted', 'accounts', 'id:10816', 'logs'] 指向accounts从表下的logs从从表 \
     * paths参数遵从通用路径的格式，并且指向一个从表（或者从从表） \
     * 使用示例：
     * ```typescript
     * // 将绑定路径下当前行的路径转换为Entity可识别的通用路径
     * const fullPaths = EntityPathConverter.toEntityPathArray(this.viewModel.bindingPath, this.bindingData);
     * const paths = fullPaths.slice(0, fullPaths.length - 1);
     * const bindingPaths = this.viewModel.bindingPath.split('/').filter(item => item);
     * const bindingData = this.viewModel.bindingData;
     * let nodeCode = bindingPaths[bindingPaths.length - 1];
     * nodeCode = nodeCode.substr(0, nodeCode.length - 1);
     * // 获取上级实体
     * const parentPaths = bindingPaths.slice(0, bindingPaths.length - 1);
     * const parentObject = bindingData.getValue(parentPaths) as BindingObject;
     * if (!parentObject) {
     *   throw new Error('上级实体不存在');
     * }
     * const configPath = `/${nodeCode}_${parentObject[parentObject.primaryKey]}`;
     * // 获取绑定路径对应的分页信息
     * const { pageIndex = 1, pageSize } = this.repository.entityCollection.getPaginationConfigByPath(configPath);
     * const request$ = this.repository.queryChild(paths, pageIndex, pageSize);
     * ```
     */
    queryChild(paths: string[], pageIndex: number, pageSize: number, filter?: string, sort?: string): Observable<any>;
    /**
    * 获取主键为id的实体
    * @param id 主表实体主键
    * @description
    * 获取主表上对应主键的实体，调用该方法成功后实体仓库中仅包含这一个实体 \
    * 如果仅仅想要将对应id的实体同步为服务器上的值，请调用 {@link updateEntityById} 方法
    */
    getEntityById(id: string): Observable<T>;
    /**
     * 更新实体数据
     * @param id 主表实体主键
     * @description
     * 重新从服务器获取主表上对应主键的实体数据 \
     * 使用示例：
     * ```typescript
     * const rootDataId = this.bindingData.list.currentId;
     * return this.repository.updateEntityById(rootDataId);
     * ```
     */
    updateEntityById(id: string): Observable<T>;
    /**
     * 更新实体数据并加锁
     * @param id 主表实体主键
     * @description
     * 使用示例：
     * ```typescript
     * id = this.bindingData.list.currentId;  // 编辑当前行
     * const edit$ = this.repository.editEntityById(id);
     * ```
     */
    editEntityById(id: string): Observable<T>;
    /**
     * 创建实体
     * @param defaultValue 默认值，JSON对象
     * @description
     * 请求创建一个新的实体，并加载到实体仓库（加载后仓库中只会有这一个实体，适用于卡片） \
     * 使用示例：
     * ```typescript
     * // 在创建新实体后进入编辑状态
     * const create$ = this.repository.createEntity();
     * create$.pipe(
     *   tap(() => {
     *       EditStateUtil.setEditState(this.frameContext, lastModifiedId);
     *   })
     * );
     * ```
     */
    createEntity(defaultValue?: any): Observable<T>;
    /**
     * 追加实体
     * @param defaultValue 默认值
     * @description 请求创建一个新的实体，并追加到实体仓库（适用于列表）
     */
    appendEntity(defaultValue?: any): Observable<T>;
    /**
     * 创建并插入新实体（向主表插入）
     * @param position 插入位置
     * @param defaultValue 默认值
     * @description
     * 关于插入位置，可选值：1或-1，1代表在当前行后，-1代表在当前行前
     */
    insert(position: 1 | -1, defaultValue?: any): Observable<any>;
    /**
     * 创建子实体并插入到指定位置（向从表或从从表插入）
     * @param path 父路径
     * @param position 插入位置
     * @description
     * 关于父路径格式，从表形如："/1/edus"，从从表形如："/1/edus/12/grades" \
     * 父路径是由实体主键值和实体属性名成对拼接而成的字符串（用斜杠分隔），指向要插入的那张表 \
     * 父路径与实体通用路径是相似的，区别主要是格式上的不同，父路径是字符串而不是数组，主键值前面不需要加冒号，父路径必须指向从表而实体通用路径还可以指向实体的普通属性或者关联 \
     * 插入位置参考 {@link insert} \
     * 使用示例：
     * ```typescript
     * // 我们可以通过bindingPath以及bindingData计算拼接出当前行所属从表的父路径
     * const append$ = this.repository.insertByPath(path, position);
     * ```
     */
    insertByPath(path: string, position: 1 | -1): Observable<any>;
    /**
     * 创建子实体并追加到末尾
     * @param fpath 父路径
     * @description
     * 父路径格式参考 {@link insertByPath}
     */
    appendEntityByPath(fpath: string): Observable<Entity>;
    /**
     * 根据id删除实体
     * @param id 主表实体主键
     * @param ifSave 是否保存，可选，默认为true
     * @description
     * 如果ifSave传递为false，则会添加一个删除变更，等待以后保存
     */
    removeEntityById(id: string, ifSave?: boolean): Observable<boolean>;
    /**
     * 根据id删除实体并执行保存
     * @param id 主表实体主键
     */
    removeEntityAndSaveById(id: string): Observable<boolean>;
    /**
     * 根据id删除父路径下子表中的实体
     * @param fpath 父路径
     * @param id 实体主键
     * @description
     * 父路径格式参考 {@link insertByPath}
     */
    removeEntityByPath(fpath: string, id: string): Observable<boolean>;
    /**
     * 根据ids批量删除实体
     * @param ids ids
     * @param ifSave 是否保存(默认为false)
     */
    batchRemove(ids: string[], ifSave?: boolean): Observable<any>;
    /**
     * 批量删除子级实体
     * @param fPath 父路径
     * @param ids 子级id集合
     * @description
     * ids中各个id之间以逗号分隔，父路径格式参考 {@link insertByPath} \
     * 使用示例：
     * ```typescript
     * // ids字符串可以从表单变量UIState中获取，列表组件的勾选状态变化后会自动更新表单变量
     * const remove$ = this.repository.batchRemoveByPath(path, ids);
     * ```
     */
    batchRemoveByPath(fPath: string, ids: string): Observable<boolean>;
    /**
     * 保存主键为id的实体
     * @param id 主表实体主键
     * @description
     * 调用该方法会应用id对应实体上的变更 \
     * ```typescript
     * const id = this.bindingData.list.currentId as string;
     * const save$ = this.repository.saveEntityById(id);  // 向服务器提交变更并应用
     * ```
     */
    saveEntityById(id: string): Observable<boolean>;
    /**
     * 批量保存
     * @description
     * 应用所有变更，比如调用了 {@link removeEntityById} 且未保存则可以通过此方法保存 \
     * 在列表服务中，我们可以通过调用该方法实现列表数据的批量保存
     */
    saveEntities(): Observable<boolean>;
    /**
     * 取消实体变更
     * @description 清空所有实体变更，不希望保存变更时调用此方法
     */
    cancelEntityChanges(): Observable<boolean>;
    /**
     * 批量新增从表/从从表数据
     * @param path 父路径，参考 {@link insertByPath}
     * @param defaultValues 默认实体数据数组
     * @description
     * 后端接口只支持批量新增子表，批量新增主表目前不支持
     */
    batchAppendByPath(path: string, defaultValues: Array<any>): Observable<any>;
    /**
     * 批量新增主表数据
     * @param defaultValues 默认实体数据数组
     */
    batchAppend(defaultValues: Array<any>): Observable<any>;
    /**
     * 清空Repositoy内的数据和变量
     * @description 清空所有实体、变量，并清空BeSessionId
     */
    reset(): void;
    /**
     * 获取Injector（外部请勿使用）
     * @internal
     */
    getInjector(): Injector;
    /**
     * 清空vo变量变更
     */
    clearAllVariableChanges(changeDetail: ChangeDetail): void;
    /**
     * 检查当前业务上下文内是否存在未保存的变更
     * @returns
     */
    hasChanges(): Observable<any>;
}
export { BefRepository };
