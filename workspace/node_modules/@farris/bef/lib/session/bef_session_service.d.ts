import { Injector } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';
import { FrameworkSessionService } from '../framework_session_service';
declare class BefSessionService {
    beBaseUri: string;
    /**
     * Session处理策略类
     */
    private handlingStrategy;
    private injector;
    /**
     * 构造函数
     * @summary
     * 产品部存在new BeSessionService()的场景，injector可能为空，必须要兼容。
     */
    constructor(httpClient: HttpClient, beBaseUri: string, frmSessionService: FrameworkSessionService, injector?: Injector);
    /**
     * 获取token
     */
    readonly token: string;
    /**
     * 获取BeSessionId
     */
    getBeSessionId(): Observable<string>;
    /**
     * 设置sessionId
     * @param sessionId sessionId
     */
    setBeSessionId(sessionId: string): void;
    /**
     * 清空BeSessionId
     */
    clearBeSessionId(): void;
    /**
     * 扩展请求header
     */
    extendRequestHeaders(headers: HttpHeaders, runtimeContext?: any): HttpHeaders;
    /**
     * 处理响应header
     */
    handleResponseHeaders(headers: HttpHeaders): void;
    /**
     * 创建BeSessionId
     * @deprecated
     * 不再提供封装，请自行调用EAPI上的createSession方法。
     * @summary
     * 1、兼容产品部直接new BeSessionService()，并调用该方法的场景；
     * 2、此场景肯定是BefSeparatedSessionHandlingStrategy.
     */
    createBeSession(): Observable<string>;
    private setSessionId;
    /**
     * 创建BeSession处理策略
     * @summary session处理策略
     *
     * 1、开发自己实例化BefSessionService，使用老的模式（分开创建session），判断的标准是有没有injector
     *
     * 2、老表单，使用老的模式（兼容老的模式，分开创建session），判断的标准是有`injector`，但`没有注入策略`
     *
     * 3、新表单，使用用户设置的模式（单表单：使用统一session，组合表单：使用分开的session）
     */
    private createHandlingStrategy;
}
export { BefSessionService };
