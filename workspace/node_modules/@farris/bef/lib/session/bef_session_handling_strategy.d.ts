import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';
import { FrameworkSessionService } from '../framework_session_service';
import { BeSessionStorageStrategy } from './bef_session_storage_strategy';
import { Injector } from '@angular/core';
/**
 * BefSession处理策略类
 */
declare abstract class BefSessionHandlingStrategy {
    /**
     * 存储策略
     */
    protected storageStrategy: BeSessionStorageStrategy;
    /**
     * 框架Session服务
     */
    protected frmSessionService: FrameworkSessionService;
    /**
     * 框架SessionId（用户的或者功能菜单的）
     */
    protected getFrmSessionId(runtimeContext?: any): string;
    protected readonly frmSessionId: string;
    /**
     * 构造函数
     */
    constructor(storageStrategy: BeSessionStorageStrategy, frmSessionService: FrameworkSessionService);
    /**
     * 获取SessionId
     */
    abstract getSessionId(): Observable<string>;
    abstract setSessionId(sessionId: any): void;
    abstract clearSessionId(): void;
    abstract extendRequestHeaders(headers: HttpHeaders, runtimeContext?: any): HttpHeaders;
    abstract handleReponseHeaders(headers: HttpHeaders): void;
    protected abstract getSessionStorageKey(runtimeContext?: any): string;
    /**
     * 获取框架SessionId
     */
    getFrameworkSessionId(runtimeContext?: any): string;
    /**
     * 从缓存中获取BeSession
     */
    protected getSessionIdFromStorage(runtimeContext?: any): string;
}
/**
 * 隔离的BeSession处理策略（此策略必须保证injector为null的情况下正常影讯性）
 * @summary
 * ----------------------------------------
 * 处理原则：
 * 1、通过createSession创建；
 * 2、每个Repository拥有独立的BeSession；
 * 3、访问BE的EAPI时，通过header里的SessionId传递；
 * ----------------------------------------
 * 兼容性考虑：
 * 1、有产品部直接new BeSessionService()，没有传递
 */
declare class BefSeparatedSessionHandlingStrategy extends BefSessionHandlingStrategy {
    private injector;
    /**
     * 创建Session的的EAPI地址
     */
    private beSessionUri;
    /**
     * httpClient
     */
    private httpClient;
    private httpService;
    /**
     * 构造函数
     */
    constructor(storageStrategy: BeSessionStorageStrategy, frmSessionService: FrameworkSessionService, httpClient: HttpClient, beBaseUri: string, injector: Injector);
    /**
     * 获取BeSessionId
     */
    getSessionId(): Observable<string>;
    /**
     * 设置BeSessionId
     */
    setSessionId(sessionId: string): void;
    /**
     * 清空Sessionid
     */
    clearSessionId(): void;
    /**
     * 扩展Session相关头信息
     */
    extendRequestHeaders(headers: HttpHeaders, runtimeContext?: any): HttpHeaders;
    /**
     * 处理服务器端返回的headers
     */
    handleReponseHeaders(headers: HttpHeaders): void;
    /**
     * 创建BeSessionId
     */
    createSession(): Observable<string>;
    extendHttpHeader(): void;
    /**
     * 获取某个Repository对应的BeSession的唯一key
     * @summary
     * 1、在使用独立BeSession的组合表单中，需要通过BeSessionUri隔离；
     * 2、在Debug模式下，FrmSessionId=UserSessionid，如果只用它作key，
     */
    protected getSessionStorageKey(runtimeContext?: any): string;
}
declare class BefUnifiedSessionHandlingStrategy extends BefSessionHandlingStrategy {
    /**
     * 创建Session的的EAPI地址
     */
    private beSessionUri;
    private injector;
    /**
     * 构造函数
     */
    constructor(storageStrategy: BeSessionStorageStrategy, frmSessionService: FrameworkSessionService, beBaseUri: string, injector: Injector);
    getSessionId(): Observable<string>;
    /**
     * 设置BeSessionId
     */
    setSessionId(sessionId: string): void;
    /**
     * 清空Sessionid
     */
    clearSessionId(): void;
    /**
     * 扩展Session相关头信息
     */
    extendRequestHeaders(headers: HttpHeaders, runtimeContext?: any): HttpHeaders;
    /**
     * 处理服务器端返回的headers
     */
    handleReponseHeaders(headers: HttpHeaders): void;
    /**
     * 获取某个Repository对应的BeSession的唯一key
     * @summary
     */
    protected getSessionStorageKey(runtimeContext?: any): string;
}
export { BefSessionHandlingStrategy, BefSeparatedSessionHandlingStrategy, BefUnifiedSessionHandlingStrategy };
