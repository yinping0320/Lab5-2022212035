import { Injectable, Injector } from "@angular/core";
import { BigNumber } from 'bignumber.js';
import { AppContext, FrameContext, Repository, ENTITY_TEMPLATE, ResolveService, ExpressionUtil, ExpressionExecutor } from "@farris/devkit";
import { of } from "rxjs";
export class ExpressionService {
    constructor(injector, resolveService, frameContext, expressionExecutor) {
        this.injector = injector;
        this.resolveService = resolveService;
        this.frameContext = frameContext;
        this.expressionExecutor = expressionExecutor;
    }
    /**
     * 执行表达式计算
     * @param expression 表达式
     * @param customContext 自定义上下文
     * @returns
     */
    execute(expression, customContext) {
        const deps = this.resolveService.resolve(expression);
        const groupDependencies = ExpressionUtil.getGroupFunctionDependency(expression, this.frameContext.repository.entityTypeInfo);
        const entityContext = this.buildEntityContext(deps, groupDependencies);
        const stateContext = this.buildStateContext();
        const context = Object.assign({ [this.entityOriginalNodeCode]: entityContext }, stateContext, { BigNumber, frameContext: this.frameContext, bindingData: this.frameContext.bindingData, repository: this.frameContext.repository }, customContext);
        return this.expressionExecutor.eval(expression, context);
    }
    /**
     * 执行表达式（返回可观察对象）
     * @param expression 表达式
     * @param customContext 自定义上下文
     * @returns
     */
    executeAsync(expression, customContext) {
        const result = this.execute(expression, customContext);
        return of(result);
    }
    /**
     * 构造实体上下文
     * @param deps
     * @param groupDependencies
     * @param context
     * @returns
     */
    buildEntityContext(deps, groupDependencies, context) {
        let isGroupdMainEntity = false;
        deps.forEach((dep) => {
            const isEntityDependency = this.isEntityDependency(dep);
            const isGroupDependency = groupDependencies.findIndex(item => item === dep) !== -1;
            // 如果依赖的是state，无需处理，现在需要确定的是返回多少实体的问题，和state没有关系
            // 表达式依赖了实体
            if (isEntityDependency) {
                // 是聚合依赖
                if (isGroupDependency) {
                    const dependencyLength = dep.split('/').filter(p => p).length - 1;
                    if (dependencyLength === 1) {
                        // 聚合了主表字段，所有主表数据都需要参与运算，此时已经确定计算的实体上下文了。
                        isGroupdMainEntity = true;
                    }
                    else {
                        // 聚合了子表字段，只需要传递当前实体
                    }
                }
                else {
                    // 当前依赖不是聚合，只需要传递当前实体
                }
            }
        });
        const data = this.getEntity();
        if (isGroupdMainEntity) {
            const collection = this.frameContext.repository.entityCollection.toJSON();
            data['__type__'] = 'List';
            data['__items__'] = collection;
        }
        return data;
    }
    /**
     * 是否为实体依赖
     * @param dep
     * @returns
     */
    isEntityDependency(dep) {
        return dep.startsWith(ENTITY_TEMPLATE);
    }
    /**
     * 获取实体
     * @param event
     * @returns
     */
    getEntity() {
        const entityTypeInfo = this.frameContext.repository.entityTypeInfo;
        const bindingData = this.frameContext.bindingData;
        const childrenEntityPaths = [];
        ExpressionUtil.getChildrenEntityPaths(entityTypeInfo, childrenEntityPaths);
        const entity = this.frameContext.bindingData.list.currentItem.toJSON();
        entity['__type__'] = 'Entity';
        if (!childrenEntityPaths || childrenEntityPaths.length < 1) {
            return entity;
        }
        // 找到所有子表
        childrenEntityPaths.forEach((paths) => {
            const row = ExpressionUtil.getCurrentRowByPaths(paths, bindingData);
            if (row) {
                const propertyName = paths.pop();
                let parent = paths.reduce((object, path) => {
                    return object && object[path] || null;
                }, entity);
                const node = Object.assign({ __items__: [...parent[propertyName]] }, row, { __type__: 'List' });
                parent[propertyName] = node;
            }
        });
        return entity;
    }
    /**
     * 获取主实体原始字段名
     */
    get entityOriginalNodeCode() {
        const repository = this.injector.get(Repository);
        return repository && repository.entityTypeInfo && repository.entityTypeInfo.entityInfo && repository.entityTypeInfo.entityInfo.originalCode || null;
    }
    /**
     * 构造变量上下文
     * @param event
     * @returns
     */
    buildStateContext() {
        const ns = this.frameContext.namespace;
        const appContext = this.injector.get(AppContext, null);
        const frameContexts = appContext.frameContextManager.getFrameContextsByNamespace(ns);
        const result = {};
        if (frameContexts && frameContexts.length > 0) {
            const anonymousFrameContext = frameContexts[0];
            const rootFrameContext = anonymousFrameContext.getVirtualRootFrameContext();
            if (rootFrameContext) {
                const uiState = rootFrameContext.viewModel.uiState;
                const propertyNames = Object.getOwnPropertyNames(uiState) || [];
                propertyNames.forEach((prop) => {
                    if (prop.match(/^[a-zA-Z0-9_\$]+$/g) !== null) {
                        result[prop] = uiState[prop];
                    }
                });
            }
        }
        return result;
    }
}
ExpressionService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ExpressionService.ctorParameters = () => [
    { type: Injector },
    { type: ResolveService },
    { type: FrameContext },
    { type: ExpressionExecutor }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbl9zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZhcnJpcy9jb21tYW5kLXNlcnZpY2VzLyIsInNvdXJjZXMiOlsibGliL2V4cHJlc3Npb25fc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNJLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFHdEMsTUFBTSxPQUFPLGlCQUFpQjtJQUM1QixZQUFvQixRQUFrQixFQUFVLGNBQThCLEVBQVUsWUFBMEIsRUFBVSxrQkFBc0M7UUFBOUksYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUFVLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUFVLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBQVUsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtJQUFJLENBQUM7SUFDdks7Ozs7O09BS0c7SUFDSSxPQUFPLENBQUMsVUFBa0IsRUFBRSxhQUF1QztRQUN4RSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNyRCxNQUFNLGlCQUFpQixHQUFHLGNBQWMsQ0FBQywwQkFBMEIsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDN0gsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQ3ZFLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxp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ZSwgSW5qZWN0b3IgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xyXG5pbXBvcnQgeyBBcHBDb250ZXh0LCBGcmFtZUNvbnRleHQsIFJlcG9zaXRvcnksIEVOVElUWV9URU1QTEFURSwgUmVzb2x2ZVNlcnZpY2UsIEV4cHJlc3Npb25VdGlsLCBFeHByZXNzaW9uRXhlY3V0b3IgfSBmcm9tIFwiQGZhcnJpcy9kZXZraXRcIjtcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tIFwicnhqc1wiO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRXhwcmVzc2lvblNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLCBwcml2YXRlIHJlc29sdmVTZXJ2aWNlOiBSZXNvbHZlU2VydmljZSwgcHJpdmF0ZSBmcmFtZUNvbnRleHQ6IEZyYW1lQ29udGV4dCwgcHJpdmF0ZSBleHByZXNzaW9uRXhlY3V0b3I6IEV4cHJlc3Npb25FeGVjdXRvcikgeyB9XHJcbiAgLyoqXHJcbiAgICog5omn6KGM6KGo6L6+5byP6K6h566XXHJcbiAgICogQHBhcmFtIGV4cHJlc3Npb24g6KGo6L6+5byPXHJcbiAgICogQHBhcmFtIGN1c3RvbUNvbnRleHQg6Ieq5a6a5LmJ5LiK5LiL5paHXHJcbiAgICogQHJldHVybnMgXHJcbiAgICovXHJcbiAgcHVibGljIGV4ZWN1dGUoZXhwcmVzc2lvbjogc3RyaW5nLCBjdXN0b21Db250ZXh0PzogeyBbcHJvcDogc3RyaW5nXTogYW55IH0pOiBhbnkge1xyXG4gICAgY29uc3QgZGVwcyA9IHRoaXMucmVzb2x2ZVNlcnZpY2UucmVzb2x2ZShleHByZXNzaW9uKTtcclxuICAgIGNvbnN0IGdyb3VwRGVwZW5kZW5jaWVzID0gRXhwcmVzc2lvblV0aWwuZ2V0R3JvdXBGdW5jdGlvbkRlcGVuZGVuY3koZXhwcmVzc2lvbiwgdGhpcy5mcmFtZUNvbnRleHQucmVwb3NpdG9yeS5lbnRpdHlUeXBlSW5mbyk7XHJcbiAgICBjb25zdCBlbnRpdHlDb250ZXh0ID0gdGhpcy5idWlsZEVudGl0eUNvbnRleHQoZGVwcywgZ3JvdXBEZXBlbmRlbmNpZXMpO1xyXG4gICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5idWlsZFN0YXRlQ29udGV4dCgpO1xyXG4gICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgW3RoaXMuZW50aXR5T3JpZ2luYWxOb2RlQ29kZV06IGVudGl0eUNvbnRleHQsXHJcbiAgICAgIC4uLnN0YXRlQ29udGV4dCxcclxuICAgICAgQmlnTnVtYmVyLFxyXG4gICAgICBmcmFtZUNvbnRleHQ6IHRoaXMuZnJhbWVDb250ZXh0LFxyXG4gICAgICBiaW5kaW5nRGF0YTogdGhpcy5mcmFtZUNvbnRleHQuYmluZGluZ0RhdGEsXHJcbiAgICAgIHJlcG9zaXRvcnk6IHRoaXMuZnJhbWVDb250ZXh0LnJlcG9zaXRvcnksXHJcbiAgICAgIC4uLmN1c3RvbUNvbnRleHRcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb25FeGVjdXRvci5ldmFsKGV4cHJlc3Npb24sIGNvbnRleHQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiDmiafooYzooajovr7lvI/vvIjov5Tlm57lj6/op4Llr5/lr7nosaHvvIlcclxuICAgKiBAcGFyYW0gZXhwcmVzc2lvbiDooajovr7lvI9cclxuICAgKiBAcGFyYW0gY3VzdG9tQ29udGV4dCDoh6rlrprkuYnkuIrkuIvmlodcclxuICAgKiBAcmV0dXJucyBcclxuICAgKi9cclxuICBwdWJsaWMgZXhlY3V0ZUFzeW5jKGV4cHJlc3Npb246IHN0cmluZywgY3VzdG9tQ29udGV4dD86IHsgW3Byb3A6IHN0cmluZ106IGFueSB9KTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXhlY3V0ZShleHByZXNzaW9uLCBjdXN0b21Db250ZXh0KTtcclxuICAgIHJldHVybiBvZihyZXN1bHQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiDmnoTpgKDlrp7kvZPkuIrkuIvmlodcclxuICAgKiBAcGFyYW0gZGVwcyBcclxuICAgKiBAcGFyYW0gZ3JvdXBEZXBlbmRlbmNpZXMgXHJcbiAgICogQHBhcmFtIGNvbnRleHQgXHJcbiAgICogQHJldHVybnMgXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBidWlsZEVudGl0eUNvbnRleHQoZGVwczogc3RyaW5nW10sIGdyb3VwRGVwZW5kZW5jaWVzOiBzdHJpbmdbXSwgY29udGV4dD86IHsgW3Byb3A6IHN0cmluZ106IGFueSB9KSB7XHJcbiAgICBsZXQgaXNHcm91cGRNYWluRW50aXR5ID0gZmFsc2U7XHJcbiAgICBkZXBzLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGNvbnN0IGlzRW50aXR5RGVwZW5kZW5jeSA9IHRoaXMuaXNFbnRpdHlEZXBlbmRlbmN5KGRlcCk7XHJcbiAgICAgIGNvbnN0IGlzR3JvdXBEZXBlbmRlbmN5ID0gZ3JvdXBEZXBlbmRlbmNpZXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbSA9PT0gZGVwKSAhPT0gLTE7XHJcbiAgICAgIC8vIOWmguaenOS+nei1lueahOaYr3N0YXRl77yM5peg6ZyA5aSE55CG77yM546w5Zyo6ZyA6KaB56Gu5a6a55qE5piv6L+U5Zue5aSa5bCR5a6e5L2T55qE6Zeu6aKY77yM5ZKMc3RhdGXmsqHmnInlhbPns7tcclxuICAgICAgLy8g6KGo6L6+5byP5L6d6LWW5LqG5a6e5L2TXHJcbiAgICAgIGlmIChpc0VudGl0eURlcGVuZGVuY3kpIHtcclxuICAgICAgICAvLyDmmK/ogZrlkIjkvp3otZZcclxuICAgICAgICBpZiAoaXNHcm91cERlcGVuZGVuY3kpIHtcclxuICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY3lMZW5ndGggPSBkZXAuc3BsaXQoJy8nKS5maWx0ZXIocCA9PiBwKS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgaWYgKGRlcGVuZGVuY3lMZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgLy8g6IGa5ZCI5LqG5Li76KGo5a2X5q6177yM5omA5pyJ5Li76KGo5pWw5o2u6YO96ZyA6KaB5Y+C5LiO6L+Q566X77yM5q2k5pe25bey57uP56Gu5a6a6K6h566X55qE5a6e5L2T5LiK5LiL5paH5LqG44CCXHJcbiAgICAgICAgICAgIGlzR3JvdXBkTWFpbkVudGl0eSA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDogZrlkIjkuoblrZDooajlrZfmrrXvvIzlj6rpnIDopoHkvKDpgJLlvZPliY3lrp7kvZNcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8g5b2T5YmN5L6d6LWW5LiN5piv6IGa5ZCI77yM5Y+q6ZyA6KaB5Lyg6YCS5b2T5YmN5a6e5L2TXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldEVudGl0eSgpO1xyXG4gICAgaWYgKGlzR3JvdXBkTWFpbkVudGl0eSkge1xyXG4gICAgICBjb25zdCBjb2xsZWN0aW9uID0gdGhpcy5mcmFtZUNvbnRleHQucmVwb3NpdG9yeS5lbnRpdHlDb2xsZWN0aW9uLnRvSlNPTigpO1xyXG4gICAgICBkYXRhWydfX3R5cGVfXyddID0gJ0xpc3QnO1xyXG4gICAgICBkYXRhWydfX2l0ZW1zX18nXSA9IGNvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICog5piv5ZCm5Li65a6e5L2T5L6d6LWWXHJcbiAgICogQHBhcmFtIGRlcCBcclxuICAgKiBAcmV0dXJucyBcclxuICAgKi9cclxuICBwcml2YXRlIGlzRW50aXR5RGVwZW5kZW5jeShkZXA6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIGRlcC5zdGFydHNXaXRoKEVOVElUWV9URU1QTEFURSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIOiOt+WPluWunuS9k1xyXG4gICAqIEBwYXJhbSBldmVudCBcclxuICAgKiBAcmV0dXJucyBcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0RW50aXR5KCkge1xyXG4gICAgY29uc3QgZW50aXR5VHlwZUluZm8gPSB0aGlzLmZyYW1lQ29udGV4dC5yZXBvc2l0b3J5LmVudGl0eVR5cGVJbmZvO1xyXG4gICAgY29uc3QgYmluZGluZ0RhdGEgPSB0aGlzLmZyYW1lQ29udGV4dC5iaW5kaW5nRGF0YTtcclxuICAgIGNvbnN0IGNoaWxkcmVuRW50aXR5UGF0aHMgPSBbXTtcclxuICAgIEV4cHJlc3Npb25VdGlsLmdldENoaWxkcmVuRW50aXR5UGF0aHMoZW50aXR5VHlwZUluZm8sIGNoaWxkcmVuRW50aXR5UGF0aHMpO1xyXG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5mcmFtZUNvbnRleHQuYmluZGluZ0RhdGEubGlzdC5jdXJyZW50SXRlbS50b0pTT04oKTtcclxuICAgIGVudGl0eVsnX190eXBlX18nXSA9ICdFbnRpdHknO1xyXG4gICAgaWYgKCFjaGlsZHJlbkVudGl0eVBhdGhzIHx8IGNoaWxkcmVuRW50aXR5UGF0aHMubGVuZ3RoIDwgMSkge1xyXG4gICAgICByZXR1cm4gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgLy8g5om+5Yiw5omA5pyJ5a2Q6KGoXHJcbiAgICBjaGlsZHJlbkVudGl0eVBhdGhzLmZvckVhY2goKHBhdGhzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgICBjb25zdCByb3cgPSBFeHByZXNzaW9uVXRpbC5nZXRDdXJyZW50Um93QnlQYXRocyhwYXRocywgYmluZGluZ0RhdGEpO1xyXG4gICAgICBpZiAocm93KSB7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lID0gcGF0aHMucG9wKCk7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IHBhdGhzLnJlZHVjZSgob2JqZWN0OiBhbnksIHBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3RbcGF0aF0gfHwgbnVsbDtcclxuICAgICAgICB9LCBlbnRpdHkpO1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB7IF9faXRlbXNfXzogWy4uLnBhcmVudFtwcm9wZXJ0eU5hbWVdXSwgLi4ucm93LCBfX3R5cGVfXzogJ0xpc3QnIH07XHJcbiAgICAgICAgcGFyZW50W3Byb3BlcnR5TmFtZV0gPSBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBlbnRpdHk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIOiOt+WPluS4u+WunuS9k+WOn+Wni+Wtl+auteWQjVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXQgZW50aXR5T3JpZ2luYWxOb2RlQ29kZSgpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgcmVwb3NpdG9yeSA9IHRoaXMuaW5qZWN0b3IuZ2V0KFJlcG9zaXRvcnkpO1xyXG4gICAgcmV0dXJuIHJlcG9zaXRvcnkgJiYgcmVwb3NpdG9yeS5lbnRpdHlUeXBlSW5mbyAmJiByZXBvc2l0b3J5LmVudGl0eVR5cGVJbmZvLmVudGl0eUluZm8gJiYgcmVwb3NpdG9yeS5lbnRpdHlUeXBlSW5mby5lbnRpdHlJbmZvLm9yaWdpbmFsQ29kZSB8fCBudWxsO1xyXG4gIH1cclxuICAvKipcclxuICAgKiDmnoTpgKDlj5jph4/kuIrkuIvmlodcclxuICAgKiBAcGFyYW0gZXZlbnQgXHJcbiAgICogQHJldHVybnMgXHJcbiAgICovXHJcbiAgcHVibGljIGJ1aWxkU3RhdGVDb250ZXh0KCkge1xyXG4gICAgY29uc3QgbnMgPSB0aGlzLmZyYW1lQ29udGV4dC5uYW1lc3BhY2U7XHJcbiAgICBjb25zdCBhcHBDb250ZXh0ID0gdGhpcy5pbmplY3Rvci5nZXQ8QXBwQ29udGV4dD4oQXBwQ29udGV4dCwgbnVsbCk7XHJcbiAgICBjb25zdCBmcmFtZUNvbnRleHRzID0gYXBwQ29udGV4dC5mcmFtZUNvbnRleHRNYW5hZ2VyLmdldEZyYW1lQ29udGV4dHNCeU5hbWVzcGFjZShucyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIGlmIChmcmFtZUNvbnRleHRzICYmIGZyYW1lQ29udGV4dHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBhbm9ueW1vdXNGcmFtZUNvbnRleHQgPSBmcmFtZUNvbnRleHRzWzBdO1xyXG4gICAgICBjb25zdCByb290RnJhbWVDb250ZXh0ID0gYW5vbnltb3VzRnJhbWVDb250ZXh0LmdldFZpcnR1YWxSb290RnJhbWVDb250ZXh0KCk7XHJcbiAgICAgIGlmIChyb290RnJhbWVDb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgdWlTdGF0ZSA9IHJvb3RGcmFtZUNvbnRleHQudmlld01vZGVsLnVpU3RhdGU7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHVpU3RhdGUpIHx8IFtdO1xyXG4gICAgICAgIHByb3BlcnR5TmFtZXMuZm9yRWFjaCgocHJvcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBpZiAocHJvcC5tYXRjaCgvXlthLXpBLVowLTlfXFwkXSskL2cpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHVpU3RhdGVbcHJvcF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59Il19