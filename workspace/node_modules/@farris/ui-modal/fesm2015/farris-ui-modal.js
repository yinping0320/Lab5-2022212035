import { DomSanitizer } from '@angular/platform-browser';
import { of, fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { Utils, isBs3, document as document$1, window as window$1 } from '@farris/ui-modal/utils';
import { CommonUtils } from '@farris/ui-common';
import { Injectable, Component, ElementRef, Renderer2, Directive, Injector, Input, HostListener, ViewChild, Output, EventEmitter, TemplateRef, ViewChildren, HostBinding, RendererFactory2, NgZone, ChangeDetectorRef, Optional, ViewContainerRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PerfectScrollbarModule } from '@farris/ui-perfect-scrollbar';
import { AngularDraggableDirective, AngularDraggableModule } from '@farris/ui-draggable';
import { PositioningService } from '@farris/ui-modal/positioning';
import { ComponentLoaderFactory } from '@farris/ui-modal/component-loader';
import { FAreaResponseModule } from '@farris/ui-area-response';
import { FarrisTooltipModule } from '@farris/ui-tooltip';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsModalRef {
    constructor() {
        /**
         * Hides the modal
         */
        this.close = Function;
    }
}
BsModalRef.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalOptions {
}
ModalOptions.decorators = [
    { type: Injectable }
];
/** @type {?} */
const modalConfigDefaults = {
    backdrop: 'static',
    keyboard: true,
    focus: true,
    show: false,
    ignoreBackdropClick: true,
    class: '',
    animated: true,
    initialState: {},
    width: 400,
    height: 350,
    minHeight: null,
    minWidth: null,
    maxHeight: null,
    maxWidth: null,
    title: 'Title is here.',
    showCloseButton: true,
    showMaxButton: true,
    showButtons: true,
    buttonAlign: 'center',
    draggable: true,
    resizable: true,
    enableScroll: true,
    beforeOpen: (/**
     * @return {?}
     */
    () => of(true)),
    beforeClose: (/**
     * @return {?}
     */
    () => of(true)),
    okText: '确定',
    cancelText: '取消',
    dialogHeaderHeight: 38,
    dialogFooterHeight: 50,
    dialogType: 'default',
    showHeader: true,
    fitContent: false,
    areaResponse: false
};
/** @type {?} */
const CLASS_NAME = {
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    IN: 'in',
    // bs3
    SHOW: 'show' // bs4
};
/** @type {?} */
const TRANSITION_DURATIONS = {
    MODAL: 300,
    BACKDROP: 150
};
/** @type {?} */
const DISMISS_REASONS = {
    BACKRDOP: 'backdrop-click',
    ESC: 'esc'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component will be added as background layout for modals if enabled
 */
class ModalBackdropComponent {
    /**
     * @param {?} element
     * @param {?} renderer
     */
    constructor(element, renderer) {
        this._isShown = false;
        this.element = element;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    get isAnimated() {
        return this._isAnimated;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isAnimated(value) {
        this._isAnimated = value;
        // this.renderer.setElementClass(this.element.nativeElement, `${ClassName.FADE}`, value);
    }
    /**
     * @return {?}
     */
    get isShown() {
        return this._isShown;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isShown(value) {
        this._isShown = value;
        if (value) {
            this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.IN}`);
        }
        else {
            this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.IN}`);
        }
        if (!isBs3()) {
            if (value) {
                this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);
            }
            else {
                this.renderer.removeClass(this.element.nativeElement, `${CLASS_NAME.SHOW}`);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isAnimated) {
            this.renderer.addClass(this.element.nativeElement, `${CLASS_NAME.FADE}`);
            Utils.reflow(this.element.nativeElement);
        }
        this.isShown = true;
    }
}
ModalBackdropComponent.decorators = [
    { type: Component, args: [{
                selector: 'bs-modal-backdrop',
                template: ' ',
                host: { class: CLASS_NAME.BACKDROP }
            }] }
];
/** @nocollapse */
ModalBackdropComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalButtonDirective {
    /**
     * @param {?} injector
     * @param {?} el
     */
    constructor(injector, el) {
        this.injector = injector;
        this.el = el;
        this.visable = true;
    }
    /**
     * @param {?} disable
     * @return {?}
     */
    setDisabled(disable) {
        this.el.nativeElement.disabled = disable;
    }
    /**
     * @return {?}
     */
    show() {
        this.visable = true;
    }
    /**
     * @return {?}
     */
    hide() {
        this.visable = false;
    }
}
ModalButtonDirective.decorators = [
    { type: Directive, args: [{ selector: '[modal-button]' },] }
];
/** @nocollapse */
ModalButtonDirective.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef }
];
ModalButtonDirective.propDecorators = {
    visable: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalContainerComponent {
    /**
     * @param {?} options
     * @param {?} el
     * @param {?} _renderer
     * @param {?} sanitizer
     */
    constructor(options, el, _renderer, sanitizer) {
        this.el = el;
        this._renderer = _renderer;
        this.sanitizer = sanitizer;
        this.isShown = false;
        // 是否非模态窗口
        this.isModeless = false;
        this.isModalHiding = false;
        // 记录上次的高度
        this.isMax = false;
        this.closed = new EventEmitter();
        this.opened = new EventEmitter();
        this.resized = new EventEmitter();
        this.modalID = `MODALID_${Date.now().toPrecision()}`;
        this._windowResizeToMax = false;
        this.windowResize$ = null;
        this.config = Object.assign({}, options);
        if (!this.config.buttons) {
            this.config.buttons = [
                {
                    text: '取消',
                    cls: 'btn btn-light',
                    iconCls: 'k-icon k-i-close',
                    handle: (/**
                     * @return {?}
                     */
                    () => {
                        this.close();
                    })
                },
                {
                    text: '确定',
                    cls: 'btn btn-primary',
                    iconCls: 'k-icon k-i-check',
                    handle: (/**
                     * @return {?}
                     */
                    () => { alert('好(｡･∀･)ﾉﾞ嗨哟!!'); })
                }
            ];
        }
        this.setIsModeless();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set iframe(value) {
        if (this.sanitizer) {
            this.iframeSrc = this.sanitizer.bypassSecurityTrustResourceUrl(value);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.isModeless) {
            // 如果是非模态窗口
            this.boundsElement = null;
            this._renderer.addClass(this.el.nativeElement, 'f-modal-is-modeless');
        }
        else {
            this.boundsElement = this.el.nativeElement;
        }
        if (this.config.fitContent) {
            this._renderer.addClass(this.el.nativeElement, 'f-modal-fitContent');
        }
        if (this.isAnimated) {
            this._renderer.addClass(this.el.nativeElement, CLASS_NAME.FADE);
        }
        // this.ngZone.runOutsideAngular(() => {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.isShown = true;
            this._renderer.addClass(this.el.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
            if (this.isModeless) {
                this._renderer.setStyle(this.el.nativeElement, 'position', 'static');
            }
            this._renderer.setStyle(this.el.nativeElement, 'display', 'block');
            if (this.config.fitContent && this.el.nativeElement.className.indexOf('f-modal-fitContent-scroll') > -1) {
                this.el.nativeElement.scrollTop = 0;
            }
            if (document && document.body) {
                /** @type {?} */
                const modalLen = this.bsModalService.getModalsCount();
                if (modalLen === 1) {
                    this.bsModalService.checkScrollbar();
                    this.bsModalService.setScrollbar();
                }
                if (!document.body.classList.contains(CLASS_NAME.OPEN)) {
                    this._renderer.addClass(document.body, CLASS_NAME.OPEN);
                }
            }
            this.opened.emit({ modal: this });
        }), this.isAnimated ? TRANSITION_DURATIONS.BACKDROP : 0);
        // });
        if (this.el.nativeElement) {
            this.el.nativeElement.focus();
        }
        this.dlgHeaderLineHeight = this.getDialogHeaderLineHeight() + 'px';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Called after ngAfterContentInit when the component's view has been initialized. Applies to components only.
        // Add 'implements AfterViewInit' to the class.
        this._renderer.setStyle(this.el.nativeElement, 'display', 'block');
        // 如果内容适应宽度
        if (this.config.fitContent) {
            /** @type {?} */
            let initElRect = this.el.nativeElement.getBoundingClientRect();
            /** @type {?} */
            let initBodySize = this.getContainerSize();
            if (initElRect.height < initBodySize.height + 30) {
                this._renderer.addClass(this.el.nativeElement, 'f-modal-fitContent-scroll');
            }
        }
        this.originalHeight = this.config.height;
        this.originalWidth = this.config.width;
        this.windowResize$ = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            /** @type {?} */
            const winWidth = window.innerWidth - 20;
            /** @type {?} */
            const winHeight = window.innerHeight - 20;
            if (this.config.width <= winWidth && this.config.height <= winHeight) {
                if (this._windowResizeToMax) {
                    this.revertDialog();
                    this._windowResizeToMax = false;
                }
                else {
                    if (this.isMax) {
                        this.maxDialog(false);
                    }
                }
            }
            else {
                if (!this.isMax) {
                    this._windowResizeToMax = true;
                    this.maxDialog();
                }
                else {
                    this.maxDialog(false);
                }
            }
            this.toCenter();
            this.moveTo(0, 0);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    getDlgElement() {
        return this.el.nativeElement.querySelector('.modal-dialog');
    }
    /**
     * @private
     * @return {?}
     */
    getDialogHeaderLineHeight() {
        if (this.config.showHeader) {
            /** @type {?} */
            const modalHeaderStyles = window.getComputedStyle(this.modalHeader.nativeElement);
            /** @type {?} */
            const paddingTop = parseInt(modalHeaderStyles.paddingTop.replace('px', ''), 10);
            /** @type {?} */
            const paddingBottom = parseInt(modalHeaderStyles.paddingBottom.replace('px', ''), 10);
            return this.config.dialogHeaderHeight - paddingTop - paddingBottom;
        }
        else {
            return 0;
        }
    }
    // 获取内容区域的尺寸
    /**
     * @return {?}
     */
    getContainerSize() {
        /** @type {?} */
        const bodyTarget = this.el.nativeElement.querySelector('.modal-body');
        /** @type {?} */
        const height = bodyTarget.offsetHeight;
        /** @type {?} */
        const width = bodyTarget.offsetWidth;
        return { width, height };
    }
    /**
     * @return {?}
     */
    buildFooterStyles() {
        /** @type {?} */
        let styles = {};
        if (this.config.dialogFooterStyles) {
            styles = Object.assign({}, styles, this.config.dialogFooterStyles);
        }
        return styles;
    }
    /**
     * @return {?}
     */
    useButtonsTemplate() {
        return this.config.buttons instanceof TemplateRef;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        /** @type {?} */
        const tag = (/** @type {?} */ (event.target));
        // if (tag.localName === 'label') {
        //     if (tag.className) {
        //         const clsList = tag.className.split(' ');
        //         if (
        //             clsList.indexOf('k-radio-label') > -1 ||
        //             clsList.indexOf('k-checkbox-label') > -1 ||
        //             clsList.indexOf('custom-control-label') > -1
        //         ) {
        //             return;
        //         }
        //     }
        // }
        // if (tag.localName === 'input' && (tag.type === 'checkbox' || tag.type === 'radio' || tag.type === 'file')) {
        //     return;
        // }
        if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || event.target !== this.el.nativeElement) {
            event.stopPropagation();
            return;
        }
        this.bsModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);
        this.close();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEsc(event) {
        if (!this.isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        /**从最后一个窗口开始关闭 */
        if (this.config.keyboard &&
            this.level === this.bsModalService.getModalsCount()) {
            this.bsModalService.setDismissReason(DISMISS_REASONS.ESC);
            this.close(event);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.isShown) {
            this.close();
        }
        if (this.windowResize$) {
            this.windowResize$.unsubscribe();
            this.windowResize$ = null;
        }
    }
    /**
     * @param {?=} e
     * @param {?=} isCloseButton
     * @return {?}
     */
    close(e, isCloseButton = false) {
        if (e && e.stopPropagation) {
            e.stopPropagation();
        }
        if (this.isModalHiding || !this.isShown) {
            return;
        }
        this.config.beforeClose(this, { event: e }).subscribe((/**
         * @param {?} r
         * @return {?}
         */
        r => {
            if (!r) {
                return false;
            }
            // 更新服务中非模态窗口的个数
            this.bsModalService.closeUpdateModelessCountByModal(this.isModeless);
            this.isModalHiding = true;
            this._renderer.removeClass(this.el.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.isShown = false;
                this.bsModalService.hide(this.level);
                this.isModalHiding = false;
                if (document && document.body && !document.querySelectorAll('.farris-modal.show').length) {
                    this._renderer.removeClass(document.body, CLASS_NAME.OPEN);
                }
                if (this.config.closed) {
                    this.config.closed(isCloseButton, { modalRef: this, event: e });
                }
                this.closed.emit(this.level);
            }), this.isAnimated ? TRANSITION_DURATIONS.MODAL : 0);
            // });
        }));
    }
    /**
     * @return {?}
     */
    toCenter() {
        /** @type {?} */
        const marginLeft = Number.parseInt('' + -this.config.width / 2);
        /** @type {?} */
        const marginTop = Number.parseInt('' + -this.config.height / 2);
        /** @type {?} */
        const dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        /** @type {?} */
        const contentEl = this.el.nativeElement.querySelector('.modal-body');
        // this._renderer.setStyle(dialogEl, 'margin-left', marginLeft);
        // this._renderer.setStyle(dialogEl, 'margin-top', marginTop);
        this._renderer.setStyle(dialogEl, 'left', `${window.innerWidth / 2 + marginLeft}px`);
        this._renderer.setStyle(dialogEl, 'top', `${window.innerHeight / 2 + marginTop}px`);
        /** @type {?} */
        let contentHeight = this.config.height - 38;
        if (this.config.showButtons) {
            contentHeight = contentHeight - 50;
        }
        if (!this.config.fitContent) {
            this._renderer.setStyle(contentEl, 'height', contentHeight + 'px');
        }
        this._renderer.setStyle(contentEl, 'overflow', 'hidden');
        this._renderer.setStyle(dialogEl, 'transform', `translate3d(0px, 0px, 0px)`);
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const container = this.getContainerSize();
            const { width: containerWidth, height: containerHeight } = container;
            this.resized.emit({ width: this.config.width, height: this.config.height, containerWidth, containerHeight });
        }));
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    moveTo(x, y) {
        /** @type {?} */
        const dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.setStyle(dialogEl, 'transform', `translate3d(${x}px, ${y}px, 0px)`);
        // this._renderer.setStyle(dialogEl, 'top', '50%');
        // this._renderer.setStyle(dialogEl, 'left', '50%');
        // const marginLeft = Number.parseInt('' + -this.config.width / 2);
        // const marginTop = Number.parseInt('' + -this.config.height / 2);
        // this._renderer.setStyle(dialogEl, 'left', `${window.innerWidth / 2 + marginLeft}px`);
        // this._renderer.setStyle(dialogEl, 'top',  `${window.innerHeight / 2 + marginTop}px`);
        this.draggbar.position = { x, y };
        this.draggbar.resetPosition();
    }
    /**
     * @param {?=} rememberPrevSize
     * @return {?}
     */
    maxDialog(rememberPrevSize = true) {
        if (rememberPrevSize) {
            this.prevWidth = this.config.width;
            this.prevHeight = this.config.height;
        }
        // this.config.width = (document.scrollingElement?document.scrollingElement:document.documentElement)['clientWidth'] - 20;
        // this.config.height = (document.scrollingElement?document.scrollingElement:document.documentElement)['clientHeight'] - 20;
        this.config.width = window.innerWidth - 20;
        this.config.height = window.innerHeight - 20;
        this.config.draggable = false;
        this.config.resizable = false;
        /** @type {?} */
        const dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.addClass(dialogEl, 'model-dialog-maximize');
        this._renderer.setStyle(dialogEl, 'top', '50%');
        this._renderer.setStyle(dialogEl, 'left', '50%');
        this.isMax = true;
        this.toCenter();
        this.moveTo(0, 0);
    }
    /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    resize(width, height) {
        if (width) {
            this.config.width = width;
        }
        if (height) {
            this.config.height = height;
        }
        /** @type {?} */
        const dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.removeClass(dialogEl, 'model-dialog-maximize');
        this.toCenter();
        this.draggbar.resetPosition();
    }
    /**
     * @param {?} el
     * @return {?}
     */
    dropdown(el) {
        // const rect = el.getBoundingClientRect();
        // this._renderer.removeStyle(el, 'margin-top');
        // this._renderer.removeStyle(el, 'margin-left');
        // this._renderer.setStyle(el, 'top', `${rect.top}px`);
        // this._renderer.setStyle(el, 'left', `${rect.left}px`);
        // this._renderer.removeStyle(el, 'transform');
        // this._renderer.removeStyle(el, '-webkit-transform');
        // this._renderer.removeStyle(el, '-ms-transform');
        // this._renderer.removeStyle(el, '-moz-transform');
        // this._renderer.removeStyle(el, '-o-transform');
    }
    /**
     * @return {?}
     */
    revertDialog() {
        this.isMax = false;
        /** @type {?} */
        const ww = window.innerWidth - 20;
        /** @type {?} */
        const wh = window.innerHeight - 20;
        this.config.width = this.prevWidth == ww ? this.originalWidth : this.prevWidth;
        this.config.height = this.prevHeight == wh ? this.originalHeight : this.prevHeight;
        if (this.config.width > ww) {
            this.config.width = ww;
        }
        if (this.config.height > wh) {
            this.config.height = wh;
        }
        this.config.draggable = true;
        this.config.resizable = true;
        /** @type {?} */
        const dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.removeClass(dialogEl, 'model-dialog-maximize');
        this.toCenter();
        this.draggbar.resetPosition();
    }
    /**
     * @return {?}
     */
    changeDialogSize() {
        if (this.isMax) {
            this.revertDialog();
        }
        else {
            this.maxDialog();
        }
        this._windowResizeToMax = false;
    }
    /**
     * @param {?} opts
     * @return {?}
     */
    resizeStop(opts) {
        // console.log('resizeStop');
        this.config.width = opts.size.width;
        this.config.height = opts.size.height;
        /** @type {?} */
        const container = this.getContainerSize();
        const { width: containerWidth, height: containerHeight } = container;
        this.resized.emit(Object.assign({}, opts.size, { containerWidth, containerHeight }));
    }
    /**
     * 是否非模态
     * @return {?}
     */
    setIsModeless() {
        if (this.config.hasOwnProperty('modeless')) {
            this.isModeless = this.config['modeless'];
        }
        else {
            this.isModeless = false;
        }
    }
    /**
     * @param {?} zIndex
     * @return {?}
     */
    updateDialogZindex(zIndex) {
        if (this.isModeless) {
            /** @type {?} */
            let modalEl = this.el.nativeElement;
            /** @type {?} */
            const dialogEl = modalEl.querySelector('.modal-dialog');
            this._renderer.setStyle(dialogEl, 'position', 'fixed');
            this._renderer.setStyle(dialogEl, 'zIndex', zIndex ? zIndex : modalEl.style.zIndex);
        }
    }
}
ModalContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'modal-container',
                template: `
    <div [attr.id]="modalID"

        [ngDraggable]="config.draggable"
        [ngResizable]="config.resizable"
        [rzMinWidth]="config.minWidth"
        [rzMaxWidth]="config.maxWidth"
        [rzMinHeight]="config.minHeight"
        [rzMaxHeight]="config.maxHeight"
        rzHandles="all" [handle]="config.showHeader ? header:dragEl"
        (stopped)="dropdown($event)"
        (rzStop)="resizeStop($event)"
        [inBounds]="true" [bounds]="boundsElement" [rzContainment]="boundsElement" [isFixed]="isModeless"
        [class]="'modal-dialog' + (config.class ? ' ' + config.class : '')" role="document"
        [style.width]="config.width + 'px'" [style.height]="config.fitContent?'auto':(config.height + 'px')"
        style="position: absolute;top: 50%;left: 50%;">
        <div class="modal-content" [ngClass]="{'modal-content--has-header':config.showHeader}">
            <div #header class="modal-header" [style.display]="config.showHeader ? '': 'none'">
                <div class="modal-title">
                    <span *ngIf="config.iconCls" [class]="config.iconCls" style="margin-right: 8px"></span>
                    <span class="modal-title-label">{{ config.title }}</span>
                </div>
                <div class="actions">
                    <ul>
                        <li *ngIf="config.showMinButton" class="f-btn-icon f-bare">
                            <span class="f-icon modal_minimize"></span></li>
                        <li *ngIf="config.showMaxButton" (click)="changeDialogSize()" class="f-btn-icon f-bare">
                            <span class="f-icon modal_maximize" [class.modalrevert]="isMax"></span>
                        </li>
                        <li *ngIf="config.showCloseButton" (click)="close($event, true)" class="f-btn-icon f-bare">
                             <span class="f-icon modal_close"></span>
                        </li>
                    </ul>
                </div>
            </div>
        <div #dragEl class="f-utils-absolute-all" style="height:10px;z-index: 1;" [style.display]="config.showHeader ? 'none': ''"></div>
            <div class="modal-body" [class.f-utils-flex-column]="dialogType === 'iframe'"   [f-area-response]="config.areaResponse">
                <perfect-scrollbar [config]="{}" [disabled]="!config.enableScroll||config.fitContent"  *ngIf="!dialogType || dialogType === 'default'">
                    <ng-content ></ng-content>
                </perfect-scrollbar>
                <iframe *ngIf="dialogType === 'iframe'" class="f-utils-fill" width="100%" frameborder="0" [src]="iframeSrc"></iframe>
            </div>

            <div [style.textAlign]="config.buttonAlign" class="modal-footer" [ngStyle]="buildFooterStyles()" *ngIf="config.showButtons && config.buttons">
                <ng-container [ngTemplateOutlet]="useButtonsTemplate() ? config.buttons : defaultButtonRef"></ng-container>
            </div>
        </div>
    </div>

    <ng-template #defaultButtonRef>

        <ng-container *ngFor="let btn of config.buttons; last as isLast">
            <button type="button" modal-button  *ngIf="btn.display === undefined && btn.tipsEnable === undefined"
                [class]="btn.cls"
                (click)="btn.handle && btn.handle($event) ">
                <span [class]="btn.iconCls" *ngIf="btn.iconCls"></span> {{ btn.text }}
            </button>

            <button type="button" modal-button  *ngIf="btn.display !== undefined || btn.tipsEnable !== undefined"
                [class]="btn.cls"
                (click)="btn.handle && btn.handle($event) " 
                [style.display]="(btn.display === true || btn.display === undefined) ? '' : 'none'"
                [farrisTooltip]="btn?.tipsEnable" [placement]="'top'" [delay]="500" [content]="btn?.tipsText">
                <span [class]="btn.iconCls" *ngIf="btn.iconCls"></span> {{ btn.text }}
            </button>

        </ng-container>

    </ng-template>
  `,
                host: {
                    class: 'modal farris-modal',
                    role: 'dialog',
                    tabindex: '-1',
                    '[attr.aria-modal]': 'true'
                }
            }] }
];
/** @nocollapse */
ModalContainerComponent.ctorParameters = () => [
    { type: ModalOptions },
    { type: ElementRef },
    { type: Renderer2 },
    { type: DomSanitizer }
];
ModalContainerComponent.propDecorators = {
    iframe: [{ type: Input }],
    draggbar: [{ type: ViewChild, args: [AngularDraggableDirective,] }],
    modalHeader: [{ type: ViewChild, args: ['header',] }],
    closed: [{ type: Output }],
    opened: [{ type: Output }],
    resized: [{ type: Output }],
    modalID: [{ type: HostBinding, args: ['id',] }],
    buttons: [{ type: ViewChildren, args: [ModalButtonDirective,] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onEsc: [{ type: HostListener, args: ['window:keydown.esc', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BsModalService {
    /**
     * @param {?} rendererFactory
     * @param {?} clf
     * @param {?} ngZone
     */
    constructor(rendererFactory, clf, ngZone) {
        this.clf = clf;
        this.ngZone = ngZone;
        this.version = '0.0.6';
        this.config = modalConfigDefaults;
        this.onShow = new EventEmitter();
        this.onShown = new EventEmitter();
        this.onHide = new EventEmitter();
        this.onHidden = new EventEmitter();
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        // 标记模态和非模态窗口的总个数
        this.modalsCount = 0;
        this.lastDismissReason = '';
        this.loaders = [];
        this._documentMouseDownHandler = null;
        this.commonUtils = null;
        // 标记非模态窗口个数
        this.modellessCount = 0;
        this._renderer = rendererFactory.createRenderer(null, null);
        this._backdropLoader = this.clf.createLoader(null, null, this._renderer);
        this.commonUtils = new CommonUtils();
    }
    /**
     * @private
     * @return {?}
     */
    clearDocumentEvents() {
        if (this._documentMouseDownHandler) {
            document.body.removeEventListener('mousedown', this._documentMouseDownHandler);
        }
        this._documentMouseDownHandler = null;
    }
    /**
     * Shows a modal
     * @param {?} content
     * @param {?=} config
     * @return {?}
     */
    show(content, config) {
        this.modalsCount++;
        this._createLoaders();
        this.config = Object.assign({}, modalConfigDefaults, config);
        this.checkDialogSize();
        if (this.isModeless()) {
            this.modellessCount++;
        }
        else {
            this._showBackdrop();
        }
        this.lastDismissReason = null;
        /** @type {?} */
        const modal = this._showModal(content);
        return modal;
    }
    /**
     * @private
     * @return {?}
     */
    isModeless() {
        if (this.config.hasOwnProperty('modeless')) {
            return this.config['modeless'];
        }
        return false;
    }
    /**
     * @param {?} level
     * @return {?}
     */
    hide(level) {
        if (this.modalsCount - this.modellessCount === 1) {
            this._hideBackdrop();
            this.resetScrollbar();
        }
        this.modalsCount = this.modalsCount >= 1 ? this.modalsCount - 1 : 0;
        // this.ngZone.runOutsideAngular(() => {
        //     setTimeout(() => {
        // this._hideModal(level);
        // this.removeLoaders(level);
        //     }, this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0);
        // });
        this._hideModal(level);
        this.removeLoaders(level);
        this.clearDocumentEvents();
    }
    /**
     * @return {?}
     */
    _showBackdrop() {
        /** @type {?} */
        const isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';
        /** @type {?} */
        const isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;
        /**
         * 此处做限定是解决【弹出多个模态窗口时，因为遮罩层的叠加，导致背景很黑】的问题
         */
        if (this.modalsCount - this.modellessCount === 1) {
            this.removeBackdrop();
            if (isBackdropEnabled && isBackdropInDOM) {
                this._backdropLoader
                    .attach(ModalBackdropComponent)
                    .to('body')
                    .show({ isAnimated: this.config.animated });
                this.backdropRef = this._backdropLoader._componentRef;
            }
        }
    }
    /**
     * @return {?}
     */
    _hideBackdrop() {
        if (!this.backdropRef) {
            return;
        }
        this.backdropRef.instance.isShown = false;
        /** @type {?} */
        const duration = this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0;
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            setTimeout((/**
             * @return {?}
             */
            () => this.removeBackdrop()), duration);
        }));
    }
    /**
     * @private
     * @param {?} _modal
     * @return {?}
     */
    updateZindex(_modal) {
        /** @type {?} */
        const maxZindex = this.commonUtils.getFloatingLayerIndex();
        // 非模态下zIndex的设置
        _modal.dialog.instance.updateDialogZindex(maxZindex);
        _modal.dialog.location.nativeElement.style.zIndex = maxZindex;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    _showModal(content) {
        /** @type {?} */
        const modalLoader = this.loaders[this.loaders.length - 1];
        /** @type {?} */
        const bsModalRef = new BsModalRef();
        /** @type {?} */
        const modalContainerRef = modalLoader
            .provide({ provide: ModalOptions, useValue: this.config })
            .provide({ provide: BsModalRef, useValue: bsModalRef })
            .attach(ModalContainerComponent)
            .to('body')
            .show({ content, isAnimated: this.config.animated,
            initialState: this.config.initialState,
            bsModalService: this
        });
        modalContainerRef.instance.level = this.getModalsCount();
        modalContainerRef.instance.dialogType = this.config.dialogType;
        modalContainerRef.instance.iframe = '';
        if (this.config.dialogType === 'iframe') {
            modalContainerRef.instance.iframe = content;
        }
        bsModalRef.close = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            modalContainerRef.instance.close(e);
            this.clearDocumentEvents();
        });
        // 如果是消息类型的，出现滚动条就不响应动画了
        if (!this.config.fitContent) {
            modalContainerRef.instance.toCenter();
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                document.body.addEventListener('mousedown', this._documentMouseDownHandler = (/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => { this._onMouseDown(e, modalContainerRef.instance.isModeless); }));
            }));
        }
        bsModalRef.content = modalLoader.getInnerComponent() || null;
        bsModalRef.dialog = modalContainerRef;
        bsModalRef.buttons = modalContainerRef.instance.buttons;
        modalContainerRef.instance['modalRef'] = bsModalRef;
        if (this.config.opened) {
            this.config.opened({ instance: bsModalRef });
        }
        this.updateZindex(bsModalRef);
        return bsModalRef;
    }
    /**
     * 增加参数，解决，在当前模态窗口内先弹出非模态再弹出Dialog时，点击外层
     * @param {?} e
     * @param {?=} curModalisModeless
     * @return {?}
     */
    _onMouseDown(e, curModalisModeless = null) {
        if (curModalisModeless) {
            /** @type {?} */
            var modalDialogEl = e.target.classList.contains('modal-dialog') ? e.target : null;
            modalDialogEl = modalDialogEl ? modalDialogEl : e.target.closest('.modal-dialog');
            if (modalDialogEl) {
                /** @type {?} */
                const maxZindex = this.commonUtils.getFloatingLayerIndex();
                modalDialogEl.style.zIndex = maxZindex;
                modalDialogEl.parentElement.style.zIndex = maxZindex;
            }
            return false;
        }
        else {
            if (e.target.localName === 'modal-container' || e.target.classList.contains('farris-modal')) {
                this._renderer.addClass(e.target, 'animated');
                this._renderer.addClass(e.target, 'shake');
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                () => {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        this._renderer.removeClass(e.target, 'animated');
                        this._renderer.removeClass(e.target, 'shake');
                    }), 650);
                }));
                return false;
            }
        }
    }
    /**
     * @param {?} level
     * @return {?}
     */
    _hideModal(level) {
        /** @type {?} */
        const modalLoader = this.loaders[level - 1];
        if (modalLoader) {
            modalLoader.hide();
        }
    }
    /**
     * @return {?}
     */
    getModalsCount() {
        return this.modalsCount;
    }
    /**
     * @return {?}
     */
    getCurrentModalContainer() {
        return this.loaders[this.getModalsCount() - 1];
    }
    /**
     * @param {?} reason
     * @return {?}
     */
    setDismissReason(reason) {
        this.lastDismissReason = reason;
    }
    /**
     * @return {?}
     */
    removeBackdrop() {
        this._backdropLoader.hide();
        this.backdropRef = null;
    }
    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @return {?}
     */
    checkScrollbar() {
        this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    }
    /**
     * @return {?}
     */
    setScrollbar() {
        if (!document) {
            return;
        }
        this.originalBodyPadding = parseInt(window
            .getComputedStyle(document.body)
            .getPropertyValue('padding-right') || '0', 10);
        if (this.isBodyOverflowing) {
            document.body.style.paddingRight = `${this.originalBodyPadding +
                this.scrollbarWidth}px`;
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetScrollbar() {
        document.body.style.paddingRight = `${this.originalBodyPadding}px`;
    }
    // thx d.walsh
    /**
     * @private
     * @return {?}
     */
    getScrollbarWidth() {
        /** @type {?} */
        const scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document.body, scrollDiv);
        /** @type {?} */
        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document.body, scrollDiv);
        return scrollbarWidth;
    }
    /**
     * @private
     * @return {?}
     */
    _createLoaders() {
        /** @type {?} */
        const loader = this.clf.createLoader(null, null, this._renderer);
        this.copyEvent(loader.onBeforeShow, this.onShow);
        this.copyEvent(loader.onShown, this.onShown);
        this.copyEvent(loader.onBeforeHide, this.onHide);
        this.copyEvent(loader.onHidden, this.onHidden);
        this.loaders.push(loader);
    }
    /**
     * @private
     * @param {?} level
     * @return {?}
     */
    removeLoaders(level) {
        this.loaders.splice(level - 1, 1);
        this.loaders.forEach((/**
         * @param {?} loader
         * @param {?} i
         * @return {?}
         */
        (loader, i) => {
            loader.instance.level = i + 1;
        }));
    }
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    copyEvent(from, to) {
        from.subscribe((/**
         * @return {?}
         */
        () => {
            to.emit(this.lastDismissReason);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    checkDialogSize() {
        /** @type {?} */
        const newSize = Utils.checkDialogSize(this.config.width, this.config.height);
        if (this.config.width !== newSize.width) {
            this.config.width = newSize.width - 20;
        }
        if (this.config.height !== newSize.height) {
            this.config.height = newSize.height - 20;
        }
    }
    /**
     * @param {?} curIsModeless
     * @return {?}
     */
    closeUpdateModelessCountByModal(curIsModeless) {
        if (curIsModeless) {
            this.modellessCount = this.modellessCount - 1 > 0 ? this.modellessCount - 1 : 0;
        }
    }
}
BsModalService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BsModalService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: ComponentLoaderFactory },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalBackdropOptions {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.animate = true;
        Object.assign(this, options);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TRANSITION_DURATION = 300;
/** @type {?} */
const BACKDROP_TRANSITION_DURATION = 150;
/**
 * Mark any code with directive to show it's content in modal
 */
class ModalDirective {
    /**
     * @param {?} _element
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @param {?} clf
     * @param {?} ngZone
     * @param {?} cd
     */
    constructor(_element, _viewContainerRef, _renderer, clf, ngZone, cd) {
        this._element = _element;
        this._renderer = _renderer;
        this.ngZone = ngZone;
        this.cd = cd;
        /**
         * This event fires immediately when the `show` instance method is called.
         */
        this.onShow = new EventEmitter();
        /**
         * This event is fired when the modal has been made visible to the user
         * (will wait for CSS transitions to complete)
         */
        this.onShown = new EventEmitter();
        /**
         * This event is fired immediately when
         * the hide instance method has been called.
         */
        this.onHide = new EventEmitter();
        /**
         * This event is fired when the modal has finished being
         * hidden from the user (will wait for CSS transitions to complete).
         */
        this.onHidden = new EventEmitter();
        this._isShown = false;
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        this.timerHideModal = 0;
        this.timerRmBackDrop = 0;
        this.isNested = false;
        this.commonUtils = null;
        this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);
        this.commonUtils = new CommonUtils();
    }
    /**
     * allows to set modal configuration via element property
     * @param {?} conf
     * @return {?}
     */
    set config(conf) {
        this._config = this.getConfig(conf);
    }
    /**
     * @return {?}
     */
    get config() {
        return this._config;
    }
    /**
     * @return {?}
     */
    get isShown() {
        return this._isShown;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        /** @type {?} */
        const tag = (/** @type {?} */ (event.target));
        // if (tag.localName === 'label') {
        //     if (tag.className) {
        //         const clsList = tag.className.split(' ');
        //         if (
        //             clsList.indexOf('k-radio-label') > -1 ||
        //             clsList.indexOf('k-checkbox-label') > -1 ||
        //             clsList.indexOf('custom-control-label') > -1
        //         ) {
        //             return;
        //         }
        //     }
        // }
        // if (tag.localName === 'input' && (tag.type === 'checkbox' || tag.type === 'radio' || tag.type === 'file')) {
        //     return;
        // }
        if (this.config.ignoreBackdropClick ||
            this.config.backdrop === 'static' ||
            event.target !== this._element.nativeElement) {
            event.stopPropagation();
            return;
        }
        this.dismissReason = DISMISS_REASONS.BACKRDOP;
        this.hide(event);
    }
    // todo: consider preventing default and stopping propagation
    /**
     * @param {?} event
     * @return {?}
     */
    onEsc(event) {
        if (!this._isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        if (this.config.keyboard) {
            this.dismissReason = DISMISS_REASONS.ESC;
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.config = void 0;
        if (this._isShown) {
            this._isShown = false;
            this.hideModal();
            this._backdrop.dispose();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._config = this._config || this.getConfig();
        // this.ngZone.runOutsideAngular(() => {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this._config.show) {
                this.show();
            }
        }), 0);
        // });
    }
    /* Public methods */
    /**
     * Allows to manually toggle modal visibility
     * @return {?}
     */
    toggle() {
        return this._isShown ? this.hide() : this.show();
    }
    /**
     * Allows to manually open modal
     * @return {?}
     */
    show() {
        this.dismissReason = null;
        this.onShow.emit(this);
        if (this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        /** @type {?} */
        const maxZindex = this.commonUtils.getFloatingLayerIndex();
        this._element.nativeElement.style.zIndex = maxZindex;
        this._isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        if (document$1 && document$1.body) {
            if (document$1.body.classList.contains(CLASS_NAME.OPEN)) {
                this.isNested = true;
            }
            else {
                this._renderer.addClass(document$1.body, CLASS_NAME.OPEN);
            }
        }
        this.showBackdrop((/**
         * @return {?}
         */
        () => {
            this.showElement();
        }));
    }
    /**
     * Allows to manually close modal
     * @param {?=} event
     * @return {?}
     */
    hide(event) {
        if (event) {
            event.preventDefault();
        }
        this.onHide.emit(this);
        // todo: add an option to prevent hiding
        if (!this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        this._isShown = false;
        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);
        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);
        // if (!isBs3()) {
        // }
        // this._addClassIn = false;
        if (this._config.animated) {
            this.timerHideModal = setTimeout((/**
             * @return {?}
             */
            () => this.hideModal()), TRANSITION_DURATION);
        }
        else {
            this.hideModal();
        }
    }
    /**
     * Private methods \@internal
     * @protected
     * @param {?=} config
     * @return {?}
     */
    getConfig(config) {
        return Object.assign({}, modalConfigDefaults, config);
    }
    /**
     *  Show dialog
     * \@internal
     * @protected
     * @return {?}
     */
    showElement() {
        // todo: replace this with component loader usage
        if (!this._element.nativeElement.parentNode ||
            this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {
            // don't move modals dom position
            if (document$1 && document$1.body) {
                document$1.body.appendChild(this._element.nativeElement);
            }
        }
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');
        this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');
        this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);
        if (this._config.animated) {
            Utils.reflow(this._element.nativeElement);
        }
        // this._addClassIn = true;
        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);
        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);
        // if (!isBs3()) {
        // }
        /** @type {?} */
        const transitionComplete = (/**
         * @return {?}
         */
        () => {
            if (this._config.focus) {
                this._element.nativeElement.focus();
            }
            this.onShown.emit(this);
        });
        if (this._config.animated) {
            // this.ngZone.runOutsideAngular(() => {
            setTimeout(transitionComplete, TRANSITION_DURATION);
            // });
        }
        else {
            transitionComplete();
        }
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    hideModal() {
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'none');
        this.showBackdrop((/**
         * @return {?}
         */
        () => {
            if (!this.isNested) {
                if (document$1 && document$1.body && !document$1.querySelectorAll('.farris-modal.show').length) {
                    this._renderer.removeClass(document$1.body, CLASS_NAME.OPEN);
                }
                this.resetScrollbar();
            }
            this.resetAdjustments();
            this.focusOtherModal();
            this.onHidden.emit(this);
        }));
    }
    // todo: original show was calling a callback when done, but we can use
    // promise
    /**
     * \@internal
     * @protected
     * @param {?=} callback
     * @return {?}
     */
    showBackdrop(callback) {
        if (this._isShown &&
            this.config.backdrop &&
            (!this.backdrop || !this.backdrop.instance.isShown)) {
            this.removeBackdrop();
            this._backdrop
                .attach(ModalBackdropComponent)
                .to('body')
                .show({ isAnimated: this._config.animated });
            this.backdrop = this._backdrop._componentRef;
            if (!callback) {
                return;
            }
            if (!this._config.animated) {
                callback();
                return;
            }
            // this.ngZone.runOutsideAngular(() => {
            setTimeout(callback, BACKDROP_TRANSITION_DURATION);
            // })
        }
        else if (!this._isShown && this.backdrop) {
            this.backdrop.instance.isShown = false;
            /** @type {?} */
            const callbackRemove = (/**
             * @return {?}
             */
            () => {
                this.removeBackdrop();
                if (callback) {
                    callback();
                }
            });
            if (this.backdrop.instance.isAnimated) {
                // this.ngZone.runOutsideAngular(() => {
                this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);
                // });
            }
            else {
                callbackRemove();
            }
        }
        else if (callback) {
            callback();
        }
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    removeBackdrop() {
        this._backdrop.hide();
    }
    /**
     * Events tricks
     * @protected
     * @return {?}
     */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    focusOtherModal() {
        if (this._element.nativeElement.parentElement == null)
            return;
        /** @type {?} */
        const otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');
        if (!otherOpenedModals.length) {
            return;
        }
        otherOpenedModals[otherOpenedModals.length - 1].focus();
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    resetAdjustments() {
        this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');
        this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');
    }
    /** Scroll bar tricks */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    checkScrollbar() {
        this.isBodyOverflowing = document$1.body.clientWidth < window$1.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    }
    /**
     * @protected
     * @return {?}
     */
    setScrollbar() {
        if (!document$1) {
            return;
        }
        this.originalBodyPadding = parseInt(window$1
            .getComputedStyle(document$1.body)
            .getPropertyValue('padding-right') || 0, 10);
        if (this.isBodyOverflowing) {
            document$1.body.style.paddingRight = `${this.originalBodyPadding +
                this.scrollbarWidth}px`;
        }
    }
    /**
     * @protected
     * @return {?}
     */
    resetScrollbar() {
        document$1.body.style.paddingRight = this.originalBodyPadding + 'px';
    }
    // thx d.walsh
    /**
     * @protected
     * @return {?}
     */
    getScrollbarWidth() {
        /** @type {?} */
        const scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document$1.body, scrollDiv);
        /** @type {?} */
        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document$1.body, scrollDiv);
        return scrollbarWidth;
    }
}
ModalDirective.decorators = [
    { type: Directive, args: [{
                selector: '[bsModal]',
                exportAs: 'bs-modal'
            },] }
];
/** @nocollapse */
ModalDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: ComponentLoaderFactory },
    { type: NgZone },
    { type: ChangeDetectorRef, decorators: [{ type: Optional }] }
];
ModalDirective.propDecorators = {
    config: [{ type: Input }],
    onShow: [{ type: Output }],
    onShown: [{ type: Output }],
    onHide: [{ type: Output }],
    onHidden: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onEsc: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: ModalModule,
            providers: [
                ComponentLoaderFactory,
                BsModalService,
                PositioningService
            ]
        };
    }
}
ModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    PerfectScrollbarModule,
                    AngularDraggableModule,
                    FAreaResponseModule,
                    FarrisTooltipModule
                ],
                declarations: [
                    ModalDirective,
                    ModalBackdropComponent,
                    ModalContainerComponent,
                    ModalButtonDirective
                ],
                exports: [
                    ModalBackdropComponent, ModalDirective
                ],
                entryComponents: [ModalBackdropComponent, ModalContainerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BsModalRef, BsModalService, ModalBackdropOptions, ModalContainerComponent, ModalBackdropComponent, ModalDirective, ModalModule, ModalButtonDirective, ModalOptions, CLASS_NAME };

//# sourceMappingURL=farris-ui-modal.js.map