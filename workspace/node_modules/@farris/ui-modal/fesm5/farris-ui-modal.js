import { __assign } from 'tslib';
import { DomSanitizer } from '@angular/platform-browser';
import { of, fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { Utils, isBs3, document as document$1, window as window$1 } from '@farris/ui-modal/utils';
import { CommonUtils } from '@farris/ui-common';
import { Injectable, Component, ElementRef, Renderer2, Directive, Injector, Input, HostListener, ViewChild, Output, EventEmitter, TemplateRef, ViewChildren, HostBinding, RendererFactory2, NgZone, ChangeDetectorRef, Optional, ViewContainerRef, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PerfectScrollbarModule } from '@farris/ui-perfect-scrollbar';
import { AngularDraggableDirective, AngularDraggableModule } from '@farris/ui-draggable';
import { PositioningService } from '@farris/ui-modal/positioning';
import { ComponentLoaderFactory } from '@farris/ui-modal/component-loader';
import { FAreaResponseModule } from '@farris/ui-area-response';
import { FarrisTooltipModule } from '@farris/ui-tooltip';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsModalRef = /** @class */ (function () {
    function BsModalRef() {
        /**
         * Hides the modal
         */
        this.close = Function;
    }
    BsModalRef.decorators = [
        { type: Injectable }
    ];
    return BsModalRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalOptions = /** @class */ (function () {
    function ModalOptions() {
    }
    ModalOptions.decorators = [
        { type: Injectable }
    ];
    return ModalOptions;
}());
/** @type {?} */
var modalConfigDefaults = {
    backdrop: 'static',
    keyboard: true,
    focus: true,
    show: false,
    ignoreBackdropClick: true,
    class: '',
    animated: true,
    initialState: {},
    width: 400,
    height: 350,
    minHeight: null,
    minWidth: null,
    maxHeight: null,
    maxWidth: null,
    title: 'Title is here.',
    showCloseButton: true,
    showMaxButton: true,
    showButtons: true,
    buttonAlign: 'center',
    draggable: true,
    resizable: true,
    enableScroll: true,
    beforeOpen: (/**
     * @return {?}
     */
    function () { return of(true); }),
    beforeClose: (/**
     * @return {?}
     */
    function () { return of(true); }),
    okText: '确定',
    cancelText: '取消',
    dialogHeaderHeight: 38,
    dialogFooterHeight: 50,
    dialogType: 'default',
    showHeader: true,
    fitContent: false,
    areaResponse: false
};
/** @type {?} */
var CLASS_NAME = {
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    IN: 'in',
    // bs3
    SHOW: 'show' // bs4
};
/** @type {?} */
var TRANSITION_DURATIONS = {
    MODAL: 300,
    BACKDROP: 150
};
/** @type {?} */
var DISMISS_REASONS = {
    BACKRDOP: 'backdrop-click',
    ESC: 'esc'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This component will be added as background layout for modals if enabled
 */
var ModalBackdropComponent = /** @class */ (function () {
    function ModalBackdropComponent(element, renderer) {
        this._isShown = false;
        this.element = element;
        this.renderer = renderer;
    }
    Object.defineProperty(ModalBackdropComponent.prototype, "isAnimated", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isAnimated;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isAnimated = value;
            // this.renderer.setElementClass(this.element.nativeElement, `${ClassName.FADE}`, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalBackdropComponent.prototype, "isShown", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isShown;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isShown = value;
            if (value) {
                this.renderer.addClass(this.element.nativeElement, "" + CLASS_NAME.IN);
            }
            else {
                this.renderer.removeClass(this.element.nativeElement, "" + CLASS_NAME.IN);
            }
            if (!isBs3()) {
                if (value) {
                    this.renderer.addClass(this.element.nativeElement, "" + CLASS_NAME.SHOW);
                }
                else {
                    this.renderer.removeClass(this.element.nativeElement, "" + CLASS_NAME.SHOW);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ModalBackdropComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.isAnimated) {
            this.renderer.addClass(this.element.nativeElement, "" + CLASS_NAME.FADE);
            Utils.reflow(this.element.nativeElement);
        }
        this.isShown = true;
    };
    ModalBackdropComponent.decorators = [
        { type: Component, args: [{
                    selector: 'bs-modal-backdrop',
                    template: ' ',
                    host: { class: CLASS_NAME.BACKDROP }
                }] }
    ];
    /** @nocollapse */
    ModalBackdropComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    return ModalBackdropComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalButtonDirective = /** @class */ (function () {
    function ModalButtonDirective(injector, el) {
        this.injector = injector;
        this.el = el;
        this.visable = true;
    }
    /**
     * @param {?} disable
     * @return {?}
     */
    ModalButtonDirective.prototype.setDisabled = /**
     * @param {?} disable
     * @return {?}
     */
    function (disable) {
        this.el.nativeElement.disabled = disable;
    };
    /**
     * @return {?}
     */
    ModalButtonDirective.prototype.show = /**
     * @return {?}
     */
    function () {
        this.visable = true;
    };
    /**
     * @return {?}
     */
    ModalButtonDirective.prototype.hide = /**
     * @return {?}
     */
    function () {
        this.visable = false;
    };
    ModalButtonDirective.decorators = [
        { type: Directive, args: [{ selector: '[modal-button]' },] }
    ];
    /** @nocollapse */
    ModalButtonDirective.ctorParameters = function () { return [
        { type: Injector },
        { type: ElementRef }
    ]; };
    ModalButtonDirective.propDecorators = {
        visable: [{ type: Input }]
    };
    return ModalButtonDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalContainerComponent = /** @class */ (function () {
    function ModalContainerComponent(options, el, _renderer, sanitizer) {
        var _this = this;
        this.el = el;
        this._renderer = _renderer;
        this.sanitizer = sanitizer;
        this.isShown = false;
        // 是否非模态窗口
        this.isModeless = false;
        this.isModalHiding = false;
        // 记录上次的高度
        this.isMax = false;
        this.closed = new EventEmitter();
        this.opened = new EventEmitter();
        this.resized = new EventEmitter();
        this.modalID = "MODALID_" + Date.now().toPrecision();
        this._windowResizeToMax = false;
        this.windowResize$ = null;
        this.config = Object.assign({}, options);
        if (!this.config.buttons) {
            this.config.buttons = [
                {
                    text: '取消',
                    cls: 'btn btn-light',
                    iconCls: 'k-icon k-i-close',
                    handle: (/**
                     * @return {?}
                     */
                    function () {
                        _this.close();
                    })
                },
                {
                    text: '确定',
                    cls: 'btn btn-primary',
                    iconCls: 'k-icon k-i-check',
                    handle: (/**
                     * @return {?}
                     */
                    function () { alert('好(｡･∀･)ﾉﾞ嗨哟!!'); })
                }
            ];
        }
        this.setIsModeless();
    }
    Object.defineProperty(ModalContainerComponent.prototype, "iframe", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.sanitizer) {
                this.iframeSrc = this.sanitizer.bypassSecurityTrustResourceUrl(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isModeless) {
            // 如果是非模态窗口
            this.boundsElement = null;
            this._renderer.addClass(this.el.nativeElement, 'f-modal-is-modeless');
        }
        else {
            this.boundsElement = this.el.nativeElement;
        }
        if (this.config.fitContent) {
            this._renderer.addClass(this.el.nativeElement, 'f-modal-fitContent');
        }
        if (this.isAnimated) {
            this._renderer.addClass(this.el.nativeElement, CLASS_NAME.FADE);
        }
        // this.ngZone.runOutsideAngular(() => {
        setTimeout((/**
         * @return {?}
         */
        function () {
            _this.isShown = true;
            _this._renderer.addClass(_this.el.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
            if (_this.isModeless) {
                _this._renderer.setStyle(_this.el.nativeElement, 'position', 'static');
            }
            _this._renderer.setStyle(_this.el.nativeElement, 'display', 'block');
            if (_this.config.fitContent && _this.el.nativeElement.className.indexOf('f-modal-fitContent-scroll') > -1) {
                _this.el.nativeElement.scrollTop = 0;
            }
            if (document && document.body) {
                /** @type {?} */
                var modalLen = _this.bsModalService.getModalsCount();
                if (modalLen === 1) {
                    _this.bsModalService.checkScrollbar();
                    _this.bsModalService.setScrollbar();
                }
                if (!document.body.classList.contains(CLASS_NAME.OPEN)) {
                    _this._renderer.addClass(document.body, CLASS_NAME.OPEN);
                }
            }
            _this.opened.emit({ modal: _this });
        }), this.isAnimated ? TRANSITION_DURATIONS.BACKDROP : 0);
        // });
        if (this.el.nativeElement) {
            this.el.nativeElement.focus();
        }
        this.dlgHeaderLineHeight = this.getDialogHeaderLineHeight() + 'px';
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Called after ngAfterContentInit when the component's view has been initialized. Applies to components only.
        // Add 'implements AfterViewInit' to the class.
        this._renderer.setStyle(this.el.nativeElement, 'display', 'block');
        // 如果内容适应宽度
        if (this.config.fitContent) {
            /** @type {?} */
            var initElRect = this.el.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var initBodySize = this.getContainerSize();
            if (initElRect.height < initBodySize.height + 30) {
                this._renderer.addClass(this.el.nativeElement, 'f-modal-fitContent-scroll');
            }
        }
        this.originalHeight = this.config.height;
        this.originalWidth = this.config.width;
        this.windowResize$ = fromEvent(window, 'resize').pipe(debounceTime(50)).subscribe((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            /** @type {?} */
            var winWidth = window.innerWidth - 20;
            /** @type {?} */
            var winHeight = window.innerHeight - 20;
            if (_this.config.width <= winWidth && _this.config.height <= winHeight) {
                if (_this._windowResizeToMax) {
                    _this.revertDialog();
                    _this._windowResizeToMax = false;
                }
                else {
                    if (_this.isMax) {
                        _this.maxDialog(false);
                    }
                }
            }
            else {
                if (!_this.isMax) {
                    _this._windowResizeToMax = true;
                    _this.maxDialog();
                }
                else {
                    _this.maxDialog(false);
                }
            }
            _this.toCenter();
            _this.moveTo(0, 0);
        }));
    };
    /**
     * @private
     * @return {?}
     */
    ModalContainerComponent.prototype.getDlgElement = /**
     * @private
     * @return {?}
     */
    function () {
        return this.el.nativeElement.querySelector('.modal-dialog');
    };
    /**
     * @private
     * @return {?}
     */
    ModalContainerComponent.prototype.getDialogHeaderLineHeight = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.config.showHeader) {
            /** @type {?} */
            var modalHeaderStyles = window.getComputedStyle(this.modalHeader.nativeElement);
            /** @type {?} */
            var paddingTop = parseInt(modalHeaderStyles.paddingTop.replace('px', ''), 10);
            /** @type {?} */
            var paddingBottom = parseInt(modalHeaderStyles.paddingBottom.replace('px', ''), 10);
            return this.config.dialogHeaderHeight - paddingTop - paddingBottom;
        }
        else {
            return 0;
        }
    };
    // 获取内容区域的尺寸
    // 获取内容区域的尺寸
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.getContainerSize = 
    // 获取内容区域的尺寸
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var bodyTarget = this.el.nativeElement.querySelector('.modal-body');
        /** @type {?} */
        var height = bodyTarget.offsetHeight;
        /** @type {?} */
        var width = bodyTarget.offsetWidth;
        return { width: width, height: height };
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.buildFooterStyles = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var styles = {};
        if (this.config.dialogFooterStyles) {
            styles = Object.assign({}, styles, this.config.dialogFooterStyles);
        }
        return styles;
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.useButtonsTemplate = /**
     * @return {?}
     */
    function () {
        return this.config.buttons instanceof TemplateRef;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ModalContainerComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var tag = (/** @type {?} */ (event.target));
        // if (tag.localName === 'label') {
        //     if (tag.className) {
        //         const clsList = tag.className.split(' ');
        //         if (
        //             clsList.indexOf('k-radio-label') > -1 ||
        //             clsList.indexOf('k-checkbox-label') > -1 ||
        //             clsList.indexOf('custom-control-label') > -1
        //         ) {
        //             return;
        //         }
        //     }
        // }
        // if (tag.localName === 'input' && (tag.type === 'checkbox' || tag.type === 'radio' || tag.type === 'file')) {
        //     return;
        // }
        if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || event.target !== this.el.nativeElement) {
            event.stopPropagation();
            return;
        }
        this.bsModalService.setDismissReason(DISMISS_REASONS.BACKRDOP);
        this.close();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ModalContainerComponent.prototype.onEsc = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        /**从最后一个窗口开始关闭 */
        if (this.config.keyboard &&
            this.level === this.bsModalService.getModalsCount()) {
            this.bsModalService.setDismissReason(DISMISS_REASONS.ESC);
            this.close(event);
        }
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.isShown) {
            this.close();
        }
        if (this.windowResize$) {
            this.windowResize$.unsubscribe();
            this.windowResize$ = null;
        }
    };
    /**
     * @param {?=} e
     * @param {?=} isCloseButton
     * @return {?}
     */
    ModalContainerComponent.prototype.close = /**
     * @param {?=} e
     * @param {?=} isCloseButton
     * @return {?}
     */
    function (e, isCloseButton) {
        var _this = this;
        if (isCloseButton === void 0) { isCloseButton = false; }
        if (e && e.stopPropagation) {
            e.stopPropagation();
        }
        if (this.isModalHiding || !this.isShown) {
            return;
        }
        this.config.beforeClose(this, { event: e }).subscribe((/**
         * @param {?} r
         * @return {?}
         */
        function (r) {
            if (!r) {
                return false;
            }
            // 更新服务中非模态窗口的个数
            _this.bsModalService.closeUpdateModelessCountByModal(_this.isModeless);
            _this.isModalHiding = true;
            _this._renderer.removeClass(_this.el.nativeElement, isBs3() ? CLASS_NAME.IN : CLASS_NAME.SHOW);
            setTimeout((/**
             * @return {?}
             */
            function () {
                _this.isShown = false;
                _this.bsModalService.hide(_this.level);
                _this.isModalHiding = false;
                if (document && document.body && !document.querySelectorAll('.farris-modal.show').length) {
                    _this._renderer.removeClass(document.body, CLASS_NAME.OPEN);
                }
                if (_this.config.closed) {
                    _this.config.closed(isCloseButton, { modalRef: _this, event: e });
                }
                _this.closed.emit(_this.level);
            }), _this.isAnimated ? TRANSITION_DURATIONS.MODAL : 0);
            // });
        }));
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.toCenter = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var marginLeft = Number.parseInt('' + -this.config.width / 2);
        /** @type {?} */
        var marginTop = Number.parseInt('' + -this.config.height / 2);
        /** @type {?} */
        var dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        /** @type {?} */
        var contentEl = this.el.nativeElement.querySelector('.modal-body');
        // this._renderer.setStyle(dialogEl, 'margin-left', marginLeft);
        // this._renderer.setStyle(dialogEl, 'margin-top', marginTop);
        this._renderer.setStyle(dialogEl, 'left', window.innerWidth / 2 + marginLeft + "px");
        this._renderer.setStyle(dialogEl, 'top', window.innerHeight / 2 + marginTop + "px");
        /** @type {?} */
        var contentHeight = this.config.height - 38;
        if (this.config.showButtons) {
            contentHeight = contentHeight - 50;
        }
        if (!this.config.fitContent) {
            this._renderer.setStyle(contentEl, 'height', contentHeight + 'px');
        }
        this._renderer.setStyle(contentEl, 'overflow', 'hidden');
        this._renderer.setStyle(dialogEl, 'transform', "translate3d(0px, 0px, 0px)");
        setTimeout((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var container = _this.getContainerSize();
            var containerWidth = container.width, containerHeight = container.height;
            _this.resized.emit({ width: _this.config.width, height: _this.config.height, containerWidth: containerWidth, containerHeight: containerHeight });
        }));
    };
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    ModalContainerComponent.prototype.moveTo = /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (x, y) {
        /** @type {?} */
        var dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.setStyle(dialogEl, 'transform', "translate3d(" + x + "px, " + y + "px, 0px)");
        // this._renderer.setStyle(dialogEl, 'top', '50%');
        // this._renderer.setStyle(dialogEl, 'left', '50%');
        // const marginLeft = Number.parseInt('' + -this.config.width / 2);
        // const marginTop = Number.parseInt('' + -this.config.height / 2);
        // this._renderer.setStyle(dialogEl, 'left', `${window.innerWidth / 2 + marginLeft}px`);
        // this._renderer.setStyle(dialogEl, 'top',  `${window.innerHeight / 2 + marginTop}px`);
        this.draggbar.position = { x: x, y: y };
        this.draggbar.resetPosition();
    };
    /**
     * @param {?=} rememberPrevSize
     * @return {?}
     */
    ModalContainerComponent.prototype.maxDialog = /**
     * @param {?=} rememberPrevSize
     * @return {?}
     */
    function (rememberPrevSize) {
        if (rememberPrevSize === void 0) { rememberPrevSize = true; }
        if (rememberPrevSize) {
            this.prevWidth = this.config.width;
            this.prevHeight = this.config.height;
        }
        // this.config.width = (document.scrollingElement?document.scrollingElement:document.documentElement)['clientWidth'] - 20;
        // this.config.height = (document.scrollingElement?document.scrollingElement:document.documentElement)['clientHeight'] - 20;
        this.config.width = window.innerWidth - 20;
        this.config.height = window.innerHeight - 20;
        this.config.draggable = false;
        this.config.resizable = false;
        /** @type {?} */
        var dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.addClass(dialogEl, 'model-dialog-maximize');
        this._renderer.setStyle(dialogEl, 'top', '50%');
        this._renderer.setStyle(dialogEl, 'left', '50%');
        this.isMax = true;
        this.toCenter();
        this.moveTo(0, 0);
    };
    /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    ModalContainerComponent.prototype.resize = /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    function (width, height) {
        if (width) {
            this.config.width = width;
        }
        if (height) {
            this.config.height = height;
        }
        /** @type {?} */
        var dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.removeClass(dialogEl, 'model-dialog-maximize');
        this.toCenter();
        this.draggbar.resetPosition();
    };
    /**
     * @param {?} el
     * @return {?}
     */
    ModalContainerComponent.prototype.dropdown = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        // const rect = el.getBoundingClientRect();
        // this._renderer.removeStyle(el, 'margin-top');
        // this._renderer.removeStyle(el, 'margin-left');
        // this._renderer.setStyle(el, 'top', `${rect.top}px`);
        // this._renderer.setStyle(el, 'left', `${rect.left}px`);
        // this._renderer.removeStyle(el, 'transform');
        // this._renderer.removeStyle(el, '-webkit-transform');
        // this._renderer.removeStyle(el, '-ms-transform');
        // this._renderer.removeStyle(el, '-moz-transform');
        // this._renderer.removeStyle(el, '-o-transform');
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.revertDialog = /**
     * @return {?}
     */
    function () {
        this.isMax = false;
        /** @type {?} */
        var ww = window.innerWidth - 20;
        /** @type {?} */
        var wh = window.innerHeight - 20;
        this.config.width = this.prevWidth == ww ? this.originalWidth : this.prevWidth;
        this.config.height = this.prevHeight == wh ? this.originalHeight : this.prevHeight;
        if (this.config.width > ww) {
            this.config.width = ww;
        }
        if (this.config.height > wh) {
            this.config.height = wh;
        }
        this.config.draggable = true;
        this.config.resizable = true;
        /** @type {?} */
        var dialogEl = this.el.nativeElement.querySelector('.modal-dialog');
        this._renderer.removeClass(dialogEl, 'model-dialog-maximize');
        this.toCenter();
        this.draggbar.resetPosition();
    };
    /**
     * @return {?}
     */
    ModalContainerComponent.prototype.changeDialogSize = /**
     * @return {?}
     */
    function () {
        if (this.isMax) {
            this.revertDialog();
        }
        else {
            this.maxDialog();
        }
        this._windowResizeToMax = false;
    };
    /**
     * @param {?} opts
     * @return {?}
     */
    ModalContainerComponent.prototype.resizeStop = /**
     * @param {?} opts
     * @return {?}
     */
    function (opts) {
        // console.log('resizeStop');
        this.config.width = opts.size.width;
        this.config.height = opts.size.height;
        /** @type {?} */
        var container = this.getContainerSize();
        var containerWidth = container.width, containerHeight = container.height;
        this.resized.emit(__assign({}, opts.size, { containerWidth: containerWidth, containerHeight: containerHeight }));
    };
    /**
     * 是否非模态
     * @returns
     */
    /**
     * 是否非模态
     * @return {?}
     */
    ModalContainerComponent.prototype.setIsModeless = /**
     * 是否非模态
     * @return {?}
     */
    function () {
        if (this.config.hasOwnProperty('modeless')) {
            this.isModeless = this.config['modeless'];
        }
        else {
            this.isModeless = false;
        }
    };
    /**
     * @param {?} zIndex
     * @return {?}
     */
    ModalContainerComponent.prototype.updateDialogZindex = /**
     * @param {?} zIndex
     * @return {?}
     */
    function (zIndex) {
        if (this.isModeless) {
            /** @type {?} */
            var modalEl = this.el.nativeElement;
            /** @type {?} */
            var dialogEl = modalEl.querySelector('.modal-dialog');
            this._renderer.setStyle(dialogEl, 'position', 'fixed');
            this._renderer.setStyle(dialogEl, 'zIndex', zIndex ? zIndex : modalEl.style.zIndex);
        }
    };
    ModalContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'modal-container',
                    template: "\n    <div [attr.id]=\"modalID\"\n\n        [ngDraggable]=\"config.draggable\"\n        [ngResizable]=\"config.resizable\"\n        [rzMinWidth]=\"config.minWidth\"\n        [rzMaxWidth]=\"config.maxWidth\"\n        [rzMinHeight]=\"config.minHeight\"\n        [rzMaxHeight]=\"config.maxHeight\"\n        rzHandles=\"all\" [handle]=\"config.showHeader ? header:dragEl\"\n        (stopped)=\"dropdown($event)\"\n        (rzStop)=\"resizeStop($event)\"\n        [inBounds]=\"true\" [bounds]=\"boundsElement\" [rzContainment]=\"boundsElement\" [isFixed]=\"isModeless\"\n        [class]=\"'modal-dialog' + (config.class ? ' ' + config.class : '')\" role=\"document\"\n        [style.width]=\"config.width + 'px'\" [style.height]=\"config.fitContent?'auto':(config.height + 'px')\"\n        style=\"position: absolute;top: 50%;left: 50%;\">\n        <div class=\"modal-content\" [ngClass]=\"{'modal-content--has-header':config.showHeader}\">\n            <div #header class=\"modal-header\" [style.display]=\"config.showHeader ? '': 'none'\">\n                <div class=\"modal-title\">\n                    <span *ngIf=\"config.iconCls\" [class]=\"config.iconCls\" style=\"margin-right: 8px\"></span>\n                    <span class=\"modal-title-label\">{{ config.title }}</span>\n                </div>\n                <div class=\"actions\">\n                    <ul>\n                        <li *ngIf=\"config.showMinButton\" class=\"f-btn-icon f-bare\">\n                            <span class=\"f-icon modal_minimize\"></span></li>\n                        <li *ngIf=\"config.showMaxButton\" (click)=\"changeDialogSize()\" class=\"f-btn-icon f-bare\">\n                            <span class=\"f-icon modal_maximize\" [class.modalrevert]=\"isMax\"></span>\n                        </li>\n                        <li *ngIf=\"config.showCloseButton\" (click)=\"close($event, true)\" class=\"f-btn-icon f-bare\">\n                             <span class=\"f-icon modal_close\"></span>\n                        </li>\n                    </ul>\n                </div>\n            </div>\n        <div #dragEl class=\"f-utils-absolute-all\" style=\"height:10px;z-index: 1;\" [style.display]=\"config.showHeader ? 'none': ''\"></div>\n            <div class=\"modal-body\" [class.f-utils-flex-column]=\"dialogType === 'iframe'\"   [f-area-response]=\"config.areaResponse\">\n                <perfect-scrollbar [config]=\"{}\" [disabled]=\"!config.enableScroll||config.fitContent\"  *ngIf=\"!dialogType || dialogType === 'default'\">\n                    <ng-content ></ng-content>\n                </perfect-scrollbar>\n                <iframe *ngIf=\"dialogType === 'iframe'\" class=\"f-utils-fill\" width=\"100%\" frameborder=\"0\" [src]=\"iframeSrc\"></iframe>\n            </div>\n\n            <div [style.textAlign]=\"config.buttonAlign\" class=\"modal-footer\" [ngStyle]=\"buildFooterStyles()\" *ngIf=\"config.showButtons && config.buttons\">\n                <ng-container [ngTemplateOutlet]=\"useButtonsTemplate() ? config.buttons : defaultButtonRef\"></ng-container>\n            </div>\n        </div>\n    </div>\n\n    <ng-template #defaultButtonRef>\n\n        <ng-container *ngFor=\"let btn of config.buttons; last as isLast\">\n            <button type=\"button\" modal-button  *ngIf=\"btn.display === undefined && btn.tipsEnable === undefined\"\n                [class]=\"btn.cls\"\n                (click)=\"btn.handle && btn.handle($event) \">\n                <span [class]=\"btn.iconCls\" *ngIf=\"btn.iconCls\"></span> {{ btn.text }}\n            </button>\n\n            <button type=\"button\" modal-button  *ngIf=\"btn.display !== undefined || btn.tipsEnable !== undefined\"\n                [class]=\"btn.cls\"\n                (click)=\"btn.handle && btn.handle($event) \" \n                [style.display]=\"(btn.display === true || btn.display === undefined) ? '' : 'none'\"\n                [farrisTooltip]=\"btn?.tipsEnable\" [placement]=\"'top'\" [delay]=\"500\" [content]=\"btn?.tipsText\">\n                <span [class]=\"btn.iconCls\" *ngIf=\"btn.iconCls\"></span> {{ btn.text }}\n            </button>\n\n        </ng-container>\n\n    </ng-template>\n  ",
                    host: {
                        class: 'modal farris-modal',
                        role: 'dialog',
                        tabindex: '-1',
                        '[attr.aria-modal]': 'true'
                    }
                }] }
    ];
    /** @nocollapse */
    ModalContainerComponent.ctorParameters = function () { return [
        { type: ModalOptions },
        { type: ElementRef },
        { type: Renderer2 },
        { type: DomSanitizer }
    ]; };
    ModalContainerComponent.propDecorators = {
        iframe: [{ type: Input }],
        draggbar: [{ type: ViewChild, args: [AngularDraggableDirective,] }],
        modalHeader: [{ type: ViewChild, args: ['header',] }],
        closed: [{ type: Output }],
        opened: [{ type: Output }],
        resized: [{ type: Output }],
        modalID: [{ type: HostBinding, args: ['id',] }],
        buttons: [{ type: ViewChildren, args: [ModalButtonDirective,] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onEsc: [{ type: HostListener, args: ['window:keydown.esc', ['$event'],] }]
    };
    return ModalContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BsModalService = /** @class */ (function () {
    function BsModalService(rendererFactory, clf, ngZone) {
        this.clf = clf;
        this.ngZone = ngZone;
        this.version = '0.0.6';
        this.config = modalConfigDefaults;
        this.onShow = new EventEmitter();
        this.onShown = new EventEmitter();
        this.onHide = new EventEmitter();
        this.onHidden = new EventEmitter();
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        // 标记模态和非模态窗口的总个数
        this.modalsCount = 0;
        this.lastDismissReason = '';
        this.loaders = [];
        this._documentMouseDownHandler = null;
        this.commonUtils = null;
        // 标记非模态窗口个数
        this.modellessCount = 0;
        this._renderer = rendererFactory.createRenderer(null, null);
        this._backdropLoader = this.clf.createLoader(null, null, this._renderer);
        this.commonUtils = new CommonUtils();
    }
    /**
     * @private
     * @return {?}
     */
    BsModalService.prototype.clearDocumentEvents = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._documentMouseDownHandler) {
            document.body.removeEventListener('mousedown', this._documentMouseDownHandler);
        }
        this._documentMouseDownHandler = null;
    };
    /** Shows a modal */
    /**
     * Shows a modal
     * @param {?} content
     * @param {?=} config
     * @return {?}
     */
    BsModalService.prototype.show = /**
     * Shows a modal
     * @param {?} content
     * @param {?=} config
     * @return {?}
     */
    function (content, config) {
        this.modalsCount++;
        this._createLoaders();
        this.config = Object.assign({}, modalConfigDefaults, config);
        this.checkDialogSize();
        if (this.isModeless()) {
            this.modellessCount++;
        }
        else {
            this._showBackdrop();
        }
        this.lastDismissReason = null;
        /** @type {?} */
        var modal = this._showModal(content);
        return modal;
    };
    /**
     * @private
     * @return {?}
     */
    BsModalService.prototype.isModeless = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.config.hasOwnProperty('modeless')) {
            return this.config['modeless'];
        }
        return false;
    };
    /**
     * @param {?} level
     * @return {?}
     */
    BsModalService.prototype.hide = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        if (this.modalsCount - this.modellessCount === 1) {
            this._hideBackdrop();
            this.resetScrollbar();
        }
        this.modalsCount = this.modalsCount >= 1 ? this.modalsCount - 1 : 0;
        // this.ngZone.runOutsideAngular(() => {
        //     setTimeout(() => {
        // this._hideModal(level);
        // this.removeLoaders(level);
        //     }, this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0);
        // });
        this._hideModal(level);
        this.removeLoaders(level);
        this.clearDocumentEvents();
    };
    /**
     * @return {?}
     */
    BsModalService.prototype._showBackdrop = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isBackdropEnabled = this.config.backdrop || this.config.backdrop === 'static';
        /** @type {?} */
        var isBackdropInDOM = !this.backdropRef || !this.backdropRef.instance.isShown;
        /**
         * 此处做限定是解决【弹出多个模态窗口时，因为遮罩层的叠加，导致背景很黑】的问题
         */
        if (this.modalsCount - this.modellessCount === 1) {
            this.removeBackdrop();
            if (isBackdropEnabled && isBackdropInDOM) {
                this._backdropLoader
                    .attach(ModalBackdropComponent)
                    .to('body')
                    .show({ isAnimated: this.config.animated });
                this.backdropRef = this._backdropLoader._componentRef;
            }
        }
    };
    /**
     * @return {?}
     */
    BsModalService.prototype._hideBackdrop = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.backdropRef) {
            return;
        }
        this.backdropRef.instance.isShown = false;
        /** @type {?} */
        var duration = this.config.animated ? TRANSITION_DURATIONS.BACKDROP : 0;
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            setTimeout((/**
             * @return {?}
             */
            function () { return _this.removeBackdrop(); }), duration);
        }));
    };
    /**
     * @private
     * @param {?} _modal
     * @return {?}
     */
    BsModalService.prototype.updateZindex = /**
     * @private
     * @param {?} _modal
     * @return {?}
     */
    function (_modal) {
        /** @type {?} */
        var maxZindex = this.commonUtils.getFloatingLayerIndex();
        // 非模态下zIndex的设置
        _modal.dialog.instance.updateDialogZindex(maxZindex);
        _modal.dialog.location.nativeElement.style.zIndex = maxZindex;
    };
    /**
     * @param {?} content
     * @return {?}
     */
    BsModalService.prototype._showModal = /**
     * @param {?} content
     * @return {?}
     */
    function (content) {
        var _this = this;
        /** @type {?} */
        var modalLoader = this.loaders[this.loaders.length - 1];
        /** @type {?} */
        var bsModalRef = new BsModalRef();
        /** @type {?} */
        var modalContainerRef = modalLoader
            .provide({ provide: ModalOptions, useValue: this.config })
            .provide({ provide: BsModalRef, useValue: bsModalRef })
            .attach(ModalContainerComponent)
            .to('body')
            .show({ content: content, isAnimated: this.config.animated,
            initialState: this.config.initialState,
            bsModalService: this
        });
        modalContainerRef.instance.level = this.getModalsCount();
        modalContainerRef.instance.dialogType = this.config.dialogType;
        modalContainerRef.instance.iframe = '';
        if (this.config.dialogType === 'iframe') {
            modalContainerRef.instance.iframe = content;
        }
        bsModalRef.close = (/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            modalContainerRef.instance.close(e);
            _this.clearDocumentEvents();
        });
        // 如果是消息类型的，出现滚动条就不响应动画了
        if (!this.config.fitContent) {
            modalContainerRef.instance.toCenter();
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                document.body.addEventListener('mousedown', _this._documentMouseDownHandler = (/**
                 * @param {?} e
                 * @return {?}
                 */
                function (e) { _this._onMouseDown(e, modalContainerRef.instance.isModeless); }));
            }));
        }
        bsModalRef.content = modalLoader.getInnerComponent() || null;
        bsModalRef.dialog = modalContainerRef;
        bsModalRef.buttons = modalContainerRef.instance.buttons;
        modalContainerRef.instance['modalRef'] = bsModalRef;
        if (this.config.opened) {
            this.config.opened({ instance: bsModalRef });
        }
        this.updateZindex(bsModalRef);
        return bsModalRef;
    };
    /**
     * 增加参数，解决，在当前模态窗口内先弹出非模态再弹出Dialog时，点击外层
     * @param e
     * @param curModalisModeless
     * @returns
     */
    /**
     * 增加参数，解决，在当前模态窗口内先弹出非模态再弹出Dialog时，点击外层
     * @param {?} e
     * @param {?=} curModalisModeless
     * @return {?}
     */
    BsModalService.prototype._onMouseDown = /**
     * 增加参数，解决，在当前模态窗口内先弹出非模态再弹出Dialog时，点击外层
     * @param {?} e
     * @param {?=} curModalisModeless
     * @return {?}
     */
    function (e, curModalisModeless) {
        var _this = this;
        if (curModalisModeless === void 0) { curModalisModeless = null; }
        if (curModalisModeless) {
            /** @type {?} */
            var modalDialogEl = e.target.classList.contains('modal-dialog') ? e.target : null;
            modalDialogEl = modalDialogEl ? modalDialogEl : e.target.closest('.modal-dialog');
            if (modalDialogEl) {
                /** @type {?} */
                var maxZindex = this.commonUtils.getFloatingLayerIndex();
                modalDialogEl.style.zIndex = maxZindex;
                modalDialogEl.parentElement.style.zIndex = maxZindex;
            }
            return false;
        }
        else {
            if (e.target.localName === 'modal-container' || e.target.classList.contains('farris-modal')) {
                this._renderer.addClass(e.target, 'animated');
                this._renderer.addClass(e.target, 'shake');
                this.ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    setTimeout((/**
                     * @return {?}
                     */
                    function () {
                        _this._renderer.removeClass(e.target, 'animated');
                        _this._renderer.removeClass(e.target, 'shake');
                    }), 650);
                }));
                return false;
            }
        }
    };
    /**
     * @param {?} level
     * @return {?}
     */
    BsModalService.prototype._hideModal = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        /** @type {?} */
        var modalLoader = this.loaders[level - 1];
        if (modalLoader) {
            modalLoader.hide();
        }
    };
    /**
     * @return {?}
     */
    BsModalService.prototype.getModalsCount = /**
     * @return {?}
     */
    function () {
        return this.modalsCount;
    };
    /**
     * @return {?}
     */
    BsModalService.prototype.getCurrentModalContainer = /**
     * @return {?}
     */
    function () {
        return this.loaders[this.getModalsCount() - 1];
    };
    /**
     * @param {?} reason
     * @return {?}
     */
    BsModalService.prototype.setDismissReason = /**
     * @param {?} reason
     * @return {?}
     */
    function (reason) {
        this.lastDismissReason = reason;
    };
    /**
     * @return {?}
     */
    BsModalService.prototype.removeBackdrop = /**
     * @return {?}
     */
    function () {
        this._backdropLoader.hide();
        this.backdropRef = null;
    };
    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /** @internal */
    /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @return {?}
     */
    BsModalService.prototype.checkScrollbar = /** AFTER PR MERGE MODAL.COMPONENT WILL BE USING THIS CODE */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @return {?}
     */
    function () {
        this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    };
    /**
     * @return {?}
     */
    BsModalService.prototype.setScrollbar = /**
     * @return {?}
     */
    function () {
        if (!document) {
            return;
        }
        this.originalBodyPadding = parseInt(window
            .getComputedStyle(document.body)
            .getPropertyValue('padding-right') || '0', 10);
        if (this.isBodyOverflowing) {
            document.body.style.paddingRight = this.originalBodyPadding +
                this.scrollbarWidth + "px";
        }
    };
    /**
     * @private
     * @return {?}
     */
    BsModalService.prototype.resetScrollbar = /**
     * @private
     * @return {?}
     */
    function () {
        document.body.style.paddingRight = this.originalBodyPadding + "px";
    };
    // thx d.walsh
    // thx d.walsh
    /**
     * @private
     * @return {?}
     */
    BsModalService.prototype.getScrollbarWidth = 
    // thx d.walsh
    /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document.body, scrollDiv);
        /** @type {?} */
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document.body, scrollDiv);
        return scrollbarWidth;
    };
    /**
     * @private
     * @return {?}
     */
    BsModalService.prototype._createLoaders = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var loader = this.clf.createLoader(null, null, this._renderer);
        this.copyEvent(loader.onBeforeShow, this.onShow);
        this.copyEvent(loader.onShown, this.onShown);
        this.copyEvent(loader.onBeforeHide, this.onHide);
        this.copyEvent(loader.onHidden, this.onHidden);
        this.loaders.push(loader);
    };
    /**
     * @private
     * @param {?} level
     * @return {?}
     */
    BsModalService.prototype.removeLoaders = /**
     * @private
     * @param {?} level
     * @return {?}
     */
    function (level) {
        this.loaders.splice(level - 1, 1);
        this.loaders.forEach((/**
         * @param {?} loader
         * @param {?} i
         * @return {?}
         */
        function (loader, i) {
            loader.instance.level = i + 1;
        }));
    };
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    BsModalService.prototype.copyEvent = /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    function (from, to) {
        var _this = this;
        from.subscribe((/**
         * @return {?}
         */
        function () {
            to.emit(_this.lastDismissReason);
        }));
    };
    /**
     * @private
     * @return {?}
     */
    BsModalService.prototype.checkDialogSize = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var newSize = Utils.checkDialogSize(this.config.width, this.config.height);
        if (this.config.width !== newSize.width) {
            this.config.width = newSize.width - 20;
        }
        if (this.config.height !== newSize.height) {
            this.config.height = newSize.height - 20;
        }
    };
    /**
     * @param {?} curIsModeless
     * @return {?}
     */
    BsModalService.prototype.closeUpdateModelessCountByModal = /**
     * @param {?} curIsModeless
     * @return {?}
     */
    function (curIsModeless) {
        if (curIsModeless) {
            this.modellessCount = this.modellessCount - 1 > 0 ? this.modellessCount - 1 : 0;
        }
    };
    BsModalService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    BsModalService.ctorParameters = function () { return [
        { type: RendererFactory2 },
        { type: ComponentLoaderFactory },
        { type: NgZone }
    ]; };
    return BsModalService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalBackdropOptions = /** @class */ (function () {
    function ModalBackdropOptions(options) {
        this.animate = true;
        Object.assign(this, options);
    }
    return ModalBackdropOptions;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var TRANSITION_DURATION = 300;
/** @type {?} */
var BACKDROP_TRANSITION_DURATION = 150;
/**
 * Mark any code with directive to show it's content in modal
 */
var ModalDirective = /** @class */ (function () {
    function ModalDirective(_element, _viewContainerRef, _renderer, clf, ngZone, cd) {
        this._element = _element;
        this._renderer = _renderer;
        this.ngZone = ngZone;
        this.cd = cd;
        /**
         * This event fires immediately when the `show` instance method is called.
         */
        this.onShow = new EventEmitter();
        /**
         * This event is fired when the modal has been made visible to the user
         * (will wait for CSS transitions to complete)
         */
        this.onShown = new EventEmitter();
        /**
         * This event is fired immediately when
         * the hide instance method has been called.
         */
        this.onHide = new EventEmitter();
        /**
         * This event is fired when the modal has finished being
         * hidden from the user (will wait for CSS transitions to complete).
         */
        this.onHidden = new EventEmitter();
        this._isShown = false;
        this.isBodyOverflowing = false;
        this.originalBodyPadding = 0;
        this.scrollbarWidth = 0;
        this.timerHideModal = 0;
        this.timerRmBackDrop = 0;
        this.isNested = false;
        this.commonUtils = null;
        this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);
        this.commonUtils = new CommonUtils();
    }
    Object.defineProperty(ModalDirective.prototype, "config", {
        get: /**
         * @return {?}
         */
        function () {
            return this._config;
        },
        /** allows to set modal configuration via element property */
        set: /**
         * allows to set modal configuration via element property
         * @param {?} conf
         * @return {?}
         */
        function (conf) {
            this._config = this.getConfig(conf);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModalDirective.prototype, "isShown", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isShown;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    ModalDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var tag = (/** @type {?} */ (event.target));
        // if (tag.localName === 'label') {
        //     if (tag.className) {
        //         const clsList = tag.className.split(' ');
        //         if (
        //             clsList.indexOf('k-radio-label') > -1 ||
        //             clsList.indexOf('k-checkbox-label') > -1 ||
        //             clsList.indexOf('custom-control-label') > -1
        //         ) {
        //             return;
        //         }
        //     }
        // }
        // if (tag.localName === 'input' && (tag.type === 'checkbox' || tag.type === 'radio' || tag.type === 'file')) {
        //     return;
        // }
        if (this.config.ignoreBackdropClick ||
            this.config.backdrop === 'static' ||
            event.target !== this._element.nativeElement) {
            event.stopPropagation();
            return;
        }
        this.dismissReason = DISMISS_REASONS.BACKRDOP;
        this.hide(event);
    };
    // todo: consider preventing default and stopping propagation
    // todo: consider preventing default and stopping propagation
    /**
     * @param {?} event
     * @return {?}
     */
    ModalDirective.prototype.onEsc = 
    // todo: consider preventing default and stopping propagation
    /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this._isShown) {
            return;
        }
        if (event.keyCode === 27) {
            event.preventDefault();
        }
        if (this.config.keyboard) {
            this.dismissReason = DISMISS_REASONS.ESC;
            this.hide();
        }
    };
    /**
     * @return {?}
     */
    ModalDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.config = void 0;
        if (this._isShown) {
            this._isShown = false;
            this.hideModal();
            this._backdrop.dispose();
        }
    };
    /**
     * @return {?}
     */
    ModalDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._config = this._config || this.getConfig();
        // this.ngZone.runOutsideAngular(() => {
        setTimeout((/**
         * @return {?}
         */
        function () {
            if (_this._config.show) {
                _this.show();
            }
        }), 0);
        // });
    };
    /* Public methods */
    /** Allows to manually toggle modal visibility */
    /* Public methods */
    /**
     * Allows to manually toggle modal visibility
     * @return {?}
     */
    ModalDirective.prototype.toggle = /* Public methods */
    /**
     * Allows to manually toggle modal visibility
     * @return {?}
     */
    function () {
        return this._isShown ? this.hide() : this.show();
    };
    /** Allows to manually open modal */
    /**
     * Allows to manually open modal
     * @return {?}
     */
    ModalDirective.prototype.show = /**
     * Allows to manually open modal
     * @return {?}
     */
    function () {
        var _this = this;
        this.dismissReason = null;
        this.onShow.emit(this);
        if (this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        /** @type {?} */
        var maxZindex = this.commonUtils.getFloatingLayerIndex();
        this._element.nativeElement.style.zIndex = maxZindex;
        this._isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        if (document$1 && document$1.body) {
            if (document$1.body.classList.contains(CLASS_NAME.OPEN)) {
                this.isNested = true;
            }
            else {
                this._renderer.addClass(document$1.body, CLASS_NAME.OPEN);
            }
        }
        this.showBackdrop((/**
         * @return {?}
         */
        function () {
            _this.showElement();
        }));
    };
    /** Allows to manually close modal */
    /**
     * Allows to manually close modal
     * @param {?=} event
     * @return {?}
     */
    ModalDirective.prototype.hide = /**
     * Allows to manually close modal
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (event) {
            event.preventDefault();
        }
        this.onHide.emit(this);
        // todo: add an option to prevent hiding
        if (!this._isShown) {
            return;
        }
        clearTimeout(this.timerHideModal);
        clearTimeout(this.timerRmBackDrop);
        this._isShown = false;
        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.IN);
        this._renderer.removeClass(this._element.nativeElement, CLASS_NAME.SHOW);
        // if (!isBs3()) {
        // }
        // this._addClassIn = false;
        if (this._config.animated) {
            this.timerHideModal = setTimeout((/**
             * @return {?}
             */
            function () { return _this.hideModal(); }), TRANSITION_DURATION);
        }
        else {
            this.hideModal();
        }
    };
    /** Private methods @internal */
    /**
     * Private methods \@internal
     * @protected
     * @param {?=} config
     * @return {?}
     */
    ModalDirective.prototype.getConfig = /**
     * Private methods \@internal
     * @protected
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        return Object.assign({}, modalConfigDefaults, config);
    };
    /**
     *  Show dialog
     *  @internal
     */
    /**
     *  Show dialog
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.showElement = /**
     *  Show dialog
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        // todo: replace this with component loader usage
        if (!this._element.nativeElement.parentNode ||
            this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {
            // don't move modals dom position
            if (document$1 && document$1.body) {
                document$1.body.appendChild(this._element.nativeElement);
            }
        }
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'false');
        this._renderer.setAttribute(this._element.nativeElement, 'aria-modal', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'block');
        this._renderer.setProperty(this._element.nativeElement, 'scrollTop', 0);
        if (this._config.animated) {
            Utils.reflow(this._element.nativeElement);
        }
        // this._addClassIn = true;
        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.IN);
        this._renderer.addClass(this._element.nativeElement, CLASS_NAME.SHOW);
        // if (!isBs3()) {
        // }
        /** @type {?} */
        var transitionComplete = (/**
         * @return {?}
         */
        function () {
            if (_this._config.focus) {
                _this._element.nativeElement.focus();
            }
            _this.onShown.emit(_this);
        });
        if (this._config.animated) {
            // this.ngZone.runOutsideAngular(() => {
            setTimeout(transitionComplete, TRANSITION_DURATION);
            // });
        }
        else {
            transitionComplete();
        }
    };
    /** @internal */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.hideModal = /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        this._renderer.setAttribute(this._element.nativeElement, 'aria-hidden', 'true');
        this._renderer.setStyle(this._element.nativeElement, 'display', 'none');
        this.showBackdrop((/**
         * @return {?}
         */
        function () {
            if (!_this.isNested) {
                if (document$1 && document$1.body && !document$1.querySelectorAll('.farris-modal.show').length) {
                    _this._renderer.removeClass(document$1.body, CLASS_NAME.OPEN);
                }
                _this.resetScrollbar();
            }
            _this.resetAdjustments();
            _this.focusOtherModal();
            _this.onHidden.emit(_this);
        }));
    };
    // todo: original show was calling a callback when done, but we can use
    // promise
    /** @internal */
    // todo: original show was calling a callback when done, but we can use
    // promise
    /**
     * \@internal
     * @protected
     * @param {?=} callback
     * @return {?}
     */
    ModalDirective.prototype.showBackdrop = 
    // todo: original show was calling a callback when done, but we can use
    // promise
    /**
     * \@internal
     * @protected
     * @param {?=} callback
     * @return {?}
     */
    function (callback) {
        var _this = this;
        if (this._isShown &&
            this.config.backdrop &&
            (!this.backdrop || !this.backdrop.instance.isShown)) {
            this.removeBackdrop();
            this._backdrop
                .attach(ModalBackdropComponent)
                .to('body')
                .show({ isAnimated: this._config.animated });
            this.backdrop = this._backdrop._componentRef;
            if (!callback) {
                return;
            }
            if (!this._config.animated) {
                callback();
                return;
            }
            // this.ngZone.runOutsideAngular(() => {
            setTimeout(callback, BACKDROP_TRANSITION_DURATION);
            // })
        }
        else if (!this._isShown && this.backdrop) {
            this.backdrop.instance.isShown = false;
            /** @type {?} */
            var callbackRemove = (/**
             * @return {?}
             */
            function () {
                _this.removeBackdrop();
                if (callback) {
                    callback();
                }
            });
            if (this.backdrop.instance.isAnimated) {
                // this.ngZone.runOutsideAngular(() => {
                this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);
                // });
            }
            else {
                callbackRemove();
            }
        }
        else if (callback) {
            callback();
        }
    };
    /** @internal */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.removeBackdrop = /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this._backdrop.hide();
    };
    /** Events tricks */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    /**
     * Events tricks
     * @protected
     * @return {?}
     */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    ModalDirective.prototype.focusOtherModal = /**
     * Events tricks
     * @protected
     * @return {?}
     */
    // no need for it
    // protected setEscapeEvent():void {
    //   if (this._isShown && this._config.keyboard) {
    //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {
    //       if (event.which === 27) {
    //         this.hide()
    //       }
    //     })
    //
    //   } else if (!this._isShown) {
    //     $(this._element).off(Event.KEYDOWN_DISMISS)
    //   }
    // }
    // protected setResizeEvent():void {
    // console.log(this.renderer.listenGlobal('', Event.RESIZE));
    // if (this._isShown) {
    //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))
    // } else {
    //   $(window).off(Event.RESIZE)
    // }
    // }
    function () {
        if (this._element.nativeElement.parentElement == null)
            return;
        /** @type {?} */
        var otherOpenedModals = this._element.nativeElement.parentElement.querySelectorAll('.in[bsModal]');
        if (!otherOpenedModals.length) {
            return;
        }
        otherOpenedModals[otherOpenedModals.length - 1].focus();
    };
    /** @internal */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.resetAdjustments = /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this._renderer.setStyle(this._element.nativeElement, 'paddingLeft', '');
        this._renderer.setStyle(this._element.nativeElement, 'paddingRight', '');
    };
    /** Scroll bar tricks */
    /** @internal */
    /** Scroll bar tricks */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.checkScrollbar = /** Scroll bar tricks */
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    function () {
        this.isBodyOverflowing = document$1.body.clientWidth < window$1.innerWidth;
        this.scrollbarWidth = this.getScrollbarWidth();
    };
    /**
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.setScrollbar = /**
     * @protected
     * @return {?}
     */
    function () {
        if (!document$1) {
            return;
        }
        this.originalBodyPadding = parseInt(window$1
            .getComputedStyle(document$1.body)
            .getPropertyValue('padding-right') || 0, 10);
        if (this.isBodyOverflowing) {
            document$1.body.style.paddingRight = this.originalBodyPadding +
                this.scrollbarWidth + "px";
        }
    };
    /**
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.resetScrollbar = /**
     * @protected
     * @return {?}
     */
    function () {
        document$1.body.style.paddingRight = this.originalBodyPadding + 'px';
    };
    // thx d.walsh
    // thx d.walsh
    /**
     * @protected
     * @return {?}
     */
    ModalDirective.prototype.getScrollbarWidth = 
    // thx d.walsh
    /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollDiv = this._renderer.createElement('div');
        this._renderer.addClass(scrollDiv, CLASS_NAME.SCROLLBAR_MEASURER);
        this._renderer.appendChild(document$1.body, scrollDiv);
        /** @type {?} */
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this._renderer.removeChild(document$1.body, scrollDiv);
        return scrollbarWidth;
    };
    ModalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[bsModal]',
                    exportAs: 'bs-modal'
                },] }
    ];
    /** @nocollapse */
    ModalDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: Renderer2 },
        { type: ComponentLoaderFactory },
        { type: NgZone },
        { type: ChangeDetectorRef, decorators: [{ type: Optional }] }
    ]; };
    ModalDirective.propDecorators = {
        config: [{ type: Input }],
        onShow: [{ type: Output }],
        onShown: [{ type: Output }],
        onHide: [{ type: Output }],
        onHidden: [{ type: Output }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onEsc: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }]
    };
    return ModalDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ModalModule = /** @class */ (function () {
    function ModalModule() {
    }
    /**
     * @return {?}
     */
    ModalModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: ModalModule,
            providers: [
                ComponentLoaderFactory,
                BsModalService,
                PositioningService
            ]
        };
    };
    ModalModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        PerfectScrollbarModule,
                        AngularDraggableModule,
                        FAreaResponseModule,
                        FarrisTooltipModule
                    ],
                    declarations: [
                        ModalDirective,
                        ModalBackdropComponent,
                        ModalContainerComponent,
                        ModalButtonDirective
                    ],
                    exports: [
                        ModalBackdropComponent, ModalDirective
                    ],
                    entryComponents: [ModalBackdropComponent, ModalContainerComponent]
                },] }
    ];
    return ModalModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BsModalRef, BsModalService, ModalBackdropOptions, ModalContainerComponent, ModalBackdropComponent, ModalDirective, ModalModule, ModalButtonDirective, ModalOptions, CLASS_NAME };

//# sourceMappingURL=farris-ui-modal.js.map