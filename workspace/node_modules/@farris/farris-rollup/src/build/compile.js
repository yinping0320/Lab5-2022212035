const angularCompiler = require('@angular/compiler-cli/src/main');
const replaceBootstrap = require('./transforms/replace_bootstrap');
const gentleFS = require('gentle-fs');
const log = require("../util/log");
const isAppPath = (fileName) =>
  !fileName.endsWith('.ngfactory.ts') && !fileName.endsWith('.ngstyle.ts');

const getEntryModule = (root, sourceRoot) => () => {
  return {
    path: root + "/" + sourceRoot + "/app/app.module",
    className: "AppModule"
  };
}

function linkNodeModules(buildConfig, callback, errorCallback) {
  if (buildConfig.options.linkedNodeModules) {
    gentleFS.linkIfExists(buildConfig.options.linkedNodeModules, './node_modules', {
      prefixes: [],
      force: true,
      base: null
    }, function (e) {
      if (e) {
        errorCallback(e);
      }
      callback();
    });
  } else {
    callback();
  }
}

let watchChanged = false;

function doCompile(root, buildConfig, reject, watchCallback) {
  //console.timeLog("doCompile","begin ");
  const args = ["-p", buildConfig.options.tsConfig];
  if (buildConfig.options.watch) {
    args.push("--watch");
  }
  angularCompiler.main(
    args,
    (s) => {
      if (buildConfig.options.watch) {
        log.info(s);
        if (s && s.indexOf(': File change detected') > -1) {
          watchChanged = true;
          console.time("farrisCompiler");
        }
        if (s && s.indexOf(': Compilation complete') > -1 && watchChanged && watchCallback) {
          console.timeEnd("farrisCompiler");
          watchCallback();
        }
      } else if (reject) {
        reject(s);
      }
    },
    null, {
    beforeTs: [
      replaceBootstrap.replaceBootstrap(
        isAppPath,
        getEntryModule(root, buildConfig.sourceRoot),
        null,
        false
      )
    ]
  });
  // console.timeLog("doCompile","completely");  
}

exports.compile = async function compile(root, buildConfig, watchCallback) {
  if (buildConfig.options.linkedNodeModules) {
    return new Promise(function (resolve, reject) {
      linkNodeModules(buildConfig,
        () => {
          let doCompileFlag = true;
          let doCompileErr;
          doCompile(root, buildConfig, (err) => {
            doCompileFlag = false;
            doCompileErr = err;
            console.log(err);
          });
          if (doCompileFlag) {
            resolve();
          } else {
            reject(doCompileErr);
          }
        },
        (e) => {
          reject(e);
        });
    });
  } else {
    return new Promise(function (resolve, reject) {
      doCompile(root, buildConfig, reject, watchCallback);
      resolve();
    });
  }
}
