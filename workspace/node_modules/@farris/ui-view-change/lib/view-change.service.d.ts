import { ViewChangeManageService } from './view-change-manage.service';
import { BehaviorSubject } from 'rxjs';
interface StoreCurrentInfo {
    guid: string;
    groupId: string;
    count: number;
}
/**
 * ximena
 * 20240301修改
 * 1、此服务原本的功能被拆分到view-change-manage.service.ts里
 * 2、解决：在框架里打开不同表单，但是分组id一样引起的切换菜单后看不到界面的问题
 * 3、方式：拆分root的服务到一个普通服务里，root服务只用来区分Module
 * ----------------------------可能问题
 *  1、存在显示隐藏切换ngIf方式切换的view-change元素，归集不到一个模块id下
 * 归集到其他的模块下，但是不影响展示
 *
 */
/**
 * ximena
 * 20240410修改
 * 上次版本修改：利用module初始化，创建单一guid，区分不同表单下的多视图。
 * 缺点：
 * 1、module只能初始化一次，后面因为缓存机制，不会再次初始化，导致第二次打开单据可能出现问题
 * 2、同一个组件被多个菜单组合不支持
 * 本次修改方案：
 * 1、通过currentInfos，存储组件创建时的guid对象，当对应的指令初始化完毕，删除这个对象
 * 2、通过BehaviorSubject，组件创建时的guid对象时，next变量currentInfos
 * 3、通过storeDirectiveInstances，解决组件和指令创建顺序先后的问题
 * 4、通过storeViewChangeCmps，解决在标签页下，指令初始化一次，多视图组件会被多次初始化，此时双方无法匹配的问题
 * 支持的场景
 * 1、同一个组件被多个菜单组合，可以正常显示
 * 2、同个表单内，多个多视图，只要组件、指令匹配，无论groupid是否一样，可以正常显示
 * 3、同个表单内，在某个多视图的指令内再嵌套其他多视图，可以正常显示
 * 4、标签页上使用时，多个多视图，可以正常显示
 */
export declare class ViewChangeService {
    /**
     * 每次view-change组件创建完会创建current对象，然后放到此处保存。
     * 当对应的指令都初始化后，开始销毁
     */
    private currentInfos;
    private current;
    private storeDirectiveInstances;
    private currentDirectiveInstance;
    private guidChangeSubject;
    private storeViewChangeSer;
    /**
     * 解决标签页上有组件和指令
     * 当组件销毁时，指令还存在，这样根据原来的逻辑找不到组件与指令的对应关系
     */
    private storeViewChangeCmps;
    constructor();
    /**
     * 获取当前模块信息
     * @param id
     */
    getModuleInfo(id?: string): ViewChangeManageService;
    /**
     * 删除对应的模块信息
     * @param id
     */
    removeModuleInfo(guid: any): void;
    /**
     * 被用于指令绑定
     * @returns
     */
    getModuleChange(): BehaviorSubject<StoreCurrentInfo[]>;
    /**
     * 创建实例
     */
    createViewChangeCmp(moduleCount: any, viewChangeCmpEl: HTMLElement): string;
    /**
     *
     */
    private findInstoreDirectiveInstances;
    /**
     * 执行指令实例的初始化
     */
    private doDirectiveInstanceInit;
    /**
     * 存储指令实例
     * @param tInstance
     */
    storeViewChangeDirectiveInstance(tInstance: any): void;
    /**
     * 移除指令实例
     * @param tInstance
     */
    removeViewChangeDirectiveInstance(viewItemType: string, guid: string): void;
    private createGuid;
    /**
     * 更新多视图组件
     * @param guid
     * @param groupId
     * @param viewChangeDirectiveEl
     */
    updatedStoreViewChangeCmp(guid: string, groupId: string, viewChangeDirectiveEl: HTMLElement): void;
    /**
     * 找两个元素的公共父元素
     * @param element1
     * @param element2
     * @returns
     */
    private findCommonParent;
    private getGuidFromStoreViewChangeCmp;
}
export {};
