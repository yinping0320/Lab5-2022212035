(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators'), require('resize-observer-polyfill'), require('@farris/ui-common'), require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@farris/ui-dropdown'), require('@farris/ui-locale')) :
    typeof define === 'function' && define.amd ? define('@farris/ui-tabs', ['exports', 'rxjs', 'rxjs/operators', 'resize-observer-polyfill', '@farris/ui-common', '@angular/core', '@angular/common', '@angular/forms', '@farris/ui-dropdown', '@farris/ui-locale'], factory) :
    (factory((global.farris = global.farris || {}, global.farris['ui-tabs'] = {}),global.rxjs,global.rxjs.operators,global.ResizeObserver,global.uiCommon,global.ng.core,global.ng.common,global.ng.forms,global.uiDropdown,global.uiLocale));
}(this, (function (exports,rxjs,operators,ResizeObserver,uiCommon,core,common,forms,uiDropdown,uiLocale) { 'use strict';

    ResizeObserver = ResizeObserver && ResizeObserver.hasOwnProperty('default') ? ResizeObserver['default'] : ResizeObserver;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TabHostDirective = /** @class */ (function () {
        function TabHostDirective(viewContainerRef) {
            this.viewContainerRef = viewContainerRef;
        }
        TabHostDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[tabHost]'
                    },] }
        ];
        /** @nocollapse */
        TabHostDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef }
            ];
        };
        return TabHostDirective;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TabConfig = /** @class */ (function () {
        function TabConfig() {
            // 是否启用下拉框
            this.showDropDown = true;
            // 是否启用提示信息
            this.showTooltips = true;
            // 点击时滚动值
            this.scrollStep = 15;
            // 是否自动重新宽度 ---- todo:此处只处理了window的resize事件
            this.autoResize = true;
            // 下拉列表最大高度 非正值表明是不高度
            this.maxDropdownH = 200;
            // 下拉列表最大宽度： 非正值表明是不限制宽度
            this.maxDropdownW = -1;
            // 标签最大宽度：非正值表明不限制宽度
            this.maxTabW = 100;
            // 提示信息条数
            this.maxTooltipLen = 5;
        }
        return TabConfig;
    }());
    var TabService = /** @class */ (function () {
        function TabService(exConfig) {
            this.config = new TabConfig();
            if (exConfig) {
                Object.assign(this.config, exConfig);
            }
        }
        /**
         * @return {?}
         */
        TabService.prototype.getConfig = /**
         * @return {?}
         */
            function () {
                return this.config;
            };
        TabService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        TabService.ctorParameters = function () {
            return [
                { type: TabConfig, decorators: [{ type: core.Optional }] }
            ];
        };
        return TabService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FarrisTabsComponent = /** @class */ (function () {
        function FarrisTabsComponent(stService, elementRef, renderer, cdRef, ngZone) {
            var _this = this;
            this.stService = stService;
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.cdRef = cdRef;
            this.ngZone = ngZone;
            this.tabType = '';
            // 支持标签页填充
            this.fill = false;
            // 支持标签页标题自适应宽度-
            this.autoTitleWidth = false;
            // 标题长度大于等于多少字符，启用渐变样式——属性废弃
            this.titleLength = 7;
            // 搜索框是否显示
            this.searchBoxVisible = true;
            // 内容是否是flex 容器 用于内部子元素flex-----未被使用
            this.contentDirection = 'column';
            this.clickThrottleTime = 350;
            this.clickItems = new rxjs.Subject();
            /**
             * 因为生成器结构变更导致此处变更
             */
            this._disableStatesDatas = new rxjs.Subject();
            // 按照之前的逻辑，如果没有找到key，就说明可见
            this._visibleDatas = new rxjs.Subject();
            // 左侧所有标签的宽度和,百分比
            this.titleWidth = 0;
            this.tabChange = new core.EventEmitter();
            this.tabRemove = new core.EventEmitter();
            // 内容填充状态
            this.contentFillStates = new rxjs.BehaviorSubject(false);
            // 宽度状态
            this.widthStates = new rxjs.BehaviorSubject(false);
            // 高度状态
            this.heightStates = new rxjs.BehaviorSubject(false);
            this.positionStates = new rxjs.BehaviorSubject('top');
            this.menuItemsWidth = 'auto';
            //maxDropdownH = 200; -----未被使用
            // 下拉列表最大宽度： 非正值表明是不限制宽度 -----未被使用
            this.maxDropdownW = -1;
            this._customClass = '';
            // 标签存储列表
            this._tabs = [];
            // 工具条显示相关配置
            this.toolbarConf = {
                position: '',
                contents: []
            };
            // 工具条右侧小下拉框是否显示
            this.toolbarDpHidden = true;
            // 工具条“更多”里的按钮
            this.inMoreButtonContents = [];
            // 显示下拉数据
            this.dropdownTabs = [];
            // 隐藏左右滚动箭头按钮
            this.hideButtons = true;
            // 隐藏下拉
            this.hideDropDown = true;
            // 禁用左箭头
            this.disableLeft = false;
            // 禁用右箭头
            this.disableRight = false;
            // 记录事件流
            this.subscription = [];
            // 禁用右侧提示
            this.disableRTooltip = true;
            // 禁用左侧提示
            this.disableLTooltip = true;
            // 左侧提示数据
            this.leftTooltipTabs = [];
            // 右侧提示数据
            this.rightTooltipTabs = [];
            this.maxTooltipLen = 5;
            // 标记当前Tab标签
            this.activeId = '';
            this.ro = null;
            this._ddmHandler = null;
            // 当宽度改变时，强制收起下拉菜单 
            this.dpState = [false];
            // 在toolbar不存在的时候先记录visible变化的地方
            this.visibleRecord = {};
            this.disableRecord = {};
            // 下拉菜单的参照元素
            this.referEl = null;
            this.tabVisibleChanged = new rxjs.Subject();
            this.el = this.elementRef.nativeElement;
            if (this.el.parentElement) {
                this.referEl = this.el.parentElement;
            }
            this.verifyConfig();
            this.subscription.push(this.tabVisibleChanged.subscribe(( /**
             * @param {?} e
             * @return {?}
             */function (e) {
                _this._reCalculateAll();
                _this._calculateToolbarDropdownIsShow();
                _this._calculateButtonsShow();
            })));
        }
        Object.defineProperty(FarrisTabsComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this._position;
            },
            // tab页位置 上下左右
            set: 
            // tab页位置 上下左右
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._position = value;
                this.positionStates.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "width", {
            // tabs宽度和高度
            set: 
            // tabs宽度和高度
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._width = this.resolveSize(value);
                this.widthStates.next(this._width);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "height", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._height = this.resolveSize(value);
                this.heightStates.next(this._height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "headerHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this._headerHeight;
            },
            set: /**
             * @param {?} headerHeight
             * @return {?}
             */ function (headerHeight) {
                this._headerHeight = this.resolveSize(headerHeight);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "contentFill", {
            // 内容是否填充  默认是不填充
            set: 
            // 内容是否填充  默认是不填充
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._contentFill = value;
                this.contentFillStates.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "btnStates", {
            set: /**
             * @param {?} values
             * @return {?}
             */ function (values) {
                if (values) {
                    if (this._disableStatesDatas &&
                        this._disableStatesDatas.hasOwnProperty("unsubscribe")) {
                        this._disableStatesDatas["unsubscribe"]();
                    }
                    this._disableStatesDatas = values;
                    this.disableStateBind();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "btnVisible", {
            // 是否可见的状态
            set: 
            // 是否可见的状态
            /**
             * @param {?} values
             * @return {?}
             */
            function (values) {
                if (values) {
                    if (this._visibleDatas &&
                        this._visibleDatas.hasOwnProperty("unsubscribe")) {
                        this._visibleDatas["unsubscribe"]();
                    }
                    this._visibleDatas = values;
                    this.visibleStateBind();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "tabs", {
            // 所有标签数据
            get: 
            // 所有标签数据
            /**
             * @return {?}
             */
            function () {
                return this._tabs;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._tabs = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "customClass", {
            get: /**
             * @return {?}
             */ function () {
                return this._customClass;
            },
            set: /**
             * @param {?} customClass
             * @return {?}
             */ function (customClass) {
                var _this = this;
                if (this.customClass) {
                    this.customClass.split(' ').forEach(( /**
                     * @param {?} cssClass
                     * @return {?}
                     */function (cssClass) {
                        _this.renderer.removeClass(_this.el, cssClass);
                    }));
                }
                this._customClass = customClass ? customClass.trim() : null;
                if (this.customClass) {
                    this.customClass.split(' ').forEach(( /**
                     * @param {?} cssClass
                     * @return {?}
                     */function (cssClass) {
                        _this.renderer.addClass(_this.el, cssClass);
                    }));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "direction", {
            get: /**
             * @return {?}
             */ function () {
                switch (this.position) {
                    case 'top':
                        return 'column';
                    case 'bottom':
                        return 'column-reverse';
                    case 'left':
                        return 'row';
                    case 'right':
                        return 'row-reverse';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabsComponent.prototype, "tabDirection", {
            // 无用，兼容
            get: 
            // 无用，兼容
            /**
             * @return {?}
             */
            function () {
                if (this.position === 'top' || this.position === 'bottom') {
                    return 'row';
                }
                else if (this.position === 'left' || this.position === 'right') {
                    return 'column';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} index
         * @param {?} btn
         * @return {?}
         */
        FarrisTabsComponent.prototype.trackByButton = /**
         * @param {?} index
         * @param {?} btn
         * @return {?}
         */
            function (index, btn) { return btn.id; };
        /** 验证传递参数 */
        /**
         * 验证传递参数
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype.verifyConfig = /**
         * 验证传递参数
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var config = this.stService.getConfig();
                Object.assign(this, config);
                this.scrollStep = parseInt(this.scrollStep + '', 10);
            };
        /**
         * @return {?}
         */
        FarrisTabsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.beforeSelect) {
                    this.beforeSelect = ( /**
                     * @return {?}
                     */function () { return rxjs.of(true); });
                }
                this.clickSubscription = this.clickItems.pipe(operators.debounceTime(this.clickThrottleTime))
                    .subscribe(( /**
             * @param {?} btnInfo
             * @return {?}
             */function (btnInfo) {
                    if (btnInfo.click && typeof btnInfo.click == 'function') {
                        btnInfo.click();
                    }
                }));
                this._tabContainerEl = this.tabContainer.nativeElement;
                this._createStream();
                this.activeId = this.selectId;
                if (this.ngZone) {
                    this.ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        if (_this.ro === null) {
                            _this.ro = new ResizeObserver(( /**
                             * @param {?} el
                             * @return {?}
                             */function (el) {
                                _this._reCalculateAll();
                                _this._calculateToolbarDropdownIsShow();
                                _this._calculateButtonsShow();
                            }));
                            _this.ro.observe(_this.el.parentElement);
                        }
                    }));
                }
            };
        /**
         * 解决按钮调整隐藏状态之后，下拉中能显示的按钮有多少
         */
        /**
         * 解决按钮调整隐藏状态之后，下拉中能显示的按钮有多少
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype.visibleStateBind = /**
         * 解决按钮调整隐藏状态之后，下拉中能显示的按钮有多少
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this._visibleDatas.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    // 解决切换时，按钮状态没被记录的问题
                    /** @type {?} */
                    var idArray = Object.keys(data);
                    idArray.forEach(( /**
                     * @param {?} btnId
                     * @return {?}
                     */function (btnId) {
                        _this.visibleRecord[btnId] = data[btnId];
                    }));
                    if (_this.toolbarConf && _this.toolbarConf.contents.length > 0) {
                        // 调整按钮可见状态            
                        _this.changeState(data, "visible");
                        // 重新计算
                        _this._reCalculateAll();
                        _this._calculateToolbarDropdownIsShow();
                        _this._calculateButtonsShow();
                    }
                }));
            };
        /**
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype.disableStateBind = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this._disableStatesDatas.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    // 解决切换时，按钮状态没被记录的问题
                    /** @type {?} */
                    var idArray = Object.keys(data);
                    idArray.forEach(( /**
                     * @param {?} btnId
                     * @return {?}
                     */function (btnId) {
                        _this.disableRecord[btnId] = data[btnId];
                    }));
                    if (_this.toolbarConf && _this.toolbarConf.contents.length > 0) {
                        // 调整按钮可见状态            
                        _this.changeState(data, "disable");
                    }
                }));
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        FarrisTabsComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes['selectId']) {
                    this.selectTab(changes['selectId'].currentValue);
                }
            };
        /* 标签页内容初始化 */
        /* 标签页内容初始化 */
        /**
         * @return {?}
         */
        FarrisTabsComponent.prototype.ngAfterContentInit = /* 标签页内容初始化 */
            /**
             * @return {?}
             */
            function () { };
        /**
         * @return {?}
         */
        FarrisTabsComponent.prototype.ngAfterContentChecked = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        FarrisTabsComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // 为了兼容弄旧表单，不兼容HostBinding, 通过追加class的方式实现
                this.renderer.addClass(this.el, 'farris-tabs');
                this.renderer.addClass(this.el, 'flex-column');
                this.contentFillStates.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    if (data) {
                        _this.renderer.addClass(_this.el, 'f-tabs-content-fill');
                    }
                    else {
                        _this.renderer.removeClass(_this.el, 'f-tabs-content-fill');
                    }
                }));
                this.widthStates.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    if (data) {
                        _this.renderer.setStyle(_this.el, 'width', data);
                    }
                }));
                this.heightStates.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    if (data) {
                        _this.renderer.setStyle(_this.el, 'height', data);
                    }
                }));
                this.positionStates.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    _this.renderer.removeClass(_this.el, 'flex-row');
                    _this.renderer.removeClass(_this.el, 'flex-column');
                    _this.renderer.removeClass(_this.el, 'flex-row-reverse');
                    _this.renderer.removeClass(_this.el, 'flex-column-reverse');
                    if (data === 'left') {
                        _this.renderer.addClass(_this.el, 'flex-row');
                    }
                    if (data === 'top') {
                        _this.renderer.addClass(_this.el, 'flex-column');
                    }
                    if (data === 'right') {
                        _this.renderer.addClass(_this.el, 'flex-row-reverse');
                    }
                    if (data === 'bottom') {
                        _this.renderer.addClass(_this.el, 'flex-column-reverse');
                    }
                }));
                // 兼容结束
                this.getToolbarConf();
                this._reCalculateAll();
                this._setActive();
                this._changeTitleStyle();
                this._listenShowChanges();
                // this.renderer.listen(document, 'keyup', function (e) {
                //     if (self.searchInputVisible) {
                //         console.log(e);
                //     }
                // });
                this.ngZone.runOutsideAngular(( /**
                 * @return {?}
                 */function () {
                    _this._ddmHandler = _this.renderer.listen(document, 'mousedown', ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        if (!e.target.closest('.farris-tabs-header')) {
                            if (_this.el && _this.el.querySelector('.dropdown-menu')) {
                                if (_this.ddm && _this.ddm.dropdown) {
                                    _this.ddm.dropdown.close();
                                }
                            }
                        }
                    }));
                }));
            };
        /**
         * @return {?}
         */
        FarrisTabsComponent.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        FarrisTabsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // 组件销毁时  取消所有事件订阅
                this.subscription.forEach(( /**
                 * @param {?} sub
                 * @return {?}
                 */function (sub) {
                    sub.unsubscribe();
                }));
                this.subscription = [];
                if (this.ro) {
                    if (this.el.parentElement) {
                        this.ro.unobserve(this.el.parentElement);
                    }
                    this.ro = null;
                }
                if (this._ddmHandler) {
                    this._ddmHandler();
                    this._ddmHandler = null;
                }
                if (this.clickSubscription) {
                    this.clickSubscription.unsubscribe();
                }
                if (this._visibleDatas &&
                    this._visibleDatas.hasOwnProperty("unsubscribe")) {
                    this._visibleDatas["unsubscribe"]();
                    this._visibleDatas = null;
                }
            };
        /**
         * @param {?} btnInfo
         * @return {?}
         */
        FarrisTabsComponent.prototype.clickHandler = /**
         * @param {?} btnInfo
         * @return {?}
         */
            function (btnInfo) {
                if (!btnInfo) {
                    return;
                }
                if (btnInfo.hasOwnProperty('disable') && btnInfo['disable']) {
                    // 如果禁用就不触发点击事件
                    return;
                }
                this.clickItems.next(btnInfo);
            };
        // 更多tab的显示隐藏
        // 更多tab的显示隐藏
        /**
         * @param {?} e
         * @return {?}
         */
        FarrisTabsComponent.prototype.openChange =
            // 更多tab的显示隐藏
            /**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                this.searchInputVisible = e;
                this.searchTabText = undefined;
                this._reCalculateAll();
                // 启用了搜索，需要判断下拉面板的值
                // 因为下拉面板可能存在遮挡的问题
                if (e) {
                    this.menuItemsWidth = this.ddm.resetMenuElWidthOpen() + 'px';
                }
                else {
                    this.menuItemsWidth = 'auto';
                }
            };
        // 搜索tab
        // 搜索tab
        /**
         * @param {?} e
         * @return {?}
         */
        FarrisTabsComponent.prototype.searchTab =
            // 搜索tab
            /**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                this.stopBubble(e);
                this._reCalculateAll();
            };
        // 阻止冒泡
        // 阻止冒泡
        /**
         * @param {?} e
         * @return {?}
         */
        FarrisTabsComponent.prototype.stopBubble =
            // 阻止冒泡
            /**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                if (e && e.stopPropagation) {
                    e.stopPropagation();
                }
                else {
                    window.event.cancelBubble = true;
                }
            };
        /**
         * Ximena 23.08.30 判断是否可见,独立出来
         * Todo:
         * 1、现在btnVisible每次的变更都是全量，是否需要记录每次变更，然后合并计算？
         * 2、现在判断是否可见的方法，是直接更新界面的，每个按钮上都绑定了这个方法，会有性能问题。应该改成处理在绑定的所有数据，然后更新界面。
         * 3、是否可见和禁用有同样的问题
         * @param id
         * @returns
         */
        /**
         * Ximena 23.08.30 判断是否可见,独立出来
         * Todo:
         * 1、现在btnVisible每次的变更都是全量，是否需要记录每次变更，然后合并计算？
         * 2、现在判断是否可见的方法，是直接更新界面的，每个按钮上都绑定了这个方法，会有性能问题。应该改成处理在绑定的所有数据，然后更新界面。
         * 3、是否可见和禁用有同样的问题
         * @param {?} btnItem
         * @return {?}
         */
        FarrisTabsComponent.prototype.getToolbarStateVisible = /**
         * Ximena 23.08.30 判断是否可见,独立出来
         * Todo:
         * 1、现在btnVisible每次的变更都是全量，是否需要记录每次变更，然后合并计算？
         * 2、现在判断是否可见的方法，是直接更新界面的，每个按钮上都绑定了这个方法，会有性能问题。应该改成处理在绑定的所有数据，然后更新界面。
         * 3、是否可见和禁用有同样的问题
         * @param {?} btnItem
         * @return {?}
         */
            function (btnItem) {
                /** @type {?} */
                var stateProp = "visible";
                if (btnItem.hasOwnProperty(stateProp)) {
                    return btnItem[stateProp];
                }
                // 不存在属性
                return true;
            };
        /**
         * @param {?} btnItem
         * @return {?}
         */
        FarrisTabsComponent.prototype.getToolbarStateDisable = /**
         * @param {?} btnItem
         * @return {?}
         */
            function (btnItem) {
                /** @type {?} */
                var stateProp = "disable";
                if (btnItem.hasOwnProperty(stateProp)) {
                    return btnItem[stateProp];
                }
                // 不存在属性
                return false;
            };
        /**
         * 只处理是否禁用
         * @param id
         * @param state
         * @returns
         */
        /**
         * 只处理是否禁用
         * @param {?} id
         * @param {?=} state
         * @return {?}
         */
        FarrisTabsComponent.prototype.getToolbarState = /**
         * 只处理是否禁用
         * @param {?} id
         * @param {?=} state
         * @return {?}
         */
            function (id, state) {
                if (state === void 0) {
                    state = this.btnStates;
                }
                if (state) {
                    return state.pipe(operators.map(( /**
                     * @param {?} n
                     * @return {?}
                     */function (n) {
                        if (n[id] === undefined) {
                            // console.warn(`未找ID为：${id} 相关状态设置！`);
                            return false;
                        }
                        return n[id];
                    })));
                }
                else {
                    return rxjs.of(true);
                }
            };
        // 监听子组件的隐藏显示属性
        // 监听子组件的隐藏显示属性
        /**
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._listenShowChanges =
            // 监听子组件的隐藏显示属性
            /**
             * @private
             * @return {?}
             */
            function () {
                var _this = this;
                // 如果隐藏的组件是激活状态，先将其设置为常规
                this.tabs.forEach(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    item.showStates.subscribe(( /**
                     * @param {?} data
                     * @return {?}
                     */function (data) {
                        /** @type {?} */
                        var activeIdToken;
                        item._show = data;
                        if (data === false && item.id === _this.activeId) {
                            item._active = false;
                            _this.activeId = '';
                            activeIdToken = false;
                        }
                        /** @type {?} */
                        var tabs = _this.tabs.filter(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) { return item._show === true; }));
                        /** @type {?} */
                        var defaultTabId = tabs.length ? tabs[0].id : null;
                        // 然后将显示状态下的第一个tab激活
                        if (defaultTabId && activeIdToken === false) {
                            _this.tabs.forEach(( /**
                             * @param {?} item
                             * @param {?} index
                             * @return {?}
                             */function (item, index) {
                                if (item.id === defaultTabId) {
                                    _this.activeId = item.id;
                                    _this.tabs[index]._active = true;
                                }
                            }));
                            _this.getToolbarConf();
                        }
                        _this.cdRef.detectChanges();
                    }));
                }));
            };
        /**
         * 选中Tab
         * @param  tabId tab标识
         */
        /**
         * 选中Tab
         * @param {?} tabId tab标识
         * @return {?}
         */
        FarrisTabsComponent.prototype.selectTab = /**
         * 选中Tab
         * @param {?} tabId tab标识
         * @return {?}
         */
            function (tabId) {
                /** @type {?} */
                var selectedTab = this._getTabById(tabId);
                this._selectTab(selectedTab.tab, selectedTab.index);
            };
        /**
         * @param {?} ev
         * @param {?} id
         * @param {?=} ddm
         * @return {?}
         */
        FarrisTabsComponent.prototype._cpSelectTabByIndex = /**
         * @param {?} ev
         * @param {?} id
         * @param {?=} ddm
         * @return {?}
         */
            function (ev, id, ddm) {
                if (ddm === void 0) {
                    ddm = null;
                }
                ev.preventDefault();
                ev.stopPropagation();
                /** @type {?} */
                var targetEL = ( /** @type {?} */(ev.target));
                if (targetEL.className.indexOf('st-drop-close') > -1 ||
                    targetEL.parentElement.className.indexOf('st-drop-close') > -1) {
                    // 阻止冒泡和捕获事件 点击删除标记 则执行删除标签方法  而不是选中标签
                    this.closeTab(id);
                }
                else {
                    // 阻止冒泡
                    this.selectTab(id);
                }
                this.getToolbarConf();
                this.cdRef.markForCheck();
                this._reCalculateAll();
                this._calculateToolbarDropdownIsShow();
                this._calculateButtonsShow();
                if (ddm) {
                    ddm.dropdown.close();
                }
                return false;
            };
        /**
         * 通过tabs的索引选择 tab
         * @param index tabs索引
         */
        /**
         * 通过tabs的索引选择 tab
         * @param {?} index tabs索引
         * @return {?}
         */
        FarrisTabsComponent.prototype.selectTabByIndex = /**
         * 通过tabs的索引选择 tab
         * @param {?} index tabs索引
         * @return {?}
         */
            function (index) {
                if (index >= 0 && index < this.tabs.length) {
                    /** @type {?} */
                    var selectTab = this.tabs[index];
                    this._selectTab(selectTab, index);
                }
            };
        /* 选中tab时  暴露出选中tab的id 和其之后的id */
        /* 选中tab时  暴露出选中tab的id 和其之后的id */
        /**
         * @private
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        FarrisTabsComponent.prototype._selectTab = /* 选中tab时  暴露出选中tab的id 和其之后的id */
            /**
             * @private
             * @param {?} tab
             * @param {?} index
             * @return {?}
             */
            function (tab, index) {
                var _this = this;
                if (tab && !tab.disabled && this.activeId !== tab.id) {
                    if (!this.beforeSelect) {
                        this.beforeSelect = ( /**
                         * @return {?}
                         */function () { return rxjs.of(true); });
                    }
                    /** @type {?} */
                    var tabsChangeEventParam_1 = {
                        prevId: this.activeId,
                        nextId: tab.id
                    };
                    this.beforeSelect(tabsChangeEventParam_1).subscribe(( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        if (e) {
                            _this.activeId = tab.id;
                            // 首先不激活所有的tab页  然后激活当前tab页
                            // let index = -1;
                            _this.tabs.forEach(( /**
                             * @param {?} item
                             * @param {?} i
                             * @return {?}
                             */function (item, i) {
                                item._active = false;
                            }));
                            _this.tabs[index]._active = true;
                            _this.getToolbarConf();
                            // 滚动到可见区域内
                            _this.scrollTabIntoView(index);
                            _this.cdRef.detectChanges();
                            _this.tabChange.emit(tabsChangeEventParam_1);
                        }
                    }));
                }
            };
        /**
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._setActive = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.tabs.length) {
                    /** @type {?} */
                    var tabs = this.tabs.filter(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) { return item._show === true; }));
                    /** @type {?} */
                    var activeTab = this._getTabById(this.activeId).tab;
                    this.activeId = activeTab ? activeTab.id : this.tabs.length ? this.tabs[0].id : null;
                    // 过滤掉show=false（隐藏）的tab
                    if (tabs.length) {
                        if (this.activeId) {
                            /** @type {?} */
                            var targetTab = tabs.find(( /**
                             * @param {?} item
                             * @return {?}
                             */function (item) { return item.id === _this.activeId; }));
                            if (targetTab) {
                                this.activeId = targetTab.id;
                            }
                        }
                        else {
                            this.activeId = tabs[0].id;
                        }
                    }
                    else {
                        this.activeId = null;
                    }
                    this.tabs.forEach(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) {
                        item._active = false;
                        if (item.id === _this.activeId) {
                            item._active = true;
                        }
                    }));
                }
            };
        /**
         * @param activeId 显示某个tab
         */
        /**
         * @param {?} tabId
         * @param {?=} selectable
         * @return {?}
         */
        FarrisTabsComponent.prototype.showTab = /**
         * @param {?} tabId
         * @param {?=} selectable
         * @return {?}
         */
            function (tabId, selectable) {
                if (selectable === void 0) {
                    selectable = true;
                }
                /** @type {?} */
                var len = this.tabs.length;
                for (var i = 0; i < len; i++) {
                    if (this.tabs[i].id === tabId) {
                        this.tabs[i]._show = true;
                        if (selectable) {
                            this.selectTab(tabId);
                        }
                        return;
                    }
                }
            };
        /**
         * @param activeId 隐藏某个tab
         */
        /**
         * @param {?} activeId 隐藏某个tab
         * @return {?}
         */
        FarrisTabsComponent.prototype.hideTab = /**
         * @param {?} activeId 隐藏某个tab
         * @return {?}
         */
            function (activeId) {
                /** @type {?} */
                var showTabs = this.tabs.filter(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    return item._show === true;
                }));
                /** @type {?} */
                var len = showTabs.length - 1;
                if (len < 0) {
                    return;
                }
                /** @type {?} */
                var index;
                for (var i = 0; i <= len; i++) {
                    if (showTabs[i].id === activeId) {
                        showTabs[i]._show = false;
                        index = i;
                        break;
                    }
                }
                if (index === undefined) {
                    return;
                }
                else if (index === len && len < 1) {
                    this.selectTab('');
                }
                else if (index === len && len >= 1) {
                    this.selectTab(showTabs[len - 1].id);
                }
                else {
                    this.selectTab(showTabs[index + 1].id);
                }
            };
        /**
         * 添加标签
         * @param curTabs 数组或者对象
         * @param activeId 设置
         */
        /**
         * 添加标签
         * @param {?} curTabs 数组或者对象
         * @param {?} index
         * @param {?} setActiveId
         * @return {?}
         */
        FarrisTabsComponent.prototype.addTabs = /**
         * 添加标签
         * @param {?} curTabs 数组或者对象
         * @param {?} index
         * @param {?} setActiveId
         * @return {?}
         */
            function (curTabs, index, setActiveId) {
                var _a;
                if (curTabs.length > 0) {
                    (_a = this.tabs).splice.apply(_a, __spread([index, 0], curTabs));
                    // 去重
                    this.tabs = this._unique(this.tabs);
                }
                if (setActiveId && this.activeId !== setActiveId) {
                    /** @type {?} */
                    var filterTab = this._getTabById(setActiveId);
                    if (filterTab.index >= 0) {
                        this.selectTab(setActiveId);
                        this.activeId = setActiveId;
                        this.scrollTabIntoView(filterTab.index);
                    }
                }
                this.cdRef.detectChanges();
                this._reCalculateAll();
                this._changeTitleStyle();
            };
        /**
         * 添加标签时  去重
         *
         */
        /**
         * 添加标签时  去重
         *
         * @private
         * @param {?} objArray
         * @return {?}
         */
        FarrisTabsComponent.prototype._unique = /**
         * 添加标签时  去重
         *
         * @private
         * @param {?} objArray
         * @return {?}
         */
            function (objArray) {
                /** @type {?} */
                var hash = {};
                objArray = objArray.reduce(( /**
                 * @param {?} item
                 * @param {?} next
                 * @return {?}
                 */function (item, next) {
                    if (hash[next.id]) {
                        hash[next.id] = '';
                    }
                    else {
                        hash[next.id] = item.push(next);
                    }
                    return item;
                }), []);
                return objArray;
            };
        /* 通过tab列表的序列删除tab */
        /* 通过tab列表的序列删除tab */
        /**
         * @param {?} index
         * @return {?}
         */
        FarrisTabsComponent.prototype.removeTabByIndex = /* 通过tab列表的序列删除tab */
            /**
             * @param {?} index
             * @return {?}
             */
            function (index) {
                /** @type {?} */
                var len = this.tabs.length - 1;
                if (index < 0 || index > len) {
                    return;
                }
                /** @type {?} */
                var removeTab = this.tabs[index];
                removeTab._active = false;
                if (this.activeId === removeTab.id) {
                    // 只有一个而且被删除
                    if (len === 0) {
                        // 如果所有标签均删除 激活id为空
                        this.activeId = '';
                    }
                    else if (index === len) {
                        // 如果删除的是最后一个标签 设置其前面的处于激活状态
                        this.activeId = this.tabs[len - 1].id;
                        this.tabs[index - 1]._active = true;
                    }
                    else {
                        // 如果其他情况  设置其后面的处于激活状态
                        this.activeId = this.tabs[index + 1].id;
                        this.tabs[index + 1]._active = true;
                    }
                    this.tabs.splice(index, 1);
                    this.scrollTabIntoView(index);
                }
                else {
                    this.tabs.splice(index, 1);
                }
                this.tabRemove.emit({
                    removeIndex: index,
                    removeId: removeTab.id,
                    activeId: this.activeId
                });
                this.cdRef.detectChanges();
            };
        /**
         * 关闭标签  跟删除标签不同
         * @param string
         */
        /**
         * 关闭标签  跟删除标签不同
         * @param {?} activeId
         * @return {?}
         */
        FarrisTabsComponent.prototype.closeTab = /**
         * 关闭标签  跟删除标签不同
         * @param {?} activeId
         * @return {?}
         */
            function (activeId) {
                /** @type {?} */
                var len = this.tabs.length;
                for (var i = 0; i < len; i++) {
                    /** @type {?} */
                    var tab = this.tabs[i];
                    if (tab.id === activeId) {
                        this.removeTabByIndex(i);
                        return;
                    }
                }
            };
        /**
         * 初始化
         */
        /**
         * 初始化
         * @return {?}
         */
        FarrisTabsComponent.prototype.load = /**
         * 初始化
         * @return {?}
         */
            function () {
                for (var i = 0; i < this.tabs.length; i++) {
                    if (this.tabs[i].id === this.activeId) {
                        this.tabs[i]._active = true;
                        return;
                    }
                }
            };
        /**
         * 截取tab中的title,超过6位，截断
         */
        /**
         * 截取tab中的title,超过6位，截断
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._truncateTitle = /**
         * 截取tab中的title,超过6位，截断
         * @private
         * @return {?}
         */
            function () {
                this.tabs = this.tabs.map(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    item.title = item.title.length > 6 ? item.title.substr(0, 6) : item.title;
                    return item;
                }));
            };
        /**
         * 替换tab中的title颜色
         */
        /**
         * 替换tab中的title颜色
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._changeTitleStyle = /**
         * 替换tab中的title颜色
         * @private
         * @return {?}
         */
            function () {
                if (this.autoTitleWidth) {
                    return;
                }
                /** @type {?} */
                var $textEls = this._tabContainerEl.querySelectorAll('.st-tab-text');
                for (var k = 0; k < $textEls.length; k++) {
                    /** @type {?} */
                    var parentEl = $textEls[k].parentNode;
                    if ($textEls[k].scrollWidth > parentEl['offsetWidth']) {
                        this.tabs[k].titleOverflow = true;
                    }
                    else {
                        this.tabs[k].titleOverflow = false;
                    }
                }
                //this.cdRef.detectChanges();
            };
        /**
         * 创建流
         */
        /**
         * 创建流
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._createStream = /**
         * 创建流
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                [this.rightNav, this.leftNav].forEach(( /**
                 * @param {?} curBtn
                 * @param {?} index
                 * @return {?}
                 */function (curBtn, index) {
                    /** @type {?} */
                    var direction = index ? -1 : 1;
                    /** @type {?} */
                    var mousedown$ = rxjs.fromEvent(curBtn.nativeElement, 'mousedown');
                    /** @type {?} */
                    var mouseup$ = rxjs.fromEvent(curBtn.nativeElement, 'mouseup');
                    /** @type {?} */
                    var newMouseDown$ = mousedown$.pipe(operators.switchMap(( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        event.preventDefault();
                        event.stopPropagation();
                        /** @type {?} */
                        var interval$ = rxjs.of(0).pipe(
                        // concat(interval(80)),
                        operators.takeUntil(mouseup$), operators.scan(( /**
                         * @param {?} sum
                         * @param {?} num
                         * @return {?}
                         */function (sum, num) {
                            return sum + _this.scrollStep * direction;
                        }), 0), operators.takeWhile(( /**
                         * @param {?} num
                         * @return {?}
                         */function (num) {
                            if (direction > 0) {
                                return !_this.disableRight;
                            }
                            return !_this.disableLeft;
                        })), operators.map(( /**
                         * @param {?} v
                         * @return {?}
                         */function (v) {
                            return { value: v, direction: direction };
                        })));
                        return interval$;
                    })));
                    /** @type {?} */
                    var mousepressSub = newMouseDown$.subscribe(( /**
                     * @param {?} change
                     * @return {?}
                     */function (change) {
                        _this._scrollTab(change.value, change.direction);
                    }));
                    _this.subscription.push(mousepressSub);
                }));
                // if (this.autoResize) {
                //     // 订阅windows resize事件
                //     this.subscription.push(
                //         fromEvent(window, 'resize')
                //             .pipe(throttleTime(80))
                //             .subscribe(e => {
                //                 this.cdRef.detectChanges();
                //             })
                //     );
                // }
            };
        /**
         * 按照方向，滚动到指定位置
         * @param dist_scroll 目标滚动
         * @param direction 方向
         */
        /**
         * 按照方向，滚动到指定位置
         * @private
         * @param {?} move
         * @param {?} direction 方向
         * @return {?}
         */
        FarrisTabsComponent.prototype._scrollTab = /**
         * 按照方向，滚动到指定位置
         * @private
         * @param {?} move
         * @param {?} direction 方向
         * @return {?}
         */
            function (move, direction) {
                /** @type {?} */
                var dist_scrollleft = this._tabContainerEl.scrollLeft + move;
                /** @type {?} */
                var max_scroll_left = this._tabContainerEl.scrollWidth - this._tabContainerEl.offsetWidth;
                // 标签页左侧移动
                if (direction > 0) {
                    this._tabContainerEl.scrollLeft = Math.min(dist_scrollleft, max_scroll_left);
                }
                else if (direction < 0) {
                    // 标签页右侧移动
                    this._tabContainerEl.scrollLeft = Math.max(dist_scrollleft, 0);
                }
                this._reCalculateSides();
                // this.cdRef.detectChanges();
            };
        /**
         * 指定当前滑动到可视区域——————————————未测试
         * index
         */
        /**
         * 指定当前滑动到可视区域——————————————未测试
         * index
         * @param {?} index
         * @return {?}
         */
        FarrisTabsComponent.prototype.scrollTabIntoView = /**
         * 指定当前滑动到可视区域——————————————未测试
         * index
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (!this._tabContainerEl || this.hideButtons) {
                    return;
                }
                /** @type {?} */
                var tabIndex = parseInt(index + '', 10);
                /** @type {?} */
                var tabToScroll;
                // first we find the tab element.
                if (tabIndex >= 0) {
                    /** @type {?} */
                    var allTabs = this._tabContainerEl.querySelectorAll('.nav-item');
                    if (allTabs.length > tabIndex) {
                        tabToScroll = allTabs[tabIndex];
                    }
                }
                else {
                    // scroll selected tab into view
                    /** @type {?} */
                    var activeTab = this._tabContainerEl.querySelector('li.active');
                    if (activeTab) {
                        tabToScroll = activeTab;
                    }
                }
                if (tabToScroll) {
                    /** @type {?} */
                    var tab_left = parseInt(tabToScroll.getBoundingClientRect().left + '', 10);
                    /** @type {?} */
                    var tabs_left = parseInt(this._tabContainerEl.getBoundingClientRect().left + '', 10);
                    /** @type {?} */
                    var rightPosition = tab_left +
                        parseInt(tabToScroll.getBoundingClientRect().width + '', 10) -
                        tabs_left;
                    /** @type {?} */
                    var leftPosition = tab_left - tabs_left - 10;
                    if (leftPosition < 0) {
                        this._scrollTab(leftPosition, -1);
                    }
                    else if (rightPosition > this._tabContainerEl.offsetWidth) {
                        this._scrollTab(rightPosition - this._tabContainerEl.offsetWidth + 20, 1);
                    }
                }
            };
        /**
         * 切换tab后，重新获取需要该tab下工具条按钮的配置信息以及隐藏更多按钮
         * 以及获取该tab下的头部扩展区域
         */
        /**
         * 切换tab后，重新获取需要该tab下工具条按钮的配置信息以及隐藏更多按钮
         * 以及获取该tab下的头部扩展区域
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype.getToolbarConf = /**
         * 切换tab后，重新获取需要该tab下工具条按钮的配置信息以及隐藏更多按钮
         * 以及获取该tab下的头部扩展区域
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var tabConfig = this.tabs.filter(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    return item._active === true;
                }))[0];
                if (!tabConfig || !tabConfig.hasOwnProperty('toolbar')) {
                    this.toolbarConf = null;
                }
                else {
                    this.toolbarConf = tabConfig.toolbar;
                }
                // 记录状态
                this.changeState(this.visibleRecord, "visible");
                this.changeState(this.disableRecord, "disable");
                // 获取该tab下的头部扩展区域
                if (!tabConfig || !tabConfig.hasOwnProperty('farrisTabsExtendDirective')) {
                    this.headerExtendConf = null;
                }
                else {
                    this.headerExtendConf = tabConfig.farrisTabsExtendDirective;
                }
                // 隐藏更多按钮
                this.toolbarDpHidden = true;
                this.cdRef.detectChanges();
            };
        /**
         * 计算工具栏是否显示下拉按钮
         */
        /**
         * 计算工具栏是否显示下拉按钮
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._calculateToolbarDropdownIsShow = /**
         * 计算工具栏是否显示下拉按钮
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var headerExtendEl;
                /** @type {?} */
                var headerExtendElWidth = 0;
                if (!this.toolbarContainer || !this.toolbarConf) {
                    return;
                }
                /** @type {?} */
                var toolbarContainer = this.hasInHeadCl() ? this.toolbarContainer.nativeElement : this.toolbarContainer.nativeElement.parentElement;
                /** @type {?} */
                var divEl = toolbarContainer.querySelector('.farris-tabs-inline-flex');
                if (!divEl) {
                    return;
                }
                if (this.headerExtendConf) {
                    headerExtendEl = toolbarContainer.querySelector('.farris-tabs-header-extend');
                    this.renderer.removeStyle(headerExtendEl, 'overflow');
                    headerExtendElWidth = headerExtendEl.offsetWidth;
                }
                // 按钮在内容区
                if (!this.hasInHeadCl() && this.btnPlaceHolder.nativeElement.offsetWidth > toolbarContainer.offsetWidth) {
                    this.toolbarDpHidden = false;
                }
                else if (this.hasInHeadCl() && this.btnPlaceHolder.nativeElement.offsetWidth > toolbarContainer.offsetWidth - headerExtendElWidth) {
                    // 按钮在头部工具栏
                    this.toolbarDpHidden = false;
                }
                else {
                    this.toolbarDpHidden = true;
                }
                this.cdRef.detectChanges();
            };
        /**
         * 计算显示的按钮个数及更多中显示的按钮个数
         */
        /**
         * 计算显示的按钮个数及更多中显示的按钮个数
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._calculateButtonsShow = /**
         * 计算显示的按钮个数及更多中显示的按钮个数
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var headerExtendEl;
                /** @type {?} */
                var headerExtendElWidth = 0;
                if (!this.toolbarContainer || !this.toolbarConf) {
                    return;
                }
                /** @type {?} */
                var toolbarContainer = this.hasInHeadCl() ? this.toolbarContainer.nativeElement : this.toolbarContainer.nativeElement.parentElement;
                /** @type {?} */
                var divEl = toolbarContainer.querySelector('.farris-tabs-inline-flex');
                /** @type {?} */
                var btnPlaceHolderEl = this.btnPlaceHolder.nativeElement;
                /** @type {?} */
                var btnPlaceHolderBtns = btnPlaceHolderEl.querySelectorAll('.btn--cal');
                if (!divEl || btnPlaceHolderBtns.length == 0) {
                    return;
                }
                // 此处有个Bug，如果是inContent还是headerExtendConf的情况下，按钮的位置形如inHead
                if (this.headerExtendConf) {
                    headerExtendEl = toolbarContainer.querySelector('.farris-tabs-header-extend');
                    headerExtendElWidth = this.hasInHeadCl() ? headerExtendEl.offsetWidth : 0;
                }
                /** @type {?} */
                var moreButton = btnPlaceHolderEl.parentElement.querySelector('.morebtn');
                // 计算按钮的宽度      
                /** @type {?} */
                var basicStart = parseInt(btnPlaceHolderEl.getBoundingClientRect().left);
                /** @type {?} */
                var basicWidth = toolbarContainer.offsetWidth - moreButton.offsetWidth - 12 - headerExtendElWidth;
                /** @type {?} */
                var toolbarDropdownHidden = true;
                /** @type {?} */
                var k = 0;
                // 只有一个按钮
                if (btnPlaceHolderBtns.length == 1) {
                    if (btnPlaceHolderEl.offsetWidth > basicWidth) {
                        toolbarDropdownHidden = false;
                    }
                    else {
                        k = 1;
                    }
                }
                else {
                    for (k = 1; k <= btnPlaceHolderBtns.length - 1; k++) {
                        // 如果内容超出,考虑到按钮之间的间距
                        if (k == btnPlaceHolderBtns.length - 1) {
                            if (btnPlaceHolderEl.offsetWidth > basicWidth) {
                                toolbarDropdownHidden = false;
                                k = k - 1;
                                break;
                            }
                        }
                        else if (parseInt(btnPlaceHolderBtns[k].getBoundingClientRect().left) - basicStart > basicWidth) {
                            toolbarDropdownHidden = false;
                            k = k - 1;
                            break;
                        }
                    }
                }
                this.toolbarDpHidden = toolbarDropdownHidden;
                /** @type {?} */
                var showBtns = divEl.querySelectorAll('.btn--cal');
                for (var i = 0; i < k; i++) {
                    this.renderer.setStyle(showBtns[i], 'display', '');
                }
                for (var m = k; m < showBtns.length; m++) {
                    this.renderer.setStyle(showBtns[m], 'display', 'none');
                }
                if (this.toolbarConf.contents && this.toolbarConf.contents.length) {
                    // 过滤显示按钮的个数
                    /** @type {?} */
                    var filterShowBtns = this.toolbarConf.contents.filter(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) { return _this.getToolbarStateVisible(item); }));
                    // 从显示按钮中过滤下拉按钮
                    this.inMoreButtonContents = filterShowBtns.filter(( /**
                     * @param {?} item
                     * @param {?} index
                     * @return {?}
                     */function (item, index) {
                        return index >= k;
                    }));
                }
                this.cdRef && !this.cdRef['destroyed'] && this.cdRef.detectChanges();
            };
        /**
         * 重新计算是否显示按钮和下拉
         */
        /**
         * 重新计算是否显示按钮和下拉
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._reCalculateAll = /**
         * 重新计算是否显示按钮和下拉
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this._tabContainerEl) {
                    return;
                }
                /** @type {?} */
                var tabParentWidth = this.tabParent.nativeElement.offsetWidth;
                if (!this.hideButtons) {
                    /** @type {?} */
                    var tr = parseInt(window.getComputedStyle(this.tabParent.nativeElement).getPropertyValue("margin-right"));
                    /** @type {?} */
                    var tl = parseInt(window.getComputedStyle(this.tabParent.nativeElement).getPropertyValue("margin-left"));
                    tabParentWidth += tr + tl;
                }
                this.hideButtons = this._tabContainerEl.scrollWidth <= tabParentWidth;
                this.hideDropDown = this.showDropDown ? this.hideButtons : true;
                if (!this.hideButtons) {
                    if (!this.hideDropDown) {
                        this.dropdownTabs = [].concat(this.tabs);
                    }
                    if (this.searchTabText) {
                        this.dropdownTabs = this.dropdownTabs.filter(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) {
                            return item['title'].indexOf(_this.searchTabText) !== -1;
                        }));
                    }
                    this._reCalculateSides();
                }
                this.dpState = [false];
                this.cdRef.detectChanges();
            };
        /**
         * 重新计算左右的提示文字
         */
        /**
         * 重新计算左右的提示文字
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._reCalulateTooltips = /**
         * 重新计算左右的提示文字
         * @private
         * @return {?}
         */
            function () {
                if (!this._tabContainerEl || this.hideButtons) {
                    return;
                }
                /** @type {?} */
                var t_right_tooltips = [];
                /** @type {?} */
                var t_left_tooltips = [];
                /** @type {?} */
                var allTabs = this._tabContainerEl.querySelectorAll('.nav-item');
                /** @type {?} */
                var len = allTabs.length;
                /** @type {?} */
                var hiddenTabs = this.tabs.filter(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    return item._show !== true;
                }));
                /** @type {?} */
                var hiddenTabsLength = hiddenTabs.length;
                for (var i = 0; i < len; i++) {
                    /** @type {?} */
                    var leftPosition = allTabs[i].getBoundingClientRect().left -
                        this._tabContainerEl.getBoundingClientRect().left;
                    /** @type {?} */
                    var rightPosition = allTabs[i].getBoundingClientRect().width + leftPosition;
                    if (rightPosition > this._tabContainerEl.offsetWidth) {
                        t_right_tooltips.push(this.tabs[i]);
                    }
                    else if (leftPosition < 0) {
                        t_left_tooltips.push(this.tabs[i]);
                    }
                }
                this.leftTooltipTabs = []
                    .concat(t_left_tooltips)
                    .slice(Math.max(0, t_left_tooltips.length - this.maxTooltipLen));
                this.rightTooltipTabs = []
                    .concat(t_right_tooltips)
                    .slice(0, Math.min(this.maxTooltipLen, t_right_tooltips.length));
                this.disableRTooltip = this.rightTooltipTabs.length < 1;
                this.disableLTooltip = this.leftTooltipTabs.length - hiddenTabsLength < 1;
            };
        /**
         * 重新计算左右箭头状态
         */
        /**
         * 重新计算左右箭头状态
         * @private
         * @return {?}
         */
        FarrisTabsComponent.prototype._reCalculateSides = /**
         * 重新计算左右箭头状态
         * @private
         * @return {?}
         */
            function () {
                this.disableRight =
                    this._tabContainerEl.scrollLeft >=
                        this._tabContainerEl.scrollWidth - this._tabContainerEl.offsetWidth;
                this.disableLeft = this._tabContainerEl.scrollLeft <= 0;
                this._reCalulateTooltips();
            };
        /**
         * 通过id寻找Tab
         * @param id ID
         */
        /**
         * 通过id寻找Tab
         * @private
         * @param {?} id ID
         * @return {?}
         */
        FarrisTabsComponent.prototype._getTabById = /**
         * 通过id寻找Tab
         * @private
         * @param {?} id ID
         * @return {?}
         */
            function (id) {
                /** @type {?} */
                var indexWidthId = [];
                /** @type {?} */
                var tabsWithId = this.tabs.filter(( /**
                 * @param {?} tab
                 * @param {?} index
                 * @return {?}
                 */function (tab, index) {
                    if (tab.id === id) {
                        indexWidthId.push(index);
                        return true;
                    }
                    else {
                        return false;
                    }
                }));
                return {
                    tab: tabsWithId.length ? tabsWithId[0] : null,
                    index: indexWidthId.length ? indexWidthId[0] : -1
                };
            };
        /*宽高类型是 string或者number 解析宽高  尺寸 */
        /*宽高类型是 string或者number 解析宽高  尺寸 */
        /**
         * @param {?} size
         * @return {?}
         */
        FarrisTabsComponent.prototype.resolveSize = /*宽高类型是 string或者number 解析宽高  尺寸 */
            /**
             * @param {?} size
             * @return {?}
             */
            function (size) {
                /** @type {?} */
                var regex = /px|em|rem|pt|%/;
                // 说明是字符串
                return regex.test(size)
                    ? "" + parseInt(size, 10) + size.match(regex)[0]
                    : size + "px";
            };
        /*
          清空tab
           */
        // removeAllTab() {
        //     this.tabs.splice(0, this.tabs.length);
        // }
        /*
              清空tab
               */
        // removeAllTab() {
        //     this.tabs.splice(0, this.tabs.length);
        // }
        /**
         * @return {?}
         */
        FarrisTabsComponent.prototype.hasInHeadCl = /*
              清空tab
               */
            // removeAllTab() {
            //     this.tabs.splice(0, this.tabs.length);
            // }
            /**
             * @return {?}
             */
            function () {
                if (this.toolbarConf && this.toolbarConf.hasOwnProperty('position') && this.toolbarConf.hasOwnProperty('contents') && this.toolbarConf.position === 'inHead' && this.toolbarConf.contents.length > 0) {
                    return true;
                }
                if (this.headerExtendConf && !(this.toolbarConf && this.toolbarConf.position === 'inContent' && this.toolbarConf.contents.length)) {
                    return true;
                }
                return false;
            };
        /**
     * 改变可用状态
     * @param values
     */
        /**
         * 改变可用状态
         * @private
         * @param {?} values
         * @param {?} stateProp
         * @return {?}
         */
        FarrisTabsComponent.prototype.changeState = /**
         * 改变可用状态
         * @private
         * @param {?} values
         * @param {?} stateProp
         * @return {?}
         */
            function (values, stateProp) {
                if (!this.toolbarConf || !this.toolbarConf.contents) {
                    return;
                }
                /** @type {?} */
                var idArray = Object.keys(values);
                this.toolbarConf.contents.forEach(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    /** @type {?} */
                    var findId = idArray.find(( /**
                     * @param {?} id
                     * @return {?}
                     */function (id) { return id == item.id; }));
                    if (findId) {
                        item[stateProp] = values[findId];
                    }
                    if (item['children'] && item['children'].length > 0) {
                        // 数据源只有一级的下拉
                        /** @type {?} */
                        var dpChildren = item.children;
                        dpChildren.forEach(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) {
                            /** @type {?} */
                            var findId = idArray.find(( /**
                             * @param {?} id
                             * @return {?}
                             */function (id) { return id == item.id; }));
                            if (findId) {
                                item[stateProp] = values[findId];
                            }
                        }));
                    }
                }));
                this.inMoreButtonContents.forEach(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) {
                    /** @type {?} */
                    var findId = idArray.find(( /**
                     * @param {?} id
                     * @return {?}
                     */function (id) { return id == item.id; }));
                    if (findId) {
                        item[stateProp] = values[findId];
                    }
                    if (item['children'] && item['children'].length > 0) {
                        // 数据源只有一级的下拉
                        /** @type {?} */
                        var dpChildren = item.children;
                        dpChildren.forEach(( /**
                         * @param {?} item
                         * @return {?}
                         */function (item) {
                            /** @type {?} */
                            var findId = idArray.find(( /**
                             * @param {?} id
                             * @return {?}
                             */function (id) { return id == item.id; }));
                            if (findId) {
                                item[stateProp] = values[findId];
                            }
                        }));
                    }
                }));
                this.dpState = [false];
                this.cdRef && !this.cdRef['destroyed'] && this.cdRef.detectChanges();
            };
        FarrisTabsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'farris-tabs',
                        template: "<div #tabHeader class=\"farris-tabs-header\"\r\n    [class.farris-tabs-inHead]=\"hasInHeadCl()\"\r\n    [class.farris-tabs-inContent]=\"!hasInHeadCl()\"\r\n    [class.farris-tabs-nav-fill]=\"fill||tabType=='fill'\"\r\n    [class.farris-tabs-nav-pills]=\"tabType=='pills'\"\r\n    >\r\n    <div class=\"farris-tabs-title scroll-tabs\"\r\n        [ngStyle]=\"{'width': hasInHeadCl() ? (titleWidth?titleWidth + '%':null) : null}\">\r\n        <button type=\"button\" (disabled)=\"disableLeft\" class=\"btn sc-nav-btn px-1 sc-nav-lr\"\r\n            [ngClass]=\"{'d-none':hideButtons}\" #leftNav>\r\n        </button>\r\n        <div class=\"spacer f-utils-fill\" #tabParent\r\n            [ngClass]=\"{'spacer-sides':!hideButtons&& hideDropDown,'spacer-sides-dropdown':!hideButtons&&!hideDropDown}\"\r\n            style=\"width:100%;\">\r\n            <ul class=\"nav farris-nav-tabs flex-nowrap\" [class.nav-fill]=\"fill||tabType=='fill'\"\r\n                [class.flex-row]=\"position==='top'||position==='bottom'\"\r\n                [class.flex-column]=\"position==='left'||position==='right'\" [class.nav-pills]=\"tabType=='pills'\" #tabContainer>\r\n                <li class=\"nav-item\" *ngFor=\"let tab of tabs;index as tabIndex\"\r\n                    [ngClass]=\"{'d-none': tab._show !== true, 'f-state-active': tab.id === activeId, 'f-state-disabled': tab.disabled === true}\"\r\n                    [ngStyle]=\"{'width':tab.tabWidth+'px'}\">\r\n                    <a class=\"nav-link tabs-text-truncate\" #anchor [class.active]=\"tab.id === activeId\"\r\n                        [class.disabled]=\"tab.disabled\" (click)=\"_cpSelectTabByIndex($event,tab.id)\">\r\n                        <span class=\"st-tab-text\" [class.farris-title-auto]=\"autoTitleWidth\"\r\n                            [ngClass]=\"tab.titleCustomCls\" [tabTransclude]=\"tab.headingRef\"\r\n                            *ngIf=\"tab.headingRef\"></span>\r\n                        <span class=\"st-tab-text\" [ngbTooltip]=\"tab.title\" [referElement]=\"tabContainer\"\r\n                            [disableTooltip]=\"!tab.titleOverflow\" [class.farris-title-auto]=\"autoTitleWidth\"\r\n                            [class.farris-title-text-custom]=\"tab.titleOverflow\"\r\n                            *ngIf=\"!tab.headingRef\">{{tab.title}}</span>\r\n                        <span class=\"st-drop-close\" *ngIf=\"tab.removeable\">\r\n                            <i class=\"f-icon f-icon-close\"></i>\r\n                        </span>\r\n                    </a>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n        <div class=\"btn-group sc-nav-btn\" ngbDropdown (openChange)=\"openChange($event)\" >\r\n            <button type=\"button\"  (disabled)=\"disableRight\" class=\"btn sc-nav-rg\" [ngClass]=\"{'d-none':hideButtons}\"\r\n                #rightNav></button>\r\n            <button #dropDownButton class=\"btn dropdown-toggle-split \" ngbDropdownToggle\r\n                [ngClass]=\"{'d-none':hideDropDown}\">\r\n            </button>\r\n            <div class=\"dropdown-menu\" style=\"max-width: 300px;\" [class.tabs-pt28]=\"searchBoxVisible\" ngbDropdownMenu #ddm=\"DropdownMenu\">\r\n                <div (click)=\"stopBubble($event)\" class='pb-1 tabs-li-absolute' *ngIf=\"searchBoxVisible\">\r\n                    <input type=\"text\" class=\"form-control k-textbox\" [(ngModel)]=\"searchTabText\"\r\n                        (keyup)=\"searchTab($event)\" />\r\n                    <span class=\"f-icon f-icon-page-title-query tabs-icon-search\"></span>\r\n                </div>\r\n                <ul class=\"tab-dropdown-menu--items\" [ngStyle]=\"{'width':menuItemsWidth}\">\r\n                    <li class=\"dropdown-item text-truncate px-2\" *ngFor=\"let tab of dropdownTabs;index as tabIndex\"\r\n                        [ngClass]=\"{'disabled': tab.disabled, 'active': tab.id === activeId, 'd-none': tab._show !==true}\"\r\n                        (click)=\"_cpSelectTabByIndex($event,tab.id, ddm)\">\r\n                        <a class=\"dropdown-title\" style=\"\r\n                            text-overflow: ellipsis;white-space: nowrap;word-break: break-word;width: 100%;\">{{tab.title}}</a>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div #toolbarContainer class=\"farris-tabs-toolbar\" *ngIf=\"toolbarConf || headerExtendConf\">\r\n        <div class=\"farris-tabs-inline-flex\" *ngIf=\"toolbarConf\">\r\n            <ng-template ngFor let-btn [ngForOf]=\"toolbarConf.contents\" let-i=\"index\" [ngForTrackBy]=\"trackByButton\">\r\n                <ng-container  *ngIf=\"getToolbarStateVisible(btn)\">\r\n                    <ng-container *ngIf=\"!btn.children||btn.children.length==0\">\r\n                        <button class=\"btn--cal\" [attr.id]=\"btn.id\" [ngClass]=\"btn.appearance.class\"  [disabled]=\"getToolbarStateDisable(btn)\"\r\n                        (click)=\"clickHandler(btn)\"  [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                        <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{btn.title}}\r\n                    </button>\r\n                    </ng-container>\r\n                    <ng-container *ngIf=\"btn.children&&btn.children.length>0\">\r\n                        <ng-container *ngTemplateOutlet=\"dropdownTmpl; context: { $implicit: btn }\"></ng-container>\r\n                    </ng-container>  \r\n                </ng-container>              \r\n            </ng-template>\r\n        </div>\r\n         <ng-container *ngIf=\"!toolbarDpHidden&&inMoreButtonContents.length>0\">\r\n            <div class=\"btn-group f-btn-ml sc-nav-btn\" fDropdown #ddmore=\"fDropdown\"  [forceState]=\"dpState\"  [rectifyReference]=\"referEl\" [autoRectify]=\"true\">\r\n                    <button class=\"btn btn-secondary morebtn  dropdown-toggle\" fDropdownToggle >{{'tabs.more' | locale}}</button>\r\n                    <ul class=\"dropdown-menu\" fDropdownMenu id=\"more_menu\">\r\n                        <ng-container *ngFor=\"let item of inMoreButtonContents\">                                            \r\n                            <ng-container  *ngIf=\"getToolbarStateVisible(item)\">\r\n                                <ng-container *ngIf=\"item.children&&item.children.length>0\">\r\n                                    <ng-container *ngTemplateOutlet=\"dropdownSubTmpl;context: { $implicit: item}\"></ng-container>\r\n                                </ng-container>\r\n                                <ng-container *ngIf=\"!item.children||item.children.length==0\">\r\n                                    <li class=\"dropdown-item  f-rt-btn\" id=\"{{ item.id }}\" [class.disabled]=\"getToolbarStateDisable(item)\"  (click)=\"clickHandler(item)\">\r\n                                        {{ item.title }}\r\n                                    </li>\r\n                                </ng-container>\r\n                            </ng-container>\r\n                        </ng-container>\r\n                    </ul>\r\n            </div> \r\n        </ng-container>             \r\n        <div *ngIf=\"headerExtendConf && headerExtendConf.templateRef\" class=\"farris-tabs-header-extend\"\r\n        [class.margin-right-14]=\"toolbarConf && toolbarConf.contents.length\"\r\n        [ngClass]=\"headerExtendConf && headerExtendConf.extendCls\">\r\n        <template [ngTemplateOutlet]=\"headerExtendConf.templateRef\"></template>\r\n    </div>\r\n    </div>\r\n    <!--\u8BA1\u7B97\u4F4D\u7F6E-->\r\n    <div class=\"farris-tabs-btn-placeholder\" *ngIf=\"toolbarConf\">\r\n        <div class=\"btn-group\"><button class=\"btn btn-secondary morebtn  dropdown-toggle\">{{'tabs.more' | locale}}</button></div>        \r\n        <div class=\"btn-placeholder--content\" #btnPlaceholder>\r\n            <ng-container *ngFor=\"let btn of toolbarConf.contents\">\r\n                <ng-container  *ngIf=\"getToolbarStateVisible(btn)\">                    \r\n                    <ng-container *ngIf=\"!btn.children||btn.children.length==0\">\r\n                        <button class=\"btn--cal\" [ngClass]=\"btn.appearance.class\"  [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                        <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{btn.title}}\r\n                    </button>\r\n                    </ng-container>\r\n                    <ng-container *ngIf=\"btn.children&&btn.children.length>0\">\r\n                        <div class=\"btn-group btn--cal\" [ngClass]=\"btn.appearance?.dropdownCls\" >\r\n                            <ng-container *ngIf=\"btn.split\">\r\n                                <button type=\"button\" class=\"btn\" [ngClass]=\"btn.appearance?.class\" [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                                    <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{ btn.title }}\r\n                                </button>\r\n                            <button class=\"btn dropdown-toggle dropdown-toggle-split\" [ngClass]=\"btn.appearance?.class\"></button>\r\n                            </ng-container>\r\n                            <!--\u4E0D\u542F\u7528\u4E0B\u62C9\u5206\u5F00\u6309\u94AE-->\r\n                            <ng-container *ngIf=\"!btn.split\">\r\n                                <button type=\"button\"  class=\"btn\" [ngClass]=\"btn.appearance?.class + ' dropdown-toggle'\"  [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                                    <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{ btn.title }}\r\n                                </button>\r\n                                <i></i>\r\n                            </ng-container>\r\n                        </div>\r\n                    </ng-container>  \r\n                </ng-container> \r\n            </ng-container>\r\n        </div>\r\n    </div>\r\n</div>\r\n<!--\u7B2C\u4E00\u5C42\u4E0B\u62C9-->\r\n<ng-template #dropdownTmpl let-data>\r\n    <div class=\"btn-group btn--cal\" id=\"{{ data.id }}\" [ngClass]=\"data.appearance?.dropdownCls\" fDropdown [rectifyReference]=\"referEl\"  [autoRectify]=\"true\">\r\n        <ng-container *ngIf=\"data.split\">\r\n            <button type=\"button\" class=\"btn\"  (click)=\"clickHandler(data)\" [ngClass]=\"data.appearance?.class\" [class.disabled]=\"getToolbarStateDisable(data)\" [class.btn-icontext]=\"data.icon&&data.icon.trim()\">\r\n                <i class=\"f-icon\" [ngClass]=\"data.icon&&data.icon.trim()\" *ngIf=\"data.icon&&data.icon.trim()\"></i>{{ data.title }}\r\n            </button>\r\n        <button class=\"btn dropdown-toggle dropdown-toggle-split\" [ngClass]=\"data.appearance?.class\" fDropdownToggle></button>\r\n        </ng-container>\r\n        <!--\u4E0D\u542F\u7528\u4E0B\u62C9\u5206\u5F00\u6309\u94AE-->\r\n        <ng-container *ngIf=\"!data.split\">\r\n            <button type=\"button\" fDropdownToggle class=\"btn\" [ngClass]=\"data.appearance?.class + ' dropdown-toggle'\"\r\n                [dpDisabled]=\"getToolbarStateDisable(data)\"  [class.btn-icontext]=\"data.icon&&data.icon.trim()\"   (click)=\"clickHandler(data)\">\r\n                <i class=\"f-icon\" [ngClass]=\"data.icon&&data.icon.trim()\" *ngIf=\"data.icon&&data.icon.trim()\"></i>{{ data.title }}\r\n            </button>\r\n            <i></i>\r\n        </ng-container>\r\n        <ul class=\"dropdown-menu\" fDropdownMenu id=\"{{ data.id }}_menu\">\r\n            <ng-container *ngTemplateOutlet=\"dropMenuItem; context: { $implicit: data.children }\"></ng-container>\r\n        </ul>\r\n    </div>\r\n</ng-template>\r\n<!--\u4E0B\u62C9\u5B50\u9879-->\r\n<ng-template #dropMenuItem let-data>\r\n    <ng-container *ngFor=\"let item of data\">\r\n        <ng-container *ngIf=\"getToolbarStateVisible(item)\">\r\n            <li class=\"dropdown-item\" id=\"{{ item.id }}\" [class.disabled]=\"getToolbarStateDisable(item)\"  (click)=\"clickHandler(item)\">\r\n                {{ item.title }}\r\n            </li>\r\n        </ng-container>\r\n    </ng-container>\r\n</ng-template>\r\n<!--\u7B2C\u4E8C\u5C42\u4E0B\u62C9-->\r\n<ng-template #dropdownSubTmpl let-subData>\r\n    <li class=\"dropdown-submenu\" fDropdown [isSubDP]=\"true\" [placement]=\"'left-bottom'\" [autoRectify]=\"true\" [rectifyReference]=\"referEl\" id=\"{{ subData.id }}\">\r\n        <ng-container *ngIf=\"subData.split\">\r\n            <span class=\"dropdown-item\" [class.disabled]=\"getToolbarStateDisable(subData)\"  (click)=\"clickHandler(subData)\">{{ subData.title }}</span>\r\n            <span class=\"dropdown-toggle dropdown-toggle-split\" fDropdownToggle></span>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!subData.split\">\r\n            <span class=\"dropdown-item  dropdown-toggle\" [dpDisabled]=\"getToolbarStateDisable(subData)\"  (click)=\"clickHandler(subData)\" fDropdownToggle>{{ subData.title }}</span>\r\n        </ng-container>\r\n        <ul class=\"dropdown-menu\" fDropdownMenu id=\"{{ subData.id }}_submenu\">\r\n            <ng-container *ngTemplateOutlet=\"dropMenuItem; context: { $implicit: subData.children }\"></ng-container>\r\n        </ul>\r\n    </li>\r\n</ng-template>\r\n<ng-content></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        styles: [".farris-tabs .farris-tabs-header.farris-tabs-inHead .farris-tabs-title{width:41.6666667%}.farris-tabs .farris-tabs-header.farris-tabs-inHead .farris-tabs-toolbar{-webkit-box-flex:1;flex:1;-webkit-box-align:center;align-items:center}.farris-tabs .farris-tabs-header .farris-tabs-title.scroll-tabs .spacer.spacer-sides-dropdown{margin:0 60px 0 28px}.farris-tabs .farris-tabs-header .farris-tabs-title.scroll-tabs .sc-nav-btn.dropdown{right:6px}.farris-tabs .margin-right-14{margin-right:14px}.farris-tabs .farris-tabs-header-extend{height:44px}.farris-tabs .farris-tabs-header .farris-tabs-title.scroll-tabs .spacer .farris-nav-tabs .nav-item .nav-link .farris-title-text{max-width:112px}.farris-tabs .tabs-pt28{padding:0}.farris-tabs .tab-dropdown-menu--items{max-height:200px;overflow:auto}.farris-tabs .tabs-li-absolute{padding:4px;margin:0;position:relative}.farris-tabs .tabs-icon-search{position:absolute;right:4px;top:50%;font-size:14px;padding:0 4px;width:auto;height:24px;color:rgba(0,0,0,.25);margin-top:-12px;line-height:20px}.farris-tabs .st-drop-close{line-height:1}.farris-tabs .dropdown-menu .dropdown-item .dropdown-title{overflow:hidden;display:inline-block;padding:0 5px}.farris-tabs .farris-tabs-header.farris-tabs-inHead .farris-tabs-inline-flex{overflow:hidden}.farris-tabs .farris-tabs-btn-placeholder{position:absolute;top:-30px;right:0;overflow:hidden;left:0;opacity:0;z-index:-90}.farris-tabs .farris-tabs-btn-placeholder .btn-placeholder--content{display:-webkit-inline-box;display:inline-flex;left:0;position:absolute}"]
                    }] }
        ];
        /** @nocollapse */
        FarrisTabsComponent.ctorParameters = function () {
            return [
                { type: TabService },
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.ChangeDetectorRef },
                { type: core.NgZone }
            ];
        };
        FarrisTabsComponent.propDecorators = {
            tabType: [{ type: core.Input }],
            fill: [{ type: core.Input }],
            autoTitleWidth: [{ type: core.Input }],
            titleLength: [{ type: core.Input }],
            position: [{ type: core.Input }],
            showDropDown: [{ type: core.Input }],
            showTooltips: [{ type: core.Input }],
            scrollStep: [{ type: core.Input }],
            autoResize: [{ type: core.Input }],
            closeable: [{ type: core.Input }],
            selectId: [{ type: core.Input, args: ['value',] }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            searchBoxVisible: [{ type: core.Input }],
            headerHeight: [{ type: core.Input, args: ['header-height',] }],
            contentDirection: [{ type: core.Input }],
            contentFill: [{ type: core.Input }],
            clickThrottleTime: [{ type: core.Input }],
            btnStates: [{ type: core.Input }],
            btnVisible: [{ type: core.Input }],
            tabs: [{ type: core.Input }],
            customClass: [{ type: core.Input }],
            titleWidth: [{ type: core.Input }],
            leftNav: [{ type: core.ViewChild, args: ['leftNav',] }],
            rightNav: [{ type: core.ViewChild, args: ['rightNav',] }],
            tabContainer: [{ type: core.ViewChild, args: ['tabContainer',] }],
            toolbarContainer: [{ type: core.ViewChild, args: ['toolbarContainer',] }],
            dropDownButton: [{ type: core.ViewChild, args: ['dropDownButton',] }],
            tabParent: [{ type: core.ViewChild, args: ['tabParent',] }],
            btnPlaceHolder: [{ type: core.ViewChild, args: ['btnPlaceholder',] }],
            beforeSelect: [{ type: core.Input }],
            tabChange: [{ type: core.Output }],
            tabRemove: [{ type: core.Output }],
            ddm: [{ type: core.ViewChild, args: ['ddm',] }]
        };
        return FarrisTabsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FarrisTabsExtendDirective = /** @class */ (function () {
        function FarrisTabsExtendDirective(templateRef) {
            this.templateRef = templateRef;
        }
        FarrisTabsExtendDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[farrisTabsExtend]',
                    },] }
        ];
        /** @nocollapse */
        FarrisTabsExtendDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef }
            ];
        };
        FarrisTabsExtendDirective.propDecorators = {
            extendCls: [{ type: core.Input }]
        };
        return FarrisTabsExtendDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FarrisTabComponent = /** @class */ (function () {
        function FarrisTabComponent(cp, componentFactoryResolver, render, el, cef, scrollTabs) {
            this.cp = cp;
            this.componentFactoryResolver = componentFactoryResolver;
            this.render = render;
            this.el = el;
            this.cef = cef;
            this.scrollTabs = scrollTabs;
            this.tabWidth = -1;
            // 追加自定义的样式
            this.titleCustomCls = '';
            // selected 是否选中
            // tslint:disable-next-line:no-inferrable-types
            this.selected = false;
            // appDiv: T;
            this.showStates = new rxjs.BehaviorSubject(true);
            // 兼容旧表单
            this.activeState = new rxjs.BehaviorSubject(false);
            this._show = true;
        }
        Object.defineProperty(FarrisTabComponent.prototype, "show", {
            get: /**
             * @return {?}
             */ function () {
                return this._show;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._show != value) {
                    this.showStates.next(value);
                    this._show = value;
                    this.scrollTabs.tabVisibleChanged.next({ tab: this, visible: value });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabComponent.prototype, "_active", {
            get: /**
             * @return {?}
             */ function () {
                return this._activeForOld;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._activeForOld = value;
                this.activeState.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FarrisTabComponent.prototype, "active", {
            // 无用代码
            get: 
            // 无用代码
            /**
             * @return {?}
             */
            function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 内容是否激活
         */
        /**
         * 内容是否激活
         * @return {?}
         */
        FarrisTabComponent.prototype.ngOnInit = /**
         * 内容是否激活
         * @return {?}
         */
            function () {
                this.scrollTabs.tabs.push(this);
                if (!this.scrollTabs.activeId) {
                    this.scrollTabs.tabs[0]._active = true;
                }
                else {
                    this.scrollTabs.load();
                }
            };
        /**
         * @return {?}
         */
        FarrisTabComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // 为了兼容弄旧表单，不兼容HostBinding, 通过追加class的方式实现
                /** @type {?} */
                var nEl = this.el.nativeElement;
                this.activeState.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    _this.render.addClass(nEl, 'farris-tabs-body');
                    if (data) {
                        _this.render.addClass(nEl, 'f-tab-active');
                        _this.render.removeClass(nEl, 'f-tab-d-none');
                    }
                    else {
                        _this.render.addClass(nEl, 'f-tab-d-none');
                        _this.render.removeClass(nEl, 'f-tab-active');
                    }
                }));
            };
        /**
         * @return {?}
         */
        FarrisTabComponent.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        FarrisTabComponent.prototype.loadComponent = /**
         * @return {?}
         */
            function () {
            };
        FarrisTabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'farris-tab',
                        template: "<!-- \u5F02\u6B65\u83B7\u53D6\u7EC4\u4EF6 -->\r\n<ng-template [ngTemplateOutlet]=\"contentTempl\"></ng-template>\r\n<ng-container>\r\n    <ng-container *ngComponentOutlet=\"asyncComponent;ngModuleFactory:asyncModule\">\r\n    </ng-container>\r\n</ng-container>\r\n\r\n"
                    }] }
        ];
        /** @nocollapse */
        FarrisTabComponent.ctorParameters = function () {
            return [
                { type: core.Compiler },
                { type: core.ComponentFactoryResolver },
                { type: core.Renderer2 },
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef },
                { type: FarrisTabsComponent, decorators: [{ type: core.Optional }] }
            ];
        };
        FarrisTabComponent.propDecorators = {
            tabWidth: [{ type: core.Input, args: ['width',] }],
            show: [{ type: core.Input }],
            asyncComponent: [{ type: core.Input }],
            asyncModule: [{ type: core.Input }],
            id: [{ type: core.Input }],
            titleCustomCls: [{ type: core.Input }],
            title: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            removeable: [{ type: core.Input }],
            toolbar: [{ type: core.Input }],
            contentTempl: [{ type: core.ContentChild, args: ['content',] }],
            farrisTabsExtendDirective: [{ type: core.ContentChild, args: [FarrisTabsExtendDirective,] }]
        };
        return FarrisTabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TabTranscludeDirective = /** @class */ (function () {
        function TabTranscludeDirective(viewRef, _differs) {
            this._differs = _differs;
            // setTimeout(() => {
            this.viewRef = viewRef;
            // }, 5000);
            // this.cd.detectChanges();
        }
        Object.defineProperty(TabTranscludeDirective.prototype, "trancludeTempl", {
            get: /**
             * @return {?}
             */ function () {
                return this._trancludeTempl;
            },
            set: /**
             * @param {?} templateRef
             * @return {?}
             */ function (templateRef) {
                this._trancludeTempl = templateRef;
                if (templateRef) {
                    this.viewRef.createEmbeddedView(templateRef);
                }
                // if (!this._differ && templateRef) {
                //     this._differ = this._differs.find(templateRef).create();
                // }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabTranscludeDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // this.setIntervalTemp = setInterval(() => {
                //     if (this._trancludeTempl && this.viewRef) {
                //         console.log('sa');
                //         // this.viewRef = this.viewRef;
                //         clearInterval(this.setIntervalTemp);
                //     }
                // }, 0);
            };
        /**
         * @return {?}
         */
        TabTranscludeDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                // const CHANGE = this._differ.diff(this._trancludeTempl);
                // if (CHANGE) {
                //     this.viewRef.createEmbeddedView(this._trancludeTempl);
                // }
            };
        TabTranscludeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[tabTransclude]',
                    },] }
        ];
        /** @nocollapse */
        TabTranscludeDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef },
                { type: core.KeyValueDiffers }
            ];
        };
        TabTranscludeDirective.propDecorators = {
            trancludeTempl: [{ type: core.Input, args: ['tabTransclude',] }]
        };
        return TabTranscludeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TabHeadDirective = /** @class */ (function () {
        function TabHeadDirective(tabItem, el, template) {
            tabItem.headingRef = template;
        }
        TabHeadDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[tabHead]'
                    },] }
        ];
        /** @nocollapse */
        TabHeadDirective.ctorParameters = function () {
            return [
                { type: FarrisTabComponent },
                { type: core.ElementRef },
                { type: core.TemplateRef }
            ];
        };
        return TabHeadDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration service for the NgbDropdown directive.
     * You can inject this service, typically in your root component, and customize the values of its properties in
     * order to provide default values for all the dropdowns used in the application.
     */
    var NgbDropdownConfig = /** @class */ (function () {
        function NgbDropdownConfig() {
            this.autoClose = true;
            this.placement = 'bottom-right';
        }
        NgbDropdownConfig.decorators = [
            { type: core.Injectable }
        ];
        return NgbDropdownConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // previous version:
    // https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js
    var 
    // previous version:
    // https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js
    Positioning = /** @class */ (function () {
        function Positioning() {
        }
        /**
         * @private
         * @param {?} element
         * @return {?}
         */
        Positioning.prototype.getAllStyles = /**
         * @private
         * @param {?} element
         * @return {?}
         */
            function (element) { return window.getComputedStyle(element); };
        /**
         * @private
         * @param {?} element
         * @param {?} prop
         * @return {?}
         */
        Positioning.prototype.getStyle = /**
         * @private
         * @param {?} element
         * @param {?} prop
         * @return {?}
         */
            function (element, prop) { return this.getAllStyles(element)[prop]; };
        /**
         * @private
         * @param {?} element
         * @return {?}
         */
        Positioning.prototype.isStaticPositioned = /**
         * @private
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return (this.getStyle(element, 'position') || 'static') === 'static';
            };
        /**
         * @private
         * @param {?} element
         * @return {?}
         */
        Positioning.prototype.offsetParent = /**
         * @private
         * @param {?} element
         * @return {?}
         */
            function (element) {
                /** @type {?} */
                var offsetParentEl = ( /** @type {?} */(element.offsetParent)) || document.documentElement;
                while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {
                    offsetParentEl = ( /** @type {?} */(offsetParentEl.offsetParent));
                }
                return offsetParentEl || document.documentElement;
            };
        /**
         * @param {?} element
         * @param {?=} round
         * @return {?}
         */
        Positioning.prototype.position = /**
         * @param {?} element
         * @param {?=} round
         * @return {?}
         */
            function (element, round) {
                if (round === void 0) {
                    round = true;
                }
                /** @type {?} */
                var elPosition;
                /** @type {?} */
                var parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };
                if (this.getStyle(element, 'position') === 'fixed') {
                    elPosition = element.getBoundingClientRect();
                }
                else {
                    /** @type {?} */
                    var offsetParentEl = this.offsetParent(element);
                    elPosition = this.offset(element, false);
                    if (offsetParentEl !== document.documentElement) {
                        parentOffset = this.offset(offsetParentEl, false);
                    }
                    parentOffset.top += offsetParentEl.clientTop;
                    parentOffset.left += offsetParentEl.clientLeft;
                }
                elPosition.top -= parentOffset.top;
                elPosition.bottom -= parentOffset.top;
                elPosition.left -= parentOffset.left;
                elPosition.right -= parentOffset.left;
                if (round) {
                    elPosition.top = Math.round(elPosition.top);
                    elPosition.bottom = Math.round(elPosition.bottom);
                    elPosition.left = Math.round(elPosition.left);
                    elPosition.right = Math.round(elPosition.right);
                }
                return elPosition;
            };
        /**
         * @param {?} element
         * @param {?=} round
         * @return {?}
         */
        Positioning.prototype.offset = /**
         * @param {?} element
         * @param {?=} round
         * @return {?}
         */
            function (element, round) {
                if (round === void 0) {
                    round = true;
                }
                /** @type {?} */
                var elBcr = element.getBoundingClientRect();
                /** @type {?} */
                var viewportOffset = {
                    top: window.pageYOffset - document.documentElement.clientTop,
                    left: window.pageXOffset - document.documentElement.clientLeft
                };
                /** @type {?} */
                var elOffset = {
                    height: elBcr.height || element.offsetHeight,
                    width: elBcr.width || element.offsetWidth,
                    top: elBcr.top + viewportOffset.top,
                    bottom: elBcr.bottom + viewportOffset.top,
                    left: elBcr.left + viewportOffset.left,
                    right: elBcr.right + viewportOffset.left
                };
                if (round) {
                    elOffset.height = Math.round(elOffset.height);
                    elOffset.width = Math.round(elOffset.width);
                    elOffset.top = Math.round(elOffset.top);
                    elOffset.bottom = Math.round(elOffset.bottom);
                    elOffset.left = Math.round(elOffset.left);
                    elOffset.right = Math.round(elOffset.right);
                }
                return elOffset;
            };
        /**
         * @param {?} hostElement
         * @param {?} targetElement
         * @param {?} placement
         * @param {?=} appendToBody
         * @param {?=} referElement
         * @return {?}
         */
        Positioning.prototype.positionElements = /**
         * @param {?} hostElement
         * @param {?} targetElement
         * @param {?} placement
         * @param {?=} appendToBody
         * @param {?=} referElement
         * @return {?}
         */
            function (hostElement, targetElement, placement, appendToBody, referElement) {
                /** @type {?} */
                var oldhostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);
                /** @type {?} */
                var hostElPosition = this.getRectCompareReferElementAndHostElement(oldhostElPosition, referElement);
                /** @type {?} */
                var targetElStyles = this.getAllStyles(targetElement);
                /** @type {?} */
                var targetElBCR = targetElement.getBoundingClientRect();
                /** @type {?} */
                var placementPrimary = placement.split('-')[0] || 'top';
                /** @type {?} */
                var placementSecondary = placement.split('-')[1] || 'center';
                /** @type {?} */
                var targetElPosition = {
                    'height': targetElBCR.height || targetElement.offsetHeight,
                    'width': targetElBCR.width || targetElement.offsetWidth,
                    'top': 0,
                    'bottom': targetElBCR.height || targetElement.offsetHeight,
                    'left': 0,
                    'right': targetElBCR.width || targetElement.offsetWidth
                };
                switch (placementPrimary) {
                    case 'top':
                        targetElPosition.top =
                            hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));
                        break;
                    case 'bottom':
                        targetElPosition.top = hostElPosition.top + hostElPosition.height;
                        break;
                    case 'left':
                        targetElPosition.left =
                            hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));
                        break;
                    case 'right':
                        targetElPosition.left = hostElPosition.left + hostElPosition.width;
                        break;
                }
                switch (placementSecondary) {
                    case 'top':
                        targetElPosition.top = hostElPosition.top;
                        break;
                    case 'bottom':
                        targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;
                        break;
                    case 'left':
                        targetElPosition.left = hostElPosition.left;
                        break;
                    case 'right':
                        targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;
                        break;
                    case 'center':
                        if (placementPrimary === 'top' || placementPrimary === 'bottom') {
                            targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;
                        }
                        else {
                            targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;
                        }
                        break;
                }
                targetElPosition.top = Math.round(targetElPosition.top);
                targetElPosition.bottom = Math.round(targetElPosition.bottom);
                targetElPosition.left = Math.round(targetElPosition.left);
                targetElPosition.right = Math.round(targetElPosition.right);
                return targetElPosition;
            };
        /**
         * @private
         * @param {?} hostRect
         * @param {?} referElement
         * @return {?}
         */
        Positioning.prototype.getRectCompareReferElementAndHostElement = /**
         * @private
         * @param {?} hostRect
         * @param {?} referElement
         * @return {?}
         */
            function (hostRect, referElement) {
                /** @type {?} */
                var hostElemClientRect = {
                    left: hostRect.left,
                    bottom: hostRect.bottom,
                    height: hostRect.height,
                    right: hostRect.right,
                    top: hostRect.top,
                    width: hostRect.width
                };
                if (referElement) {
                    /** @type {?} */
                    var referRect = referElement.getBoundingClientRect();
                    if (referRect.left > hostRect.left) {
                        hostElemClientRect.left = referRect.left;
                    }
                    if (referRect.right < hostRect.right) {
                        hostElemClientRect.right = referRect.right;
                    }
                    hostElemClientRect.width = Math.min(referRect.width, hostRect.width, (hostElemClientRect.right - hostElemClientRect.left));
                }
                return hostElemClientRect;
            };
        // get the availble placements of the target element in the viewport dependeing on the host element
        // get the availble placements of the target element in the viewport dependeing on the host element
        /**
         * @param {?} hostElement
         * @param {?} targetElement
         * @param {?} referElement
         * @return {?}
         */
        Positioning.prototype.getAvailablePlacements =
            // get the availble placements of the target element in the viewport dependeing on the host element
            /**
             * @param {?} hostElement
             * @param {?} targetElement
             * @param {?} referElement
             * @return {?}
             */
            function (hostElement, targetElement, referElement) {
                /** @type {?} */
                var oldhostElemClientRect = hostElement.getBoundingClientRect();
                /** @type {?} */
                var hostElemClientRect = this.getRectCompareReferElementAndHostElement(oldhostElemClientRect, referElement);
                /** @type {?} */
                var availablePlacements = [];
                /** @type {?} */
                var targetElemClientRect = targetElement.getBoundingClientRect();
                /** @type {?} */
                var html = document.documentElement;
                /** @type {?} */
                var windowHeight = window.innerHeight || html.clientHeight;
                /** @type {?} */
                var windowWidth = window.innerWidth || html.clientWidth;
                /** @type {?} */
                var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;
                /** @type {?} */
                var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2;
                // left: check if target width can be placed between host left and viewport start and also height of target is
                // inside viewport
                if (targetElemClientRect.width < hostElemClientRect.left) {
                    // check for left only
                    if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&
                        windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {
                        availablePlacements.splice(availablePlacements.length, 1, 'left');
                    }
                    // check for left-top and left-bottom
                    this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);
                }
                // top: target height is less than host top
                if (targetElemClientRect.height < hostElemClientRect.top) {
                    if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&
                        windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {
                        availablePlacements.splice(availablePlacements.length, 1, 'top');
                    }
                    this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);
                }
                // right: check if target width can be placed between host right and viewport end and also height of target is
                // inside viewport
                if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {
                    // check for right only
                    if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&
                        windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {
                        availablePlacements.splice(availablePlacements.length, 1, 'right');
                    }
                    // check for right-top and right-bottom
                    this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);
                }
                // bottom: check if there is enough space between host bottom and viewport end for target height
                if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {
                    if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&
                        windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {
                        availablePlacements.splice(availablePlacements.length, 1, 'bottom');
                    }
                    this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);
                }
                return availablePlacements;
            };
        /**
         * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom
         * primaryplacement: left|right
         * availablePlacementArr: array in which available placemets to be set
         */
        /**
         * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom
         * primaryplacement: left|right
         * availablePlacementArr: array in which available placemets to be set
         * @private
         * @param {?} hostElemClientRect
         * @param {?} targetElemClientRect
         * @param {?} primaryPlacement
         * @param {?} availablePlacementArr
         * @return {?}
         */
        Positioning.prototype.setSecondaryPlacementForLeftRight = /**
         * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom
         * primaryplacement: left|right
         * availablePlacementArr: array in which available placemets to be set
         * @private
         * @param {?} hostElemClientRect
         * @param {?} targetElemClientRect
         * @param {?} primaryPlacement
         * @param {?} availablePlacementArr
         * @return {?}
         */
            function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {
                /** @type {?} */
                var html = document.documentElement;
                // check for left-bottom
                if (targetElemClientRect.height <= hostElemClientRect.bottom) {
                    availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');
                }
                if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {
                    availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');
                }
            };
        /**
         * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right
         * primaryplacement: top|bottom
         * availablePlacementArr: array in which available placemets to be set
         */
        /**
         * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right
         * primaryplacement: top|bottom
         * availablePlacementArr: array in which available placemets to be set
         * @private
         * @param {?} hostElemClientRect
         * @param {?} targetElemClientRect
         * @param {?} primaryPlacement
         * @param {?} availablePlacementArr
         * @return {?}
         */
        Positioning.prototype.setSecondaryPlacementForTopBottom = /**
         * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right
         * primaryplacement: top|bottom
         * availablePlacementArr: array in which available placemets to be set
         * @private
         * @param {?} hostElemClientRect
         * @param {?} targetElemClientRect
         * @param {?} primaryPlacement
         * @param {?} availablePlacementArr
         * @return {?}
         */
            function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {
                /** @type {?} */
                var html = document.documentElement;
                // check for left-bottom
                if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {
                    availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');
                }
                if (targetElemClientRect.width <= hostElemClientRect.right) {
                    availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');
                }
            };
        return Positioning;
    }());
    /** @type {?} */
    var positionService = new Positioning();
    /*
     * Accept the placement array and applies the appropriate placement dependent on the viewport.
     * Returns the applied placement.
     * In case of auto placement, placements are selected in order
     *   'top', 'bottom', 'left', 'right',
     *   'top-left', 'top-right',
     *   'bottom-left', 'bottom-right',
     *   'left-top', 'left-bottom',
     *   'right-top', 'right-bottom'.
     * */
    /**
     * @param {?} hostElement
     * @param {?} targetElement
     * @param {?} placement
     * @param {?=} appendToBody
     * @param {?=} referElement
     * @return {?}
     */
    function positionElements(hostElement, targetElement, placement, appendToBody, referElement) {
        var e_1, _a;
        /** @type {?} */
        var placementVals = Array.isArray(placement) ? placement : [( /** @type {?} */(placement))];
        // replace auto placement with other placements
        /** @type {?} */
        var hasAuto = placementVals.findIndex(( /**
         * @param {?} val
         * @return {?}
         */function (val) { return val === 'auto'; }));
        if (hasAuto >= 0) {
            ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top',
                'left-bottom', 'right-top', 'right-bottom',
            ].forEach(( /**
             * @param {?} obj
             * @return {?}
             */function (obj) {
                if (placementVals.find(( /**
                 * @param {?} val
                 * @return {?}
                 */function (val) { return val.search('^' + obj) !== -1; })) == null) {
                    placementVals.splice(hasAuto++, 1, ( /** @type {?} */(obj)));
                }
            }));
        }
        // coordinates where to position
        /** @type {?} */
        var topVal = 0;
        /** @type {?} */
        var leftVal = 0;
        /** @type {?} */
        var appliedPlacement;
        // get available placements
        /** @type {?} */
        var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement, referElement);
        var _loop_1 = function (item, index) {
            // check if passed placement is present in the available placement or otherwise apply the last placement in the
            // passed placement list
            if ((availablePlacements.find(( /**
             * @param {?} val
             * @return {?}
             */function (val) { return val === item; })) != null) || (placementVals.length === index + 1)) {
                appliedPlacement = ( /** @type {?} */(item));
                /** @type {?} */
                var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody, referElement);
                topVal = pos.top;
                leftVal = pos.left;
                return "break";
            }
        };
        try {
            // iterate over all the passed placements
            for (var _b = __values(toItemIndexes(placementVals)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = _c.value, item = _d.item, index = _d.index;
                var state_1 = _loop_1(item, index);
                if (state_1 === "break")
                    break;
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
        targetElement.style.top = topVal + "px";
        targetElement.style.left = leftVal + "px";
        return appliedPlacement;
    }
    // function to get index and item of an array
    /**
     * @template T
     * @param {?} a
     * @return {?}
     */
    function toItemIndexes(a) {
        return a.map(( /**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */function (item, index) { return ({ item: item, index: index }); }));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     *
     */
    var NgbDropdownMenu = /** @class */ (function () {
        function NgbDropdownMenu(dropdown, _elementRef, _renderer) {
            this.dropdown = dropdown;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.placement = "bottom";
            this.isOpen = false;
        }
        /*
         * 因为下拉面板可能存在遮挡的问题,计算宽度
         */
        /*
             * 因为下拉面板可能存在遮挡的问题,计算宽度
             */
        /**
         * @return {?}
         */
        NgbDropdownMenu.prototype.resetMenuElWidthOpen = /*
             * 因为下拉面板可能存在遮挡的问题,计算宽度
             */
            /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var parentNode = this._elementRef.nativeElement.parentNode.parentNode;
                /** @type {?} */
                var parentNodeW = parentNode
                    ? parentNode.getBoundingClientRect().width
                    : 0;
                /** @type {?} */
                var menuW = this._elementRef.nativeElement.getBoundingClientRect().width;
                return Math.min(menuW, parentNodeW);
            };
        /**
         * @param {?} $event
         * @return {?}
         */
        NgbDropdownMenu.prototype.isEventFrom = /**
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                return this._elementRef.nativeElement.contains($event.target);
            };
        /**
         * @param {?} triggerEl
         * @param {?} placement
         * @return {?}
         */
        NgbDropdownMenu.prototype.position = /**
         * @param {?} triggerEl
         * @param {?} placement
         * @return {?}
         */
            function (triggerEl, placement) {
                var _this = this;
                //
                if (this._elementRef.nativeElement.getBoundingClientRect().width == 0) {
                    setTimeout(( /**
                     * @return {?}
                     */function () {
                        _this.applyPlacement(positionElements(triggerEl, _this._elementRef.nativeElement, placement));
                    }), 0);
                }
                else {
                    this.applyPlacement(positionElements(triggerEl, this._elementRef.nativeElement, placement));
                }
            };
        /**
         * @param {?} _placement
         * @return {?}
         */
        NgbDropdownMenu.prototype.applyPlacement = /**
         * @param {?} _placement
         * @return {?}
         */
            function (_placement) {
                // remove the current placement classes
                this._renderer.removeClass(this._elementRef.nativeElement.parentNode, "dropup");
                this._renderer.removeClass(this._elementRef.nativeElement.parentNode, "dropdown");
                this.placement = _placement;
                /**
                 * apply the new placement
                 * in case of top use up-arrow or down-arrow otherwise
                 */
                if (_placement.search("^top") !== -1) {
                    this._renderer.addClass(this._elementRef.nativeElement.parentNode, "dropup");
                }
                else {
                    this._renderer.addClass(this._elementRef.nativeElement.parentNode, "dropdown");
                }
            };
        NgbDropdownMenu.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngbDropdownMenu]",
                        host: {
                            "[class.dropdown-menu]": "true",
                            "[class.show]": "dropdown.isOpen()",
                            "[attr.x-placement]": "placement",
                        },
                        exportAs: "DropdownMenu",
                    },] }
        ];
        /** @nocollapse */
        NgbDropdownMenu.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: [core.forwardRef(( /**
                                                 * @return {?}
                                                 */function () { return NgbDropdown; })),] }] },
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        return NgbDropdownMenu;
    }());
    /**
     * Marks an element to which dropdown menu will be anchored. This is a simple version
     * of the NgbDropdownToggle directive. It plays the same role as NgbDropdownToggle but
     * doesn't listen to click events to toggle dropdown menu thus enabling support for
     * events other than click.
     *
     * \@since 1.1.0
     */
    var NgbDropdownAnchor = /** @class */ (function () {
        function NgbDropdownAnchor(dropdown, _elementRef) {
            this.dropdown = dropdown;
            this._elementRef = _elementRef;
            this.anchorEl = _elementRef.nativeElement;
        }
        /**
         * @param {?} $event
         * @return {?}
         */
        NgbDropdownAnchor.prototype.isEventFrom = /**
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                return this._elementRef.nativeElement.contains($event.target);
            };
        NgbDropdownAnchor.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngbDropdownAnchor]",
                        host: {
                            class: "dropdown-toggle",
                            "aria-haspopup": "true",
                            "[attr.aria-expanded]": "dropdown.isOpen()",
                        },
                    },] }
        ];
        /** @nocollapse */
        NgbDropdownAnchor.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: [core.forwardRef(( /**
                                                 * @return {?}
                                                 */function () { return NgbDropdown; })),] }] },
                { type: core.ElementRef }
            ];
        };
        return NgbDropdownAnchor;
    }());
    /**
     * Allows the dropdown to be toggled via click. This directive is optional: you can use NgbDropdownAnchor as an
     * alternative.
     */
    var NgbDropdownToggle = /** @class */ (function (_super) {
        __extends(NgbDropdownToggle, _super);
        function NgbDropdownToggle(dropdown, elementRef) {
            return _super.call(this, dropdown, elementRef) || this;
        }
        /**
         * @param {?=} $event
         * @return {?}
         */
        NgbDropdownToggle.prototype.toggleOpen = /**
         * @param {?=} $event
         * @return {?}
         */
            function ($event) {
                if ($event) {
                    $event.stopPropagation();
                }
                this.dropdown.toggle();
            };
        NgbDropdownToggle.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngbDropdownToggle]",
                        host: {
                            class: "dropdown-toggle",
                            "aria-haspopup": "true",
                            "[attr.aria-expanded]": "dropdown.isOpen()",
                            "(click)": "toggleOpen($event)",
                        },
                        providers: [
                            {
                                provide: NgbDropdownAnchor,
                                useExisting: core.forwardRef(( /**
                                 * @return {?}
                                 */function () { return NgbDropdownToggle; })),
                            },
                        ],
                    },] }
        ];
        /** @nocollapse */
        NgbDropdownToggle.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: [core.forwardRef(( /**
                                                 * @return {?}
                                                 */function () { return NgbDropdown; })),] }] },
                { type: core.ElementRef }
            ];
        };
        return NgbDropdownToggle;
    }(NgbDropdownAnchor));
    /**
     * Transforms a node into a dropdown.
     */
    var NgbDropdown = /** @class */ (function () {
        function NgbDropdown(config, ngZone) {
            var _this = this;
            /**
             *  Defines whether or not the dropdown-menu is open initially.
             */
            this._open = false;
            /**
             * Placement of a popover accepts:
             *    "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
             *    "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
             * and array of above values.
             */
            this.placement = ["auto", "bottom"];
            /**
             *  An event fired when the dropdown is opened or closed.
             *  Event's payload equals whether dropdown is open.
             */
            this.openChange = new core.EventEmitter();
            this.overLayService = null;
            this.placement = config.placement;
            this.autoClose = config.autoClose;
            // 此处原意是解决menu还没有被显示时，会再次调用计算位置。但是在框架会出现位置只计算一次的情况
            this._zoneSubscription = ngZone.onStable.subscribe(( /**
             * @return {?}
             */function () {
                _this._positionMenu();
            }));
            this.overLayService = new uiCommon.OverLayHiddenService();
        }
        /**
         * @return {?}
         */
        NgbDropdown.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this._menu) {
                    this._menu.applyPlacement(Array.isArray(this.placement)
                        ? this.placement[0]
                        : (( /** @type {?} */(this.placement))));
                }
            };
        /**
         * Checks if the dropdown menu is open or not.
         */
        /**
         * Checks if the dropdown menu is open or not.
         * @return {?}
         */
        NgbDropdown.prototype.isOpen = /**
         * Checks if the dropdown menu is open or not.
         * @return {?}
         */
            function () {
                return this._open;
            };
        /**
         * Opens the dropdown menu of a given navbar or tabbed navigation.
         */
        /**
         * Opens the dropdown menu of a given navbar or tabbed navigation.
         * @return {?}
         */
        NgbDropdown.prototype.open = /**
         * Opens the dropdown menu of a given navbar or tabbed navigation.
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this._open) {
                    this._open = true;
                    this._positionMenu();
                    this.openChange.emit(true);
                    this._menu._elementRef.nativeElement.classList.add('show');
                    // 注册鼠标滚轮，点击事件，用于隐藏Panel
                    this.overLayService.registerMouseEvent(this._menu._elementRef.nativeElement, ( /**
                     * @param {?} e
                     * @return {?}
                     */function (e) {
                        /** @type {?} */
                        var tar = ( /** @type {?} */(e.target));
                        /** @type {?} */
                        var classList = Array.from(tar.classList || []);
                        if (_this._menu._elementRef.nativeElement.contains(e.target)) {
                            return;
                        }
                        if (classList.includes('morebtn') ||
                            classList.includes("dropdown-toggle") ||
                            tar.closest(".dropdown-item") ||
                            classList.includes("dropdown-item")) {
                            return;
                        }
                        _this.close();
                    }));
                }
            };
        /**
         * Closes the dropdown menu of a given navbar or tabbed navigation.
         */
        /**
         * Closes the dropdown menu of a given navbar or tabbed navigation.
         * @return {?}
         */
        NgbDropdown.prototype.close = /**
         * Closes the dropdown menu of a given navbar or tabbed navigation.
         * @return {?}
         */
            function () {
                if (this._open) {
                    this._open = false;
                    this.openChange.emit(false);
                    this._menu._elementRef.nativeElement.classList.remove('show');
                    this.overLayService.destory(this._menu._elementRef.nativeElement);
                }
            };
        /**
         * Toggles the dropdown menu of a given navbar or tabbed navigation.
         */
        /**
         * Toggles the dropdown menu of a given navbar or tabbed navigation.
         * @return {?}
         */
        NgbDropdown.prototype.toggle = /**
         * Toggles the dropdown menu of a given navbar or tabbed navigation.
         * @return {?}
         */
            function () {
                if (this.isOpen()) {
                    this.close();
                }
                else {
                    this.open();
                }
            };
        /**
         * @param {?} $event
         * @return {?}
         */
        NgbDropdown.prototype.closeFromClick = /**
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                if (this.autoClose &&
                    $event.button !== 2 &&
                    !this._isEventFromToggle($event)) {
                    if (this.autoClose === true) {
                        this.close();
                    }
                    else if (this.autoClose === "inside" &&
                        this._isEventFromMenu($event)) {
                        this.close();
                    }
                    else if (this.autoClose === "outside" &&
                        !this._isEventFromMenu($event)) {
                        this.close();
                    }
                }
            };
        /**
         * @return {?}
         */
        NgbDropdown.prototype.closeFromOutsideEsc = /**
         * @return {?}
         */
            function () {
                if (this.autoClose) {
                    this.close();
                }
            };
        /**
         * @return {?}
         */
        NgbDropdown.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._zoneSubscription)
                    this._zoneSubscription.unsubscribe();
            };
        /**
         * @private
         * @param {?} $event
         * @return {?}
         */
        NgbDropdown.prototype._isEventFromToggle = /**
         * @private
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                return this._anchor.isEventFrom($event);
            };
        /**
         * @private
         * @param {?} $event
         * @return {?}
         */
        NgbDropdown.prototype._isEventFromMenu = /**
         * @private
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                return this._menu ? this._menu.isEventFrom($event) : false;
            };
        /**
         * @private
         * @return {?}
         */
        NgbDropdown.prototype._positionMenu = /**
         * @private
         * @return {?}
         */
            function () {
                if (this.isOpen() && this._menu) {
                    this._menu.position(this._anchor.anchorEl, this.placement);
                }
            };
        NgbDropdown.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngbDropdown]",
                        exportAs: "ngbDropdown",
                        host: {
                            "(keyup.esc)": "closeFromOutsideEsc()",
                        },
                    },] }
        ];
        /** @nocollapse */
        NgbDropdown.ctorParameters = function () {
            return [
                { type: NgbDropdownConfig },
                { type: core.NgZone }
            ];
        };
        NgbDropdown.propDecorators = {
            _menu: [{ type: core.ContentChild, args: [NgbDropdownMenu,] }],
            _anchor: [{ type: core.ContentChild, args: [NgbDropdownAnchor,] }],
            autoClose: [{ type: core.Input }],
            _open: [{ type: core.Input, args: ["open",] }],
            placement: [{ type: core.Input }],
            openChange: [{ type: core.Output }]
        };
        return NgbDropdown;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NGB_DROPDOWN_DIRECTIVES = [
        NgbDropdown,
        NgbDropdownAnchor,
        NgbDropdownToggle,
        NgbDropdownMenu
    ];
    var NgbDropdownModule = /** @class */ (function () {
        function NgbDropdownModule() {
        }
        /**
         * @return {?}
         */
        NgbDropdownModule.forRoot = /**
         * @return {?}
         */
            function () {
                return { ngModule: NgbDropdownModule, providers: [NgbDropdownConfig] };
            };
        NgbDropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            uiCommon.FarrisCommonModule
                        ],
                        declarations: NGB_DROPDOWN_DIRECTIVES,
                        exports: NGB_DROPDOWN_DIRECTIVES
                    },] }
        ];
        return NgbDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Trigger = /** @class */ (function () {
        function Trigger(open, close) {
            this.open = open;
            this.close = close;
            if (!close) {
                this.close = open;
            }
        }
        /**
         * @return {?}
         */
        Trigger.prototype.isManual = /**
         * @return {?}
         */
            function () { return this.open === 'manual' || this.close === 'manual'; };
        return Trigger;
    }());
    /** @type {?} */
    var DEFAULT_ALIASES = {
        'hover': ['mouseenter', 'mouseleave']
    };
    /**
     * @param {?} triggers
     * @param {?=} aliases
     * @return {?}
     */
    function parseTriggers(triggers, aliases) {
        if (aliases === void 0) {
            aliases = DEFAULT_ALIASES;
        }
        /** @type {?} */
        var trimmedTriggers = (triggers || '').trim();
        if (trimmedTriggers.length === 0) {
            return [];
        }
        /** @type {?} */
        var parsedTriggers = trimmedTriggers.split(/\s+/).map(( /**
         * @param {?} trigger
         * @return {?}
         */function (trigger) { return trigger.split(':'); })).map(( /**
         * @param {?} triggerPair
         * @return {?}
         */function (triggerPair) {
            /** @type {?} */
            var alias = aliases[triggerPair[0]] || triggerPair;
            return new Trigger(alias[0], alias[1]);
        }));
        /** @type {?} */
        var manualTriggers = parsedTriggers.filter(( /**
         * @param {?} triggerPair
         * @return {?}
         */function (triggerPair) { return triggerPair.isManual(); }));
        if (manualTriggers.length > 1) {
            throw 'Triggers parse error: only one manual trigger is allowed';
        }
        if (manualTriggers.length === 1 && parsedTriggers.length > 1) {
            throw 'Triggers parse error: manual trigger can\'t be mixed with other triggers';
        }
        return parsedTriggers;
    }
    /** @type {?} */
    var noopFn = ( /**
     * @return {?}
     */function () { });
    /**
     * @param {?} renderer
     * @param {?} nativeElement
     * @param {?} triggers
     * @param {?} openFn
     * @param {?} closeFn
     * @param {?} toggleFn
     * @return {?}
     */
    function listenToTriggers(renderer, nativeElement, triggers, openFn, closeFn, toggleFn) {
        /** @type {?} */
        var parsedTriggers = parseTriggers(triggers);
        /** @type {?} */
        var listeners = [];
        if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {
            return noopFn;
        }
        parsedTriggers.forEach(( /**
         * @param {?} trigger
         * @return {?}
         */function (trigger) {
            if (trigger.open === trigger.close) {
                listeners.push(renderer.listen(nativeElement, trigger.open, toggleFn));
            }
            else {
                listeners.push(renderer.listen(nativeElement, trigger.open, openFn), renderer.listen(nativeElement, trigger.close, closeFn));
            }
        }));
        return ( /**
         * @return {?}
         */function () {
            listeners.forEach(( /**
             * @param {?} unsubscribeFn
             * @return {?}
             */function (unsubscribeFn) { return unsubscribeFn(); }));
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ContentRef = /** @class */ (function () {
        function ContentRef(nodes, viewRef, componentRef) {
            this.nodes = nodes;
            this.viewRef = viewRef;
            this.componentRef = componentRef;
        }
        return ContentRef;
    }());
    /**
     * @template T
     */
    var /**
     * @template T
     */ PopupService = /** @class */ (function () {
        function PopupService(_type, _injector, _viewContainerRef, _renderer, _componentFactoryResolver) {
            this._type = _type;
            this._injector = _injector;
            this._viewContainerRef = _viewContainerRef;
            this._renderer = _renderer;
            this._componentFactoryResolver = _componentFactoryResolver;
        }
        /**
         * @param {?=} content
         * @param {?=} context
         * @return {?}
         */
        PopupService.prototype.open = /**
         * @param {?=} content
         * @param {?=} context
         * @return {?}
         */
            function (content, context) {
                if (!this._windowRef) {
                    this._contentRef = this._getContentRef(content, context);
                    this._windowRef = this._viewContainerRef.createComponent(this._componentFactoryResolver.resolveComponentFactory(this._type), 0, this._injector, this._contentRef.nodes);
                }
                return this._windowRef;
            };
        /**
         * @return {?}
         */
        PopupService.prototype.close = /**
         * @return {?}
         */
            function () {
                if (this._windowRef) {
                    this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._windowRef.hostView));
                    this._windowRef = null;
                    if (this._contentRef.viewRef) {
                        this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
                        this._contentRef = null;
                    }
                }
            };
        /**
         * @private
         * @param {?} content
         * @param {?=} context
         * @return {?}
         */
        PopupService.prototype._getContentRef = /**
         * @private
         * @param {?} content
         * @param {?=} context
         * @return {?}
         */
            function (content, context) {
                if (!content) {
                    return new ContentRef([]);
                }
                else if (content instanceof core.TemplateRef) {
                    /** @type {?} */
                    var viewRef = this._viewContainerRef.createEmbeddedView(( /** @type {?} */(content)), context);
                    return new ContentRef([viewRef.rootNodes], viewRef);
                }
                else {
                    return new ContentRef([[this._renderer.createText("" + content)]]);
                }
            };
        return PopupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Configuration service for the NgbTooltip directive.
     * You can inject this service, typically in your root component, and customize the values of its properties in
     * order to provide default values for all the tooltips used in the application.
     */
    var NgbTooltipConfig = /** @class */ (function () {
        function NgbTooltipConfig() {
            this.placement = 'top';
            this.triggers = 'hover';
            this.container = 'body';
            this.disableTooltip = false;
        }
        NgbTooltipConfig.decorators = [
            { type: core.Injectable }
        ];
        return NgbTooltipConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId = 0;
    var NgbTooltipWindow = /** @class */ (function () {
        function NgbTooltipWindow(_element, _renderer) {
            this._element = _element;
            this._renderer = _renderer;
            this.placement = 'top';
        }
        /**
         * @param {?} _placement
         * @return {?}
         */
        NgbTooltipWindow.prototype.applyPlacement = /**
         * @param {?} _placement
         * @return {?}
         */
            function (_placement) {
                // remove the current placement classes
                this._renderer.removeClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString().split('-')[0]);
                this._renderer.removeClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString());
                // set the new placement classes
                this.placement = _placement;
                // apply the new placement
                this._renderer.addClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString().split('-')[0]);
                this._renderer.addClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString());
            };
        NgbTooltipWindow.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngb-tooltip-window',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            '[class]': '"tooltip show bs-tooltip-" + placement.split("-")[0]+" bs-tooltip-" + placement',
                            'role': 'tooltip',
                            '[id]': 'id'
                        },
                        template: "<div class=\"arrow\"></div><div class=\"tooltip-inner\"><ng-content></ng-content></div>",
                        styles: ["\n    :host.bs-tooltip-top .arrow, :host.bs-tooltip-bottom .arrow {\n      left: calc(50% - 0.4rem);\n    }\n\n    :host.bs-tooltip-top-left .arrow, :host.bs-tooltip-bottom-left .arrow {\n      left: 1em;\n    }\n\n    :host.bs-tooltip-top-right .arrow, :host.bs-tooltip-bottom-right .arrow {\n      left: auto;\n      right: 0.8rem;\n    }\n\n    :host.bs-tooltip-left .arrow, :host.bs-tooltip-right .arrow {\n      top: calc(50% - 0.4rem);\n    }\n\n    :host.bs-tooltip-left-top .arrow, :host.bs-tooltip-right-top .arrow {\n      top: 0.4rem;\n    }\n\n    :host.bs-tooltip-left-bottom .arrow, :host.bs-tooltip-right-bottom .arrow {\n      top: auto;\n      bottom: 0.4rem;\n    }\n  "]
                    }] }
        ];
        /** @nocollapse */
        NgbTooltipWindow.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        NgbTooltipWindow.propDecorators = {
            placement: [{ type: core.Input }],
            id: [{ type: core.Input }]
        };
        return NgbTooltipWindow;
    }());
    /**
     * A lightweight, extensible directive for fancy tooltip creation.
     */
    var NgbTooltip = /** @class */ (function () {
        function NgbTooltip(_elementRef, _renderer, injector, componentFactoryResolver, viewContainerRef, config, ngZone) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            /**
             * A selector specifying the element the tooltip should be appended to.
             * Currently only supports "body".
             */
            this.container = 'body';
            /**
             * Emits an event when the tooltip is shown
             */
            this.shown = new core.EventEmitter();
            /**
             * Emits an event when the tooltip is hidden
             */
            this.hidden = new core.EventEmitter();
            this._ngbTooltipWindowId = "ngb-tooltip-" + nextId++;
            this.placement = config.placement;
            this.triggers = config.triggers;
            this.container = config.container || 'body';
            this.disableTooltip = config.disableTooltip;
            this._popupService = new PopupService(NgbTooltipWindow, injector, viewContainerRef, _renderer, componentFactoryResolver);
            this._zoneSubscription = ngZone.onStable.subscribe(( /**
             * @return {?}
             */function () {
                if (_this._windowRef) {
                    _this._windowRef.instance.applyPlacement(positionElements(_this._elementRef.nativeElement, _this._windowRef.location.nativeElement, _this.placement, _this.container === 'body', _this.referElement));
                }
            }));
        }
        Object.defineProperty(NgbTooltip.prototype, "ngbTooltip", {
            get: /**
             * @return {?}
             */ function () { return this._ngbTooltip; },
            /**
             * Content to be displayed as tooltip. If falsy, the tooltip won't open.
             */
            set: /**
             * Content to be displayed as tooltip. If falsy, the tooltip won't open.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._ngbTooltip = value;
                if (!value && this._windowRef) {
                    this.close();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Opens an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         * The context is an optional value to be injected into the tooltip template when it is created.
         */
        /**
         * Opens an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         * The context is an optional value to be injected into the tooltip template when it is created.
         * @param {?=} context
         * @return {?}
         */
        NgbTooltip.prototype.open = /**
         * Opens an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         * The context is an optional value to be injected into the tooltip template when it is created.
         * @param {?=} context
         * @return {?}
         */
            function (context) {
                if (!this._windowRef && this._ngbTooltip && !this.disableTooltip) {
                    this._windowRef = this._popupService.open(this._ngbTooltip, context);
                    this._windowRef.instance.id = this._ngbTooltipWindowId;
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._ngbTooltipWindowId);
                    if (this.container === 'body') {
                        window.document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement);
                    }
                    this._windowRef.instance.placement = Array.isArray(this.placement) ? this.placement[0] : this.placement;
                    // apply styling to set basic css-classes on target element, before going for positioning
                    this._windowRef.changeDetectorRef.detectChanges();
                    this._windowRef.changeDetectorRef.markForCheck();
                    // position tooltip along the element
                    this._windowRef.instance.applyPlacement(positionElements(this._elementRef.nativeElement, this._windowRef.location.nativeElement, this.placement, this.container === 'body', this.referElement));
                    this.shown.emit();
                }
            };
        /**
         * Closes an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         */
        /**
         * Closes an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         * @return {?}
         */
        NgbTooltip.prototype.close = /**
         * Closes an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         * @return {?}
         */
            function () {
                if (this._windowRef != null) {
                    this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
                    this._popupService.close();
                    this._windowRef = null;
                    this.hidden.emit();
                }
            };
        /**
         * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         */
        /**
         * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         * @return {?}
         */
        NgbTooltip.prototype.toggle = /**
         * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
         * @return {?}
         */
            function () {
                if (this._windowRef) {
                    this.close();
                }
                else {
                    this.open();
                }
            };
        /**
         * Returns whether or not the tooltip is currently being shown
         */
        /**
         * Returns whether or not the tooltip is currently being shown
         * @return {?}
         */
        NgbTooltip.prototype.isOpen = /**
         * Returns whether or not the tooltip is currently being shown
         * @return {?}
         */
            function () { return this._windowRef != null; };
        /**
         * @return {?}
         */
        NgbTooltip.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._unregisterListenersFn = listenToTriggers(this._renderer, this._elementRef.nativeElement, this.triggers, this.open.bind(this), this.close.bind(this), this.toggle.bind(this));
            };
        /**
         * @return {?}
         */
        NgbTooltip.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.close();
                // This check is needed as it might happen that ngOnDestroy is called before ngOnInit
                // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199
                if (this._unregisterListenersFn) {
                    this._unregisterListenersFn();
                }
                this._zoneSubscription.unsubscribe();
            };
        NgbTooltip.decorators = [
            { type: core.Directive, args: [{ selector: '[ngbTooltip]', exportAs: 'ngbTooltip' },] }
        ];
        /** @nocollapse */
        NgbTooltip.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.Injector },
                { type: core.ComponentFactoryResolver },
                { type: core.ViewContainerRef },
                { type: NgbTooltipConfig },
                { type: core.NgZone }
            ];
        };
        NgbTooltip.propDecorators = {
            placement: [{ type: core.Input }],
            triggers: [{ type: core.Input }],
            container: [{ type: core.Input }],
            disableTooltip: [{ type: core.Input }],
            shown: [{ type: core.Output }],
            hidden: [{ type: core.Output }],
            referElement: [{ type: core.Input }],
            ngbTooltip: [{ type: core.Input }]
        };
        return NgbTooltip;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgbTooltipModule = /** @class */ (function () {
        function NgbTooltipModule() {
        }
        /**
         * @return {?}
         */
        NgbTooltipModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: NgbTooltipModule,
                    providers: [NgbTooltipConfig]
                };
            };
        NgbTooltipModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NgbTooltip, NgbTooltipWindow],
                        exports: [NgbTooltip],
                        entryComponents: [NgbTooltipWindow]
                    },] }
        ];
        return NgbTooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FarrisTabsModule = /** @class */ (function () {
        function FarrisTabsModule() {
        }
        /**
         * @param {?=} config
         * @return {?}
         */
        FarrisTabsModule.forRoot = /**
         * @param {?=} config
         * @return {?}
         */
            function (config) {
                return {
                    ngModule: FarrisTabsModule,
                    providers: [{ provide: TabConfig, useValue: config }]
                };
            };
        FarrisTabsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            uiLocale.LocaleModule,
                            forms.FormsModule,
                            NgbDropdownModule.forRoot(),
                            NgbTooltipModule.forRoot(),
                            uiDropdown.FDropdownDirectiveTypeModule
                        ],
                        declarations: [FarrisTabsComponent, FarrisTabComponent,
                            TabTranscludeDirective, TabHeadDirective, FarrisTabsExtendDirective, TabHostDirective],
                        exports: [
                            FarrisTabsComponent,
                            FarrisTabComponent,
                            TabTranscludeDirective,
                            TabHeadDirective,
                            TabHostDirective,
                            FarrisTabsExtendDirective,
                            NgbDropdownModule,
                            NgbTooltipModule
                        ],
                        providers: [TabService]
                    },] }
        ];
        return FarrisTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.TabHostDirective = TabHostDirective;
    exports.FarrisTabComponent = FarrisTabComponent;
    exports.TabTranscludeDirective = TabTranscludeDirective;
    exports.TabHeadDirective = TabHeadDirective;
    exports.NgbDropdownMenu = NgbDropdownMenu;
    exports.NgbDropdownAnchor = NgbDropdownAnchor;
    exports.NgbDropdownToggle = NgbDropdownToggle;
    exports.NgbDropdown = NgbDropdown;
    exports.NgbDropdownConfig = NgbDropdownConfig;
    exports.NgbDropdownModule = NgbDropdownModule;
    exports.NgbTooltipConfig = NgbTooltipConfig;
    exports.NgbTooltip = NgbTooltip;
    exports.NgbTooltipModule = NgbTooltipModule;
    exports.NgbTooltipWindow = NgbTooltipWindow;
    exports.FarrisTabsModule = FarrisTabsModule;
    exports.FarrisTabsComponent = FarrisTabsComponent;
    exports.TabConfig = TabConfig;
    exports.TabService = TabService;
    exports.FarrisTabsExtendDirective = FarrisTabsExtendDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=farris-ui-tabs.umd.js.map