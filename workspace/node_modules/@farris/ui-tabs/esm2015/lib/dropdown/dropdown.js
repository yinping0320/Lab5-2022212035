/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { forwardRef, Inject, Directive, Input, Output, EventEmitter, ElementRef, ContentChild, NgZone, Renderer2, } from "@angular/core";
import { NgbDropdownConfig } from "./dropdown-config";
import { positionElements, } from "../util/positioning";
import { OverLayHiddenService } from "@farris/ui-common";
/**
 *
 */
export class NgbDropdownMenu {
    /**
     * @param {?} dropdown
     * @param {?} _elementRef
     * @param {?} _renderer
     */
    constructor(dropdown, _elementRef, _renderer) {
        this.dropdown = dropdown;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.placement = "bottom";
        this.isOpen = false;
    }
    /*
         * 因为下拉面板可能存在遮挡的问题,计算宽度
         */
    /**
     * @return {?}
     */
    resetMenuElWidthOpen() {
        /** @type {?} */
        var parentNode = this._elementRef.nativeElement.parentNode.parentNode;
        /** @type {?} */
        var parentNodeW = parentNode
            ? parentNode.getBoundingClientRect().width
            : 0;
        /** @type {?} */
        var menuW = this._elementRef.nativeElement.getBoundingClientRect().width;
        return Math.min(menuW, parentNodeW);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    isEventFrom($event) {
        return this._elementRef.nativeElement.contains($event.target);
    }
    /**
     * @param {?} triggerEl
     * @param {?} placement
     * @return {?}
     */
    position(triggerEl, placement) {
        //
        if (this._elementRef.nativeElement.getBoundingClientRect().width == 0) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.applyPlacement(positionElements(triggerEl, this._elementRef.nativeElement, placement));
            }), 0);
        }
        else {
            this.applyPlacement(positionElements(triggerEl, this._elementRef.nativeElement, placement));
        }
    }
    /**
     * @param {?} _placement
     * @return {?}
     */
    applyPlacement(_placement) {
        // remove the current placement classes
        this._renderer.removeClass(this._elementRef.nativeElement.parentNode, "dropup");
        this._renderer.removeClass(this._elementRef.nativeElement.parentNode, "dropdown");
        this.placement = _placement;
        /**
         * apply the new placement
         * in case of top use up-arrow or down-arrow otherwise
         */
        if (_placement.search("^top") !== -1) {
            this._renderer.addClass(this._elementRef.nativeElement.parentNode, "dropup");
        }
        else {
            this._renderer.addClass(this._elementRef.nativeElement.parentNode, "dropdown");
        }
    }
}
NgbDropdownMenu.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdownMenu]",
                host: {
                    "[class.dropdown-menu]": "true",
                    "[class.show]": "dropdown.isOpen()",
                    "[attr.x-placement]": "placement",
                },
                exportAs: "DropdownMenu",
            },] }
];
/** @nocollapse */
NgbDropdownMenu.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef },
    { type: Renderer2 }
];
if (false) {
    /** @type {?} */
    NgbDropdownMenu.prototype.placement;
    /** @type {?} */
    NgbDropdownMenu.prototype.isOpen;
    /**
     * @type {?}
     * @private
     */
    NgbDropdownMenu.prototype._triggerEl;
    /** @type {?} */
    NgbDropdownMenu.prototype.dropdown;
    /** @type {?} */
    NgbDropdownMenu.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    NgbDropdownMenu.prototype._renderer;
}
/**
 * Marks an element to which dropdown menu will be anchored. This is a simple version
 * of the NgbDropdownToggle directive. It plays the same role as NgbDropdownToggle but
 * doesn't listen to click events to toggle dropdown menu thus enabling support for
 * events other than click.
 *
 * \@since 1.1.0
 */
export class NgbDropdownAnchor {
    /**
     * @param {?} dropdown
     * @param {?} _elementRef
     */
    constructor(dropdown, _elementRef) {
        this.dropdown = dropdown;
        this._elementRef = _elementRef;
        this.anchorEl = _elementRef.nativeElement;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    isEventFrom($event) {
        return this._elementRef.nativeElement.contains($event.target);
    }
}
NgbDropdownAnchor.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdownAnchor]",
                host: {
                    class: "dropdown-toggle",
                    "aria-haspopup": "true",
                    "[attr.aria-expanded]": "dropdown.isOpen()",
                },
            },] }
];
/** @nocollapse */
NgbDropdownAnchor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef }
];
if (false) {
    /** @type {?} */
    NgbDropdownAnchor.prototype.anchorEl;
    /** @type {?} */
    NgbDropdownAnchor.prototype.dropdown;
    /**
     * @type {?}
     * @private
     */
    NgbDropdownAnchor.prototype._elementRef;
}
/**
 * Allows the dropdown to be toggled via click. This directive is optional: you can use NgbDropdownAnchor as an
 * alternative.
 */
export class NgbDropdownToggle extends NgbDropdownAnchor {
    /**
     * @param {?} dropdown
     * @param {?} elementRef
     */
    constructor(dropdown, elementRef) {
        super(dropdown, elementRef);
    }
    /**
     * @param {?=} $event
     * @return {?}
     */
    toggleOpen($event) {
        if ($event) {
            $event.stopPropagation();
        }
        this.dropdown.toggle();
    }
}
NgbDropdownToggle.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdownToggle]",
                host: {
                    class: "dropdown-toggle",
                    "aria-haspopup": "true",
                    "[attr.aria-expanded]": "dropdown.isOpen()",
                    "(click)": "toggleOpen($event)",
                },
                providers: [
                    {
                        provide: NgbDropdownAnchor,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NgbDropdownToggle)),
                    },
                ],
            },] }
];
/** @nocollapse */
NgbDropdownToggle.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef }
];
/**
 * Transforms a node into a dropdown.
 */
export class NgbDropdown {
    /**
     * @param {?} config
     * @param {?} ngZone
     */
    constructor(config, ngZone) {
        /**
         *  Defines whether or not the dropdown-menu is open initially.
         */
        this._open = false;
        /**
         * Placement of a popover accepts:
         *    "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
         *    "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
         * and array of above values.
         */
        this.placement = ["auto", "bottom"];
        /**
         *  An event fired when the dropdown is opened or closed.
         *  Event's payload equals whether dropdown is open.
         */
        this.openChange = new EventEmitter();
        this.overLayService = null;
        this.placement = config.placement;
        this.autoClose = config.autoClose;
        // 此处原意是解决menu还没有被显示时，会再次调用计算位置。但是在框架会出现位置只计算一次的情况
        this._zoneSubscription = ngZone.onStable.subscribe((/**
         * @return {?}
         */
        () => {
            this._positionMenu();
        }));
        this.overLayService = new OverLayHiddenService();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._menu) {
            this._menu.applyPlacement(Array.isArray(this.placement)
                ? this.placement[0]
                : ((/** @type {?} */ (this.placement))));
        }
    }
    /**
     * Checks if the dropdown menu is open or not.
     * @return {?}
     */
    isOpen() {
        return this._open;
    }
    /**
     * Opens the dropdown menu of a given navbar or tabbed navigation.
     * @return {?}
     */
    open() {
        if (!this._open) {
            this._open = true;
            this._positionMenu();
            this.openChange.emit(true);
            this._menu._elementRef.nativeElement.classList.add('show');
            // 注册鼠标滚轮，点击事件，用于隐藏Panel
            this.overLayService.registerMouseEvent(this._menu._elementRef.nativeElement, (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                /** @type {?} */
                const tar = (/** @type {?} */ (e.target));
                /** @type {?} */
                var classList = Array.from(tar.classList || []);
                if (this._menu._elementRef.nativeElement.contains(e.target)) {
                    return;
                }
                if (classList.includes('morebtn') ||
                    classList.includes("dropdown-toggle") ||
                    tar.closest(".dropdown-item") ||
                    classList.includes("dropdown-item")) {
                    return;
                }
                this.close();
            }));
        }
    }
    /**
     * Closes the dropdown menu of a given navbar or tabbed navigation.
     * @return {?}
     */
    close() {
        if (this._open) {
            this._open = false;
            this.openChange.emit(false);
            this._menu._elementRef.nativeElement.classList.remove('show');
            this.overLayService.destory(this._menu._elementRef.nativeElement);
        }
    }
    /**
     * Toggles the dropdown menu of a given navbar or tabbed navigation.
     * @return {?}
     */
    toggle() {
        if (this.isOpen()) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    closeFromClick($event) {
        if (this.autoClose &&
            $event.button !== 2 &&
            !this._isEventFromToggle($event)) {
            if (this.autoClose === true) {
                this.close();
            }
            else if (this.autoClose === "inside" &&
                this._isEventFromMenu($event)) {
                this.close();
            }
            else if (this.autoClose === "outside" &&
                !this._isEventFromMenu($event)) {
                this.close();
            }
        }
    }
    /**
     * @return {?}
     */
    closeFromOutsideEsc() {
        if (this.autoClose) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._zoneSubscription)
            this._zoneSubscription.unsubscribe();
    }
    /**
     * @private
     * @param {?} $event
     * @return {?}
     */
    _isEventFromToggle($event) {
        return this._anchor.isEventFrom($event);
    }
    /**
     * @private
     * @param {?} $event
     * @return {?}
     */
    _isEventFromMenu($event) {
        return this._menu ? this._menu.isEventFrom($event) : false;
    }
    /**
     * @private
     * @return {?}
     */
    _positionMenu() {
        if (this.isOpen() && this._menu) {
            this._menu.position(this._anchor.anchorEl, this.placement);
        }
    }
}
NgbDropdown.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdown]",
                exportAs: "ngbDropdown",
                host: {
                    "(keyup.esc)": "closeFromOutsideEsc()",
                },
            },] }
];
/** @nocollapse */
NgbDropdown.ctorParameters = () => [
    { type: NgbDropdownConfig },
    { type: NgZone }
];
NgbDropdown.propDecorators = {
    _menu: [{ type: ContentChild, args: [NgbDropdownMenu,] }],
    _anchor: [{ type: ContentChild, args: [NgbDropdownAnchor,] }],
    autoClose: [{ type: Input }],
    _open: [{ type: Input, args: ["open",] }],
    placement: [{ type: Input }],
    openChange: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._zoneSubscription;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._menu;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype._anchor;
    /**
     * Indicates that dropdown should be closed when selecting one of dropdown items (click) or pressing ESC.
     * When it is true (default) dropdowns are automatically closed on both outside and inside (menu) clicks.
     * When it is false dropdowns are never automatically closed.
     * When it is 'outside' dropdowns are automatically closed on outside clicks but not on menu clicks.
     * When it is 'inside' dropdowns are automatically on menu clicks but not on outside clicks.
     * @type {?}
     */
    NgbDropdown.prototype.autoClose;
    /**
     *  Defines whether or not the dropdown-menu is open initially.
     * @type {?}
     */
    NgbDropdown.prototype._open;
    /**
     * Placement of a popover accepts:
     *    "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
     *    "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
     * and array of above values.
     * @type {?}
     */
    NgbDropdown.prototype.placement;
    /**
     *  An event fired when the dropdown is opened or closed.
     *  Event's payload equals whether dropdown is open.
     * @type {?}
     */
    NgbDropdown.prototype.openChange;
    /**
     * @type {?}
     * @private
     */
    NgbDropdown.prototype.overLayService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL3VpLXRhYnMvIiwic291cmNlcyI6WyJsaWIvZHJvcGRvd24vZHJvcGRvd24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDSCxVQUFVLEVBQ1YsTUFBTSxFQUNOLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixVQUFVLEVBQ1YsWUFBWSxFQUNaLE1BQU0sRUFDTixTQUFTLEdBR1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUNILGdCQUFnQixHQUduQixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7O0FBYXpELE1BQU0sT0FBTyxlQUFlOzs7Ozs7SUFLeEIsWUFDa0QsUUFBUSxFQUMvQyxXQUF1QixFQUN0QixTQUFvQjtRQUZrQixhQUFRLEdBQVIsUUFBUSxDQUFBO1FBQy9DLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ3RCLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFQaEMsY0FBUyxHQUFjLFFBQVEsQ0FBQztRQUNoQyxXQUFNLEdBQUcsS0FBSyxDQUFDO0lBT1osQ0FBQzs7Ozs7OztJQUlKLG9CQUFvQjs7WUFDWixVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLFVBQVU7O1lBQ2pFLFdBQVcsR0FBRyxVQUFVO1lBQ3hCLENBQUMsQ0FBQyxVQUFVLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLO1lBQzFDLENBQUMsQ0FBQyxDQUFDOztZQUNILEtBQUssR0FDTCxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEtBQUs7UUFDaEUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxXQUFXLENB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QyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDL0QsQ0FBQzs7Ozs7SUFFTyxhQUFhO1FBQ2pCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzlEO0lBQ0wsQ0FBQzs7O1lBbExKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZUFBZTtnQkFDekIsUUFBUSxFQUFFLGFBQWE7Z0JBQ3ZCLElBQUksRUFBRTtvQkFDRixhQUFhLEVBQUUsdUJBQXVCO2lCQUV6QzthQUNKOzs7O1lBN0tRLGlCQUFpQjtZQUx0QixNQUFNOzs7b0JBc0xMLFlBQVksU0FBQyxlQUFlO3NCQUU1QixZQUFZLFNBQUMsaUJBQWlCO3dCQVM5QixLQUFLO29CQUtMLEtBQUssU0FBQyxNQUFNO3dCQVFaLEtBQUs7eUJBTUwsTUFBTTs7Ozs7OztJQWhDUCx3Q0FBK0I7Ozs7O0lBRS9CLDRCQUE4RDs7Ozs7SUFFOUQsOEJBQW9FOzs7Ozs7Ozs7SUFTcEUsZ0NBQW1EOzs7OztJQUtuRCw0QkFBNkI7Ozs7Ozs7O0lBUTdCLGdDQUF3RDs7Ozs7O0lBTXhELGlDQUEwQzs7Ozs7SUFDMUMscUNBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIGZvcndhcmRSZWYsXHJcbiAgICBJbmplY3QsXHJcbiAgICBEaXJlY3RpdmUsXHJcbiAgICBJbnB1dCxcclxuICAgIE91dHB1dCxcclxuICAgIEV2ZW50RW1pdHRlcixcclxuICAgIEVsZW1lbnRSZWYsXHJcbiAgICBDb250ZW50Q2hpbGQsXHJcbiAgICBOZ1pvbmUsXHJcbiAgICBSZW5kZXJlcjIsXHJcbiAgICBPbkluaXQsXHJcbiAgICBPbkRlc3Ryb3ksXHJcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcclxuaW1wb3J0IHsgTmdiRHJvcGRvd25Db25maWcgfSBmcm9tIFwiLi9kcm9wZG93bi1jb25maWdcIjtcclxuaW1wb3J0IHtcclxuICAgIHBvc2l0aW9uRWxlbWVudHMsXHJcbiAgICBQbGFjZW1lbnRBcnJheSxcclxuICAgIFBsYWNlbWVudCxcclxufSBmcm9tIFwiLi4vdXRpbC9wb3NpdGlvbmluZ1wiO1xyXG5pbXBvcnQgeyBPdmVyTGF5SGlkZGVuU2VydmljZSB9IGZyb20gXCJAZmFycmlzL3VpLWNvbW1vblwiO1xyXG5cclxuLyoqXHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiBcIltuZ2JEcm9wZG93bk1lbnVdXCIsXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgXCJbY2xhc3MuZHJvcGRvd24tbWVudV1cIjogXCJ0cnVlXCIsXHJcbiAgICAgICAgXCJbY2xhc3Muc2hvd11cIjogXCJkcm9wZG93bi5pc09wZW4oKVwiLFxyXG4gICAgICAgIFwiW2F0dHIueC1wbGFjZW1lbnRdXCI6IFwicGxhY2VtZW50XCIsXHJcbiAgICB9LFxyXG4gICAgZXhwb3J0QXM6IFwiRHJvcGRvd25NZW51XCIsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ2JEcm9wZG93bk1lbnUge1xyXG4gICAgcGxhY2VtZW50OiBQbGFjZW1lbnQgPSBcImJvdHRvbVwiO1xyXG4gICAgaXNPcGVuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF90cmlnZ2VyRWw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE5nYkRyb3Bkb3duKSkgcHVibGljIGRyb3Bkb3duLFxyXG4gICAgICAgIHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyXHJcbiAgICApIHt9XHJcbiAgICAvKlxyXG4gICAgICog5Zug5Li65LiL5ouJ6Z2i5p2/5Y+v6IO95a2Y5Zyo6YGu5oyh55qE6Zeu6aKYLOiuoeeul+WuveW6plxyXG4gICAgICovXHJcbiAgICByZXNldE1lbnVFbFdpZHRoT3BlbigpIHtcclxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgdmFyIHBhcmVudE5vZGVXID0gcGFyZW50Tm9kZVxyXG4gICAgICAgICAgICA/IHBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgIHZhciBtZW51VyA9XHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4obWVudVcsIHBhcmVudE5vZGVXKTtcclxuICAgIH1cclxuICAgIGlzRXZlbnRGcm9tKCRldmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoJGV2ZW50LnRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcG9zaXRpb24odHJpZ2dlckVsLCBwbGFjZW1lbnQpIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPT0gMCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50cyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkVsZW1lbnRzKFxyXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFbCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFwcGx5UGxhY2VtZW50KF9wbGFjZW1lbnQ6IFBsYWNlbWVudCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCBwbGFjZW1lbnQgY2xhc3Nlc1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKFxyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgXCJkcm9wdXBcIlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3MoXHJcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICBcImRyb3Bkb3duXCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMucGxhY2VtZW50ID0gX3BsYWNlbWVudDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBhcHBseSB0aGUgbmV3IHBsYWNlbWVudFxyXG4gICAgICAgICAqIGluIGNhc2Ugb2YgdG9wIHVzZSB1cC1hcnJvdyBvciBkb3duLWFycm93IG90aGVyd2lzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChfcGxhY2VtZW50LnNlYXJjaChcIl50b3BcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICBcImRyb3B1cFwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MoXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSxcclxuICAgICAgICAgICAgICAgIFwiZHJvcGRvd25cIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1hcmtzIGFuIGVsZW1lbnQgdG8gd2hpY2ggZHJvcGRvd24gbWVudSB3aWxsIGJlIGFuY2hvcmVkLiBUaGlzIGlzIGEgc2ltcGxlIHZlcnNpb25cclxuICogb2YgdGhlIE5nYkRyb3Bkb3duVG9nZ2xlIGRpcmVjdGl2ZS4gSXQgcGxheXMgdGhlIHNhbWUgcm9sZSBhcyBOZ2JEcm9wZG93blRvZ2dsZSBidXRcclxuICogZG9lc24ndCBsaXN0ZW4gdG8gY2xpY2sgZXZlbnRzIHRvIHRvZ2dsZSBkcm9wZG93biBtZW51IHRodXMgZW5hYmxpbmcgc3VwcG9ydCBmb3JcclxuICogZXZlbnRzIG90aGVyIHRoYW4gY2xpY2suXHJcbiAqXHJcbiAqIEBzaW5jZSAxLjEuMFxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogXCJbbmdiRHJvcGRvd25BbmNob3JdXCIsXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgY2xhc3M6IFwiZHJvcGRvd24tdG9nZ2xlXCIsXHJcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwidHJ1ZVwiLFxyXG4gICAgICAgIFwiW2F0dHIuYXJpYS1leHBhbmRlZF1cIjogXCJkcm9wZG93bi5pc09wZW4oKVwiLFxyXG4gICAgfSxcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nYkRyb3Bkb3duQW5jaG9yIHtcclxuICAgIGFuY2hvckVsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBOZ2JEcm9wZG93bikpIHB1YmxpYyBkcm9wZG93bixcclxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmXHJcbiAgICApIHtcclxuICAgICAgICB0aGlzLmFuY2hvckVsID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBpc0V2ZW50RnJvbSgkZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKCRldmVudC50YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIHRoZSBkcm9wZG93biB0byBiZSB0b2dnbGVkIHZpYSBjbGljay4gVGhpcyBkaXJlY3RpdmUgaXMgb3B0aW9uYWw6IHlvdSBjYW4gdXNlIE5nYkRyb3Bkb3duQW5jaG9yIGFzIGFuXHJcbiAqIGFsdGVybmF0aXZlLlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogXCJbbmdiRHJvcGRvd25Ub2dnbGVdXCIsXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgY2xhc3M6IFwiZHJvcGRvd24tdG9nZ2xlXCIsXHJcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwidHJ1ZVwiLFxyXG4gICAgICAgIFwiW2F0dHIuYXJpYS1leHBhbmRlZF1cIjogXCJkcm9wZG93bi5pc09wZW4oKVwiLFxyXG4gICAgICAgIFwiKGNsaWNrKVwiOiBcInRvZ2dsZU9wZW4oJGV2ZW50KVwiLFxyXG4gICAgfSxcclxuICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJvdmlkZTogTmdiRHJvcGRvd25BbmNob3IsXHJcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5nYkRyb3Bkb3duVG9nZ2xlKSxcclxuICAgICAgICB9LFxyXG4gICAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nYkRyb3Bkb3duVG9nZ2xlIGV4dGVuZHMgTmdiRHJvcGRvd25BbmNob3Ige1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE5nYkRyb3Bkb3duKSkgZHJvcGRvd24sXHJcbiAgICAgICAgZWxlbWVudFJlZjogRWxlbWVudFJlZlxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIoZHJvcGRvd24sIGVsZW1lbnRSZWYpO1xyXG4gICAgfVxyXG5cclxuICAgIHRvZ2dsZU9wZW4oJGV2ZW50PzogYW55KSB7XHJcbiAgICAgICAgaWYgKCRldmVudCkge1xyXG4gICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHJvcGRvd24udG9nZ2xlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIGEgbm9kZSBpbnRvIGEgZHJvcGRvd24uXHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiBcIltuZ2JEcm9wZG93bl1cIixcclxuICAgIGV4cG9ydEFzOiBcIm5nYkRyb3Bkb3duXCIsXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgXCIoa2V5dXAuZXNjKVwiOiBcImNsb3NlRnJvbU91dHNpZGVFc2MoKVwiLFxyXG4gICAgICAgIC8vIFwiKGRvY3VtZW50OmNsaWNrKVwiOiBcImNsb3NlRnJvbUNsaWNrKCRldmVudClcIixcclxuICAgIH0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ2JEcm9wZG93biBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuICAgIHByaXZhdGUgX3pvbmVTdWJzY3JpcHRpb246IGFueTtcclxuXHJcbiAgICBAQ29udGVudENoaWxkKE5nYkRyb3Bkb3duTWVudSkgcHJpdmF0ZSBfbWVudTogTmdiRHJvcGRvd25NZW51O1xyXG5cclxuICAgIEBDb250ZW50Q2hpbGQoTmdiRHJvcGRvd25BbmNob3IpIHByaXZhdGUgX2FuY2hvcjogTmdiRHJvcGRvd25BbmNob3I7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBkcm9wZG93biBzaG91bGQgYmUgY2xvc2VkIHdoZW4gc2VsZWN0aW5nIG9uZSBvZiBkcm9wZG93biBpdGVtcyAoY2xpY2spIG9yIHByZXNzaW5nIEVTQy5cclxuICAgICAqIFdoZW4gaXQgaXMgdHJ1ZSAoZGVmYXVsdCkgZHJvcGRvd25zIGFyZSBhdXRvbWF0aWNhbGx5IGNsb3NlZCBvbiBib3RoIG91dHNpZGUgYW5kIGluc2lkZSAobWVudSkgY2xpY2tzLlxyXG4gICAgICogV2hlbiBpdCBpcyBmYWxzZSBkcm9wZG93bnMgYXJlIG5ldmVyIGF1dG9tYXRpY2FsbHkgY2xvc2VkLlxyXG4gICAgICogV2hlbiBpdCBpcyAnb3V0c2lkZScgZHJvcGRvd25zIGFyZSBhdXRvbWF0aWNhbGx5IGNsb3NlZCBvbiBvdXRzaWRlIGNsaWNrcyBidXQgbm90IG9uIG1lbnUgY2xpY2tzLlxyXG4gICAgICogV2hlbiBpdCBpcyAnaW5zaWRlJyBkcm9wZG93bnMgYXJlIGF1dG9tYXRpY2FsbHkgb24gbWVudSBjbGlja3MgYnV0IG5vdCBvbiBvdXRzaWRlIGNsaWNrcy5cclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgYXV0b0Nsb3NlOiBib29sZWFuIHwgXCJvdXRzaWRlXCIgfCBcImluc2lkZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIERlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGRyb3Bkb3duLW1lbnUgaXMgb3BlbiBpbml0aWFsbHkuXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dChcIm9wZW5cIikgX29wZW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYWNlbWVudCBvZiBhIHBvcG92ZXIgYWNjZXB0czpcclxuICAgICAqICAgIFwidG9wXCIsIFwidG9wLWxlZnRcIiwgXCJ0b3AtcmlnaHRcIiwgXCJib3R0b21cIiwgXCJib3R0b20tbGVmdFwiLCBcImJvdHRvbS1yaWdodFwiLFxyXG4gICAgICogICAgXCJsZWZ0XCIsIFwibGVmdC10b3BcIiwgXCJsZWZ0LWJvdHRvbVwiLCBcInJpZ2h0XCIsIFwicmlnaHQtdG9wXCIsIFwicmlnaHQtYm90dG9tXCJcclxuICAgICAqIGFuZCBhcnJheSBvZiBhYm92ZSB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHBsYWNlbWVudDogUGxhY2VtZW50QXJyYXkgPSBbXCJhdXRvXCIsIFwiYm90dG9tXCJdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIEFuIGV2ZW50IGZpcmVkIHdoZW4gdGhlIGRyb3Bkb3duIGlzIG9wZW5lZCBvciBjbG9zZWQuXHJcbiAgICAgKiAgRXZlbnQncyBwYXlsb2FkIGVxdWFscyB3aGV0aGVyIGRyb3Bkb3duIGlzIG9wZW4uXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBvcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgcHJpdmF0ZSBvdmVyTGF5U2VydmljZTogT3ZlckxheUhpZGRlblNlcnZpY2UgPSBudWxsO1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBOZ2JEcm9wZG93bkNvbmZpZywgbmdab25lOiBOZ1pvbmUpIHtcclxuICAgICAgICB0aGlzLnBsYWNlbWVudCA9IGNvbmZpZy5wbGFjZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBjb25maWcuYXV0b0Nsb3NlO1xyXG4gICAgICAgIC8vIOatpOWkhOWOn+aEj+aYr+ino+WGs21lbnXov5jmsqHmnInooqvmmL7npLrml7bvvIzkvJrlho3mrKHosIPnlKjorqHnrpfkvY3nva7jgILkvYbmmK/lnKjmoYbmnrbkvJrlh7rnjrDkvY3nva7lj6rorqHnrpfkuIDmrKHnmoTmg4XlhrVcclxuICAgICAgICB0aGlzLl96b25lU3Vic2NyaXB0aW9uID0gbmdab25lLm9uU3RhYmxlLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uTWVudSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm92ZXJMYXlTZXJ2aWNlID0gbmV3IE92ZXJMYXlIaWRkZW5TZXJ2aWNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lbnUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVudS5hcHBseVBsYWNlbWVudChcclxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5wbGFjZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnBsYWNlbWVudFswXVxyXG4gICAgICAgICAgICAgICAgICAgIDogKHRoaXMucGxhY2VtZW50IGFzIFBsYWNlbWVudClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRyb3Bkb3duIG1lbnUgaXMgb3BlbiBvciBub3QuXHJcbiAgICAgKi9cclxuICAgIGlzT3BlbigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIHRoZSBkcm9wZG93biBtZW51IG9mIGEgZ2l2ZW4gbmF2YmFyIG9yIHRhYmJlZCBuYXZpZ2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBvcGVuKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5fb3Blbikge1xyXG4gICAgICAgICAgICB0aGlzLl9vcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25NZW51KCk7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KHRydWUpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX21lbnUuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyDms6jlhozpvKDmoIfmu5rova7vvIzngrnlh7vkuovku7bvvIznlKjkuo7pmpDol49QYW5lbFxyXG4gICAgICAgICAgICB0aGlzLm92ZXJMYXlTZXJ2aWNlLnJlZ2lzdGVyTW91c2VFdmVudChcclxuICAgICAgICAgICAgICB0aGlzLl9tZW51Ll9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgKGU6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXIgPSBlLnRhcmdldCBhcyBhbnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IEFycmF5LmZyb20odGFyLmNsYXNzTGlzdCB8fCBbXSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWVudS5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5pbmNsdWRlcygnbW9yZWJ0bicpfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0LmluY2x1ZGVzKFwiZHJvcGRvd24tdG9nZ2xlXCIpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhci5jbG9zZXN0KFwiLmRyb3Bkb3duLWl0ZW1cIikgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0LmluY2x1ZGVzKFwiZHJvcGRvd24taXRlbVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGRyb3Bkb3duIG1lbnUgb2YgYSBnaXZlbiBuYXZiYXIgb3IgdGFiYmVkIG5hdmlnYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGNsb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9vcGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuQ2hhbmdlLmVtaXQoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbWVudS5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3cnKTtcclxuICAgICAgICAgICAgdGhpcy5vdmVyTGF5U2VydmljZS5kZXN0b3J5KHRoaXMuX21lbnUuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0aGUgZHJvcGRvd24gbWVudSBvZiBhIGdpdmVuIG5hdmJhciBvciB0YWJiZWQgbmF2aWdhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xvc2VGcm9tQ2xpY2soJGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLmF1dG9DbG9zZSAmJlxyXG4gICAgICAgICAgICAkZXZlbnQuYnV0dG9uICE9PSAyICYmXHJcbiAgICAgICAgICAgICF0aGlzLl9pc0V2ZW50RnJvbVRvZ2dsZSgkZXZlbnQpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPT09IFwiaW5zaWRlXCIgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzRXZlbnRGcm9tTWVudSgkZXZlbnQpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPT09IFwib3V0c2lkZVwiICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5faXNFdmVudEZyb21NZW51KCRldmVudClcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xvc2VGcm9tT3V0c2lkZUVzYygpIHtcclxuICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fem9uZVN1YnNjcmlwdGlvbikgdGhpcy5fem9uZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2lzRXZlbnRGcm9tVG9nZ2xlKCRldmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3IuaXNFdmVudEZyb20oJGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9pc0V2ZW50RnJvbU1lbnUoJGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lbnUgPyB0aGlzLl9tZW51LmlzRXZlbnRGcm9tKCRldmVudCkgOiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9wb3NpdGlvbk1lbnUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkgJiYgdGhpcy5fbWVudSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZW51LnBvc2l0aW9uKHRoaXMuX2FuY2hvci5hbmNob3JFbCwgdGhpcy5wbGFjZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=