import { fromEvent, of, BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, map, scan, switchMap, takeWhile, debounceTime } from 'rxjs/operators';
import ResizeObserver from 'resize-observer-polyfill';
import { OverLayHiddenService, FarrisCommonModule } from '@farris/ui-common';
import { Directive, ViewContainerRef, Injectable, Optional, forwardRef, Inject, Input, Output, EventEmitter, ElementRef, ContentChild, NgZone, Renderer2, Component, ChangeDetectionStrategy, ChangeDetectorRef, ViewEncapsulation, ViewChild, TemplateRef, Compiler, ComponentFactoryResolver, KeyValueDiffers, NgModule, Injector } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { FDropdownDirectiveTypeModule } from '@farris/ui-dropdown';
import { LocaleModule } from '@farris/ui-locale';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabHostDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
TabHostDirective.decorators = [
    { type: Directive, args: [{
                selector: '[tabHost]'
            },] }
];
/** @nocollapse */
TabHostDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabConfig {
    constructor() {
        // 是否启用下拉框
        this.showDropDown = true;
        // 是否启用提示信息
        this.showTooltips = true;
        // 点击时滚动值
        this.scrollStep = 15;
        // 是否自动重新宽度 ---- todo:此处只处理了window的resize事件
        this.autoResize = true;
        // 下拉列表最大高度 非正值表明是不高度
        this.maxDropdownH = 200;
        // 下拉列表最大宽度： 非正值表明是不限制宽度
        this.maxDropdownW = -1;
        // 标签最大宽度：非正值表明不限制宽度
        this.maxTabW = 100;
        // 提示信息条数
        this.maxTooltipLen = 5;
    }
}
class TabService {
    /**
     * @param {?} exConfig
     */
    constructor(exConfig) {
        this.config = new TabConfig();
        if (exConfig) {
            Object.assign(this.config, exConfig);
        }
    }
    /**
     * @return {?}
     */
    getConfig() {
        return this.config;
    }
}
TabService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TabService.ctorParameters = () => [
    { type: TabConfig, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbDropdown directive.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the dropdowns used in the application.
 */
class NgbDropdownConfig {
    constructor() {
        this.autoClose = true;
        this.placement = 'bottom-right';
    }
}
NgbDropdownConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// previous version:
// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js
class Positioning {
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    getAllStyles(element) { return window.getComputedStyle(element); }
    /**
     * @private
     * @param {?} element
     * @param {?} prop
     * @return {?}
     */
    getStyle(element, prop) { return this.getAllStyles(element)[prop]; }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    isStaticPositioned(element) {
        return (this.getStyle(element, 'position') || 'static') === 'static';
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    offsetParent(element) {
        /** @type {?} */
        let offsetParentEl = (/** @type {?} */ (element.offsetParent)) || document.documentElement;
        while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {
            offsetParentEl = (/** @type {?} */ (offsetParentEl.offsetParent));
        }
        return offsetParentEl || document.documentElement;
    }
    /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    position(element, round = true) {
        /** @type {?} */
        let elPosition;
        /** @type {?} */
        let parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };
        if (this.getStyle(element, 'position') === 'fixed') {
            elPosition = element.getBoundingClientRect();
        }
        else {
            /** @type {?} */
            const offsetParentEl = this.offsetParent(element);
            elPosition = this.offset(element, false);
            if (offsetParentEl !== document.documentElement) {
                parentOffset = this.offset(offsetParentEl, false);
            }
            parentOffset.top += offsetParentEl.clientTop;
            parentOffset.left += offsetParentEl.clientLeft;
        }
        elPosition.top -= parentOffset.top;
        elPosition.bottom -= parentOffset.top;
        elPosition.left -= parentOffset.left;
        elPosition.right -= parentOffset.left;
        if (round) {
            elPosition.top = Math.round(elPosition.top);
            elPosition.bottom = Math.round(elPosition.bottom);
            elPosition.left = Math.round(elPosition.left);
            elPosition.right = Math.round(elPosition.right);
        }
        return elPosition;
    }
    /**
     * @param {?} element
     * @param {?=} round
     * @return {?}
     */
    offset(element, round = true) {
        /** @type {?} */
        const elBcr = element.getBoundingClientRect();
        /** @type {?} */
        const viewportOffset = {
            top: window.pageYOffset - document.documentElement.clientTop,
            left: window.pageXOffset - document.documentElement.clientLeft
        };
        /** @type {?} */
        const elOffset = {
            height: elBcr.height || element.offsetHeight,
            width: elBcr.width || element.offsetWidth,
            top: elBcr.top + viewportOffset.top,
            bottom: elBcr.bottom + viewportOffset.top,
            left: elBcr.left + viewportOffset.left,
            right: elBcr.right + viewportOffset.left
        };
        if (round) {
            elOffset.height = Math.round(elOffset.height);
            elOffset.width = Math.round(elOffset.width);
            elOffset.top = Math.round(elOffset.top);
            elOffset.bottom = Math.round(elOffset.bottom);
            elOffset.left = Math.round(elOffset.left);
            elOffset.right = Math.round(elOffset.right);
        }
        return elOffset;
    }
    /**
     * @param {?} hostElement
     * @param {?} targetElement
     * @param {?} placement
     * @param {?=} appendToBody
     * @param {?=} referElement
     * @return {?}
     */
    positionElements(hostElement, targetElement, placement, appendToBody, referElement) {
        /** @type {?} */
        const oldhostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);
        /** @type {?} */
        let hostElPosition = this.getRectCompareReferElementAndHostElement(oldhostElPosition, referElement);
        /** @type {?} */
        const targetElStyles = this.getAllStyles(targetElement);
        /** @type {?} */
        const targetElBCR = targetElement.getBoundingClientRect();
        /** @type {?} */
        const placementPrimary = placement.split('-')[0] || 'top';
        /** @type {?} */
        const placementSecondary = placement.split('-')[1] || 'center';
        /** @type {?} */
        const targetElPosition = {
            'height': targetElBCR.height || targetElement.offsetHeight,
            'width': targetElBCR.width || targetElement.offsetWidth,
            'top': 0,
            'bottom': targetElBCR.height || targetElement.offsetHeight,
            'left': 0,
            'right': targetElBCR.width || targetElement.offsetWidth
        };
        switch (placementPrimary) {
            case 'top':
                targetElPosition.top =
                    hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));
                break;
            case 'bottom':
                targetElPosition.top = hostElPosition.top + hostElPosition.height;
                break;
            case 'left':
                targetElPosition.left =
                    hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));
                break;
            case 'right':
                targetElPosition.left = hostElPosition.left + hostElPosition.width;
                break;
        }
        switch (placementSecondary) {
            case 'top':
                targetElPosition.top = hostElPosition.top;
                break;
            case 'bottom':
                targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;
                break;
            case 'left':
                targetElPosition.left = hostElPosition.left;
                break;
            case 'right':
                targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;
                break;
            case 'center':
                if (placementPrimary === 'top' || placementPrimary === 'bottom') {
                    targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;
                }
                else {
                    targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;
                }
                break;
        }
        targetElPosition.top = Math.round(targetElPosition.top);
        targetElPosition.bottom = Math.round(targetElPosition.bottom);
        targetElPosition.left = Math.round(targetElPosition.left);
        targetElPosition.right = Math.round(targetElPosition.right);
        return targetElPosition;
    }
    /**
     * @private
     * @param {?} hostRect
     * @param {?} referElement
     * @return {?}
     */
    getRectCompareReferElementAndHostElement(hostRect, referElement) {
        /** @type {?} */
        let hostElemClientRect = {
            left: hostRect.left,
            bottom: hostRect.bottom,
            height: hostRect.height,
            right: hostRect.right,
            top: hostRect.top,
            width: hostRect.width
        };
        if (referElement) {
            /** @type {?} */
            let referRect = referElement.getBoundingClientRect();
            if (referRect.left > hostRect.left) {
                hostElemClientRect.left = referRect.left;
            }
            if (referRect.right < hostRect.right) {
                hostElemClientRect.right = referRect.right;
            }
            hostElemClientRect.width = Math.min(referRect.width, hostRect.width, (hostElemClientRect.right - hostElemClientRect.left));
        }
        return hostElemClientRect;
    }
    // get the availble placements of the target element in the viewport dependeing on the host element
    /**
     * @param {?} hostElement
     * @param {?} targetElement
     * @param {?} referElement
     * @return {?}
     */
    getAvailablePlacements(hostElement, targetElement, referElement) {
        /** @type {?} */
        const oldhostElemClientRect = hostElement.getBoundingClientRect();
        /** @type {?} */
        let hostElemClientRect = this.getRectCompareReferElementAndHostElement(oldhostElemClientRect, referElement);
        /** @type {?} */
        const availablePlacements = [];
        /** @type {?} */
        const targetElemClientRect = targetElement.getBoundingClientRect();
        /** @type {?} */
        const html = document.documentElement;
        /** @type {?} */
        const windowHeight = window.innerHeight || html.clientHeight;
        /** @type {?} */
        const windowWidth = window.innerWidth || html.clientWidth;
        /** @type {?} */
        const hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;
        /** @type {?} */
        const hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2;
        // left: check if target width can be placed between host left and viewport start and also height of target is
        // inside viewport
        if (targetElemClientRect.width < hostElemClientRect.left) {
            // check for left only
            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&
                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {
                availablePlacements.splice(availablePlacements.length, 1, 'left');
            }
            // check for left-top and left-bottom
            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);
        }
        // top: target height is less than host top
        if (targetElemClientRect.height < hostElemClientRect.top) {
            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&
                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {
                availablePlacements.splice(availablePlacements.length, 1, 'top');
            }
            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);
        }
        // right: check if target width can be placed between host right and viewport end and also height of target is
        // inside viewport
        if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {
            // check for right only
            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&
                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {
                availablePlacements.splice(availablePlacements.length, 1, 'right');
            }
            // check for right-top and right-bottom
            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);
        }
        // bottom: check if there is enough space between host bottom and viewport end for target height
        if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {
            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&
                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {
                availablePlacements.splice(availablePlacements.length, 1, 'bottom');
            }
            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);
        }
        return availablePlacements;
    }
    /**
     * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom
     * primaryplacement: left|right
     * availablePlacementArr: array in which available placemets to be set
     * @private
     * @param {?} hostElemClientRect
     * @param {?} targetElemClientRect
     * @param {?} primaryPlacement
     * @param {?} availablePlacementArr
     * @return {?}
     */
    setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {
        /** @type {?} */
        const html = document.documentElement;
        // check for left-bottom
        if (targetElemClientRect.height <= hostElemClientRect.bottom) {
            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');
        }
        if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {
            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');
        }
    }
    /**
     * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right
     * primaryplacement: top|bottom
     * availablePlacementArr: array in which available placemets to be set
     * @private
     * @param {?} hostElemClientRect
     * @param {?} targetElemClientRect
     * @param {?} primaryPlacement
     * @param {?} availablePlacementArr
     * @return {?}
     */
    setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {
        /** @type {?} */
        const html = document.documentElement;
        // check for left-bottom
        if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {
            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');
        }
        if (targetElemClientRect.width <= hostElemClientRect.right) {
            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');
        }
    }
}
/** @type {?} */
const positionService = new Positioning();
/*
 * Accept the placement array and applies the appropriate placement dependent on the viewport.
 * Returns the applied placement.
 * In case of auto placement, placements are selected in order
 *   'top', 'bottom', 'left', 'right',
 *   'top-left', 'top-right',
 *   'bottom-left', 'bottom-right',
 *   'left-top', 'left-bottom',
 *   'right-top', 'right-bottom'.
 * */
/**
 * @param {?} hostElement
 * @param {?} targetElement
 * @param {?} placement
 * @param {?=} appendToBody
 * @param {?=} referElement
 * @return {?}
 */
function positionElements(hostElement, targetElement, placement, appendToBody, referElement) {
    /** @type {?} */
    const placementVals = Array.isArray(placement) ? placement : [(/** @type {?} */ (placement))];
    // replace auto placement with other placements
    /** @type {?} */
    let hasAuto = placementVals.findIndex((/**
     * @param {?} val
     * @return {?}
     */
    val => val === 'auto'));
    if (hasAuto >= 0) {
        ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top',
            'left-bottom', 'right-top', 'right-bottom',
        ].forEach((/**
         * @param {?} obj
         * @return {?}
         */
        function (obj) {
            if (placementVals.find((/**
             * @param {?} val
             * @return {?}
             */
            val => val.search('^' + obj) !== -1)) == null) {
                placementVals.splice(hasAuto++, 1, (/** @type {?} */ (obj)));
            }
        }));
    }
    // coordinates where to position
    /** @type {?} */
    let topVal = 0;
    /** @type {?} */
    let leftVal = 0;
    /** @type {?} */
    let appliedPlacement;
    // get available placements
    /** @type {?} */
    const availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement, referElement);
    // iterate over all the passed placements
    for (const { item, index } of toItemIndexes(placementVals)) {
        // check if passed placement is present in the available placement or otherwise apply the last placement in the
        // passed placement list
        if ((availablePlacements.find((/**
         * @param {?} val
         * @return {?}
         */
        val => val === item)) != null) || (placementVals.length === index + 1)) {
            appliedPlacement = (/** @type {?} */ (item));
            /** @type {?} */
            const pos = positionService.positionElements(hostElement, targetElement, item, appendToBody, referElement);
            topVal = pos.top;
            leftVal = pos.left;
            break;
        }
    }
    targetElement.style.top = `${topVal}px`;
    targetElement.style.left = `${leftVal}px`;
    return appliedPlacement;
}
// function to get index and item of an array
/**
 * @template T
 * @param {?} a
 * @return {?}
 */
function toItemIndexes(a) {
    return a.map((/**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    (item, index) => ({ item, index })));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 *
 */
class NgbDropdownMenu {
    /**
     * @param {?} dropdown
     * @param {?} _elementRef
     * @param {?} _renderer
     */
    constructor(dropdown, _elementRef, _renderer) {
        this.dropdown = dropdown;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.placement = "bottom";
        this.isOpen = false;
    }
    /*
         * 因为下拉面板可能存在遮挡的问题,计算宽度
         */
    /**
     * @return {?}
     */
    resetMenuElWidthOpen() {
        /** @type {?} */
        var parentNode = this._elementRef.nativeElement.parentNode.parentNode;
        /** @type {?} */
        var parentNodeW = parentNode
            ? parentNode.getBoundingClientRect().width
            : 0;
        /** @type {?} */
        var menuW = this._elementRef.nativeElement.getBoundingClientRect().width;
        return Math.min(menuW, parentNodeW);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    isEventFrom($event) {
        return this._elementRef.nativeElement.contains($event.target);
    }
    /**
     * @param {?} triggerEl
     * @param {?} placement
     * @return {?}
     */
    position(triggerEl, placement) {
        //
        if (this._elementRef.nativeElement.getBoundingClientRect().width == 0) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.applyPlacement(positionElements(triggerEl, this._elementRef.nativeElement, placement));
            }), 0);
        }
        else {
            this.applyPlacement(positionElements(triggerEl, this._elementRef.nativeElement, placement));
        }
    }
    /**
     * @param {?} _placement
     * @return {?}
     */
    applyPlacement(_placement) {
        // remove the current placement classes
        this._renderer.removeClass(this._elementRef.nativeElement.parentNode, "dropup");
        this._renderer.removeClass(this._elementRef.nativeElement.parentNode, "dropdown");
        this.placement = _placement;
        /**
         * apply the new placement
         * in case of top use up-arrow or down-arrow otherwise
         */
        if (_placement.search("^top") !== -1) {
            this._renderer.addClass(this._elementRef.nativeElement.parentNode, "dropup");
        }
        else {
            this._renderer.addClass(this._elementRef.nativeElement.parentNode, "dropdown");
        }
    }
}
NgbDropdownMenu.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdownMenu]",
                host: {
                    "[class.dropdown-menu]": "true",
                    "[class.show]": "dropdown.isOpen()",
                    "[attr.x-placement]": "placement",
                },
                exportAs: "DropdownMenu",
            },] }
];
/** @nocollapse */
NgbDropdownMenu.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef },
    { type: Renderer2 }
];
/**
 * Marks an element to which dropdown menu will be anchored. This is a simple version
 * of the NgbDropdownToggle directive. It plays the same role as NgbDropdownToggle but
 * doesn't listen to click events to toggle dropdown menu thus enabling support for
 * events other than click.
 *
 * \@since 1.1.0
 */
class NgbDropdownAnchor {
    /**
     * @param {?} dropdown
     * @param {?} _elementRef
     */
    constructor(dropdown, _elementRef) {
        this.dropdown = dropdown;
        this._elementRef = _elementRef;
        this.anchorEl = _elementRef.nativeElement;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    isEventFrom($event) {
        return this._elementRef.nativeElement.contains($event.target);
    }
}
NgbDropdownAnchor.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdownAnchor]",
                host: {
                    class: "dropdown-toggle",
                    "aria-haspopup": "true",
                    "[attr.aria-expanded]": "dropdown.isOpen()",
                },
            },] }
];
/** @nocollapse */
NgbDropdownAnchor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef }
];
/**
 * Allows the dropdown to be toggled via click. This directive is optional: you can use NgbDropdownAnchor as an
 * alternative.
 */
class NgbDropdownToggle extends NgbDropdownAnchor {
    /**
     * @param {?} dropdown
     * @param {?} elementRef
     */
    constructor(dropdown, elementRef) {
        super(dropdown, elementRef);
    }
    /**
     * @param {?=} $event
     * @return {?}
     */
    toggleOpen($event) {
        if ($event) {
            $event.stopPropagation();
        }
        this.dropdown.toggle();
    }
}
NgbDropdownToggle.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdownToggle]",
                host: {
                    class: "dropdown-toggle",
                    "aria-haspopup": "true",
                    "[attr.aria-expanded]": "dropdown.isOpen()",
                    "(click)": "toggleOpen($event)",
                },
                providers: [
                    {
                        provide: NgbDropdownAnchor,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => NgbDropdownToggle)),
                    },
                ],
            },] }
];
/** @nocollapse */
NgbDropdownToggle.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => NgbDropdown)),] }] },
    { type: ElementRef }
];
/**
 * Transforms a node into a dropdown.
 */
class NgbDropdown {
    /**
     * @param {?} config
     * @param {?} ngZone
     */
    constructor(config, ngZone) {
        /**
         *  Defines whether or not the dropdown-menu is open initially.
         */
        this._open = false;
        /**
         * Placement of a popover accepts:
         *    "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
         *    "left", "left-top", "left-bottom", "right", "right-top", "right-bottom"
         * and array of above values.
         */
        this.placement = ["auto", "bottom"];
        /**
         *  An event fired when the dropdown is opened or closed.
         *  Event's payload equals whether dropdown is open.
         */
        this.openChange = new EventEmitter();
        this.overLayService = null;
        this.placement = config.placement;
        this.autoClose = config.autoClose;
        // 此处原意是解决menu还没有被显示时，会再次调用计算位置。但是在框架会出现位置只计算一次的情况
        this._zoneSubscription = ngZone.onStable.subscribe((/**
         * @return {?}
         */
        () => {
            this._positionMenu();
        }));
        this.overLayService = new OverLayHiddenService();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._menu) {
            this._menu.applyPlacement(Array.isArray(this.placement)
                ? this.placement[0]
                : ((/** @type {?} */ (this.placement))));
        }
    }
    /**
     * Checks if the dropdown menu is open or not.
     * @return {?}
     */
    isOpen() {
        return this._open;
    }
    /**
     * Opens the dropdown menu of a given navbar or tabbed navigation.
     * @return {?}
     */
    open() {
        if (!this._open) {
            this._open = true;
            this._positionMenu();
            this.openChange.emit(true);
            this._menu._elementRef.nativeElement.classList.add('show');
            // 注册鼠标滚轮，点击事件，用于隐藏Panel
            this.overLayService.registerMouseEvent(this._menu._elementRef.nativeElement, (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                /** @type {?} */
                const tar = (/** @type {?} */ (e.target));
                /** @type {?} */
                var classList = Array.from(tar.classList || []);
                if (this._menu._elementRef.nativeElement.contains(e.target)) {
                    return;
                }
                if (classList.includes('morebtn') ||
                    classList.includes("dropdown-toggle") ||
                    tar.closest(".dropdown-item") ||
                    classList.includes("dropdown-item")) {
                    return;
                }
                this.close();
            }));
        }
    }
    /**
     * Closes the dropdown menu of a given navbar or tabbed navigation.
     * @return {?}
     */
    close() {
        if (this._open) {
            this._open = false;
            this.openChange.emit(false);
            this._menu._elementRef.nativeElement.classList.remove('show');
            this.overLayService.destory(this._menu._elementRef.nativeElement);
        }
    }
    /**
     * Toggles the dropdown menu of a given navbar or tabbed navigation.
     * @return {?}
     */
    toggle() {
        if (this.isOpen()) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    closeFromClick($event) {
        if (this.autoClose &&
            $event.button !== 2 &&
            !this._isEventFromToggle($event)) {
            if (this.autoClose === true) {
                this.close();
            }
            else if (this.autoClose === "inside" &&
                this._isEventFromMenu($event)) {
                this.close();
            }
            else if (this.autoClose === "outside" &&
                !this._isEventFromMenu($event)) {
                this.close();
            }
        }
    }
    /**
     * @return {?}
     */
    closeFromOutsideEsc() {
        if (this.autoClose) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._zoneSubscription)
            this._zoneSubscription.unsubscribe();
    }
    /**
     * @private
     * @param {?} $event
     * @return {?}
     */
    _isEventFromToggle($event) {
        return this._anchor.isEventFrom($event);
    }
    /**
     * @private
     * @param {?} $event
     * @return {?}
     */
    _isEventFromMenu($event) {
        return this._menu ? this._menu.isEventFrom($event) : false;
    }
    /**
     * @private
     * @return {?}
     */
    _positionMenu() {
        if (this.isOpen() && this._menu) {
            this._menu.position(this._anchor.anchorEl, this.placement);
        }
    }
}
NgbDropdown.decorators = [
    { type: Directive, args: [{
                selector: "[ngbDropdown]",
                exportAs: "ngbDropdown",
                host: {
                    "(keyup.esc)": "closeFromOutsideEsc()",
                },
            },] }
];
/** @nocollapse */
NgbDropdown.ctorParameters = () => [
    { type: NgbDropdownConfig },
    { type: NgZone }
];
NgbDropdown.propDecorators = {
    _menu: [{ type: ContentChild, args: [NgbDropdownMenu,] }],
    _anchor: [{ type: ContentChild, args: [NgbDropdownAnchor,] }],
    autoClose: [{ type: Input }],
    _open: [{ type: Input, args: ["open",] }],
    placement: [{ type: Input }],
    openChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisTabsComponent {
    /**
     * @param {?} stService
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} cdRef
     * @param {?} ngZone
     */
    constructor(stService, elementRef, renderer, cdRef, ngZone) {
        this.stService = stService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.cdRef = cdRef;
        this.ngZone = ngZone;
        this.tabType = '';
        // 支持标签页填充
        this.fill = false;
        // 支持标签页标题自适应宽度-
        this.autoTitleWidth = false;
        // 标题长度大于等于多少字符，启用渐变样式——属性废弃
        this.titleLength = 7;
        // 搜索框是否显示
        this.searchBoxVisible = true;
        // 内容是否是flex 容器 用于内部子元素flex-----未被使用
        this.contentDirection = 'column';
        this.clickThrottleTime = 350;
        this.clickItems = new Subject();
        /**
         * 因为生成器结构变更导致此处变更
         */
        this._disableStatesDatas = new Subject();
        // 按照之前的逻辑，如果没有找到key，就说明可见
        this._visibleDatas = new Subject();
        // 左侧所有标签的宽度和,百分比
        this.titleWidth = 0;
        this.tabChange = new EventEmitter();
        this.tabRemove = new EventEmitter();
        // 内容填充状态
        this.contentFillStates = new BehaviorSubject(false);
        // 宽度状态
        this.widthStates = new BehaviorSubject(false);
        // 高度状态
        this.heightStates = new BehaviorSubject(false);
        this.positionStates = new BehaviorSubject('top');
        this.menuItemsWidth = 'auto';
        //maxDropdownH = 200; -----未被使用
        // 下拉列表最大宽度： 非正值表明是不限制宽度 -----未被使用
        this.maxDropdownW = -1;
        this._customClass = '';
        // 标签存储列表
        this._tabs = [];
        // 工具条显示相关配置
        this.toolbarConf = {
            position: '',
            contents: []
        };
        // 工具条右侧小下拉框是否显示
        this.toolbarDpHidden = true;
        // 工具条“更多”里的按钮
        this.inMoreButtonContents = [];
        // 显示下拉数据
        this.dropdownTabs = [];
        // 隐藏左右滚动箭头按钮
        this.hideButtons = true;
        // 隐藏下拉
        this.hideDropDown = true;
        // 禁用左箭头
        this.disableLeft = false;
        // 禁用右箭头
        this.disableRight = false;
        // 记录事件流
        this.subscription = [];
        // 禁用右侧提示
        this.disableRTooltip = true;
        // 禁用左侧提示
        this.disableLTooltip = true;
        // 左侧提示数据
        this.leftTooltipTabs = [];
        // 右侧提示数据
        this.rightTooltipTabs = [];
        this.maxTooltipLen = 5;
        // 标记当前Tab标签
        this.activeId = '';
        this.ro = null;
        this._ddmHandler = null;
        // 当宽度改变时，强制收起下拉菜单 
        this.dpState = [false];
        // 在toolbar不存在的时候先记录visible变化的地方
        this.visibleRecord = {};
        this.disableRecord = {};
        // 下拉菜单的参照元素
        this.referEl = null;
        this.tabVisibleChanged = new Subject();
        this.el = this.elementRef.nativeElement;
        if (this.el.parentElement) {
            this.referEl = this.el.parentElement;
        }
        this.verifyConfig();
        this.subscription.push(this.tabVisibleChanged.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this._reCalculateAll();
            this._calculateToolbarDropdownIsShow();
            this._calculateButtonsShow();
        })));
    }
    // tab页位置 上下左右
    /**
     * @param {?} value
     * @return {?}
     */
    set position(value) {
        this._position = value;
        this.positionStates.next(value);
    }
    /**
     * @return {?}
     */
    get position() {
        return this._position;
    }
    // tabs宽度和高度
    /**
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        this._width = this.resolveSize(value);
        this.widthStates.next(this._width);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set height(value) {
        this._height = this.resolveSize(value);
        this.heightStates.next(this._height);
    }
    /**
     * @return {?}
     */
    get headerHeight() {
        return this._headerHeight;
    }
    /**
     * @param {?} headerHeight
     * @return {?}
     */
    set headerHeight(headerHeight) {
        this._headerHeight = this.resolveSize(headerHeight);
    }
    // 内容是否填充  默认是不填充
    /**
     * @param {?} value
     * @return {?}
     */
    set contentFill(value) {
        this._contentFill = value;
        this.contentFillStates.next(value);
    }
    /**
     * @param {?} values
     * @return {?}
     */
    set btnStates(values) {
        if (values) {
            if (this._disableStatesDatas &&
                this._disableStatesDatas.hasOwnProperty("unsubscribe")) {
                this._disableStatesDatas["unsubscribe"]();
            }
            this._disableStatesDatas = values;
            this.disableStateBind();
        }
    }
    // 是否可见的状态
    /**
     * @param {?} values
     * @return {?}
     */
    set btnVisible(values) {
        if (values) {
            if (this._visibleDatas &&
                this._visibleDatas.hasOwnProperty("unsubscribe")) {
                this._visibleDatas["unsubscribe"]();
            }
            this._visibleDatas = values;
            this.visibleStateBind();
        }
    }
    // 所有标签数据
    /**
     * @return {?}
     */
    get tabs() {
        return this._tabs;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabs(value) {
        this._tabs = value;
    }
    /**
     * @return {?}
     */
    get customClass() {
        return this._customClass;
    }
    /**
     * @param {?} customClass
     * @return {?}
     */
    set customClass(customClass) {
        if (this.customClass) {
            this.customClass.split(' ').forEach((/**
             * @param {?} cssClass
             * @return {?}
             */
            (cssClass) => {
                this.renderer.removeClass(this.el, cssClass);
            }));
        }
        this._customClass = customClass ? customClass.trim() : null;
        if (this.customClass) {
            this.customClass.split(' ').forEach((/**
             * @param {?} cssClass
             * @return {?}
             */
            (cssClass) => {
                this.renderer.addClass(this.el, cssClass);
            }));
        }
    }
    /**
     * @return {?}
     */
    get direction() {
        switch (this.position) {
            case 'top':
                return 'column';
            case 'bottom':
                return 'column-reverse';
            case 'left':
                return 'row';
            case 'right':
                return 'row-reverse';
        }
    }
    // 无用，兼容
    /**
     * @return {?}
     */
    get tabDirection() {
        if (this.position === 'top' || this.position === 'bottom') {
            return 'row';
        }
        else if (this.position === 'left' || this.position === 'right') {
            return 'column';
        }
    }
    /**
     * @param {?} index
     * @param {?} btn
     * @return {?}
     */
    trackByButton(index, btn) { return btn.id; }
    ;
    /**
     * 验证传递参数
     * @private
     * @return {?}
     */
    verifyConfig() {
        /** @type {?} */
        const config = this.stService.getConfig();
        Object.assign(this, config);
        this.scrollStep = parseInt(this.scrollStep + '', 10);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.beforeSelect) {
            this.beforeSelect = (/**
             * @return {?}
             */
            () => of(true));
        }
        this.clickSubscription = this.clickItems.pipe(debounceTime(this.clickThrottleTime))
            .subscribe((/**
         * @param {?} btnInfo
         * @return {?}
         */
        (btnInfo) => {
            if (btnInfo.click && typeof btnInfo.click == 'function') {
                btnInfo.click();
            }
        }));
        this._tabContainerEl = this.tabContainer.nativeElement;
        this._createStream();
        this.activeId = this.selectId;
        if (this.ngZone) {
            this.ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                if (this.ro === null) {
                    this.ro = new ResizeObserver((/**
                     * @param {?} el
                     * @return {?}
                     */
                    (el) => {
                        this._reCalculateAll();
                        this._calculateToolbarDropdownIsShow();
                        this._calculateButtonsShow();
                    }));
                    this.ro.observe(this.el.parentElement);
                }
            }));
        }
    }
    /**
     * 解决按钮调整隐藏状态之后，下拉中能显示的按钮有多少
     * @private
     * @return {?}
     */
    visibleStateBind() {
        this._visibleDatas.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            // 解决切换时，按钮状态没被记录的问题
            /** @type {?} */
            const idArray = Object.keys(data);
            idArray.forEach((/**
             * @param {?} btnId
             * @return {?}
             */
            (btnId) => {
                this.visibleRecord[btnId] = data[btnId];
            }));
            if (this.toolbarConf && this.toolbarConf.contents.length > 0) {
                // 调整按钮可见状态            
                this.changeState(data, "visible");
                // 重新计算
                this._reCalculateAll();
                this._calculateToolbarDropdownIsShow();
                this._calculateButtonsShow();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    disableStateBind() {
        this._disableStatesDatas.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            // 解决切换时，按钮状态没被记录的问题
            /** @type {?} */
            const idArray = Object.keys(data);
            idArray.forEach((/**
             * @param {?} btnId
             * @return {?}
             */
            (btnId) => {
                this.disableRecord[btnId] = data[btnId];
            }));
            if (this.toolbarConf && this.toolbarConf.contents.length > 0) {
                // 调整按钮可见状态            
                this.changeState(data, "disable");
            }
        }));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['selectId']) {
            this.selectTab(changes['selectId'].currentValue);
        }
    }
    /* 标签页内容初始化 */
    /**
     * @return {?}
     */
    ngAfterContentInit() { }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // 为了兼容弄旧表单，不兼容HostBinding, 通过追加class的方式实现
        this.renderer.addClass(this.el, 'farris-tabs');
        this.renderer.addClass(this.el, 'flex-column');
        this.contentFillStates.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            if (data) {
                this.renderer.addClass(this.el, 'f-tabs-content-fill');
            }
            else {
                this.renderer.removeClass(this.el, 'f-tabs-content-fill');
            }
        }));
        this.widthStates.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            if (data) {
                this.renderer.setStyle(this.el, 'width', data);
            }
        }));
        this.heightStates.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            if (data) {
                this.renderer.setStyle(this.el, 'height', data);
            }
        }));
        this.positionStates.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.renderer.removeClass(this.el, 'flex-row');
            this.renderer.removeClass(this.el, 'flex-column');
            this.renderer.removeClass(this.el, 'flex-row-reverse');
            this.renderer.removeClass(this.el, 'flex-column-reverse');
            if (data === 'left') {
                this.renderer.addClass(this.el, 'flex-row');
            }
            if (data === 'top') {
                this.renderer.addClass(this.el, 'flex-column');
            }
            if (data === 'right') {
                this.renderer.addClass(this.el, 'flex-row-reverse');
            }
            if (data === 'bottom') {
                this.renderer.addClass(this.el, 'flex-column-reverse');
            }
        }));
        // 兼容结束
        this.getToolbarConf();
        this._reCalculateAll();
        this._setActive();
        this._changeTitleStyle();
        this._listenShowChanges();
        // this.renderer.listen(document, 'keyup', function (e) {
        //     if (self.searchInputVisible) {
        //         console.log(e);
        //     }
        // });
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            this._ddmHandler = this.renderer.listen(document, 'mousedown', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (!e.target.closest('.farris-tabs-header')) {
                    if (this.el && this.el.querySelector('.dropdown-menu')) {
                        if (this.ddm && this.ddm.dropdown) {
                            this.ddm.dropdown.close();
                        }
                    }
                }
            }));
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // 组件销毁时  取消所有事件订阅
        this.subscription.forEach((/**
         * @param {?} sub
         * @return {?}
         */
        sub => {
            sub.unsubscribe();
        }));
        this.subscription = [];
        if (this.ro) {
            if (this.el.parentElement) {
                this.ro.unobserve(this.el.parentElement);
            }
            this.ro = null;
        }
        if (this._ddmHandler) {
            this._ddmHandler();
            this._ddmHandler = null;
        }
        if (this.clickSubscription) {
            this.clickSubscription.unsubscribe();
        }
        if (this._visibleDatas &&
            this._visibleDatas.hasOwnProperty("unsubscribe")) {
            this._visibleDatas["unsubscribe"]();
            this._visibleDatas = null;
        }
    }
    /**
     * @param {?} btnInfo
     * @return {?}
     */
    clickHandler(btnInfo) {
        if (!btnInfo) {
            return;
        }
        if (btnInfo.hasOwnProperty('disable') && btnInfo['disable']) {
            // 如果禁用就不触发点击事件
            return;
        }
        this.clickItems.next(btnInfo);
    }
    // 更多tab的显示隐藏
    /**
     * @param {?} e
     * @return {?}
     */
    openChange(e) {
        this.searchInputVisible = e;
        this.searchTabText = undefined;
        this._reCalculateAll();
        // 启用了搜索，需要判断下拉面板的值
        // 因为下拉面板可能存在遮挡的问题
        if (e) {
            this.menuItemsWidth = this.ddm.resetMenuElWidthOpen() + 'px';
        }
        else {
            this.menuItemsWidth = 'auto';
        }
    }
    // 搜索tab
    /**
     * @param {?} e
     * @return {?}
     */
    searchTab(e) {
        this.stopBubble(e);
        this._reCalculateAll();
    }
    // 阻止冒泡
    /**
     * @param {?} e
     * @return {?}
     */
    stopBubble(e) {
        if (e && e.stopPropagation) {
            e.stopPropagation();
        }
        else {
            window.event.cancelBubble = true;
        }
    }
    /**
     * Ximena 23.08.30 判断是否可见,独立出来
     * Todo:
     * 1、现在btnVisible每次的变更都是全量，是否需要记录每次变更，然后合并计算？
     * 2、现在判断是否可见的方法，是直接更新界面的，每个按钮上都绑定了这个方法，会有性能问题。应该改成处理在绑定的所有数据，然后更新界面。
     * 3、是否可见和禁用有同样的问题
     * @param {?} btnItem
     * @return {?}
     */
    getToolbarStateVisible(btnItem) {
        /** @type {?} */
        let stateProp = "visible";
        if (btnItem.hasOwnProperty(stateProp)) {
            return btnItem[stateProp];
        }
        // 不存在属性
        return true;
    }
    /**
     * @param {?} btnItem
     * @return {?}
     */
    getToolbarStateDisable(btnItem) {
        /** @type {?} */
        let stateProp = "disable";
        if (btnItem.hasOwnProperty(stateProp)) {
            return btnItem[stateProp];
        }
        // 不存在属性
        return false;
    }
    /**
     * 只处理是否禁用
     * @param {?} id
     * @param {?=} state
     * @return {?}
     */
    getToolbarState(id, state = this.btnStates) {
        if (state) {
            return state.pipe(map((/**
             * @param {?} n
             * @return {?}
             */
            (n) => {
                if (n[id] === undefined) {
                    // console.warn(`未找ID为：${id} 相关状态设置！`);
                    return false;
                }
                return n[id];
            })));
        }
        else {
            return of(true);
        }
    }
    // 监听子组件的隐藏显示属性
    /**
     * @private
     * @return {?}
     */
    _listenShowChanges() {
        // 如果隐藏的组件是激活状态，先将其设置为常规
        this.tabs.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            item.showStates.subscribe((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                /** @type {?} */
                let activeIdToken;
                item._show = data;
                if (data === false && item.id === this.activeId) {
                    item._active = false;
                    this.activeId = '';
                    activeIdToken = false;
                }
                /** @type {?} */
                const tabs = this.tabs.filter((/**
                 * @param {?} item
                 * @return {?}
                 */
                item => item._show === true));
                /** @type {?} */
                const defaultTabId = tabs.length ? tabs[0].id : null;
                // 然后将显示状态下的第一个tab激活
                if (defaultTabId && activeIdToken === false) {
                    this.tabs.forEach((/**
                     * @param {?} item
                     * @param {?} index
                     * @return {?}
                     */
                    (item, index) => {
                        if (item.id === defaultTabId) {
                            this.activeId = item.id;
                            this.tabs[index]._active = true;
                        }
                    }));
                    this.getToolbarConf();
                }
                this.cdRef.detectChanges();
            }));
        }));
    }
    /**
     * 选中Tab
     * @param {?} tabId tab标识
     * @return {?}
     */
    selectTab(tabId) {
        /** @type {?} */
        const selectedTab = this._getTabById(tabId);
        this._selectTab(selectedTab.tab, selectedTab.index);
    }
    /**
     * @param {?} ev
     * @param {?} id
     * @param {?=} ddm
     * @return {?}
     */
    _cpSelectTabByIndex(ev, id, ddm = null) {
        ev.preventDefault();
        ev.stopPropagation();
        /** @type {?} */
        const targetEL = (/** @type {?} */ (ev.target));
        if (targetEL.className.indexOf('st-drop-close') > -1 ||
            targetEL.parentElement.className.indexOf('st-drop-close') > -1) {
            // 阻止冒泡和捕获事件 点击删除标记 则执行删除标签方法  而不是选中标签
            this.closeTab(id);
        }
        else {
            // 阻止冒泡
            this.selectTab(id);
        }
        this.getToolbarConf();
        this.cdRef.markForCheck();
        this._reCalculateAll();
        this._calculateToolbarDropdownIsShow();
        this._calculateButtonsShow();
        if (ddm) {
            ddm.dropdown.close();
        }
        return false;
    }
    /**
     * 通过tabs的索引选择 tab
     * @param {?} index tabs索引
     * @return {?}
     */
    selectTabByIndex(index) {
        if (index >= 0 && index < this.tabs.length) {
            /** @type {?} */
            const selectTab = this.tabs[index];
            this._selectTab(selectTab, index);
        }
    }
    /* 选中tab时  暴露出选中tab的id 和其之后的id */
    /**
     * @private
     * @param {?} tab
     * @param {?} index
     * @return {?}
     */
    _selectTab(tab, index) {
        if (tab && !tab.disabled && this.activeId !== tab.id) {
            if (!this.beforeSelect) {
                this.beforeSelect = (/**
                 * @return {?}
                 */
                () => of(true));
            }
            /** @type {?} */
            const tabsChangeEventParam = {
                prevId: this.activeId,
                nextId: tab.id
            };
            this.beforeSelect(tabsChangeEventParam).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (e) {
                    this.activeId = tab.id;
                    // 首先不激活所有的tab页  然后激活当前tab页
                    // let index = -1;
                    this.tabs.forEach((/**
                     * @param {?} item
                     * @param {?} i
                     * @return {?}
                     */
                    (item, i) => {
                        item._active = false;
                    }));
                    this.tabs[index]._active = true;
                    this.getToolbarConf();
                    // 滚动到可见区域内
                    this.scrollTabIntoView(index);
                    this.cdRef.detectChanges();
                    this.tabChange.emit(tabsChangeEventParam);
                }
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    _setActive() {
        if (this.tabs.length) {
            /** @type {?} */
            const tabs = this.tabs.filter((/**
             * @param {?} item
             * @return {?}
             */
            item => item._show === true));
            /** @type {?} */
            const activeTab = this._getTabById(this.activeId).tab;
            this.activeId = activeTab ? activeTab.id : this.tabs.length ? this.tabs[0].id : null;
            // 过滤掉show=false（隐藏）的tab
            if (tabs.length) {
                if (this.activeId) {
                    /** @type {?} */
                    const targetTab = tabs.find((/**
                     * @param {?} item
                     * @return {?}
                     */
                    item => item.id === this.activeId));
                    if (targetTab) {
                        this.activeId = targetTab.id;
                    }
                }
                else {
                    this.activeId = tabs[0].id;
                }
            }
            else {
                this.activeId = null;
            }
            this.tabs.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                item._active = false;
                if (item.id === this.activeId) {
                    item._active = true;
                }
            }));
        }
    }
    /**
     * @param {?} tabId
     * @param {?=} selectable
     * @return {?}
     */
    showTab(tabId, selectable = true) {
        /** @type {?} */
        const len = this.tabs.length;
        for (let i = 0; i < len; i++) {
            if (this.tabs[i].id === tabId) {
                this.tabs[i]._show = true;
                if (selectable) {
                    this.selectTab(tabId);
                }
                return;
            }
        }
    }
    /**
     * @param {?} activeId 隐藏某个tab
     * @return {?}
     */
    hideTab(activeId) {
        /** @type {?} */
        const showTabs = this.tabs.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return item._show === true;
        }));
        /** @type {?} */
        const len = showTabs.length - 1;
        if (len < 0) {
            return;
        }
        /** @type {?} */
        let index;
        for (let i = 0; i <= len; i++) {
            if (showTabs[i].id === activeId) {
                showTabs[i]._show = false;
                index = i;
                break;
            }
        }
        if (index === undefined) {
            return;
        }
        else if (index === len && len < 1) {
            this.selectTab('');
        }
        else if (index === len && len >= 1) {
            this.selectTab(showTabs[len - 1].id);
        }
        else {
            this.selectTab(showTabs[index + 1].id);
        }
    }
    /**
     * 添加标签
     * @param {?} curTabs 数组或者对象
     * @param {?} index
     * @param {?} setActiveId
     * @return {?}
     */
    addTabs(curTabs, index, setActiveId) {
        if (curTabs.length > 0) {
            this.tabs.splice(index, 0, ...curTabs);
            // 去重
            this.tabs = this._unique(this.tabs);
        }
        if (setActiveId && this.activeId !== setActiveId) {
            /** @type {?} */
            const filterTab = this._getTabById(setActiveId);
            if (filterTab.index >= 0) {
                this.selectTab(setActiveId);
                this.activeId = setActiveId;
                this.scrollTabIntoView(filterTab.index);
            }
        }
        this.cdRef.detectChanges();
        this._reCalculateAll();
        this._changeTitleStyle();
    }
    /**
     * 添加标签时  去重
     *
     * @private
     * @param {?} objArray
     * @return {?}
     */
    _unique(objArray) {
        /** @type {?} */
        const hash = {};
        objArray = objArray.reduce((/**
         * @param {?} item
         * @param {?} next
         * @return {?}
         */
        function (item, next) {
            if (hash[next.id]) {
                hash[next.id] = '';
            }
            else {
                hash[next.id] = item.push(next);
            }
            return item;
        }), []);
        return objArray;
    }
    /* 通过tab列表的序列删除tab */
    /**
     * @param {?} index
     * @return {?}
     */
    removeTabByIndex(index) {
        /** @type {?} */
        const len = this.tabs.length - 1;
        if (index < 0 || index > len) {
            return;
        }
        /** @type {?} */
        const removeTab = this.tabs[index];
        removeTab._active = false;
        if (this.activeId === removeTab.id) {
            // 只有一个而且被删除
            if (len === 0) {
                // 如果所有标签均删除 激活id为空
                this.activeId = '';
            }
            else if (index === len) {
                // 如果删除的是最后一个标签 设置其前面的处于激活状态
                this.activeId = this.tabs[len - 1].id;
                this.tabs[index - 1]._active = true;
            }
            else {
                // 如果其他情况  设置其后面的处于激活状态
                this.activeId = this.tabs[index + 1].id;
                this.tabs[index + 1]._active = true;
            }
            this.tabs.splice(index, 1);
            this.scrollTabIntoView(index);
        }
        else {
            this.tabs.splice(index, 1);
        }
        this.tabRemove.emit({
            removeIndex: index,
            removeId: removeTab.id,
            activeId: this.activeId
        });
        this.cdRef.detectChanges();
    }
    /**
     * 关闭标签  跟删除标签不同
     * @param {?} activeId
     * @return {?}
     */
    closeTab(activeId) {
        /** @type {?} */
        const len = this.tabs.length;
        for (let i = 0; i < len; i++) {
            /** @type {?} */
            const tab = this.tabs[i];
            if (tab.id === activeId) {
                this.removeTabByIndex(i);
                return;
            }
        }
    }
    /**
     * 初始化
     * @return {?}
     */
    load() {
        for (let i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].id === this.activeId) {
                this.tabs[i]._active = true;
                return;
            }
        }
    }
    /**
     * 截取tab中的title,超过6位，截断
     * @private
     * @return {?}
     */
    _truncateTitle() {
        this.tabs = this.tabs.map((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            item.title = item.title.length > 6 ? item.title.substr(0, 6) : item.title;
            return item;
        }));
    }
    /**
     * 替换tab中的title颜色
     * @private
     * @return {?}
     */
    _changeTitleStyle() {
        if (this.autoTitleWidth) {
            return;
        }
        /** @type {?} */
        const $textEls = this._tabContainerEl.querySelectorAll('.st-tab-text');
        for (var k = 0; k < $textEls.length; k++) {
            /** @type {?} */
            let parentEl = $textEls[k].parentNode;
            if ($textEls[k].scrollWidth > parentEl['offsetWidth']) {
                this.tabs[k].titleOverflow = true;
            }
            else {
                this.tabs[k].titleOverflow = false;
            }
        }
        //this.cdRef.detectChanges();
    }
    /**
     * 创建流
     * @private
     * @return {?}
     */
    _createStream() {
        [this.rightNav, this.leftNav].forEach((/**
         * @param {?} curBtn
         * @param {?} index
         * @return {?}
         */
        (curBtn, index) => {
            /** @type {?} */
            const direction = index ? -1 : 1;
            /** @type {?} */
            const mousedown$ = fromEvent(curBtn.nativeElement, 'mousedown');
            /** @type {?} */
            const mouseup$ = fromEvent(curBtn.nativeElement, 'mouseup');
            /** @type {?} */
            const newMouseDown$ = mousedown$.pipe(switchMap((/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                event.preventDefault();
                event.stopPropagation();
                /** @type {?} */
                const interval$ = of(0).pipe(
                // concat(interval(80)),
                takeUntil(mouseup$), scan((/**
                 * @param {?} sum
                 * @param {?} num
                 * @return {?}
                 */
                (sum, num) => {
                    return sum + this.scrollStep * direction;
                }), 0), takeWhile((/**
                 * @param {?} num
                 * @return {?}
                 */
                num => {
                    if (direction > 0) {
                        return !this.disableRight;
                    }
                    return !this.disableLeft;
                })), map((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => {
                    return { value: v, direction };
                })));
                return interval$;
            })));
            /** @type {?} */
            const mousepressSub = newMouseDown$.subscribe((/**
             * @param {?} change
             * @return {?}
             */
            change => {
                this._scrollTab(change.value, change.direction);
            }));
            this.subscription.push(mousepressSub);
        }));
        // if (this.autoResize) {
        //     // 订阅windows resize事件
        //     this.subscription.push(
        //         fromEvent(window, 'resize')
        //             .pipe(throttleTime(80))
        //             .subscribe(e => {
        //                 this.cdRef.detectChanges();
        //             })
        //     );
        // }
    }
    /**
     * 按照方向，滚动到指定位置
     * @private
     * @param {?} move
     * @param {?} direction 方向
     * @return {?}
     */
    _scrollTab(move, direction) {
        /** @type {?} */
        const dist_scrollleft = this._tabContainerEl.scrollLeft + move;
        /** @type {?} */
        const max_scroll_left = this._tabContainerEl.scrollWidth - this._tabContainerEl.offsetWidth;
        // 标签页左侧移动
        if (direction > 0) {
            this._tabContainerEl.scrollLeft = Math.min(dist_scrollleft, max_scroll_left);
        }
        else if (direction < 0) {
            // 标签页右侧移动
            this._tabContainerEl.scrollLeft = Math.max(dist_scrollleft, 0);
        }
        this._reCalculateSides();
        // this.cdRef.detectChanges();
    }
    /**
     * 指定当前滑动到可视区域——————————————未测试
     * index
     * @param {?} index
     * @return {?}
     */
    scrollTabIntoView(index) {
        if (!this._tabContainerEl || this.hideButtons) {
            return;
        }
        /** @type {?} */
        const tabIndex = parseInt(index + '', 10);
        /** @type {?} */
        let tabToScroll;
        // first we find the tab element.
        if (tabIndex >= 0) {
            /** @type {?} */
            const allTabs = this._tabContainerEl.querySelectorAll('.nav-item');
            if (allTabs.length > tabIndex) {
                tabToScroll = allTabs[tabIndex];
            }
        }
        else {
            // scroll selected tab into view
            /** @type {?} */
            const activeTab = this._tabContainerEl.querySelector('li.active');
            if (activeTab) {
                tabToScroll = activeTab;
            }
        }
        if (tabToScroll) {
            /** @type {?} */
            const tab_left = parseInt(tabToScroll.getBoundingClientRect().left + '', 10);
            /** @type {?} */
            const tabs_left = parseInt(this._tabContainerEl.getBoundingClientRect().left + '', 10);
            /** @type {?} */
            const rightPosition = tab_left +
                parseInt(tabToScroll.getBoundingClientRect().width + '', 10) -
                tabs_left;
            /** @type {?} */
            const leftPosition = tab_left - tabs_left - 10;
            if (leftPosition < 0) {
                this._scrollTab(leftPosition, -1);
            }
            else if (rightPosition > this._tabContainerEl.offsetWidth) {
                this._scrollTab(rightPosition - this._tabContainerEl.offsetWidth + 20, 1);
            }
        }
    }
    /**
     * 切换tab后，重新获取需要该tab下工具条按钮的配置信息以及隐藏更多按钮
     * 以及获取该tab下的头部扩展区域
     * @private
     * @return {?}
     */
    getToolbarConf() {
        /** @type {?} */
        const tabConfig = this.tabs.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return item._active === true;
        }))[0];
        if (!tabConfig || !tabConfig.hasOwnProperty('toolbar')) {
            this.toolbarConf = null;
        }
        else {
            this.toolbarConf = tabConfig.toolbar;
        }
        // 记录状态
        this.changeState(this.visibleRecord, "visible");
        this.changeState(this.disableRecord, "disable");
        // 获取该tab下的头部扩展区域
        if (!tabConfig || !tabConfig.hasOwnProperty('farrisTabsExtendDirective')) {
            this.headerExtendConf = null;
        }
        else {
            this.headerExtendConf = tabConfig.farrisTabsExtendDirective;
        }
        // 隐藏更多按钮
        this.toolbarDpHidden = true;
        this.cdRef.detectChanges();
    }
    /**
     * 计算工具栏是否显示下拉按钮
     * @private
     * @return {?}
     */
    _calculateToolbarDropdownIsShow() {
        /** @type {?} */
        let headerExtendEl;
        /** @type {?} */
        let headerExtendElWidth = 0;
        if (!this.toolbarContainer || !this.toolbarConf) {
            return;
        }
        /** @type {?} */
        const toolbarContainer = this.hasInHeadCl() ? this.toolbarContainer.nativeElement : this.toolbarContainer.nativeElement.parentElement;
        /** @type {?} */
        let divEl = toolbarContainer.querySelector('.farris-tabs-inline-flex');
        if (!divEl) {
            return;
        }
        if (this.headerExtendConf) {
            headerExtendEl = toolbarContainer.querySelector('.farris-tabs-header-extend');
            this.renderer.removeStyle(headerExtendEl, 'overflow');
            headerExtendElWidth = headerExtendEl.offsetWidth;
        }
        // 按钮在内容区
        if (!this.hasInHeadCl() && this.btnPlaceHolder.nativeElement.offsetWidth > toolbarContainer.offsetWidth) {
            this.toolbarDpHidden = false;
        }
        else if (this.hasInHeadCl() && this.btnPlaceHolder.nativeElement.offsetWidth > toolbarContainer.offsetWidth - headerExtendElWidth) {
            // 按钮在头部工具栏
            this.toolbarDpHidden = false;
        }
        else {
            this.toolbarDpHidden = true;
        }
        this.cdRef.detectChanges();
    }
    /**
     * 计算显示的按钮个数及更多中显示的按钮个数
     * @private
     * @return {?}
     */
    _calculateButtonsShow() {
        /** @type {?} */
        let headerExtendEl;
        /** @type {?} */
        let headerExtendElWidth = 0;
        if (!this.toolbarContainer || !this.toolbarConf) {
            return;
        }
        /** @type {?} */
        const toolbarContainer = this.hasInHeadCl() ? this.toolbarContainer.nativeElement : this.toolbarContainer.nativeElement.parentElement;
        /** @type {?} */
        let divEl = toolbarContainer.querySelector('.farris-tabs-inline-flex');
        /** @type {?} */
        let btnPlaceHolderEl = this.btnPlaceHolder.nativeElement;
        /** @type {?} */
        let btnPlaceHolderBtns = btnPlaceHolderEl.querySelectorAll('.btn--cal');
        if (!divEl || btnPlaceHolderBtns.length == 0) {
            return;
        }
        // 此处有个Bug，如果是inContent还是headerExtendConf的情况下，按钮的位置形如inHead
        if (this.headerExtendConf) {
            headerExtendEl = toolbarContainer.querySelector('.farris-tabs-header-extend');
            headerExtendElWidth = this.hasInHeadCl() ? headerExtendEl.offsetWidth : 0;
        }
        /** @type {?} */
        const moreButton = btnPlaceHolderEl.parentElement.querySelector('.morebtn');
        // 计算按钮的宽度      
        /** @type {?} */
        let basicStart = parseInt(btnPlaceHolderEl.getBoundingClientRect().left);
        /** @type {?} */
        let basicWidth = toolbarContainer.offsetWidth - moreButton.offsetWidth - 12 - headerExtendElWidth;
        /** @type {?} */
        let toolbarDropdownHidden = true;
        /** @type {?} */
        let k = 0
        // 只有一个按钮
        ;
        // 只有一个按钮
        if (btnPlaceHolderBtns.length == 1) {
            if (btnPlaceHolderEl.offsetWidth > basicWidth) {
                toolbarDropdownHidden = false;
            }
            else {
                k = 1;
            }
        }
        else {
            for (k = 1; k <= btnPlaceHolderBtns.length - 1; k++) {
                // 如果内容超出,考虑到按钮之间的间距
                if (k == btnPlaceHolderBtns.length - 1) {
                    if (btnPlaceHolderEl.offsetWidth > basicWidth) {
                        toolbarDropdownHidden = false;
                        k = k - 1;
                        break;
                    }
                }
                else if (parseInt(btnPlaceHolderBtns[k].getBoundingClientRect().left) - basicStart > basicWidth) {
                    toolbarDropdownHidden = false;
                    k = k - 1;
                    break;
                }
            }
        }
        this.toolbarDpHidden = toolbarDropdownHidden;
        /** @type {?} */
        let showBtns = divEl.querySelectorAll('.btn--cal');
        for (let i = 0; i < k; i++) {
            this.renderer.setStyle(showBtns[i], 'display', '');
        }
        for (let m = k; m < showBtns.length; m++) {
            this.renderer.setStyle(showBtns[m], 'display', 'none');
        }
        if (this.toolbarConf.contents && this.toolbarConf.contents.length) {
            // 过滤显示按钮的个数
            /** @type {?} */
            let filterShowBtns = this.toolbarConf.contents.filter((/**
             * @param {?} item
             * @return {?}
             */
            (item) => this.getToolbarStateVisible(item)));
            // 从显示按钮中过滤下拉按钮
            this.inMoreButtonContents = filterShowBtns.filter((/**
             * @param {?} item
             * @param {?} index
             * @return {?}
             */
            (item, index) => {
                return index >= k;
            }));
        }
        this.cdRef && !this.cdRef['destroyed'] && this.cdRef.detectChanges();
    }
    /**
     * 重新计算是否显示按钮和下拉
     * @private
     * @return {?}
     */
    _reCalculateAll() {
        if (!this._tabContainerEl) {
            return;
        }
        /** @type {?} */
        let tabParentWidth = this.tabParent.nativeElement.offsetWidth;
        if (!this.hideButtons) {
            /** @type {?} */
            const tr = parseInt(window.getComputedStyle(this.tabParent.nativeElement).getPropertyValue("margin-right"));
            /** @type {?} */
            const tl = parseInt(window.getComputedStyle(this.tabParent.nativeElement).getPropertyValue("margin-left"));
            tabParentWidth += tr + tl;
        }
        this.hideButtons = this._tabContainerEl.scrollWidth <= tabParentWidth;
        this.hideDropDown = this.showDropDown ? this.hideButtons : true;
        if (!this.hideButtons) {
            if (!this.hideDropDown) {
                this.dropdownTabs = [].concat(this.tabs);
            }
            if (this.searchTabText) {
                this.dropdownTabs = this.dropdownTabs.filter((/**
                 * @param {?} item
                 * @return {?}
                 */
                item => {
                    return item['title'].indexOf(this.searchTabText) !== -1;
                }));
            }
            this._reCalculateSides();
        }
        this.dpState = [false];
        this.cdRef.detectChanges();
    }
    /**
     * 重新计算左右的提示文字
     * @private
     * @return {?}
     */
    _reCalulateTooltips() {
        if (!this._tabContainerEl || this.hideButtons) {
            return;
        }
        /** @type {?} */
        const t_right_tooltips = [];
        /** @type {?} */
        const t_left_tooltips = [];
        /** @type {?} */
        const allTabs = this._tabContainerEl.querySelectorAll('.nav-item');
        /** @type {?} */
        const len = allTabs.length;
        /** @type {?} */
        const hiddenTabs = this.tabs.filter((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return item._show !== true;
        }));
        /** @type {?} */
        const hiddenTabsLength = hiddenTabs.length;
        for (let i = 0; i < len; i++) {
            /** @type {?} */
            const leftPosition = allTabs[i].getBoundingClientRect().left -
                this._tabContainerEl.getBoundingClientRect().left;
            /** @type {?} */
            const rightPosition = allTabs[i].getBoundingClientRect().width + leftPosition;
            if (rightPosition > this._tabContainerEl.offsetWidth) {
                t_right_tooltips.push(this.tabs[i]);
            }
            else if (leftPosition < 0) {
                t_left_tooltips.push(this.tabs[i]);
            }
        }
        this.leftTooltipTabs = []
            .concat(t_left_tooltips)
            .slice(Math.max(0, t_left_tooltips.length - this.maxTooltipLen));
        this.rightTooltipTabs = []
            .concat(t_right_tooltips)
            .slice(0, Math.min(this.maxTooltipLen, t_right_tooltips.length));
        this.disableRTooltip = this.rightTooltipTabs.length < 1;
        this.disableLTooltip = this.leftTooltipTabs.length - hiddenTabsLength < 1;
    }
    /**
     * 重新计算左右箭头状态
     * @private
     * @return {?}
     */
    _reCalculateSides() {
        this.disableRight =
            this._tabContainerEl.scrollLeft >=
                this._tabContainerEl.scrollWidth - this._tabContainerEl.offsetWidth;
        this.disableLeft = this._tabContainerEl.scrollLeft <= 0;
        this._reCalulateTooltips();
    }
    /**
     * 通过id寻找Tab
     * @private
     * @param {?} id ID
     * @return {?}
     */
    _getTabById(id) {
        /** @type {?} */
        const indexWidthId = [];
        /** @type {?} */
        const tabsWithId = this.tabs.filter((/**
         * @param {?} tab
         * @param {?} index
         * @return {?}
         */
        (tab, index) => {
            if (tab.id === id) {
                indexWidthId.push(index);
                return true;
            }
            else {
                return false;
            }
        }));
        return {
            tab: tabsWithId.length ? tabsWithId[0] : null,
            index: indexWidthId.length ? indexWidthId[0] : -1
        };
    }
    /*宽高类型是 string或者number 解析宽高  尺寸 */
    /**
     * @param {?} size
     * @return {?}
     */
    resolveSize(size) {
        /** @type {?} */
        const regex = /px|em|rem|pt|%/;
        // 说明是字符串
        return regex.test(size)
            ? `${parseInt(size, 10)}${size.match(regex)[0]}`
            : `${size}px`;
    }
    /*
          清空tab
           */
    // removeAllTab() {
    //     this.tabs.splice(0, this.tabs.length);
    // }
    /**
     * @return {?}
     */
    hasInHeadCl() {
        if (this.toolbarConf && this.toolbarConf.hasOwnProperty('position') && this.toolbarConf.hasOwnProperty('contents') && this.toolbarConf.position === 'inHead' && this.toolbarConf.contents.length > 0) {
            return true;
        }
        if (this.headerExtendConf && !(this.toolbarConf && this.toolbarConf.position === 'inContent' && this.toolbarConf.contents.length)) {
            return true;
        }
        return false;
    }
    /**
     * 改变可用状态
     * @private
     * @param {?} values
     * @param {?} stateProp
     * @return {?}
     */
    changeState(values, stateProp) {
        if (!this.toolbarConf || !this.toolbarConf.contents) {
            return;
        }
        /** @type {?} */
        const idArray = Object.keys(values);
        this.toolbarConf.contents.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            /** @type {?} */
            const findId = idArray.find((/**
             * @param {?} id
             * @return {?}
             */
            (id) => id == item.id));
            if (findId) {
                item[stateProp] = values[findId];
            }
            if (item['children'] && item['children'].length > 0) {
                // 数据源只有一级的下拉
                /** @type {?} */
                let dpChildren = item.children;
                dpChildren.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => {
                    /** @type {?} */
                    const findId = idArray.find((/**
                     * @param {?} id
                     * @return {?}
                     */
                    (id) => id == item.id));
                    if (findId) {
                        item[stateProp] = values[findId];
                    }
                }));
            }
        }));
        this.inMoreButtonContents.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            /** @type {?} */
            const findId = idArray.find((/**
             * @param {?} id
             * @return {?}
             */
            (id) => id == item.id));
            if (findId) {
                item[stateProp] = values[findId];
            }
            if (item['children'] && item['children'].length > 0) {
                // 数据源只有一级的下拉
                /** @type {?} */
                let dpChildren = item.children;
                dpChildren.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => {
                    /** @type {?} */
                    const findId = idArray.find((/**
                     * @param {?} id
                     * @return {?}
                     */
                    (id) => id == item.id));
                    if (findId) {
                        item[stateProp] = values[findId];
                    }
                }));
            }
        }));
        this.dpState = [false];
        this.cdRef && !this.cdRef['destroyed'] && this.cdRef.detectChanges();
    }
}
FarrisTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-tabs',
                template: "<div #tabHeader class=\"farris-tabs-header\"\r\n    [class.farris-tabs-inHead]=\"hasInHeadCl()\"\r\n    [class.farris-tabs-inContent]=\"!hasInHeadCl()\"\r\n    [class.farris-tabs-nav-fill]=\"fill||tabType=='fill'\"\r\n    [class.farris-tabs-nav-pills]=\"tabType=='pills'\"\r\n    >\r\n    <div class=\"farris-tabs-title scroll-tabs\"\r\n        [ngStyle]=\"{'width': hasInHeadCl() ? (titleWidth?titleWidth + '%':null) : null}\">\r\n        <button type=\"button\" (disabled)=\"disableLeft\" class=\"btn sc-nav-btn px-1 sc-nav-lr\"\r\n            [ngClass]=\"{'d-none':hideButtons}\" #leftNav>\r\n        </button>\r\n        <div class=\"spacer f-utils-fill\" #tabParent\r\n            [ngClass]=\"{'spacer-sides':!hideButtons&& hideDropDown,'spacer-sides-dropdown':!hideButtons&&!hideDropDown}\"\r\n            style=\"width:100%;\">\r\n            <ul class=\"nav farris-nav-tabs flex-nowrap\" [class.nav-fill]=\"fill||tabType=='fill'\"\r\n                [class.flex-row]=\"position==='top'||position==='bottom'\"\r\n                [class.flex-column]=\"position==='left'||position==='right'\" [class.nav-pills]=\"tabType=='pills'\" #tabContainer>\r\n                <li class=\"nav-item\" *ngFor=\"let tab of tabs;index as tabIndex\"\r\n                    [ngClass]=\"{'d-none': tab._show !== true, 'f-state-active': tab.id === activeId, 'f-state-disabled': tab.disabled === true}\"\r\n                    [ngStyle]=\"{'width':tab.tabWidth+'px'}\">\r\n                    <a class=\"nav-link tabs-text-truncate\" #anchor [class.active]=\"tab.id === activeId\"\r\n                        [class.disabled]=\"tab.disabled\" (click)=\"_cpSelectTabByIndex($event,tab.id)\">\r\n                        <span class=\"st-tab-text\" [class.farris-title-auto]=\"autoTitleWidth\"\r\n                            [ngClass]=\"tab.titleCustomCls\" [tabTransclude]=\"tab.headingRef\"\r\n                            *ngIf=\"tab.headingRef\"></span>\r\n                        <span class=\"st-tab-text\" [ngbTooltip]=\"tab.title\" [referElement]=\"tabContainer\"\r\n                            [disableTooltip]=\"!tab.titleOverflow\" [class.farris-title-auto]=\"autoTitleWidth\"\r\n                            [class.farris-title-text-custom]=\"tab.titleOverflow\"\r\n                            *ngIf=\"!tab.headingRef\">{{tab.title}}</span>\r\n                        <span class=\"st-drop-close\" *ngIf=\"tab.removeable\">\r\n                            <i class=\"f-icon f-icon-close\"></i>\r\n                        </span>\r\n                    </a>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n        <div class=\"btn-group sc-nav-btn\" ngbDropdown (openChange)=\"openChange($event)\" >\r\n            <button type=\"button\"  (disabled)=\"disableRight\" class=\"btn sc-nav-rg\" [ngClass]=\"{'d-none':hideButtons}\"\r\n                #rightNav></button>\r\n            <button #dropDownButton class=\"btn dropdown-toggle-split \" ngbDropdownToggle\r\n                [ngClass]=\"{'d-none':hideDropDown}\">\r\n            </button>\r\n            <div class=\"dropdown-menu\" style=\"max-width: 300px;\" [class.tabs-pt28]=\"searchBoxVisible\" ngbDropdownMenu #ddm=\"DropdownMenu\">\r\n                <div (click)=\"stopBubble($event)\" class='pb-1 tabs-li-absolute' *ngIf=\"searchBoxVisible\">\r\n                    <input type=\"text\" class=\"form-control k-textbox\" [(ngModel)]=\"searchTabText\"\r\n                        (keyup)=\"searchTab($event)\" />\r\n                    <span class=\"f-icon f-icon-page-title-query tabs-icon-search\"></span>\r\n                </div>\r\n                <ul class=\"tab-dropdown-menu--items\" [ngStyle]=\"{'width':menuItemsWidth}\">\r\n                    <li class=\"dropdown-item text-truncate px-2\" *ngFor=\"let tab of dropdownTabs;index as tabIndex\"\r\n                        [ngClass]=\"{'disabled': tab.disabled, 'active': tab.id === activeId, 'd-none': tab._show !==true}\"\r\n                        (click)=\"_cpSelectTabByIndex($event,tab.id, ddm)\">\r\n                        <a class=\"dropdown-title\" style=\"\r\n                            text-overflow: ellipsis;white-space: nowrap;word-break: break-word;width: 100%;\">{{tab.title}}</a>\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div #toolbarContainer class=\"farris-tabs-toolbar\" *ngIf=\"toolbarConf || headerExtendConf\">\r\n        <div class=\"farris-tabs-inline-flex\" *ngIf=\"toolbarConf\">\r\n            <ng-template ngFor let-btn [ngForOf]=\"toolbarConf.contents\" let-i=\"index\" [ngForTrackBy]=\"trackByButton\">\r\n                <ng-container  *ngIf=\"getToolbarStateVisible(btn)\">\r\n                    <ng-container *ngIf=\"!btn.children||btn.children.length==0\">\r\n                        <button class=\"btn--cal\" [attr.id]=\"btn.id\" [ngClass]=\"btn.appearance.class\"  [disabled]=\"getToolbarStateDisable(btn)\"\r\n                        (click)=\"clickHandler(btn)\"  [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                        <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{btn.title}}\r\n                    </button>\r\n                    </ng-container>\r\n                    <ng-container *ngIf=\"btn.children&&btn.children.length>0\">\r\n                        <ng-container *ngTemplateOutlet=\"dropdownTmpl; context: { $implicit: btn }\"></ng-container>\r\n                    </ng-container>  \r\n                </ng-container>              \r\n            </ng-template>\r\n        </div>\r\n         <ng-container *ngIf=\"!toolbarDpHidden&&inMoreButtonContents.length>0\">\r\n            <div class=\"btn-group f-btn-ml sc-nav-btn\" fDropdown #ddmore=\"fDropdown\"  [forceState]=\"dpState\"  [rectifyReference]=\"referEl\" [autoRectify]=\"true\">\r\n                    <button class=\"btn btn-secondary morebtn  dropdown-toggle\" fDropdownToggle >{{'tabs.more' | locale}}</button>\r\n                    <ul class=\"dropdown-menu\" fDropdownMenu id=\"more_menu\">\r\n                        <ng-container *ngFor=\"let item of inMoreButtonContents\">                                            \r\n                            <ng-container  *ngIf=\"getToolbarStateVisible(item)\">\r\n                                <ng-container *ngIf=\"item.children&&item.children.length>0\">\r\n                                    <ng-container *ngTemplateOutlet=\"dropdownSubTmpl;context: { $implicit: item}\"></ng-container>\r\n                                </ng-container>\r\n                                <ng-container *ngIf=\"!item.children||item.children.length==0\">\r\n                                    <li class=\"dropdown-item  f-rt-btn\" id=\"{{ item.id }}\" [class.disabled]=\"getToolbarStateDisable(item)\"  (click)=\"clickHandler(item)\">\r\n                                        {{ item.title }}\r\n                                    </li>\r\n                                </ng-container>\r\n                            </ng-container>\r\n                        </ng-container>\r\n                    </ul>\r\n            </div> \r\n        </ng-container>             \r\n        <div *ngIf=\"headerExtendConf && headerExtendConf.templateRef\" class=\"farris-tabs-header-extend\"\r\n        [class.margin-right-14]=\"toolbarConf && toolbarConf.contents.length\"\r\n        [ngClass]=\"headerExtendConf && headerExtendConf.extendCls\">\r\n        <template [ngTemplateOutlet]=\"headerExtendConf.templateRef\"></template>\r\n    </div>\r\n    </div>\r\n    <!--\u8BA1\u7B97\u4F4D\u7F6E-->\r\n    <div class=\"farris-tabs-btn-placeholder\" *ngIf=\"toolbarConf\">\r\n        <div class=\"btn-group\"><button class=\"btn btn-secondary morebtn  dropdown-toggle\">{{'tabs.more' | locale}}</button></div>        \r\n        <div class=\"btn-placeholder--content\" #btnPlaceholder>\r\n            <ng-container *ngFor=\"let btn of toolbarConf.contents\">\r\n                <ng-container  *ngIf=\"getToolbarStateVisible(btn)\">                    \r\n                    <ng-container *ngIf=\"!btn.children||btn.children.length==0\">\r\n                        <button class=\"btn--cal\" [ngClass]=\"btn.appearance.class\"  [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                        <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{btn.title}}\r\n                    </button>\r\n                    </ng-container>\r\n                    <ng-container *ngIf=\"btn.children&&btn.children.length>0\">\r\n                        <div class=\"btn-group btn--cal\" [ngClass]=\"btn.appearance?.dropdownCls\" >\r\n                            <ng-container *ngIf=\"btn.split\">\r\n                                <button type=\"button\" class=\"btn\" [ngClass]=\"btn.appearance?.class\" [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                                    <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{ btn.title }}\r\n                                </button>\r\n                            <button class=\"btn dropdown-toggle dropdown-toggle-split\" [ngClass]=\"btn.appearance?.class\"></button>\r\n                            </ng-container>\r\n                            <!--\u4E0D\u542F\u7528\u4E0B\u62C9\u5206\u5F00\u6309\u94AE-->\r\n                            <ng-container *ngIf=\"!btn.split\">\r\n                                <button type=\"button\"  class=\"btn\" [ngClass]=\"btn.appearance?.class + ' dropdown-toggle'\"  [class.btn-icontext]=\"btn.icon&&btn.icon.trim()\">\r\n                                    <i class=\"f-icon\" [ngClass]=\"btn.icon&&btn.icon.trim()\" *ngIf=\"btn.icon&&btn.icon.trim()\"></i>{{ btn.title }}\r\n                                </button>\r\n                                <i></i>\r\n                            </ng-container>\r\n                        </div>\r\n                    </ng-container>  \r\n                </ng-container> \r\n            </ng-container>\r\n        </div>\r\n    </div>\r\n</div>\r\n<!--\u7B2C\u4E00\u5C42\u4E0B\u62C9-->\r\n<ng-template #dropdownTmpl let-data>\r\n    <div class=\"btn-group btn--cal\" id=\"{{ data.id }}\" [ngClass]=\"data.appearance?.dropdownCls\" fDropdown [rectifyReference]=\"referEl\"  [autoRectify]=\"true\">\r\n        <ng-container *ngIf=\"data.split\">\r\n            <button type=\"button\" class=\"btn\"  (click)=\"clickHandler(data)\" [ngClass]=\"data.appearance?.class\" [class.disabled]=\"getToolbarStateDisable(data)\" [class.btn-icontext]=\"data.icon&&data.icon.trim()\">\r\n                <i class=\"f-icon\" [ngClass]=\"data.icon&&data.icon.trim()\" *ngIf=\"data.icon&&data.icon.trim()\"></i>{{ data.title }}\r\n            </button>\r\n        <button class=\"btn dropdown-toggle dropdown-toggle-split\" [ngClass]=\"data.appearance?.class\" fDropdownToggle></button>\r\n        </ng-container>\r\n        <!--\u4E0D\u542F\u7528\u4E0B\u62C9\u5206\u5F00\u6309\u94AE-->\r\n        <ng-container *ngIf=\"!data.split\">\r\n            <button type=\"button\" fDropdownToggle class=\"btn\" [ngClass]=\"data.appearance?.class + ' dropdown-toggle'\"\r\n                [dpDisabled]=\"getToolbarStateDisable(data)\"  [class.btn-icontext]=\"data.icon&&data.icon.trim()\"   (click)=\"clickHandler(data)\">\r\n                <i class=\"f-icon\" [ngClass]=\"data.icon&&data.icon.trim()\" *ngIf=\"data.icon&&data.icon.trim()\"></i>{{ data.title }}\r\n            </button>\r\n            <i></i>\r\n        </ng-container>\r\n        <ul class=\"dropdown-menu\" fDropdownMenu id=\"{{ data.id }}_menu\">\r\n            <ng-container *ngTemplateOutlet=\"dropMenuItem; context: { $implicit: data.children }\"></ng-container>\r\n        </ul>\r\n    </div>\r\n</ng-template>\r\n<!--\u4E0B\u62C9\u5B50\u9879-->\r\n<ng-template #dropMenuItem let-data>\r\n    <ng-container *ngFor=\"let item of data\">\r\n        <ng-container *ngIf=\"getToolbarStateVisible(item)\">\r\n            <li class=\"dropdown-item\" id=\"{{ item.id }}\" [class.disabled]=\"getToolbarStateDisable(item)\"  (click)=\"clickHandler(item)\">\r\n                {{ item.title }}\r\n            </li>\r\n        </ng-container>\r\n    </ng-container>\r\n</ng-template>\r\n<!--\u7B2C\u4E8C\u5C42\u4E0B\u62C9-->\r\n<ng-template #dropdownSubTmpl let-subData>\r\n    <li class=\"dropdown-submenu\" fDropdown [isSubDP]=\"true\" [placement]=\"'left-bottom'\" [autoRectify]=\"true\" [rectifyReference]=\"referEl\" id=\"{{ subData.id }}\">\r\n        <ng-container *ngIf=\"subData.split\">\r\n            <span class=\"dropdown-item\" [class.disabled]=\"getToolbarStateDisable(subData)\"  (click)=\"clickHandler(subData)\">{{ subData.title }}</span>\r\n            <span class=\"dropdown-toggle dropdown-toggle-split\" fDropdownToggle></span>\r\n        </ng-container>\r\n        <ng-container *ngIf=\"!subData.split\">\r\n            <span class=\"dropdown-item  dropdown-toggle\" [dpDisabled]=\"getToolbarStateDisable(subData)\"  (click)=\"clickHandler(subData)\" fDropdownToggle>{{ subData.title }}</span>\r\n        </ng-container>\r\n        <ul class=\"dropdown-menu\" fDropdownMenu id=\"{{ subData.id }}_submenu\">\r\n            <ng-container *ngTemplateOutlet=\"dropMenuItem; context: { $implicit: subData.children }\"></ng-container>\r\n        </ul>\r\n    </li>\r\n</ng-template>\r\n<ng-content></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".farris-tabs .farris-tabs-header.farris-tabs-inHead .farris-tabs-title{width:41.6666667%}.farris-tabs .farris-tabs-header.farris-tabs-inHead .farris-tabs-toolbar{-webkit-box-flex:1;flex:1;-webkit-box-align:center;align-items:center}.farris-tabs .farris-tabs-header .farris-tabs-title.scroll-tabs .spacer.spacer-sides-dropdown{margin:0 60px 0 28px}.farris-tabs .farris-tabs-header .farris-tabs-title.scroll-tabs .sc-nav-btn.dropdown{right:6px}.farris-tabs .margin-right-14{margin-right:14px}.farris-tabs .farris-tabs-header-extend{height:44px}.farris-tabs .farris-tabs-header .farris-tabs-title.scroll-tabs .spacer .farris-nav-tabs .nav-item .nav-link .farris-title-text{max-width:112px}.farris-tabs .tabs-pt28{padding:0}.farris-tabs .tab-dropdown-menu--items{max-height:200px;overflow:auto}.farris-tabs .tabs-li-absolute{padding:4px;margin:0;position:relative}.farris-tabs .tabs-icon-search{position:absolute;right:4px;top:50%;font-size:14px;padding:0 4px;width:auto;height:24px;color:rgba(0,0,0,.25);margin-top:-12px;line-height:20px}.farris-tabs .st-drop-close{line-height:1}.farris-tabs .dropdown-menu .dropdown-item .dropdown-title{overflow:hidden;display:inline-block;padding:0 5px}.farris-tabs .farris-tabs-header.farris-tabs-inHead .farris-tabs-inline-flex{overflow:hidden}.farris-tabs .farris-tabs-btn-placeholder{position:absolute;top:-30px;right:0;overflow:hidden;left:0;opacity:0;z-index:-90}.farris-tabs .farris-tabs-btn-placeholder .btn-placeholder--content{display:-webkit-inline-box;display:inline-flex;left:0;position:absolute}"]
            }] }
];
/** @nocollapse */
FarrisTabsComponent.ctorParameters = () => [
    { type: TabService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: NgZone }
];
FarrisTabsComponent.propDecorators = {
    tabType: [{ type: Input }],
    fill: [{ type: Input }],
    autoTitleWidth: [{ type: Input }],
    titleLength: [{ type: Input }],
    position: [{ type: Input }],
    showDropDown: [{ type: Input }],
    showTooltips: [{ type: Input }],
    scrollStep: [{ type: Input }],
    autoResize: [{ type: Input }],
    closeable: [{ type: Input }],
    selectId: [{ type: Input, args: ['value',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    searchBoxVisible: [{ type: Input }],
    headerHeight: [{ type: Input, args: ['header-height',] }],
    contentDirection: [{ type: Input }],
    contentFill: [{ type: Input }],
    clickThrottleTime: [{ type: Input }],
    btnStates: [{ type: Input }],
    btnVisible: [{ type: Input }],
    tabs: [{ type: Input }],
    customClass: [{ type: Input }],
    titleWidth: [{ type: Input }],
    leftNav: [{ type: ViewChild, args: ['leftNav',] }],
    rightNav: [{ type: ViewChild, args: ['rightNav',] }],
    tabContainer: [{ type: ViewChild, args: ['tabContainer',] }],
    toolbarContainer: [{ type: ViewChild, args: ['toolbarContainer',] }],
    dropDownButton: [{ type: ViewChild, args: ['dropDownButton',] }],
    tabParent: [{ type: ViewChild, args: ['tabParent',] }],
    btnPlaceHolder: [{ type: ViewChild, args: ['btnPlaceholder',] }],
    beforeSelect: [{ type: Input }],
    tabChange: [{ type: Output }],
    tabRemove: [{ type: Output }],
    ddm: [{ type: ViewChild, args: ['ddm',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisTabsExtendDirective {
    /**
     * @param {?} templateRef
     */
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
FarrisTabsExtendDirective.decorators = [
    { type: Directive, args: [{
                selector: '[farrisTabsExtend]',
            },] }
];
/** @nocollapse */
FarrisTabsExtendDirective.ctorParameters = () => [
    { type: TemplateRef }
];
FarrisTabsExtendDirective.propDecorators = {
    extendCls: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisTabComponent {
    /**
     * @param {?} cp
     * @param {?} componentFactoryResolver
     * @param {?} render
     * @param {?} el
     * @param {?} cef
     * @param {?} scrollTabs
     */
    constructor(cp, componentFactoryResolver, render, el, cef, scrollTabs) {
        this.cp = cp;
        this.componentFactoryResolver = componentFactoryResolver;
        this.render = render;
        this.el = el;
        this.cef = cef;
        this.scrollTabs = scrollTabs;
        this.tabWidth = -1;
        // 追加自定义的样式
        this.titleCustomCls = '';
        // selected 是否选中
        // tslint:disable-next-line:no-inferrable-types
        this.selected = false;
        // appDiv: T;
        this.showStates = new BehaviorSubject(true);
        // 兼容旧表单
        this.activeState = new BehaviorSubject(false);
        this._show = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set show(value) {
        if (this._show != value) {
            this.showStates.next(value);
            this._show = value;
            this.scrollTabs.tabVisibleChanged.next({ tab: this, visible: value });
        }
    }
    /**
     * @return {?}
     */
    get show() {
        return this._show;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set _active(value) {
        this._activeForOld = value;
        this.activeState.next(value);
    }
    /**
     * @return {?}
     */
    get _active() {
        return this._activeForOld;
    }
    // 无用代码
    /**
     * @return {?}
     */
    get active() {
        return this._active;
    }
    /**
     * 内容是否激活
     * @return {?}
     */
    ngOnInit() {
        this.scrollTabs.tabs.push(this);
        if (!this.scrollTabs.activeId) {
            this.scrollTabs.tabs[0]._active = true;
        }
        else {
            this.scrollTabs.load();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // 为了兼容弄旧表单，不兼容HostBinding, 通过追加class的方式实现
        /** @type {?} */
        const nEl = this.el.nativeElement;
        this.activeState.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.render.addClass(nEl, 'farris-tabs-body');
            if (data) {
                this.render.addClass(nEl, 'f-tab-active');
                this.render.removeClass(nEl, 'f-tab-d-none');
            }
            else {
                this.render.addClass(nEl, 'f-tab-d-none');
                this.render.removeClass(nEl, 'f-tab-active');
            }
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
    }
    /**
     * @return {?}
     */
    loadComponent() {
    }
}
FarrisTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-tab',
                template: "<!-- \u5F02\u6B65\u83B7\u53D6\u7EC4\u4EF6 -->\r\n<ng-template [ngTemplateOutlet]=\"contentTempl\"></ng-template>\r\n<ng-container>\r\n    <ng-container *ngComponentOutlet=\"asyncComponent;ngModuleFactory:asyncModule\">\r\n    </ng-container>\r\n</ng-container>\r\n\r\n"
            }] }
];
/** @nocollapse */
FarrisTabComponent.ctorParameters = () => [
    { type: Compiler },
    { type: ComponentFactoryResolver },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: FarrisTabsComponent, decorators: [{ type: Optional }] }
];
FarrisTabComponent.propDecorators = {
    tabWidth: [{ type: Input, args: ['width',] }],
    show: [{ type: Input }],
    asyncComponent: [{ type: Input }],
    asyncModule: [{ type: Input }],
    id: [{ type: Input }],
    titleCustomCls: [{ type: Input }],
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    removeable: [{ type: Input }],
    toolbar: [{ type: Input }],
    contentTempl: [{ type: ContentChild, args: ['content',] }],
    farrisTabsExtendDirective: [{ type: ContentChild, args: [FarrisTabsExtendDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabTranscludeDirective {
    /**
     * @param {?} viewRef
     * @param {?} _differs
     */
    constructor(viewRef, _differs) {
        this._differs = _differs;
        // setTimeout(() => {
        this.viewRef = viewRef;
        // }, 5000);
        // this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    get trancludeTempl() {
        return this._trancludeTempl;
    }
    /**
     * @param {?} templateRef
     * @return {?}
     */
    set trancludeTempl(templateRef) {
        this._trancludeTempl = templateRef;
        if (templateRef) {
            this.viewRef.createEmbeddedView(templateRef);
        }
        // if (!this._differ && templateRef) {
        //     this._differ = this._differs.find(templateRef).create();
        // }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // this.setIntervalTemp = setInterval(() => {
        //     if (this._trancludeTempl && this.viewRef) {
        //         console.log('sa');
        //         // this.viewRef = this.viewRef;
        //         clearInterval(this.setIntervalTemp);
        //     }
        // }, 0);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        // const CHANGE = this._differ.diff(this._trancludeTempl);
        // if (CHANGE) {
        //     this.viewRef.createEmbeddedView(this._trancludeTempl);
        // }
    }
}
TabTranscludeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[tabTransclude]',
            },] }
];
/** @nocollapse */
TabTranscludeDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: KeyValueDiffers }
];
TabTranscludeDirective.propDecorators = {
    trancludeTempl: [{ type: Input, args: ['tabTransclude',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabHeadDirective {
    /**
     * @param {?} tabItem
     * @param {?} el
     * @param {?} template
     */
    constructor(tabItem, el, template) {
        tabItem.headingRef = template;
    }
}
TabHeadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[tabHead]'
            },] }
];
/** @nocollapse */
TabHeadDirective.ctorParameters = () => [
    { type: FarrisTabComponent },
    { type: ElementRef },
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGB_DROPDOWN_DIRECTIVES = [
    NgbDropdown,
    NgbDropdownAnchor,
    NgbDropdownToggle,
    NgbDropdownMenu
];
class NgbDropdownModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return { ngModule: NgbDropdownModule, providers: [NgbDropdownConfig] };
    }
}
NgbDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FarrisCommonModule
                ],
                declarations: NGB_DROPDOWN_DIRECTIVES,
                exports: NGB_DROPDOWN_DIRECTIVES
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Trigger {
    /**
     * @param {?} open
     * @param {?=} close
     */
    constructor(open, close) {
        this.open = open;
        this.close = close;
        if (!close) {
            this.close = open;
        }
    }
    /**
     * @return {?}
     */
    isManual() { return this.open === 'manual' || this.close === 'manual'; }
}
/** @type {?} */
const DEFAULT_ALIASES = {
    'hover': ['mouseenter', 'mouseleave']
};
/**
 * @param {?} triggers
 * @param {?=} aliases
 * @return {?}
 */
function parseTriggers(triggers, aliases = DEFAULT_ALIASES) {
    /** @type {?} */
    const trimmedTriggers = (triggers || '').trim();
    if (trimmedTriggers.length === 0) {
        return [];
    }
    /** @type {?} */
    const parsedTriggers = trimmedTriggers.split(/\s+/).map((/**
     * @param {?} trigger
     * @return {?}
     */
    trigger => trigger.split(':'))).map((/**
     * @param {?} triggerPair
     * @return {?}
     */
    (triggerPair) => {
        /** @type {?} */
        let alias = aliases[triggerPair[0]] || triggerPair;
        return new Trigger(alias[0], alias[1]);
    }));
    /** @type {?} */
    const manualTriggers = parsedTriggers.filter((/**
     * @param {?} triggerPair
     * @return {?}
     */
    triggerPair => triggerPair.isManual()));
    if (manualTriggers.length > 1) {
        throw 'Triggers parse error: only one manual trigger is allowed';
    }
    if (manualTriggers.length === 1 && parsedTriggers.length > 1) {
        throw 'Triggers parse error: manual trigger can\'t be mixed with other triggers';
    }
    return parsedTriggers;
}
/** @type {?} */
const noopFn = (/**
 * @return {?}
 */
() => { });
/**
 * @param {?} renderer
 * @param {?} nativeElement
 * @param {?} triggers
 * @param {?} openFn
 * @param {?} closeFn
 * @param {?} toggleFn
 * @return {?}
 */
function listenToTriggers(renderer, nativeElement, triggers, openFn, closeFn, toggleFn) {
    /** @type {?} */
    const parsedTriggers = parseTriggers(triggers);
    /** @type {?} */
    const listeners = [];
    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {
        return noopFn;
    }
    parsedTriggers.forEach((/**
     * @param {?} trigger
     * @return {?}
     */
    (trigger) => {
        if (trigger.open === trigger.close) {
            listeners.push(renderer.listen(nativeElement, trigger.open, toggleFn));
        }
        else {
            listeners.push(renderer.listen(nativeElement, trigger.open, openFn), renderer.listen(nativeElement, trigger.close, closeFn));
        }
    }));
    return (/**
     * @return {?}
     */
    () => { listeners.forEach((/**
     * @param {?} unsubscribeFn
     * @return {?}
     */
    unsubscribeFn => unsubscribeFn())); });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ContentRef {
    /**
     * @param {?} nodes
     * @param {?=} viewRef
     * @param {?=} componentRef
     */
    constructor(nodes, viewRef, componentRef) {
        this.nodes = nodes;
        this.viewRef = viewRef;
        this.componentRef = componentRef;
    }
}
/**
 * @template T
 */
class PopupService {
    /**
     * @param {?} _type
     * @param {?} _injector
     * @param {?} _viewContainerRef
     * @param {?} _renderer
     * @param {?} _componentFactoryResolver
     */
    constructor(_type, _injector, _viewContainerRef, _renderer, _componentFactoryResolver) {
        this._type = _type;
        this._injector = _injector;
        this._viewContainerRef = _viewContainerRef;
        this._renderer = _renderer;
        this._componentFactoryResolver = _componentFactoryResolver;
    }
    /**
     * @param {?=} content
     * @param {?=} context
     * @return {?}
     */
    open(content, context) {
        if (!this._windowRef) {
            this._contentRef = this._getContentRef(content, context);
            this._windowRef = this._viewContainerRef.createComponent(this._componentFactoryResolver.resolveComponentFactory(this._type), 0, this._injector, this._contentRef.nodes);
        }
        return this._windowRef;
    }
    /**
     * @return {?}
     */
    close() {
        if (this._windowRef) {
            this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._windowRef.hostView));
            this._windowRef = null;
            if (this._contentRef.viewRef) {
                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
                this._contentRef = null;
            }
        }
    }
    /**
     * @private
     * @param {?} content
     * @param {?=} context
     * @return {?}
     */
    _getContentRef(content, context) {
        if (!content) {
            return new ContentRef([]);
        }
        else if (content instanceof TemplateRef) {
            /** @type {?} */
            const viewRef = this._viewContainerRef.createEmbeddedView((/** @type {?} */ (content)), context);
            return new ContentRef([viewRef.rootNodes], viewRef);
        }
        else {
            return new ContentRef([[this._renderer.createText(`${content}`)]]);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Configuration service for the NgbTooltip directive.
 * You can inject this service, typically in your root component, and customize the values of its properties in
 * order to provide default values for all the tooltips used in the application.
 */
class NgbTooltipConfig {
    constructor() {
        this.placement = 'top';
        this.triggers = 'hover';
        this.container = 'body';
        this.disableTooltip = false;
    }
}
NgbTooltipConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 0;
class NgbTooltipWindow {
    /**
     * @param {?} _element
     * @param {?} _renderer
     */
    constructor(_element, _renderer) {
        this._element = _element;
        this._renderer = _renderer;
        this.placement = 'top';
    }
    /**
     * @param {?} _placement
     * @return {?}
     */
    applyPlacement(_placement) {
        // remove the current placement classes
        this._renderer.removeClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString().split('-')[0]);
        this._renderer.removeClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString());
        // set the new placement classes
        this.placement = _placement;
        // apply the new placement
        this._renderer.addClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString().split('-')[0]);
        this._renderer.addClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString());
    }
}
NgbTooltipWindow.decorators = [
    { type: Component, args: [{
                selector: 'ngb-tooltip-window',
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    '[class]': '"tooltip show bs-tooltip-" + placement.split("-")[0]+" bs-tooltip-" + placement',
                    'role': 'tooltip',
                    '[id]': 'id'
                },
                template: `<div class="arrow"></div><div class="tooltip-inner"><ng-content></ng-content></div>`,
                styles: [`
    :host.bs-tooltip-top .arrow, :host.bs-tooltip-bottom .arrow {
      left: calc(50% - 0.4rem);
    }

    :host.bs-tooltip-top-left .arrow, :host.bs-tooltip-bottom-left .arrow {
      left: 1em;
    }

    :host.bs-tooltip-top-right .arrow, :host.bs-tooltip-bottom-right .arrow {
      left: auto;
      right: 0.8rem;
    }

    :host.bs-tooltip-left .arrow, :host.bs-tooltip-right .arrow {
      top: calc(50% - 0.4rem);
    }

    :host.bs-tooltip-left-top .arrow, :host.bs-tooltip-right-top .arrow {
      top: 0.4rem;
    }

    :host.bs-tooltip-left-bottom .arrow, :host.bs-tooltip-right-bottom .arrow {
      top: auto;
      bottom: 0.4rem;
    }
  `]
            }] }
];
/** @nocollapse */
NgbTooltipWindow.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgbTooltipWindow.propDecorators = {
    placement: [{ type: Input }],
    id: [{ type: Input }]
};
/**
 * A lightweight, extensible directive for fancy tooltip creation.
 */
class NgbTooltip {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} injector
     * @param {?} componentFactoryResolver
     * @param {?} viewContainerRef
     * @param {?} config
     * @param {?} ngZone
     */
    constructor(_elementRef, _renderer, injector, componentFactoryResolver, viewContainerRef, config, ngZone) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        /**
         * A selector specifying the element the tooltip should be appended to.
         * Currently only supports "body".
         */
        this.container = 'body';
        /**
         * Emits an event when the tooltip is shown
         */
        this.shown = new EventEmitter();
        /**
         * Emits an event when the tooltip is hidden
         */
        this.hidden = new EventEmitter();
        this._ngbTooltipWindowId = `ngb-tooltip-${nextId++}`;
        this.placement = config.placement;
        this.triggers = config.triggers;
        this.container = config.container || 'body';
        this.disableTooltip = config.disableTooltip;
        this._popupService = new PopupService(NgbTooltipWindow, injector, viewContainerRef, _renderer, componentFactoryResolver);
        this._zoneSubscription = ngZone.onStable.subscribe((/**
         * @return {?}
         */
        () => {
            if (this._windowRef) {
                this._windowRef.instance.applyPlacement(positionElements(this._elementRef.nativeElement, this._windowRef.location.nativeElement, this.placement, this.container === 'body', this.referElement));
            }
        }));
    }
    /**
     * Content to be displayed as tooltip. If falsy, the tooltip won't open.
     * @param {?} value
     * @return {?}
     */
    set ngbTooltip(value) {
        this._ngbTooltip = value;
        if (!value && this._windowRef) {
            this.close();
        }
    }
    /**
     * @return {?}
     */
    get ngbTooltip() { return this._ngbTooltip; }
    /**
     * Opens an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * The context is an optional value to be injected into the tooltip template when it is created.
     * @param {?=} context
     * @return {?}
     */
    open(context) {
        if (!this._windowRef && this._ngbTooltip && !this.disableTooltip) {
            this._windowRef = this._popupService.open(this._ngbTooltip, context);
            this._windowRef.instance.id = this._ngbTooltipWindowId;
            this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._ngbTooltipWindowId);
            if (this.container === 'body') {
                window.document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement);
            }
            this._windowRef.instance.placement = Array.isArray(this.placement) ? this.placement[0] : this.placement;
            // apply styling to set basic css-classes on target element, before going for positioning
            this._windowRef.changeDetectorRef.detectChanges();
            this._windowRef.changeDetectorRef.markForCheck();
            // position tooltip along the element
            this._windowRef.instance.applyPlacement(positionElements(this._elementRef.nativeElement, this._windowRef.location.nativeElement, this.placement, this.container === 'body', this.referElement));
            this.shown.emit();
        }
    }
    /**
     * Closes an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @return {?}
     */
    close() {
        if (this._windowRef != null) {
            this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
            this._popupService.close();
            this._windowRef = null;
            this.hidden.emit();
        }
    }
    /**
     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
     * @return {?}
     */
    toggle() {
        if (this._windowRef) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Returns whether or not the tooltip is currently being shown
     * @return {?}
     */
    isOpen() { return this._windowRef != null; }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._unregisterListenersFn = listenToTriggers(this._renderer, this._elementRef.nativeElement, this.triggers, this.open.bind(this), this.close.bind(this), this.toggle.bind(this));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.close();
        // This check is needed as it might happen that ngOnDestroy is called before ngOnInit
        // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199
        if (this._unregisterListenersFn) {
            this._unregisterListenersFn();
        }
        this._zoneSubscription.unsubscribe();
    }
}
NgbTooltip.decorators = [
    { type: Directive, args: [{ selector: '[ngbTooltip]', exportAs: 'ngbTooltip' },] }
];
/** @nocollapse */
NgbTooltip.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: NgbTooltipConfig },
    { type: NgZone }
];
NgbTooltip.propDecorators = {
    placement: [{ type: Input }],
    triggers: [{ type: Input }],
    container: [{ type: Input }],
    disableTooltip: [{ type: Input }],
    shown: [{ type: Output }],
    hidden: [{ type: Output }],
    referElement: [{ type: Input }],
    ngbTooltip: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgbTooltipModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgbTooltipModule,
            providers: [NgbTooltipConfig]
        };
    }
}
NgbTooltipModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgbTooltip, NgbTooltipWindow],
                exports: [NgbTooltip],
                entryComponents: [NgbTooltipWindow]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisTabsModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: FarrisTabsModule,
            providers: [{ provide: TabConfig, useValue: config }]
        };
    }
}
FarrisTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    LocaleModule,
                    FormsModule,
                    NgbDropdownModule.forRoot(),
                    NgbTooltipModule.forRoot(),
                    FDropdownDirectiveTypeModule
                ],
                declarations: [FarrisTabsComponent, FarrisTabComponent,
                    TabTranscludeDirective, TabHeadDirective, FarrisTabsExtendDirective, TabHostDirective],
                exports: [
                    FarrisTabsComponent,
                    FarrisTabComponent,
                    TabTranscludeDirective,
                    TabHeadDirective,
                    TabHostDirective,
                    FarrisTabsExtendDirective,
                    NgbDropdownModule,
                    NgbTooltipModule
                ],
                providers: [TabService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TabHostDirective, FarrisTabComponent, TabTranscludeDirective, TabHeadDirective, NgbDropdownMenu, NgbDropdownAnchor, NgbDropdownToggle, NgbDropdown, NgbDropdownConfig, NgbDropdownModule, NgbTooltipConfig, NgbTooltip, NgbTooltipModule, NgbTooltipWindow, FarrisTabsModule, FarrisTabsComponent, TabConfig, TabService, FarrisTabsExtendDirective };

//# sourceMappingURL=farris-ui-tabs.js.map