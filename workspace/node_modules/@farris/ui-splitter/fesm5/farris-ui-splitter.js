import { fromEvent, BehaviorSubject } from 'rxjs';
import { Injectable, Component, Input, HostBinding, Renderer2, ElementRef, HostListener, Output, EventEmitter, ContentChildren, ComponentFactoryResolver, ViewContainerRef, Injector, ViewChild, NgModule, defineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AngularDraggableModule } from '@farris/ui-draggable';
import { PerfectScrollbarModule } from '@farris/ui-perfect-scrollbar';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SplitterService = /** @class */ (function () {
    function SplitterService() {
    }
    SplitterService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    SplitterService.ctorParameters = function () { return []; };
    /** @nocollapse */ SplitterService.ngInjectableDef = defineInjectable({ factory: function SplitterService_Factory() { return new SplitterService(); }, token: SplitterService, providedIn: "root" });
    return SplitterService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SplitterPaneComponent = /** @class */ (function () {
    function SplitterPaneComponent(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.klass = true;
        this.collapsible = false;
        this.sizeChange = new EventEmitter();
        //orderState = new BehaviorSubject<any>({});
        // 记录収折前宽度，方便后续恢复
        this._beforeCollapseDistance = -1;
        this._enableCollapse = false;
        // 记录真实的iframe父容器
        this._relatedContainer = null;
        // 标记iframe父容器的样式属性position的值
        this._relatedContainerPosition = "";
        // 记录iframe在拖拽时的遮罩层
        this._relatedIframeOverlay = null;
        // 标记iframe遮罩层是否已显示
        this._iframeOverlayShownFlag = false;
        // 拖拽到某个值时，自动收起的阈值。如果阈值设置小于0，则不处理自动收起
        this.resizeCollapseThreshold = 20;
        // pane在splitter的位置，left 左侧 right 右侧 top 顶部 bottom 底部
        this.pos = "right";
        // 真实的展开时的距离，
        this.defaultExpandDistance = "20%";
        this.realExpandDisatance = "";
        // 展开时的距离，不设置时为空，设置了按照设置的值来
        this._expandDistance = "";
        // 初始收起状态
        this.initCollapse = false;
        /**
         * 收起折叠状态变化
         */
        this.collapseStateChange = new EventEmitter();
        // collapse的动画样式名
        this.animateCls = "splitter-pane-collapse-animate";
        // 标记是否需要更新变量
        this.updateParamsFlag = false;
        // 标记拖拽时上次的大小
        this.resizeDistance = -1;
        // 兼容旧表单写法
        if (this.elementRef) {
            this.el = this.elementRef.nativeElement;
        }
    }
    Object.defineProperty(SplitterPaneComponent.prototype, "size", {
        /**
         * 2022年6月8日 ximena
         * size、max、min、collapsible、sizeChange、order、orderState这些属性没有被实际使用
         * 该组件常用的属性来自于 ngResizable 拖拽组件
         */
        set: /**
         * 2022年6月8日 ximena
         * size、max、min、collapsible、sizeChange、order、orderState这些属性没有被实际使用
         * 该组件常用的属性来自于 ngResizable 拖拽组件
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._size = value;
            this.sizeChange.emit(value);
            // this._sizeState.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "order", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._order = value;
            //this.orderState.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "enableCollapse", {
        get: /**
         * @return {?}
         */
        function () {
            return this._enableCollapse;
        },
        // 启用収折
        set: 
        // 启用収折
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== undefined && value !== null) {
                this._enableCollapse = value;
                // 变化属性时
                if (this._enableCollapse && this.initCollapse) {
                    this.toggleInitCollapseState();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "relatedIframeParent", {
        get: /**
         * @return {?}
         */
        function () {
            return this._relatedContainer;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._relatedIframeParent = value;
            this.getRelatedIframeParent(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "collapsePosition", {
        get: /**
         * @return {?}
         */
        function () {
            return this.pos;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.enableCollapse && value) {
                // 规范position
                /** @type {?} */
                var positionCorrect = ["left", "right", "top", "bottom"].findIndex((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return item == value; }));
                if (positionCorrect < -1) {
                    value = "right";
                }
                if (this.pos != value) {
                    this.el &&
                        this.renderer.removeClass(this.el, "splitter-pane-collapse-on-" + this.pos);
                    this.pos = value;
                    this.el &&
                        this.renderer.addClass(this.el, "splitter-pane-collapse-on-" + value);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "expandDistance", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expandDistance;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._expandDistance = this.resolveSize(value + "");
            }
            else {
                this._expandDistance = "";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitterPaneComponent.prototype, "collapsed", {
        get: /**
         * @return {?}
         */
        function () {
            return this.initCollapse;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.enableCollapse && value !== undefined && value !== null) {
                if (this.initCollapse !== value) {
                    this.initCollapse = value;
                    this.toggleInitCollapseState();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  拖拽的变化中事件
     *  如果超过阈值，不处理
     *  暂未处理拖拽最大、最小值的问题
     */
    /**
     *  拖拽的变化中事件
     *  如果超过阈值，不处理
     *  暂未处理拖拽最大、最小值的问题
     * @param {?} pos
     * @return {?}
     */
    SplitterPaneComponent.prototype.onRZResizing = /**
     *  拖拽的变化中事件
     *  如果超过阈值，不处理
     *  暂未处理拖拽最大、最小值的问题
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (this.enableCollapse && pos && pos["size"]) {
            /** @type {?} */
            var changeProp = this.getStyleProp();
            /** @type {?} */
            var resizeDirection = "";
            if (this.resizeDistance >= 0) {
                // 开始记录后
                // 此次值比上次记录大，说明在expand
                resizeDirection =
                    pos["size"][changeProp] > this.resizeDistance
                        ? "expand"
                        : "collapse";
            }
            this.resizeDistance = pos["size"][changeProp];
            if (resizeDirection == "expand" && this.initCollapse) {
                this.initCollapse = false;
            }
            if (pos["size"][changeProp] > this.resizeCollapseThreshold ||
                !resizeDirection) {
                // 拖拽速度快的时候，会漏掉计算的时机
                return;
            }
            if (this.resizeCollapseThreshold > 0) {
                // 设置了自动収折阈值
                if (!this.initCollapse && resizeDirection == "collapse") {
                    // 处理拖拽収折过程中，自动收起；不处理展开过程中的，自动展开
                    if (pos["actions"] &&
                        pos["actions"].hasOwnProperty("stopResize")) {
                        pos["actions"]["stopResize"]();
                    }
                    this.toggleCollapseState(null);
                }
            }
            else {
                // 未设置自动収折阈值，需要单独处理 即将收起时状态、即将展开时状态
                if (resizeDirection == "collapse") {
                    if (pos["size"][changeProp] < 3 && !this.initCollapse) {
                        this.initCollapse = true;
                    }
                }
            }
        }
    };
    // 拖拽的开始的事件
    // 拖拽的开始的事件
    /**
     * @param {?} pos
     * @return {?}
     */
    SplitterPaneComponent.prototype.onRZStart = 
    // 拖拽的开始的事件
    /**
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (this.enableCollapse) {
            if (this.el.className.indexOf(this.animateCls) > -1) {
                this.renderer.removeClass(this.el, this.animateCls);
            }
        }
        // 如果有iframe遮罩并且没有显示
        if (this._relatedIframeOverlay && !this._iframeOverlayShownFlag) {
            if (["relative", "absolute"].indexOf(this._relatedContainerPosition) < 0) {
                this.renderer.setStyle(this._relatedContainer, "position", "relative");
            }
            this.renderer.setStyle(this._relatedIframeOverlay, "display", "block");
            this._iframeOverlayShownFlag = true;
        }
        if (!this.updateParamsFlag &&
            pos["actions"] &&
            pos["actions"].hasOwnProperty("updateParams")) {
            pos["actions"]["updateParams"]({ fixedEdge: true });
            this.updateParamsFlag = true;
        }
    };
    // 拖拽的停止事件
    // 拖拽的停止事件
    /**
     * @param {?} pos
     * @return {?}
     */
    SplitterPaneComponent.prototype.onRZStop = 
    // 拖拽的停止事件
    /**
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        this.resizeDistance = -1;
        // 如果有iframe遮罩并且显示了
        if (this._relatedIframeOverlay && this._iframeOverlayShownFlag) {
            if (["relative", "absolute"].indexOf(this._relatedContainerPosition) < 0) {
                this.renderer.setStyle(this._relatedContainer, "position", this._relatedContainerPosition);
            }
            this.renderer.setStyle(this._relatedIframeOverlay, "display", "none");
            this._iframeOverlayShownFlag = false;
        }
    };
    /**
     * @return {?}
     */
    SplitterPaneComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.elementRef) {
            this.compatibleEl();
        }
    };
    /**
     * @return {?}
     */
    SplitterPaneComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (!this.el) {
            this.compatibleEl();
        }
    };
    /**
     * 兼容旧表单写法
     */
    /**
     * 兼容旧表单写法
     * @private
     * @return {?}
     */
    SplitterPaneComponent.prototype.compatibleEl = /**
     * 兼容旧表单写法
     * @private
     * @return {?}
     */
    function () {
        this.el = this.elementRef.nativeElement;
        // 设置了iframe容器，但是没有创建遮罩
        if (this._relatedIframeParent && !this._relatedIframeOverlay) {
            this.getRelatedIframeParent(this._relatedIframeParent);
        }
        this.enableCollapse &&
            this.renderer.addClass(this.el, "splitter-pane-collapse-on-" + this.collapsePosition);
    };
    /**
     * @return {?}
     */
    SplitterPaneComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () { };
    /*宽高类型是 string或者number 解析宽高  尺寸 */
    /*宽高类型是 string或者number 解析宽高  尺寸 */
    /**
     * @param {?} size
     * @return {?}
     */
    SplitterPaneComponent.prototype.resolveSize = /*宽高类型是 string或者number 解析宽高  尺寸 */
    /**
     * @param {?} size
     * @return {?}
     */
    function (size) {
        /** @type {?} */
        var regex = /px|%|rem|em/;
        // 说明是字符串
        return regex.test(size)
            ? "" + parseInt(size, 10) + size.match(regex)[0]
            : size + "px";
    };
    /**
     * 规范获取iframe所在的父容器
     */
    /**
     * 规范获取iframe所在的父容器
     * @private
     * @param {?} content
     * @return {?}
     */
    SplitterPaneComponent.prototype.getRelatedIframeParent = /**
     * 规范获取iframe所在的父容器
     * @private
     * @param {?} content
     * @return {?}
     */
    function (content) {
        if (!content || !this.el) {
            this._relatedContainer = null;
        }
        if (content instanceof ElementRef) {
            this._relatedContainer = content.nativeElement;
        }
        else if (typeof content == "string") {
            this._relatedContainer = this.el.parentElement.querySelector(content);
        }
        else {
            this._relatedContainer = content;
        }
        if (this._relatedContainer) {
            this._relatedContainerPosition = this._relatedContainer["style"]["position"];
            // 构造遮罩层
            this._relatedIframeOverlay = this.renderer.createElement("div");
            this._relatedIframeOverlay.className = "f-utils-absolute-all";
            this.renderer.setStyle(this._relatedIframeOverlay, "display", "none");
            this.renderer.appendChild(this._relatedContainer, this._relatedIframeOverlay);
        }
    };
    /**
     * 点击収折
     */
    /**
     * 点击収折
     * @param {?} ev
     * @return {?}
     */
    SplitterPaneComponent.prototype.toggleCollapseState = /**
     * 点击収折
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        //禁止冒泡
        ev && ev.stopPropagation();
        if (!this.el)
            return;
        if (this.initCollapse) {
            // 待展开
            this.renderer.addClass(this.el, this.animateCls);
            this.changeCollapse("expand");
        }
        else {
            // 待收起
            this.renderer.addClass(this.el, this.animateCls);
            this.changeCollapse("collapse");
        }
        this.initCollapse = !this.initCollapse;
        this.collapseStateChange.emit(this.initCollapse);
    };
    /**
     * 切换初始收起状态
     */
    /**
     * 切换初始收起状态
     * @return {?}
     */
    SplitterPaneComponent.prototype.toggleInitCollapseState = /**
     * 切换初始收起状态
     * @return {?}
     */
    function () {
        if (!this.el)
            return;
        if (this.initCollapse) {
            // 收起
            this.changeCollapse("collapse");
        }
        else {
            // 展开
            this.changeCollapse("expand");
        }
        this.collapseStateChange.emit(this.initCollapse);
    };
    /**
     * expand 为展开，collapse 为收起
     * @param collapseOrExpand
     */
    /**
     * expand 为展开，collapse 为收起
     * @private
     * @param {?} collapseOrExpand
     * @return {?}
     */
    SplitterPaneComponent.prototype.changeCollapse = /**
     * expand 为展开，collapse 为收起
     * @private
     * @param {?} collapseOrExpand
     * @return {?}
     */
    function (collapseOrExpand) {
        /** @type {?} */
        var changeProp = this.getStyleProp();
        switch (collapseOrExpand) {
            case "expand":
                // 展开
                // 如果存在手写width赋值给pane会有问题
                if (this._expandDistance) {
                    //设置了展开距离
                    this.realExpandDisatance = this._expandDistance;
                }
                else {
                    //没有设置，按照之前的记录，如果存在就按照记录的值，如果没有就按照默认的值
                    this.realExpandDisatance = this._beforeCollapseDistance
                        ? this._beforeCollapseDistance + "px"
                        : this.defaultExpandDistance;
                }
                this.renderer.setStyle(this.el, changeProp, this.realExpandDisatance);
                break;
            default:
                // 收起
                this._beforeCollapseDistance =
                    changeProp == "height"
                        ? this.el.offsetHeight
                        : this.el.offsetWidth;
                this.renderer.setStyle(this.el, changeProp, "0px");
        }
    };
    /**
     * 布局排列不一样，影响到是设置宽度还是高度
     */
    /**
     * 布局排列不一样，影响到是设置宽度还是高度
     * @private
     * @return {?}
     */
    SplitterPaneComponent.prototype.getStyleProp = /**
     * 布局排列不一样，影响到是设置宽度还是高度
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var hori = ["left", "right"].findIndex((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item == _this.collapsePosition; }));
        return hori > -1 ? "width" : "height";
    };
    SplitterPaneComponent.decorators = [
        { type: Component, args: [{
                    selector: "farris-splitter-pane",
                    template: "\n        <ng-content></ng-content>\n        <div\n            class=\"f-list-nav-toggle-sidebar\"\n            *ngIf=\"enableCollapse\"\n            [ngClass]=\"{ active: collapsed }\"\n            (click)=\"toggleCollapseState($event)\"\n        >\n            <span class=\"triangle\"></span>\n        </div>\n    "
                }] }
    ];
    /** @nocollapse */
    SplitterPaneComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    SplitterPaneComponent.propDecorators = {
        klass: [{ type: HostBinding, args: ["class.f-component-splitter-pane",] }],
        size: [{ type: Input }],
        max: [{ type: Input }],
        min: [{ type: Input }],
        collapsible: [{ type: Input }],
        sizeChange: [{ type: Output }],
        enableCollapse: [{ type: Input }],
        relatedIframeParent: [{ type: Input }],
        resizeCollapseThreshold: [{ type: Input }],
        collapsePosition: [{ type: Input }],
        expandDistance: [{ type: Input }],
        collapsed: [{ type: Input }],
        collapseStateChange: [{ type: Output, args: ["collapseStateChange",] }],
        onRZResizing: [{ type: HostListener, args: ["rzResizing", ["$event"],] }],
        onRZStart: [{ type: HostListener, args: ["rzStart", ["$event"],] }],
        onRZStop: [{ type: HostListener, args: ["rzStop", ["$event"],] }]
    };
    return SplitterPaneComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Position = /** @class */ (function () {
    function Position(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * @param {?} e
     * @param {?=} el
     * @return {?}
     */
    Position.fromEvent = /**
     * @param {?} e
     * @param {?=} el
     * @return {?}
     */
    function (e, el) {
        if (el === void 0) { el = null; }
        /**
         * Fix issue: Resize doesn't work on Windows10 IE11 (and on some windows 7 IE11)
         * https://github.com/xieziyu/angular2-draggable/issues/164
         * e instanceof MouseEvent check returns false on IE11
         */
        if (this.isMouseEvent(e)) {
            return new Position(e.clientX, e.clientY);
        }
        else {
            if (el === null || e.changedTouches.length === 1) {
                return new Position(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
            /**
             * Fix issue: Multiple phone draggables at the same time
             * https://github.com/xieziyu/angular2-draggable/issues/128
             */
            for (var i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].target === el) {
                    return new Position(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                }
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    Position.isMouseEvent = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        return Object.prototype.toString.apply(e).indexOf('MouseEvent') === 8;
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    Position.isIPosition = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        return !!obj && ('x' in obj) && ('y' in obj);
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Position.getCurrent = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        /** @type {?} */
        var pos = new Position(0, 0);
        if (window) {
            /** @type {?} */
            var computed = window.getComputedStyle(el);
            if (computed) {
                /** @type {?} */
                var x = parseInt(computed.getPropertyValue('left'), 10);
                /** @type {?} */
                var y = parseInt(computed.getPropertyValue('top'), 10);
                pos.x = isNaN(x) ? 0 : x;
                pos.y = isNaN(y) ? 0 : y;
            }
            return pos;
        }
        else {
            // console.error('Not Supported!');
            return null;
        }
    };
    /**
     * @param {?} p
     * @return {?}
     */
    Position.copy = /**
     * @param {?} p
     * @return {?}
     */
    function (p) {
        return new Position(0, 0).set(p);
    };
    Object.defineProperty(Position.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return { x: this.x, y: this.y };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    Position.prototype.add = /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    function (p) {
        (/** @type {?} */ (this)).x += p.x;
        (/** @type {?} */ (this)).y += p.y;
        return (/** @type {?} */ (this));
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    Position.prototype.subtract = /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    function (p) {
        (/** @type {?} */ (this)).x -= p.x;
        (/** @type {?} */ (this)).y -= p.y;
        return (/** @type {?} */ (this));
    };
    /**
     * @param {?} n
     * @return {?}
     */
    Position.prototype.multiply = /**
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.x *= n;
        this.y *= n;
    };
    /**
     * @param {?} n
     * @return {?}
     */
    Position.prototype.divide = /**
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.x /= n;
        this.y /= n;
    };
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    Position.prototype.reset = /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    function () {
        (/** @type {?} */ (this)).x = 0;
        (/** @type {?} */ (this)).y = 0;
        return (/** @type {?} */ (this));
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    Position.prototype.set = /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    function (p) {
        (/** @type {?} */ (this)).x = p.x;
        (/** @type {?} */ (this)).y = p.y;
        return (/** @type {?} */ (this));
    };
    return Position;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HelperBlock = /** @class */ (function () {
    function HelperBlock(parent, renderer) {
        this.parent = parent;
        this.renderer = renderer;
        this._added = false;
        // generate helper div
        /** @type {?} */
        var helper = renderer.createElement('div');
        renderer.setStyle(helper, 'position', 'absolute');
        renderer.setStyle(helper, 'width', '100%');
        renderer.setStyle(helper, 'height', '100%');
        renderer.setStyle(helper, 'background-color', 'transparent');
        renderer.setStyle(helper, 'top', '0');
        renderer.setStyle(helper, 'left', '0');
        // done
        this._helper = helper;
    }
    /**
     * @return {?}
     */
    HelperBlock.prototype.add = /**
     * @return {?}
     */
    function () {
        // append div to parent
        if (this.parent && !this._added) {
            this.parent.appendChild(this._helper);
            this._added = true;
        }
    };
    /**
     * @return {?}
     */
    HelperBlock.prototype.remove = /**
     * @return {?}
     */
    function () {
        if (this.parent && this._added) {
            this.parent.removeChild(this._helper);
            this._added = false;
        }
    };
    /**
     * @return {?}
     */
    HelperBlock.prototype.dispose = /**
     * @return {?}
     */
    function () {
        this._helper = null;
        this._added = false;
    };
    Object.defineProperty(HelperBlock.prototype, "el", {
        get: /**
         * @return {?}
         */
        function () {
            return this._helper;
        },
        enumerable: true,
        configurable: true
    });
    return HelperBlock;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SplitterBarComponent = /** @class */ (function () {
    function SplitterBarComponent(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        // 这个组件没有被使用过，目前实现拖拽都是用ngResizable
        this.klass = true;
        this.position = { x: 0, y: 0 };
        this.trackPosition = true;
        this.gridSize = 1;
        this.lockAxis = null;
        this.scale = 1;
        this.started = new EventEmitter();
        this.stopped = new EventEmitter();
        this.edge = new EventEmitter();
        this.endOffset = new EventEmitter();
        this.movingOffset = new EventEmitter();
        this.orderState = new BehaviorSubject({});
        this.allowDrag = true;
        this.preventDefaultEvent = true;
        // 鼠标初始位置
        this.orignal = null;
        this.draggingSub = null;
        this.moving = false;
        this._helperBlock = null;
        this.needTransform = false;
        this.oldTrans = new Position(0, 0);
        this.tempTrans = new Position(0, 0);
        this.currTrans = new Position(0, 0);
        this.movedTrans = new Position(0, 0);
        this._helperBlock = new HelperBlock(elementRef.nativeElement, renderer);
    }
    Object.defineProperty(SplitterBarComponent.prototype, "order", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._order = value;
            this.orderState.next(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SplitterBarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.el = this.elementRef.nativeElement;
    };
    /**
     * @return {?}
     */
    SplitterBarComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.orderState.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data !== undefined && _this.renderer) {
                _this.renderer.setStyle(_this.el, 'order', data);
            }
        }));
        // console.log("bar" + this.el.getBoundingClientRect().left, this.el.getBoundingClientRect().top)
    };
    /**
     * @return {?}
     */
    SplitterBarComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.orignal = null;
        this.oldTrans = null;
        this.tempTrans = null;
        this.currTrans = null;
        this.movedTrans = null;
        this._helperBlock.dispose();
        this._helperBlock = null;
        if (this.draggingSub) {
            this.draggingSub.unsubscribe();
        }
    };
    /**
     * @private
     * @param {?} p
     * @return {?}
     */
    SplitterBarComponent.prototype.moveTo = /**
     * @private
     * @param {?} p
     * @return {?}
     */
    function (p) {
        if (this.orignal) {
            p.subtract(this.orignal);
            this.tempTrans.set(p);
            this.tempTrans.divide(this.scale);
            this.transform();
            this.movingOffset.emit(this.currTrans.value);
        }
    };
    /**
     * @private
     * @return {?}
     */
    SplitterBarComponent.prototype.transform = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var translateX = this.tempTrans.x + this.oldTrans.x;
        /** @type {?} */
        var translateY = this.tempTrans.y + this.oldTrans.y;
        if (this.lockAxis === 'x') {
            translateX = this.oldTrans.x;
            this.tempTrans.x = 0;
        }
        else if (this.lockAxis === 'y') {
            translateY = this.oldTrans.y;
            this.tempTrans.y = 0;
            // console.log(this.movedTrans.x + this.tempTrans.x, this.movedTrans.x, this.tempTrans.x, this.rightMovedMax, this.leftMovedMax);
            if (this.movedTrans.x + this.tempTrans.x > this.rightMovedMax && this.movedTrans.x + this.tempTrans.x > 0) {
                return;
            }
            if (this.movedTrans.x + this.tempTrans.x <= 0 && Math.abs(this.movedTrans.x + this.tempTrans.x) > this.leftMovedMax) {
                return;
            }
        }
        // Snap to grid: by grid size
        if (this.gridSize > 1) {
            translateX = Math.round(translateX / this.gridSize) * this.gridSize;
            translateY = Math.round(translateY / this.gridSize) * this.gridSize;
        }
        /** @type {?} */
        var value = "translate(" + Math.round(translateX) + "px, " + Math.round(translateY) + "px)";
        this.renderer.setStyle(this.el, 'transform', value);
        this.renderer.setStyle(this.el, '-webkit-transform', value);
        this.renderer.setStyle(this.el, '-ms-transform', value);
        this.renderer.setStyle(this.el, '-moz-transform', value);
        this.renderer.setStyle(this.el, '-o-transform', value);
        // save current position
        this.currTrans.x = translateX;
        this.currTrans.y = translateY;
    };
    /**
     * @private
     * @return {?}
     */
    SplitterBarComponent.prototype.putBack = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._zIndex) {
            this.renderer.setStyle(this.el, 'z-index', this._zIndex);
        }
        else if (this.zIndexMoving) {
            if (this.oldZIndex) {
                this.renderer.setStyle(this.el, 'z-index', this.oldZIndex);
            }
            else {
                this.el.style.removeProperty('z-index');
            }
        }
        if (this.moving) {
            this.stopped.emit(this.el);
            // Remove the helper div:
            this._helperBlock.remove();
            if (this.needTransform) {
                if (Position.isIPosition(this.position)) {
                    this.oldTrans.set(this.position);
                }
                else {
                    this.oldTrans.reset();
                }
                this.transform();
                this.needTransform = false;
            }
            this.moving = false;
            this.endOffset.emit(this.currTrans.value);
            this.renderer.removeStyle(this.el, 'transform');
            if (this.trackPosition) {
                this.oldTrans.add(this.tempTrans);
                this.movedTrans.add(this.tempTrans);
            }
            this.tempTrans.reset();
            if (!this.trackPosition) {
                this.transform();
            }
            if (this.movedTrans.x + this.tempTrans.x >= this.rightMovedMax && this.movedTrans.x + this.tempTrans.x >= 0) {
                this.movedTrans.x = this.rightMovedMax;
            }
            if (this.movedTrans.x + this.tempTrans.x <= 0 && Math.abs(this.movedTrans.x + this.tempTrans.x) >= this.leftMovedMax) {
                this.movedTrans.x = -this.leftMovedMax;
            }
            /** @type {?} */
            var element = this.el;
            this.renderer.removeClass(element, 'ng-dragging');
            /**
             * Fix performance issue:
             * https://github.com/xieziyu/angular2-draggable/issues/112
             */
            this.unsubscribeEvents();
        }
    };
    /**
     * @private
     * @return {?}
     */
    SplitterBarComponent.prototype.pickUp = /**
     * @private
     * @return {?}
     */
    function () {
        // get old z-index:
        this.oldZIndex = this.el.style.zIndex ? this.el.style.zIndex : '';
        if (window) {
            this.oldZIndex = window.getComputedStyle(this.el, null).getPropertyValue('z-index');
        }
        if (this.zIndexMoving) {
            this.renderer.setStyle(this.el, 'z-index', this.zIndexMoving);
        }
        if (!this.moving) {
            this.started.emit(this.el);
            this.moving = true;
            /** @type {?} */
            var element = this.el;
            this.renderer.addClass(element, 'ng-dragging');
            /**
             * Fix performance issue:
             * https://github.com/xieziyu/angular2-draggable/issues/112
             */
            this.subscribeEvents();
        }
    };
    /**
     * @private
     * @return {?}
     */
    SplitterBarComponent.prototype.subscribeEvents = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.draggingSub = fromEvent(document, 'mousemove', { passive: false }).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onMouseMove((/** @type {?} */ (event))); }));
        this.draggingSub.add(fromEvent(document, 'touchmove', { passive: false }).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return _this.onMouseMove((/** @type {?} */ (event))); })));
        this.draggingSub.add(fromEvent(document, 'mouseup', { passive: false }).subscribe((/**
         * @return {?}
         */
        function () { return _this.putBack(); })));
        // checking if browser is IE or Edge - https://github.com/xieziyu/angular2-draggable/issues/153
        /** @type {?} */
        var isIEOrEdge = /msie\s|trident\//i.test(window.navigator.userAgent);
        if (!isIEOrEdge) {
            this.draggingSub.add(fromEvent(document, 'mouseleave', { passive: false }).subscribe((/**
             * @return {?}
             */
            function () { return _this.putBack(); })));
        }
        this.draggingSub.add(fromEvent(document, 'touchend', { passive: false }).subscribe((/**
         * @return {?}
         */
        function () { return _this.putBack(); })));
        this.draggingSub.add(fromEvent(document, 'touchcancel', { passive: false }).subscribe((/**
         * @return {?}
         */
        function () { return _this.putBack(); })));
    };
    /**
     * @private
     * @return {?}
     */
    SplitterBarComponent.prototype.unsubscribeEvents = /**
     * @private
     * @return {?}
     */
    function () {
        this.draggingSub.unsubscribe();
        this.draggingSub = null;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SplitterBarComponent.prototype.onMouseDown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // 1. skip right click;
        if (event instanceof MouseEvent && event.button === 2) {
            return;
        }
        // 2. if handle is set, the element can only be moved by handle
        /** @type {?} */
        var target = event.target || event.srcElement;
        // 3. if allow drag is set to false, ignore the mousedown
        if (this.allowDrag === false) {
            return;
        }
        if (this.preventDefaultEvent) {
            event.stopPropagation();
            event.preventDefault();
        }
        this.orignal = Position.fromEvent(event, this.el);
        this.currTrans.reset();
        this.oldTrans.reset();
        this.pickUp();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SplitterBarComponent.prototype.onMouseMove = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.moving && this.allowDrag) {
            if (this.preventDefaultEvent) {
                event.stopPropagation();
                event.preventDefault();
            }
            // Add a transparent helper div:
            this._helperBlock.add();
            this.moveTo(Position.fromEvent(event, this.el));
        }
    };
    SplitterBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'farris-splitter-bar',
                    template: "\n    ss\n  ",
                    host: {
                        'ngDraggable': 'true'
                    },
                    styles: ["\n        :host{\n            width: 8px;\n            background: #ebebeb;\n            cursor: move;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    SplitterBarComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    SplitterBarComponent.propDecorators = {
        klass: [{ type: HostBinding, args: ['class.f-component-splitter-bar',] }],
        zIndexMoving: [{ type: Input }],
        position: [{ type: Input }],
        trackPosition: [{ type: Input }],
        gridSize: [{ type: Input }],
        lockAxis: [{ type: Input }],
        scale: [{ type: Input }],
        started: [{ type: Output }],
        stopped: [{ type: Output }],
        edge: [{ type: Output }],
        endOffset: [{ type: Output }],
        movingOffset: [{ type: Output }],
        onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }, { type: HostListener, args: ['touchstart', ['$event'],] }]
    };
    return SplitterBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SplitterComponent = /** @class */ (function () {
    function SplitterComponent(componentFactoryResolver, injector, renderer, elementRef) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.splitterCls = true;
        // @HostBinding('class.d-flex') flexCls = true;
        this.orientation = "horizontal";
        this.barComponentRefArray = [];
    }
    /**
     * @return {?}
     */
    SplitterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    SplitterComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    SplitterComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        //使用的是ngResizable，没有使用Bar，此处方法可不执行
        this.hostEl = this.elementRef.nativeElement;
        //  this.initPane();
    };
    /**
     * @return {?}
     */
    SplitterComponent.prototype.initPane = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.pane && this.pane['_results'] && this.pane['_results'].length) {
            /** @type {?} */
            var hostWidth_1 = this.hostEl.offsetWidth;
            /** @type {?} */
            var length_1 = this.pane['_results'].length;
            /** @type {?} */
            var restPane = this.pane['_results'].filter((/**
             * @param {?} item
             * @return {?}
             */
            function (item) {
                return !item._size;
            }));
            /** @type {?} */
            var restLength_1 = restPane.length;
            this.pane['_results'].forEach((/**
             * @param {?} item
             * @param {?} index
             * @return {?}
             */
            function (item, index) {
                item.order = index * 2;
                if (!!item._size) {
                    hostWidth_1 = hostWidth_1 - _this.getElementSize(hostWidth_1, item._size);
                }
            }));
            restPane.forEach((/**
             * @param {?} item
             * @return {?}
             */
            function (item) {
                item.size = hostWidth_1 / restLength_1;
            }));
            if (length_1 > 1) {
                this.createBar(length_1 - 1);
            }
            this.listenPaneSizeChange();
        }
    };
    /**
     * @return {?}
     */
    SplitterComponent.prototype.listenPaneSizeChange = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var hostWidth = this.hostEl.offsetWidth;
        this.pane['_results'].forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        function (item, index) {
            item.sizeChange.subscribe((/**
             * @param {?} size
             * @return {?}
             */
            function (size) {
                /** @type {?} */
                var nextIndex = index + 1;
                /** @type {?} */
                var diff = item.el.offsetWidth - size;
                if (_this.pane['_results'][nextIndex]) {
                    /** @type {?} */
                    var nextPaneMin = _this.getElementSize(hostWidth, _this.pane['_results'][nextIndex].min);
                    if (_this.barComponentRefArray[nextIndex]) {
                        // 拖拽向左的最大宽度
                        if (nextPaneMin >= item.el.offsetWidth || nextPaneMin <= 0) {
                            _this.barComponentRefArray[nextIndex].instance.leftMovedMax = _this.pane['_results'][nextIndex].el.offsetWidth + diff;
                        }
                        else {
                            _this.barComponentRefArray[nextIndex].instance.leftMovedMax = _this.pane['_results'][nextIndex].el.offsetWidth + diff - nextPaneMin;
                        }
                    }
                }
            }));
        }));
    };
    // 获取目标元素的size
    // 获取目标元素的size
    /**
     * @param {?} hostWidth
     * @param {?} size
     * @return {?}
     */
    SplitterComponent.prototype.getElementSize = 
    // 获取目标元素的size
    /**
     * @param {?} hostWidth
     * @param {?} size
     * @return {?}
     */
    function (hostWidth, size) {
        /** @type {?} */
        var targetSize;
        if (!size) {
            targetSize = 0;
            return targetSize;
        }
        if (size.indexOf('px') !== -1 || typeof size === 'number') {
            targetSize = parseInt(size);
        }
        else if (size.indexOf('%') !== -1) {
            targetSize = hostWidth * parseInt(size) / 100;
        }
        return targetSize;
    };
    /**
     * @param {?} len
     * @return {?}
     */
    SplitterComponent.prototype.createBar = /**
     * @param {?} len
     * @return {?}
     */
    function (len) {
        /** @type {?} */
        var hostWidth = this.hostEl.offsetWidth;
        var _loop_1 = function (i) {
            /** @type {?} */
            var factory = this_1.componentFactoryResolver.resolveComponentFactory(SplitterBarComponent);
            /** @type {?} */
            var componentRef = this_1.container.createComponent(factory);
            /** @type {?} */
            var prevPane = this_1.pane['_results'][i];
            /** @type {?} */
            var prevPaneOriginWidth = prevPane.el.offsetWidth;
            /** @type {?} */
            var nextPane = this_1.pane['_results'][i + 1];
            /** @type {?} */
            var nextPaneOriginWidth = nextPane.el.offsetWidth;
            /** @type {?} */
            var prePaneMax = this_1.getElementSize(hostWidth, this_1.pane['_results'][i].max);
            /** @type {?} */
            var prePaneMin = this_1.getElementSize(hostWidth, this_1.pane['_results'][i].min);
            // 拖拽向右的最大宽度
            if (prePaneMax <= prevPaneOriginWidth && prePaneMax > 0) {
                componentRef.instance.rightMovedMax = 0;
            }
            else if (prePaneMax >= prevPaneOriginWidth + nextPaneOriginWidth || prePaneMax === 0) {
                componentRef.instance.rightMovedMax = nextPaneOriginWidth;
            }
            else {
                componentRef.instance.rightMovedMax = prePaneMax - prevPaneOriginWidth;
            }
            // 拖拽向左的最大宽度
            if (prePaneMin >= prevPaneOriginWidth || prePaneMin <= 0) {
                componentRef.instance.leftMovedMax = prevPaneOriginWidth;
            }
            else {
                componentRef.instance.leftMovedMax = prevPaneOriginWidth - prePaneMin;
            }
            // 横向拖拽还是纵向拖拽
            if (this_1.orientation === 'horizontal') {
                componentRef.instance.lockAxis = 'y';
            }
            else if (this_1.orientation === 'vertical') {
                componentRef.instance.lockAxis = 'x';
            }
            componentRef.instance.order = 2 * i + 1;
            // 拖拽变化
            componentRef.instance.endOffset.subscribe((/**
             * @param {?} data
             * @return {?}
             */
            function (data) {
                prevPane.size = prevPane.el.offsetWidth + data.x;
                nextPane.size = nextPane.el.offsetWidth - data.x;
                // console.log(prevPanelOriginWidth + data.x, nextPanelOriginWidth - data.x)
            }));
            this_1.barComponentRefArray.push(componentRef);
            componentRef.changeDetectorRef.detectChanges();
        };
        var this_1 = this;
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    };
    SplitterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'farris-splitter',
                    template: "\n    <ng-content></ng-content>\n    <ng-container #container></ng-container>\n  "
                }] }
    ];
    /** @nocollapse */
    SplitterComponent.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    SplitterComponent.propDecorators = {
        splitterCls: [{ type: HostBinding, args: ['class.f-component-splitter',] }],
        orientation: [{ type: Input }],
        container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
        pane: [{ type: ContentChildren, args: [SplitterPaneComponent,] }]
    };
    return SplitterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SplitterModule = /** @class */ (function () {
    function SplitterModule() {
    }
    SplitterModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        SplitterComponent,
                        SplitterPaneComponent,
                        SplitterBarComponent
                    ],
                    imports: [
                        CommonModule,
                        AngularDraggableModule,
                        PerfectScrollbarModule
                    ],
                    exports: [
                        SplitterComponent,
                        SplitterPaneComponent,
                        SplitterBarComponent
                    ],
                    entryComponents: [
                        SplitterBarComponent
                    ]
                },] }
    ];
    return SplitterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { SplitterService, SplitterComponent, SplitterPaneComponent, SplitterModule, SplitterBarComponent as ɵa };

//# sourceMappingURL=farris-ui-splitter.js.map