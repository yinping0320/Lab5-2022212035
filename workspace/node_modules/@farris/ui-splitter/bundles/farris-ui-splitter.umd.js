(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('@angular/core'), require('@angular/common'), require('@farris/ui-draggable'), require('@farris/ui-perfect-scrollbar')) :
    typeof define === 'function' && define.amd ? define('@farris/ui-splitter', ['exports', 'rxjs', '@angular/core', '@angular/common', '@farris/ui-draggable', '@farris/ui-perfect-scrollbar'], factory) :
    (factory((global.farris = global.farris || {}, global.farris['ui-splitter'] = {}),global.rxjs,global.ng.core,global.ng.common,global.uiDraggable,global.uiPerfectScrollbar));
}(this, (function (exports,rxjs,i0,common,uiDraggable,uiPerfectScrollbar) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SplitterService = /** @class */ (function () {
        function SplitterService() {
        }
        SplitterService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        SplitterService.ctorParameters = function () { return []; };
        /** @nocollapse */ SplitterService.ngInjectableDef = i0.defineInjectable({ factory: function SplitterService_Factory() { return new SplitterService(); }, token: SplitterService, providedIn: "root" });
        return SplitterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SplitterPaneComponent = /** @class */ (function () {
        function SplitterPaneComponent(elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.klass = true;
            this.collapsible = false;
            this.sizeChange = new i0.EventEmitter();
            //orderState = new BehaviorSubject<any>({});
            // 记录収折前宽度，方便后续恢复
            this._beforeCollapseDistance = -1;
            this._enableCollapse = false;
            // 记录真实的iframe父容器
            this._relatedContainer = null;
            // 标记iframe父容器的样式属性position的值
            this._relatedContainerPosition = "";
            // 记录iframe在拖拽时的遮罩层
            this._relatedIframeOverlay = null;
            // 标记iframe遮罩层是否已显示
            this._iframeOverlayShownFlag = false;
            // 拖拽到某个值时，自动收起的阈值。如果阈值设置小于0，则不处理自动收起
            this.resizeCollapseThreshold = 20;
            // pane在splitter的位置，left 左侧 right 右侧 top 顶部 bottom 底部
            this.pos = "right";
            // 真实的展开时的距离，
            this.defaultExpandDistance = "20%";
            this.realExpandDisatance = "";
            // 展开时的距离，不设置时为空，设置了按照设置的值来
            this._expandDistance = "";
            // 初始收起状态
            this.initCollapse = false;
            /**
             * 收起折叠状态变化
             */
            this.collapseStateChange = new i0.EventEmitter();
            // collapse的动画样式名
            this.animateCls = "splitter-pane-collapse-animate";
            // 标记是否需要更新变量
            this.updateParamsFlag = false;
            // 标记拖拽时上次的大小
            this.resizeDistance = -1;
            // 兼容旧表单写法
            if (this.elementRef) {
                this.el = this.elementRef.nativeElement;
            }
        }
        Object.defineProperty(SplitterPaneComponent.prototype, "size", {
            /**
             * 2022年6月8日 ximena
             * size、max、min、collapsible、sizeChange、order、orderState这些属性没有被实际使用
             * 该组件常用的属性来自于 ngResizable 拖拽组件
             */
            set: /**
             * 2022年6月8日 ximena
             * size、max、min、collapsible、sizeChange、order、orderState这些属性没有被实际使用
             * 该组件常用的属性来自于 ngResizable 拖拽组件
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._size = value;
                this.sizeChange.emit(value);
                // this._sizeState.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitterPaneComponent.prototype, "order", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._order = value;
                //this.orderState.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitterPaneComponent.prototype, "enableCollapse", {
            get: /**
             * @return {?}
             */ function () {
                return this._enableCollapse;
            },
            // 启用収折
            set: 
            // 启用収折
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== undefined && value !== null) {
                    this._enableCollapse = value;
                    // 变化属性时
                    if (this._enableCollapse && this.initCollapse) {
                        this.toggleInitCollapseState();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitterPaneComponent.prototype, "relatedIframeParent", {
            get: /**
             * @return {?}
             */ function () {
                return this._relatedContainer;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._relatedIframeParent = value;
                this.getRelatedIframeParent(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitterPaneComponent.prototype, "collapsePosition", {
            get: /**
             * @return {?}
             */ function () {
                return this.pos;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.enableCollapse && value) {
                    // 规范position
                    /** @type {?} */
                    var positionCorrect = ["left", "right", "top", "bottom"].findIndex(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) { return item == value; }));
                    if (positionCorrect < -1) {
                        value = "right";
                    }
                    if (this.pos != value) {
                        this.el &&
                            this.renderer.removeClass(this.el, "splitter-pane-collapse-on-" + this.pos);
                        this.pos = value;
                        this.el &&
                            this.renderer.addClass(this.el, "splitter-pane-collapse-on-" + value);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitterPaneComponent.prototype, "expandDistance", {
            get: /**
             * @return {?}
             */ function () {
                return this._expandDistance;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._expandDistance = this.resolveSize(value + "");
                }
                else {
                    this._expandDistance = "";
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitterPaneComponent.prototype, "collapsed", {
            get: /**
             * @return {?}
             */ function () {
                return this.initCollapse;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.enableCollapse && value !== undefined && value !== null) {
                    if (this.initCollapse !== value) {
                        this.initCollapse = value;
                        this.toggleInitCollapseState();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *  拖拽的变化中事件
         *  如果超过阈值，不处理
         *  暂未处理拖拽最大、最小值的问题
         */
        /**
         *  拖拽的变化中事件
         *  如果超过阈值，不处理
         *  暂未处理拖拽最大、最小值的问题
         * @param {?} pos
         * @return {?}
         */
        SplitterPaneComponent.prototype.onRZResizing = /**
         *  拖拽的变化中事件
         *  如果超过阈值，不处理
         *  暂未处理拖拽最大、最小值的问题
         * @param {?} pos
         * @return {?}
         */
            function (pos) {
                if (this.enableCollapse && pos && pos["size"]) {
                    /** @type {?} */
                    var changeProp = this.getStyleProp();
                    /** @type {?} */
                    var resizeDirection = "";
                    if (this.resizeDistance >= 0) {
                        // 开始记录后
                        // 此次值比上次记录大，说明在expand
                        resizeDirection =
                            pos["size"][changeProp] > this.resizeDistance
                                ? "expand"
                                : "collapse";
                    }
                    this.resizeDistance = pos["size"][changeProp];
                    if (resizeDirection == "expand" && this.initCollapse) {
                        this.initCollapse = false;
                    }
                    if (pos["size"][changeProp] > this.resizeCollapseThreshold ||
                        !resizeDirection) {
                        // 拖拽速度快的时候，会漏掉计算的时机
                        return;
                    }
                    if (this.resizeCollapseThreshold > 0) {
                        // 设置了自动収折阈值
                        if (!this.initCollapse && resizeDirection == "collapse") {
                            // 处理拖拽収折过程中，自动收起；不处理展开过程中的，自动展开
                            if (pos["actions"] &&
                                pos["actions"].hasOwnProperty("stopResize")) {
                                pos["actions"]["stopResize"]();
                            }
                            this.toggleCollapseState(null);
                        }
                    }
                    else {
                        // 未设置自动収折阈值，需要单独处理 即将收起时状态、即将展开时状态
                        if (resizeDirection == "collapse") {
                            if (pos["size"][changeProp] < 3 && !this.initCollapse) {
                                this.initCollapse = true;
                            }
                        }
                    }
                }
            };
        // 拖拽的开始的事件
        // 拖拽的开始的事件
        /**
         * @param {?} pos
         * @return {?}
         */
        SplitterPaneComponent.prototype.onRZStart =
            // 拖拽的开始的事件
            /**
             * @param {?} pos
             * @return {?}
             */
            function (pos) {
                if (this.enableCollapse) {
                    if (this.el.className.indexOf(this.animateCls) > -1) {
                        this.renderer.removeClass(this.el, this.animateCls);
                    }
                }
                // 如果有iframe遮罩并且没有显示
                if (this._relatedIframeOverlay && !this._iframeOverlayShownFlag) {
                    if (["relative", "absolute"].indexOf(this._relatedContainerPosition) < 0) {
                        this.renderer.setStyle(this._relatedContainer, "position", "relative");
                    }
                    this.renderer.setStyle(this._relatedIframeOverlay, "display", "block");
                    this._iframeOverlayShownFlag = true;
                }
                if (!this.updateParamsFlag &&
                    pos["actions"] &&
                    pos["actions"].hasOwnProperty("updateParams")) {
                    pos["actions"]["updateParams"]({ fixedEdge: true });
                    this.updateParamsFlag = true;
                }
            };
        // 拖拽的停止事件
        // 拖拽的停止事件
        /**
         * @param {?} pos
         * @return {?}
         */
        SplitterPaneComponent.prototype.onRZStop =
            // 拖拽的停止事件
            /**
             * @param {?} pos
             * @return {?}
             */
            function (pos) {
                this.resizeDistance = -1;
                // 如果有iframe遮罩并且显示了
                if (this._relatedIframeOverlay && this._iframeOverlayShownFlag) {
                    if (["relative", "absolute"].indexOf(this._relatedContainerPosition) < 0) {
                        this.renderer.setStyle(this._relatedContainer, "position", this._relatedContainerPosition);
                    }
                    this.renderer.setStyle(this._relatedIframeOverlay, "display", "none");
                    this._iframeOverlayShownFlag = false;
                }
            };
        /**
         * @return {?}
         */
        SplitterPaneComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.elementRef) {
                    this.compatibleEl();
                }
            };
        /**
         * @return {?}
         */
        SplitterPaneComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (!this.el) {
                    this.compatibleEl();
                }
            };
        /**
         * 兼容旧表单写法
         */
        /**
         * 兼容旧表单写法
         * @private
         * @return {?}
         */
        SplitterPaneComponent.prototype.compatibleEl = /**
         * 兼容旧表单写法
         * @private
         * @return {?}
         */
            function () {
                this.el = this.elementRef.nativeElement;
                // 设置了iframe容器，但是没有创建遮罩
                if (this._relatedIframeParent && !this._relatedIframeOverlay) {
                    this.getRelatedIframeParent(this._relatedIframeParent);
                }
                this.enableCollapse &&
                    this.renderer.addClass(this.el, "splitter-pane-collapse-on-" + this.collapsePosition);
            };
        /**
         * @return {?}
         */
        SplitterPaneComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () { };
        /*宽高类型是 string或者number 解析宽高  尺寸 */
        /*宽高类型是 string或者number 解析宽高  尺寸 */
        /**
         * @param {?} size
         * @return {?}
         */
        SplitterPaneComponent.prototype.resolveSize = /*宽高类型是 string或者number 解析宽高  尺寸 */
            /**
             * @param {?} size
             * @return {?}
             */
            function (size) {
                /** @type {?} */
                var regex = /px|%|rem|em/;
                // 说明是字符串
                return regex.test(size)
                    ? "" + parseInt(size, 10) + size.match(regex)[0]
                    : size + "px";
            };
        /**
         * 规范获取iframe所在的父容器
         */
        /**
         * 规范获取iframe所在的父容器
         * @private
         * @param {?} content
         * @return {?}
         */
        SplitterPaneComponent.prototype.getRelatedIframeParent = /**
         * 规范获取iframe所在的父容器
         * @private
         * @param {?} content
         * @return {?}
         */
            function (content) {
                if (!content || !this.el) {
                    this._relatedContainer = null;
                }
                if (content instanceof i0.ElementRef) {
                    this._relatedContainer = content.nativeElement;
                }
                else if (typeof content == "string") {
                    this._relatedContainer = this.el.parentElement.querySelector(content);
                }
                else {
                    this._relatedContainer = content;
                }
                if (this._relatedContainer) {
                    this._relatedContainerPosition = this._relatedContainer["style"]["position"];
                    // 构造遮罩层
                    this._relatedIframeOverlay = this.renderer.createElement("div");
                    this._relatedIframeOverlay.className = "f-utils-absolute-all";
                    this.renderer.setStyle(this._relatedIframeOverlay, "display", "none");
                    this.renderer.appendChild(this._relatedContainer, this._relatedIframeOverlay);
                }
            };
        /**
         * 点击収折
         */
        /**
         * 点击収折
         * @param {?} ev
         * @return {?}
         */
        SplitterPaneComponent.prototype.toggleCollapseState = /**
         * 点击収折
         * @param {?} ev
         * @return {?}
         */
            function (ev) {
                //禁止冒泡
                ev && ev.stopPropagation();
                if (!this.el)
                    return;
                if (this.initCollapse) {
                    // 待展开
                    this.renderer.addClass(this.el, this.animateCls);
                    this.changeCollapse("expand");
                }
                else {
                    // 待收起
                    this.renderer.addClass(this.el, this.animateCls);
                    this.changeCollapse("collapse");
                }
                this.initCollapse = !this.initCollapse;
                this.collapseStateChange.emit(this.initCollapse);
            };
        /**
         * 切换初始收起状态
         */
        /**
         * 切换初始收起状态
         * @return {?}
         */
        SplitterPaneComponent.prototype.toggleInitCollapseState = /**
         * 切换初始收起状态
         * @return {?}
         */
            function () {
                if (!this.el)
                    return;
                if (this.initCollapse) {
                    // 收起
                    this.changeCollapse("collapse");
                }
                else {
                    // 展开
                    this.changeCollapse("expand");
                }
                this.collapseStateChange.emit(this.initCollapse);
            };
        /**
         * expand 为展开，collapse 为收起
         * @param collapseOrExpand
         */
        /**
         * expand 为展开，collapse 为收起
         * @private
         * @param {?} collapseOrExpand
         * @return {?}
         */
        SplitterPaneComponent.prototype.changeCollapse = /**
         * expand 为展开，collapse 为收起
         * @private
         * @param {?} collapseOrExpand
         * @return {?}
         */
            function (collapseOrExpand) {
                /** @type {?} */
                var changeProp = this.getStyleProp();
                switch (collapseOrExpand) {
                    case "expand":
                        // 展开
                        // 如果存在手写width赋值给pane会有问题
                        if (this._expandDistance) {
                            //设置了展开距离
                            this.realExpandDisatance = this._expandDistance;
                        }
                        else {
                            //没有设置，按照之前的记录，如果存在就按照记录的值，如果没有就按照默认的值
                            this.realExpandDisatance = this._beforeCollapseDistance
                                ? this._beforeCollapseDistance + "px"
                                : this.defaultExpandDistance;
                        }
                        this.renderer.setStyle(this.el, changeProp, this.realExpandDisatance);
                        break;
                    default:
                        // 收起
                        this._beforeCollapseDistance =
                            changeProp == "height"
                                ? this.el.offsetHeight
                                : this.el.offsetWidth;
                        this.renderer.setStyle(this.el, changeProp, "0px");
                }
            };
        /**
         * 布局排列不一样，影响到是设置宽度还是高度
         */
        /**
         * 布局排列不一样，影响到是设置宽度还是高度
         * @private
         * @return {?}
         */
        SplitterPaneComponent.prototype.getStyleProp = /**
         * 布局排列不一样，影响到是设置宽度还是高度
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var hori = ["left", "right"].findIndex(( /**
                 * @param {?} item
                 * @return {?}
                 */function (item) { return item == _this.collapsePosition; }));
                return hori > -1 ? "width" : "height";
            };
        SplitterPaneComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: "farris-splitter-pane",
                        template: "\n        <ng-content></ng-content>\n        <div\n            class=\"f-list-nav-toggle-sidebar\"\n            *ngIf=\"enableCollapse\"\n            [ngClass]=\"{ active: collapsed }\"\n            (click)=\"toggleCollapseState($event)\"\n        >\n            <span class=\"triangle\"></span>\n        </div>\n    "
                    }] }
        ];
        /** @nocollapse */
        SplitterPaneComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        SplitterPaneComponent.propDecorators = {
            klass: [{ type: i0.HostBinding, args: ["class.f-component-splitter-pane",] }],
            size: [{ type: i0.Input }],
            max: [{ type: i0.Input }],
            min: [{ type: i0.Input }],
            collapsible: [{ type: i0.Input }],
            sizeChange: [{ type: i0.Output }],
            enableCollapse: [{ type: i0.Input }],
            relatedIframeParent: [{ type: i0.Input }],
            resizeCollapseThreshold: [{ type: i0.Input }],
            collapsePosition: [{ type: i0.Input }],
            expandDistance: [{ type: i0.Input }],
            collapsed: [{ type: i0.Input }],
            collapseStateChange: [{ type: i0.Output, args: ["collapseStateChange",] }],
            onRZResizing: [{ type: i0.HostListener, args: ["rzResizing", ["$event"],] }],
            onRZStart: [{ type: i0.HostListener, args: ["rzStart", ["$event"],] }],
            onRZStop: [{ type: i0.HostListener, args: ["rzStop", ["$event"],] }]
        };
        return SplitterPaneComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Position = /** @class */ (function () {
        function Position(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * @param {?} e
         * @param {?=} el
         * @return {?}
         */
        Position.fromEvent = /**
         * @param {?} e
         * @param {?=} el
         * @return {?}
         */
            function (e, el) {
                if (el === void 0) {
                    el = null;
                }
                /**
                 * Fix issue: Resize doesn't work on Windows10 IE11 (and on some windows 7 IE11)
                 * https://github.com/xieziyu/angular2-draggable/issues/164
                 * e instanceof MouseEvent check returns false on IE11
                 */
                if (this.isMouseEvent(e)) {
                    return new Position(e.clientX, e.clientY);
                }
                else {
                    if (el === null || e.changedTouches.length === 1) {
                        return new Position(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                    }
                    /**
                     * Fix issue: Multiple phone draggables at the same time
                     * https://github.com/xieziyu/angular2-draggable/issues/128
                     */
                    for (var i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].target === el) {
                            return new Position(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                        }
                    }
                }
            };
        /**
         * @param {?} e
         * @return {?}
         */
        Position.isMouseEvent = /**
         * @param {?} e
         * @return {?}
         */
            function (e) {
                return Object.prototype.toString.apply(e).indexOf('MouseEvent') === 8;
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        Position.isIPosition = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                return !!obj && ('x' in obj) && ('y' in obj);
            };
        /**
         * @param {?} el
         * @return {?}
         */
        Position.getCurrent = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                /** @type {?} */
                var pos = new Position(0, 0);
                if (window) {
                    /** @type {?} */
                    var computed = window.getComputedStyle(el);
                    if (computed) {
                        /** @type {?} */
                        var x = parseInt(computed.getPropertyValue('left'), 10);
                        /** @type {?} */
                        var y = parseInt(computed.getPropertyValue('top'), 10);
                        pos.x = isNaN(x) ? 0 : x;
                        pos.y = isNaN(y) ? 0 : y;
                    }
                    return pos;
                }
                else {
                    // console.error('Not Supported!');
                    return null;
                }
            };
        /**
         * @param {?} p
         * @return {?}
         */
        Position.copy = /**
         * @param {?} p
         * @return {?}
         */
            function (p) {
                return new Position(0, 0).set(p);
            };
        Object.defineProperty(Position.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return { x: this.x, y: this.y };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} p
         * @return {THIS}
         */
        Position.prototype.add = /**
         * @template THIS
         * @this {THIS}
         * @param {?} p
         * @return {THIS}
         */
            function (p) {
                ( /** @type {?} */(this)).x += p.x;
                ( /** @type {?} */(this)).y += p.y;
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} p
         * @return {THIS}
         */
        Position.prototype.subtract = /**
         * @template THIS
         * @this {THIS}
         * @param {?} p
         * @return {THIS}
         */
            function (p) {
                ( /** @type {?} */(this)).x -= p.x;
                ( /** @type {?} */(this)).y -= p.y;
                return ( /** @type {?} */(this));
            };
        /**
         * @param {?} n
         * @return {?}
         */
        Position.prototype.multiply = /**
         * @param {?} n
         * @return {?}
         */
            function (n) {
                this.x *= n;
                this.y *= n;
            };
        /**
         * @param {?} n
         * @return {?}
         */
        Position.prototype.divide = /**
         * @param {?} n
         * @return {?}
         */
            function (n) {
                this.x /= n;
                this.y /= n;
            };
        /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        Position.prototype.reset = /**
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
            function () {
                ( /** @type {?} */(this)).x = 0;
                ( /** @type {?} */(this)).y = 0;
                return ( /** @type {?} */(this));
            };
        /**
         * @template THIS
         * @this {THIS}
         * @param {?} p
         * @return {THIS}
         */
        Position.prototype.set = /**
         * @template THIS
         * @this {THIS}
         * @param {?} p
         * @return {THIS}
         */
            function (p) {
                ( /** @type {?} */(this)).x = p.x;
                ( /** @type {?} */(this)).y = p.y;
                return ( /** @type {?} */(this));
            };
        return Position;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HelperBlock = /** @class */ (function () {
        function HelperBlock(parent, renderer) {
            this.parent = parent;
            this.renderer = renderer;
            this._added = false;
            // generate helper div
            /** @type {?} */
            var helper = renderer.createElement('div');
            renderer.setStyle(helper, 'position', 'absolute');
            renderer.setStyle(helper, 'width', '100%');
            renderer.setStyle(helper, 'height', '100%');
            renderer.setStyle(helper, 'background-color', 'transparent');
            renderer.setStyle(helper, 'top', '0');
            renderer.setStyle(helper, 'left', '0');
            // done
            this._helper = helper;
        }
        /**
         * @return {?}
         */
        HelperBlock.prototype.add = /**
         * @return {?}
         */
            function () {
                // append div to parent
                if (this.parent && !this._added) {
                    this.parent.appendChild(this._helper);
                    this._added = true;
                }
            };
        /**
         * @return {?}
         */
        HelperBlock.prototype.remove = /**
         * @return {?}
         */
            function () {
                if (this.parent && this._added) {
                    this.parent.removeChild(this._helper);
                    this._added = false;
                }
            };
        /**
         * @return {?}
         */
        HelperBlock.prototype.dispose = /**
         * @return {?}
         */
            function () {
                this._helper = null;
                this._added = false;
            };
        Object.defineProperty(HelperBlock.prototype, "el", {
            get: /**
             * @return {?}
             */ function () {
                return this._helper;
            },
            enumerable: true,
            configurable: true
        });
        return HelperBlock;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SplitterBarComponent = /** @class */ (function () {
        function SplitterBarComponent(elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            // 这个组件没有被使用过，目前实现拖拽都是用ngResizable
            this.klass = true;
            this.position = { x: 0, y: 0 };
            this.trackPosition = true;
            this.gridSize = 1;
            this.lockAxis = null;
            this.scale = 1;
            this.started = new i0.EventEmitter();
            this.stopped = new i0.EventEmitter();
            this.edge = new i0.EventEmitter();
            this.endOffset = new i0.EventEmitter();
            this.movingOffset = new i0.EventEmitter();
            this.orderState = new rxjs.BehaviorSubject({});
            this.allowDrag = true;
            this.preventDefaultEvent = true;
            // 鼠标初始位置
            this.orignal = null;
            this.draggingSub = null;
            this.moving = false;
            this._helperBlock = null;
            this.needTransform = false;
            this.oldTrans = new Position(0, 0);
            this.tempTrans = new Position(0, 0);
            this.currTrans = new Position(0, 0);
            this.movedTrans = new Position(0, 0);
            this._helperBlock = new HelperBlock(elementRef.nativeElement, renderer);
        }
        Object.defineProperty(SplitterBarComponent.prototype, "order", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._order = value;
                this.orderState.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SplitterBarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.el = this.elementRef.nativeElement;
            };
        /**
         * @return {?}
         */
        SplitterBarComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.orderState.subscribe(( /**
                 * @param {?} data
                 * @return {?}
                 */function (data) {
                    if (data !== undefined && _this.renderer) {
                        _this.renderer.setStyle(_this.el, 'order', data);
                    }
                }));
                // console.log("bar" + this.el.getBoundingClientRect().left, this.el.getBoundingClientRect().top)
            };
        /**
         * @return {?}
         */
        SplitterBarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.orignal = null;
                this.oldTrans = null;
                this.tempTrans = null;
                this.currTrans = null;
                this.movedTrans = null;
                this._helperBlock.dispose();
                this._helperBlock = null;
                if (this.draggingSub) {
                    this.draggingSub.unsubscribe();
                }
            };
        /**
         * @private
         * @param {?} p
         * @return {?}
         */
        SplitterBarComponent.prototype.moveTo = /**
         * @private
         * @param {?} p
         * @return {?}
         */
            function (p) {
                if (this.orignal) {
                    p.subtract(this.orignal);
                    this.tempTrans.set(p);
                    this.tempTrans.divide(this.scale);
                    this.transform();
                    this.movingOffset.emit(this.currTrans.value);
                }
            };
        /**
         * @private
         * @return {?}
         */
        SplitterBarComponent.prototype.transform = /**
         * @private
         * @return {?}
         */
            function () {
                /** @type {?} */
                var translateX = this.tempTrans.x + this.oldTrans.x;
                /** @type {?} */
                var translateY = this.tempTrans.y + this.oldTrans.y;
                if (this.lockAxis === 'x') {
                    translateX = this.oldTrans.x;
                    this.tempTrans.x = 0;
                }
                else if (this.lockAxis === 'y') {
                    translateY = this.oldTrans.y;
                    this.tempTrans.y = 0;
                    // console.log(this.movedTrans.x + this.tempTrans.x, this.movedTrans.x, this.tempTrans.x, this.rightMovedMax, this.leftMovedMax);
                    if (this.movedTrans.x + this.tempTrans.x > this.rightMovedMax && this.movedTrans.x + this.tempTrans.x > 0) {
                        return;
                    }
                    if (this.movedTrans.x + this.tempTrans.x <= 0 && Math.abs(this.movedTrans.x + this.tempTrans.x) > this.leftMovedMax) {
                        return;
                    }
                }
                // Snap to grid: by grid size
                if (this.gridSize > 1) {
                    translateX = Math.round(translateX / this.gridSize) * this.gridSize;
                    translateY = Math.round(translateY / this.gridSize) * this.gridSize;
                }
                /** @type {?} */
                var value = "translate(" + Math.round(translateX) + "px, " + Math.round(translateY) + "px)";
                this.renderer.setStyle(this.el, 'transform', value);
                this.renderer.setStyle(this.el, '-webkit-transform', value);
                this.renderer.setStyle(this.el, '-ms-transform', value);
                this.renderer.setStyle(this.el, '-moz-transform', value);
                this.renderer.setStyle(this.el, '-o-transform', value);
                // save current position
                this.currTrans.x = translateX;
                this.currTrans.y = translateY;
            };
        /**
         * @private
         * @return {?}
         */
        SplitterBarComponent.prototype.putBack = /**
         * @private
         * @return {?}
         */
            function () {
                if (this._zIndex) {
                    this.renderer.setStyle(this.el, 'z-index', this._zIndex);
                }
                else if (this.zIndexMoving) {
                    if (this.oldZIndex) {
                        this.renderer.setStyle(this.el, 'z-index', this.oldZIndex);
                    }
                    else {
                        this.el.style.removeProperty('z-index');
                    }
                }
                if (this.moving) {
                    this.stopped.emit(this.el);
                    // Remove the helper div:
                    this._helperBlock.remove();
                    if (this.needTransform) {
                        if (Position.isIPosition(this.position)) {
                            this.oldTrans.set(this.position);
                        }
                        else {
                            this.oldTrans.reset();
                        }
                        this.transform();
                        this.needTransform = false;
                    }
                    this.moving = false;
                    this.endOffset.emit(this.currTrans.value);
                    this.renderer.removeStyle(this.el, 'transform');
                    if (this.trackPosition) {
                        this.oldTrans.add(this.tempTrans);
                        this.movedTrans.add(this.tempTrans);
                    }
                    this.tempTrans.reset();
                    if (!this.trackPosition) {
                        this.transform();
                    }
                    if (this.movedTrans.x + this.tempTrans.x >= this.rightMovedMax && this.movedTrans.x + this.tempTrans.x >= 0) {
                        this.movedTrans.x = this.rightMovedMax;
                    }
                    if (this.movedTrans.x + this.tempTrans.x <= 0 && Math.abs(this.movedTrans.x + this.tempTrans.x) >= this.leftMovedMax) {
                        this.movedTrans.x = -this.leftMovedMax;
                    }
                    /** @type {?} */
                    var element = this.el;
                    this.renderer.removeClass(element, 'ng-dragging');
                    /**
                     * Fix performance issue:
                     * https://github.com/xieziyu/angular2-draggable/issues/112
                     */
                    this.unsubscribeEvents();
                }
            };
        /**
         * @private
         * @return {?}
         */
        SplitterBarComponent.prototype.pickUp = /**
         * @private
         * @return {?}
         */
            function () {
                // get old z-index:
                this.oldZIndex = this.el.style.zIndex ? this.el.style.zIndex : '';
                if (window) {
                    this.oldZIndex = window.getComputedStyle(this.el, null).getPropertyValue('z-index');
                }
                if (this.zIndexMoving) {
                    this.renderer.setStyle(this.el, 'z-index', this.zIndexMoving);
                }
                if (!this.moving) {
                    this.started.emit(this.el);
                    this.moving = true;
                    /** @type {?} */
                    var element = this.el;
                    this.renderer.addClass(element, 'ng-dragging');
                    /**
                     * Fix performance issue:
                     * https://github.com/xieziyu/angular2-draggable/issues/112
                     */
                    this.subscribeEvents();
                }
            };
        /**
         * @private
         * @return {?}
         */
        SplitterBarComponent.prototype.subscribeEvents = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                this.draggingSub = rxjs.fromEvent(document, 'mousemove', { passive: false }).subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) { return _this.onMouseMove(( /** @type {?} */(event))); }));
                this.draggingSub.add(rxjs.fromEvent(document, 'touchmove', { passive: false }).subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) { return _this.onMouseMove(( /** @type {?} */(event))); })));
                this.draggingSub.add(rxjs.fromEvent(document, 'mouseup', { passive: false }).subscribe(( /**
                 * @return {?}
                 */function () { return _this.putBack(); })));
                // checking if browser is IE or Edge - https://github.com/xieziyu/angular2-draggable/issues/153
                /** @type {?} */
                var isIEOrEdge = /msie\s|trident\//i.test(window.navigator.userAgent);
                if (!isIEOrEdge) {
                    this.draggingSub.add(rxjs.fromEvent(document, 'mouseleave', { passive: false }).subscribe(( /**
                     * @return {?}
                     */function () { return _this.putBack(); })));
                }
                this.draggingSub.add(rxjs.fromEvent(document, 'touchend', { passive: false }).subscribe(( /**
                 * @return {?}
                 */function () { return _this.putBack(); })));
                this.draggingSub.add(rxjs.fromEvent(document, 'touchcancel', { passive: false }).subscribe(( /**
                 * @return {?}
                 */function () { return _this.putBack(); })));
            };
        /**
         * @private
         * @return {?}
         */
        SplitterBarComponent.prototype.unsubscribeEvents = /**
         * @private
         * @return {?}
         */
            function () {
                this.draggingSub.unsubscribe();
                this.draggingSub = null;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterBarComponent.prototype.onMouseDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // 1. skip right click;
                if (event instanceof MouseEvent && event.button === 2) {
                    return;
                }
                // 2. if handle is set, the element can only be moved by handle
                /** @type {?} */
                var target = event.target || event.srcElement;
                // 3. if allow drag is set to false, ignore the mousedown
                if (this.allowDrag === false) {
                    return;
                }
                if (this.preventDefaultEvent) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                this.orignal = Position.fromEvent(event, this.el);
                this.currTrans.reset();
                this.oldTrans.reset();
                this.pickUp();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterBarComponent.prototype.onMouseMove = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.moving && this.allowDrag) {
                    if (this.preventDefaultEvent) {
                        event.stopPropagation();
                        event.preventDefault();
                    }
                    // Add a transparent helper div:
                    this._helperBlock.add();
                    this.moveTo(Position.fromEvent(event, this.el));
                }
            };
        SplitterBarComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'farris-splitter-bar',
                        template: "\n    ss\n  ",
                        host: {
                            'ngDraggable': 'true'
                        },
                        styles: ["\n        :host{\n            width: 8px;\n            background: #ebebeb;\n            cursor: move;\n        }\n    "]
                    }] }
        ];
        /** @nocollapse */
        SplitterBarComponent.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        SplitterBarComponent.propDecorators = {
            klass: [{ type: i0.HostBinding, args: ['class.f-component-splitter-bar',] }],
            zIndexMoving: [{ type: i0.Input }],
            position: [{ type: i0.Input }],
            trackPosition: [{ type: i0.Input }],
            gridSize: [{ type: i0.Input }],
            lockAxis: [{ type: i0.Input }],
            scale: [{ type: i0.Input }],
            started: [{ type: i0.Output }],
            stopped: [{ type: i0.Output }],
            edge: [{ type: i0.Output }],
            endOffset: [{ type: i0.Output }],
            movingOffset: [{ type: i0.Output }],
            onMouseDown: [{ type: i0.HostListener, args: ['mousedown', ['$event'],] }, { type: i0.HostListener, args: ['touchstart', ['$event'],] }]
        };
        return SplitterBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SplitterComponent = /** @class */ (function () {
        function SplitterComponent(componentFactoryResolver, injector, renderer, elementRef) {
            this.componentFactoryResolver = componentFactoryResolver;
            this.injector = injector;
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.splitterCls = true;
            // @HostBinding('class.d-flex') flexCls = true;
            this.orientation = "horizontal";
            this.barComponentRefArray = [];
        }
        /**
         * @return {?}
         */
        SplitterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        SplitterComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        SplitterComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                //使用的是ngResizable，没有使用Bar，此处方法可不执行
                this.hostEl = this.elementRef.nativeElement;
                //  this.initPane();
            };
        /**
         * @return {?}
         */
        SplitterComponent.prototype.initPane = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.pane && this.pane['_results'] && this.pane['_results'].length) {
                    /** @type {?} */
                    var hostWidth_1 = this.hostEl.offsetWidth;
                    /** @type {?} */
                    var length_1 = this.pane['_results'].length;
                    /** @type {?} */
                    var restPane = this.pane['_results'].filter(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) {
                        return !item._size;
                    }));
                    /** @type {?} */
                    var restLength_1 = restPane.length;
                    this.pane['_results'].forEach(( /**
                     * @param {?} item
                     * @param {?} index
                     * @return {?}
                     */function (item, index) {
                        item.order = index * 2;
                        if (!!item._size) {
                            hostWidth_1 = hostWidth_1 - _this.getElementSize(hostWidth_1, item._size);
                        }
                    }));
                    restPane.forEach(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) {
                        item.size = hostWidth_1 / restLength_1;
                    }));
                    if (length_1 > 1) {
                        this.createBar(length_1 - 1);
                    }
                    this.listenPaneSizeChange();
                }
            };
        /**
         * @return {?}
         */
        SplitterComponent.prototype.listenPaneSizeChange = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var hostWidth = this.hostEl.offsetWidth;
                this.pane['_results'].forEach(( /**
                 * @param {?} item
                 * @param {?} index
                 * @return {?}
                 */function (item, index) {
                    item.sizeChange.subscribe(( /**
                     * @param {?} size
                     * @return {?}
                     */function (size) {
                        /** @type {?} */
                        var nextIndex = index + 1;
                        /** @type {?} */
                        var diff = item.el.offsetWidth - size;
                        if (_this.pane['_results'][nextIndex]) {
                            /** @type {?} */
                            var nextPaneMin = _this.getElementSize(hostWidth, _this.pane['_results'][nextIndex].min);
                            if (_this.barComponentRefArray[nextIndex]) {
                                // 拖拽向左的最大宽度
                                if (nextPaneMin >= item.el.offsetWidth || nextPaneMin <= 0) {
                                    _this.barComponentRefArray[nextIndex].instance.leftMovedMax = _this.pane['_results'][nextIndex].el.offsetWidth + diff;
                                }
                                else {
                                    _this.barComponentRefArray[nextIndex].instance.leftMovedMax = _this.pane['_results'][nextIndex].el.offsetWidth + diff - nextPaneMin;
                                }
                            }
                        }
                    }));
                }));
            };
        // 获取目标元素的size
        // 获取目标元素的size
        /**
         * @param {?} hostWidth
         * @param {?} size
         * @return {?}
         */
        SplitterComponent.prototype.getElementSize =
            // 获取目标元素的size
            /**
             * @param {?} hostWidth
             * @param {?} size
             * @return {?}
             */
            function (hostWidth, size) {
                /** @type {?} */
                var targetSize;
                if (!size) {
                    targetSize = 0;
                    return targetSize;
                }
                if (size.indexOf('px') !== -1 || typeof size === 'number') {
                    targetSize = parseInt(size);
                }
                else if (size.indexOf('%') !== -1) {
                    targetSize = hostWidth * parseInt(size) / 100;
                }
                return targetSize;
            };
        /**
         * @param {?} len
         * @return {?}
         */
        SplitterComponent.prototype.createBar = /**
         * @param {?} len
         * @return {?}
         */
            function (len) {
                /** @type {?} */
                var hostWidth = this.hostEl.offsetWidth;
                var _loop_1 = function (i) {
                    /** @type {?} */
                    var factory = this_1.componentFactoryResolver.resolveComponentFactory(SplitterBarComponent);
                    /** @type {?} */
                    var componentRef = this_1.container.createComponent(factory);
                    /** @type {?} */
                    var prevPane = this_1.pane['_results'][i];
                    /** @type {?} */
                    var prevPaneOriginWidth = prevPane.el.offsetWidth;
                    /** @type {?} */
                    var nextPane = this_1.pane['_results'][i + 1];
                    /** @type {?} */
                    var nextPaneOriginWidth = nextPane.el.offsetWidth;
                    /** @type {?} */
                    var prePaneMax = this_1.getElementSize(hostWidth, this_1.pane['_results'][i].max);
                    /** @type {?} */
                    var prePaneMin = this_1.getElementSize(hostWidth, this_1.pane['_results'][i].min);
                    // 拖拽向右的最大宽度
                    if (prePaneMax <= prevPaneOriginWidth && prePaneMax > 0) {
                        componentRef.instance.rightMovedMax = 0;
                    }
                    else if (prePaneMax >= prevPaneOriginWidth + nextPaneOriginWidth || prePaneMax === 0) {
                        componentRef.instance.rightMovedMax = nextPaneOriginWidth;
                    }
                    else {
                        componentRef.instance.rightMovedMax = prePaneMax - prevPaneOriginWidth;
                    }
                    // 拖拽向左的最大宽度
                    if (prePaneMin >= prevPaneOriginWidth || prePaneMin <= 0) {
                        componentRef.instance.leftMovedMax = prevPaneOriginWidth;
                    }
                    else {
                        componentRef.instance.leftMovedMax = prevPaneOriginWidth - prePaneMin;
                    }
                    // 横向拖拽还是纵向拖拽
                    if (this_1.orientation === 'horizontal') {
                        componentRef.instance.lockAxis = 'y';
                    }
                    else if (this_1.orientation === 'vertical') {
                        componentRef.instance.lockAxis = 'x';
                    }
                    componentRef.instance.order = 2 * i + 1;
                    // 拖拽变化
                    componentRef.instance.endOffset.subscribe(( /**
                     * @param {?} data
                     * @return {?}
                     */function (data) {
                        prevPane.size = prevPane.el.offsetWidth + data.x;
                        nextPane.size = nextPane.el.offsetWidth - data.x;
                        // console.log(prevPanelOriginWidth + data.x, nextPanelOriginWidth - data.x)
                    }));
                    this_1.barComponentRefArray.push(componentRef);
                    componentRef.changeDetectorRef.detectChanges();
                };
                var this_1 = this;
                for (var i = 0; i < len; i++) {
                    _loop_1(i);
                }
            };
        SplitterComponent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'farris-splitter',
                        template: "\n    <ng-content></ng-content>\n    <ng-container #container></ng-container>\n  "
                    }] }
        ];
        /** @nocollapse */
        SplitterComponent.ctorParameters = function () {
            return [
                { type: i0.ComponentFactoryResolver },
                { type: i0.Injector },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        SplitterComponent.propDecorators = {
            splitterCls: [{ type: i0.HostBinding, args: ['class.f-component-splitter',] }],
            orientation: [{ type: i0.Input }],
            container: [{ type: i0.ViewChild, args: ['container', { read: i0.ViewContainerRef },] }],
            pane: [{ type: i0.ContentChildren, args: [SplitterPaneComponent,] }]
        };
        return SplitterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SplitterModule = /** @class */ (function () {
        function SplitterModule() {
        }
        SplitterModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            SplitterComponent,
                            SplitterPaneComponent,
                            SplitterBarComponent
                        ],
                        imports: [
                            common.CommonModule,
                            uiDraggable.AngularDraggableModule,
                            uiPerfectScrollbar.PerfectScrollbarModule
                        ],
                        exports: [
                            SplitterComponent,
                            SplitterPaneComponent,
                            SplitterBarComponent
                        ],
                        entryComponents: [
                            SplitterBarComponent
                        ]
                    },] }
        ];
        return SplitterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.SplitterService = SplitterService;
    exports.SplitterComponent = SplitterComponent;
    exports.SplitterPaneComponent = SplitterPaneComponent;
    exports.SplitterModule = SplitterModule;
    exports.ɵa = SplitterBarComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=farris-ui-splitter.umd.js.map