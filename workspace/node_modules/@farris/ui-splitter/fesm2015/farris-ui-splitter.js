import { fromEvent, BehaviorSubject } from 'rxjs';
import { Injectable, Component, Input, HostBinding, Renderer2, ElementRef, HostListener, Output, EventEmitter, ContentChildren, ComponentFactoryResolver, ViewContainerRef, Injector, ViewChild, NgModule, defineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AngularDraggableModule } from '@farris/ui-draggable';
import { PerfectScrollbarModule } from '@farris/ui-perfect-scrollbar';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SplitterService {
    constructor() { }
}
SplitterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
SplitterService.ctorParameters = () => [];
/** @nocollapse */ SplitterService.ngInjectableDef = defineInjectable({ factory: function SplitterService_Factory() { return new SplitterService(); }, token: SplitterService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SplitterPaneComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.klass = true;
        this.collapsible = false;
        this.sizeChange = new EventEmitter();
        //orderState = new BehaviorSubject<any>({});
        // 记录収折前宽度，方便后续恢复
        this._beforeCollapseDistance = -1;
        this._enableCollapse = false;
        // 记录真实的iframe父容器
        this._relatedContainer = null;
        // 标记iframe父容器的样式属性position的值
        this._relatedContainerPosition = "";
        // 记录iframe在拖拽时的遮罩层
        this._relatedIframeOverlay = null;
        // 标记iframe遮罩层是否已显示
        this._iframeOverlayShownFlag = false;
        // 拖拽到某个值时，自动收起的阈值。如果阈值设置小于0，则不处理自动收起
        this.resizeCollapseThreshold = 20;
        // pane在splitter的位置，left 左侧 right 右侧 top 顶部 bottom 底部
        this.pos = "right";
        // 真实的展开时的距离，
        this.defaultExpandDistance = "20%";
        this.realExpandDisatance = "";
        // 展开时的距离，不设置时为空，设置了按照设置的值来
        this._expandDistance = "";
        // 初始收起状态
        this.initCollapse = false;
        /**
         * 收起折叠状态变化
         */
        this.collapseStateChange = new EventEmitter();
        // collapse的动画样式名
        this.animateCls = "splitter-pane-collapse-animate";
        // 标记是否需要更新变量
        this.updateParamsFlag = false;
        // 标记拖拽时上次的大小
        this.resizeDistance = -1;
        // 兼容旧表单写法
        if (this.elementRef) {
            this.el = this.elementRef.nativeElement;
        }
    }
    /**
     * 2022年6月8日 ximena
     * size、max、min、collapsible、sizeChange、order、orderState这些属性没有被实际使用
     * 该组件常用的属性来自于 ngResizable 拖拽组件
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this._size = value;
        this.sizeChange.emit(value);
        // this._sizeState.next(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set order(value) {
        this._order = value;
        //this.orderState.next(value);
    }
    // 启用収折
    /**
     * @param {?} value
     * @return {?}
     */
    set enableCollapse(value) {
        if (value !== undefined && value !== null) {
            this._enableCollapse = value;
            // 变化属性时
            if (this._enableCollapse && this.initCollapse) {
                this.toggleInitCollapseState();
            }
        }
    }
    /**
     * @return {?}
     */
    get enableCollapse() {
        return this._enableCollapse;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set relatedIframeParent(value) {
        this._relatedIframeParent = value;
        this.getRelatedIframeParent(value);
    }
    /**
     * @return {?}
     */
    get relatedIframeParent() {
        return this._relatedContainer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collapsePosition(value) {
        if (this.enableCollapse && value) {
            // 规范position
            /** @type {?} */
            let positionCorrect = ["left", "right", "top", "bottom"].findIndex((/**
             * @param {?} item
             * @return {?}
             */
            item => item == value));
            if (positionCorrect < -1) {
                value = "right";
            }
            if (this.pos != value) {
                this.el &&
                    this.renderer.removeClass(this.el, "splitter-pane-collapse-on-" + this.pos);
                this.pos = value;
                this.el &&
                    this.renderer.addClass(this.el, "splitter-pane-collapse-on-" + value);
            }
        }
    }
    /**
     * @return {?}
     */
    get collapsePosition() {
        return this.pos;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expandDistance(value) {
        if (value) {
            this._expandDistance = this.resolveSize(value + "");
        }
        else {
            this._expandDistance = "";
        }
    }
    /**
     * @return {?}
     */
    get expandDistance() {
        return this._expandDistance;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collapsed(value) {
        if (this.enableCollapse && value !== undefined && value !== null) {
            if (this.initCollapse !== value) {
                this.initCollapse = value;
                this.toggleInitCollapseState();
            }
        }
    }
    /**
     * @return {?}
     */
    get collapsed() {
        return this.initCollapse;
    }
    /**
     *  拖拽的变化中事件
     *  如果超过阈值，不处理
     *  暂未处理拖拽最大、最小值的问题
     * @param {?} pos
     * @return {?}
     */
    onRZResizing(pos) {
        if (this.enableCollapse && pos && pos["size"]) {
            /** @type {?} */
            let changeProp = this.getStyleProp();
            /** @type {?} */
            let resizeDirection = "";
            if (this.resizeDistance >= 0) {
                // 开始记录后
                // 此次值比上次记录大，说明在expand
                resizeDirection =
                    pos["size"][changeProp] > this.resizeDistance
                        ? "expand"
                        : "collapse";
            }
            this.resizeDistance = pos["size"][changeProp];
            if (resizeDirection == "expand" && this.initCollapse) {
                this.initCollapse = false;
            }
            if (pos["size"][changeProp] > this.resizeCollapseThreshold ||
                !resizeDirection) {
                // 拖拽速度快的时候，会漏掉计算的时机
                return;
            }
            if (this.resizeCollapseThreshold > 0) {
                // 设置了自动収折阈值
                if (!this.initCollapse && resizeDirection == "collapse") {
                    // 处理拖拽収折过程中，自动收起；不处理展开过程中的，自动展开
                    if (pos["actions"] &&
                        pos["actions"].hasOwnProperty("stopResize")) {
                        pos["actions"]["stopResize"]();
                    }
                    this.toggleCollapseState(null);
                }
            }
            else {
                // 未设置自动収折阈值，需要单独处理 即将收起时状态、即将展开时状态
                if (resizeDirection == "collapse") {
                    if (pos["size"][changeProp] < 3 && !this.initCollapse) {
                        this.initCollapse = true;
                    }
                }
            }
        }
    }
    // 拖拽的开始的事件
    /**
     * @param {?} pos
     * @return {?}
     */
    onRZStart(pos) {
        if (this.enableCollapse) {
            if (this.el.className.indexOf(this.animateCls) > -1) {
                this.renderer.removeClass(this.el, this.animateCls);
            }
        }
        // 如果有iframe遮罩并且没有显示
        if (this._relatedIframeOverlay && !this._iframeOverlayShownFlag) {
            if (["relative", "absolute"].indexOf(this._relatedContainerPosition) < 0) {
                this.renderer.setStyle(this._relatedContainer, "position", "relative");
            }
            this.renderer.setStyle(this._relatedIframeOverlay, "display", "block");
            this._iframeOverlayShownFlag = true;
        }
        if (!this.updateParamsFlag &&
            pos["actions"] &&
            pos["actions"].hasOwnProperty("updateParams")) {
            pos["actions"]["updateParams"]({ fixedEdge: true });
            this.updateParamsFlag = true;
        }
    }
    // 拖拽的停止事件
    /**
     * @param {?} pos
     * @return {?}
     */
    onRZStop(pos) {
        this.resizeDistance = -1;
        // 如果有iframe遮罩并且显示了
        if (this._relatedIframeOverlay && this._iframeOverlayShownFlag) {
            if (["relative", "absolute"].indexOf(this._relatedContainerPosition) < 0) {
                this.renderer.setStyle(this._relatedContainer, "position", this._relatedContainerPosition);
            }
            this.renderer.setStyle(this._relatedIframeOverlay, "display", "none");
            this._iframeOverlayShownFlag = false;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.elementRef) {
            this.compatibleEl();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.el) {
            this.compatibleEl();
        }
    }
    /**
     * 兼容旧表单写法
     * @private
     * @return {?}
     */
    compatibleEl() {
        this.el = this.elementRef.nativeElement;
        // 设置了iframe容器，但是没有创建遮罩
        if (this._relatedIframeParent && !this._relatedIframeOverlay) {
            this.getRelatedIframeParent(this._relatedIframeParent);
        }
        this.enableCollapse &&
            this.renderer.addClass(this.el, "splitter-pane-collapse-on-" + this.collapsePosition);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() { }
    /*宽高类型是 string或者number 解析宽高  尺寸 */
    /**
     * @param {?} size
     * @return {?}
     */
    resolveSize(size) {
        /** @type {?} */
        const regex = /px|%|rem|em/;
        // 说明是字符串
        return regex.test(size)
            ? `${parseInt(size, 10)}${size.match(regex)[0]}`
            : `${size}px`;
    }
    /**
     * 规范获取iframe所在的父容器
     * @private
     * @param {?} content
     * @return {?}
     */
    getRelatedIframeParent(content) {
        if (!content || !this.el) {
            this._relatedContainer = null;
        }
        if (content instanceof ElementRef) {
            this._relatedContainer = content.nativeElement;
        }
        else if (typeof content == "string") {
            this._relatedContainer = this.el.parentElement.querySelector(content);
        }
        else {
            this._relatedContainer = content;
        }
        if (this._relatedContainer) {
            this._relatedContainerPosition = this._relatedContainer["style"]["position"];
            // 构造遮罩层
            this._relatedIframeOverlay = this.renderer.createElement("div");
            this._relatedIframeOverlay.className = "f-utils-absolute-all";
            this.renderer.setStyle(this._relatedIframeOverlay, "display", "none");
            this.renderer.appendChild(this._relatedContainer, this._relatedIframeOverlay);
        }
    }
    /**
     * 点击収折
     * @param {?} ev
     * @return {?}
     */
    toggleCollapseState(ev) {
        //禁止冒泡
        ev && ev.stopPropagation();
        if (!this.el)
            return;
        if (this.initCollapse) {
            // 待展开
            this.renderer.addClass(this.el, this.animateCls);
            this.changeCollapse("expand");
        }
        else {
            // 待收起
            this.renderer.addClass(this.el, this.animateCls);
            this.changeCollapse("collapse");
        }
        this.initCollapse = !this.initCollapse;
        this.collapseStateChange.emit(this.initCollapse);
    }
    /**
     * 切换初始收起状态
     * @return {?}
     */
    toggleInitCollapseState() {
        if (!this.el)
            return;
        if (this.initCollapse) {
            // 收起
            this.changeCollapse("collapse");
        }
        else {
            // 展开
            this.changeCollapse("expand");
        }
        this.collapseStateChange.emit(this.initCollapse);
    }
    /**
     * expand 为展开，collapse 为收起
     * @private
     * @param {?} collapseOrExpand
     * @return {?}
     */
    changeCollapse(collapseOrExpand) {
        /** @type {?} */
        let changeProp = this.getStyleProp();
        switch (collapseOrExpand) {
            case "expand":
                // 展开
                // 如果存在手写width赋值给pane会有问题
                if (this._expandDistance) {
                    //设置了展开距离
                    this.realExpandDisatance = this._expandDistance;
                }
                else {
                    //没有设置，按照之前的记录，如果存在就按照记录的值，如果没有就按照默认的值
                    this.realExpandDisatance = this._beforeCollapseDistance
                        ? this._beforeCollapseDistance + "px"
                        : this.defaultExpandDistance;
                }
                this.renderer.setStyle(this.el, changeProp, this.realExpandDisatance);
                break;
            default:
                // 收起
                this._beforeCollapseDistance =
                    changeProp == "height"
                        ? this.el.offsetHeight
                        : this.el.offsetWidth;
                this.renderer.setStyle(this.el, changeProp, "0px");
        }
    }
    /**
     * 布局排列不一样，影响到是设置宽度还是高度
     * @private
     * @return {?}
     */
    getStyleProp() {
        /** @type {?} */
        let hori = ["left", "right"].findIndex((/**
         * @param {?} item
         * @return {?}
         */
        item => item == this.collapsePosition));
        return hori > -1 ? "width" : "height";
    }
}
SplitterPaneComponent.decorators = [
    { type: Component, args: [{
                selector: "farris-splitter-pane",
                template: `
        <ng-content></ng-content>
        <div
            class="f-list-nav-toggle-sidebar"
            *ngIf="enableCollapse"
            [ngClass]="{ active: collapsed }"
            (click)="toggleCollapseState($event)"
        >
            <span class="triangle"></span>
        </div>
    `
            }] }
];
/** @nocollapse */
SplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
SplitterPaneComponent.propDecorators = {
    klass: [{ type: HostBinding, args: ["class.f-component-splitter-pane",] }],
    size: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    collapsible: [{ type: Input }],
    sizeChange: [{ type: Output }],
    enableCollapse: [{ type: Input }],
    relatedIframeParent: [{ type: Input }],
    resizeCollapseThreshold: [{ type: Input }],
    collapsePosition: [{ type: Input }],
    expandDistance: [{ type: Input }],
    collapsed: [{ type: Input }],
    collapseStateChange: [{ type: Output, args: ["collapseStateChange",] }],
    onRZResizing: [{ type: HostListener, args: ["rzResizing", ["$event"],] }],
    onRZStart: [{ type: HostListener, args: ["rzStart", ["$event"],] }],
    onRZStop: [{ type: HostListener, args: ["rzStop", ["$event"],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Position {
    /**
     * @param {?} x
     * @param {?} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * @param {?} e
     * @param {?=} el
     * @return {?}
     */
    static fromEvent(e, el = null) {
        /**
         * Fix issue: Resize doesn't work on Windows10 IE11 (and on some windows 7 IE11)
         * https://github.com/xieziyu/angular2-draggable/issues/164
         * e instanceof MouseEvent check returns false on IE11
         */
        if (this.isMouseEvent(e)) {
            return new Position(e.clientX, e.clientY);
        }
        else {
            if (el === null || e.changedTouches.length === 1) {
                return new Position(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
            /**
             * Fix issue: Multiple phone draggables at the same time
             * https://github.com/xieziyu/angular2-draggable/issues/128
             */
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].target === el) {
                    return new Position(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                }
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    static isMouseEvent(e) {
        return Object.prototype.toString.apply(e).indexOf('MouseEvent') === 8;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    static isIPosition(obj) {
        return !!obj && ('x' in obj) && ('y' in obj);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    static getCurrent(el) {
        /** @type {?} */
        let pos = new Position(0, 0);
        if (window) {
            /** @type {?} */
            const computed = window.getComputedStyle(el);
            if (computed) {
                /** @type {?} */
                let x = parseInt(computed.getPropertyValue('left'), 10);
                /** @type {?} */
                let y = parseInt(computed.getPropertyValue('top'), 10);
                pos.x = isNaN(x) ? 0 : x;
                pos.y = isNaN(y) ? 0 : y;
            }
            return pos;
        }
        else {
            // console.error('Not Supported!');
            return null;
        }
    }
    /**
     * @param {?} p
     * @return {?}
     */
    static copy(p) {
        return new Position(0, 0).set(p);
    }
    /**
     * @return {?}
     */
    get value() {
        return { x: this.x, y: this.y };
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    add(p) {
        (/** @type {?} */ (this)).x += p.x;
        (/** @type {?} */ (this)).y += p.y;
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    subtract(p) {
        (/** @type {?} */ (this)).x -= p.x;
        (/** @type {?} */ (this)).y -= p.y;
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} n
     * @return {?}
     */
    multiply(n) {
        this.x *= n;
        this.y *= n;
    }
    /**
     * @param {?} n
     * @return {?}
     */
    divide(n) {
        this.x /= n;
        this.y /= n;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    reset() {
        (/** @type {?} */ (this)).x = 0;
        (/** @type {?} */ (this)).y = 0;
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} p
     * @return {THIS}
     */
    set(p) {
        (/** @type {?} */ (this)).x = p.x;
        (/** @type {?} */ (this)).y = p.y;
        return (/** @type {?} */ (this));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HelperBlock {
    /**
     * @param {?} parent
     * @param {?} renderer
     */
    constructor(parent, renderer) {
        this.parent = parent;
        this.renderer = renderer;
        this._added = false;
        // generate helper div
        /** @type {?} */
        let helper = renderer.createElement('div');
        renderer.setStyle(helper, 'position', 'absolute');
        renderer.setStyle(helper, 'width', '100%');
        renderer.setStyle(helper, 'height', '100%');
        renderer.setStyle(helper, 'background-color', 'transparent');
        renderer.setStyle(helper, 'top', '0');
        renderer.setStyle(helper, 'left', '0');
        // done
        this._helper = helper;
    }
    /**
     * @return {?}
     */
    add() {
        // append div to parent
        if (this.parent && !this._added) {
            this.parent.appendChild(this._helper);
            this._added = true;
        }
    }
    /**
     * @return {?}
     */
    remove() {
        if (this.parent && this._added) {
            this.parent.removeChild(this._helper);
            this._added = false;
        }
    }
    /**
     * @return {?}
     */
    dispose() {
        this._helper = null;
        this._added = false;
    }
    /**
     * @return {?}
     */
    get el() {
        return this._helper;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SplitterBarComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        // 这个组件没有被使用过，目前实现拖拽都是用ngResizable
        this.klass = true;
        this.position = { x: 0, y: 0 };
        this.trackPosition = true;
        this.gridSize = 1;
        this.lockAxis = null;
        this.scale = 1;
        this.started = new EventEmitter();
        this.stopped = new EventEmitter();
        this.edge = new EventEmitter();
        this.endOffset = new EventEmitter();
        this.movingOffset = new EventEmitter();
        this.orderState = new BehaviorSubject({});
        this.allowDrag = true;
        this.preventDefaultEvent = true;
        // 鼠标初始位置
        this.orignal = null;
        this.draggingSub = null;
        this.moving = false;
        this._helperBlock = null;
        this.needTransform = false;
        this.oldTrans = new Position(0, 0);
        this.tempTrans = new Position(0, 0);
        this.currTrans = new Position(0, 0);
        this.movedTrans = new Position(0, 0);
        this._helperBlock = new HelperBlock(elementRef.nativeElement, renderer);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set order(value) {
        this._order = value;
        this.orderState.next(value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.orderState.subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            if (data !== undefined && this.renderer) {
                this.renderer.setStyle(this.el, 'order', data);
            }
        }));
        // console.log("bar" + this.el.getBoundingClientRect().left, this.el.getBoundingClientRect().top)
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.orignal = null;
        this.oldTrans = null;
        this.tempTrans = null;
        this.currTrans = null;
        this.movedTrans = null;
        this._helperBlock.dispose();
        this._helperBlock = null;
        if (this.draggingSub) {
            this.draggingSub.unsubscribe();
        }
    }
    /**
     * @private
     * @param {?} p
     * @return {?}
     */
    moveTo(p) {
        if (this.orignal) {
            p.subtract(this.orignal);
            this.tempTrans.set(p);
            this.tempTrans.divide(this.scale);
            this.transform();
            this.movingOffset.emit(this.currTrans.value);
        }
    }
    /**
     * @private
     * @return {?}
     */
    transform() {
        /** @type {?} */
        let translateX = this.tempTrans.x + this.oldTrans.x;
        /** @type {?} */
        let translateY = this.tempTrans.y + this.oldTrans.y;
        if (this.lockAxis === 'x') {
            translateX = this.oldTrans.x;
            this.tempTrans.x = 0;
        }
        else if (this.lockAxis === 'y') {
            translateY = this.oldTrans.y;
            this.tempTrans.y = 0;
            // console.log(this.movedTrans.x + this.tempTrans.x, this.movedTrans.x, this.tempTrans.x, this.rightMovedMax, this.leftMovedMax);
            if (this.movedTrans.x + this.tempTrans.x > this.rightMovedMax && this.movedTrans.x + this.tempTrans.x > 0) {
                return;
            }
            if (this.movedTrans.x + this.tempTrans.x <= 0 && Math.abs(this.movedTrans.x + this.tempTrans.x) > this.leftMovedMax) {
                return;
            }
        }
        // Snap to grid: by grid size
        if (this.gridSize > 1) {
            translateX = Math.round(translateX / this.gridSize) * this.gridSize;
            translateY = Math.round(translateY / this.gridSize) * this.gridSize;
        }
        /** @type {?} */
        let value = `translate(${Math.round(translateX)}px, ${Math.round(translateY)}px)`;
        this.renderer.setStyle(this.el, 'transform', value);
        this.renderer.setStyle(this.el, '-webkit-transform', value);
        this.renderer.setStyle(this.el, '-ms-transform', value);
        this.renderer.setStyle(this.el, '-moz-transform', value);
        this.renderer.setStyle(this.el, '-o-transform', value);
        // save current position
        this.currTrans.x = translateX;
        this.currTrans.y = translateY;
    }
    /**
     * @private
     * @return {?}
     */
    putBack() {
        if (this._zIndex) {
            this.renderer.setStyle(this.el, 'z-index', this._zIndex);
        }
        else if (this.zIndexMoving) {
            if (this.oldZIndex) {
                this.renderer.setStyle(this.el, 'z-index', this.oldZIndex);
            }
            else {
                this.el.style.removeProperty('z-index');
            }
        }
        if (this.moving) {
            this.stopped.emit(this.el);
            // Remove the helper div:
            this._helperBlock.remove();
            if (this.needTransform) {
                if (Position.isIPosition(this.position)) {
                    this.oldTrans.set(this.position);
                }
                else {
                    this.oldTrans.reset();
                }
                this.transform();
                this.needTransform = false;
            }
            this.moving = false;
            this.endOffset.emit(this.currTrans.value);
            this.renderer.removeStyle(this.el, 'transform');
            if (this.trackPosition) {
                this.oldTrans.add(this.tempTrans);
                this.movedTrans.add(this.tempTrans);
            }
            this.tempTrans.reset();
            if (!this.trackPosition) {
                this.transform();
            }
            if (this.movedTrans.x + this.tempTrans.x >= this.rightMovedMax && this.movedTrans.x + this.tempTrans.x >= 0) {
                this.movedTrans.x = this.rightMovedMax;
            }
            if (this.movedTrans.x + this.tempTrans.x <= 0 && Math.abs(this.movedTrans.x + this.tempTrans.x) >= this.leftMovedMax) {
                this.movedTrans.x = -this.leftMovedMax;
            }
            /** @type {?} */
            const element = this.el;
            this.renderer.removeClass(element, 'ng-dragging');
            /**
             * Fix performance issue:
             * https://github.com/xieziyu/angular2-draggable/issues/112
             */
            this.unsubscribeEvents();
        }
    }
    /**
     * @private
     * @return {?}
     */
    pickUp() {
        // get old z-index:
        this.oldZIndex = this.el.style.zIndex ? this.el.style.zIndex : '';
        if (window) {
            this.oldZIndex = window.getComputedStyle(this.el, null).getPropertyValue('z-index');
        }
        if (this.zIndexMoving) {
            this.renderer.setStyle(this.el, 'z-index', this.zIndexMoving);
        }
        if (!this.moving) {
            this.started.emit(this.el);
            this.moving = true;
            /** @type {?} */
            const element = this.el;
            this.renderer.addClass(element, 'ng-dragging');
            /**
             * Fix performance issue:
             * https://github.com/xieziyu/angular2-draggable/issues/112
             */
            this.subscribeEvents();
        }
    }
    /**
     * @private
     * @return {?}
     */
    subscribeEvents() {
        this.draggingSub = fromEvent(document, 'mousemove', { passive: false }).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => this.onMouseMove((/** @type {?} */ (event)))));
        this.draggingSub.add(fromEvent(document, 'touchmove', { passive: false }).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        event => this.onMouseMove((/** @type {?} */ (event))))));
        this.draggingSub.add(fromEvent(document, 'mouseup', { passive: false }).subscribe((/**
         * @return {?}
         */
        () => this.putBack())));
        // checking if browser is IE or Edge - https://github.com/xieziyu/angular2-draggable/issues/153
        /** @type {?} */
        let isIEOrEdge = /msie\s|trident\//i.test(window.navigator.userAgent);
        if (!isIEOrEdge) {
            this.draggingSub.add(fromEvent(document, 'mouseleave', { passive: false }).subscribe((/**
             * @return {?}
             */
            () => this.putBack())));
        }
        this.draggingSub.add(fromEvent(document, 'touchend', { passive: false }).subscribe((/**
         * @return {?}
         */
        () => this.putBack())));
        this.draggingSub.add(fromEvent(document, 'touchcancel', { passive: false }).subscribe((/**
         * @return {?}
         */
        () => this.putBack())));
    }
    /**
     * @private
     * @return {?}
     */
    unsubscribeEvents() {
        this.draggingSub.unsubscribe();
        this.draggingSub = null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        // 1. skip right click;
        if (event instanceof MouseEvent && event.button === 2) {
            return;
        }
        // 2. if handle is set, the element can only be moved by handle
        /** @type {?} */
        let target = event.target || event.srcElement;
        // 3. if allow drag is set to false, ignore the mousedown
        if (this.allowDrag === false) {
            return;
        }
        if (this.preventDefaultEvent) {
            event.stopPropagation();
            event.preventDefault();
        }
        this.orignal = Position.fromEvent(event, this.el);
        this.currTrans.reset();
        this.oldTrans.reset();
        this.pickUp();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        if (this.moving && this.allowDrag) {
            if (this.preventDefaultEvent) {
                event.stopPropagation();
                event.preventDefault();
            }
            // Add a transparent helper div:
            this._helperBlock.add();
            this.moveTo(Position.fromEvent(event, this.el));
        }
    }
}
SplitterBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-splitter-bar',
                template: `
    ss
  `,
                host: {
                    'ngDraggable': 'true'
                },
                styles: [`
        :host{
            width: 8px;
            background: #ebebeb;
            cursor: move;
        }
    `]
            }] }
];
/** @nocollapse */
SplitterBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
SplitterBarComponent.propDecorators = {
    klass: [{ type: HostBinding, args: ['class.f-component-splitter-bar',] }],
    zIndexMoving: [{ type: Input }],
    position: [{ type: Input }],
    trackPosition: [{ type: Input }],
    gridSize: [{ type: Input }],
    lockAxis: [{ type: Input }],
    scale: [{ type: Input }],
    started: [{ type: Output }],
    stopped: [{ type: Output }],
    edge: [{ type: Output }],
    endOffset: [{ type: Output }],
    movingOffset: [{ type: Output }],
    onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }, { type: HostListener, args: ['touchstart', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SplitterComponent {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} injector
     * @param {?} renderer
     * @param {?} elementRef
     */
    constructor(componentFactoryResolver, injector, renderer, elementRef) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.splitterCls = true;
        // @HostBinding('class.d-flex') flexCls = true;
        this.orientation = "horizontal";
        this.barComponentRefArray = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        //使用的是ngResizable，没有使用Bar，此处方法可不执行
        this.hostEl = this.elementRef.nativeElement;
        //  this.initPane();
    }
    /**
     * @return {?}
     */
    initPane() {
        if (this.pane && this.pane['_results'] && this.pane['_results'].length) {
            /** @type {?} */
            let hostWidth = this.hostEl.offsetWidth;
            /** @type {?} */
            const length = this.pane['_results'].length;
            /** @type {?} */
            const restPane = this.pane['_results'].filter((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return !item._size;
            }));
            /** @type {?} */
            const restLength = restPane.length;
            this.pane['_results'].forEach((/**
             * @param {?} item
             * @param {?} index
             * @return {?}
             */
            (item, index) => {
                item.order = index * 2;
                if (!!item._size) {
                    hostWidth = hostWidth - this.getElementSize(hostWidth, item._size);
                }
            }));
            restPane.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                item.size = hostWidth / restLength;
            }));
            if (length > 1) {
                this.createBar(length - 1);
            }
            this.listenPaneSizeChange();
        }
    }
    /**
     * @return {?}
     */
    listenPaneSizeChange() {
        /** @type {?} */
        const hostWidth = this.hostEl.offsetWidth;
        this.pane['_results'].forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => {
            item.sizeChange.subscribe((/**
             * @param {?} size
             * @return {?}
             */
            size => {
                /** @type {?} */
                const nextIndex = index + 1;
                /** @type {?} */
                const diff = item.el.offsetWidth - size;
                if (this.pane['_results'][nextIndex]) {
                    /** @type {?} */
                    const nextPaneMin = this.getElementSize(hostWidth, this.pane['_results'][nextIndex].min);
                    if (this.barComponentRefArray[nextIndex]) {
                        // 拖拽向左的最大宽度
                        if (nextPaneMin >= item.el.offsetWidth || nextPaneMin <= 0) {
                            this.barComponentRefArray[nextIndex].instance.leftMovedMax = this.pane['_results'][nextIndex].el.offsetWidth + diff;
                        }
                        else {
                            this.barComponentRefArray[nextIndex].instance.leftMovedMax = this.pane['_results'][nextIndex].el.offsetWidth + diff - nextPaneMin;
                        }
                    }
                }
            }));
        }));
    }
    // 获取目标元素的size
    /**
     * @param {?} hostWidth
     * @param {?} size
     * @return {?}
     */
    getElementSize(hostWidth, size) {
        /** @type {?} */
        let targetSize;
        if (!size) {
            targetSize = 0;
            return targetSize;
        }
        if (size.indexOf('px') !== -1 || typeof size === 'number') {
            targetSize = parseInt(size);
        }
        else if (size.indexOf('%') !== -1) {
            targetSize = hostWidth * parseInt(size) / 100;
        }
        return targetSize;
    }
    /**
     * @param {?} len
     * @return {?}
     */
    createBar(len) {
        /** @type {?} */
        const hostWidth = this.hostEl.offsetWidth;
        for (let i = 0; i < len; i++) {
            /** @type {?} */
            const factory = this.componentFactoryResolver.resolveComponentFactory(SplitterBarComponent);
            /** @type {?} */
            const componentRef = this.container.createComponent(factory);
            /** @type {?} */
            const prevPane = this.pane['_results'][i];
            /** @type {?} */
            const prevPaneOriginWidth = prevPane.el.offsetWidth;
            /** @type {?} */
            const nextPane = this.pane['_results'][i + 1];
            /** @type {?} */
            const nextPaneOriginWidth = nextPane.el.offsetWidth;
            /** @type {?} */
            const prePaneMax = this.getElementSize(hostWidth, this.pane['_results'][i].max);
            /** @type {?} */
            const prePaneMin = this.getElementSize(hostWidth, this.pane['_results'][i].min);
            // 拖拽向右的最大宽度
            if (prePaneMax <= prevPaneOriginWidth && prePaneMax > 0) {
                componentRef.instance.rightMovedMax = 0;
            }
            else if (prePaneMax >= prevPaneOriginWidth + nextPaneOriginWidth || prePaneMax === 0) {
                componentRef.instance.rightMovedMax = nextPaneOriginWidth;
            }
            else {
                componentRef.instance.rightMovedMax = prePaneMax - prevPaneOriginWidth;
            }
            // 拖拽向左的最大宽度
            if (prePaneMin >= prevPaneOriginWidth || prePaneMin <= 0) {
                componentRef.instance.leftMovedMax = prevPaneOriginWidth;
            }
            else {
                componentRef.instance.leftMovedMax = prevPaneOriginWidth - prePaneMin;
            }
            // 横向拖拽还是纵向拖拽
            if (this.orientation === 'horizontal') {
                componentRef.instance.lockAxis = 'y';
            }
            else if (this.orientation === 'vertical') {
                componentRef.instance.lockAxis = 'x';
            }
            componentRef.instance.order = 2 * i + 1;
            // 拖拽变化
            componentRef.instance.endOffset.subscribe((/**
             * @param {?} data
             * @return {?}
             */
            data => {
                prevPane.size = prevPane.el.offsetWidth + data.x;
                nextPane.size = nextPane.el.offsetWidth - data.x;
                // console.log(prevPanelOriginWidth + data.x, nextPanelOriginWidth - data.x)
            }));
            this.barComponentRefArray.push(componentRef);
            componentRef.changeDetectorRef.detectChanges();
        }
    }
}
SplitterComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-splitter',
                template: `
    <ng-content></ng-content>
    <ng-container #container></ng-container>
  `
            }] }
];
/** @nocollapse */
SplitterComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: Renderer2 },
    { type: ElementRef }
];
SplitterComponent.propDecorators = {
    splitterCls: [{ type: HostBinding, args: ['class.f-component-splitter',] }],
    orientation: [{ type: Input }],
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
    pane: [{ type: ContentChildren, args: [SplitterPaneComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SplitterModule {
}
SplitterModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SplitterComponent,
                    SplitterPaneComponent,
                    SplitterBarComponent
                ],
                imports: [
                    CommonModule,
                    AngularDraggableModule,
                    PerfectScrollbarModule
                ],
                exports: [
                    SplitterComponent,
                    SplitterPaneComponent,
                    SplitterBarComponent
                ],
                entryComponents: [
                    SplitterBarComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { SplitterService, SplitterComponent, SplitterPaneComponent, SplitterModule, SplitterBarComponent as ɵa };

//# sourceMappingURL=farris-ui-splitter.js.map