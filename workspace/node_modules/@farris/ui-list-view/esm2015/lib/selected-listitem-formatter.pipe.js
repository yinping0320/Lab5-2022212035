/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ListViewComponent } from './list-view.component';
import { Pipe } from '@angular/core';
export class SelectedListFormatPipe {
    /**
     * @param {?} listViewRef
     */
    constructor(listViewRef) {
        this.listViewRef = listViewRef;
    }
    /**
     * @param {?} data
     * @param {?} formatter
     * @return {?}
     */
    transform(data, formatter) {
        if (data) {
            /** @type {?} */
            const idField = this.listViewRef.listidName;
            if (formatter) {
                data = data.map((/**
                 * @param {?} d
                 * @return {?}
                 */
                d => {
                    return { id: d[idField], text: formatter(d) };
                }));
            }
            else {
                data = data.map((/**
                 * @param {?} d
                 * @return {?}
                 */
                (d) => {
                    /** @type {?} */
                    const txt = [];
                    /** @type {?} */
                    const keys = Object.keys(d);
                    keys.forEach((/**
                     * @param {?} k
                     * @return {?}
                     */
                    k => {
                        txt.push(d[k]);
                    }));
                    return { id: d[idField], text: txt.join(', ') };
                }));
            }
            return data;
        }
        return [];
    }
}
SelectedListFormatPipe.decorators = [
    { type: Pipe, args: [{ name: 'formatItems' },] }
];
/** @nocollapse */
SelectedListFormatPipe.ctorParameters = () => [
    { type: ListViewComponent }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    SelectedListFormatPipe.prototype.listViewRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0ZWQtbGlzdGl0ZW0tZm9ybWF0dGVyLnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL3VpLWxpc3Qtdmlldy8iLCJzb3VyY2VzIjpbImxpYi9zZWxlY3RlZC1saXN0aXRlbS1mb3JtYXR0ZXIucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFHcEQsTUFBTSxPQUFPLHNCQUFzQjs7OztJQUUvQixZQUFxQixXQUE4QjtRQUE5QixnQkFBVyxHQUFYLFdBQVcsQ0FBbUI7SUFBSSxDQUFDOzs7Ozs7SUFFeEQsU0FBUyxDQUFDLElBQVMsRUFBRSxTQUFjO1FBQy9CLElBQUksSUFBSSxFQUFFOztrQkFFQSxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVO1lBRTNDLElBQUksU0FBUyxFQUFFO2dCQUNYLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRzs7OztnQkFBRSxDQUFDLENBQUMsRUFBRTtvQkFDakIsT0FBTyxFQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNsRCxDQUFDLEVBQUMsQ0FBQzthQUNOO2lCQUFPO2dCQUNKLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRzs7OztnQkFBQyxDQUFDLENBQU0sRUFBRSxFQUFFOzswQkFDakIsR0FBRyxHQUFHLEVBQUU7OzBCQUNSLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFDM0IsSUFBSSxDQUFDLE9BQU87Ozs7b0JBQUMsQ0FBQyxDQUFDLEVBQUU7d0JBQ2IsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDbkIsQ0FBQyxFQUFDLENBQUM7b0JBQ0gsT0FBTyxFQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDbkQsQ0FBQyxFQUFDLENBQUM7YUFDTjtZQUVELE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7OztZQTdCSixJQUFJLFNBQUMsRUFBQyxJQUFJLEVBQUUsYUFBYSxFQUFDOzs7O1lBSGxCLGlCQUFpQjs7Ozs7OztJQU1ULDZDQUFzQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpc3RWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi9saXN0LXZpZXcuY29tcG9uZW50JztcclxuaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQFBpcGUoe25hbWU6ICdmb3JtYXRJdGVtcyd9KVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0ZWRMaXN0Rm9ybWF0UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCBwcml2YXRlIGxpc3RWaWV3UmVmOiBMaXN0Vmlld0NvbXBvbmVudCApIHt9XHJcblxyXG4gICAgdHJhbnNmb3JtKGRhdGE6IGFueSwgZm9ybWF0dGVyOiBhbnkpOiBhbnkge1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpZEZpZWxkID0gdGhpcy5saXN0Vmlld1JlZi5saXN0aWROYW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEubWFwKCBkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2lkOiBkW2lkRmllbGRdLCB0ZXh0OiAgZm9ybWF0dGVyKGQpIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlICB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5tYXAoKGQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4dCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkKTtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLmZvckVhY2goayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4dC5wdXNoKGRba10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7aWQ6IGRbaWRGaWVsZF0sIHRleHQ6IHR4dC5qb2luKCcsICcpIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuIl19