import { WindowVariableService, HttpService, LanguageService, SessionService, CacheService } from '@ecp-caf/caf-common';
import { catchError, map, switchMap } from 'rxjs/operators';
import { RouterModule, Router } from '@angular/router';
import { BehaviorSubject, Subscription, Subject, of, zip } from 'rxjs';
import { NgModule, Injectable, Optional, Component, ElementRef, ViewChild, Renderer2, Output, EventEmitter, InjectionToken, ApplicationRef, ComponentFactoryResolver, Injector, defineInjectable } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CommonSharedModule {
}
CommonSharedModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    RouterModule,
                ],
                declarations: [],
                exports: [],
                providers: [],
                entryComponents: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrameworkVariableService {
    constructor() {
        this.frameworkVariable = 'frameworkVariable';
        this.nameSpace = 'variables';
        this.frmVariableName = 'rtfFrmVariable';
        this.windowService = new WindowVariableService();
        this.frmVariableInitial();
    }
    /**
     * @return {?}
     */
    getFrameworkVariable() {
        return this.windowService.getTopWindow()[this.frameworkVariable];
    }
    /**
     * 在框架顶级window注册变量
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    frameworkVariableReg(key, value) {
        /** @type {?} */
        const frmVariable = this.getFrameworkVariable();
        if (frmVariable && frmVariable.name && frmVariable.name === this.frmVariableName) {
            frmVariable[this.nameSpace] = frmVariable[this.nameSpace] || {};
            frmVariable[this.nameSpace][key] = value;
            return;
        }
        this.frmVariableInitial();
        this.getFrameworkVariable()[this.nameSpace][key] = value;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getFrmVariableByKey(key) {
        /** @type {?} */
        const frmVariable = this.getFrameworkVariable();
        if (frmVariable && frmVariable[this.nameSpace] && frmVariable[this.nameSpace][key]) {
            return frmVariable[this.nameSpace][key];
        }
        return null;
    }
    /**
     * 在框架的顶级window上
     * 定义一个公共变量。
     * 用于存放菜单、应用缓存数据，eventbus都公共对象
     * 对适配层提供服务
     * @private
     * @return {?}
     */
    frmVariableInitial() {
        /** @type {?} */
        const topWin = this.windowService.getTopWindow();
        /** @type {?} */
        const name = 'name';
        topWin[this.frameworkVariable] = topWin[this.frameworkVariable] || {};
        topWin[this.frameworkVariable][name] = this.frmVariableName;
        topWin[this.frameworkVariable][this.nameSpace] = topWin[this.frameworkVariable][this.nameSpace] || {};
    }
}
FrameworkVariableService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrameworkVariableService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FuncsService {
    /**
     * @param {?} frmVariableService
     */
    constructor(frmVariableService) {
        this.frmVariableService = frmVariableService;
        this.allgspfuncs = 'allgspfuncs';
        this.allfuncinvoks = 'allfuncinvoks';
        if (!this.frmVariableService) {
            this.frmVariableService = new FrameworkVariableService();
        }
    }
    /**
     * 缓存所有功能
     * @param {?} funcs
     * @return {?}
     */
    cacheAllFuncs(funcs) {
        this.frmVariableService.frameworkVariableReg(this.allgspfuncs, funcs);
    }
    /**
     * 获取所有缓存的功能
     * @return {?}
     */
    getAllCachedFuncs() {
        /** @type {?} */
        const funcsCache = this.frmVariableService.getFrmVariableByKey(this.allgspfuncs);
        return (/** @type {?} */ (funcsCache)) || [];
    }
    /**
     * 获取某功能
     * @param {?} funcId
     * @return {?}
     */
    getCachedFunc(funcId) {
        /** @type {?} */
        const allfuncs = this.getAllCachedFuncs();
        if (allfuncs) {
            return allfuncs.find((/**
             * @param {?} f
             * @return {?}
             */
            f => f.id === funcId));
        }
    }
    /**
     * @param {?} invoks
     * @return {?}
     */
    cacheAllFuncInvoks(invoks) {
        this.frmVariableService.frameworkVariableReg(this.allfuncinvoks, invoks);
    }
    /**
     * @return {?}
     */
    getAllCachedFuncInvoks() {
        /** @type {?} */
        const invokCache = this.frmVariableService.getFrmVariableByKey(this.allfuncinvoks);
        return (/** @type {?} */ (invokCache)) || [];
    }
}
FuncsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FuncsService.ctorParameters = () => [
    { type: FrameworkVariableService, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EventBusPipe {
    /**
     * @param {?} tokenValue
     * @param {?} parentEventPipeList
     * @param {?} sub
     */
    constructor(tokenValue, parentEventPipeList, sub) {
        this.tokenValue = tokenValue;
        this.parentEventPipeList = parentEventPipeList;
        this.eventSubject = sub || new BehaviorSubject(null);
        this.subscription = new Subscription();
        this.onceSubscription = new Subscription();
        this.observers = new Map();
        if (this.parentEventPipeList) {
            this.parentEventPipeList.push(this);
        }
    }
    /**
     * @param {?} bizPara
     * @return {?}
     */
    post(bizPara) {
        this.eventSubject.next(bizPara);
    }
    /**
     * @param {?} eventHandler
     * @return {?}
     */
    subscribe(eventHandler) {
        this.subscription = this.eventSubject.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            eventHandler(value);
        }));
        return this;
    }
    /**
     * @param {?} observerKey
     * @param {?} eventHandler
     * @return {?}
     */
    subscribeWithObkey(observerKey, eventHandler) {
        /** @type {?} */
        const observer = this.observers.get(observerKey);
        if (observer) {
            observer.unsubscribe();
        }
        /** @type {?} */
        const sub = this.eventSubject.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            eventHandler(value);
        }));
        this.observers.set(observerKey, sub);
        return this;
    }
    /**
     * @param {?} eventHandler
     * @return {?}
     */
    subscribeOnce(eventHandler) {
        /** @type {?} */
        const self = this;
        /** @type {?} */
        const scription = this.eventSubject.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            eventHandler(value);
            if (scription) {
                scription.unsubscribe();
            }
            self.parentEventPipeList = new Array();
        }));
        return this;
    }
    /**
     * @return {?}
     */
    unSubscribe() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
    // 注销使用once方法注册的订阅。
    /**
     * @return {?}
     */
    unSubscribeForOnce() {
        this.onceSubscription.unsubscribe();
    }
    /**
     * 取消某观察者的订阅
     * @param {?} observerKey 观察者唯一标识
     * @return {?}
     */
    unSubscribeWithObkey(observerKey) {
        /** @type {?} */
        const scription = this.observers.get(observerKey);
        if (scription) {
            scription.unsubscribe();
        }
    }
    /**
     * @param {?} tokenValue
     * @return {?}
     */
    matchEmitterToken(tokenValue) {
        if (this.tokenValue && tokenValue && this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    }
    /**
     * @param {?} tokenValue
     * @return {?}
     */
    examByTargetToken(tokenValue) {
        if (this.tokenValue !== tokenValue) {
            return false;
        }
        return true;
    }
    /**
     * @param {?} subscriber
     * @return {?}
     */
    dispose(subscriber) {
    }
}
EventBusPipe.decorators = [
    { type: Injectable }
];
/** @nocollapse */
EventBusPipe.ctorParameters = () => [
    { type: String },
    { type: Array },
    { type: Subject }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrmEventBus {
    constructor() {
        this.eventMap = new Map();
    }
    // 发送事件，通知订阅者接收消息。
    /**
     * @param {?} tokenValue
     * @param {?} eventArgs
     * @return {?}
     */
    post(tokenValue, eventArgs) {
        /** @type {?} */
        let eventPipeList = this.eventMap.get(tokenValue);
        if (!eventPipeList) {
            eventPipeList = new Array();
            this.eventMap.set(tokenValue, eventPipeList);
        }
        /** @type {?} */
        let eventPipe = eventPipeList.find((/**
         * @param {?} item
         * @return {?}
         */
        item => item.examByTargetToken(tokenValue)));
        if (!eventPipe) {
            eventPipe = new EventBusPipe(tokenValue, eventPipeList, null);
        }
        for (const eventPipeDetail of eventPipeList) {
            if (eventPipeDetail.matchEmitterToken(tokenValue)) {
                eventPipeDetail.post(eventArgs);
            }
        }
    }
    /**
     * @param {?} token
     * @param {?} sub
     * @return {?}
     */
    initialPipe(token, sub) {
        /** @type {?} */
        let pipes = this.eventMap.get(token);
        if (!pipes) {
            pipes = new Array();
            this.eventMap.set(token, pipes);
        }
        /** @type {?} */
        let eventPipe = pipes.find((/**
         * @param {?} item
         * @return {?}
         */
        item => item.examByTargetToken(token)));
        if (!eventPipe) {
            eventPipe = new EventBusPipe(token, pipes, sub);
        }
    }
    // 订阅事件
    /**
     * @param {?} tokenValue
     * @param {?} handler
     * @return {?}
     */
    on(tokenValue, handler) {
        /** @type {?} */
        const pipe = this.getEventPipe(tokenValue);
        if (pipe) {
            return pipe.subscribe(handler);
        }
    }
    /**
     * 订阅事件，并记录订阅者唯一标识
     * @param {?} tokenValue
     * @param {?} observerKey
     * @param {?} handler
     * @return {?}
     */
    onWithObkey(tokenValue, observerKey, handler) {
        /** @type {?} */
        const pipe = this.getEventPipe(tokenValue);
        if (pipe) {
            return pipe.subscribeWithObkey(observerKey, handler);
        }
    }
    // 订阅一次。接收到一次消息之后自动取消订阅
    /**
     * @param {?} tokenValue
     * @param {?} handler
     * @return {?}
     */
    once(tokenValue, handler) {
        /** @type {?} */
        const pipe = this.getEventPipe(tokenValue);
        if (pipe) {
            /** @type {?} */
            const res = pipe.subscribeOnce(handler);
            this.eventMap.delete(tokenValue);
            return res;
        }
    }
    /**
     * @param {?} tokenValue
     * @return {?}
     */
    unSubscribe(tokenValue) {
        /** @type {?} */
        const pipe = this.getEventPipe(tokenValue);
        if (pipe) {
            pipe.unSubscribe();
        }
    }
    /**
     * @private
     * @param {?} tokenValue
     * @return {?}
     */
    getEventPipe(tokenValue) {
        /** @type {?} */
        const eventPipeList = this.eventMap.get(tokenValue);
        if (!eventPipeList) {
            return null;
        }
        /** @type {?} */
        const eventPipe = eventPipeList.find((/**
         * @param {?} item
         * @return {?}
         */
        item => item.examByTargetToken(tokenValue)));
        return eventPipe;
    }
}
FrmEventBus.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrmEventBus.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable
class LoadingComponent {
    /**
     * @param {?} render
     * @param {?} el
     */
    constructor(render, el) {
        this.render = render;
        this.el = el;
        this._isActive = false;
        this.message = '正在加载，请稍候...';
        this.closed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this._isActive;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set isActive(val) {
        this._isActive = val;
        if (val) {
            this.animate('fadeIn');
        }
        else {
            this.el.nativeElement && this.el.nativeElement.remove();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // setTimeout(() => this.setPosition(), 0 );
        this.setPosition();
    }
    /**
     * @return {?}
     */
    close() {
        this.isActive = false;
    }
    /**
     * @private
     * @return {?}
     */
    setPosition() {
        /** @type {?} */
        const containerWidth = this.loadingContainerEl.nativeElement.clientWidth;
        /** @type {?} */
        const containerHeight = this.loadingContainerEl.nativeElement.clientHeight;
        this.render.setStyle(this.loadingContainerEl.nativeElement, 'marginTop', -containerHeight / 2 + 'px');
        this.render.setStyle(this.loadingContainerEl.nativeElement, 'marginLeft', -containerWidth / 2 + 'px');
    }
    /**
     * @private
     * @param {?} animateCls
     * @return {?}
     */
    animate(animateCls) {
        this.render.setAttribute(this.el.nativeElement, 'class', animateCls);
        this.addAnimationEndEvent('webkitAnimationEnd', 'mozAnimationEnd', 'MSAnimationEnd', 'oanimationend', 'animationend');
    }
    /**
     * @private
     * @param {...?} events
     * @return {?}
     */
    addAnimationEndEvent(...events) {
        /** @type {?} */
        const _this = this;
        events.forEach((/**
         * @param {?} e
         * @return {?}
         */
        e => {
            _this.el.nativeElement.addEventListener(e, (/**
             * @return {?}
             */
            function handler() {
                _this.render.removeAttribute(_this.el.nativeElement, 'class');
                _this.el.nativeElement.removeEventListener(e, handler);
                _this.closed.emit(_this.isActive);
            }));
        }));
    }
}
LoadingComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-loading',
                template: `
        <div #loadingBackdrop class="farris-loading-backdrop" *ngIf="isActive"></div>
        <div #loadingContainerEl class="farris-loading" *ngIf="isActive">
            <div class="ng-busy-default-wrapper">
                <div class="ng-busy-default-sign">
                    <div class="ng-busy-default-spinner">
                        <svg class="circular" viewBox="25 25 50 50">
                            <circle class="path" cx="50" cy="50" r="20" fill="none" stroke-width="2" stroke-miterlimit="10"></circle>
                        </svg>
                    </div>
                </div>
            </div>
        </div>
    `,
                styles: [`
        .circular {
            -webkit-animation: rotate 2s linear infinite;
            animation: rotate 2s linear infinite;
            height: 100%;
            -webkit-transform-origin: center center;
            transform-origin: center center;
            width: 100%;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
        }
        .circular .path {
            stroke-dasharray: 1, 200;
            stroke-dashoffset: 0;
            -webkit-animation: dash 1.5s ease-in-out infinite, color 6s ease-in-out infinite;
            animation: dash 1.5s ease-in-out infinite, color 6s ease-in-out infinite;
            stroke-linecap: round;
        }

        @-webkit-keyframes rotate {
            100% {
            -webkit-transform: rotate(360deg);
                    transform: rotate(360deg);
            }
        }
        @keyframes rotate {
            100% {
            -webkit-transform: rotate(360deg);
                    transform: rotate(360deg);
            }
        }
        @-webkit-keyframes dash {
            0% {
            stroke-dasharray: 1, 200;
            stroke-dashoffset: 0;
            }
            50% {
            stroke-dasharray: 89, 200;
            stroke-dashoffset: -35px;
            }
            100% {
            stroke-dasharray: 89, 200;
            stroke-dashoffset: -124px;
            }
        }
        @keyframes dash {
            0% {
            stroke-dasharray: 1, 200;
            stroke-dashoffset: 0;
            }
            50% {
            stroke-dasharray: 89, 200;
            stroke-dashoffset: -35px;
            }
            100% {
            stroke-dasharray: 89, 200;
            stroke-dashoffset: -124px;
            }
        }
        @-webkit-keyframes color {
            100%,
            0% {
            stroke: #48a7ff;
            }
            40% {
            stroke: #48a7ff;
            }
            66% {
            stroke: #48a7ff;
            }
            80%,
            90% {
            stroke: #48a7ff;
            }
        }
        @keyframes color {
            100%,
            0% {
            stroke: #48a7ff;
            }
            40% {
            stroke: #48a7ff;
            }
            66% {
            stroke: #48a7ff;
            }
            80%,
            90% {
            stroke: #48a7ff;
            }
        }
        .ng-busy-default-spinner {
            width: 126px;height: 126px;
        }
        .ng-busy-default-sign{
            background: transparent;
            box-shadow: none;
        }
        .farris-loading-backdrop {
            background-color: #ffffff;
            opacity: .0;
        }
        `]
            }] }
];
/** @nocollapse */
LoadingComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
LoadingComponent.propDecorators = {
    loadingContainerEl: [{ type: ViewChild, args: ['loadingContainerEl',] }],
    loadingBackdrop: [{ type: ViewChild, args: ['loadingBackdrop',] }],
    closed: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const loaddingDefaultConfig = {
    container: 'body',
    message: '正在加载中，请稍候...',
    posion: 'center'
};
/** @type {?} */
const LOADING_DEFAULT_CONFIG = new InjectionToken('loading default options.');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoadingService {
    /**
     * @param {?} appRef
     * @param {?} cfr
     * @param {?} injecotr
     */
    constructor(appRef, cfr, injecotr) {
        this.appRef = appRef;
        this.cfr = cfr;
        this.injecotr = injecotr;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    show(config) {
        this.removeDomCheck();
        this.config = this.injecotr.get(LOADING_DEFAULT_CONFIG) || {};
        this.config = Object.assign(loaddingDefaultConfig, this.config);
        /** @type {?} */
        const loadingFactory = this.cfr.resolveComponentFactory(LoadingComponent);
        this.loadingCmpRef = loadingFactory.create(this.injecotr);
        if (config) {
            this.config = Object.assign({}, this.config, config);
        }
        /** @type {?} */
        const languageCode = localStorage.getItem('languageCode');
        if (languageCode === 'en') {
            this.config.message = 'Loading...';
        }
        /** @type {?} */
        const container = this.config.container;
        if (container === 'body') {
            document.querySelector((/** @type {?} */ (container))).appendChild(this.loadingCmpRef.location.nativeElement);
        }
        else {
            if (container instanceof ElementRef) {
                container.nativeElement.appendChild(this.loadingCmpRef.location.nativeElement);
            }
        }
        this.loadingCmpRef.instance.isActive = true;
        Object.assign(this.loadingCmpRef.instance, this.config);
        this.loadingCmpRef.instance.closed.subscribe((/**
         * @param {?} state
         * @return {?}
         */
        state => {
            if (!state) {
                this.clearDom(this.loadingCmpRef);
            }
        }));
        this.loadingCmpRef.changeDetectorRef.markForCheck();
        this.loadingCmpRef.changeDetectorRef.detectChanges();
        return this.loadingCmpRef.instance;
    }
    /**
     * @return {?}
     */
    close() {
        if (!!this.loadingCmpRef) {
            this.clearDom(this.loadingCmpRef);
        }
    }
    /**
     * @private
     * @param {?} cmpRef
     * @return {?}
     */
    clearDom(cmpRef) {
        try {
            /** @type {?} */
            const loadingEl = cmpRef.location.nativeElement;
            if (!!loadingEl && loadingEl.parentNode) {
                loadingEl.parentNode.removeChild(loadingEl);
            }
            this.config = this.injecotr.get(LOADING_DEFAULT_CONFIG);
            cmpRef.destroy();
            cmpRef = null;
            setTimeout((/**
             * @return {?}
             */
            () => {
                // 1.5s 后检查是否移除成功
                this.removeDomCheck();
            }), 1500);
        }
        catch (e) {
            console.log(e);
            this.removeDomCheck();
        }
    }
    /**
     * @private
     * @return {?}
     */
    removeDomCheck() {
        try {
            /** @type {?} */
            const el = document.getElementsByTagName('farris-loading')[0];
            if (!!el && !!el.parentNode) {
                el.parentNode.removeChild(el);
            }
        }
        catch (ex) {
            console.log(ex);
        }
    }
}
LoadingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LoadingService.ctorParameters = () => [
    { type: ApplicationRef },
    { type: ComponentFactoryResolver },
    { type: Injector }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IframeLink {
    /**
     * @param {?} code
     * @param {?} sessionid
     * @param {?=} src
     * @param {?=} active
     */
    constructor(code, sessionid, src = '', active = false) {
        this.active = false;
        this.code = code;
        this.src = src;
        this.active = active;
        this.sessionid = sessionid;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrmUtil {
    /**
     * @param {?} bizContextId
     * @param {?} options
     * @return {?}
     */
    static setHeader(bizContextId, options) {
        options.headers = {
            'Content-Type': 'application/json',
        };
        if (bizContextId) {
            /** @type {?} */
            const contextKey = 'X-CAF-Runtime-Context';
            options.headers[contextKey] = bizContextId;
        }
        return options;
    }
    /**
     * @return {?}
     */
    static getTabArray() {
        /** @type {?} */
        const iframeTabArr = 'iframeTabarray';
        /** @type {?} */
        const topWin = this.getTopWindow();
        /** @type {?} */
        let frmWin = window;
        while ((!frmWin[iframeTabArr] || frmWin[iframeTabArr].length === 0) && frmWin !== topWin) {
            frmWin = frmWin.parent;
        }
        return (/** @type {?} */ (frmWin[iframeTabArr])) || [];
    }
    /**
     * @return {?}
     */
    static getTopWindow() {
        /** @type {?} */
        let curWin = window.self;
        try {
            while (curWin.location.origin === curWin.parent.location.origin) {
                if (curWin !== curWin.parent) {
                    curWin = curWin.parent;
                }
                else {
                    break;
                }
            }
        }
        catch (e) { }
        return curWin;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    static removeTab(index) {
        /** @type {?} */
        const iframeArr = this.getTabArray();
        iframeArr.splice(index, 1);
    }
}
class EventUtil {
    /**
     * 获取框架event
     * @return {?}
     */
    static getFrmEvent() {
        /** @type {?} */
        const eventBus = this.frmVariable.getFrmVariableByKey(this.eventBusKey);
        return (/** @type {?} */ (eventBus));
    }
    /**
     * @param {?} feb
     * @return {?}
     */
    static setFrmEvent(feb) {
        this.frmVariable.frameworkVariableReg(this.eventBusKey, feb);
    }
    /**
     * 获取app唯一的观察者标识
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?=} tabId
     * @return {?}
     */
    static appObsToken(appId, appEntrance, tabId) {
        return tabId || `${appId}#${appEntrance}`;
    }
    /**
     * 获取func唯一的观察者标识
     * @param {?} funcId
     * @param {?=} tabId
     * @return {?}
     */
    static funcObsToken(funcId, tabId) {
        return tabId || funcId;
    }
    /**
     * 获取某事件的监听者
     * @param {?} eventToken
     * @return {?}
     */
    static getObserver(eventToken) {
        /** @type {?} */
        const feb = this.getFrmEvent();
        /** @type {?} */
        const eventMap = feb.eventMap.get(eventToken);
        if (!eventMap) {
            return null;
        }
        /** @type {?} */
        let eventPipe;
        for (const eventPipeDetail of eventMap) {
            if (eventPipeDetail.matchEmitterToken(eventToken)) {
                eventPipe = eventPipeDetail;
                break;
            }
        }
        if (!eventPipe) {
            return null;
        }
        /** @type {?} */
        const obs = eventPipe.observers;
        return obs;
    }
    /**
     * 清空监听者
     * @param {?} obKey
     * @return {?}
     */
    static clearObserver(obKey) {
        /** @type {?} */
        const switchObsMap = this.getObserver(this.FUNC_SWITCH);
        /** @type {?} */
        const switchObs = switchObsMap.get(obKey);
        if (switchObs) {
            switchObs.unsubscribe();
            switchObsMap.delete(obKey);
        }
        /** @type {?} */
        const closeObsMap = this.getObserver(this.FUNC_CLOSED);
        /** @type {?} */
        const closeObs = closeObsMap.get(obKey);
        if (closeObs) {
            closeObs.unsubscribe();
            closeObsMap.delete(obKey);
        }
        /** @type {?} */
        const beforeCloseMap = this.getObserver(this.BEFORE_FUNC_CLOSE);
        /** @type {?} */
        const beforeClose = beforeCloseMap.get(obKey);
        if (beforeClose) {
            beforeClose.unsubscribe();
            beforeCloseMap.delete(obKey);
        }
    }
    /**
     * 清空某个管道
     * @param {?} pipeToken
     * @return {?}
     */
    static clearEventPipe(pipeToken) {
        /** @type {?} */
        const feb = this.getFrmEvent();
        /** @type {?} */
        const eventPipes = feb.eventMap.get(pipeToken);
        if (!eventPipes) {
            return;
        }
        /** @type {?} */
        const eventPipe = eventPipes.find((/**
         * @param {?} item
         * @return {?}
         */
        item => item.examByTargetToken(pipeToken)));
        if (eventPipe) {
            eventPipe.unSubscribe();
            feb.eventMap.delete(pipeToken);
        }
    }
}
/**
 * eventToken str
 */
EventUtil.FARRIS_APPS = 'all-gsp-farrisapps';
EventUtil.FARRIS_APP_CLICK = 'farrisapp-click';
EventUtil.ALL_GSP_FUNCS = 'all-gsp-functions';
EventUtil.BEFORE_FUNC_CLOSE = 'beforeFuncCloseEvent';
EventUtil.FUNC_CLOSED = 'FuncClosed';
EventUtil.FUNC_SWITCH = 'funcSwitchEvent';
EventUtil.AFTER_FRAME_LOAD = "after-iframe-load-event";
EventUtil.eventBusKey = 'frmEventBus';
EventUtil.frmVariable = new FrameworkVariableService();
/** @type {?} */
const AppType = {
    App: 'app',
    Menu: 'menu',
    Other: 'other'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrmI18nSettingService {
    /**
     * @param {?} frmVariable
     * @param {?} lanService
     * @param {?} http
     */
    constructor(frmVariable, lanService, http) {
        this.frmVariable = frmVariable;
        this.lanService = lanService;
        this.http = http;
        this.variableKey = 'frm-i18nSetting';
    }
    /**
     * @return {?}
     */
    getSetting() {
        /** @type {?} */
        const temp = this.frmVariable.getFrmVariableByKey(this.variableKey);
        return this.deepClone(temp);
    }
    /**
     * @return {?}
     */
    getSetting$() {
        /** @type {?} */
        const temp = this.frmVariable.getFrmVariableByKey(this.variableKey);
        return !temp ? this.loadSetting$() : of(this.deepClone(temp));
    }
    /**
     * @return {?}
     */
    loadSetting$() {
        /** @type {?} */
        const rtfService = ((/** @type {?} */ (window))).gspframeworkService && ((/** @type {?} */ (window))).gspframeworkService.rtf;
        /** @type {?} */
        const entity = {};
        if (!!rtfService && !!rtfService.language) {
            try {
                /** @type {?} */
                const lanService = rtfService.language;
                lanService.i18nSetting((/**
                 * @param {?} res
                 * @return {?}
                 */
                res => {
                    entity.i18nSetting = res;
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                err => {
                    console.log(err);
                }));
                lanService.allLanguages((/**
                 * @param {?} res
                 * @return {?}
                 */
                res => {
                    entity.languages = res;
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                err => {
                    console.log(err);
                }));
                entity.currentLanCode = lanService.getLanguageCode();
                this.frmVariable.frameworkVariableReg(this.variableKey, entity);
                return of(entity);
            }
            catch (e) {
                console.log(e);
                return of(null);
            }
        }
        else {
            /** @type {?} */
            const languagesUrl = '/api/runtime/sys/v1.0/i18n/languageservice/getalllanguages';
            /** @type {?} */
            const settingUrl = '/api/runtime/sys/v1.0/i18n/i18nusersetting/setting';
            entity.currentLanCode = this.lanService.getLanguageCode();
            return this.http.get(languagesUrl).pipe(map((/**
             * @param {?} res
             * @return {?}
             */
            (res) => entity.languages = res)), switchMap((/**
             * @return {?}
             */
            () => this.http.get(settingUrl))), map((/**
             * @param {?} res
             * @return {?}
             */
            (res) => {
                entity.i18nSetting = res;
                this.frmVariable.frameworkVariableReg(this.variableKey, entity);
                return entity;
            })), catchError((/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                console.log(err);
                return of(null);
            })));
        }
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    deepClone(target) {
        /** @type {?} */
        let result;
        if (typeof target === 'object') {
            if (Array.isArray(target)) {
                result = [];
                for (let i in target) {
                    result.push(this.deepClone(target[i]));
                }
            }
            else if (target === null) {
                result = null;
            }
            else if (target.constructor === RegExp) {
                result = target;
            }
            else {
                result = {};
                for (let i in target) {
                    result[i] = this.deepClone(target[i]);
                }
            }
        }
        else {
            result = target;
        }
        return result;
    }
}
FrmI18nSettingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrmI18nSettingService.ctorParameters = () => [
    { type: FrameworkVariableService },
    { type: LanguageService },
    { type: HttpService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AppService {
    /**
     * @param {?} http
     * @param {?} sessionSvc
     * @param {?} i18nSetting
     */
    constructor(http, sessionSvc, i18nSetting) {
        this.http = http;
        this.sessionSvc = sessionSvc;
        this.i18nSetting = i18nSetting;
        this.FUNCSTATUS_PATH = '/api/runtime/sys/v1.0/function-states';
        this.APPINVOKE_CAHCE_KEY = 'allappinvoks';
        this.frmVariableService = new FrameworkVariableService();
        if (!this.i18nSetting) {
            /** @type {?} */
            const variables = new FrameworkVariableService();
            /** @type {?} */
            const language = new LanguageService(null);
            this.i18nSetting = new FrmI18nSettingService(variables, language, http);
        }
    }
    /**
     * App跳转打开
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?} params
     * @param {?=} reload
     * @return {?}
     */
    openApp(appId, appEntrance, params, reload) {
        /** @type {?} */
        const appOpts = {
            funcId: '',
            appId,
            appEntrance,
            appType: AppType.App,
            entityParams: params,
            queryStringParams: params,
            isReload: reload
        };
        this.openAppByOptions(appOpts);
    }
    /**
     * App跳转打开服务
     * @param {?} options
     * @return {?}
     */
    openAppByOptions(options) {
        /** @type {?} */
        const linkobj = this.checkingRepeatOpen(options);
        if (linkobj) {
            return;
        }
        this.getInvokeAndEnterApp$(options).subscribe((/**
         * @param {?} link
         * @return {?}
         */
        link => {
            this.getFeb().post(EventUtil.FARRIS_APP_CLICK, link);
        }));
    }
    /**
     * 流方式，App跳转打开服务
     * @param {?} options
     * @return {?}
     */
    openAppByOptions$(options) {
        /** @type {?} */
        const linkobj = this.checkingRepeatOpen(options);
        if (linkobj) {
            return of(true);
        }
        return this.getInvokeAndEnterApp$(options).pipe(map((/**
         * @param {?} link
         * @return {?}
         */
        link => {
            this.getFeb().post(EventUtil.FARRIS_APP_CLICK, link);
            return true;
        })));
    }
    /**
     * 获取app调用信息
     * @param {?} appId
     * @return {?}
     */
    getAppInvok(appId) {
        /** @type {?} */
        const invoks = this.getInvokCache();
        /** @type {?} */
        const funcInvok = invoks.find((/**
         * @param {?} f
         * @return {?}
         */
        f => f.id === appId));
        if (!funcInvok) {
            return this.getInvokConfig(appId).pipe(map((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                if (!v) {
                    return null;
                }
                this.refreshInvokCache(invoks, v);
                return v;
            })));
        }
        return of(funcInvok);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    beforeCloseAppByOptions(options) {
        /** @type {?} */
        const appObkey = EventUtil.appObsToken(options.appId, options.appEntrance, options.tabId);
        /** @type {?} */
        const obs = EventUtil.getObserver(EventUtil.BEFORE_FUNC_CLOSE).get(appObkey);
        if (!obs) {
            this.closeAppByOptions(options).subscribe();
            return;
        }
        /** @type {?} */
        const eventArgs = {
            tabId: this.getPageId(options.appId, options.appEntrance, options.tabId),
            appType: AppType.App,
            appId: options.appId,
            appEntrance: options.appEntrance
        };
        this.getFeb().post(EventUtil.BEFORE_FUNC_CLOSE, eventArgs);
    }
    /**
     * App关闭前接口
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?=} tabId
     * @return {?}
     */
    beforeCloseApp(appId, appEntrance, tabId) {
        /** @type {?} */
        const self = this;
        /** @type {?} */
        const appObkey = EventUtil.appObsToken(appId, appEntrance, tabId);
        /** @type {?} */
        const obs = EventUtil.getObserver(EventUtil.BEFORE_FUNC_CLOSE).get(appObkey);
        if (!obs) {
            this.closeApp(appId, appEntrance, tabId).subscribe();
            return;
        }
        /** @type {?} */
        const eventArgs = {
            tabId: self.getPageId(appId, appEntrance, tabId),
            appType: AppType.App,
            appId,
            appEntrance
        };
        this.getFeb().post(EventUtil.BEFORE_FUNC_CLOSE, eventArgs);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    closeAppByOptions(options) {
        /** @type {?} */
        const appObkey = EventUtil.appObsToken(options.appId, options.appEntrance, options.tabId);
        /** @type {?} */
        const pageToken = this.getPageId(options.appId, options.appEntrance, options.tabId);
        EventUtil.clearObserver(appObkey);
        EventUtil.clearEventPipe(pageToken);
        /** @type {?} */
        const objIndex = FrmUtil.getTabArray().findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i.id === pageToken && i.appType === AppType.App));
        /** @type {?} */
        const obj = FrmUtil.getTabArray()[objIndex];
        options.token = options.token || obj.formToken;
        FrmUtil.removeTab(objIndex);
        /** @type {?} */
        const eventArgs = {
            tabId: pageToken,
            appType: AppType.App,
            appId: options.tabId,
            appEntrance: options.appEntrance
        };
        this.getFeb().post(EventUtil.FUNC_CLOSED, eventArgs);
        return this.quitApp(options, obj.su);
    }
    /**
     * 关闭app
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?=} tabId
     * @return {?}
     */
    closeApp(appId, appEntrance, tabId) {
        /** @type {?} */
        const self = this;
        /** @type {?} */
        const appObkey = EventUtil.appObsToken(appId, appEntrance, tabId);
        /** @type {?} */
        const pageId = this.getPageId(appId, appEntrance, tabId);
        EventUtil.clearObserver(appObkey);
        EventUtil.clearEventPipe(pageId);
        /** @type {?} */
        const objIndex = FrmUtil.getTabArray().findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i.id === pageId && i.appType === AppType.App));
        /** @type {?} */
        const obj = FrmUtil.getTabArray()[objIndex];
        /** @type {?} */
        const formToken = obj.formToken;
        FrmUtil.removeTab(objIndex);
        /** @type {?} */
        const eventArgs = {
            tabId: pageId,
            appType: AppType.App,
            appId,
            appEntrance,
        };
        self.getFeb().post(EventUtil.FUNC_CLOSED, eventArgs);
        /** @type {?} */
        const options = {
            tabId,
            funcId: '',
            appId,
            appEntrance,
            appType: AppType.App,
            token: formToken
        };
        return this.quitApp(options, obj.su).pipe(map((/**
         * @param {?} v
         * @return {?}
         */
        v => { })));
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    getInvokeAndEnterApp$(options) {
        /** @type {?} */
        const newPageId = this.newPageId(options.appId, options.appEntrance, options.tabId);
        options.tabId = newPageId;
        return this.getAppInvok(options.appId).pipe(switchMap((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            /** @type {?} */
            let invokEntry = value.appInvoks.find((/**
             * @param {?} invok
             * @return {?}
             */
            invok => invok.appEntrance === options.appEntrance));
            if (!options.appEntrance && !invokEntry) {
                invokEntry = value.appInvoks.find((/**
                 * @param {?} invok
                 * @return {?}
                 */
                invok => !invok.appEntrance));
            }
            if (!invokEntry) {
                window.alert(`请检查当前应用(ID:${options.appId})配置的应用入口(appEntrance:${options.appEntrance})是否存在`);
                return;
            }
            /** @type {?} */
            let entityParam;
            try {
                entityParam = invokEntry.entityParams ? JSON.parse(invokEntry.entityParams) : null;
            }
            catch (e) {
                entityParam = null;
                console.log(e);
            }
            /** @type {?} */
            const su = this.getSu(value.url);
            return this.enterApp({
                tabId: newPageId,
                appId: options.appId,
                appEntrance: options.appEntrance,
                menuName: options.tabName || invokEntry.name,
                action: 'enterapp'
            }, su).pipe(map((/**
             * @param {?} token
             * @return {?}
             */
            token => {
                /** @type {?} */
                const routurl = value.url + (options.appEntrance ? `#/${options.appEntrance}` : '');
                /** @type {?} */
                const linkobj = new IframeLink(value.code, null, this.buildQueryString(routurl, options.appId, options.appEntrance, options.tabId, token, options.queryStringParams));
                // id加入口区分,tabId页签唯一标识
                linkobj.id = newPageId;
                linkobj.appType = AppType.App;
                linkobj.appId = options.appId;
                linkobj.appEntrance = options.appEntrance;
                // 显示app名字及入口名字
                linkobj.FuncName = options.tabName || invokEntry.name;
                linkobj.url = value.url;
                linkobj.reload = options.isReload;
                linkobj.su = su;
                linkobj.formToken = token;
                if (entityParam) {
                    entityParam.forEach((/**
                     * @param {?} item
                     * @return {?}
                     */
                    item => {
                        if (item.name === 'mode') {
                            linkobj.mode = item.value;
                            linkobj.src += (item.value ? `&appMode=${item.value}&` : '');
                        }
                    }));
                }
                this.getFeb().post(newPageId, options.entityParams);
                return linkobj;
            })), switchMap((/**
             * @param {?} formLink
             * @return {?}
             */
            formLink => {
                return this.i18nSetting.getSetting$().pipe(map((/**
                 * @return {?}
                 */
                () => formLink)));
            })));
        })));
    }
    /**
     * @private
     * @param {?} appId
     * @return {?}
     */
    getInvokConfig(appId) {
        /** @type {?} */
        const url = `/api/runtime/sys/v1.0/gspapp/${appId}`;
        return this.http.request('Get', url, FrmUtil.setHeader(null, {}));
    }
    /**
     * 进入应用，触发相关服务
     * @private
     * @param {?} enterParam
     * @param {?} su
     * @return {?}
     */
    enterApp(enterParam, su) {
        /** @type {?} */
        const bizContextUrl = this.FUNCSTATUS_PATH + (!su ? '' : `?su=${su}`);
        return this.http.request('Post', bizContextUrl, FrmUtil.setHeader(null, { body: enterParam })).pipe(map((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            return v.token || v.sessionId;
        })));
    }
    /**
     * 退出应用，触发相关服务
     * @private
     * @param {?} options
     * @param {?=} su
     * @return {?}
     */
    quitApp(options, su) {
        /** @type {?} */
        const body = {
            tabId: options.tabId,
            token: options.token,
            appId: options.appId,
            appEntrance: options.appEntrance,
            action: 'quitapp'
        };
        /** @type {?} */
        const invokObs = this.getAppInvok(options.appId);
        /** @type {?} */
        const bizContextUrl = this.FUNCSTATUS_PATH + (!su ? '' : `?su=${su}`);
        /** @type {?} */
        const funcState$ = this.http.request('Post', bizContextUrl, FrmUtil.setHeader(null, { body }));
        // tslint:disable-next-line: deprecation
        /** @type {?} */
        const $r = zip(invokObs, funcState$, (/**
         * @param {?} res1
         * @param {?} res2
         * @return {?}
         */
        (res1, res2) => ({ res1, res2 })));
        return $r;
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    getSu(url) {
        /** @type {?} */
        const uriArr = url.split('/');
        return uriArr.length > 3 ? uriArr[3] : '';
    }
    /**
     * @private
     * @return {?}
     */
    getInvokCache() {
        /** @type {?} */
        const appInvokesCache = this.frmVariableService.getFrmVariableByKey(this.APPINVOKE_CAHCE_KEY);
        return (/** @type {?} */ (appInvokesCache)) || [];
    }
    /**
     * @private
     * @param {?} invoks
     * @param {?} funcInvok
     * @return {?}
     */
    refreshInvokCache(invoks, funcInvok) {
        if (!funcInvok) {
            return;
        }
        invoks.push(funcInvok);
        this.frmVariableService.frameworkVariableReg(this.APPINVOKE_CAHCE_KEY, invoks);
    }
    // tslint:disable-next-line: max-line-length
    /**
     * @private
     * @param {?} routurl
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?} tabId
     * @param {?} token
     * @param {?} params
     * @return {?}
     */
    buildQueryString(routurl, appId, appEntrance, tabId, token, params) {
        if (routurl.indexOf('?') < 0) {
            routurl += `?appId=${appId}&appEntrance=${appEntrance}`;
        }
        else {
            routurl += `&appId=${appId}&appEntrance=${appEntrance}`;
        }
        routurl += `&appType=${AppType.App}`;
        routurl += `&tabId=${this.getPageId(appId, appEntrance, tabId)}`;
        routurl += !token ? '' : `&cvft=${token}`;
        if (params) {
            params.forEach((/**
             * @param {?} value
             * @param {?} key
             * @return {?}
             */
            (value, key) => {
                routurl += !key ? '' : `&${key}=${value}`;
            }));
        }
        return routurl;
    }
    /**
     * @private
     * @return {?}
     */
    getFeb() {
        return EventUtil.getFrmEvent();
    }
    /**
     * @private
     * @param {?} appId
     * @param {?} appEntrance
     * @return {?}
     */
    mergeAppId(appId, appEntrance) {
        return `${appId}_${appEntrance}`;
    }
    /**
     * 获取当前菜单页面的唯一标识
     * @private
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?} tabId
     * @return {?}
     */
    getPageId(appId, appEntrance, tabId) {
        return tabId || this.mergeAppId(appId, appEntrance);
    }
    /**
     * 生成页面唯一标识
     * @private
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?} tabId
     * @return {?}
     */
    newPageId(appId, appEntrance, tabId) {
        return tabId ? `${this.mergeAppId(appId, appEntrance)}_${tabId}` : this.mergeAppId(appId, appEntrance);
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    checkingRepeatOpen(options) {
        /** @type {?} */
        const appId = options.appId;
        /** @type {?} */
        const appEntrance = options.appEntrance;
        /** @type {?} */
        const tabId = options.tabId;
        /** @type {?} */
        const entityParams = options.entityParams;
        /** @type {?} */
        let linkobj;
        /** @type {?} */
        const pageId = this.getPageId(appId, appEntrance, tabId);
        linkobj = FrmUtil.getTabArray().find((/**
         * @param {?} i
         * @return {?}
         */
        i => i.id === pageId && i.appType === AppType.App));
        if (linkobj) {
            linkobj.FuncName = options.tabName || linkobj.FuncName;
            linkobj.src = this.buildQueryString(linkobj.url, appId, appEntrance, options.tabId, linkobj.sessionid, options.queryStringParams);
            linkobj.reload = options.isReload;
            this.getFeb().post(pageId, entityParams);
            this.getFeb().post(EventUtil.FARRIS_APP_CLICK, linkobj);
        }
        return linkobj;
    }
}
AppService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AppService.ctorParameters = () => [
    { type: HttpService },
    { type: SessionService },
    { type: FrmI18nSettingService, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrameworkService {
    /**
     * @param {?} http
     * @param {?} router
     * @param {?} cache
     * @param {?} sessionSvc
     * @param {?} feb
     * @param {?} funcService
     * @param {?} loadService
     * @param {?} appService
     * @param {?} i18nSetting
     */
    constructor(http, router, cache, sessionSvc, feb, funcService, loadService, appService, i18nSetting) {
        this.http = http;
        this.router = router;
        this.cache = cache;
        this.sessionSvc = sessionSvc;
        this.feb = feb;
        this.funcService = funcService;
        this.loadService = loadService;
        this.appService = appService;
        this.i18nSetting = i18nSetting;
        this.FUNCSTATUS_PATH = '/api/runtime/sys/v1.0/function-states';
        this.BeforeFuncClose = EventUtil.BEFORE_FUNC_CLOSE;
        this.FuncClosed = EventUtil.FUNC_CLOSED;
        this.FuncSwitch = EventUtil.FUNC_SWITCH;
        if (!this.i18nSetting) {
            /** @type {?} */
            const variables = new FrameworkVariableService();
            /** @type {?} */
            const language = new LanguageService(null);
            this.i18nSetting = new FrmI18nSettingService(variables, language, http);
        }
        if (!this.appService) {
            this.appService = new AppService(this.http, this.sessionSvc, this.i18nSetting);
        }
    }
    /**
     * 根据funcid打开功能菜单
     * (适用于单页签路由，不支持NG7升级后菜单之间跳转)
     * @param {?} funcid
     * @param {?} routepath
     * @param {?} parentsessionid
     * @param {?=} newsession
     * @param {?=} simpleparam
     * @return {?}
     */
    openFunc(funcid, routepath, parentsessionid, newsession = true, simpleparam = '') {
        /** @type {?} */
        const appOps = {
            appType: AppType.Menu,
            funcId: funcid,
            appId: '',
            appEntrance: ''
        };
        this.internalOpen(appOps);
        return of(true);
        // return this.internalOpen$(appOps);
    }
    /**
     * 直接打开功能
     * @param {?} options
     * @return {?}
     */
    openMenu(options) {
        switch (options.appType && options.appType.toLowerCase()) {
            case AppType.App:
                if (!options.appId) {
                    window.alert('参数appId不能为空！');
                    return;
                }
                this.appService.openAppByOptions(options);
                break;
            case AppType.Menu:
                this.internalOpen(options);
                break;
            case AppType.Other: break;
        }
    }
    /**
     * 通过流方式打开功能
     * @param {?} options
     * @return {?}
     */
    openMenu$(options) {
        switch (options.appType && options.appType.toLowerCase()) {
            case AppType.App:
                if (!options.appId) {
                    window.alert('参数appId不能为空！');
                    return;
                }
                return this.appService.openAppByOptions$(options);
            case AppType.Menu:
                if (options.onlyGetIframeLink === true) {
                    return this.internalOpenByIframeLink$(options);
                }
                return this.internalOpen$(options);
            case AppType.Other: break;
        }
    }
    /**
     * 打开联查菜单
     * @param {?} funcId
     * @param {?} options
     * @return {?}
     */
    openConnectedFunc(funcId, options) {
        /** @type {?} */
        const appOps = {
            appType: AppType.Menu,
            funcId,
            appId: '',
            appEntrance: '',
            entityParams: options.EntityParam,
        };
        this.internalOpen(appOps);
    }
    /**
     * 打开联查菜单，并传参
     * @param {?} funcId
     * @param {?} params
     * @param {?=} reload
     * @return {?}
     */
    openFuncWithParam(funcId, params, reload) {
        /** @type {?} */
        const options = {
            appType: AppType.Menu,
            funcId,
            appId: '',
            appEntrance: '',
            entityParams: params,
            queryStringParams: params,
            isReload: reload
        };
        this.internalOpen(options);
    }
    /**
     * 打开功能，不返回流
     * @private
     * @param {?} options
     * @return {?}
     */
    internalOpen(options) {
        this.checkingBeforeOpen$(options)
            .subscribe((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            if (!res || !res.func || res.linkobj) {
                return;
            }
            /** @type {?} */
            const func = res.func;
            this.getInvokeAndEnterFunc$(options, func).subscribe((/**
             * @param {?} lobj
             * @return {?}
             */
            (lobj) => this.getFeb().post(EventUtil.FARRIS_APP_CLICK, lobj)), (/**
             * @param {?} err
             * @return {?}
             */
            err => {
                /** @type {?} */
                const info = {
                    isErr: true,
                    errInfo: err
                };
                this.getFeb().post(EventUtil.FARRIS_APP_CLICK, info);
            }));
        }));
    }
    /**
     * 通过串流控制，打开菜单
     * @private
     * @param {?} options
     * @return {?}
     */
    internalOpen$(options) {
        return this.checkingBeforeOpen$(options)
            .pipe(switchMap((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            if (!res || !res.func || res.linkobj) {
                return of(null);
            }
            /** @type {?} */
            const func = res.func;
            return this.getInvokeAndEnterFunc$(options, func).pipe(map((/**
             * @param {?} lobj
             * @return {?}
             */
            (lobj) => {
                this.getFeb().post(EventUtil.FARRIS_APP_CLICK, lobj);
                return true;
            })));
        })));
    }
    /**
     * 通过串流获取被打开菜单的iframeLink对象信息
     * @private
     * @param {?} options
     * @return {?}
     */
    internalOpenByIframeLink$(options) {
        if (!options.funcId) {
            window.alert('参数funcId不能为空！');
            return of(null);
        }
        return this.getFuncEntity(options.funcId).pipe(switchMap((/**
         * @param {?} func
         * @return {?}
         */
        func => {
            if (!func) {
                window.alert(`请确认您是否具备打开菜单(ID:${options.funcId})的权限`);
                return null;
            }
            return this.getInvokeAndEnterFunc$(options, func);
        })));
    }
    /**
     * @private
     * @param {?} options
     * @param {?} func
     * @return {?}
     */
    getInvokeAndEnterFunc$(options, func) {
        /** @type {?} */
        const newPageId = this.newPageId(options.funcId, options.tabId);
        options.tabId = newPageId;
        /** @type {?} */
        let linkobj;
        return this.getFuncInvok(options.funcId).pipe(switchMap((/**
         * @param {?} funcInvok
         * @return {?}
         */
        funcInvok => {
            /** @type {?} */
            const routurl = funcInvok.invokingConfig.url;
            /** @type {?} */
            const paramInfo = funcInvok.invokingConfig.staticParams;
            /** @type {?} */
            const entityParamInfo = funcInvok.invokingConfig.entityParams;
            /** @type {?} */
            const staticParam = paramInfo ? JSON.parse(paramInfo) : '';
            /** @type {?} */
            const entityParam = entityParamInfo ? JSON.parse(entityParamInfo) : '';
            /** @type {?} */
            const su = this.getSu(routurl);
            return this.enterFunc({
                tabId: newPageId,
                funcId: options.funcId,
                menuName: options.tabName || func.name,
                action: 'enter'
            }, su).pipe(map((/**
             * @param {?} formToken
             * @return {?}
             */
            formToken => {
                linkobj = new IframeLink(func.code, null, this.buildQueryStringByMap(routurl, options.funcId, options.tabId, formToken, options.queryStringParams));
                linkobj.id = newPageId; // 页面唯一标识 允许页面重复打开
                linkobj.appType = AppType.Menu;
                linkobj.funcId = options.funcId;
                linkobj.FuncName = options.tabName || func.name;
                linkobj.url = funcInvok.invokingConfig.url;
                linkobj.reload = options.isReload;
                linkobj.su = su;
                linkobj.isNewTab = options.isNewTab;
                linkobj.formToken = formToken;
                if (staticParam) {
                    // dky特殊场景，打开jquery原生功能
                    staticParam.forEach((/**
                     * @param {?} item
                     * @return {?}
                     */
                    item => {
                        if (item.name === 'jquery') {
                            linkobj.isjquery = true;
                        }
                        if (item.name === 'mode') {
                            linkobj.mode = item.value;
                            linkobj.src += (item.value ? `&appMode=${item.value}&` : '');
                        }
                    }));
                }
                // 大对象实体传参，针对被打开页面建立唯一管道
                this.getFeb().post(newPageId, options.entityParams);
                // this.getFeb().post(EventUtil.FARRIS_APP_CLICK, linkobj);
                return linkobj;
            })), switchMap((/**
             * @param {?} formLink
             * @return {?}
             */
            formLink => {
                return this.i18nSetting.getSetting$().pipe(map((/**
                 * @return {?}
                 */
                () => formLink)));
            })));
        })));
    }
    /**
     * 流方式检查菜单打开状态
     * @private
     * @param {?} options
     * @return {?}
     */
    checkingBeforeOpen$(options) {
        if (!options.funcId) {
            window.alert('参数funcId不能为空！');
            return of(null);
        }
        return this.getFuncEntity(options.funcId).pipe(map((/**
         * @param {?} func
         * @return {?}
         */
        func => {
            if (!func) {
                window.alert(`请确认您是否具备打开菜单(ID:${options.funcId})的权限`);
                return null;
            }
            /** @type {?} */
            const funcId = options.funcId;
            /** @type {?} */
            const tabId = options.tabId;
            /** @type {?} */
            const pageId = this.getPageId(funcId, tabId);
            /** @type {?} */
            const linkobj = FrmUtil.getTabArray().find((/**
             * @param {?} i
             * @return {?}
             */
            i => i.id === pageId && i.appType === AppType.Menu));
            if (linkobj) {
                linkobj.FuncName = options.tabName || linkobj.FuncName;
                linkobj.src = this.buildQueryStringByMap(linkobj.url, funcId, options.tabId, '', options.queryStringParams);
                linkobj.reload = options.isReload; // 界面刷新不改session
                this.getFeb().post(pageId, options.entityParams);
                this.getFeb().post(EventUtil.FARRIS_APP_CLICK, linkobj);
            }
            return { func, linkobj };
        })));
    }
    /**
     * 关闭前
     * @param {?} options
     * @return {?}
     */
    beforeCloseMenu(options) {
        switch (options.appType && options.appType.toLowerCase()) {
            case AppType.App:
                this.appService.beforeCloseAppByOptions(options);
                break;
            case AppType.Menu:
                this.beforeCloseFuncByOptions(options);
                break;
            default: break;
        }
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    beforeCloseFuncByOptions(options) {
        /** @type {?} */
        const func = this.funcService.getCachedFunc(options.funcId);
        /** @type {?} */
        const funcObkey = EventUtil.funcObsToken(options.funcId, options.tabId);
        /** @type {?} */
        const pageId = this.getPageId(options.funcId, options.tabId);
        /** @type {?} */
        const obs = EventUtil.getObserver(EventUtil.BEFORE_FUNC_CLOSE).get(funcObkey);
        if (!obs) {
            this.closeFuncByOptions(options);
            return;
        }
        /** @type {?} */
        const eventArgs = {
            tabId: pageId,
            appType: AppType.Menu,
            funcId: options.funcId,
            tabName: func && func.Name,
            beforeCloseHandle: options.beforeCloseHandle
        };
        this.getFeb().post(EventUtil.BEFORE_FUNC_CLOSE, eventArgs);
    }
    /**
     * 菜单关闭前事件触发(无 token)
     * @param {?} funcId
     * @param {?=} tabId
     * @return {?}
     */
    beforeCloseFunc(funcId, tabId) {
        /** @type {?} */
        const func = this.funcService.getCachedFunc(funcId);
        /** @type {?} */
        const funcObkey = EventUtil.funcObsToken(funcId, tabId);
        /** @type {?} */
        const obs = EventUtil.getObserver(EventUtil.BEFORE_FUNC_CLOSE).get(funcObkey);
        if (!obs) {
            this.closeFunc(funcId, tabId);
            return;
        }
        /** @type {?} */
        const eventArgs = {
            tabId: this.getPageId(funcId, tabId),
            appType: AppType.Menu,
            funcId,
            tabName: func && func.Name
        };
        this.getFeb().post(EventUtil.BEFORE_FUNC_CLOSE, eventArgs);
    }
    /**
     * 直接关闭
     *
     * @param {?} options
     * @return {?}
     */
    closeMenu(options) {
        switch (options.appType && options.appType.toLowerCase()) {
            case AppType.App:
                this.appService.closeAppByOptions(options).subscribe();
                break;
            case AppType.Menu:
                this.closeFuncByOptions(options);
                break;
            default: break;
        }
    }
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    closeFuncByOptions(options) {
        /** @type {?} */
        const pageId = this.getPageId(options.funcId, options.tabId);
        EventUtil.clearObserver(EventUtil.funcObsToken(options.funcId, options.tabId));
        EventUtil.clearEventPipe(pageId); // 当前页面大对象传参会有唯一的管道
        // 当前页面大对象传参会有唯一的管道
        /** @type {?} */
        const func = this.funcService.getCachedFunc(options.funcId);
        /** @type {?} */
        const objIndex = FrmUtil.getTabArray().findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i.id === pageId && i.appType === AppType.Menu));
        /** @type {?} */
        const obj = FrmUtil.getTabArray()[objIndex];
        options.token = options.token || obj.formToken;
        /** @type {?} */
        let su = options.su;
        if (obj) {
            su = obj.su;
            FrmUtil.removeTab(objIndex);
            /** @type {?} */
            const eventArgs = {
                tabId: pageId,
                appType: AppType.Menu,
                funcId: options.funcId,
                tabName: func && func.name
            };
            this.getFeb().post(EventUtil.FUNC_CLOSED, eventArgs);
        }
        this.quitFunc(options, su)
            .subscribe((/**
         * @return {?}
         */
        () => { }));
    }
    /**
     * 关闭菜单tab页签，tabId可以指定，默认为funcId
     * @param {?} funcId
     * @param {?=} tabId
     * @return {?}
     */
    closeFunc(funcId, tabId) {
        /** @type {?} */
        const self = this;
        /** @type {?} */
        const pageId = this.getPageId(funcId, tabId);
        EventUtil.clearObserver(EventUtil.funcObsToken(funcId, tabId));
        EventUtil.clearEventPipe(pageId); // 当前页面大对象传参会有唯一的管道
        // 当前页面大对象传参会有唯一的管道
        /** @type {?} */
        const func = this.funcService.getCachedFunc(funcId);
        /** @type {?} */
        const objIndex = FrmUtil.getTabArray().findIndex((/**
         * @param {?} i
         * @return {?}
         */
        i => i.id === pageId && i.appType === AppType.Menu));
        /** @type {?} */
        const obj = FrmUtil.getTabArray()[objIndex];
        /** @type {?} */
        const formToken = obj.formToken;
        if (obj) {
            FrmUtil.removeTab(objIndex);
            /** @type {?} */
            const eventArgs = {
                tabId: pageId,
                appType: AppType.Menu,
                funcId,
                tabName: func && func.name
            };
            self.getFeb().post(EventUtil.FUNC_CLOSED, eventArgs);
        }
        /** @type {?} */
        const options = {
            tabId,
            funcId,
            appId: '',
            appEntrance: '',
            appType: AppType.Menu,
            token: formToken,
        };
        this.quitFunc(options, obj.su)
            .subscribe((/**
         * @return {?}
         */
        () => { }));
        return of(true);
    }
    /**
     * 获取菜单的调用信息
     * @param {?} funcId
     * @return {?}
     */
    getFuncInvok(funcId) {
        /** @type {?} */
        const invoks = this.getInvokCache();
        /** @type {?} */
        const funcInvok = invoks.find((/**
         * @param {?} f
         * @return {?}
         */
        f => f.id === funcId));
        if (!funcInvok) {
            return this.getInvokConfig(funcId).pipe(map((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                if (!v) {
                    return null;
                }
                invoks.push(v);
                this.funcService.cacheAllFuncInvoks(invoks);
                return v;
            })));
        }
        return of(funcInvok);
    }
    /**
     * 获取菜单实体
     * @param {?} funcId
     * @return {?}
     */
    getFuncEntity(funcId) {
        /** @type {?} */
        const func = this.funcService.getCachedFunc(funcId);
        if (!func) {
            /** @type {?} */
            const url = `/api/runtime/sys/v1.0/functions/${funcId}`;
            return this.http.request('Get', url, FrmUtil.setHeader(null, {}))
                .pipe(map((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                if (!v || !v[0]) {
                    return null;
                }
                /** @type {?} */
                const allFuncs = (/** @type {?} */ (this.funcService.getAllCachedFuncs()));
                allFuncs.push(v[0]);
                this.funcService.cacheAllFuncs(allFuncs);
                return v[0];
            })));
        }
        return of(func);
    }
    /**
     * 获取菜单预置参数
     * @param {?} funcId
     * @return {?}
     */
    getPresetParams(funcId) {
        return this.getFuncInvok(funcId).pipe(map((/**
         * @param {?} funcInvok
         * @return {?}
         */
        funcInvok => {
            /** @type {?} */
            const paramInfo = funcInvok.invokingConfig.staticParams;
            /** @type {?} */
            const entityParamInfo = funcInvok.invokingConfig.entityParams;
            /** @type {?} */
            const staticParam = paramInfo ? JSON.parse(paramInfo) : [];
            /** @type {?} */
            const entityParam = entityParamInfo ? JSON.parse(entityParamInfo) : [];
            return this.mergeParams(staticParam, entityParam);
        })));
    }
    /**
     * 获取菜单的静态参数
     * @param {?} funcId
     * @return {?}
     */
    getStaticParam(funcId) {
        return this.getFuncInvok(funcId).pipe(map((/**
         * @param {?} v
         * @return {?}
         */
        v => {
            if (v.invokingConfig.staticParams) {
                return JSON.parse(v.invokingConfig.staticParams);
            }
        })));
    }
    /**
     * 获取表单的实体参数
     * @param {?} tabId
     * @param {?} handler
     * @param {?=} isSubonce
     * @return {?}
     */
    getEntityParam(tabId, handler, isSubonce = true) {
        if (isSubonce) {
            this.getFeb().once(tabId, handler);
        }
        this.getFeb().on(tabId, handler);
    }
    /**
     * @param {?} funcId
     * @return {?}
     */
    entityParamUnsub(funcId) {
        this.getFeb().unSubscribe(funcId);
    }
    /**
     * 获取某菜单的实体参数结构
     * @param {?} funcId
     * @return {?}
     */
    getEntityParamStructure(funcId) {
        return this.getFuncInvok(funcId).pipe(map((/**
         * @param {?} v
         * @return {?}
         */
        v => {
            if (v.invokingConfig.entityParams) {
                return JSON.parse(v.invokingConfig.entityParams);
            }
        })));
    }
    /**
     * @private
     * @param {?} staticParam
     * @param {?} entityParam
     * @return {?}
     */
    mergeParams(staticParam, entityParam) {
        /** @type {?} */
        const paraMap = new Map();
        if (entityParam) {
            entityParam.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                paraMap.set(item.name, item.value);
            }));
        }
        if (staticParam) {
            // func上对app参数复用
            staticParam.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                paraMap.set(item.name, item.value);
            }));
        }
        return paraMap;
    }
    /**
     * @private
     * @param {?} funcId
     * @return {?}
     */
    getInvokConfig(funcId) {
        /** @type {?} */
        const url = `/api/runtime/sys/v1.0/functions/funcInvok/${funcId}`;
        return this.http.request('Get', url, FrmUtil.setHeader(null, {}));
    }
    /**
     * @private
     * @return {?}
     */
    getInvokCache() {
        return this.funcService.getAllCachedFuncInvoks();
    }
    /**
     * 获取框架eventbus
     * @private
     * @return {?}
     */
    getFeb() {
        return EventUtil.getFrmEvent();
    }
    /**
     * 构造功能及session
     * (1912 funcSession移除后，接口不再提供)
     * @param {?} funcId
     * @param {?=} su
     * @return {?}
     */
    buildFuncSession(funcId, su) {
        /** @type {?} */
        const self = this;
        /** @type {?} */
        const userSession = this.sessionSvc.getUserSessionId();
        /** @type {?} */
        const body = {
            token: userSession,
            funcId,
            action: 'enter'
        };
        /** @type {?} */
        const bizContextUrl = this.FUNCSTATUS_PATH + (!su ? '' : `?su=${su}`);
        return this.http.request('Post', bizContextUrl, FrmUtil.setHeader(userSession, { body })).pipe(map((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            /** @type {?} */
            const ss = v.sessionId;
            if (ss !== undefined && ss !== null && ss.length > 0) {
                self.sessionSvc.setFuncSessionId(funcId, ss);
            }
            return ss;
        })));
    }
    /**
     * 进入功能，触发服务端逻辑
     * 移除funcSession
     * 返回公共变量token
     * @private
     * @param {?} enterParam
     * @param {?} su
     * @return {?}
     */
    enterFunc(enterParam, su) {
        /** @type {?} */
        const bizContextUrl = this.FUNCSTATUS_PATH + (!su ? '' : `?su=${su}`);
        return this.http.request('Post', bizContextUrl, FrmUtil.setHeader(null, { body: enterParam }))
            .pipe(map((/**
         * @param {?} v
         * @return {?}
         */
        (v) => {
            return v.token || v.sessionId;
        })));
    }
    /**
     * 退出功能，如果存在bizContext，则移除
     * @private
     * @param {?} options
     * @param {?} su
     * @return {?}
     */
    quitFunc(options, su) {
        /** @type {?} */
        const body = {
            token: options.token,
            tabId: options.tabId,
            funcId: options.funcId,
            action: 'quit'
        };
        /** @type {?} */
        const bizContextUrl = this.FUNCSTATUS_PATH + (!su ? '' : `?su=${su}`);
        return this.http.request('Post', bizContextUrl, FrmUtil.setHeader(null, { body }));
    }
    /**
     * 获取当前应用所属su
     * @private
     * @param {?} url
     * @return {?}
     */
    getSu(url) {
        /** @type {?} */
        const uriArr = url.split('/');
        return uriArr.length > 3 ? uriArr[3] : '';
    }
    /**
     * iframe url拼接 querystring 参数
     * @private
     * @param {?} routurl
     * @param {?} funcId
     * @param {?} params
     * @return {?}
     */
    buildQueryString(routurl, funcId, params) {
        if (routurl.indexOf('?') < 0) {
            routurl += `?funcId=${funcId}`;
        }
        else {
            routurl += `&funcId=${funcId}`;
        }
        if (params) {
            Object.keys(params).forEach((/**
             * @param {?} propName
             * @param {?} index
             * @return {?}
             */
            (propName, index) => {
                routurl += `${index === 0 ? '' : '&'}${propName}=${params[propName]}`;
            }));
        }
        return routurl;
    }
    /**
     * url 拼接map格式的参数
     * @private
     * @param {?} routurl
     * @param {?} funcId
     * @param {?} tabId
     * @param {?} token
     * @param {?} params
     * @return {?}
     */
    buildQueryStringByMap(routurl, funcId, tabId, token, params) {
        if (routurl.indexOf('?') < 0) {
            routurl += `?funcId=${funcId}`;
        }
        else {
            routurl += `&funcId=${funcId}`;
        }
        routurl += `&appType=${AppType.Menu}`;
        routurl += `&tabId=${this.getPageId(funcId, tabId)}`;
        routurl += !token ? '' : `&cvft=${token}`;
        if (params) {
            params.forEach((/**
             * @param {?} value
             * @param {?} key
             * @return {?}
             */
            (value, key) => {
                routurl += !key ? '' : `&${key}=${value}`;
            }));
        }
        return routurl;
    }
    /**
     * 获取当前菜单页面的唯一标识
     * @private
     * @param {?} funcId
     * @param {?} tabId
     * @return {?}
     */
    getPageId(funcId, tabId) {
        return tabId || funcId;
    }
    /**
     * 页面第一次被打开时，生成唯一标识
     * @private
     * @param {?} funcId
     * @param {?} tabId
     * @return {?}
     */
    newPageId(funcId, tabId) {
        return tabId ? `${funcId}_${tabId}` : funcId;
    }
    /**
     * @param {?} token
     * @param {?} args
     * @return {?}
     */
    eventFire(token, args) {
        /** @type {?} */
        const feb = EventUtil.getFrmEvent();
        if (!feb || typeof feb.post !== 'function') {
            return;
        }
        feb.post(token, args);
    }
    /**
     * @param {?} token
     * @param {?} handler
     * @param {?=} options
     * @return {?}
     */
    eventListner(token, handler, options) {
        /** @type {?} */
        const feb = EventUtil.getFrmEvent();
        if (!feb || typeof feb.on !== 'function') {
            return;
        }
        // 菜单监听者必须要声明自己的身份，方便框架管理
        if (options && options.appType) {
            switch (options.appType.toLowerCase()) {
                case AppType.App:
                    /** @type {?} */
                    const appObkey = EventUtil.appObsToken(options.appId, options.appEntrance, options.tabId);
                    feb.onWithObkey(token, appObkey, handler);
                    return;
                case AppType.Menu:
                    /** @type {?} */
                    const funcObkey = EventUtil.funcObsToken(options.funcId, options.tabId);
                    feb.onWithObkey(token, funcObkey, handler);
                    return;
                default: break;
            }
        }
        feb.on(token, handler);
    }
    /**
     * 创建监听订阅, 维护一个监听者列表，针对菜单触发事件
     * @param {?} token
     * @param {?} funcId
     * @param {?} handler
     * @return {?}
     */
    eventListner4Func(token, funcId, handler) {
        /** @type {?} */
        const feb = EventUtil.getFrmEvent();
        if (!feb || typeof feb.on !== 'function') {
            return;
        }
        feb.onWithObkey(token, funcId, handler);
    }
    /**
     * 创建监听订阅, 维护一个监听者列表，针对应用触发事件
     * @param {?} token
     * @param {?} appId
     * @param {?} appEntrance
     * @param {?} handler
     * @return {?}
     */
    eventListner4App(token, appId, appEntrance, handler) {
        /** @type {?} */
        const feb = EventUtil.getFrmEvent();
        if (!feb || typeof feb.on !== 'function') {
            return;
        }
        /** @type {?} */
        const appObkey = EventUtil.appObsToken(appId, appEntrance);
        feb.onWithObkey(token, appObkey, handler);
    }
}
FrameworkService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrameworkService.ctorParameters = () => [
    { type: HttpService },
    { type: Router },
    { type: CacheService },
    { type: SessionService },
    { type: FrmEventBus },
    { type: FuncsService },
    { type: LoadingService },
    { type: AppService, decorators: [{ type: Optional }] },
    { type: FrmI18nSettingService, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FrameworkEventService {
    /**
     * @param {?} feb
     */
    constructor(feb) {
        this.feb = feb;
        this.FarrisApps = EventUtil.FARRIS_APPS;
        this.FarrisAppClick = EventUtil.FARRIS_APP_CLICK;
        this.AllGspFuncs = EventUtil.ALL_GSP_FUNCS;
        this.BeforeFuncClose = EventUtil.BEFORE_FUNC_CLOSE;
        this.FuncClosed = EventUtil.FUNC_CLOSED;
        this.FuncSwitch = EventUtil.FUNC_SWITCH;
        this.AfterFrameLoad = EventUtil.AFTER_FRAME_LOAD;
        /** @type {?} */
        const eventBusEntity = EventUtil.getFrmEvent();
        if (!eventBusEntity) {
            EventUtil.setFrmEvent(this.feb || new FrmEventBus());
            this.eventInitial();
        }
    }
    /**
     * @param {?} token
     * @param {?} args
     * @return {?}
     */
    eventFire(token, args) {
        /** @type {?} */
        const feb = EventUtil.getFrmEvent();
        if (!feb || typeof feb.post !== 'function') {
            return;
        }
        feb.post(token, args);
    }
    /**
     * @param {?} token
     * @param {?} handler
     * @param {?=} options
     * @return {?}
     */
    eventListner(token, handler, options) {
        /** @type {?} */
        const feb = EventUtil.getFrmEvent();
        if (!feb || typeof feb.on !== 'function') {
            return;
        }
        // 菜单监听者必须要声明自己的身份，方便框架管理
        if (options && options.appType) {
            switch (options.appType.toLowerCase()) {
                case AppType.App:
                    /** @type {?} */
                    const appObkey = EventUtil.appObsToken(options.appId, options.appEntrance, options.tabId);
                    feb.onWithObkey(token, appObkey, handler);
                    return;
                case AppType.Menu:
                    /** @type {?} */
                    const funcObkey = EventUtil.funcObsToken(options.funcId, options.tabId);
                    feb.onWithObkey(token, funcObkey, handler);
                    return;
                default: break;
            }
        }
        feb.on(token, handler);
    }
    /**
     * @private
     * @return {?}
     */
    eventInitial() {
        /** @type {?} */
        const feb = EventUtil.getFrmEvent();
        if (!feb || typeof feb.post !== 'function') {
            return;
        }
        feb.post(this.FarrisApps, null);
        feb.post(this.FarrisAppClick, null);
        feb.post(this.AllGspFuncs, null);
        feb.initialPipe(this.FuncClosed, new Subject());
        feb.initialPipe(this.FuncSwitch, new Subject());
        feb.initialPipe(this.BeforeFuncClose, new Subject());
        feb.initialPipe(this.AfterFrameLoad, new Subject());
    }
}
FrameworkEventService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FrameworkEventService.ctorParameters = () => [
    { type: FrmEventBus }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BroadcastingStationService {
    constructor() {
        this.frmSubject = 'frmBroadcast-subjects';
        this.frmVariableService = new FrameworkVariableService();
        this.subjectMaps = this.frmVariableService.getFrmVariableByKey(this.frmSubject) || new Map();
    }
    /**
     * 注册主题，并获取当前主题唯一标识token
     * @param {?} subjectCode 主题编码，建议有明确含义，方便确认当前主题的职责
     * code不是唯一标识，即使相同code每次注册都会生成一个新的主题，返回值token是唯一标识
     * @param {?} options 主题注册操作，可以直接对于菜单 或 应用注册主题
     * @param {?=} customSub 自定义主题，如果为null或者不传，默认为Subject
     * @return {?}
     */
    subjectRegister(subjectCode, options, customSub) {
        if (!customSub) {
            customSub = new Subject();
        }
        /** @type {?} */
        let token;
        if (options && options.funcId) {
            token = options.funcId;
        }
        else if (options && options.appId && options.appEntrance) {
            token = `${options.appId}-${options.appEntrance}`;
        }
        else {
            token = this.createToken();
        }
        /** @type {?} */
        const pipe = new EventBusPipe(token, null, customSub);
        pipe.pipeCode = subjectCode;
        this.subjectMaps.set(token, pipe);
        this.frmVariableService.frameworkVariableReg(this.frmSubject, this.subjectMaps);
        return token;
    }
    /**
     * 注册主题，可直接获取主题实体，
     * 框架不托管维护，常用于适配层上事件扩展机制
     * @param {?} options 注册参数
     * @param {?=} customSub 是否自定义主题
     * @return {?}
     */
    customSubjectRegister(options, customSub) {
        /** @type {?} */
        const subMap = new Map();
        if (!customSub) {
            customSub = new Subject();
        }
        /** @type {?} */
        let token;
        if (options && options.customToken) {
            token = options.customToken;
        }
        else if (options && options.funcId) {
            token = options.funcId;
        }
        else if (options && options.appId && options.appEntrance) {
            token = `${options.appId}-${options.appEntrance}`;
        }
        else {
            token = this.createToken();
        }
        /** @type {?} */
        const pipe = new EventBusPipe(token, null, customSub);
        subMap.set(token, pipe);
        return subMap;
    }
    /**
     * 删除主题
     * @param {?} subjectToken 主题唯一标识
     * @return {?}
     */
    subjectRemove(subjectToken) {
        this.subjectMaps.delete(subjectToken);
        this.frmVariableService.frameworkVariableReg(this.frmSubject, this.subjectMaps);
    }
    /**
     * 通过某个主题发送消息
     * @param {?} subjectToken 主题唯一的token标识
     * @param {?} info 要发送的消息
     * @return {?}
     */
    notify(subjectToken, info) {
        /** @type {?} */
        const sub = this.getSubject(subjectToken);
        if (!sub) {
            return;
        }
        sub.post(info);
    }
    /**
     * 为主题添加观察者，并监听主题消息
     * @param {?} subjectToken 主题token
     * @param {?} observerToken 当前监听主题的观察者唯一标识token
     * @param {?} handler 观察者监听到主题消息时要执行的动作
     * @return {?}
     */
    response(subjectToken, observerToken, handler) {
        /** @type {?} */
        const sub = this.getSubject(subjectToken);
        if (!sub) {
            return;
        }
        sub.subscribeWithObkey(observerToken, handler);
    }
    /**
     * 观察者取消对主题的订阅
     * @param {?} subjectToken 主题唯一标识
     * @param {?} observerToken 观察者唯一标识
     * @return {?}
     */
    responseUnSubscribe(subjectToken, observerToken) {
        /** @type {?} */
        const sub = this.getSubject(subjectToken);
        if (!sub) {
            return;
        }
        sub.unSubscribeWithObkey(observerToken);
    }
    /**
     * @private
     * @param {?} subjectToken
     * @return {?}
     */
    getSubject(subjectToken) {
        return this.subjectMaps.get(subjectToken);
    }
    /**
     * 创建唯一token
     * @private
     * @return {?}
     */
    createToken() {
        // tslint:disable-next-line: only-arrow-functions
        /** @type {?} */
        const S4 = (/**
         * @return {?}
         */
        function () {
            // tslint:disable-next-line:no-bitwise
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        });
        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());
    }
}
BroadcastingStationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BroadcastingStationService.ctorParameters = () => [];
/** @nocollapse */ BroadcastingStationService.ngInjectableDef = defineInjectable({ factory: function BroadcastingStationService_Factory() { return new BroadcastingStationService(); }, token: BroadcastingStationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FunctionResolver {
    /**
     * @param {?} router
     * @param {?} feb
     */
    constructor(router, feb) {
        this.router = router;
        this.feb = feb;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    resolve(route, state) {
        /** @type {?} */
        const id = route.paramMap.get('funcid');
        this.editvalue = null;
        this.feb.on('frmopenfunc', (/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this.editvalue = value;
        }));
        return of(this.editvalue);
    }
}
FunctionResolver.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FunctionResolver.ctorParameters = () => [
    { type: Router },
    { type: FrmEventBus }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// export function loadingFactory(app: ApplicationRef, cfr: ComponentFactoryResolver, injector: Injector) {
//     return new LoadingService(app, cfr, injector);
// }
class LoadingModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        // const _config = config ? Object.assign({}, loaddingDefaultConfig, config) : loaddingDefaultConfig;
        return {
            ngModule: LoadingModule,
            providers: [
                { provide: LOADING_DEFAULT_CONFIG, useValue: config || loaddingDefaultConfig },
                LoadingService
                // { provide: LoadingService, useFactory: loadingFactory, deps: [ApplicationRef, ComponentFactoryResolver, Injector] }
            ]
        };
    }
}
LoadingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    LoadingComponent
                ],
                entryComponents: [
                    LoadingComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { CommonSharedModule, FuncsService, FrameworkService, AppService, FrameworkEventService, FrameworkVariableService, BroadcastingStationService, FrmI18nSettingService, FunctionResolver, EventBusPipe, FrmEventBus, LoadingModule, LoadingService, AppType, IframeLink, LoadingComponent as ɵa, LOADING_DEFAULT_CONFIG as ɵc, loaddingDefaultConfig as ɵb };

//# sourceMappingURL=gsp-sys-rtf-common.js.map